METHOD lh
METHOD_RETURN lb
PARAM lb lc[]
PARAM lb ld
<operator>.notEquals lc[la]!=-1
<operator>.postIncrement la++
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.minus -1
>>>PDG&9 0->2 0->3 0->5 0->6 0->7 0->8 2->1 2->4 3->1 4->1 4->1 4->1 5->1 5->1 8->4
>>>Token lb lh ( lb lc [ ] , lb ld ) { lb la ; lg ( la = 0  ; lc [ la ] != -1 ; la ++ ) { lf ( lc [ la ] == ld )  { le1 ; } } le 0 ; }
>>>Func
METHOD lv
METHOD_RETURN ll
lm lm("\x25\x64",&lg)
<operator>.lessThan lb<lg
<operator>.postIncrement lb++
lm lm("\x25\x64",&le)
<operator>.lessThan lb<le
<operator>.postIncrement lb++
lu lu(lc 0 ls(lc))
<operator>.lessThan la<lg
<operator>.postIncrement la++
<operator>.lessThan lb<le
<operator>.postIncrement lb++
<operator>.assignment lh=le+1
<operator>.lessThan la<lg
<operator>.postIncrement la++
ls ls(lc)
<operator>.addition le+1
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->1 2->1 2->3 2->9 2->14 3->1 3->4 3->9 4->6 5->1 5->1 5->6 5->11 5->13 5->17 6->7 6->11 7->11 8->1 8->1 8->1 9->10 9->14 10->14 11->1 11->12 11->13 11->17 12->1 12->1 13->1 13->1 13->1 14->1 14->1 14->15 15->1 15->1 16->8 17->1
>>>Token ll lv ( ) { ll lh ; lx lr ; ll lb , la , ld ; lm ( " \x25 \x64 " , & lg ) ; lf ( lb = 0  ; lb < lg ; lb ++ ) { lw [ lb ] = lp ( ) ; } lm ( " \x25 \x64 " , & le ) ; lf ( lb = 0  ; lb < le ; lb ++ ) { ln [ lb ] = lp ( ) ; lk [ lb ] = lq ( & ln [ lb ] ) ; } lu ( lc , 0 , ls ( lc ) ) ; lf ( la = 0  ; la < lg ; la ++ ) lc [ 0 ] [ la ] = 0 ; lf ( lb = 1  ; lb < le ; lb ++ ) { lf ( la = 0  ; la < lg ; la ++ ) { li ( lk [ lb - 1 ] == la )  { lc [ lb ] [ la ] = le + 1 ; lf ( ld = 0  ; ld < lg ; ld ++ ) li ( ld != la ) { lc [ lb ] [ la ] = lj ( lc [ lb ] [ la ] , lc [ lb - 1 ] [ ld ] + 1 ) ; } } lo { lc [ lb ] [ la ] = lc [ lb - 1 ] [ la ] ; lf ( ld = 0  ; ld < lg ; ld ++ ) li ( ld != la ) { lc [ lb ] [ la ] = lj ( lc [ lb ] [ la ] , lc [ lb - 1 ] [ ld ] + 1 ) ; } } } } lh = le + 1 ; lf ( la = 0  ; la < lg ; la ++ ) { li ( la == lk [ le - 1 ] ) lh = lj ( lh , lc [ le - 1 ] [ la ] + 1 ) ; lo lh = lj ( lh , lc [ le - 1 ] [ la ] ) ; } lt lh ; }
>>>Func
METHOD ln
METHOD_RETURN ld
PARAM ld li[]
PARAM ld lg
PARAM ld lh
<operator>.assignment lb=0
<operator>.assignment la=1
<operator>.assignment lc=lb+la
lm lm(lc<lh)
BLOCK <empty> <empty>
<operator>.assignment le=-1
lm lm(lc>1)
BLOCK <empty> <empty>
lj lj(la&&li[le+1]==lg)
<operator>.plus +1
<operator>.subtraction lk-1
<operator>.assignment lb=la
<operator>.assignment la=lc
<operator>.assignment lc=lb+la
<operator>.assignment lf=((le+lb)<(lh-1))?(le+lb):(lh-1)
lj lj(li[lf]<lg)
BLOCK <empty> <empty>
IDENTIFIER ll <empty>
lj lj(li[lf]>lg)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
<operator>.addition lb+la
<operator>.lessThan lc<lh
<operator>.minus -1
<operator>.greaterThan lc>1
<operator>.assignment lc=la
<operator>.assignment la=lb
<operator>.assignment lb=lc-la
<operator>.assignment le=lf
<operator>.assignment lc=lb
<operator>.assignment la=la-lb
<operator>.assignment lb=lc-la
<operator>.logicalAnd la&&li[le+1]==lg
<operator>.addition lb+la
<operator>.conditional ((le+lb)<(lh-1))?(le+lb):(lh-1)
<operator>.lessThan li[lf]<lg
<operator>.greaterThan li[lf]>lg
<operator>.equals li[le+1]==lg
<operator>.lessThan (le+lb)<(lh-1)
<operator>.addition le+lb
<operator>.subtraction lh-1
<operator>.subtraction lc-la
<operator>.subtraction la-lb
<operator>.subtraction lc-la
<operator>.addition le+lb
<operator>.subtraction lh-1
<operator>.addition le+1
>>>PDG&52 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->34 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 2->1 2->40 2->41 2->42 3->40 4->27 5->1 5->7 5->26 6->1 6->7 6->16 6->26 7->27 8->1 8->1 10->1 10->1 10->19 10->39 10->43 10->44 10->49 11->1 11->1 13->1 13->1 14->1 15->1 15->1 16->1 16->18 16->19 16->31 16->38 16->39 16->43 16->44 16->49 17->1 17->18 17->30 17->38 18->1 18->1 18->29 19->1 19->1 19->33 20->1 20->1 23->1 23->1 27->8 27->8 27->17 27->50 28->10 29->11 29->11 30->1 30->46 31->1 31->46 32->34 32->47 33->1 33->1 33->1 33->51 34->1 34->48 35->1 35->1 35->48 36->1 36->1 36->1 37->1 37->1 37->13 37->13 39->1 39->1 39->1 40->20 40->20 40->41 40->41 41->1 41->1 41->23 41->23 41->42 42->1 42->1 42->37 42->37 43->19 43->19 43->39 43->39 43->44 43->45 45->1 45->19 45->19 45->39 45->39 46->32 46->32 46->47 47->35 47->35 48->1 48->36 48->36 48->37 50->1 50->43 50->43 50->45 51->1
>>>Token ld ln ( ld li [ ] , ld lg , ld lh ) { ld lb = 0 ; ld la = 1 ; ld lc = lb + la ; lm ( lc < lh )  { lb = la ; la = lc ; lc = lb + la ; } ld le = -1 ; lm ( lc > 1 )  { ld lf = ( ( le + lb ) < ( lh - 1 ) ) ? ( le + lb ) : ( lh - 1 ) ; lj ( li [ lf ] < lg )  { lc = la ; la = lb ; lb = lc - la ; le = lf ; } ll lj ( li [ lf ] > lg ) { lc = lb ; la = la - lb ; lb = lc - la ; } ll lk lf ; } lj ( la && li [ le + 1 ] == lg ) lk le + 1 ; lk - 1 ; }
>>>Func
METHOD ll
METHOD_RETURN lk
<operator>.assignment lj[]={}
lb lb(la(lj,0,10)==-1)
<operator>.assignment ld[]={1 2 3}
lb lb(la(ld,3,10)==-1)
<operator>.assignment ln[]={1}
lb lb(la(ld,1,1)==0)
<operator>.assignment li[]={1 2}
lb lb(la(li,2,1)==0)
<operator>.assignment le[]={1 2}
lb lb(la(le,2,2)==1)
<operator>.assignment lg[]={-1 2 4 6 8}
lb lb(la(lg,5,-1)==0)
<operator>.assignment lh[]={-1 2 4 6 8}
lb lb(la(lh,5,8)==4)
<operator>.assignment lf[]={-1 2 4 6 8}
lb lb(la(lf,5,6)==3)
<operator>.equals la(lj,0,10)==-1
<operator>.arrayInitializer {1 2 3}
<operator>.equals la(ld,3,10)==-1
<operator>.arrayInitializer {1}
<operator>.equals la(ld,1,1)==0
<operator>.arrayInitializer {1 2}
<operator>.equals la(li,2,1)==0
<operator>.arrayInitializer {1 2}
<operator>.equals la(le,2,2)==1
<operator>.arrayInitializer {-1 2 4 6 8}
<operator>.equals la(lg,5,-1)==0
<operator>.arrayInitializer {-1 2 4 6 8}
<operator>.equals la(lh,5,8)==4
<operator>.arrayInitializer {-1 2 4 6 8}
<operator>.equals la(lf,5,6)==3
la la(lj,0,10)
<operator>.minus -1
la la(ld,3,10)
<operator>.minus -1
la la(ld,1,1)
la la(li,2,1)
la la(le,2,2)
<operator>.minus -1
la la(lg,5,-1)
<operator>.minus -1
la la(lh,5,8)
<operator>.minus -1
la la(lf,5,6)
<operator>.minus -1
>>>PDG&47 0->2 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 2->1 2->1 2->33 3->1 3->1 4->1 4->1 4->35 5->1 5->1 6->1 6->1 6->1 7->1 7->1 8->1 8->38 9->1 9->1 10->1 10->1 10->39 11->1 11->1 12->1 12->41 13->1 13->1 14->1 14->43 15->1 15->1 16->1 16->1 16->45 17->1 17->1 18->1 18->3 18->3 19->4 19->4 19->4 20->1 20->5 20->5 21->6 22->1 22->7 22->7 23->8 23->8 24->1 24->9 24->9 25->10 25->10 26->1 26->11 26->11 27->12 27->12 27->12 27->12 27->12 28->1 28->13 28->13 29->14 29->14 29->14 29->14 29->14 30->1 30->15 30->15 31->1 31->16 31->16 31->16 31->16 31->16 32->1 32->17 32->17 33->1 33->18 33->18 33->18 34->18 35->20 35->20 35->20 35->37 36->20 37->1 37->22 37->22 38->1 38->24 38->24 38->24 39->1 39->26 39->26 40->27 41->1 41->28 41->28 41->28 42->29 43->1 43->30 43->30 43->30 44->31 45->1 45->32 45->32 45->32 46->41
>>>Token lm lk ll ( ) { lc lj [ ] = { } ; lb ( la ( lj , 0 , 10 ) == -1 ) ; lc ld [ ] = { 1 , 2 , 3 } ; lb ( la ( ld , 3 , 10 ) == -1 ) ; lc ln [ ] = { 1 } ; lb ( la ( ld , 1 , 1 ) == 0 ) ; lc li [ ] = { 1 , 2 } ; lb ( la ( li , 2 , 1 ) == 0 ) ; lc le [ ] = { 1 , 2 } ; lb ( la ( le , 2 , 2 ) == 1 ) ; lc lg [ ] = { -1 , 2 , 4 , 6 , 8 } ; lb ( la ( lg , 5 , -1 ) == 0 ) ; lc lh [ ] = { -1 , 2 , 4 , 6 , 8 } ; lb ( la ( lh , 5 , 8 ) == 4 ) ; lc lf [ ] = { -1 , 2 , 4 , 6 , 8 } ; lb ( la ( lf , 5 , 6 ) == 3 ) ; }
>>>Func
METHOD ls
METHOD_RETURN lo
PARAM lo lg
PARAM lf*lp[]
le le(lg<2)
IDENTIFIER ln <empty>
LITERAL 1 <empty>
<operator>.assignment *lm=lp[1]
<operator>.assignment lb=li("\x70""\x72\x6f\x67\x72\x61\x6d\x2e\x74\x78\x74","\x77")
le le(lb==lh)
BLOCK <empty> <empty>
lt lt((lv)ly(&lk))
lq lq(lb,"\x25""\x73",lm)
ll ll(lb)
<operator>.assignment la=li("\x70\x72\x6f\x67\x72\x61\x6d\x2e\x74\x78\x74","\x72")
le le(la==lh)
BLOCK <empty> <empty>
lw lw((ld=lu(la))!=lx)
BLOCK <empty> <empty>
lc lc("\n")
ll ll(la)
IDENTIFIER ln <empty>
LITERAL 0 <empty>
lc lc("""\x45\x72\x72\x6f\x72\x21")
lj lj(1)
lc lc("\x45\x72\x72\x6f\x72\x21")
lj lj(1)
lc lc("\x25\x63",ld)
<operator>.lessThan lg<2
li li("\x70""\x72\x6f\x67\x72\x61\x6d\x2e\x74\x78\x74","\x77")
<operator>.equals lb==lh
<operator>.cast (lv)ly(&lk)
li li("\x70\x72\x6f\x67\x72\x61\x6d\x2e\x74\x78\x74","\x72")
<operator>.equals la==lh
<operator>.notEquals (ld=lu(la))!=lx
ly ly(&lk)
<operator>.assignment ld=lu(la)
lu lu(la)
>>>PDG&38 0->2 0->3 0->5 0->6 0->10 0->12 0->13 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->34 0->35 0->37 2->28 3->1 3->7 4->1 4->1 7->1 7->1 7->12 8->1 8->1 8->30 9->1 9->1 11->1 11->1 12->1 12->1 12->13 13->1 13->1 14->1 14->1 14->33 15->1 15->1 17->1 17->1 19->1 20->1 20->1 23->1 25->1 26->1 27->1 27->1 28->1 28->4 28->4 29->8 29->8 30->9 30->9 30->12 30->33 31->1 32->14 32->14 33->1 33->15 33->15 33->37 34->1 34->1 34->17 34->17 35->1 35->11 35->31 36->1 36->27 36->34 37->20 37->34 37->36
>>>Token lo ls ( lo lg , lf * lp [ ] ) { le ( lg < 2 ) ln 1 ; lf * lm = lp [ 1 ] ; lr * la , * lb ; lb = li ( " \x70 " " \x72 \x6f \x67 \x72 \x61 \x6d \x2e \x74 \x78 \x74 " , " \x77 " ) ; le ( lb == lh )  { lc ( " " " \x45 \x72 \x72 \x6f \x72 \x21 " ) ; lj ( 1 ) ; } lz lk ; lt ( ( lv ) ly ( & lk ) ) ; lq ( lb , " \x25 " " \x73 " , lm ) ; ll ( lb ) ; la = li ( " \x70 \x72 \x6f \x67 \x72 \x61 \x6d \x2e \x74 \x78 \x74 " , " \x72 " ) ; le ( la == lh )  { lc ( " \x45 \x72 \x72 \x6f \x72 \x21 " ) ; lj ( 1 ) ; } lf ld ; lw ( ( ld = lu ( la ) ) != lx )  { lc ( " \x25 \x63 " , ld ) ; } lc ( " \n " ) ; ll ( la ) ; ln 0 ; }
>>>Func
METHOD lj
METHOD_RETURN ll
PARAM la lg
PARAM la ld
<operator>.expressionList lo<la>lc lb
lf lf(lg,"\x20",lc)
lf lf(ld,"\x20",lb)
ln ln(lc[0].li(lb[0])==-1)
IDENTIFIER lh <empty>
<operator>.greaterThan lo<la>lc
<operator>.equals lc[0].li(lb[0])==-1
<operator>.lessThan lo<la
li lc[0].li(lb[0])
<operator>.minus -1
>>>PDG&14 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->11 0->13 2->5 3->6 4->1 4->1 4->6 5->1 5->1 5->1 6->1 6->1 6->1 6->12 7->1 7->1 9->1 9->4 9->4 9->5 10->1 10->1 10->7 10->7 11->1 11->1 11->9 11->9 12->1 12->1 12->10 12->10 13->10
>>>Token ll lj ( la lg , la ld ) { lo < la > lc , lb ; lf ( lg , " \x20 " , lc ) ; lf ( ld , " \x20 " , lb ) ; ln ( lc [ 0 ] . li ( lb [ 0 ] ) == -1 )  le lk ; lm le lh ; }
>>>Func
METHOD lt
METHOD_RETURN lw
lc lc(lb)
lk lk(lb,"\x25\x64",&lp)
<operator>.lessEqualsThan le<=lp
<operator>.postIncrement le++
IDENTIFIER lz <empty>
LITERAL 0 <empty>
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 2->3 3->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token lw lt ( ) { lc ( lb ) ; lk ( lb , " \x25 \x64 " , & lp ) ; ld ( le = 1  ; le <= lp ; le ++ ) { lc ( lb ) ; lk ( lb , " \x25 \x64 " , & ln ) ; ld ( la = 0  ; la < ln ; la ++ ) lc ( ly [ la ] ) ; lc ( lb ) ; lk ( lb , " \x25 " " \x64 " , & lf ) ; ld ( la = 0  ; la < lf ; la ++ ) lc ( lq [ la ] ) ; lm = 0 ; li = 0 ; lu ( 1 )  { lr ( lg , 0 , lx ( lg ) ) ; ll = ln ; ld ( la = lm  ; la < lf ; la ++ ) { lh = ls ( lq [ la ] ) ; lj ( ! lg [ lh ] )  { lg [ lh ] = 1 ; ll -- ; } lj ( ll == 0 ) lo ; } lj ( la == lf ) lo ; li ++ ; lm = la ; } lv ( " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , le , li ) ; } lz 0 ; }
>>>Func
METHOD lh
METHOD_RETURN la
PARAM la lb
PARAM ld*lc[]
le le(2!=lb)
BLOCK <empty> <empty>
lf lf(lc[1])
lg lg("\x50\x72\x6f\x67\x72\x61\x6d\x20""\x65\x78\x70\x65\x63\x74\x73\x20\x69\x6e\x70\x75\x74\x20\x66\x69\x6c""\x65\x20\x61\x73\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x2e\n")
IDENTIFIER lj <empty>
LITERAL 0 <empty>
<operator>.notEquals 2!=lb
>>>PDG&11 0->2 0->3 0->5 0->7 0->8 0->9 0->10 2->10 3->1 3->6 4->1 4->1 6->1 6->1 7->1 10->1 10->4 10->4
>>>Token la lh ( la lb , ld * lc [ ] ) { le ( 2 != lb ) { lg ( " \x50 \x72 \x6f \x67 \x72 \x61 \x6d \x20 " " \x65 \x78 \x70 \x65 \x63 \x74 \x73 \x20 \x69 \x6e \x70 \x75 \x74 \x20 \x66 \x69 \x6c " " \x65 \x20 \x61 \x73 \x20 \x61 \x72 \x67 \x75 \x6d \x65 \x6e \x74 \x2e \n " ) ; lj 0 ; } la li ; lf ( lc [ 1 ] ) ; }
>>>Func
METHOD lm
METHOD_RETURN lc
PARAM lc lb
PARAM lk*lf
<operator>.lessThan la<lb
<operator>.postIncrement la++
IDENTIFIER lg <empty>
LITERAL 0 <empty>
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->4 3->1 4->1 4->1 4->5 5->1 5->1
>>>Token lc lm ( lc lb , lk * lf ) { lc la ; ln ( la = 0  ; la < lb ; la ++ ) { ld ( ! ll ( li [ la ] , lf ) )  { ld ( le [ la ] == 0 )  { ld ( ++ lj == lb ) lg 1 ; } le [ la ] = 1 ; lh ; } } lg 0 ; }
>>>Func
METHOD l18
METHOD_RETURN ll
PARAM ll l2
PARAM lr*lq[]
<operator>.assignment lj=l19
<operator>.assignment *l13="\x69\x6e""\x70\x75\x74\x2e\x74\x78\x74"
<operator>.assignment *lz=lu
<operator>.assignment *l11="\x6f\x75\x74\x70\x75""\x74\x2e\x74\x78\x74"
<operator>.assignment *lx=lu
<operator>.lessThan la<l2
<operator>.postIncrement la++
lc lc(lz==lu)
BLOCK <empty> <empty>
lc lc(lx==lu)
BLOCK <empty> <empty>
<operator>.assignment lk=l14(lz,"\x72")
lc lc(lk==lu)
BLOCK <empty> <empty>
<operator>.assignment l0=l14(lx,"\x77")
lc lc(lk==lu)
BLOCK <empty> <empty>
<operator>.assignment ly=l6(lk,"\x25""\x64",&l3)
lc lc(lj>=2)
BLOCK <empty> <empty>
<operator>.lessEqualsThan lt<=l3
<operator>.postIncrement lt++
l10 l10(lk)
l10 l10(l0)
IDENTIFIER l1 <empty>
LITERAL 0 <empty>
<operator>.assignment lz=l13
<operator>.assignment lx=l11
ld ld("\x45""\x72\x72\x6f\x72\x20\x6f\x70\x65\x6e\x69\x6e\x67\x20\x69\x6e\x70\x75""\x74\x20\x66\x69\x6c\x65\x2e\n")
IDENTIFIER l1 <empty>
LITERAL 0 <empty>
ld ld("\x45\x72\x72\x6f\x72\x20\x6f\x70\x65\x6e\x69\x6e\x67\x20\x6f\x75""\x74\x70\x75\x74\x20\x66\x69\x6c\x65\x2e\n")
IDENTIFIER l1 <empty>
LITERAL 0 <empty>
ld ld("\x20\x20\x4e\x75\x6d\x62\x65\x72\x20\x6f""\x66\x20\x74\x65\x73\x74\x20\x63\x61\x73\x65\x73\x3a\x20\x25\x64\n",l3)
<operator>.equals lz==lu
<operator>.equals lx==lu
l14 l14(lz,"\x72")
<operator>.equals lk==lu
l14 l14(lx,"\x77")
<operator>.equals lk==lu
l6 l6(lk,"\x25""\x64",&l3)
<operator>.greaterEqualsThan lj>=2
>>>PDG&47 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->14 0->17 0->20 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 2->9 3->1 4->1 4->1 4->46 5->1 5->30 6->1 6->39 7->1 7->31 8->1 8->40 9->1 9->1 9->10 10->1 10->1 11->1 11->1 13->1 13->1 15->1 15->1 15->42 18->1 18->1 18->27 19->1 19->1 21->1 21->1 21->1 22->1 22->1 24->1 24->1 24->25 25->1 25->1 26->1 26->1 27->1 27->1 30->1 30->1 30->41 31->1 31->1 31->43 32->1 35->1 38->1 38->24 39->11 39->11 39->40 40->13 40->13 40->42 41->1 41->15 41->15 42->16 42->16 42->44 42->44 43->1 43->18 43->18 44->1 44->19 44->19 44->45 45->1 45->21 45->21 45->21 45->24 45->26 45->38 46->1 46->22 46->22
>>>Token ll l18 ( ll l2 , lr * lq [ ] ) { ll la , ly ; l16 * lk , * l0 ; ll lj = l19 ; lr * l13 = " \x69 \x6e " " \x70 \x75 \x74 \x2e \x74 \x78 \x74 " ; lr * lz = lu ; lr * l11 = " \x6f \x75 \x74 \x70 \x75 " " \x74 \x2e \x74 \x78 \x74 " ; lr * lx = lu ; ll l3 , lt ; ll lf , lg [ 200 ] [ 200 ] ; ls l8 [ 200 ] , ln [ 200 ] [ 200 ] , l17 [ 200 ] [ 200 ] , lm [ 200 ] , lv [ 200 ] ; ll lb ; lr lw ; ll li , lh , l7 [ 200 ] , l4 [ 200 ] , lp [ 200 ] ; ls l5 [ 200 ] ; le ( la = 1  ; la < l2 ; la ++ ) { lc ( l9 ( lq [ la ] , " " " \x2d \x69 " ) == 0 && la + 1 < l2 )  { lz = lq [ ++ la ] ; } lo lc ( l9 ( lq [ la ] , " x 2 d x 6f " ) == 0 && la + 1 < l2 )  { lx = lq [ ++ la ] ; } lo lc ( l9 ( lq [ la ] , " x 2 d x 76 " ) == 0 ) { lj = l15 ( lq [ ++ la ] ) ; } lo { ld ( " \x45 \x72 \x72 \x6f \x72 \x20 \x70 \x61 \x72 \x73 \x69 \x6e \x67 \x20 " " \x61 \x72 \x67 \x75 \x6d \x65 \x6e \x74 \x73 \x21 \n " ) ; ld ( " \x55 \x73 \x61 \x67 " " \x65 \x3a \x20 \x74 \x65 \x6d \x70 \x6c \x61 \x74 \x65 \x2e \x62 \x69 \x6e \x20 \x2d " " \x69 \x20 \x3c \x69 \x6e \x70 \x75 \x74 \x5f \x66 \x69 \x6c \x65 \x5f \x6e \x61 \x6d " " \x65 \x3e \x20 \x2d \x6f \x20 \x3c \x6f \x75 \x74 \x70 \x75 \x74 \x5f \x66 \x69 \x6c " " \x65 \x5f \x6e \x61 \x6d \x65 \x3e " ) ; ld ( " \x20 \x20 \x2d \x76 \x20 \x3c \x76 \x65 " " \x72 \x62 \x6f \x73 \x65 \x5f \x6c \x65 \x76 \x65 \x6c \x3e \n " ) ; l1 0 ; } } lc ( lz == lu )  { lz = l13 ; } lc ( lx == lu )  { lx = l11 ; } lk = l14 ( lz , " \x72 " ) ; lc ( lk == lu )  { ld ( " \x45 " " \x72 \x72 \x6f \x72 \x20 \x6f \x70 \x65 \x6e \x69 \x6e \x67 \x20 \x69 \x6e \x70 \x75 " " \x74 \x20 \x66 \x69 \x6c \x65 \x2e \n " ) ; l1 0 ; } l0 = l14 ( lx , " \x77 " ) ; lc ( lk == lu )  { ld ( " \x45 \x72 \x72 \x6f \x72 \x20 \x6f \x70 \x65 \x6e \x69 \x6e \x67 \x20 \x6f \x75 " " \x74 \x70 \x75 \x74 \x20 \x66 \x69 \x6c \x65 \x2e \n " ) ; l1 0 ; } ly = l6 ( lk , " \x25 " " \x64 " , & l3 ) ; lc ( lj >= 2 )  { ld ( " \x20 \x20 \x4e \x75 \x6d \x62 \x65 \x72 \x20 \x6f " " \x66 \x20 \x74 \x65 \x73 \x74 \x20 \x63 \x61 \x73 \x65 \x73 \x3a \x20 \x25 \x64 \n " , l3 ) ; } le ( lt = 1  ; lt <= l3 ; lt ++ ) { lc ( lj >= 1 ) { ld ( " \x20 \x20 \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x64 \x3a \x20 " , lt ) ; } ly = l6 ( lk , " \x25 \x64 " , & lf ) ; le ( la = 0  ; la < lf ; la ++ ) { ly = l6 ( lk , " \x25 \x63 " , & lw ) ; le ( lb = 0  ; lb < lf ; lb ++ ) { ly = l6 ( lk , " \x25 \x63 " , & lw ) ; lc ( lw == ' ' )  { lg [ la ] [ lb ] = -1 ; } lo lc ( lw == ' 1 ' ) { lg [ la ] [ lb ] = 1 ; } lo lc ( lw == ' 0 ' ) { lg [ la ] [ lb ] = 0 ; } } } lc ( lj >= 3 )  { ld ( " \x20 \x20 \x20 \x20 \x69 \x6e \x70 \x75 " " \x74 \x3a \x20 \n " ) ; le ( la = 0  ; la < lf ; la ++ ) { le ( lb = 0  ; lb < lf ; lb ++ ) { ld ( " \t \x20 " " \x25 \x64 " , lg [ la ] [ lb ] ) ; } ld ( " \n " ) ; } } le ( la = 0  ; la < lf ; la ++ ) { li = 0 ; lh = 0 ; le ( lb = 0  ; lb < lf ; lb ++ ) { lc ( lg [ la ] [ lb ] == 1 )  { lh ++ ; li ++ ; } lo lc ( lg [ la ] [ lb ] = = 0 ) { lh ++ ; } } l8 [ la ] = ( ( ls ) li ) / lh ; l7 [ la ] = li ; l4 [ la ] = lh ; } lc ( lj >= 3 )  { ld ( " \x20 \x20 " " \x20 \x20 \x77 \x70 \x3a \x20 " ) ; le ( la = 0  ; la < lf ; la ++ ) { ld ( " \x20 \x25 \x30 \x2e " " \x33 \x66 " , l8 [ la ] ) ; } ld ( " \n " ) ; } le ( la = 0  ; la < lf ; la ++ ) { lp [ la ] = 0 ; lm [ la ] = 0 ; le ( lb = 0  ; lb < lf ; lb ++ ) { lc ( lg [ la ] [ lb ] == 1 )  { li = l7 [ lb ] ; lh = l4 [ lb ] - 1 ; lp [ la ] ++ ; ln [ la ] [ lb ] = ( ( ls ) li ) / lh ; lm [ la ] += ln [ la ] [ lb ] ; } lo lc ( lg [ la ] [ lb ] = = 0 ) { li = l7 [ lb ] - 1 ; lh = l4 [ lb ] - 1 ; lp [ la ] ++ ; ln [ la ] [ lb ] = ( ( ls ) li ) / lh ; lm [ la ] += ln [ la ] [ lb ] ; } } lm [ la ] /= lp [ la ] ; } lc ( lj >= 3 )  { ld ( " \x20 \x20 \x20 \x20 \x6f \x77 \x70 \x3a \x20 " " \n " ) ; le ( la = 0  ; la < lf ; la ++ ) { le ( lb = 0  ; lb < lf ; lb ++ ) { ld ( " \t \x20 \x25 \x30 \x2e " " \x33 \x66 " , ln [ la ] [ lb ] ) ; } ld ( " \x20 \x20 \x61 \x76 \x67 \x5f \x6f \x77 \x70 \x20 " " \x3d \x20 \x25 \x30 \x2e \x33 \x66 \x2c \x20 \x6e \x75 \x6d \x5f \x6f \x70 \x70 \x73 " " \x20 \x3d \x20 \x25 \x64 \n " , lm [ la ] , lp [ la ] ) ; } } le ( la = 0  ; la < lf ; la ++ ) { lv [ la ] = 0 ; le ( lb = 0  ; lb < lf ; lb ++ ) { lc ( ( lg [ la ] [ lb ] == 1 ) || ( lg [ la ] [ lb ] == 0 ) )  { ln [ la ] [ lb ] = ( ( ls ) li ) / lh ; lv [ la ] += lm [ lb ] ; } } lv [ la ] /= lp [ la ] ; } lc ( lj >= 1 )  { ld ( " \x61 \x76 " " \x67 \x5f \x6f \x6f \x77 \x70 \x3a \x20 " ) ; le ( la = 0  ; la < lf ; la ++ ) { ld ( " \x20 \x25 " " \x2e \x33 \x66 \x20 " , lv [ la ] ) ; } ld ( " \n " ) ; } le ( la = 0  ; la < lf ; la ++ ) { l5 [ la ] = 0.25 * l8 [ la ] + 0.5 * lm [ la ] + 0.25 * lv [ la ] ; } lc ( lj >= 1 )  { ld ( " \x72 \x70 \x69 \x3a \x20 " ) ; le ( la = 0  ; la < lf ; la ++ ) { ld ( " \x20 \x25 \x2e \x33 \x66 \x20 " , l5 [ la ] ) ; } ld ( " \n " ) ; } lc ( lj >= 1 )  { ld ( " \n " ) ; } l12 ( l0 , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \n " , lt ) ; le ( la = 0  ; la < lf ; la ++ ) { l12 ( l0 , " \x25 \x2e \x31 \x30 \x66 \n " , l5 [ la ] ) ; } } l10 ( lk ) ; l10 ( l0 ) ; l1 0 ; }
>>>Func
METHOD lf
METHOD_RETURN lg
PARAM li*lc
PARAM lg la
le le(la<2)
<operator>.assignment lb=lk(lc+la-2)
le le(lb>=0)
BLOCK <empty> <empty>
<operator>.assignment lb=lh(lc,la)
le le(lb>=0)
BLOCK <empty> <empty>
<operator>.assignment lc[la-2]=lj[lb][2]
<operator>.postDecrement la--
<operator>.assignment la=0
<operator>.lessThan la<2
lk lk(lc+la-2)
<operator>.greaterEqualsThan lb>=0
lh lh(lc,la)
<operator>.greaterEqualsThan lb>=0
<operator>.subtraction lc+la-2
<operator>.addition lc+la
<operator>.subtraction la-2
>>>PDG&22 0->2 0->3 0->7 0->10 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 2->17 2->19 2->20 3->14 4->1 4->1 5->1 5->1 5->16 8->1 8->1 8->18 9->1 9->1 11->1 11->1 11->1 11->17 12->1 12->17 13->1 13->1 14->4 14->4 14->19 14->20 14->21 15->1 15->5 16->6 16->6 17->1 17->8 17->8 18->1 18->9 18->9 19->1 19->15 19->15 21->12
>>>Token lg lf ( li * lc , lg la ) { lg lb ; le ( la < 2 )  ld la ; lb = lk ( lc + la - 2 ) ; le ( lb >= 0 )  { lc [ la - 2 ] = lj [ lb ] [ 2 ] ; la -- ; ld lf ( lc , la ) ; } lb = lh ( lc , la ) ; le ( lb >= 0 )  { la = 0 ; ld lf ( lc , la ) ; } ld la ; }
>>>Func
METHOD lw
METHOD_RETURN lc
lp lp("\x25\x69",&lq)
<operator>.lessEqualsThan lo<=lq
<operator>.postIncrement lo++
IDENTIFIER lx <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lc lw ( ) { lc lq ; lp ( " \x25 \x69 " , & lq ) ; le ( lc  lo = 1 ; lo <= lq ; lo ++ ) { lu ( lf , 0 , lr ( lf ) ) ; lu ( li , 0 , lr ( li ) ) ; lc ld ; lp ( " \x25 \x69 \n " , & ld ) ; le ( lc  la = 0 ; la < ld ; la ++ ) { le ( lc  lb = 0 ; lb < ld ; lb ++ ) { lz lk = ly ( ) ; lh ( lk == ' ' || lk == ' ' )  { lf [ la ] [ lb ] ++ ; lh ( lk == ' ' ) li [ la ] [ lb ] ++ ; } lv l0 ( lk == ' . ' ) ; } lp ( " \n " ) ; } le ( lc  la = 0 ; la < ld ; la ++ ) { ll [ la ] = ln [ la ] = 0 ; le ( lc  lb = 0 ; lb < ld ; lb ++ ) { lh ( lb != ld ) { ll [ la ] += li [ la ] [ lb ] ; ln [ la ] += lf [ la ] [ lb ] ; } } } le ( lc  la = 0 ; la < ld ; la ++ ) { lc lg = 0 ; lj [ la ] = 0 ; le ( lc  lb = 0 ; lb < ld ; lb ++ ) { lh ( la != lb && lf [ lb ] [ la ] )  { lg ++ ; lj [ la ] += ( lt ) ( ll [ lb ] - li [ lb ] [ la ] ) / ( ln [ lb ] - lf [ lb ] [ la ] ) ; } } lj [ la ] /= lg ; } le ( lc  la = 0 ; la < ld ; la ++ ) { lc lg = 0 ; lm [ la ] = 0 ; le ( lc  lb = 0 ; lb < ld ; lb ++ ) { lh ( la != lb && lf [ lb ] [ la ] )  { lg ++ ; lm [ la ] += lj [ lb ] ; } } lm [ la ] /= lg ; } ls ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x69 " " \x3a \n " , lo ) ; le ( lc  la = 0 ; la < ld ; la ++ ) { ls ( " \x25 \x2e \x36 \x6c \x66 \n " , 0.25 * ( ( lt ) ll [ la ] / ln [ la ] ) + 0.50 * lj [ la ] + 0.25 * lm [ la ] ) ; } } lx 0 ; }
>>>Func
METHOD lt
METHOD_RETURN ls
lg lg("\x25\x64",&lp)
<operator>.assignment lo=0
lu lu(lp--)
BLOCK <empty> <empty>
IDENTIFIER lv <empty>
LITERAL 0 <empty>
<operator>.postIncrement lo++
<operator>.assignment la=0
lg lg("\x25\x64",&ln)
lc lc(ln!=0)
lg lg("\x25\x73",li)
lg lg("\x25\x64",&ll)
lc lc(ll!=0)
lg lg("\x25\x73",lk)
lg lg("""\x25\x64",&lq)
lg lg("\x25\x73",lf)
<operator>.assignment ld[0]=lf[0]
<operator>.assignment la=1
<operator>.lessThan le<lq
<operator>.postIncrement le++
<operator>.assignment ld[la++]='\0'
lj lj("\x43\x61\x73\x65\x20""\x23\x25\x64\x3a\x20",lo)
lj lj("\x5b")
<operator>.lessThan lb<la-1
<operator>.postIncrement lb++
lj lj("\x5d")
lj lj("\n")
<operator>.postDecrement lp--
<operator>.notEquals ln!=0
<operator>.notEquals ll!=0
<operator>.subtraction la-1
<operator>.postIncrement la++
>>>PDG&34 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->15 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 2->1 2->1 2->29 3->1 3->8 4->1 4->1 8->1 8->23 9->1 10->1 10->1 10->30 11->1 11->1 12->1 12->1 13->1 13->1 13->31 14->1 14->1 15->1 15->1 16->1 16->1 16->20 17->1 17->1 17->18 18->1 18->1 18->1 19->1 19->33 20->1 20->1 20->21 21->1 21->1 22->1 22->1 23->1 23->1 24->1 25->1 25->1 25->26 26->1 26->1 27->1 28->1 29->1 29->4 30->1 30->11 30->11 31->1 31->14 31->14 32->1 32->25 32->25 33->32
>>>Token ls lt ( ) { ls ln , ll , lq , le , lb , la , lh , lo ; lw lf [ 100 ] , li [ 5 ] , lk [ 5 ] , ld [ 100 ] , lp ; lg ( " \x25 \x64 " , & lp ) ; lo = 0 ; lu ( lp -- )  { lo ++ ; la = 0 ; lg ( " \x25 \x64 " , & ln ) ; lc ( ln != 0 )  lg ( " \x25 \x73 " , li ) ; lg ( " \x25 \x64 " , & ll ) ; lc ( ll != 0 )  lg ( " \x25 \x73 " , lk ) ; lg ( " " " \x25 \x64 " , & lq ) ; lg ( " \x25 \x73 " , lf ) ; ld [ 0 ] = lf [ 0 ] ; la = 1 ; lm ( le = 1  ; le < lq ; le ++ ) { lc ( ln != 0 && la != 0 && ( ( ld [ la - 1 ] == li [ 0 ] && lf [ le ] == li [ 1 ] ) || ( ld [ la - 1 ] == li [ 1 ] && lf [ le ] == li [ 0 ] ) ) )  { ld [ la - 1 ] = li [ 2 ] ; } lr { lh = 0 ; lc ( ll != 0 && lf [ le ] == lk [ 0 ] )  { lm ( lb = 0  ; lb < la ; lb ++ ) { lc ( ld [ lb ] == lk [ 1 ] ) lh = 1 ; } lc ( lh == 1 ) la = 0 ; } lr lc ( ll != 0 && lf [ le ] = = lk [ 1 ] ) { lm ( lb = 0  ; lb < la ; lb ++ ) { lc ( ld [ lb ] == lk [ 0 ] ) lh = 1 ; } lc ( lh == 1 ) la = 0 ; } lc ( lh == 0 ) ld [ la ++ ] = lf [ le ] ; } } ld [ la ++ ] = ' \0 ' ; lj ( " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x64 \x3a \x20 " , lo ) ; lj ( " \x5b " ) ; lm ( lb = 0  ; lb < la - 1 ; lb ++ ) { lj ( " \x25 " " \x63 " , ld [ lb ] ) ; lc ( lb < la - 2 )  lj ( " \x2c \x20 " ) ; } lj ( " \x5d " ) ; lj ( " \n " ) ; } lv 0 ; }
>>>Func
METHOD lq
METHOD_RETURN lb
PARAM lb li
PARAM lg* *ll
lk lk(li<2)
<operator>.subtraction lh-1
<operator>.assignment *lj=ll[1]
<operator>.assignment lc=lr(lj,"""\x72")
lm lm(lc,"\x25\x64\n",&le)
<operator>.lessEqualsThan la<=le
<operator>.postIncrement la++
ln ln(lc)
IDENTIFIER lh <empty>
LITERAL 0 <empty>
<operator>.lessThan li<2
lr lr(lj,"""\x72")
>>>PDG&16 0->2 0->3 0->5 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->14 3->1 3->6 4->1 4->1 5->1 5->1 6->1 6->1 6->1 6->15 7->1 7->1 7->8 8->1 8->1 8->9 8->11 9->1 9->1 9->10 10->1 10->1 11->1 11->1 14->1 14->4 14->4 15->1 15->7 15->7
>>>Token lb lq ( lb li , lg * * ll ) { lb le , la ; lk ( li < 2 )  lh - 1 ; ls lg * lj = ll [ 1 ] ; lc = lr ( lj , " " " \x72 " ) ; lm ( lc , " \x25 \x64 \n " , & le ) ; lt ( la = 1  ; la <= le ; la ++ ) { lb ld = lo ( ) ; lk ( ld == -1 )  lf ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , la ) ; lp lf ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , la , ld ) ; } ln ( lc ) ; lh 0 ; }
>>>Func
METHOD lj
METHOD_RETURN lg
<operator>.assignment lc=ld("\x42\x2e\x69\x6e","\x72")
<operator>.assignment le=ld("\x6f\x75\x74""\x70\x75\x74\x2e\x74\x78\x74","\x77")
lk lk(lc,"\x25\x64\x20",&la)
<operator>.lessThan lb<la
<operator>.preIncrement ++lb
lf lf(lc)
lf lf(le)
ld ld("\x42\x2e\x69\x6e","\x72")
ld ld("\x6f\x75\x74""\x70\x75\x74\x2e\x74\x78\x74","\x77")
>>>PDG&11 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 2->4 3->1 3->1 3->8 4->1 4->1 4->5 4->7 5->1 5->1 5->6 6->1 6->1 7->1 7->1 8->1 8->1 9->2 9->2 10->3 10->3
>>>Token lg lj ( ) { lg la ; lc = ld ( " \x42 \x2e \x69 \x6e " , " \x72 " ) ; le = ld ( " \x6f \x75 \x74 " " \x70 \x75 \x74 \x2e \x74 \x78 \x74 " , " \x77 " ) ; lk ( lc , " \x25 \x64 \x20 " , & la ) ; lh ( lb = 0  ; lb < la ; ++ lb ) li ( ) ; lf ( lc ) ; lf ( le ) ; }
>>>Func
METHOD ll
METHOD_RETURN lb
PARAM lj*lh
PARAM lj*lg
PARAM lb li
PARAM lb le
PARAM lb*lc
PARAM lb*ld
<operator>.lessThan la<li
<operator>.postIncrement la++
IDENTIFIER lf <empty>
LITERAL 0 <empty>
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->1 3->1 4->8 5->1 6->1 7->1 8->1 8->1 8->9 9->1 9->1
>>>Token lb ll ( lj * lh , lj * lg , lb li , lb le , lb * lc , lb * ld ) { lm ( lb  la = * lc + * ld + 2 ; la < li ; la ++ ) { lk ( lg [ le ] == lh [ la * 3 ] ) { * lc = la * 3 ; * ld = -1 ; lf 1 ; } lk ( lg [ le ] == lh [ la * 3 + 1 ] ) { * lc = -1 ; * ld = la * 3 + 1 ; lf 1 ; } } lf 0 ; }
>>>Func
METHOD lx
METHOD_RETURN lh
PARAM lh le
PARAM ll* *lb
lu lu(&le,&lb)
l1 l1(lb[0])
lz lz(lr,"")
l15 l15(lk,l10)
l8 l8(lk)
l11 l11(l16)
<operator>.assignment lm=l18
l4 l4((lc=l7(le,lb,lt,lq,ln))!=-1)
BLOCK <empty> <empty>
lp lp()
l13 l13((lj<le)?&lb[lj]:ln)
l6 l6()
l12 l12()
ly ly(lc)
BLOCK <empty> <empty>
<operator>.notEquals (lc=l7(le,lb,lt,lq,ln))!=-1
IDENTIFIER la <empty>
LITERAL 'i' <empty>
IDENTIFIER li <empty>
IDENTIFIER la <empty>
LITERAL 't' <empty>
IDENTIFIER li <empty>
IDENTIFIER la <empty>
LITERAL '0' <empty>
IDENTIFIER lw <empty>
BLOCK <empty> <empty>
IDENTIFIER li <empty>
IDENTIFIER l9 <empty>
l14 l14(l19,lo)
l5 l5(l2)
<operator>.conditional (lj<le)?&lb[lj]:ln
<operator>.assignment lc=l7(le,lb,lt,lq,ln)
<operator>.minus -1
<operator>.assignment ld[0]=lc
<operator>.assignment ld[1]='\0'
lg lg(ld)
<operator>.lessThan lj<le
l7 l7(le,lb,lt,lq,ln)
<operator>.addressOf &lb[lj]
<operator>.indirectIndexAccess lb[lj]
>>>PDG&44 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->36 0->37 0->38 0->39 0->40 0->41 2->4 2->41 3->4 3->5 3->41 4->1 4->1 4->1 4->14 4->34 4->40 4->41 4->41 5->1 5->1 5->41 6->1 6->1 7->1 7->1 7->8 8->1 8->1 9->1 9->1 10->1 10->1 10->1 11->1 11->1 13->1 14->1 14->1 15->1 16->1 17->1 17->37 19->1 19->1 19->11 19->11 32->1 32->1 32->1 33->1 33->1 34->1 34->1 34->1 35->1 35->17 35->19 36->19 37->1 37->1 37->1 37->39 38->1 38->1 38->39 39->1 39->1 40->1 40->1 40->42 40->43 41->1 41->1 41->1 41->14 41->14 41->19 41->19 41->19 41->19 41->19 41->34 41->34 41->35 41->35 41->35 41->35 41->35 41->40
>>>Token lh lx ( lh le , ll * * lb ) { lh lc ; lu ( & le , & lb ) ; l1 ( lb [ 0 ] ) ; lz ( lr , " " ) ; l15 ( lk , l10 ) ; l8 ( lk ) ; l11 ( l16 ) ; lm = l18 ; l4 ( ( lc = l7 ( le , lb , lt , lq , ln ) ) != -1 )  { ly ( lc ) { la ' ' : lm = ls ; li ; la ' ' : lg ( lf ) ; li ; la ' ' : la ' ' : la ' ' : la ' ' : la ' ' : la ' ' : la ' ' : la ' ' : la ' ' : la ' ' : l17 ( lf ) lg ( lf -1 ) ; lw { ll ld [ 2 ] ; ld [ 0 ] = lc ; ld [ 1 ] = ' \0 ' ; lg ( ld ) ; } li ; l9 ; l14 ( l19 , lo ) ; l0 : l5 ( l2 ) ; } } lp ( ) ; l13 ( ( lj < le ) ? & lb [ lj ] : ln ) ; l6 ( ) ; l12 ( ) ; l3 lv ; }
>>>Func
METHOD lo
METHOD_RETURN lc
PARAM lc lj
PARAM ld*le[]
<operator>.assignment lb=0
<operator>.assignment *lf=le[1]
<operator>.preIncrement ++la
lq lq("\x53\x75""\x6d\x20\x69\x73\x3a\x20\x25\x64\n",lb)
IDENTIFIER ll <empty>
LITERAL 0 <empty>
>>>PDG&10 0->2 0->3 0->4 0->6 0->7 0->8 0->9 2->1 3->1 3->5 4->1 4->7 5->1 5->1 5->1 6->1 6->1 7->1 7->1
>>>Token lc lo ( lc lj , ld * le [ ] ) { lc lm , lk ; lc lb = 0 ; lg ld * lf = le [ 1 ] ; lp lg  ld * lh , * la ; lr ( la = lf  ; * la ; ++ la ) { li ( * la > 127 ) lb += * la ; ln lb + = * la ; } lq ( " \x53 \x75 " " \x6d \x20 \x69 \x73 \x3a \x20 \x25 \x64 \n " , lb ) ; ll 0 ; }
>>>Func
METHOD lm
METHOD_RETURN lg
PARAM lb le
PARAM lb lf
PARAM lb* *lh
<operator>.assignment ld=0
<operator>.assignment lc=0.0
<operator>.lessThan la<lf
<operator>.postIncrement la++
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->7 4->1 5->1 5->1 6->1 6->1 7->1 7->1 7->8 8->1 8->1
>>>Token li lg lm ( lb le , lb lf , lb * * lh ) { lb la ; lb ld = 0 ; li lg lc = 0.0 ; ln ( la = 0  ; la < lf ; la ++ ) { lj ( lh [ le ] [ la ] != -1 )  { ld ++ ; lc += ll ( la , le , lf , lh ) ; } } lk ( lc ) / ( ( li lg ) ld ) ; }
>>>Func
METHOD li
METHOD_RETURN lj
<operator>.assignment la[]="\x41\x41\x42\x43\x41\x42\x31\x32\x41\x46\x41\x41\x42""\x43\x41\x42\x46\x46\x45\x47\x41\x42\x43\x41\x42"
<operator>.assignment lg[]="\x41\x42""\x43\x41\x42"
<operator>.assignment ld[]="\x46\x46\x46"
<operator>.assignment le[]="\x43\x41\x42"
lb lb("\x53""\x74\x72\x69\x6e\x67\x20\x74\x65\x73\x74\x3a\x20\x25\x73\n",la)
lb lb("""\x54\x65\x73\x74\x31\x3a\x20\x73\x65\x61\x72\x63\x68\x20\x70\x61\x74""\x74\x65\x72\x6e\x20\x25\x73\n",lg)
lf lf(la,lg)
lb lb("\x54\x65\x73\x74""\x32\x3a\x20\x73\x65\x61\x72\x63\x68\x20\x70\x61\x74\x74\x65\x72\x6e""\x20\x25\x73\n",ld)
lf lf(la,ld)
lb lb("\x54\x65\x73\x74\x33\x3a\x20\x73""\x65\x61\x72\x63\x68\x20\x70\x61\x74\x74\x65\x72\x6e\x20\x25\x73\n",le)
lf lf(la,le)
IDENTIFIER lh <empty>
LITERAL 0 <empty>
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 2->6 3->1 3->7 4->1 4->9 5->1 5->11 6->1 6->8 7->1 7->8 8->1 8->1 8->10 9->1 9->10 10->1 10->1 10->12 11->1 11->12 12->1 12->1 12->1
>>>Token lj li ( ) { lc la [ ] = " \x41 \x41 \x42 \x43 \x41 \x42 \x31 \x32 \x41 \x46 \x41 \x41 \x42 " " \x43 \x41 \x42 \x46 \x46 \x45 \x47 \x41 \x42 \x43 \x41 \x42 " ; lc lg [ ] = " \x41 \x42 " " \x43 \x41 \x42 " ; lc ld [ ] = " \x46 \x46 \x46 " ; lc le [ ] = " \x43 \x41 \x42 " ; lb ( " \x53 " " \x74 \x72 \x69 \x6e \x67 \x20 \x74 \x65 \x73 \x74 \x3a \x20 \x25 \x73 \n " , la ) ; lb ( " " " \x54 \x65 \x73 \x74 \x31 \x3a \x20 \x73 \x65 \x61 \x72 \x63 \x68 \x20 \x70 \x61 \x74 " " \x74 \x65 \x72 \x6e \x20 \x25 \x73 \n " , lg ) ; lf ( la , lg ) ; lb ( " \x54 \x65 \x73 \x74 " " \x32 \x3a \x20 \x73 \x65 \x61 \x72 \x63 \x68 \x20 \x70 \x61 \x74 \x74 \x65 \x72 \x6e " " \x20 \x25 \x73 \n " , ld ) ; lf ( la , ld ) ; lb ( " \x54 \x65 \x73 \x74 \x33 \x3a \x20 \x73 " " \x65 \x61 \x72 \x63 \x68 \x20 \x70 \x61 \x74 \x74 \x65 \x72 \x6e \x20 \x25 \x73 \n " , le ) ; lf ( la , le ) ; lh 0 ; }
>>>Func
METHOD lv
METHOD_RETURN lp
<operator>.assignment ln=1
lk lk(lh)
lq lq(lh,"\x25\x64",&lj)
lx lx(lj--)
BLOCK <empty> <empty>
IDENTIFIER lt <empty>
LITERAL 0 <empty>
lk lk(lh)
lq lq(lh,"\x25\x64",&lc)
lu lu(lf -1 ls(lf))
<operator>.lessThan la<2*lc-1
<operator>.postIncrement la++
<operator>.lessThan la<lc
<operator>.postIncrement la++
<operator>.lessThan la<2*lc-1
<operator>.postIncrement la++
<operator>.assignment ll=0
<operator>.assignment li=0
lo lo()
<operator>.assignment lm=2*lc-1
<operator>.lessThan la<2*lc-1
<operator>.postIncrement la++
<operator>.lessThan lb<2*lc-1
<operator>.postIncrement lb++
lw lw(le lr ls(le))
<operator>.lessThan la<lc
<operator>.postIncrement la++
<operator>.lessThan la<2*lc-1
<operator>.postIncrement la++
lo lo()
<operator>.assignmentPlus li+=lc
<operator>.assignment ll=li*li-lc*lc
ly ly("\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x25\x64\n",ln++,ll)
<operator>.postDecrement lj--
<operator>.minus -1
ls ls(lf)
<operator>.subtraction 2*lc-1
<operator>.subtraction 2*lc-1
<operator>.subtraction 2*lc-1
<operator>.subtraction 2*lc-1
<operator>.subtraction 2*lc-1
ls ls(le)
<operator>.subtraction 2*lc-1
<operator>.subtraction li*li-lc*lc
<operator>.postIncrement ln++
<operator>.multiplication 2*lc
<operator>.multiplication 2*lc
<operator>.multiplication 2*lc
<operator>.multiplication 2*lc
<operator>.multiplication 2*lc
<operator>.multiplication 2*lc
<operator>.multiplication li*li
<operator>.multiplication lc*lc
>>>PDG&55 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 2->1 2->46 3->4 4->1 4->1 4->9 4->35 5->1 5->1 9->1 9->10 10->1 10->1 10->1 10->14 10->27 10->32 10->47 10->48 10->49 10->50 10->51 10->52 10->54 11->1 11->1 11->1 11->1 12->13 13->14 14->15 14->48 15->16 16->17 17->22 18->1 19->1 19->32 21->1 21->1 22->23 23->27 24->1 24->25 25->1 25->1 26->1 26->1 26->1 26->1 27->1 27->28 27->52 28->29 29->1 29->1 29->30 30->1 30->1 31->1 32->1 32->53 33->1 33->1 33->34 34->1 34->1 34->1 35->1 35->5 36->11 37->11 38->12 38->12 39->16 39->16 40->21 40->21 41->22 41->22 42->24 42->24 43->26 44->1 44->29 44->29 45->1 45->1 45->33 45->33 46->1 46->34 47->14 47->38 47->38 48->39 48->39 48->49 49->40 49->40 49->50 50->41 50->41 50->51 51->27 51->42 51->42 52->32 52->44 52->44 52->54 53->1 53->45 54->1 54->45
>>>Token lp lv ( ) { lp lj , ln = 1 , la , lb , lm , lg ; lk ( lh ) ; lq ( lh , " \x25 \x64 " , & lj ) ; lx ( lj -- )  { lk ( lh ) ; lq ( lh , " \x25 \x64 " , & lc ) ; lu ( lf , -1 , ls ( lf ) ) ; ld ( la = 0  ; la < 2 * lc - 1 ; la ++ ) lk ( le [ la ] ) ; ld ( la = 0  ; la < lc ; la ++ ) { ld ( lb = 0  ; lb <= la ; lb ++ ) lf [ la ] [ lb ] = le [ la ] [ lc - la - 1 + lb * 2 ] - ' ' ; } ld ( la = lc  ; la < 2 * lc - 1 ; la ++ ) { lg = 2 * lc - la ; ld ( lb = 0  ; lb < lg ; lb ++ ) { lf [ la ] [ lb ] = le [ la ] [ la - lc + lb * 2 + 1 ] - ' ' ; } } ll = 0 ; li = 0 ; lo ( ) ; lm = 2 * lc - 1 ; ld ( la = 0  ; la < 2 * lc - 1 ; la ++ ) ld ( lb = 0 ; lb < 2 * lc - 1 ; lb ++ ) { lr [ lm - 1 - lb ] [ la ] = le [ la ] [ lb ] ; } lw ( le , lr , ls ( le ) ) ; ld ( la = 0  ; la < lc ; la ++ ) { ld ( lb = 0  ; lb <= la ; lb ++ ) lf [ la ] [ lb ] = le [ la ] [ lc - la - 1 + lb * 2 ] - ' ' ; } ld ( la = lc  ; la < 2 * lc - 1 ; la ++ ) { lg = 2 * lc - la ; ld ( lb = 0  ; lb < lg ; lb ++ ) { lf [ la ] [ lb ] = le [ la ] [ la - lc + lb * 2 + 1 ] - ' ' ; } } lo ( ) ; li += lc ; ll = li * li - lc * lc ; ly ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , ln ++ , ll ) ; } lt 0 ; }
>>>Func
METHOD lx
METHOD_RETURN lv
<operator>.assignment lr=0
ll ll("\x25\x64",&lu)
lq lq(lr<lu)
BLOCK <empty> <empty>
IDENTIFIER ly <empty>
LITERAL 0 <empty>
<operator>.lessEqualsThan le<='Z'
<operator>.postIncrement le++
<operator>.lessEqualsThan lb<='Z'
<operator>.postIncrement lb++
<operator>.lessEqualsThan le<='Z'
<operator>.postIncrement le++
<operator>.lessEqualsThan lb<='Z'
<operator>.postIncrement lb++
<operator>.lessEqualsThan lb<='Z'
<operator>.postIncrement lb++
<operator>.assignment la=0
<operator>.assignment lc=0
ll ll("\x25\x64\x20",&lg)
lq lq(lc<lg)
BLOCK <empty> <empty>
<operator>.assignment lc=0
ll ll("\x25\x64\x20",&lg)
lq lq(lc<lg)
BLOCK <empty> <empty>
<operator>.assignment lc=0
ll ll("\x25\x64\x20",&lg)
lq lq(lc<lg)
BLOCK <empty> <empty>
ls ls("\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x5b",lr+1)
<operator>.lessThan lc<la-1
<operator>.postIncrement lc++
ls ls("\x25\x63",ld[la-1])
ls ls("\x5d\n")
<operator>.postIncrement lr++
<operator>.lessThan lr<lu
ll ll("\x25\x63\x25""\x63\x25\x63\x20",&li,&lh,&lj)
<operator>.assignment lm[li][lh]=lj
<operator>.assignment lm[lh][li]=lj
<operator>.postIncrement lc++
ll ll("\x25\x63\x25\x63\x20",&li,&lh)
<operator>.assignment lo[li][lh]='1'
<operator>.assignment lo[lh][li]='1'
<operator>.postIncrement lc++
ll ll("\x25\x63",&lj)
<operator>.assignment ld[la]=lj
<operator>.postIncrement lk[lj]++
<operator>.postIncrement la++
lp lp(la>1)
BLOCK <empty> <empty>
<operator>.postIncrement lc++
<operator>.lessThan lc<lg
<operator>.lessThan lc<lg
<operator>.lessThan lc<lg
lp lp(lm[ld[la-1]][ld[la-2]]!='0')
BLOCK <empty> <empty>
IDENTIFIER lw <empty>
<operator>.lessEqualsThan ln<='Z'
<operator>.postIncrement ln++
<operator>.addition lr+1
<operator>.subtraction la-1
<operator>.greaterThan la>1
<operator>.postDecrement lk[ld[la-1]]--
<operator>.postDecrement lk[ld[la-2]]--
<operator>.assignment ld[la-2]=lm[ld[la-1]][ld[la-2]]
<operator>.postDecrement la--
<operator>.subtraction la-1
<operator>.notEquals lm[ld[la-1]][ld[la-2]]!='0'
<operator>.subtraction la-2
<operator>.subtraction la-2
<operator>.subtraction la-1
<operator>.subtraction la-2
<operator>.subtraction la-2
<operator>.subtraction la-1
<operator>.subtraction la-1
>>>PDG&77 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->26 0->27 0->28 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->49 0->51 0->52 0->53 0->54 0->55 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 2->1 2->37 3->1 3->1 3->37 4->1 4->1 8->9 9->12 10->11 11->14 12->1 12->13 13->1 13->1 14->15 15->16 16->1 16->17 17->1 17->1 18->1 18->49 19->53 20->24 20->53 20->54 23->54 24->28 24->54 24->55 27->1 27->55 28->1 28->1 28->55 29->1 29->1 31->1 31->1 32->1 32->33 33->1 33->1 34->1 34->1 35->1 36->1 36->1 37->1 37->4 37->4 37->31 37->36 37->61 38->1 38->39 38->40 38->42 38->42 38->46 38->47 39->1 39->1 40->1 40->1 42->1 42->1 42->1 43->1 43->1 44->1 44->1 46->1 46->1 46->47 47->1 47->1 47->1 48->1 48->1 49->1 49->63 50->1 50->1 52->32 53->21 53->21 53->24 53->41 53->54 54->25 54->25 54->28 54->45 54->55 55->1 55->29 55->29 55->52 56->1 56->1 59->1 59->60 60->1 60->1 62->32 62->32 62->68 63->50 63->50 63->75 64->1 64->1 65->1 65->1 66->1 66->1 66->1 67->1 67->62 68->1 69->56 69->56 69->66 70->76 71->72 72->73 73->70 74->67 75->71 76->74
>>>Token lv lx ( ) { lt lm [ 100 ] [ 100 ] , lo [ 100 ] [ 100 ] , lk [ 100 ] , li , lh , lj ; lv la , lr = 0 , lc , ln , lu , lg ; lt lb , le ; lt ld [ 100 ] ; ll ( " \x25 \x64 " , & lu ) ; lq ( lr < lu )  { lf ( le = ' '  ; le <= ' ' ; le ++ ) lf ( lb = ' ' ; lb <= ' ' ; lb ++ ) lm [ le ] [ lb ] = ' ' ; lf ( le = ' '  ; le <= ' ' ; le ++ ) lf ( lb = ' ' ; lb <= ' ' ; lb ++ ) lo [ le ] [ lb ] = ' ' ; lf ( lb = ' '  ; lb <= ' ' ; lb ++ ) lk [ lb ] = ' ' ; la = 0 ; lc = 0 ; ll ( " \x25 \x64 \x20 " , & lg ) ; lq ( lc < lg )  { ll ( " \x25 \x63 \x25 " " \x63 \x25 \x63 \x20 " , & li , & lh , & lj ) ; lm [ li ] [ lh ] = lj ; lm [ lh ] [ li ] = lj ; lc ++ ; } lc = 0 ; ll ( " \x25 \x64 \x20 " , & lg ) ; lq ( lc < lg )  { ll ( " \x25 \x63 \x25 \x63 \x20 " , & li , & lh ) ; lo [ li ] [ lh ] = ' ' ; lo [ lh ] [ li ] = ' ' ; lc ++ ; } lc = 0 ; ll ( " \x25 \x64 \x20 " , & lg ) ; lq ( lc < lg )  { ll ( " \x25 \x63 " , & lj ) ; ld [ la ] = lj ; lk [ lj ] ++ ; la ++ ; lp ( la > 1 )  { lp ( lm [ ld [ la - 1 ] ] [ ld [ la - 2 ] ] != ' ' )  { lk [ ld [ la - 1 ] ] -- ; lk [ ld [ la - 2 ] ] -- ; ld [ la - 2 ] = lm [ ld [ la - 1 ] ] [ ld [ la - 2 ] ] ; la -- ; } lw lf ( ln  = ' ' ; ln <= ' ' ; ln ++ ) lp ( ( lo [ ld [ la - 1 ] ] [ ln ] != ' ' ) && ( lk [ ln ] != ' ' ) ) { la = 0 ; lf ( lb = ' '  ; lb <= ' ' ; lb ++ ) lk [ lb ] = ' ' ; } } lc ++ ; } ls ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lr + 1 ) ; lf ( lc = 0  ; lc < la - 1 ; lc ++ ) ls ( " \x25 \x63 \x2c \x20 " , ld [ lc ] ) ; lp ( la ) ls ( " \x25 \x63 " , ld [ la - 1 ] ) ; ls ( " \x5d \n " ) ; lr ++ ; } ly 0 ; }
>>>Func
METHOD ly
METHOD_RETURN l0
PARAM lk*lf
PARAM le lx
<operator>.assignment lq=0
<operator>.assignment ln=0
<operator>.assignment lt=0
<operator>.assignment lb=0
<operator>.assignment la=0
lm lm(lf[lb]>='0'&&lf[lb]<='9')
BLOCK <empty> <empty>
<operator>.assignmentPlus lb+=1
<operator>.assignment li=0
<operator>.assignment la=0
lm lm(li<lq)
BLOCK <empty> <empty>
lm lm(lf[lb]>='0'&&lf[lb]<='9')
BLOCK <empty> <empty>
<operator>.assignmentPlus lb+=1
<operator>.assignment li=0
<operator>.assignment la=0
lm lm(li<ln)
BLOCK <empty> <empty>
lm lm(lf[lb]>='0'&&lf[lb]<='9')
BLOCK <empty> <empty>
<operator>.assignmentPlus lb+=1
<operator>.assignment li=0
<operator>.assignment la=0
lm lm(li<lt)
BLOCK <empty> <empty>
lz lz(ld,la,lx)
<operator>.assignmentMultiplication lq*=10
<operator>.assignmentPlus lq+=lf[lb]-'0'
<operator>.assignmentPlus lb+=1
<operator>.assignment lh[la]=lf[lb++]
<operator>.assignment ls[(le)lh[la++]-'A']=1
<operator>.assignment lh[la]=lf[lb++]
<operator>.assignment lu[(le)lh[la++]-'A']=1
<operator>.assignment lh[la++]=lf[lb++]
<operator>.assignmentPlus lb+=1
<operator>.assignmentPlus li+=1
<operator>.assignmentMultiplication ln*=10
<operator>.assignmentPlus ln+=lf[lb]-'0'
<operator>.assignmentPlus lb+=1
<operator>.assignment lj[la]=lf[lb++]
<operator>.assignment lv[(le)lj[la++]-'A']=1
<operator>.assignment lj[la]=lf[lb++]
<operator>.assignment lw[(le)lj[la++]-'A']=1
<operator>.assignmentPlus lb+=1
<operator>.assignmentPlus li+=1
<operator>.assignmentMultiplication lt *=10
<operator>.assignmentPlus lt+=lf[lb]-'0'
<operator>.assignmentPlus lb+=1
<operator>.assignment ld[la++]=lf[lb++]
lg lg(la>=2)
BLOCK <empty> <empty>
lg lg(la>=2)
BLOCK <empty> <empty>
<operator>.assignmentPlus li+=1
<operator>.logicalAnd lf[lb]>='0'&&lf[lb]<='9'
<operator>.lessThan li<lq
<operator>.logicalAnd lf[lb]>='0'&&lf[lb]<='9'
<operator>.lessThan li<ln
<operator>.logicalAnd lf[lb]>='0'&&lf[lb]<='9'
<operator>.lessThan li<lt
<operator>.assignment lr=0
lm lm(!lr)
BLOCK <empty> <empty>
lg lg(lv[(le)ld[la-1]-'A'])
BLOCK <empty> <empty>
lg lg(lw[(le)ld[la-1]-'A']&&la>0)
BLOCK <empty> <empty>
<operator>.greaterEqualsThan lf[lb]>='0'
<operator>.lessEqualsThan lf[lb]<='9'
<operator>.subtraction lf[lb]-'0'
<operator>.greaterEqualsThan lf[lb]>='0'
<operator>.lessEqualsThan lf[lb]<='9'
<operator>.subtraction lf[lb]-'0'
<operator>.greaterEqualsThan lf[lb]>='0'
<operator>.lessEqualsThan lf[lb]<='9'
<operator>.subtraction lf[lb]-'0'
<operator>.greaterEqualsThan la>=2
<operator>.assignment lr=1
lg lg(ls[(le)ld[la-2]-'A']&&lu[(le)ld[la-1]-'A'])
BLOCK <empty> <empty>
lg lg(lu[(le)ld[la-2]-'A']&&ls[(le)ld[la-1]-'A'])
BLOCK <empty> <empty>
<operator>.greaterEqualsThan la>=2
<operator>.lessThan lc<(ln*2)
<operator>.assignmentPlus lc+=2
<operator>.lessThan lc<(ln*2)
<operator>.assignmentPlus lc+=2
<operator>.postIncrement lb++
<operator>.subtraction (le)lh[la++]-'A'
<operator>.postIncrement lb++
<operator>.subtraction (le)lh[la++]-'A'
<operator>.postIncrement la++
<operator>.postIncrement lb++
<operator>.postIncrement lb++
<operator>.subtraction (le)lj[la++]-'A'
<operator>.postIncrement lb++
<operator>.subtraction (le)lj[la++]-'A'
<operator>.postIncrement la++
<operator>.postIncrement lb++
<operator>.logicalNot !lr
<operator>.lessThan lc<(lq*3)
<operator>.assignmentPlus lc+=3
<operator>.lessThan lc<(lq*3)
<operator>.assignmentPlus lc+=3
<operator>.logicalAnd lw[(le)ld[la-1]-'A']&&la>0
<operator>.cast (le)lj[la++]
<operator>.logicalAnd ls[(le)ld[la-2]-'A']&&lu[(le)ld[la-1]-'A']
<operator>.logicalAnd lu[(le)ld[la-2]-'A']&&ls[(le)ld[la-1]-'A']
<operator>.subtraction (le)ld[la-1]-'A'
<operator>.multiplication ln*2
<operator>.greaterThan la>0
<operator>.multiplication ln*2
<operator>.multiplication lq*3
<operator>.multiplication lq*3
<operator>.subtraction (le)ld[la-1]-'A'
<operator>.postIncrement la++
<operator>.postIncrement la++
<operator>.postIncrement la++
<operator>.postIncrement la++
<operator>.subtraction (le)ld[la-2]-'A'
<operator>.subtraction (le)ld[la-1]-'A'
<operator>.subtraction (le)ld[la-2]-'A'
<operator>.subtraction (le)ld[la-1]-'A'
<operator>.cast (le)ld[la-1]
<operator>.cast (le)ld[la-2]
<operator>.subtraction la-1
<operator>.subtraction la-1
<operator>.subtraction la-2
<operator>.subtraction la-1
<operator>.subtraction la-2
<operator>.subtraction la-1
<operator>.indirectIndexAccess lf[lb]
<operator>.indirectIndexAccess lf[lb]
<operator>.indirectIndexAccess lf[lb]
<operator>.indirectIndexAccess lw[(le)ld[la-1]-'A']
<operator>.indirectIndexAccess ls[(le)ld[la-2]-'A']
<operator>.indirectIndexAccess lu[(le)ld[la-1]-'A']
<operator>.indirectIndexAccess lu[(le)ld[la-2]-'A']
<operator>.indirectIndexAccess ls[(le)ld[la-1]-'A']
<operator>.cast (le)ld[la-1]
<operator>.cast (le)ld[la-1]
UNKNOWN le le
<operator>.indirectIndexAccess ld[la-1]
UNKNOWN le le
<operator>.indirectIndexAccess ld[la-1]
>>>PDG&150 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->15 0->17 0->18 0->19 0->20 0->22 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->35 0->37 0->39 0->40 0->41 0->42 0->43 0->45 0->47 0->48 0->49 0->50 0->51 0->52 0->55 0->57 0->58 0->60 0->62 0->64 0->65 0->67 0->69 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->84 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->127 0->130 0->131 0->132 0->133 0->134 0->135 2->1 2->34 2->36 2->38 2->44 2->46 2->53 2->72 2->73 2->74 2->75 2->76 2->77 2->78 2->79 2->80 3->30 4->1 4->31 5->1 5->41 6->1 6->50 7->1 7->33 11->92 12->60 13->120 14->1 14->1 18->98 19->62 20->122 21->1 21->1 23->1 23->1 25->1 25->103 26->1 26->64 27->1 27->102 28->1 28->1 30->1 30->1 30->1 30->1 31->1 31->32 32->1 32->60 33->11 35->1 35->1 36->1 36->1 37->1 37->1 38->1 38->1 39->43 41->1 41->42 42->1 42->62 43->18 45->1 45->1 46->1 46->1 47->1 47->1 48->52 50->1 50->51 51->1 51->1 51->64 52->25 53->1 53->1 53->1 53->30 56->1 56->1 58->1 58->1 59->9 59->9 59->61 60->14 60->14 60->40 60->117 61->16 61->16 61->63 62->21 62->21 62->49 62->114 63->1 63->1 63->23 63->23 64->1 64->28 64->28 64->58 65->1 65->104 66->1 66->1 68->1 68->1 70->1 70->1 72->59 72->59 72->73 72->73 72->74 72->136 73->59 73->59 73->74 74->32 74->32 74->75 75->61 75->61 75->76 75->76 75->77 75->137 76->61 76->61 76->77 77->42 77->42 77->78 78->63 78->63 78->79 78->79 78->80 78->138 79->63 79->63 79->80 80->1 80->51 80->51 81->54 81->54 81->132 82->1 82->1 83->1 83->1 85->1 85->1 87->56 87->56 87->130 88->89 89->90 90->1 90->1 90->91 91->1 91->1 92->94 94->97 95->1 97->39 98->100 100->48 101->1 102->81 103->1 104->66 105->106 106->107 107->1 107->1 107->108 108->1 108->88 109->1 109->1 109->70 109->70 110->1 111->1 111->1 111->83 111->83 112->1 112->1 112->85 112->85 114->88 114->88 114->116 115->30 115->109 115->109 116->1 116->90 116->90 117->105 117->105 117->118 118->1 118->107 118->107 119->1 120->121 121->96 122->123 126->1 128->1 129->1 130->131 131->30 131->115 132->133 132->134 133->134 134->87 134->135 135->87 139->115 140->125 140->133 140->141 140->144 140->146 140->147 142->127 142->135 142->143 142->145 142->148 142->149
>>>Token l0 ly ( lk * lf , le lx ) { le lq = 0 ; le ln = 0 ; le lt = 0 ; le lc ; le ll ; le li ; le lb = 0 ; lk lh [ 36 * 3 ] ; lk lj [ 28 * 2 ] ; lk ld [ 100 ] ; lk ls [ 26 ] ; lk lu [ 26 ] ; lk lv [ 26 ] ; lk lw [ 26 ] ; le la = 0 ; lm ( lf [ lb ] >= ' ' && lf [ lb ] <= ' ' )  { lq *= 10 ; lq += lf [ lb ] - ' ' ; lb += 1 ; } lb += 1 ; li = 0 ; la = 0 ; lm ( li < lq )  { lh [ la ] = lf [ lb ++ ] ; ls [ ( le ) lh [ la ++ ] - ' ' ] = 1 ; lh [ la ] = lf [ lb ++ ] ; lu [ ( le ) lh [ la ++ ] - ' ' ] = 1 ; lh [ la ++ ] = lf [ lb ++ ] ; lb += 1 ; li += 1 ; } lm ( lf [ lb ] >= ' ' && lf [ lb ] <= ' ' )  { ln *= 10 ; ln += lf [ lb ] - ' ' ; lb += 1 ; } lb += 1 ; li = 0 ; la = 0 ; lm ( li < ln )  { lj [ la ] = lf [ lb ++ ] ; lv [ ( le ) lj [ la ++ ] - ' ' ] = 1 ; lj [ la ] = lf [ lb ++ ] ; lw [ ( le ) lj [ la ++ ] - ' ' ] = 1 ; lb += 1 ; li += 1 ; } lm ( lf [ lb ] >= ' ' && lf [ lb ] <= ' ' )  { lt *= 10 ; lt += lf [ lb ] - ' ' ; lb += 1 ; } lb += 1 ; li = 0 ; la = 0 ; lm ( li < lt )  { ld [ la ++ ] = lf [ lb ++ ] ; lg ( la >= 2 )  { lk lr = 0 ; lm ( ! lr )  { lr = 1 ; lg ( ls [ ( le ) ld [ la - 2 ] - ' ' ] && lu [ ( le ) ld [ la - 1 ] - ' ' ] )  { lo ( lc = 0  ; lc < ( lq * 3 ) ; lc += 3 ) { lg ( lh [ lc ] == ld [ la - 2 ] && lh [ lc + 1 ] == ld [ la - 1 ] )  { la -- ; ld [ la - 1 ] = lh [ lc + 2 ] ; lr = 0 ; lp ; } } } lg ( lu [ ( le ) ld [ la - 2 ] - ' ' ] && ls [ ( le ) ld [ la - 1 ] - ' ' ] )  { lo ( lc = 0  ; lc < ( lq * 3 ) ; lc += 3 ) { lg ( lh [ lc ] == ld [ la - 1 ] && lh [ lc + 1 ] == ld [ la - 2 ] )  { la -- ; ld [ la - 1 ] = lh [ lc + 2 ] ; lr = 0 ; lp ; } } } } } lg ( la >= 2 )  { lg ( lv [ ( le ) ld [ la - 1 ] - ' ' ] ) { lo ( lc = 0  ; lc < ( ln * 2 ) ; lc += 2 ) { lg ( ld [ la - 1 ] == lj [ lc ] )  { lo ( ll = 0  ; ll < la - 1 ; ll ++ ) { lg ( ld [ ll ] == lj [ lc + 1 ] )  { la = 0 ; lp ; } } } lg ( ! la ) lp ; } } lg ( lw [ ( le ) ld [ la - 1 ] - ' ' ] && la > 0 )  { lo ( lc = 1  ; lc < ( ln * 2 ) ; lc += 2 ) { lg ( ld [ la - 1 ] == lj [ lc ] )  { lo ( ll = 0  ; ll < la - 1 ; ll ++ ) { lg ( ld [ ll ] == lj [ lc - 1 ] )  { la = 0 ; lp ; } } } lg ( ! la ) lp ; } } } li += 1 ; } lz ( ld , la , lx ) ; }
>>>Func
METHOD lj
METHOD_RETURN lc
ld ld("\x69\x6e\x70\x75\x74\x2e\x74\x78\x74","\x72",ll)
ld ld("\x6f""\x75\x74\x70\x75\x74\x2e\x74\x78\x74","\x77",li)
lf lf("\x25\x64""\x20",&lb)
<operator>.lessThan la<lb
<operator>.postIncrement la++
IDENTIFIER lh <empty>
LITERAL 0 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 2->1 3->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token lc lj ( ) { ld ( " \x69 \x6e \x70 \x75 \x74 \x2e \x74 \x78 \x74 " , " \x72 " , ll ) ; ld ( " \x6f " " \x75 \x74 \x70 \x75 \x74 \x2e \x74 \x78 \x74 " , " \x77 " , li ) ; lc lb ; lf ( " \x25 \x64 " " \x20 " , & lb ) ; lc la ; le ( la = 0  ; la < lb ; la ++ ) { lk ( " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a \x20 " , la + 1 ) ; lg ( ) ; } lh 0 ; }
>>>Func
METHOD lm
METHOD_RETURN lg
PARAM lj*le
PARAM lg lf
PARAM lj( *ld)[5]
PARAM lg ll
<operator>.lessThan lc<lf
<operator>.postIncrement lc++
<operator>.lessThan lb<lf
<operator>.postIncrement lb++
<operator>.lessThan la<ll
<operator>.postIncrement la++
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->1 3->6 4->1 5->10 6->1 6->7 6->8 7->1 7->1 8->1 8->1 8->9 9->1 9->1 10->1 10->1 10->11 11->1 11->1
>>>Token lg lm ( lj * le , lg lf , lj ( * ld ) [ 5 ] , lg ll ) { lg lc , lb , la ; lh ( lc = 0  ; lc < lf ; lc ++ ) lh ( lb = 0 ; lb < lf ; lb ++ ) li ( lc != lb )  lh ( la = 0  ; la < ll ; la ++ ) li ( ( * ( le + lc ) == * * ( ld + la ) && * ( le + lb ) == * ( * ( ld + la ) + 1 ) ) || ( * ( le + lc ) == * ( * ( ld + la ) + 1 ) && * ( le + lb ) == * * ( ld + la ) ) ) lk 0 ; lk lf ; }
>>>Func
METHOD lp
METHOD_RETURN ls
PARAM lq lg[100][100]
PARAM lh lf
PARAM la ll[100]
PARAM la ln[100]
PARAM la lm[100]
<operator>.assignment lb=0
lo lo(lb<lf)
BLOCK <empty> <empty>
<operator>.assignment lc=0
<operator>.assignment ld=0
<operator>.assignment le=0
lo lo(lc<lf)
BLOCK <empty> <empty>
<operator>.assignment lm[lb]=le
<operator>.assignment ln[lb]=ld
<operator>.assignment lj=ld+le
<operator>.assignment li=(la)(ld/lj)
<operator>.assignment ll[lb]=li
<operator>.postIncrement lb++
<operator>.lessThan lb<lf
lk lk(lg[lb][lc]=='0')
BLOCK <empty> <empty>
IDENTIFIER lr <empty>
lk lk(lg[lb][lc]=='1')
BLOCK <empty> <empty>
<operator>.postIncrement lc++
<operator>.lessThan lc<lf
<operator>.postIncrement le++
<operator>.postIncrement ld++
<operator>.addition ld+le
la (la)(ld/lj)
<operator>.equals lg[lb][lc]=='0'
<operator>.equals lg[lb][lc]=='1'
<operator>.division ld/lj
>>>PDG&36 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->34 0->35 2->1 3->21 4->1 5->1 6->1 7->1 7->21 8->1 8->1 10->1 10->28 11->1 11->30 12->1 12->29 13->1 13->1 15->1 15->1 16->1 16->1 17->1 17->1 17->35 18->1 18->1 18->19 19->1 19->1 19->1 20->1 20->1 21->8 21->8 21->20 21->28 22->1 22->1 25->1 25->1 27->1 27->1 28->1 28->13 28->13 28->27 29->1 29->15 29->17 29->31 30->1 30->16 30->17 30->31 30->35 31->1 32->1 32->18 33->22 33->22 33->34 34->1 34->25 34->25 35->1 35->1 35->32 35->32
>>>Token ls lp ( lq lg [ 100 ] [ 100 ] , lh lf , la ll [ 100 ] , la ln [ 100 ] , la lm [ 100 ] ) { lh lb = 0 ; lo ( lb < lf )  { lh lc = 0 ; la ld = 0 ; la le = 0 ; lo ( lc < lf )  { lk ( lg [ lb ] [ lc ] == ' ' )  { le ++ ; } lr lk ( lg [ lb ] [ lc ] = = ' ' ) { ld ++ ; } lc ++ ; } lm [ lb ] = le ; ln [ lb ] = ld ; la lj = ld + le ; la li = ( la ) ( ld / lj ) ; ll [ lb ] = li ; lb ++ ; } }
>>>Func
METHOD li
METHOD_RETURN lb
PARAM lb*le
PARAM lb ld
PARAM lb lf
PARAM lb*lc
<operator>.lessThan la<ld
<operator>.postIncrement la++
IDENTIFIER lh <empty>
LITERAL 0 <empty>
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 3->6 4->1 5->1 6->1 6->1 6->7 7->1 7->1
>>>Token lb li ( lb * le , lb ld , lb lf , lb * lc ) { lb la ; lj ( la = 0  ; la < ld ; la ++ ) { lg ( le [ la ] == lf )  { lg ( 0 != lc ) * lc = la ; lh 1 ; } } lh 0 ; }
>>>Func
METHOD le
METHOD_RETURN lg
PARAM lk lc
lj lj(lc!=lu)
lp lp()
IDENTIFIER ls <empty>
BLOCK <empty> <empty>
lh lh(lc)
lf lf(ld("\xa\x55\x73\x61\x67\x65\x3a""\x20\x25\x73\x20\x5b\x4f\x50\x54\x49\x4f\x4e\x5d\x2e\x2e\x2e\x20\x5b""\x46\x49\x4c\x45\x5d\x2e\x2e\x2e\n\xa"),lm)
la la(ld("\xa\x43\x6f\x6e""\x76\x65\x72\x74\x20\x74\x61\x62\x73\x20\x69\x6e\x20\x65\x61\x63\x68""\x20\x46\x49\x4c\x45\x20\x74\x6f\x20\x73\x70\x61\x63\x65\x73\x2c\x20""\x77\x72\x69\x74\x69\x6e\x67\x20\x74\x6f\x20\x73\x74\x61\x6e\x64\x61""\x72\x64\x20\x6f\x75\x74\x70\x75\x74\x2e\n\xa"),lb)
lr lr()
lo lo()
la la(ld("\xa\x20\x20\x2d\x69\x2c\x20\x2d\x2d\x69\x6e\x69\x74\x69\x61\x6c""\x20\x20\x20\x20\x64\x6f\x20\x6e\x6f\x74\x20\x63\x6f\x6e\x76\x65\x72""\x74\x20\x74\x61\x62\x73\x20\x61\x66\x74\x65\x72\x20\x6e\x6f\x6e\x20""\x62\x6c\x61\x6e\x6b\x73\n\xa\x20\x20\x2d\x74\x2c\x20\x2d\x2d\x74""\x61\x62\x73\x3d\x4e\x20\x20\x20\x20\x20\x68\x61\x76\x65\x20\x74\x61""\x62\x73\x20\x4e\x20\x63\x68\x61\x72\x61\x63\x74\x65\x72\x73\x20\x61""\x70\x61\x72\x74\x2c\x20\x6e\x6f\x74\x20\x38\n\xa"),lb)
ln ln()
la la(li,lb)
la la(lt,lb)
ll ll(lq)
<operator>.notEquals lc!=lu
ld ld("\xa\x55\x73\x61\x67\x65\x3a""\x20\x25\x73\x20\x5b\x4f\x50\x54\x49\x4f\x4e\x5d\x2e\x2e\x2e\x20\x5b""\x46\x49\x4c\x45\x5d\x2e\x2e\x2e\n\xa")
ld ld("\xa\x43\x6f\x6e""\x76\x65\x72\x74\x20\x74\x61\x62\x73\x20\x69\x6e\x20\x65\x61\x63\x68""\x20\x46\x49\x4c\x45\x20\x74\x6f\x20\x73\x70\x61\x63\x65\x73\x2c\x20""\x77\x72\x69\x74\x69\x6e\x67\x20\x74\x6f\x20\x73\x74\x61\x6e\x64\x61""\x72\x64\x20\x6f\x75\x74\x70\x75\x74\x2e\n\xa")
ld ld("\xa\x20\x20\x2d\x69\x2c\x20\x2d\x2d\x69\x6e\x69\x74\x69\x61\x6c""\x20\x20\x20\x20\x64\x6f\x20\x6e\x6f\x74\x20\x63\x6f\x6e\x76\x65\x72""\x74\x20\x74\x61\x62\x73\x20\x61\x66\x74\x65\x72\x20\x6e\x6f\x6e\x20""\x62\x6c\x61\x6e\x6b\x73\n\xa\x20\x20\x2d\x74\x2c\x20\x2d\x2d\x74""\x61\x62\x73\x3d\x4e\x20\x20\x20\x20\x20\x68\x61\x76\x65\x20\x74\x61""\x62\x73\x20\x4e\x20\x63\x68\x61\x72\x61\x63\x74\x65\x72\x73\x20\x61""\x70\x61\x72\x74\x2c\x20\x6e\x6f\x74\x20\x38\n\xa")
>>>PDG&21 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 2->17 3->1 3->1 4->1 7->1 7->1 8->1 8->1 8->1 9->1 9->1 9->12 10->1 11->1 12->1 12->1 12->14 13->1 14->1 14->1 14->15 15->1 15->1 15->1 16->1 16->1 17->1 17->3 17->3 17->7 18->8 19->9 20->12
>>>Token lg le ( lk lc ) { lj ( lc != lu ) lp ( ) ; ls { lf ( ld ( " x a x 55 x 73 x 61 x 67 x 65 x 3 a " " \x20 \x25 \x73 \x20 \x5b \x4f \x50 \x54 \x49 \x4f \x4e \x5d \x2e \x2e \x2e \x20 \x5b " " \x46 \x49 \x4c \x45 \x5d \x2e \x2e \x2e \n x a " ) , lm ) ; la ( ld ( " x a x 43 x 6f x 6e " " \x76 \x65 \x72 \x74 \x20 \x74 \x61 \x62 \x73 \x20 \x69 \x6e \x20 \x65 \x61 \x63 \x68 " " \x20 \x46 \x49 \x4c \x45 \x20 \x74 \x6f \x20 \x73 \x70 \x61 \x63 \x65 \x73 \x2c \x20 " " \x77 \x72 \x69 \x74 \x69 \x6e \x67 \x20 \x74 \x6f \x20 \x73 \x74 \x61 \x6e \x64 \x61 " " \x72 \x64 \x20 \x6f \x75 \x74 \x70 \x75 \x74 \x2e \n x a " ) , lb ) ; lr ( ) ; lo ( ) ; la ( ld ( " x a x 20 x 20 x 2 d x 69 x 2 c x 20 x 2 d x 2 d x 69 x 6e x 69 x 74 x 69 x 61 x 6 c " " \x20 \x20 \x20 \x20 \x64 \x6f \x20 \x6e \x6f \x74 \x20 \x63 \x6f \x6e \x76 \x65 \x72 " " \x74 \x20 \x74 \x61 \x62 \x73 \x20 \x61 \x66 \x74 \x65 \x72 \x20 \x6e \x6f \x6e \x20 " " \x62 \x6c \x61 \x6e \x6b \x73 \n x a x 20 x 20 x 2 d x 74 x 2 c x 20 x 2 d x 2 d x 74 " " \x61 \x62 \x73 \x3d \x4e \x20 \x20 \x20 \x20 \x20 \x68 \x61 \x76 \x65 \x20 \x74 \x61 " " \x62 \x73 \x20 \x4e \x20 \x63 \x68 \x61 \x72 \x61 \x63 \x74 \x65 \x72 \x73 \x20 \x61 " " \x70 \x61 \x72 \x74 \x2c \x20 \x6e \x6f \x74 \x20 \x38 \n x a " ) , lb ) ; ln ( ) ; la ( li , lb ) ; la ( lt , lb ) ; ll ( lq ) ; } lh ( lc ) ; }
>>>Func
METHOD lg
METHOD_RETURN lh
PARAM lc lf[][26]
PARAM lc ld[][26]
<operator>.lessThan lb<26
<operator>.postIncrement lb++
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 3->1 4->1 4->5 5->1 5->1
>>>Token li lh lg ( lc lf [ ] [ 26 ] , lc ld [ ] [ 26 ] ) { lc lb , la ; le ( lb = 0  ; lb < 26 ; lb ++ ) { le ( la = 0  ; la < 26 ; la ++ ) { lf [ lb ] [ la ] = -1 ; ld [ lb ] [ la ] = -1 ; } } }
>>>Func
METHOD lv
METHOD_RETURN lc
lg lg("\x25\x64",&ls)
<operator>.lessEqualsThan ll<=ls
<operator>.postIncrement ll++
IDENTIFIER lw <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lc lv ( ) { lc ls ; lg ( " \x25 \x64 " , & ls ) ; lh ( lc  ll = 1 ; ll <= ls ; ll ++ ) { lf le [ 100 ] ; lc ld = 0 ; lf lj [ 256 ] [ 256 ] = { 0 } ; lf lk [ 256 ] [ 256 ] = { 0 } ; lc lp ; lg ( " \x25 \x64 " " \x20 " , & lp ) ; lh ( lc  lb = 0 ; lb < lp ; lb ++ ) { lf la [ 4 ] ; lg ( " \x25 \x73 " , & la ) ; lj [ la [ 0 ] ] [ la [ 1 ] ] = la [ 2 ] ; lj [ la [ 1 ] ] [ la [ 0 ] ] = la [ 2 ] ; } lc lo ; lg ( " \x25 \x64 " , & lo ) ; lh ( lc  lb = 0 ; lb < lo ; lb ++ ) { lf la [ 3 ] ; lg ( " \x25 \x73 " , & la ) ; lk [ la [ 0 ] ] [ la [ 1 ] ] = 1 ; lk [ la [ 1 ] ] [ la [ 0 ] ] = 1 ; } lc lr ; lf la [ 101 ] ; lg ( " \x25 \x64 \x20 \x25 \x73 " , & lr , & la ) ; lh ( lc  lb = 0 ; lb < lr ; lb ++ ) { le [ ld ++ ] = la [ lb ] ; ln ( ld < 2 ) lt ; lf lq = lj [ le [ ld - 1 ] ] [ le [ ld - 2 ] ] ; ln ( lq != 0 )  { ld -= 2 ; le [ ld ++ ] = lq ; } lu { lh ( lc lm  = 0 ; lm < ld - 1 ; lm ++ ) ln ( lk [ le [ lm ] ] [ la [ lb ] ] ) { ld = 0 ; lx ; } } } li ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 " " \x3a \x20 \x5b " , ll ) ; lh ( lc  lb = 0 ; lb < ld ; lb ++ ) { ln ( lb > 0 ) li ( " \x2c \x20 " ) ; li ( " " " \x25 \x63 " , le [ lb ] ) ; } li ( " \x5d \n " ) ; } lw 0 ; }
>>>Func
METHOD li
METHOD_RETURN lf
PARAM ld*lc
<operator>.assignment *la=lc
lh lh(la!=lg)
BLOCK <empty> <empty>
lb lb("\n")
lb lb("\t")
lb lb("\x5b\x25\x6c\x66\x5d""\x20\x2d\x2d\x20",la->lk)
lb lb("\x5b\x25\x6c\x66\x5d",la->lj)
<operator>.assignment la=la->le
<operator>.notEquals la!=lg
>>>PDG&12 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->11 2->3 3->1 3->1 3->11 4->1 4->1 6->1 7->1 8->1 8->1 9->1 9->1 10->1 10->1 10->1 11->1 11->4 11->4
>>>Token lf li ( ld * lc ) { ld * la = lc ; lh ( la != lg )  { lb ( " \t " ) ; lb ( " \x5b \x25 \x6c \x66 \x5d " " \x20 \x2d \x2d \x20 " , la -> lk ) ; lb ( " \x5b \x25 \x6c \x66 \x5d " , la -> lj ) ; la = la -> le ; } lb ( " \n " ) ; }
>>>Func
METHOD l3
METHOD_RETURN l1
<operator>.assignment lf=l0("\x69\x6e\x70\x75""\x74\x2e\x69\x6e","\x72")
<operator>.assignment lm=l0("\x6f\x75\x74\x70\x75\x74\x2e\x74""\x78\x74","\x77")
ll ll(lf,"\x25\x64",&lx)
<operator>.lessThan ln<lx
<operator>.postIncrement ln++
IDENTIFIER l4 <empty>
LITERAL 0 <empty>
l0 l0("\x69\x6e\x70\x75""\x74\x2e\x69\x6e","\x72")
l0 l0("\x6f\x75\x74\x70\x75\x74\x2e\x74""\x78\x74","\x77")
>>>PDG&11 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 2->4 3->1 3->1 3->1 4->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1 9->2 9->2 10->3 10->3
>>>Token l1 l3 ( ) { l1 lx , lq , lp , lw , lc , ln , la , lb , le , lk ; l5 lg [ 100 ] , lt [ 10 ] , ls [ 10 ] , lv [ 10 ] , li [ 4 ] , lu [ 10 ] , lo [ 10 ] , ld [ 100 ] ; l2 * lf , * lm ; lf = l0 ( " \x69 \x6e \x70 \x75 " " \x74 \x2e \x69 \x6e " , " \x72 " ) ; lm = l0 ( " \x6f \x75 \x74 \x70 \x75 \x74 \x2e \x74 " " \x78 \x74 " , " \x77 " ) ; ll ( lf , " \x25 \x64 " , & lx ) ; lh ( ln = 0  ; ln < lx ; ln ++ ) { lc = -1 ; ll ( lf , " \x25 \x64 " , & lq ) ; lh ( la = 0  ; la < lq ; la ++ ) { ll ( lf , " \x25 \x73 " , li ) ; lt [ la ] = li [ 0 ] ; ls [ la ] = li [ 1 ] ; lv [ la ] = li [ 2 ] ; } ll ( lf , " \x25 \x64 " , & lp ) ; lh ( la = 0  ; la < lp ; la ++ ) { ll ( lf , " \x25 \x73 " , li ) ; lu [ la ] = li [ 0 ] ; lo [ la ] = li [ 1 ] ; } ll ( lf , " \x25 \x64 " , & lw ) ; ll ( lf , " \x25 \x73 " , lg ) ; lh ( le = 0  ; le < lw ; le ++ ) { lj ( lc == -1 ) ld [ ++ lc ] = lg [ le ] ; lz { lk = 0 ; lh ( la = 0  ; la < lq ; la ++ ) { lj ( ( lt [ la ] == ld [ lc ] && lg [ le ] == ls [ la ] ) || ( lt [ la ] == lg [ le ] && ld [ lc ] == ls [ la ] ) )  { ld [ lc ] = lv [ la ] ; lk = 1 ; ly ; } } lj ( ! lk )  { lh ( lb = 0  ; lb <= lc ; lb ++ ) { lh ( la = 0  ; la < lp ; la ++ ) { lj ( ( lu [ la ] == ld [ lb ] && lg [ le ] == lo [ la ] ) || ( lu [ la ] == lg [ le ] && ld [ lb ] == lo [ la ] ) )  { lc = -1 ; lk = 1 ; ly ; } } lj ( lk ) ly ; } } lj ( ! lk ) ld [ ++ lc ] = lg [ le ] ; } } lr ( lm , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a " " \x20 \x5b " , ln + 1 ) ; lh ( lb = 0  ; lb <= lc ; lb ++ ) { lj ( ! lb ) lr ( lm , " \x25 \x63 " , ld [ lb ] ) ; lz lr ( lm , " \x2c \x20 \x25 \x63 " , ld [ lb ] ) ; } lr ( lm , " \x5d \n " ) ; } l4 0 ; }
>>>Func
METHOD lz
METHOD_RETURN lx
<operator>.assignment lb=lv("\x69\x6e\x70\x75\x74\x2e\x74\x78\x74","""\x72")
<operator>.assignment li=lv("\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74","\x77")
le le(lb,"\x25\x64\x20",&lt)
<operator>.lessEqualsThan lj<=lt
<operator>.postIncrement lj++
lw lw(lb)
lw lw(li)
IDENTIFIER l1 <empty>
LITERAL 0 <empty>
lv lv("\x69\x6e\x70\x75\x74\x2e\x74\x78\x74","""\x72")
lv lv("\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74","\x77")
>>>PDG&13 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 2->1 2->4 3->1 3->1 3->8 4->1 4->1 4->5 4->7 5->1 5->1 5->6 6->1 6->1 7->1 7->1 8->1 8->1 11->2 11->2 12->3 12->3
>>>Token lx lz ( ) { lx lt , lm , lj , la , lc , ln , lf , ld ; lq lh [ 101 ] ; lq ll [ 37 ] [ 4 ] ; lq lk [ 29 ] [ 3 ] ; lq ls ; lu * lb ; lu * li ; lb = lv ( " \x69 \x6e \x70 \x75 \x74 \x2e \x74 \x78 \x74 " , " " " \x72 " ) ; li = lv ( " \x6f \x75 \x74 \x70 \x75 \x74 \x2e \x74 \x78 \x74 " , " \x77 " ) ; le ( lb , " \x25 \x64 \x20 " , & lt ) ; lg ( lj = 1  ; lj <= lt ; lj ++ ) { le ( lb , " \x25 \x64 \x20 " , & lm ) ; lp ( lm > 0 )  { ll [ 0 ] [ 0 ] = ' ' ; lg ( la = 1  ; la <= lm ; la ++ ) { lg ( lc = 1  ; lc <= 3 ; lc ++ ) le ( lb , " " " \x25 \x63 " , & ll [ la ] [ lc ] ) ; le ( lb , " \x25 \x63 " , & ls ) ; } } lr ll [ 0 ] [ 0 ] = ' ' ; le ( lb , " \x25 \x64 \x20 " , & ln ) ; lp ( ln > 0 )  { lk [ 0 ] [ 0 ] = ' ' ; lg ( la = 1  ; la <= ln ; la ++ ) { lg ( lc = 1  ; lc <= 2 ; lc ++ ) le ( lb , " \x25 \x63 " , & lk [ la ] [ lc ] ) ; le ( lb , " \x25 \x63 " , & ls ) ; } } lr lk [ 0 ] [ 0 ] = ' ' ; le ( lb , " \x25 \x64 \x20 " , & lf ) ; lg ( la = 1  ; la <= lf ; la ++ ) le ( lb , " " " \x25 \x63 " , & lh [ la ] ) ; ly ( lh , lf , ll , lm , lk , ln ) ; ld = 0 ; l2 ld ++ ; l0 ( ( ld > lf ) || ( lh [ ld ] == ' ' ) ) ; lp ( ld > lf )  lo ( li , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a " " \x20 \x5b \x5d \n " , lj ) ; lr  { lo ( li , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a " " \x20 \x5b \x25 \x63 " , lj , lh [ ld ] ) ; ld ++ ; lg ( la = ld  ; la <= lf ; la ++ ) lp ( lh [ la ] != ' ' )  lo ( li , " \x2c \x20 \x25 \x63 " , lh [ la ] ) ; lo ( li , " \x5d \n " ) ; } } lw ( lb ) ; lw ( li ) ; l1 0 ; }
>>>Func
METHOD lh
METHOD_RETURN lc
PARAM lc
<operator>.lessEqualsThan lb<=100
<operator>.postIncrement lb++
>>>PDG&5 0->2 0->3 0->4 2->1 3->1 3->4 4->1 4->1
>>>Token lc lh ( lc ) { lg lb , la ; ld ( lb = 0  ; lb <= 100 ; lb ++ ) { ld ( la = 0  ; la <= 100 ; la ++ ) { le [ lb ] [ la ] = lf ( la , 100 - la , lb - la ) ; } } }
>>>Func
METHOD ll
METHOD_RETURN lb
<operator>.assignment la=lm("\x63\x61\x73""\x65\x32\x2e\x74\x78\x74","\x72")
ln ln(la==0)
BLOCK <empty> <empty>
li li(la,"\x25\x64",&ld)
<operator>.lessThan lc<ld
<operator>.postIncrement lc++
lo lo(la)
lf lf("\x63\x61\x6e\x20\x6e""\x6f\x74\x20\x6f\x70\x65\x72\x6e\n")
lm lm("\x63\x61\x73""\x65\x32\x2e\x74\x78\x74","\x72")
<operator>.equals la==0
>>>PDG&12 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->1 2->1 2->11 3->1 3->1 5->1 5->1 5->6 5->8 6->1 6->1 6->7 7->1 7->1 8->1 8->1 9->1 10->2 10->2 11->3 11->3 11->5
>>>Token lb ll ( ) { lp * la ; lb ld ; lb lh ; lb lc ; lb le ; lg lk [ 101 ] ; la = lm ( " \x63 \x61 \x73 " " \x65 \x32 \x2e \x74 \x78 \x74 " , " \x72 " ) ; ln ( la == 0 )  { lf ( " \x63 \x61 \x6e \x20 \x6e " " \x6f \x74 \x20 \x6f \x70 \x65 \x72 \x6e \n " ) ; } li ( la , " \x25 \x64 " , & ld ) ; lq ( lc = 0  ; lc < ld ; lc ++ ) { le = lj ( la , lc ) ; } lo ( la ) ; }
>>>Func
METHOD ly
METHOD_RETURN ll
<operator>.assignment lm=0
<operator>.assignment lc=0
<operator>.assignment lj=0
<operator>.assignment lz=0
<operator>.assignment ln=0
<operator>.assignment lg=0
<operator>.assignment la=0
<operator>.assignment lile=0
<operator>.assignment ld=0
<operator>.assignment lb=lt("\x53\x6f\x6c\x33\x2e\x69\x6e","\x72")
lh lh(lb==lr)
BLOCK <empty> <empty>
<operator>.assignment lf=lt("\x53\x6f\x6c\x33\x2e\x6f\x75\x74","\x77")
lh lh(lf==lr)
BLOCK <empty> <empty>
lo lo(lb,"\x25\x64",&lm)
<operator>.lessThan lc<lm
<operator>.postIncrement lc++
lw lw(lb)
lw lw(lf)
IDENTIFIER lp <empty>
LITERAL 0 <empty>
lu lu("\x46\x69\x6c\x65\x20\x4e\x6f\x74\x20\x46\x6f\x75\x6e\x64")
lv lv()
IDENTIFIER lp <empty>
LITERAL 0 <empty>
lu lu("\x43\x61\x6e\x27\x74\x20\x43\x72\x65\x61\x74\x65\x20\x46\x69\x6c""\x65")
lv lv()
IDENTIFIER lp <empty>
LITERAL 0 <empty>
lt lt("\x53\x6f\x6c\x33\x2e\x69\x6e","\x72")
<operator>.equals lb==lr
lt lt("\x53\x6f\x6c\x33\x2e\x6f\x75\x74","\x77")
<operator>.equals lf==lr
>>>PDG&36 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->13 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 2->1 2->17 2->18 3->1 3->18 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 9->1 9->1 10->1 10->1 11->1 11->1 11->33 12->1 12->1 14->1 14->1 14->35 15->1 15->1 17->1 17->1 17->18 17->20 18->1 18->1 18->19 19->1 19->1 20->1 20->1 21->1 21->1 24->1 28->1 29->1 32->11 32->11 33->12 33->12 33->17 33->35 34->14 34->14 35->1 35->15 35->15 35->21
>>>Token ll ly ( ) { ll lm = 0 ; ll lc = 0 , lj = 0 , lz = 0 ; ll ln = 0 ; lk li lg = 0 ; lk li la = 0 ; lk lile = 0 ; lk li ld = 0 ; lb = lt ( " \x53 \x6f \x6c \x33 \x2e \x69 \x6e " , " \x72 " ) ; lh ( lb == lr )  { lu ( " \x46 \x69 \x6c \x65 \x20 \x4e \x6f \x74 \x20 \x46 \x6f \x75 \x6e \x64 " ) ; lv ( ) ; lp 0 ; } lf = lt ( " \x53 \x6f \x6c \x33 \x2e \x6f \x75 \x74 " , " \x77 " ) ; lh ( lf == lr )  { lu ( " \x43 \x61 \x6e \x27 \x74 \x20 \x43 \x72 \x65 \x61 \x74 \x65 \x20 \x46 \x69 \x6c " " \x65 " ) ; lv ( ) ; lp 0 ; } lo ( lb , " \x25 \x64 " , & lm ) ; ls ( lc = 0  ; lc < lm ; lc ++ ) { lo ( lb , " " " \x25 \x64 " , & ln ) ; la = 0 ; le = 0xFFFFFFFF ; lg = 0 ; ls ( lj = 0  ; lj < ln ; lj ++ ) { lo ( lb , " " " \x25 \x75 " , & ld ) ; lh ( le > ld )  { le = ld ; } lg = lg ^ ld ; la = la + ld ; } lh ( 0 == lg )  { la = la - le ; lq ( lf , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x6c \x64 \n " , lc + 1 , la ) ; } lx  { lq ( lf , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , lc + 1 ) ; } } lw ( lb ) ; lw ( lf ) ; lp 0 ; }
>>>Func
METHOD lh
METHOD_RETURN le
PARAM le lc
<operator>.assignment lb=0
IDENTIFIER lc <empty>
<operator>.postIncrement ld++
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 3->1 3->1 5->1 5->1
>>>Token le lh ( le lc ) { le ld , lb , la ; lb = 0 ; lf ( ld = 0  ; lc ; ld ++ ) { la = lc % 10 ; la *= la ; lb += la ; lc /= 10 ; } lg lb ; }
>>>Func
METHOD lx
METHOD_RETURN lt
<operator>.assignment lw[]={' ' 'Q' 'W' 'E' 'R' 'A' 'S' 'D' 'F'}
<operator>.lessEqualsThan la<=8
<operator>.postIncrement la++
li li("\x25\x64",&lo)
<operator>.lessEqualsThan lk<=lo
<operator>.postIncrement lk++
IDENTIFIER ly <empty>
LITERAL 0 <empty>
<operator>.arrayInitializer {' ' 'Q' 'W' 'E' 'R' 'A' 'S' 'D' 'F'}
>>>PDG&11 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 2->1 3->1 3->4 4->1 4->1 5->1 5->1 5->6 6->1 6->1 6->7 7->1 7->1 10->2 10->2 10->2 10->2 10->2 10->2 10->2 10->2 10->2
>>>Token lt lx ( ) { lv lp [ 5 ] , lq [ 5 ] , le [ 100 ] , lh [ 100 ] ; lv lw [ ] = { ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' } ; lt lk , lo , l7 , l0 , la , lb , l4 , lc , lf , lu ; ld ( la = 0  ; la <= 8 ; la ++ ) lg [ lw [ la ] ] = la ; li ( " \x25 \x64 " , & lo ) ; ld ( lk = 1  ; lk <= lo ; lk ++ ) { lc = -1 ; ld ( la = 0  ; la <= 8 ; la ++ ) ld ( lb = 0 ; lb <= 8 ; lb ++ ) ls [ la ] [ lb ] = 0 ; ld ( la = 0  ; la <= 8 ; la ++ ) ld ( lb = 0 ; lb <= 8 ; lb ++ ) lr [ la ] [ lb ] = 0 ; lt ll [ 9 ] = { 0 } ; li ( " \x25 \x64 " , & lf ) ; ld ( lb = 0  ; lb < lf ; lb ++ ) { li ( " \x25 \x73 " , lp ) ; l3 ( lp ) ; } li ( " \x25 \x64 " , & lf ) ; ld ( lb = 0  ; lb < lf ; lb ++ ) { li ( " \x25 \x73 " , lq ) ; l2 ( lq ) ; } li ( " \x25 \x64 " , & lu ) ; li ( " \x25 \x73 " , le ) ; ld ( lb = 0  ; lb < l1 ( le ) ; lb ++ ) { lj ( lc != -1 && ( lf = ls [ lg [ lh [ lc ] ] ] [ lg [ le [ lb ] ] ] ) )  { lh [ lc ] = lf ; } ln lj ( lc != -1 && ( lf = ls [ lg [ lh [ lc ] ] ] [ lg [ le [ lb ] ] ] ) ) { lh [ lc ] = lf ; } ln  { ld ( la = 1  ; la <= 8 ; la ++ ) { lj ( ll [ la ] ) { lj ( lr [ la ] [ lg [ le [ lb ] ] ] || lr [ lg [ le [ lb ] ] ] [ la ] )  { l5 ( ll , lz ( ll ) ) ; lc = -1 ; l6 ; } } } lj ( la == 9 )  { lh [ ++ lc ] = le [ lb ] ; ll [ lg [ le [ lb ] ] ] = 1 ; } } } lj ( lc != -1 )  lm ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " " \x25 \x63 " , lk , lh [ 0 ] ) ; ln lm ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " " \x5b " , lk ) ; ld ( la = 1  ; la <= lc ; la ++ ) lm ( " \x2c \x20 \x25 \x63 " , lh [ la ] ) ; lm ( " \x5d " " \n " ) ; } ly 0 ; }
>>>Func
METHOD lj
METHOD_RETURN le
PARAM lf lc[]
PARAM le la
PARAM lf ld[][4]
PARAM lf li
<operator>.assignment lb=0
<operator>.lessThan lb<li
<operator>.postIncrement lb++
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->1 4->1 5->7 6->1 6->7 7->1 7->1 7->8 8->1 8->1
>>>Token le lj ( lf lc [ ] , le la , lf ld [ ] [ 4 ] , lf li ) { le lb = 0 ; ll ( lb = 0  ; lb < li ; lb ++ ) { lh ( la < 2 ) lg la ; lh ( ( ( lc [ la - 2 ] == ld [ lb ] [ 0 ] ) && ( lc [ la - 1 ] == ld [ lb ] [ 1 ] ) ) || ( ( lc [ la - 1 ] == ld [ lb ] [ 0 ] ) && ( lc [ la - 2 ] == ld [ lb ] [ 1 ] ) ) )  { lc [ la - 2 ] = ld [ lb ] [ 2 ] ; lc [ la - 1 ] = 0 ; la -- ; } lk lm ; } lg la ; }
>>>Func
METHOD lo
METHOD_RETURN le
PARAM lg*lf
PARAM lg*ld
<operator>.assignment lc=li(lf)
<operator>.assignment lj=li(ld)
<operator>.logicalAnd la<lc&&lb<lj
<operator>.expressionList lb++ la++
ln ln(la==lc)
<operator>.minus -lc
<operator>.minus -1
li li(lf)
li li(ld)
<operator>.lessThan la<lc
<operator>.lessThan lb<lj
<operator>.postIncrement lb++
<operator>.postIncrement la++
<operator>.equals la==lc
>>>PDG&18 0->2 0->3 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->11 3->12 4->1 4->1 4->13 5->1 5->1 5->1 5->14 6->1 6->1 6->1 7->1 7->1 7->1 8->1 8->1 9->1 9->1 10->1 11->1 11->4 12->1 12->5 13->6 13->6 13->14 13->16 13->17 14->1 14->6 14->6 14->15 15->1 15->7 16->7 16->17 17->1 17->8 17->8 17->9
>>>Token le lo ( lg * lf , lg * ld ) { le lb , la ; le lc = li ( lf ) , lj = li ( ld ) ; ll ( lb = 0 , la = 0  ; la < lc && lb < lj ; lb ++ , la ++ ) { lm ( ld [ lb ] != lf [ la ] )  { lb -= la - 1 ; la = 0 ; } } ln ( la == lc ) lh lb - lc ; lk lh -1 ; }
>>>Func
METHOD lq
METHOD_RETURN lm
PARAM ls
lg lg("\x25\x64",&ll)
<operator>.lessEqualsThan le<=ll
<operator>.postIncrement le++
IDENTIFIER lr <empty>
LITERAL 0 <empty>
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token lm lq ( ls ) { lm ll , ld [ 2 ] [ 4 ] [ 4 ] , le , la , lb , lh , li , lf , lj ; lg ( " \x25 \x64 " , & ll ) ; lc ( le = 1  ; le <= ll ; le ++ ) { lf = -1 ; lg ( " \x25 \x64 " , & lh ) ; lc ( la = 0  ; la < 4 ; la ++ ) lc ( lb = 0 ; lb < 4 ; lb ++ ) lg ( " \x25 \x64 " , & ld [ 0 ] [ la ] [ lb ] ) ; lg ( " \x25 \x64 " , & li ) ; lc ( la = 0  ; la < 4 ; la ++ ) lc ( lb = 0 ; lb < 4 ; lb ++ ) lg ( " \x25 \x64 " , & ld [ 1 ] [ la ] [ lb ] ) ; lc ( la = 0  ; la < 4 ; la ++ ) { lc ( lb = 0  ; lb < 4 ; lb ++ ) { lk ( ld [ 0 ] [ lh - 1 ] [ la ] == ld [ 1 ] [ li - 1 ] [ lb ] )  { lf ++ ; lj = ld [ 0 ] [ lh - 1 ] [ la ] ; } } } lo ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , le ) ; lk ( ! lf )  lo ( " \x25 \x64 \n " , lj ) ; lp lk ( lf > 0 )  ln ( " \x42 \x61 \x64 \x20 \x6d " " \x61 \x67 \x69 \x63 \x69 \x61 \x6e \x21 " ) ; lp ln ( " \x56 \x6f \x6c \x75 \x6e \x74 " " \x65 \x65 \x72 \x20 \x63 \x68 \x65 \x61 \x74 \x65 \x64 \x21 " ) ; } lr 0 ; }
>>>Func
METHOD li
METHOD_RETURN lb
PARAM lb lg
PARAM lj*ld[]
<operator>.assignment lc=0
<operator>.lessThan la<ld[1][0]
<operator>.postIncrement la++
le le("\x53\x75\x6d""\x20\x69\x73\x3a\x20\x25\x64\n",lc)
IDENTIFIER lf <empty>
LITERAL 0 <empty>
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 3->1 4->1 4->7 5->1 5->1 5->6 6->1 6->1 7->1 7->1
>>>Token lb li ( lb lg , lj * ld [ ] ) { lb la ; lb lc = 0 ; lk ( la = 0  ; la < ld [ 1 ] [ 0 ] ; la ++ ) { lh ( lg < 2 ) { le ( " \x55 \x73 \x61 \x67 \x65 \x3a \x20 \x70 \x72 \x6f \x67 \x72 \x61 \x6d \x2d \x6e " " \x61 \x6d \x65 \x20 \x63 \x68 \x61 \x72 \n " ) ; lf 1 ; } lc += la ; } le ( " \x53 \x75 \x6d " " \x20 \x69 \x73 \x3a \x20 \x25 \x64 \n " , lc ) ; lf 0 ; }
>>>Func
METHOD lh
METHOD_RETURN lm
PARAM lj*la
lg lg(la->lc==0)
IDENTIFIER li <empty>
<operator>.postDecrement la->lc--
<operator>.assignment lf= * ((la->lb)+la->lc)
<operator>.assignment * ((la->lb)+la->lc)= * (la->lb)
<operator>.assignment * (la->lb)=lf
lk lk(la,0)
lg lg(4*la->lc<=la->ld)
BLOCK <empty> <empty>
<operator>.assignmentDivision la->ld/=2
<operator>.assignment (la->lb)=(le* )ln((la->lb) (la->ld) *ll(le))
<operator>.equals la->lc==0
<operator>.lessEqualsThan 4*la->lc<=la->ld
<operator>.addition (la->lb)+la->lc
<operator>.addition (la->lb)+la->lc
<operator>.multiplication 4*la->lc
<operator>.cast (le* )ln((la->lb) (la->ld) *ll(le))
ln ln((la->lb) (la->ld) *ll(le))
<operator>.multiplication (la->ld) *ll(le)
ll ll(le)
>>>PDG&23 0->2 0->4 0->8 0->9 0->11 0->12 0->14 0->18 0->22 2->9 3->1 3->1 5->1 5->16 5->17 5->18 6->1 6->8 7->1 7->1 8->1 8->1 8->1 8->20 9->1 9->1 10->1 10->1 12->1 12->21 13->1 13->1 13->1 14->3 14->3 14->5 15->1 15->10 15->10 15->12 18->1 18->15 18->15 19->1 20->1 20->13 20->13 20->19 20->19 21->1 21->1 21->20 21->20 22->1 22->21
>>>Token lm lh ( lj * la ) { lg ( la -> lc == 0 ) li ; la -> lc -- ; le lf = * ( ( la -> lb ) + la -> lc ) ; * ( ( la -> lb ) + la -> lc ) = * ( la -> lb ) ; * ( la -> lb ) = lf ; lk ( la , 0 ) ; lg ( 4 * la -> lc <= la -> ld )  { la -> ld /= 2 ; ( la -> lb ) = ( le * ) ln ( ( la -> lb ) , ( la -> ld ) * ll ( le ) ) ; } }
>>>Func
METHOD lv
METHOD_RETURN ls
lt lt("\x31\x31\x2e\x69\x6e","\x72",l0)
lt lt("\x34\x2e\x69""\x6e","\x77",lz)
lh lh("\x25\x64",&lq)
<operator>.lessEqualsThan ll<=lq
<operator>.postIncrement ll++
IDENTIFIER lx <empty>
LITERAL 0 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 2->1 3->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token ls lv ( ) { ls la , lj , lo , lq , ll , lf , lb , lp , ly , lr , lg [ 100 ] ; lw li [ 100 ] , lk [ 100 ] , le [ 100 ] , lc [ 100 ] ; lt ( " \x31 \x31 \x2e \x69 \x6e " , " \x72 " , l0 ) ; lt ( " \x34 \x2e \x69 " " \x6e " , " \x77 " , lz ) ; lh ( " \x25 \x64 " , & lq ) ; ln ( ll = 1  ; ll <= lq ; ll ++ ) { lh ( " \x25 " " \x64 " , & lp ) ; ld ( lp != 0 )  lh ( " \x25 \x73 " , li ) ; lh ( " \x25 \x64 " , & lo ) ; ld ( lo != 0 )  lh ( " \x25 \x73 " , lk ) ; lh ( " \x25 \x64 " , & lr ) ; lh ( " \x25 \x73 " , le ) ; ln ( la = 0  ; la <= 99 ; la ++ ) { lc [ la ] = ' \0 ' ; lg [ la ] = 0 ; } lf = 1 ; lc [ lf ] = le [ 0 ] ; lb = lf ; lg [ le [ 0 ] - ' ' ] = 1 ; ln ( la = 1  ; la < lr ; la ++ ) { lg [ le [ la ] - ' ' ] = 1 ; lj = 0 ; ld ( lp == 1 )  { ld ( lc [ lb ] != ' \0 ' )  ld ( ( li [ 0 ] == le [ la ] && li [ 1 ] == lc [ lb ] ) || ( li [ 1 ] == le [ la ] && li [ 0 ] == lc [ lb ] ) )  { lc [ lb ] = li [ 2 ] ; lj = 1 ; } } ld ( lo == 1 && lj == 0 )  { ld ( lg [ lk [ 0 ] - ' ' ] == 1 && lg [ lk [ 1 ] - ' ' ] == 1 )  { lb ++ ; lf = lb ; lg [ lk [ 0 ] - ' ' ] = 0 ; lg [ lk [ 1 ] - ' ' ] = 0 ; lj = 1 ; } } ld ( lj == 0 )  { ld ( lc [ lb ] != ' \0 ' )  { lc [ lb + 1 ] = le [ la ] ; lb ++ ; } lu lc [ lb ] = le [ la ] ; } } lm ( " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , ll ) ; ld ( lc [ lf ] != ' \0 ' )  lm ( " \x25 " " \x63 " , lc [ lf ] ) ; ln ( la = lf + 1  ; la <= lb ; la ++ ) lm ( " \x2c \x20 \x25 \x63 " , lc [ la ] ) ; lm ( " \x5d \n " ) ; } lx 0 ; }
>>>Func
METHOD lj
METHOD_RETURN le
PARAM lg ld
lh lh(ld)
BLOCK <empty> <empty>
IDENTIFIER lc <empty>
LITERAL 'Q' <empty>
IDENTIFIER lb <empty>
IDENTIFIER lc <empty>
LITERAL 'W' <empty>
IDENTIFIER lb <empty>
IDENTIFIER lc <empty>
LITERAL 'E' <empty>
IDENTIFIER lb <empty>
IDENTIFIER lc <empty>
LITERAL 'R' <empty>
IDENTIFIER lb <empty>
IDENTIFIER lc <empty>
LITERAL 'A' <empty>
IDENTIFIER lb <empty>
IDENTIFIER lc <empty>
LITERAL 'S' <empty>
IDENTIFIER lb <empty>
IDENTIFIER lc <empty>
LITERAL 'D' <empty>
IDENTIFIER lb <empty>
IDENTIFIER lc <empty>
LITERAL 'F' <empty>
IDENTIFIER lb <empty>
<operator>.assignment la=-1
IDENTIFIER lb <empty>
<operator>.minus -1
>>>PDG&32 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->31 2->3 3->1 3->1 29->1 29->1 29->1 31->29
>>>Token le lj ( lg ld ) { le la ; lh ( ld ) { lc ' ' : la = 0 ; lb ; lc ' ' : la = 1 ; lb ; lc ' ' : la = 2 ; lb ; lc ' ' : la = 3 ; lb ; lc ' ' : la = 4 ; lb ; lc ' ' : la = 5 ; lb ; lc ' ' : la = 6 ; lb ; lc ' ' : la = 7 ; lb ; li : la = -1 ; lb ; } lf la ; }
>>>Func
METHOD lg
METHOD_RETURN ld
lb lb(lc(la("\x28\x41\x2f\x28\x42\x2d\x43\x29\x2a\x44\x2b\x45""\x29"),"\x41\x42\x43\x2d\x2f\x44\x2a\x45\x2b")==0)
lb lb(lc(la("\x37""\x2d\x28\x32\x2a\x33\x2b\x35\x29\x2a\x28\x38\x2d\x34\x2f\x32\x29"),"""\x37\x32\x33\x2a\x35\x2b\x38\x34\x32\x2f\x2d\x2a\x2d")==0)
le le("\x41""\x6c\x6c\x20\x74\x65\x73\x74\x73\x20\x68\x61\x76\x65\x20\x73\x75\x63""\x63\x65\x73\x73\x66\x75\x6c\x6c\x79\x20\x70\x61\x73\x73\x65\x64\x21""\n")
<operator>.equals lc(la("\x28\x41\x2f\x28\x42\x2d\x43\x29\x2a\x44\x2b\x45""\x29"),"\x41\x42\x43\x2d\x2f\x44\x2a\x45\x2b")==0
<operator>.equals lc(la("\x37""\x2d\x28\x32\x2a\x33\x2b\x35\x29\x2a\x28\x38\x2d\x34\x2f\x32\x29"),"""\x37\x32\x33\x2a\x35\x2b\x38\x34\x32\x2f\x2d\x2a\x2d")==0
lc lc(la("\x28\x41\x2f\x28\x42\x2d\x43\x29\x2a\x44\x2b\x45""\x29"),"\x41\x42\x43\x2d\x2f\x44\x2a\x45\x2b")
lc lc(la("\x37""\x2d\x28\x32\x2a\x33\x2b\x35\x29\x2a\x28\x38\x2d\x34\x2f\x32\x29"),"""\x37\x32\x33\x2a\x35\x2b\x38\x34\x32\x2f\x2d\x2a\x2d")
la la("\x28\x41\x2f\x28\x42\x2d\x43\x29\x2a\x44\x2b\x45""\x29")
la la("\x37""\x2d\x28\x32\x2a\x33\x2b\x35\x29\x2a\x28\x38\x2d\x34\x2f\x32\x29")
>>>PDG&11 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 3->1 3->1 4->1 5->1 5->2 5->2 6->1 6->3 6->3 7->1 7->5 7->5 8->1 8->6 8->6 9->7 10->8
>>>Token lf ld lg ( ) { lb ( lc ( la ( " \x28 \x41 \x2f \x28 \x42 \x2d \x43 \x29 \x2a \x44 \x2b \x45 " " \x29 " ) , " \x41 \x42 \x43 \x2d \x2f \x44 \x2a \x45 \x2b " ) == 0 ) ; lb ( lc ( la ( " \x37 " " \x2d \x28 \x32 \x2a \x33 \x2b \x35 \x29 \x2a \x28 \x38 \x2d \x34 \x2f \x32 \x29 " ) , " " " \x37 \x32 \x33 \x2a \x35 \x2b \x38 \x34 \x32 \x2f \x2d \x2a \x2d " ) == 0 ) ; le ( " \x41 " " \x6c \x6c \x20 \x74 \x65 \x73 \x74 \x73 \x20 \x68 \x61 \x76 \x65 \x20 \x73 \x75 \x63 " " \x63 \x65 \x73 \x73 \x66 \x75 \x6c \x6c \x79 \x20 \x70 \x61 \x73 \x73 \x65 \x64 \x21 " " \n " ) ; }
>>>Func
METHOD lv
METHOD_RETURN lf
lh lh("\x25\x64",&lu)
<operator>.lessEqualsThan lk<=lu
<operator>.postIncrement lk++
IDENTIFIER lw <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lf lv ( ) { lf lk ; lf lu ; lf lb , la ; lf ls ; lo lt [ 1000 ] ; lo li [ 100 ] [ 4 ] ; lo lm [ 100 ] [ 3 ] ; lo ld [ 1000 ] ; lf lq , ln ; lf lc , lg ; lf lj [ 26 ] ; lh ( " \x25 \x64 " , & lu ) ; le ( lk = 1  ; lk <= lu ; lk ++ ) { lh ( " \x25 \x64 " , & lq ) ; le ( lb = 0  ; lb < lq ; lb ++ ) lh ( " \x25 \x73 " , li [ lb ] ) ; lh ( " \x25 \x64 " , & ln ) ; le ( lb = 0  ; lb < ln ; lb ++ ) lh ( " \x25 \x73 " , lm [ lb ] ) ; lh ( " \x25 \x64 " , & ls ) ; lh ( " \x25 \x73 " , lt ) ; lc = 0 ; le ( lb = 0  ; lb < ls ; lb ++ ) { ld [ lc ++ ] = lt [ lb ] ; lg = 1 ; lx ( lg ) { lg = 0 ; ll ( lc <= 1 ) lr ; le ( la = 0  ; la < lq ; la ++ ) ll ( ( ld [ lc - 1 ] == li [ la ] [ 0 ] && ld [ lc - 2 ] == li [ la ] [ 1 ] ) || ( ld [ lc - 1 ] == li [ la ] [ 1 ] && ld [ lc - 2 ] == li [ la ] [ 0 ] ) ) { lc -- ; lc -- ; ld [ lc ++ ] = li [ la ] [ 2 ] ; lg = 1 ; lr ; } ll ( lg ) lz ; ly ( lj , 0 , l0 ( lj ) ) ; le ( la = 0  ; la < lc ; la ++ ) lj [ ld [ la ] - ' ' ] = 1 ; le ( la = 0  ; la < ln ; la ++ ) ll ( lj [ lm [ la ] [ 0 ] - ' ' ] && lj [ lm [ la ] [ 1 ] - ' ' ] ) { lc = 0 ; lg = 1 ; lr ; } } } lp ( " \x43 \x61 \x73 \x65 " " \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lk ) ; le ( lb = 0  ; lb < lc ; lb ++ ) { ll ( lb != 0 ) lp ( " " " \x2c \x20 " ) ; lp ( " \x25 \x63 " , ld [ lb ] ) ; } lp ( " \x5d \n " ) ; } lw 0 ; }
>>>Func
METHOD lp
METHOD_RETURN la
PARAM la lw
PARAM ll*lq[]
lf lf("\x25\x64",&lg)
<operator>.lessThan lc<lg
<operator>.preIncrement ++lc
IDENTIFIER lt <empty>
LITERAL 0 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token la lp ( la lw , ll * lq [ ] ) { la lg ; lf ( " \x25 \x64 " , & lg ) ; li ( la  lc = 0 ; lc < lg ; ++ lc ) { la le ; la lb ; ln lm ld [ 15 ] ; lf ( " \x25 \x64 " , & le ) ; li ( lb = 0  ; lb < le ; ++ lb ) { lf ( " " " \x25 \x75 " , & ( ld [ lb ] . ls ) ) ; ld [ lb ] . lr = lv ; } la lj = lh ( ld , le ) ; lu ( lj != 0 )  { lk ( " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x75 \n " , lc + 1 , lh ( ld , le ) ) ; } lo  { lk ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , lc + 1 ) ; } } lt 0 ; }
>>>Func
METHOD lj
METHOD_RETURN le
PARAM le la
PARAM le ld
<operator>.assignment lc=0
<operator>.assignment lb=0
<operator>.assignment lf=0
lh lh(la!=0||ld!=0)
BLOCK <empty> <empty>
li li(lb!=0)
<operator>.assignment lg[lc++]=lb
<operator>.preDecrement --lc
lh lh(lc>=0)
<operator>.assignment lf=lf*10+lg[lc--]
<operator>.assignment lg[lc++]=(la%10+ld%10+lb)%2
<operator>.assignment lb=(la%10+ld%10+lb)/2
<operator>.assignment la=la/10
<operator>.assignment ld=ld/10
<operator>.logicalOr la!=0||ld!=0
<operator>.notEquals lb!=0
<operator>.greaterEqualsThan lc>=0
<operator>.addition lf*10+lg[lc--]
<operator>.notEquals la!=0
<operator>.notEquals ld!=0
<operator>.modulo (la%10+ld%10+lb)%2
<operator>.division (la%10+ld%10+lb)/2
<operator>.division la/10
<operator>.division ld/10
<operator>.postIncrement lc++
<operator>.multiplication lf*10
<operator>.postIncrement lc++
<operator>.addition la%10+ld%10+lb
<operator>.addition la%10+ld%10+lb
<operator>.postDecrement lc--
<operator>.addition la%10+ld%10
<operator>.addition la%10+ld%10
<operator>.modulo la%10
<operator>.modulo ld%10
<operator>.modulo la%10
<operator>.modulo ld%10
>>>PDG&40 0->2 0->3 0->4 0->5 0->6 0->8 0->10 0->11 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->36 0->37 0->38 0->39 2->22 3->23 3->37 4->1 4->30 5->1 5->24 5->25 5->31 5->32 6->1 6->29 7->1 7->1 9->1 9->1 10->1 10->1 10->1 11->1 11->20 12->1 12->1 13->1 13->1 13->1 14->1 14->1 15->1 15->1 15->19 16->1 16->1 16->1 17->1 17->1 17->1 18->1 18->1 18->7 18->7 19->9 19->9 19->10 20->12 20->12 20->33 21->1 21->1 22->18 22->18 22->23 22->36 23->18 23->18 23->37 24->14 24->14 25->1 25->15 25->15 26->16 26->16 27->17 27->17 28->11 29->13 29->13 29->21 29->21 30->28 32->1 33->1 35->1 35->1 36->24 36->24 36->31 36->31 36->34 36->34 36->38 37->24 37->24 37->31 37->31 37->34 37->34 37->39 38->25 38->25 38->26 38->32 38->32 38->35 38->35 39->25 39->25 39->27 39->32 39->32 39->35 39->35
>>>Token le lj ( le la , le ld ) { le lc = 0 , lb = 0 , lg [ 20 ] ; le lf = 0 ; lh ( la != 0 || ld != 0 )  { lg [ lc ++ ] = ( la % 10 + ld % 10 + lb ) % 2 ; lb = ( la % 10 + ld % 10 + lb ) / 2 ; la = la / 10 ; ld = ld / 10 ; } li ( lb != 0 ) lg [ lc ++ ] = lb ; -- lc ; lh ( lc >= 0 ) lf = lf * 10 + lg [ lc -- ] ; lk lf ; }
>>>Func
METHOD lo
METHOD_RETURN le
lh lh("\x25\x64",&li)
<operator>.lessThan ld<li
<operator>.postIncrement ld++
IDENTIFIER lp <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token le lo ( ) { le ld , la ; le li , lg ; le lb [ 1000 ] , lf ; le lc ; lh ( " \x25 \x64 " , & li ) ; lj ( ld = 0  ; ld < li ; ld ++ ) { lf = 0 ; lc = 0 ; lh ( " \x25 \x64 " , & lg ) ; lj ( la = 0  ; la < lg ; la ++ ) { lh ( " " " \x25 \x64 " , & lb [ la ] ) ; lf += lb [ la ] ; lc = ( ( ~ lc ) | ( ~ lb [ la ] ) ) & ( lc | lb [ la ] ) ; } lr ( lb , lg , ll ( le ) , lm ) ; lf -= lb [ 0 ] ; lq ( lc != 0 )  lk ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 " " \x64 \x3a \x20 \x4e \x4f \n " , ld + 1 ) ; ln lk ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 " " \x64 \x3a \x20 \x25 \x64 \n " , ld + 1 , lf ) ; } lp 0 ; }
>>>Func
METHOD lp
METHOD_RETURN lh
PARAM lh
lk lk(le 0 lf(le))
lk lk(ld 0 lf(ld))
lc lc("\x25\x64",&lj)
<operator>.lessThan lb<lj
<operator>.postIncrement lb++
lc lc("\x25\x64",&lg)
<operator>.lessThan lb<lg
<operator>.postIncrement lb++
lc lc("\x25\x64",&lo)
lc lc("""\x25\x73",ll)
lf lf(le)
lf lf(ld)
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 3->1 3->1 4->1 4->1 4->1 5->1 5->1 5->6 6->1 6->1 6->7 7->9 8->1 8->1 8->9 9->1 9->1 9->10 10->1 10->1 11->1 11->1 12->1 12->1 13->3 14->4
>>>Token lh lp ( lh ) { ln lb ; lm la [ 3 ] ; lk ( le , 0 , lf ( le ) ) ; lk ( ld , 0 , lf ( ld ) ) ; lc ( " \x25 \x64 " , & lj ) ; li ( lb = 0  ; lb < lj ; lb ++ ) { lc ( " \x25 \x73 " , la ) ; le [ la [ 0 ] ] [ la [ 1 ] ] = la [ 2 ] ; le [ la [ 1 ] ] [ la [ 0 ] ] = la [ 2 ] ; } lc ( " \x25 \x64 " , & lg ) ; li ( lb = 0  ; lb < lg ; lb ++ ) { lc ( " \x25 " " \x73 " , la ) ; ld [ la [ 0 ] ] = la [ 1 ] ; ld [ la [ 1 ] ] = la [ 0 ] ; } lc ( " \x25 \x64 " , & lo ) ; lc ( " " " \x25 \x73 " , ll ) ; }
>>>Func
METHOD l0
METHOD_RETURN lz
PARAM la lo
<operator>.assignment lc=lt(2,lo)
<operator>.assignment lh=10
<operator>.lessThan le<lh
<operator>.postIncrement le++
lb lb("\x2d\x2d\x2d\x2d\x2d""\x2d\x2d\x20\x54\x65\x73\x74\x20\x31\x20\x2d\x2d\x2d\x2d\x2d\x2d\x2d""\n")
lb lb("\x4d\x6f\x64\x65\x6c\x20\x62\x65\x66\x6f\x72\x65\x20\x66""\x69\x74\x3a\x20\x25\x73\n" lk(&lc))
lx lx(&lc,lg,lj,lh)
lb lb("\x4d\x6f""\x64\x65\x6c\x20\x61\x66\x74\x65\x72\x20\x66\x69\x74\x3a\x20\x25\x73""\n" lk(&lc))
<operator>.assignment lm[]={5 -3}
<operator>.assignment ld=ll(&lc,lm,lq)
lb lb("\x50\x72\x65\x64""\x69\x63\x74\x20\x66\x6f\x72\x20\x78\x3d\x28\x35\x2c\x2d\x33\x29\x3a""\x20\x25\x20\x64\n",ld)
ln ln(ld==-1)
lb lb("\x20\x2e\x2e\x2e\x70\x61\x73""\x73\x65\x64\n")
<operator>.assignment lp[]={5 8}
<operator>.assignment ld=ll(&lc,lp,lq)
lb lb("\x50\x72\x65\x64""\x69\x63\x74\x20\x66\x6f\x72\x20\x78\x3d\x28\x35\x2c\x20\x38\x29\x3a""\x20\x25\x20\x64\n",ld)
ln ln(ld==1)
lb lb("\x20\x2e\x2e\x2e\x70\x61\x73""\x73\x65\x64\n")
lu lu(lg)
ls ls(&lc)
lt lt(2,lo)
lk lk(&lc)
lk lk(&lc)
<operator>.arrayInitializer {5 -3}
ll ll(&lc,lm,lq)
<operator>.equals ld==-1
<operator>.arrayInitializer {5 8}
ll ll(&lc,lp,lq)
<operator>.equals ld==1
<operator>.minus -3
<operator>.minus -1
>>>PDG&34 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->13 0->15 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 2->23 3->1 3->1 3->1 3->9 3->22 3->24 3->25 3->27 3->30 4->1 4->5 5->1 5->6 5->9 6->1 6->1 7->1 8->1 9->1 9->1 9->1 9->21 9->22 9->25 9->27 9->30 10->1 10->1 11->1 11->1 11->27 12->1 12->1 12->13 13->1 13->28 14->1 14->1 16->1 16->1 16->30 17->1 17->1 17->18 18->1 18->31 19->1 19->1 20->1 21->1 21->1 22->1 22->1 23->1 23->3 23->3 24->8 24->9 24->22 24->25 24->27 24->30 25->10 25->22 25->27 25->30 26->1 26->11 26->11 27->1 27->12 27->12 27->12 27->22 27->30 27->30 28->1 28->14 28->14 29->16 29->16 30->1 30->1 30->17 30->17 30->17 30->22 31->1 31->19 31->19 32->26 33->28
>>>Token lz l0 ( la lo ) { ly l1 lc = lt ( 2 , lo ) ; li lf lh = 10 ; li la lr [ 10 ] [ 2 ] = { { 0 , 1 } , { 1 , -2 } , { 2 , 3 } , { 3 , -1 } , { 4 , 1 } , { 6 , -5 } , { -7 , -3 } , { -8 , 5 } , { -9 , 2 } , { -10 , -15 } } ; la * * lg = ( la * * ) lw ( lh * lv ( la *  ) ) ; li lf lj [ 10 ] = { 1 , -1 , 1 , -1 , -1 , -1 , 1 , 1 , 1 , -1 } ; l2 ( lf  le = 0 ; le < lh ; le ++ ) { lg [ le ] = ( la * ) lr [ le ] ; } lb ( " \x2d \x2d \x2d \x2d \x2d " " \x2d \x2d \x20 \x54 \x65 \x73 \x74 \x20 \x31 \x20 \x2d \x2d \x2d \x2d \x2d \x2d \x2d " " \n " ) ; lb ( " \x4d \x6f \x64 \x65 \x6c \x20 \x62 \x65 \x66 \x6f \x72 \x65 \x20 \x66 " " \x69 \x74 \x3a \x20 \x25 \x73 \n " , lk ( & lc ) ) ; lx ( & lc , lg , lj , lh ) ; lb ( " \x4d \x6f " " \x64 \x65 \x6c \x20 \x61 \x66 \x74 \x65 \x72 \x20 \x66 \x69 \x74 \x3a \x20 \x25 \x73 " " \n " , lk ( & lc ) ) ; la lm [ ] = { 5 , -3 } ; lf ld = ll ( & lc , lm , lq ) ; lb ( " \x50 \x72 \x65 \x64 " " \x69 \x63 \x74 \x20 \x66 \x6f \x72 \x20 \x78 \x3d \x28 \x35 \x2c \x2d \x33 \x29 \x3a " " \x20 \x25 \x20 \x64 \n " , ld ) ; ln ( ld == -1 ) ; lb ( " \x20 \x2e \x2e \x2e \x70 \x61 \x73 " " \x73 \x65 \x64 \n " ) ; la lp [ ] = { 5 , 8 } ; ld = ll ( & lc , lp , lq ) ; lb ( " \x50 \x72 \x65 \x64 " " \x69 \x63 \x74 \x20 \x66 \x6f \x72 \x20 \x78 \x3d \x28 \x35 \x2c \x20 \x38 \x29 \x3a " " \x20 \x25 \x20 \x64 \n " , ld ) ; ln ( ld == 1 ) ; lb ( " \x20 \x2e \x2e \x2e \x70 \x61 \x73 " " \x73 \x65 \x64 \n " ) ; lu ( lg ) ; ls ( & lc ) ; }
>>>Func
METHOD l3
METHOD_RETURN lu
<operator>.assignment *lg=lz("\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65""\x6d\x70\x74\x30\x2e\x69\x6e","\x72")
<operator>.assignment *lm=lz("\x6f\x75\x74\x70\x75""\x74\x2e\x74\x78\x74","\x77")
lh lh(lg,"\x25\x64",&lx)
<operator>.lessThan ln<lx
<operator>.postIncrement ln++
lz lz("\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65""\x6d\x70\x74\x30\x2e\x69\x6e","\x72")
lz lz("\x6f\x75\x74\x70\x75""\x74\x2e\x74\x78\x74","\x77")
>>>PDG&9 0->4 0->5 0->6 0->7 0->8 2->1 2->1 2->4 3->1 3->1 3->1 4->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1 7->2 7->2 8->3 8->3
>>>Token lu l3 ( ) { l0 * lg = lz ( " \x42 \x2d \x73 \x6d \x61 \x6c \x6c \x2d \x61 \x74 \x74 \x65 " " \x6d \x70 \x74 \x30 \x2e \x69 \x6e " , " \x72 " ) ; l0 * lm = lz ( " \x6f \x75 \x74 \x70 \x75 " " \x74 \x2e \x74 \x78 \x74 " , " \x77 " ) ; lu ln , la , lp , li , lk ; l4 ld [ 4 ] , lj [ lt ] , le [ lt ] ; lh ( lg , " \x25 \x64 " , & lx ) ; ll ( ln = 0  ; ln < lx ; ln ++ ) { lb = 0 ; l2 ( & lf , 0 , l7 ( lf ) ) ; lh ( lg , " \x25 \x64 " , & ly ) ; ll ( la = 0  ; la < ly ; la ++ ) { lh ( lg , " \x25 \x73 " , & ld ) ; li = lc ( ld [ 0 ] ) ; lk = lc ( ld [ 1 ] ) ; lf [ li ] [ lk ] . lq = ld [ 2 ] ; lf [ lk ] [ li ] . lq = ld [ 2 ] ; } lh ( lg , " " " \x25 \x64 " , & lw ) ; ll ( la = 0  ; la < lw ; la ++ ) { lh ( lg , " \x25 \x73 " , & ld ) ; li = lc ( ld [ 0 ] ) ; lk = lc ( ld [ 1 ] ) ; lf [ li ] [ lk ] . ls = ' ' ; lf [ lk ] [ li ] . ls = ' ' ; } lh ( lg , " \x25 \x64 " , & l1 ) ; lh ( lg , " \x25 \x73 " , lj ) ; ll ( la = 0  ; la < l1 ; la ++ ) { lo ( lb == 0 ) { le [ lb ++ ] = lj [ la ] ; l6 ; } lo ( ( 0 != lf [ lc ( le [ lb - 1 ] ) ] [ lc ( lj [ la ] ) ] . lq ) )  { le [ lb - 1 ] = lf [ lc ( le [ lb - 1 ] ) ] [ lc ( lj [ la ] ) ] . lq ; } lv { ll ( lp = 0  ; lp < lb ; lp ++ ) lo ( ' ' == lf [ lc ( le [ lp ] ) ] [ lc ( lj [ la ] ) ] . ls ) { lb = 0 ; l5 ; } lo ( lb != 0 )  { le [ lb ++ ] = lj [ la ] ; } } } lr ( lm , " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , ln + 1 ) ; ll ( la = 0  ; la < lb ; la ++ ) { lo ( la == lb - 1 )  { lr ( lm , " \x25 \x63 " , le [ la ] ) ; } lv  { lr ( lm , " \x25 \x63 \x2c \x20 " , le [ la ] ) ; } } lr ( lm , " \x5d \n " ) ; } }
>>>Func
METHOD lr
METHOD_RETURN lc
lm lm("\x25\x64",&lh)
<operator>.lessEqualsThan la<=lh
<operator>.postIncrement la++
IDENTIFIER ls <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lc lr ( ) { lc la , ld , lh ; lc lj , lb , le ; lc lf ; lm ( " \x25 \x64 " , & lh ) ; ll ( la = 1  ; la <= lh ; la ++ ) { lm ( " \x25 \x64 \x20 \x25 \x64 \x20 \x25 \x64 " , & lj , & lb , & le ) ; lf = 0 ; lg ( ! ( le == 100 && lb != 100 ) && ! ( le == 0 && lb != 0 ) )  { lk ln = ( lk ) lb / 100 ; ll ( ld = lj  ; ld > 0 ; ld -- ) { lk li = ld * ln ; lg ( li == ( lc ) li )  { lf = 1 ; lp ; } } } lg ( lf ) lo ( " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " , la ) ; lq lo ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x42 \x72 \x6f \x6b \x65 " " \x6e \n " , la ) ; } ls 0 ; }
>>>Func
METHOD lg
METHOD_RETURN lj
<operator>.assignment lb[lc]={0}
<operator>.lessThan la<lc
<operator>.postIncrement la++
lh lh(lb)
<operator>.lessThan la<lc-1
<operator>.postIncrement la++
<operator>.arrayInitializer {0}
<operator>.subtraction lc-1
>>>PDG&10 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 2->1 2->5 3->1 3->4 3->9 4->6 5->1 5->1 6->1 6->1 6->7 7->1 7->1 8->2 9->1 9->6 9->6
>>>Token lf lj lg ( ) { ld lb [ lc ] = { 0 } ; le ( ld  la = 0 ; la < lc ; la ++ ) { lb [ la ] = lk ( ) % 101 ; } lh ( lb ) ; le ( ld  la = 0 ; la < lc - 1 ; la ++ ) { li ( lb [ la ] <= lb [ la + 1 ] ) ; } }
>>>Func
METHOD ln
METHOD_RETURN ld
lf lf("\x25\x64\n",&lc)
<operator>.lessThan la<lc-1
<operator>.postIncrement la++
lf lf("\x25\x75\n",&lb[lc-1])
IDENTIFIER lk <empty>
BLOCK <empty> <empty>
<operator>.subtraction li-1
<operator>.subtraction lc-1
<operator>.subtraction lc-1
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 2->9 2->10 3->1 3->4 4->1 4->1 5->1 5->1 8->1 8->1 9->3 9->3 9->10 10->1
>>>Token ld ln ( ) { ld la ; ld lc ; lf ( " \x25 \x64 \n " , & lc ) ; ll ld lb [ lc ] ; lj ( la = 0  ; la < lc - 1 ; la ++ ) { lf ( " \x25 \x75 \x20 " , & lb [ la ] ) ; } lf ( " \x25 \x75 \n " , & lb [ lc - 1 ] ) ; lh ( lm ( lb , lc ) ) { ld lg = 0 ; ld le = 2000000 ; lj ( la = 0  ; la < lc ; la ++ ) { lg += lb [ la ] ; lh ( lb [ la ] < le )  { le = lb [ la ] ; } } li lg  - le ; } lk  { li - 1 ; } }
>>>Func
METHOD lq
METHOD_RETURN le
PARAM le l0
PARAM ld* *lk
<operator>.assignment *lf=lw(lk[1],"\x72")
lm lm(!lf)
BLOCK <empty> <empty>
<operator>.assignment lg=256
<operator>.assignment *la=(ld* )lr(lg)
lj lj(&la,&lg,lf)
<operator>.assignment ll=ly(la)
<operator>.assignment lc=1
ls ls(lj(&la,&lg,lf)!=-1)
BLOCK <empty> <empty>
lm lm(lc!=(ll+1))
BLOCK <empty> <empty>
lx lx(la)
li li("\x43\x61\x6e""\x27\x74\x20\x6f\x70\x65\x6e\x20\x66\x69\x6c\x65")
IDENTIFIER lu <empty>
LITERAL 0 <empty>
lo lo(la,&lh)
<operator>.assignment lb[0]=0
lt lt(&lh,lb)
lz lz(lc,lb)
<operator>.postIncrement lc++
li li("\x57\x72\x6f\x6e\x67\x20\x6e\x75\x6d\x62\x65""\x72\x20\x6f\x66\x20\x74\x65\x73\x74\x73\x20\x72\x75\x6e\x2e\x2e\x2e""\x20\x4d\x61\x79\x20\x77\x61\x6e\x74\x20\x74\x6f\x20\x63\x68\x65\x63""\x6b\x20\x65\x76\x65\x72\x79\x74\x68\x69\x6e\x67\x20\x69\x73\x20\x6f""\x6b")
lw lw(lk[1],"\x72")
<operator>.logicalNot !lf
<operator>.cast (ld* )lr(lg)
ly ly(la)
<operator>.notEquals lj(&la,&lg,lf)!=-1
<operator>.notEquals lc!=(ll+1)
lr lr(lg)
lj lj(&la,&lg,lf)
<operator>.minus -1
<operator>.addition ll+1
>>>PDG&36 0->2 0->3 0->6 0->7 0->9 0->11 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->31 0->32 0->33 0->34 0->35 2->1 3->1 3->26 4->1 4->1 4->27 5->1 5->1 7->1 7->32 8->1 8->1 8->9 8->29 9->20 9->29 9->33 9->33 9->33 10->1 10->1 10->31 10->35 11->1 11->23 12->1 12->1 14->1 14->1 16->1 16->1 17->1 20->1 20->16 20->22 21->1 21->1 21->22 21->23 22->1 22->1 22->23 23->1 23->1 23->24 24->1 24->31 25->1 26->1 26->4 26->4 27->5 27->9 28->1 29->10 29->20 29->33 30->1 30->1 30->12 30->12 31->1 31->1 31->14 31->14 32->1 32->8 32->9 32->28 32->33 33->1 33->1 33->1 33->16 33->20 33->30 33->30 33->30 34->30 35->1
>>>Token le lq ( le l0 , ld * * lk ) { lp * lf = lw ( lk [ 1 ] , " \x72 " ) ; lm ( ! lf )  { li ( " \x43 \x61 \x6e " " \x27 \x74 \x20 \x6f \x70 \x65 \x6e \x20 \x66 \x69 \x6c \x65 " ) ; lu 0 ; } lv lg = 256 ; ld * la = ( ld * ) lr ( lg ) ; lj ( & la , & lg , lf ) ; le ll = ly ( la ) ; le lc = 1 ; ls ( lj ( & la , & lg , lf ) != -1 )  { ln lh ; lo ( la , & lh ) ; ld lb [ 256 ] ; lb [ 0 ] = 0 ; lt ( & lh , lb ) ; lz ( lc , lb ) ; lc ++ ; } lm ( lc != ( ll + 1 ) )  { li ( " \x57 \x72 \x6f \x6e \x67 \x20 \x6e \x75 \x6d \x62 \x65 " " \x72 \x20 \x6f \x66 \x20 \x74 \x65 \x73 \x74 \x73 \x20 \x72 \x75 \x6e \x2e \x2e \x2e " " \x20 \x4d \x61 \x79 \x20 \x77 \x61 \x6e \x74 \x20 \x74 \x6f \x20 \x63 \x68 \x65 \x63 " " \x6b \x20 \x65 \x76 \x65 \x72 \x79 \x74 \x68 \x69 \x6e \x67 \x20 \x69 \x73 \x20 \x6f " " \x6b " ) ; } lx ( la ) ; }
>>>Func
METHOD lu
METHOD_RETURN lb
<operator>.assignment *le=lw("\x69\x6e\x70\x75\x74\x2e\x74\x78\x74","\x72")
li li(le,"\x25\x64",&lk)
<operator>.lessThan lf<lk
<operator>.preIncrement ++lf
lx lx(le)
IDENTIFIER lv <empty>
LITERAL 0 <empty>
lw lw("\x69\x6e\x70\x75\x74\x2e\x74\x78\x74","\x72")
>>>PDG&10 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 2->1 2->3 3->1 3->1 3->4 3->6 4->1 4->1 4->5 5->1 5->1 6->1 6->1 9->2 9->2
>>>Token lb lu ( ) { ls * le = lw ( " \x69 \x6e \x70 \x75 \x74 \x2e \x74 \x78 \x74 " , " \x72 " ) ; lb la , ld , lk ; lb lp , lf ; lb lq [ 20 ] ; li ( le , " \x25 \x64 " , & lk ) ; lm ( lf = 0  ; lf < lk ; ++ lf ) { lb lc = -1 ; li ( le , " \x25 \x64 " , & ld ) ; lm ( la = 0  ; la < ld ; ++ la ) { li ( le , " \x25 \x64 " , & lq [ la ] ) ; } lm ( la = 1  ; la < ( 1 << ld ) - 1 ; ++ la ) { lp = la ; lb ln = -1 , lr = -1 , lg = -1 , lh = -1 ; ly ( lp , lq , ld , & ln , & lr , & lg , & lh ) ; ll ( ln == lr )  { lb lo = ( lg > lh ) ? lg : lh ; ll ( lo > lc ) lc = lo ; } } lj ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , lf + 1 ) ; ll ( lc == -1 )  { lj ( " \x4e \x4f \n " ) ; } lt  { lj ( " \x25 \x64 \n " , lc ) ; } } lx ( le ) ; lv 0 ; }
>>>Func
METHOD lp
METHOD_RETURN lo
ln ln("\x25\x64",&ll)
<operator>.lessThan lg<ll
<operator>.postIncrement lg++
IDENTIFIER lq <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lo lp ( ) { lo lh [ 1000000 ] , lf [ 1000000 ] , li , ll , lg , lk [ 100 ] , le , la , lc , lb , lj ; ln ( " \x25 \x64 " , & ll ) ; ld ( lg = 0  ; lg < ll ; lg ++ ) { ln ( " \x25 \x64 \x20 \x25 \x64 " , & le , & li ) ; ld ( la = 0  ; la < li ; la ++ ) ln ( " \x25 \x64 " , & lk [ la ] ) ; ld ( la = 0  ; la < le ; la ++ ) { lh [ la ] = 0 ; lf [ la ] = la ; } lc = -1 ; ld ( lb = 1  ; lb <= le ; lb ++ ) { lj = le + 1 - lb ; lc = ( lc + lb ) % lj ; lh [ lf [ lc ] ] = lb ; ld ( la = lc  ; la < lj ; la ++ ) lf [ la ] = lf [ la + 1 ] ; lc -- ; } lm ( " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , lg + 1 ) ; ld ( la = 0  ; la < li ; la ++ ) lm ( " \x25 " " \x64 \x20 " , lh [ lk [ la ] - 1 ] ) ; lm ( " \n " ) ; } lq 0 ; }
>>>Func
METHOD lg
METHOD_RETURN li
PARAM lc*lb
PARAM lc lf
<operator>.assignment la=0
lj lj(la<lf)
BLOCK <empty> <empty>
le le(lb[la]>=lb[la-1])
<operator>.postIncrement la++
IDENTIFIER lh <empty>
BLOCK <empty> <empty>
<operator>.lessThan la<lf
<operator>.assignment ld=lb[la-1]
<operator>.assignment lb[la-1]=lb[la]
<operator>.assignment lb[la]=ld
<operator>.postDecrement la--
le le(la==0)
<operator>.assignment la=1
<operator>.greaterEqualsThan lb[la]>=lb[la-1]
<operator>.equals la==0
<operator>.subtraction la-1
<operator>.subtraction la-1
<operator>.subtraction la-1
>>>PDG&23 0->2 0->3 0->4 0->6 0->8 0->9 0->10 0->11 0->14 0->15 0->17 0->19 0->20 0->21 0->22 2->1 2->12 2->13 2->18 3->11 4->1 4->11 5->1 5->1 7->1 7->1 8->1 8->21 11->1 11->5 11->5 11->20 12->1 12->14 13->1 13->1 14->1 14->1 14->1 15->1 15->19 16->1 16->1 17->1 17->1 18->7 18->7 18->12 18->13 19->16 19->16 20->8 21->22 22->15
>>>Token li lg ( lc * lb , lc lf ) { lc la = 0 ; lj ( la < lf )  { le ( lb [ la ] >= lb [ la - 1 ] ) la ++ ; lh  { lc ld = lb [ la - 1 ] ; lb [ la - 1 ] = lb [ la ] ; lb [ la ] = ld ; la -- ; le ( la == 0 ) la = 1 ; } } }
>>>Func
METHOD lp
METHOD_RETURN lc
PARAM ld*lf
PARAM ld le
lg lg(&la 0 lm(lc))
ll ll(lf)
<operator>.assignment lb=0
lk lk(lb!=le)
BLOCK <empty> <empty>
lo lo(&la)
<operator>.assignment lb=li()
lh lh(&la.lj,lb)
lm lm(lc)
<operator>.notEquals lb!=le
>>>PDG&14 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->12 0->13 2->5 3->13 4->1 4->1 4->9 5->1 5->1 6->1 6->13 7->1 7->1 9->1 9->1 10->1 10->1 10->11 11->1 11->1 11->1 12->1 12->4 13->1 13->7 13->7
>>>Token lc lp ( ld * lf , ld le ) { lc la ; lg ( & la , 0 , lm ( lc ) ) ; ll ( lf ) ; ld lb = 0 ; lk ( lb != le )  { lb = li ( ) ; lh ( & la . lj , lb ) ; } lo ( & la ) ; ln la ; }
>>>Func
METHOD lu
METHOD_RETURN ll
PARAM lp*lc
<operator>.assignment lb=0
<operator>.assignment la=le(lc lh(lc))
lf lf(ls==0)
<operator>.assignment lm=lg<lb?lg:lb
IDENTIFIER lq <empty>
BLOCK <empty> <empty>
<operator>.assignment lm=lb
<operator>.notEquals *ld!='\0'
<operator>.postIncrement ld++
<operator>.assignment la=le(lc,la)
le le(lc lh(lc))
<operator>.equals ls==0
<operator>.conditional lg<lb?lg:lb
lh lh(lc)
<operator>.lessThan lg<lb
le le(lc,la)
>>>PDG&19 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 0->18 2->16 3->1 3->17 4->1 4->1 4->18 5->1 5->1 6->1 6->1 9->1 9->1 9->1 10->1 10->1 10->11 11->1 11->1 12->1 12->1 12->1 13->1 13->4 13->4 13->18 14->1 14->5 14->5 15->1 15->1 16->13 17->6 17->6 17->9 17->15 17->15 18->1 18->12 18->12
>>>Token ln ll lu ( lp * lc ) { ll la ; lb = 0 ; la = le ( lc , lh ( lc ) ) ; lf ( ls == 0 ) lm = lg < lb ? lg : lb ; lq  { li lt * ld ; lm = lb ; lv ( ld = lo  ; * ld != ' \0 ' ; ld ++ ) { lr li lk = * ld ; lf ( la != lk ) ljla ; lb ++ ; la = lh ( lc ) ; } la = le ( lc , la ) ; } lj la ; }
>>>Func
METHOD lq
METHOD_RETURN ll
lm lm("\x25\x49\x36""\x34\x64",&lj)
<operator>.lessEqualsThan lc<=lj
<operator>.postIncrement lc++
IDENTIFIER lr <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token ll lq ( ) { lk lk  ll lb , la , ld , lu , lt , lh , lc , lp , lo , ln , ls , lj ; lm ( " \x25 \x49 \x36 " " \x34 \x64 " , & lj ) ; lv ( lc = 1  ; lc <= lj ; lc ++ ) { lm ( " \x25 \x49 \x36 \x34 \x64 \x20 \x25 " " \x49 \x36 \x34 \x64 \x20 \x25 \x49 \x36 \x34 \x64 " , & lh , & lb , & la ) ; lf ( la == 100 )  { lf ( lb == 100 )  { le ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x49 \x36 \x34 \x64 \x3a \x20 " " \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " , lc ) ; } lg  { le ( " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x49 \x36 \x34 \x64 \x3a \x20 \x42 \x72 \x6f \x6b \x65 \x6e \n " , lc ) ; } } lglf ( la == 0 )  { lf ( lb == 0 ) { le ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x49 \x36 \x34 \x64 " " \x3a \x20 \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " , lc ) ; } lg { le ( " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x49 \x36 \x34 \x64 \x3a \x20 \x42 \x72 \x6f \x6b \x65 \x6e \n " , lc ) ; } } lg  { lf ( lh >= 100 )  { le ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x49 \x36 \x34 \x64 " " \x3a \x20 \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " , lc ) ; } lg { la = 100 ; li ( lb % 2 == 0 && la % 2 == 0 )  { lb = lb / 2 ; la = la / 2 ; } ld = 3 ; li ( lb > 1 && lb >= ld )  { li ( lb % ld == 0 && la % ld == 0 )  { lb = lb / ld ; la = la / ld ; } ld = ld + 2 ; } lf ( la <= lh )  { le ( " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x49 \x36 \x34 \x64 \x3a \x20 \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " , lc ) ; } lg  { le ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x49 \x36 \x34 \x64 \x3a \x20 \x42 " " \x72 \x6f \x6b \x65 \x6e \n " , lc ) ; } } } } lr 0 ; }
>>>Func
METHOD lc
METHOD_RETURN lg
ld ld("\x45\x6e\x74\x65\x72\x20\x64\x65\x63\x69\x6d\x61""\x6c\x20\x6e\x75\x6d\x62\x65\x72\x3a\x20")
le le("\x25\x6c\x64",&la)
lb lb(la)
IDENTIFIER lh <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 3->1 3->4 4->1 4->1
>>>Token lg lc ( ) { lf la ; ld ( " \x45 \x6e \x74 \x65 \x72 \x20 \x64 \x65 \x63 \x69 \x6d \x61 " " \x6c \x20 \x6e \x75 \x6d \x62 \x65 \x72 \x3a \x20 " ) ; le ( " \x25 \x6c \x64 " , & la ) ; lb ( la ) ; lh 0 ; }
>>>Func
METHOD lz
METHOD_RETURN lc
lk lk("\x25\x64\n",&lw)
<operator>.lessThan lp<lw
<operator>.postIncrement lp++
IDENTIFIER l0 <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lc lz ( ) { lc lw ; lc lp ; lk ( " \x25 \x64 \n " , & lw ) ; le ( lp = 0  ; lp < lw ; lp ++ ) { lc lq ; lk ( " \x25 \x64 \x20 " , & lq ) ; ll lh [ lq ] [ 3 ] ; lc ld ; le ( ld = 0  ; ld < lq ; ld ++ ) { lk ( " \x25 " " \x63 \x25 \x63 \x25 \x63 \x20 " , & lh [ ld ] [ 0 ] , & lh [ ld ] [ 1 ] , & lh [ ld ] [ 2 ] ) ; } lc lr ; lk ( " \x25 \x64 \x20 " , & lr ) ; ll lm [ lr ] [ 2 ] ; lc la ; le ( la = 0  ; la < lr ; la ++ ) { lk ( " " " \x25 \x63 \x25 \x63 \x20 " , & lm [ la ] [ 0 ] , & lm [ la ] [ 1 ] ) ; } lc lf ; lk ( " \x25 \x64 \x20 " , & lf ) ; ll lv [ lf ] ; lc lb ; le ( lb = 0  ; lb < lf ; lb ++ ) { lk ( " \x25 \x63 " , & lv [ lb ] ) ; lj ( lb == lf )  lk ( " \n " ) ; } ll li [ lf ] ; le ( lb = 0  ; lb < lf ; lb ++ ) { li [ lb ] = 0 ; } lc lt = 0 , lg = 0 ; le ( lb = 0  ; lb < lf ; lb ++ ) { lc lu = 0 ; lc ln = 0 ; ll lo = lv [ lb ] ; lj ( lg ) { ll lx = li [ lg - 1 ] ; le ( la = 0  ; la < lq ; la ++ ) { lj ( ( lo == lh [ la ] [ 0 ] && lx == lh [ la ] [ 1 ] ) || ( lo == lh [ la ] [ 1 ] && lx == lh [ la ] [ 0 ] ) )  { li [ lg - 1 ] = lh [ la ] [ 2 ] ; lu = 1 ; } } lj ( ! lu )  { le ( ld = 0  ; ld < lg && ! ln ; ld ++ ) { ll ly = li [ ld ] ; le ( la = 0  ; la < lr && ! ln ; la ++ ) { lj ( ( lo == lm [ la ] [ 0 ] && ly == lm [ la ] [ 1 ] ) || ( lo == lm [ la ] [ 1 ] && ly == lm [ la ] [ 0 ] ) )  { ln = 1 ; } } } } } lj ( ! ln && ! lu )  { li [ lt ] = lo ; lt ++ ; lg ++ ; } lj ( ln ) { lt = 0 ; lg = 0 ; le ( la = 0  ; la < lf ; la ++ ) { li [ la ] = 0 ; } } } ls ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lp + 1 ) ; le ( lb = 0  ; lb < lg ; lb ++ ) { ls ( " \x25 \x63 " , li [ lb ] ) ; lj ( lb < lg - 1 )  { ls ( " \x2c \x20 " ) ; } } ls ( " \x5d " " \n " ) ; } l0 0 ; }
>>>Func
METHOD lm
METHOD_RETURN le
PARAM lj*lb
PARAM li*lg
PARAM le*ld
lf lf( *ld<2)
IDENTIFIER lc <empty>
LITERAL 0 <empty>
<operator>.lessThan la<lb->lq
<operator>.postIncrement la++
<operator>.lessThan la<lb->ln
<operator>.postIncrement la++
IDENTIFIER lc <empty>
LITERAL 0 <empty>
<operator>.lessThan *ld<2
>>>PDG&15 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 4->1 5->1 5->1 8->1 8->1 8->9 9->10 10->1 10->1 10->11 11->1 11->1 14->1 14->5 14->5
>>>Token le lm ( lj * lb , li * lg , le * ld ) { lf ( * ld < 2 ) lc 0 ; le la ; lh ( la = 0  ; la < lb -> lq ; la ++ ) { lf ( lo ( lb -> lp + la , lg , ld ) ) lc 1 ; } lh ( la = 0  ; la < lb -> ln ; la ++ ) { lf ( lk ( lb -> ll + la , lg , ld ) ) lc 1 ; } lc 0 ; }
>>>Func
METHOD lu
METHOD_RETURN lr
PARAM lg lb
PARAM lg lq
<operator>.assignment lk[7]={'C' 'a' 's' 'e' ' ' '#' '\0'}
lc lc(lb,lk,6)
<operator>.assignment lf[5]={'\0' '\0' '\0' '\0' '\0'}
lt lt(lf,"\x25\x64",lq)
<operator>.logicalAnd la<5&&lf[la]!='\0'
<operator>.preIncrement ++la
<operator>.assignment lm[3]={':' ' ' '\0'}
lc lc(lb,lm,2)
<operator>.assignment lp='['
<operator>.assignment lo=']'
lc lc(lb,&lp,1)
<operator>.lessThan la<le.ll-1
<operator>.preIncrement ++la
ls ls(la<le.ll)
lc lc(lb,&le.lh[la],1)
lc lc(lb,&lo,1)
<operator>.assignment ln='\n'
lc lc(lb,&ln,1)
<operator>.arrayInitializer {'C' 'a' 's' 'e' ' ' '#' '\0'}
<operator>.arrayInitializer {'\0' '\0' '\0' '\0' '\0'}
<operator>.lessThan la<5
<operator>.notEquals lf[la]!='\0'
<operator>.arrayInitializer {':' ' ' '\0'}
<operator>.subtraction le.ll-1
<operator>.lessThan la<le.ll
<operator>.indirectIndexAccess lf[la]
>>>PDG&30 0->2 0->3 0->5 0->7 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 2->5 3->7 4->1 4->1 4->5 5->1 5->1 5->11 6->1 6->1 6->7 7->1 7->1 7->1 7->25 8->1 8->1 8->1 9->15 10->1 10->1 10->11 11->1 11->1 11->14 12->1 12->1 12->14 13->1 13->1 13->19 14->1 14->1 14->18 15->1 15->1 15->16 16->1 16->28 17->1 17->1 18->1 18->1 18->19 19->1 19->1 19->21 20->1 20->1 20->21 21->1 21->1 21->1 22->4 22->4 22->4 22->4 22->4 22->4 22->4 23->6 24->8 24->8 24->9 24->25 24->29 25->1 25->8 25->8 26->10 26->10 26->10 27->15 27->15 27->28 28->1 28->1 28->17 28->17
>>>Token lr lu ( lg lb , lg lq ) { ld lk [ 7 ] = { ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' \0 ' } ; lc ( lb , lk , 6 ) ; ld lf [ 5 ] = { ' \0 ' , ' \0 ' , ' \0 ' , ' \0 ' , ' \0 ' } ; lt ( lf , " \x25 \x64 " , lq ) ; lg la ; lj ( la = 0  ; la < 5 && lf [ la ] != ' \0 ' ; ++ la ) lc ( lb , & lf [ la ] , 1 ) ; ld lm [ 3 ] = { ' ' , ' ' , ' \0 ' } ; lc ( lb , lm , 2 ) ; ld lp = ' ' ; ld lo = ' ' ; lc ( lb , & lp , 1 ) ; lj ( la = 0  ; la < le . ll - 1 ; ++ la ) { ld li [ 3 ] = { ' ' , ' ' , ' \0 ' } ; lc ( lb , & le . lh [ la ] , 1 ) ; lc ( lb , li , 2 ) ; } ls ( la < le . ll )  lc ( lb , & le . lh [ la ] , 1 ) ; lc ( lb , & lo , 1 ) ; ld ln = ' \n ' ; lc ( lb , & ln , 1 ) ; }
>>>Func
METHOD lv
METHOD_RETURN lk
<operator>.assignment ln=1
ls ls("\x25\x64",&ld)
lw lw(ln<=ld)
BLOCK <empty> <empty>
IDENTIFIER lx <empty>
LITERAL 0 <empty>
lt lt("\x43\x61\x73\x65""\x20\x23\x25\x64\x3a\x20",ln)
<operator>.assignment ll=0
<operator>.assignment lb=0
<operator>.assignment lp=0
<operator>.assignment li=0
<operator>.assignment lr=0
ls ls("\x25\x6c\x6c\x64\x25\x6c\x6c\x64\x25\x6c\x6c""\x64\x25\x6c\x6c\x64",&lo,&ld,&le,&lj)
<operator>.lessThan la<lj
<operator>.postIncrement la++
<operator>.lessThan la<le
<operator>.postIncrement la++
<operator>.lessEqualsThan la<=le
<operator>.postIncrement la++
<operator>.lessThan la<lh+1+lo
<operator>.postIncrement la++
<operator>.lessEqualsThan la<=le
<operator>.postIncrement la++
lt lt("\x25\x6c\x6c\x64\n",li+ld)
<operator>.postIncrement ln++
<operator>.lessEqualsThan ln<=ld
<operator>.addition lh+1+lo
<operator>.addition li+ld
<operator>.addition lh+1
>>>PDG&31 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 2->1 2->27 3->1 3->14 3->25 3->27 3->29 4->1 4->1 8->1 8->26 9->1 9->1 10->1 10->1 11->1 11->1 12->1 12->25 12->29 13->1 13->1 14->1 14->1 14->1 14->1 14->1 14->15 14->17 14->19 14->21 14->23 14->25 14->28 14->29 15->1 15->1 15->16 16->17 17->1 17->18 17->19 18->19 19->20 19->23 20->21 21->1 21->1 21->22 22->23 23->1 23->1 23->24 24->1 24->1 25->1 25->1 26->1 26->1 27->4 27->4 27->8 27->14 27->25 27->29 28->1 28->1 29->1 29->1 30->1
>>>Token lk lv ( ) { lk ld , ln = 1 ; ls ( " \x25 \x64 " , & ld ) ; lw ( ln <= ld )  { lt ( " \x43 \x61 \x73 \x65 " " \x20 \x23 \x25 \x64 \x3a \x20 " , ln ) ; lm lm  lk lo , ld , le , lj , ll = 0 , la , lb = 0 , lh , lp = 0 , li = 0 ; lk lr = 0 ; ls ( " \x25 \x6c \x6c \x64 \x25 \x6c \x6c \x64 \x25 \x6c \x6c " " \x64 \x25 \x6c \x6c \x64 " , & lo , & ld , & le , & lj ) ; lm lm  lk lg [ lj ] , lc [ le + 2 ] ; lf ( la = 0  ; la < lj ; la ++ ) { ls ( " \x25 \x6c \x6c \x64 " , & lg [ la ] ) ; } lf ( la = 0  ; la < le ; la ++ ) { lq ( lb == lj ) { lb = 0 ; } ll = ll + lg [ lb ] * 2 ; lq ( ll >= ld && lr == 0 )  { lr = 1 ; lc [ la ] = lg [ lb ] - ( ll - ld ) / 2 ; lc [ le ] = lg [ lb ] - lc [ la ] ; lh = la ; } lu { lc [ la ] = lg [ lb ] ; } lb ++ ; } lf ( la = lh + 1  ; la <= le ; la ++ ) { lf ( lb = lh + 1  ; lb < le ; lb ++ ) { lq ( lc [ lb ] < lc [ lb + 1 ] )  { lp = lc [ lb ] ; lc [ lb ] = lc [ lb + 1 ] ; lc [ lb + 1 ] = lp ; } } } lf ( la = lh + 1  ; la < lh + 1 + lo ; la ++ ) { li = li + lc [ la ] ; } lf ( ; la <= le ; la ++ ) { li = li + lc [ la ] * 2 ; } lt ( " \x25 \x6c \x6c \x64 \n " , li + ld ) ; ln ++ ; } lx 0 ; }
>>>Func
METHOD lz
METHOD_RETURN lx
lj lj("\x25\x64",&lw)
<operator>.assignment lv=1
l1 l1((lw--)!=0)
BLOCK <empty> <empty>
IDENTIFIER l0 <empty>
LITERAL 0 <empty>
lj lj("""\x25\x64",&lt)
<operator>.assignment lm=0
<operator>.lessThan la<lt
<operator>.postIncrement la++
lj lj("""\x25\x64",&ls)
<operator>.lessThan la<ls
<operator>.postIncrement la++
<operator>.assignment lc=1
lj lj("""\x25\x64",&lg)
lj lj("\x25\x73",lb)
<operator>.lessEqualsThan lo<=lg
<operator>.postIncrement lo++
lp lp("\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x5b",lv++)
lh lh(lb[0]!='\0')
BLOCK <empty> <empty>
IDENTIFIER lu <empty>
lp lp("\x5d\n")
<operator>.notEquals (lw--)!=0
<operator>.lessThan la<lg-1
<operator>.postIncrement la++
lp lp("\x25\x63\x5d\n",lb[lg-1])
<operator>.postDecrement lw--
<operator>.postIncrement lv++
<operator>.notEquals lb[0]!='\0'
<operator>.subtraction lg-1
<operator>.subtraction lg-1
>>>PDG&34 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 2->1 2->1 2->29 3->1 3->30 4->1 4->1 8->1 8->1 8->10 9->1 9->1 10->1 10->1 10->11 11->13 12->1 12->1 12->13 13->1 13->1 13->14 14->26 15->1 15->1 16->1 16->1 16->18 16->32 16->33 17->1 17->1 17->28 17->31 18->1 18->19 18->32 19->1 19->1 20->1 20->1 21->1 21->1 24->1 25->1 25->4 25->4 26->1 26->27 27->1 27->1 28->1 28->1 29->1 29->25 30->1 30->20 31->1 31->21 31->21 32->26 32->26 32->33 33->1
>>>Token lx lz ( ) { lx lw , lv , lt , ls , lg , la , le , lo , ld , ll , lc , lk , lm ; lq li [ 36 ] [ 3 ] ; lq ln [ 28 ] [ 2 ] ; lq lb [ 100 ] ; lq lr [ 27 ] ; lj ( " \x25 \x64 " , & lw ) ; lv = 1 ; l1 ( ( lw -- ) != 0 )  { lj ( " " " \x25 \x64 " , & lt ) ; lm = 0 ; lf ( la = 0  ; la < lt ; la ++ ) { lj ( " \x25 \x73 " , li [ la ] ) ; } lj ( " " " \x25 \x64 " , & ls ) ; lf ( la = 0  ; la < ls ; la ++ ) { lj ( " \x25 \x73 " , ln [ la ] ) ; } lc = 1 ; lj ( " " " \x25 \x64 " , & lg ) ; lj ( " \x25 \x73 " , lb ) ; lf ( lo = 0  ; lo <= lg ; lo ++ ) { lf ( la = 0  ; la < lt ; la ++ ) { lf ( le = 0  ; le < 2 ; le ++ ) { lh ( lb [ lc ] == li [ la ] [ le ] )  { lh ( le == 1 ) { lh ( lb [ lc - 1 ] == li [ la ] [ 0 ] )  { lb [ lc - 1 ] = li [ la ] [ 2 ] ; lf ( ld = lc  ; ld < lg - 1 ; ld ++ ) { lb [ ld ] = lb [ ld + 1 ] ; } lb [ lg - 1 ] = ' \0 ' ; lg -- ; lc = lc -- ; lm = 1 ; } } lu { lh ( lb [ lc - 1 ] == li [ la ] [ 1 ] )  { lb [ lc - 1 ] = li [ la ] [ 2 ] ; lf ( ld = lc  ; ld < lg - 1 ; ld ++ ) { lb [ ld ] = lb [ ld + 1 ] ; } lb [ lg - 1 ] = ' \0 ' ; lc = lc -- ; lg -- ; lm = 1 ; } } } } } lk = 0 ; lh ( lm != 1 )  { lf ( la = 0  ; la < ls ; la ++ ) { lf ( le = 0  ; le < 2 ; le ++ ) { lh ( ln [ la ] [ le ] == lb [ lc ] )  { lh ( le == 1 ) lr [ lk ] = ln [ la ] [ 0 ] ; lu lr [ lk ] = ln [ la ] [ 1 ] ; lk ++ ; } } } lf ( la = 0  ; la < lc ; la ++ ) { lf ( le = 0  ; le < lk ; le ++ ) { lh ( lr [ le ] == lb [ la ] )  { lf ( ll = 0 , ld = lc + 1  ; ld < lg ; ld ++ , ll ++ ) { lb [ ll ] = lb [ ld ] ; } lb [ ll ] = ' \0 ' ; lg = ll ; lc = 0 ; ly ; } } } } lc ++ ; } lp ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lv ++ ) ; lh ( lb [ 0 ] != ' \0 ' )  { lf ( la = 0  ; la < lg - 1 ; la ++ ) { lp ( " \x25 \x63 \x2c \x20 " , lb [ la ] ) ; } lp ( " \x25 \x63 \x5d \n " , lb [ lg - 1 ] ) ; } lu lp ( " \x5d \n " ) ; } l0 0 ; }
>>>Func
METHOD ll
METHOD_RETURN lf
PARAM lf lg
PARAM lf la[]
<operator>.logicalAnd lb>=0&&la[lb]>la[lb+1]
<operator>.postDecrement lb--
lj lj(lb<0)
IDENTIFIER li <empty>
LITERAL 0 <empty>
<operator>.lessThan lc<le
<operator>.expressionList lc++ le--
<operator>.assignment ld=la[lb]
<operator>.lessThan la[lc]<ld
<operator>.postIncrement lc++
<operator>.assignment la[lb]=la[lc]
<operator>.assignment la[lc]=ld
IDENTIFIER li <empty>
LITERAL 1 <empty>
<operator>.greaterEqualsThan lb>=0
<operator>.greaterThan la[lb]>la[lb+1]
<operator>.lessThan lb<0
<operator>.postIncrement lc++
<operator>.postDecrement le--
<operator>.addition lb+1
<operator>.indirectIndexAccess la[lb]
<operator>.indirectIndexAccess la[lb+1]
>>>PDG&26 0->2 0->3 0->5 0->7 0->8 0->9 0->12 0->13 0->15 0->16 0->17 0->18 0->20 0->21 0->22 0->23 2->1 3->1 3->11 3->12 3->14 3->19 4->1 4->1 4->1 5->1 5->20 6->1 6->1 9->1 9->21 9->22 10->1 10->1 11->1 11->12 12->1 12->14 12->15 13->1 13->1 14->1 14->1 15->1 15->1 15->1 18->4 18->4 18->5 18->19 18->23 18->23 18->24 18->25 19->1 19->4 19->4 19->11 20->1 20->6 20->6 21->10 21->13 22->1 22->10
>>>Token lk lf ll ( lf lg , lf la [ ] ) { lf lb , lc , le , ld ; lh ( lb = lg - 2  ; lb >= 0 && la [ lb ] > la [ lb + 1 ] ; lb -- ) ; lj ( lb < 0 ) li 0 ; lh ( lc = lb + 1 , le = lg - 1  ; lc < le ; lc ++ , le -- ) { ld = la [ lc ] ; la [ lc ] = la [ le ] ; la [ le ] = ld ; } ld = la [ lb ] ; lh ( lc = lb + 1  ; la [ lc ] < ld ; lc ++ ) ; la [ lb ] = la [ lc ] ; la [ lc ] = ld ; li 1 ; }
>>>Func
METHOD lq
METHOD_RETURN ld
PARAM ld ls
PARAM lr* *lo
lm lm("\x25\x64\n",&lj)
<operator>.lessThan lf<lj
<operator>.postIncrement lf++
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token ld lq ( ld ls , lr * * lo ) { ld lf , le , lj , lg ; ld lb , li ; ld lh ; lm ( " \x25 \x64 \n " , & lj ) ; ln ( lf = 0  ; lf < lj ; lf ++ ) { lh = 0 ; la ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a " " \x20 " , lf + 1 ) ; lm ( " \x25 \x64 \x20 \x25 \x64 \x20 \x25 \x64 \n " , & lg , & lb , & li ) ; lc ( ( lb != 100 ) && ( li == 100 ) )  { la ( " \x42 \x72 \x6f \x6b \x65 \x6e \n " ) ; ll ; } lk lc ( lb != 0 && li = = 0 ) { la ( " \x42 \x72 \x6f \x6b \x65 \x6e \n " ) ; ll ; } lc ( lg >= 100 )  { la ( " \x50 " " \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " ) ; ll ; } lk  { ln ( le = 1  ; le <= lg ; le ++ ) { lc ( ( lb * le ) % 100 == 0 )  { lh = 1 ; lp ; } } lc ( lh ) { la ( " \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " ) ; } lk  { la ( " \x42 \x72 \x6f \x6b \x65 \x6e \n " ) ; } } } }
>>>Func
METHOD le
METHOD_RETURN lf
ld ld("\x3c\x3c\x3c\x3c\x20\x54\x45\x53\x54\x20\x46\x55\x4e\x43""\x54\x49\x4f\x4e\x20\x3e\x3e\x3e\x3e\n")
lb lb(la("\x31\x32\x33")==lc("""\x31\x32\x33"))
lb lb(la("\x2d\x31\x32\x33")==lc("\x2d\x31\x32\x33"))
lb lb(la("")==lc(""))
lb lb(la("\x2d\x68\x32\x33")==lc("\x2d\x68\x32\x33"))
lb lb(la("\x20\x20\x20\x20\x20\x20\x20\x20\x20\x32\x33")==lc("\x20\x20""\x20\x20\x20\x20\x20\x20\x20\x32\x33"))
lb lb(la("\x39\x39\x39\x39\x39""\x39\x39\x39\x39")==lc("\x39\x39\x39\x39\x39\x39\x39\x39\x39"))
ld ld("""\x3c\x3c\x3c\x3c\x20\x54\x45\x53\x54\x20\x44\x4f\x4e\x45\x20\x3e\x3e""\x3e\x3e\n")
<operator>.equals la("\x31\x32\x33")==lc("""\x31\x32\x33")
<operator>.equals la("\x2d\x31\x32\x33")==lc("\x2d\x31\x32\x33")
<operator>.equals la("")==lc("")
<operator>.equals la("\x2d\x68\x32\x33")==lc("\x2d\x68\x32\x33")
<operator>.equals la("\x20\x20\x20\x20\x20\x20\x20\x20\x20\x32\x33")==lc("\x20\x20""\x20\x20\x20\x20\x20\x20\x20\x32\x33")
<operator>.equals la("\x39\x39\x39\x39\x39""\x39\x39\x39\x39")==lc("\x39\x39\x39\x39\x39\x39\x39\x39\x39")
la la("\x31\x32\x33")
lc lc("""\x31\x32\x33")
la la("\x2d\x31\x32\x33")
lc lc("\x2d\x31\x32\x33")
la la("")
lc lc("")
la la("\x2d\x68\x32\x33")
lc lc("\x2d\x68\x32\x33")
la la("\x20\x20\x20\x20\x20\x20\x20\x20\x20\x32\x33")
lc lc("\x20\x20""\x20\x20\x20\x20\x20\x20\x20\x32\x33")
la la("\x39\x39\x39\x39\x39""\x39\x39\x39\x39")
lc lc("\x39\x39\x39\x39\x39\x39\x39\x39\x39")
>>>PDG&28 0->2 0->9 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->1 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 9->1 10->1 10->1 10->3 10->3 11->1 11->1 11->4 11->4 12->1 12->1 12->5 12->5 13->1 13->1 13->6 13->6 14->1 14->1 14->7 14->7 15->1 15->1 15->8 15->8 16->10 17->10 18->11 19->11 20->12 21->12 22->13 23->13 24->14 25->14 26->15 27->15
>>>Token lf le ( ) { ld ( " \x3c \x3c \x3c \x3c \x20 \x54 \x45 \x53 \x54 \x20 \x46 \x55 \x4e \x43 " " \x54 \x49 \x4f \x4e \x20 \x3e \x3e \x3e \x3e \n " ) ; lb ( la ( " \x31 \x32 \x33 " ) == lc ( " " " \x31 \x32 \x33 " ) ) ; lb ( la ( " \x2d \x31 \x32 \x33 " ) == lc ( " \x2d \x31 \x32 \x33 " ) ) ; lb ( la ( " " ) == lc ( " " ) ) ; lb ( la ( " \x2d \x68 \x32 \x33 " ) == lc ( " \x2d \x68 \x32 \x33 " ) ) ; lb ( la ( " \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x32 \x33 " ) == lc ( " \x20 \x20 " " \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x32 \x33 " ) ) ; lb ( la ( " \x39 \x39 \x39 \x39 \x39 " " \x39 \x39 \x39 \x39 " ) == lc ( " \x39 \x39 \x39 \x39 \x39 \x39 \x39 \x39 \x39 " ) ) ; ld ( " " " \x3c \x3c \x3c \x3c \x20 \x54 \x45 \x53 \x54 \x20 \x44 \x4f \x4e \x45 \x20 \x3e \x3e " " \x3e \x3e \n " ) ; }
>>>Func
METHOD lr
METHOD_RETURN lh
IDENTIFIER li <empty>
lm lm("\x25\x64",&lj)
<operator>.lessThan ld<lj
<operator>.postIncrement ld++
IDENTIFIER lq <empty>
LITERAL 0 <empty>
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token lh lr ( ) { lh lj , lc , lg ; ll ll li ; lh ld , lt , ls ; lh la , lb , lf ; lm ( " \x25 \x64 " , & lj ) ; lo ( ld = 0  ; ld < lj ; ld ++ ) { lm ( " \x25 \x6c \x6c \x64 \x20 \x25 \x64 \x20 \x25 \x64 " , & li , & lc , & lg ) ; lb = 100 ; lf = lc ; lo ( la = 2  ; la < 10 ; la ++ ) { lp ( lb % la == 0 && lf % la == 0 )  { lb /= la ; lf /= la ; } } le ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , ld + 1 ) ; lk ( lg == 100 && lc != 100 || lg == 0 && lc != 0 )  le ( " \x42 \x72 \x6f \x6b \x65 \x6e \n " ) ; lnlk ( li >= lb )  le ( " \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " ) ; ln le ( " \x42 \x72 " " \x6f \x6b \x65 \x6e \n " ) ; } lq 0 ; }
>>>Func
METHOD lk
METHOD_RETURN ll
<operator>.lessThan la<lc
<operator>.postIncrement la++
<operator>.lessThan la<lc
<operator>.postIncrement la++
<operator>.lessThan la<lc
<operator>.postIncrement la++
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->3 2->4 3->4 4->5 4->6 5->6 6->1 6->1 6->7 7->1 7->1
>>>Token ll lk ( ) { le ( la = 0  ; la < lc ; la ++ ) { ld [ la ] = 0 ; lg [ la ] = 0 ; le ( lb = 0  ; lb < lc ; lb ++ ) { lj ( lf [ la ] [ lb ] >= 0 )  { ld [ la ] ++ ; lg [ la ] += lf [ la ] [ lb ] ; } } } le ( la = 0  ; la < lc ; la ++ ) { lh [ la ] = 0 ; le ( lb = 0  ; lb < lc ; lb ++ ) { lj ( lf [ la ] [ lb ] >= 0 )  { lh [ la ] += ( lg [ lb ] - lf [ lb ] [ la ] ) / ( ld [ lb ] - 1 ) ; } } lh [ la ] /= ld [ la ] ; } le ( la = 0  ; la < lc ; la ++ ) { li [ la ] = 0 ; le ( lb = 0  ; lb < lc ; lb ++ ) { lj ( lf [ la ] [ lb ] >= 0 )  { li [ la ] += lh [ lb ] ; } } li [ la ] /= ld [ la ] ; lg [ la ] /= ld [ la ] ; li [ la ] = li [ la ] * 0.25 + lh [ la ] * 0.5 + lg [ la ] * 0.25 ; } }
>>>Func
METHOD lu
METHOD_RETURN ANY
<operator>.assignment la=0
<operator>.assignment ld=ln("\x69""\x6e\x2e\x74\x78\x74","\x72")
<operator>.assignment lg=ln("\x6f\x75\x74\x2e\x74\x78\x74","""\x77")
lj lj(ld,"\x25\x64",&ll)
<operator>.lessThan lf<ll
<operator>.postIncrement lf++
ln ln("\x69""\x6e\x2e\x74\x78\x74","\x72")
ln ln("\x6f\x75\x74\x2e\x74\x78\x74","""\x77")
>>>PDG&10 0->2 0->5 0->6 0->7 0->8 0->9 2->1 2->1 3->1 3->1 3->5 4->1 4->1 4->1 5->1 5->1 5->1 5->6 6->1 6->1 6->7 7->1 7->1 8->3 8->3 9->4 9->4
>>>Token lu ( ) { lt * ld , * lg ; lq ll , le , lh , lw , lo , lv , lr , lf , lc , ls , lk , la = 0 ; ld = ln ( " \x69 " " \x6e \x2e \x74 \x78 \x74 " , " \x72 " ) ; lg = ln ( " \x6f \x75 \x74 \x2e \x74 \x78 \x74 " , " " " \x77 " ) ; lj ( ld , " \x25 \x64 " , & ll ) ; lp ( lf = 0  ; lf < ll ; lf ++ ) { la = 0 ; lj ( ld , " \x25 " " \x64 " , & lk ) ; lj ( ld , " \x25 \x64 " , & le ) ; lj ( ld , " \x25 \x64 " , & lh ) ; lp ( lc = 1  ; ( ! la ) && lc <= lk ; lc ++ ) { lb ( ( lc * le ) % 100 == 0 )  { lo = lc * le / 100 ; lb ( lh == 0 )  { lb ( le == 0 ) la = 1 ; li la = 0 ; } li  { lb ( lh == 100 )  { lb ( le == 100 ) la = 1 ; } li la = 1 ; } } } lm ( lg , " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , lf + 1 ) ; lb ( la ) lm ( lg , " \x50 \x6f \x73 " " \x73 \x69 \x62 \x6c \x65 \n " ) ; li lm ( lg , " \x42 \x72 \x6f \x6b \x65 \x6e \n " ) ; } }
>>>Func
METHOD lg
METHOD_RETURN lh
PARAM lf lc[10][10]
PARAM lf la
PARAM lf lb
ld ld(lc[la][lb]==0||lc[la][lb]==-1)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
ld ld(lc[la][lb]==1)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
ld ld(lc[la][lb]==2)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
ld ld(lc[la][lb]==3)
BLOCK <empty> <empty>
<operator>.assignment lc[la][lb]=-2
<operator>.assignment lc[la][lb]=10
<operator>.assignment lc[la][lb]=20
<operator>.assignment lc[la][lb]=30
<operator>.logicalOr lc[la][lb]==0||lc[la][lb]==-1
<operator>.equals lc[la][lb]==1
<operator>.equals lc[la][lb]==2
<operator>.equals lc[la][lb]==3
<operator>.equals lc[la][lb]==0
<operator>.equals lc[la][lb]==-1
<operator>.minus -2
<operator>.minus -1
<operator>.indirectIndexAccess lc[la][lb]
<operator>.indirectIndexAccess lc[la]
>>>PDG&30 0->2 0->3 0->4 0->6 0->7 0->9 0->10 0->12 0->13 0->15 0->17 0->18 0->19 0->21 0->22 0->23 0->24 0->26 0->27 2->1 3->1 4->1 5->1 5->1 8->1 8->1 11->1 11->1 14->1 14->1 16->1 16->1 16->21 17->1 17->22 18->1 18->23 19->1 19->1 20->1 20->1 20->5 20->5 21->8 21->8 22->11 22->11 23->14 23->14 24->20 24->20 24->25 24->25 24->27 24->28 24->29 25->1 25->20 25->20 26->16 27->25
>>>Token lh lg ( lf lc [ 10 ] [ 10 ] , lf la , lf lb ) { ld ( lc [ la ] [ lb ] == 0 || lc [ la ] [ lb ] == -1 )  { lc [ la ] [ lb ] = -2 ; } le ld ( lc [ la ] [ lb ] = = 1 ) { lc [ la ] [ lb ] = 10 ; } le ld ( lc [ la ] [ lb ] = = 2 ) { lc [ la ] [ lb ] = 20 ; } le ld ( lc [ la ] [ lb ] = = 3 ) { lc [ la ] [ lb ] = 30 ; } }
>>>Func
METHOD lz
METHOD_RETURN lp
<operator>.assignment lt=1
lo lo("\x25\x64\n",&lq)
l2 l2(lq--)
BLOCK <empty> <empty>
IDENTIFIER l0 <empty>
LITERAL 0 <empty>
lo lo("\x25\x64\n",&lc)
<operator>.lessThan la<lc
<operator>.preIncrement ++la
lw lw(le 0 lc*ly(lp))
lw lw(lj 0 lc*ly(lp))
<operator>.lessThan la<lc
<operator>.preIncrement ++la
<operator>.lessThan la<lc
<operator>.preIncrement ++la
<operator>.lessThan la<lc
<operator>.preIncrement ++la
lv lv("\x43\x61\x73\x65\x20""\x23\x25\x64\x3a\n",lt++)
<operator>.lessThan la<lc
<operator>.preIncrement ++la
<operator>.postDecrement lq--
<operator>.multiplication lc*ly(lp)
<operator>.multiplication lc*ly(lp)
<operator>.postIncrement lt++
ly ly(lp)
ly ly(lp)
>>>PDG&28 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->1 2->25 3->1 3->1 3->22 4->1 4->1 8->1 8->1 8->9 8->13 8->15 8->17 8->20 8->23 8->24 9->10 9->23 10->13 11->1 11->1 12->1 12->1 12->1 13->14 13->15 14->15 15->16 15->17 16->17 17->18 17->20 18->20 19->1 19->1 20->1 20->1 20->21 21->1 21->1 22->1 22->4 23->11 23->11 23->24 24->1 24->12 24->12 24->13 25->1 25->19 26->23 26->27 27->1 27->24
>>>Token lp lz ( ) { l4 l1 ; lp la , lb , lk , l3 , lc , lq , lf , lt = 1 ; lo ( " \x25 \x64 \n " , & lq ) ; l2 ( lq -- )  { lo ( " \x25 \x64 \n " , & lc ) ; ld ( la = 0  ; la < lc ; ++ la ) { ld ( lb = 0  ; lb < lc ; ++ lb ) lo ( " " " \x25 \x63 " , & lr [ la ] [ lb ] ) ; lo ( " \n " ) ; } lw ( le , 0 , lc * ly ( lp ) ) ; lw ( lj , 0 , lc * ly ( lp ) ) ; ld ( la = 0  ; la < lc ; ++ la ) { ld ( lb = 0  ; lb < lc ; ++ lb ) { lu ( lr [ la ] [ lb ] ) { lh ' ' : lm [ la ] [ lb ] = 1 ; le [ la ] ++ ; lg ; lh ' ' : lm [ la ] [ lb ] = 1 ; le [ la ] ++ ; lj [ la ] ++ ; lg ; lh ' ' : lm [ la ] [ lb ] = 0 ; lg ; } } lx [ la ] = ( li ) lj [ la ] / ( li ) le [ la ] ; } ld ( la = 0  ; la < lc ; ++ la ) { lf = 0 ; ll [ la ] = 0.0 ; ld ( lb = 0  ; lb < lc ; ++ lb ) { ls ( lm [ la ] [ lb ] ) { lf ++ ; lj [ 0 ] = le [ 0 ] = 0 ; ld ( lk = 0  ; lk < lc ; ++ lk ) { ls ( lk != la ) { lu ( lr [ lb ] [ lk ] ) { lh ' ' : le [ 0 ] ++ ; lg ; lh ' ' : le [ 0 ] ++ ; lj [ 0 ] ++ ; lg ; lh ' ' : lg ; } } } ll [ la ] += ( li ) lj [ 0 ] / ( li ) le [ 0 ] ; } } ll [ la ] /= ( li ) ( lf ) ; } ld ( la = 0  ; la < lc ; ++ la ) { lf = ln [ la ] = 0 ; ld ( lb = 0  ; lb < lc ; ++ lb ) ls ( lm [ la ] [ lb ] ) ln [ la ] + = ll [ lb ] , lf ++ ; ln [ la ] /= ( li ) ( lf ) ; } lv ( " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x64 \x3a \n " , lt ++ ) ; ld ( la = 0  ; la < lc ; ++ la ) lv ( " \x25 \x6c \x66 \n " , lx [ la ] * 0.25 + ll [ la ] * 0.5 + ln [ la ] * 0.25 ) ; } l0 0 ; }
>>>Func
METHOD l26
METHOD_RETURN lg
PARAM lg l28
PARAM lc* *l17
<operator>.assignment l6=l22(l17[1],"\x72\x74")
<operator>.assignment l16=l22(l17[2],"\x77\x74\x2b")
<operator>.assignment lp=(lc* )lv(102400)
<operator>.assignment lf=(lc* )lv(1000)
<operator>.assignment lt=(lc* )lv(3002)
l23 l23(lp,102400,l6)
l5 l5(lp,"\x25\x64",&l13)
<operator>.lessThan lq<lx
<operator>.greaterThan ';'>("\x6e""\x75\x6d\x62\x65\x72\x20\x69\x73\x20\x25\x64\n",l13)
IDENTIFIER lz <empty>
<operator>.greaterThan l13>ls
<operator>.postIncrement ls++
lw lw(lp)
lw lw(lf)
lw lw(lt)
l30 l30()
IDENTIFIER l27 <empty>
LITERAL 0 <empty>
l22 l22(l17[1],"\x72\x74")
l22 l22(l17[2],"\x77\x74\x2b")
<operator>.cast (lc* )lv(102400)
<operator>.cast (lc* )lv(1000)
<operator>.cast (lc* )lv(3002)
<operator>.bracketedPrimary ("\x6e""\x75\x6d\x62\x65\x72\x20\x69\x73\x20\x25\x64\n",l13)
lv lv(102400)
lv lv(1000)
lv lv(3002)
<operator>.expressionList "\x6e""\x75\x6d\x62\x65\x72\x20\x69\x73\x20\x25\x64\n" l13
>>>PDG&32 0->2 0->3 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->28 0->29 0->30 0->31 2->1 3->1 3->22 3->23 4->1 4->1 4->9 5->1 5->1 5->1 6->1 6->1 6->9 7->1 7->1 7->17 8->1 8->1 8->18 9->1 9->1 9->10 10->1 10->1 10->14 10->16 10->31 11->1 11->1 11->1 12->1 12->1 14->1 14->1 14->15 15->1 15->1 16->1 16->1 17->1 17->1 18->1 18->1 19->1 22->1 22->4 22->4 23->1 23->5 23->5 24->1 25->1 26->1 27->1 27->12 28->6 28->24 29->7 29->25 30->8 30->26 31->14 31->27 31->27
>>>Token lg l26 ( lg l28 , lc * * l17 ) { lg ls , lb , la , lk ; lc * lp ; lc * lf ; lc * ld ; lc * lt ; lc * lm ; lc * li ; lc * ln ; lc * ll ; lc * l10 ; lc * l9 ; lc * l14 ; lg l13 ; lg lr ; lg l2 ; lg l4 ; lg l12 ; lg l18 ; lg lj ; lg le ; l19 * l6 ; l19 * l16 ; l6 = l22 ( l17 [ 1 ] , " \x72 \x74 " ) ; l16 = l22 ( l17 [ 2 ] , " \x77 \x74 \x2b " ) ; lp = ( lc * ) lv ( 102400 ) ; lf = ( lc * ) lv ( 1000 ) ; lt = ( lc * ) lv ( 3002 ) ; l23 ( lp , 102400 , l6 ) ; l5 ( lp , " \x25 \x64 " , & l13 ) ; l1 ly  lq < lx ' ' > ( " \x6e " " \x75 \x6d \x62 \x65 \x72 \x20 \x69 \x73 \x20 \x25 \x64 \n " , l13 ) ; lz lo ( ls  = 0 ; l13 > ls ; ls ++ ) { l23 ( lp , 102400 , l6 ) ; l1 ly  lq < lx ' ' > ( " \x25 \x64 \x3a \x69 \x6e \x70 " " \x75 \x74 \x20 \x69 \x73 \x20 \x25 \x73 \n " , ls , lp ) ; lz ld = l0 ( lp , " \x20 " ) ; l5 ( ld , " \x25 \x64 " , & lr ) ; l1 ly  lq < lx ' ' > ( " \x6e \x75 \x6d \x62 \x65 \x72 \x4f \x66 " " \x43 \x20 \x69 \x73 \x20 \x25 \x64 \n " , lr ) ; lz li = ( lc * ) lv ( 2 * lr ) ; ll = ( lc * ) lv ( lr ) ; l7 ( li , 0x00 , 2 * lr ) ; l7 ( ll , 0x00 , lr ) ; l10 = li ; l14 = ll ; lo ( lb = 0  ; lr > lb ; lb ++ ) { ld = l0 ( l3 , " \x20 " ) ; l15 ( l10 , ld , 2 ) ; l15 ( l14 , ld + 2 , 1 ) ; l10 += 2 ; l14 ++ ; } l1 lylq < lx ' ' > ( " \x61 \x72 \x72 \x61 \x79 \x43 x 9 x 3 d x 20 x 25 x 73 n " , li ) ; lq ( " " " \x74 \x72 \x61 \x6e \x73 \x43 x 9 x 3 d x 20 x 25 x 73 n " , ll ) ; lz ld = l0 ( l3 , " " " \x20 " ) ; l5 ( ld , " \x25 \x64 " , & l2 ) ; l1 ly  lq < lx ' ' > ( " \x6e \x75 \x6d \x62 \x65 " " \x72 \x4f \x66 \x44 \x20 \x69 \x73 \x20 \x25 \x64 \n " , l2 ) ; lz ln = ( lc * ) lv ( l2 * 2 ) ; l7 ( ln , 0x00 , 2 * l2 ) ; l9 = ln ; lo ( lb = 0  ; l2 > lb ; lb ++ ) { ld = l0 ( l3 , " \x20 " ) ; l15 ( l9 , ld , 2 ) ; l9 += 2 ; } ld = l0 ( l3 , " \x20 " ) ; l5 ( ld , " \x25 \x64 " , & l18 ) ; ld = l0 ( l3 , " \x20 " ) ; le = 0 ; l12 = l24 ( ln ) ; l4 = l24 ( li ) ; l7 ( lf , 0x00 , 1000 ) ; lo ( lb = 0  ; l18 > lb ; lb ++ ) { l1ly lq < lx ' ' > ( " \x25 \x64 \x3a \x25 \x73 \n " , lb , lf ) ; lz lo ( la  = 0 ; l12 > la ; la ++ ) { lh ( ld [ lb ] == ln [ la ] )  { lj = 0 ; l21 ( la % 2 )  { l11 1 : lo ( lk = le - 1  ; 0 <= lk ; lk -- ) { lh ( ln [ la - 1 ] == lf [ lk ] )  { le = lk ; lj = 1 ; } } lu ; l11 0 : lo ( lk = le - 1  ; 0 <= lk ; lk -- ) { lh ( ln [ la + 1 ] == lf [ lk ] )  { le = lk ; lj = 1 ; } } lu ; } lh ( 1 == lj ) lu ; } } lh ( l12 != la ) l29 ; lo ( la = 0  ; l4 > la ; la ++ ) { lh ( ld [ lb ] == li [ la ] )  { lj = 0 ; l21 ( la % 2 )  { l11 1 : lh ( li [ la - 1 ] == lf [ le - 1 ] )  { lf [ le - 1 ] = ll [ ( lg ) l8 ( la / 2 ) ] ; lj = 1 ; } l20 lh ( ld [ lb + 1 ] = = li [ la - 1 ] ) { lf [ le ] = ll [ ( lg ) l8 ( la / 2 ) ] ; le ++ ; lb ++ ; lj = 1 ; } lu ; l11 0 : lh ( li [ la + 1 ] == lf [ le - 1 ] )  { lf [ le - 1 ] = ll [ ( lg ) l8 ( la / 2 ) ] ; lj = 1 ; } l20 lh ( ld [ lb + 1 ] = = li [ la + 1 ] ) { lf [ le ] = ll [ ( lg ) l8 ( la / 2 ) ] ; le ++ ; lb ++ ; lj = 1 ; } lu ; } lh ( 1 == lj ) lu ; } } lh ( l4 == la )  { lf [ le ] = ld [ lb ] ; le ++ ; } } lt [ 0 ] = ' ' ; lm = lt + 1 ; lo ( lb = 0  ; le > lb ; lb ++ ) { lm [ 0 ] = lf [ lb ] ; lm [ 1 ] = ' ' ; lm [ 2 ] = ' ' ; lm += 3 ; } lh ( 0 != le )  { lm -= 2 ; } * ( lm ) = ' ' ; * ( lm + 1 ) = 0x00 ; lq ( " \x43 " " \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x73 \n " , ls + 1 , lt ) ; l25 ( l16 , " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x73 \n " , ls + 1 , lt ) ; lw ( li ) ; lw ( ln ) ; lw ( ll ) ; } lw ( lp ) ; lw ( lf ) ; lw ( lt ) ; l30 ( ) ; l27 0 ; }
>>>Func
METHOD ll
METHOD_RETURN lm
PARAM lm la
lj lj(la==lp)
BLOCK <empty> <empty>
<operator>.assignment lg=le
<operator>.assignmentPlus lh+=lb[la]
<operator>.assignment le=le?le^lb[la]:lb[la]
<operator>.assignment lr[lk++]=lb[la]
ll ll(la+1)
<operator>.postDecrement lk--
<operator>.assignmentMinus lh-=lb[la]
<operator>.assignment le=lg
<operator>.assignment lg=ld
<operator>.assignmentPlus lf+=lb[la]
<operator>.assignment ld=ld?ld^lb[la]:lb[la]
<operator>.assignment lq[ln++]=lb[la]
ll ll(la+1)
<operator>.postDecrement ln--
<operator>.assignmentMinus lf-=lb[la]
<operator>.assignment ld=lg
lj lj(lk&&ln&&le==ld)
BLOCK <empty> <empty>
IDENTIFIER lo <empty>
BLOCK <empty> <empty>
<operator>.equals la==lp
lj lj(lh>lf)
<operator>.assignment lc=lh>lc?lh:lc
<operator>.assignment lc=lf>lc?lf:lc
<operator>.subtraction li-1
<operator>.conditional le?le^lb[la]:lb[la]
<operator>.addition la+1
<operator>.conditional ld?ld^lb[la]:lb[la]
<operator>.addition la+1
<operator>.logicalAnd lk&&ln&&le==ld
<operator>.xor le^lb[la]
<operator>.postIncrement lk++
<operator>.xor ld^lb[la]
<operator>.postIncrement ln++
<operator>.logicalAnd lk&&ln
<operator>.equals le==ld
<operator>.greaterThan lh>lf
<operator>.conditional lh>lc?lh:lc
<operator>.conditional lf>lc?lf:lc
<operator>.greaterThan lh>lc
<operator>.greaterThan lf>lc
>>>PDG&46 0->2 0->4 0->5 0->6 0->9 0->10 0->11 0->12 0->13 0->14 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->27 0->28 0->29 0->31 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 2->25 3->1 3->1 5->1 5->12 6->1 6->11 7->1 7->1 8->1 8->1 10->1 10->1 11->1 11->1 12->1 12->1 13->1 13->20 14->1 14->19 15->1 15->1 16->1 16->1 17->1 17->1 18->1 18->1 19->1 19->1 19->1 20->1 20->1 20->1 21->1 21->1 25->1 25->3 25->3 25->9 25->17 25->31 25->33 26->1 26->1 27->1 27->1 27->45 28->1 28->1 28->1 29->1 29->1 30->1 32->1 33->1 34->1 34->1 34->21 34->21 35->7 35->7 35->8 35->11 35->14 35->15 35->16 35->19 35->30 35->30 35->32 35->37 36->10 37->15 37->15 37->16 37->19 37->32 37->32 38->18 39->34 39->34 39->36 39->38 39->40 40->5 40->13 40->34 40->34 40->35 40->37 41->26 41->26 41->44 41->45 42->1 43->1 44->6 44->27 44->27 44->42 44->42 45->14 45->28 45->28 45->43 45->43
>>>Token lm ll ( lm la ) { lj ( la == lp ) { lj ( lk && ln && le == ld )  { lj ( lh > lf ) li lc = lh > lc ? lh : lc ; lo li lc = lf > lc ? lf : lc ; } lo  { li - 1 ; } } lm lg ; lg = le ; lh += lb [ la ] ; le = le ? le ^ lb [ la ] : lb [ la ] ; lr [ lk ++ ] = lb [ la ] ; ll ( la + 1 ) ; lk -- ; lh -= lb [ la ] ; le = lg ; lg = ld ; lf += lb [ la ] ; ld = ld ? ld ^ lb [ la ] : lb [ la ] ; lq [ ln ++ ] = lb [ la ] ; ll ( la + 1 ) ; ln -- ; lf -= lb [ la ] ; ld = lg ; li lc ; }
>>>Func
METHOD l1
METHOD_RETURN lh
<operator>.assignment ln=1
lf lf("\x25\x64",&lr)
<operator>.assignment *lx=l4("\x6f\x75\x74\x70\x75""\x74\x31\x2e\x6f\x75\x74","\x77")
<operator>.lessEqualsThan ln<=lr
<operator>.postIncrement ln++
IDENTIFIER l2 <empty>
LITERAL 0 <empty>
l4 l4("\x6f\x75\x74\x70\x75""\x74\x31\x2e\x6f\x75\x74","\x77")
>>>PDG&10 0->2 0->3 0->5 0->6 0->7 0->8 0->9 2->1 2->5 3->1 3->1 3->5 4->1 4->1 4->1 5->1 5->1 5->6 6->1 6->1 9->4 9->4
>>>Token lh l1 ( ) { lh lr , ln = 1 ; lf ( " \x25 \x64 " , & lr ) ; l0 * lx = l4 ( " \x6f \x75 \x74 \x70 \x75 " " \x74 \x31 \x2e \x6f \x75 \x74 " , " \x77 " ) ; ll ( ; ln <= lr ; ln ++ ) { lh lc , ls , lq , lk ; la = 1 ; lo le [ 4 ] = { ' \0 ' } , lg [ 4 ] = { ' \0 ' } ; lf ( " \x25 \x64 " , & ls ) ; ll ( lc = 0  ; lc < ls ; lc ++ ) lf ( " \x25 \x73 " , le ) ; lf ( " \x25 \x64 " , & lq ) ; ll ( lc = 0  ; lc < lq ; lc ++ ) lf ( " \x25 \x73 " , lg ) ; lo lm [ 15 ] = { ' \0 ' } ; lf ( " \x25 \x64 \x25 \x73 " , & lk , lm ) ; lo lb [ 15 ] = { ' \0 ' } ; lb [ 0 ] = lm [ 0 ] ; ll ( lc = 1  ; lc < lk && la < lk ; lc ++ , la ++ ) { lh lu = 1 ; lb [ la ] = lm [ lc ] ; lv ( lu && la > 0 )  { lt ( ( la > 0 && lb [ la ] == le [ 0 ] && lb [ la - 1 ] == le [ 1 ] ) || ( la > 0 && lb [ la ] == le [ 1 ] && lb [ la - 1 ] == le [ 0 ] ) )  { lb [ la - 1 ] = le [ 2 ] ; lb [ la ] = ' \0 ' ; la = la - 1 ; } lp lt ( la > 0 && lb [ la ] = = lg [ 0 ] & & lw ( lb , lg [ 1 ] ) ) { ly ( lb , ' \0 ' , lz ( lb ) ) ; la = -1 ; } lp lt ( la > 0 && lb [ la ] = = lg [ 1 ] & & lw ( lb , lg [ 0 ] ) ) { ly ( lb , ' \0 ' , lz ( lb ) ) ; la = -1 ; } lp lu = 0 ; } } lold [ 45 ] = { ' \0 ' } ; ld [ 0 ] = ' ' ; lh lj = 0 , li = 1 ; lv ( lj < l5 ( lb ) - 1 )  { ld [ li ++ ] = lb [ lj ] ; ld [ li ++ ] = ' ' ; ld [ li ++ ] = ' ' ; lj ++ ; } ld [ li ++ ] = lb [ lj ] ; l3 ( lx , " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x73 \x5d \n " , ln , ld ) ; } l2 0 ; }
>>>Func
METHOD lq
METHOD_RETURN lh
PARAM lr
lj lj("\x25\x64",&li)
<operator>.lessThan lb<li
<operator>.postIncrement lb++
IDENTIFIER ln <empty>
LITERAL 0 <empty>
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token lh lq ( lr ) { lh li , lb ; lj ( " \x25 \x64 " , & li ) ; ll ( lb = 0  ; lb < li ; lb ++ ) { lh lg , le , lf , lc , ld , la ; lf = 0 ; ld = 0 ; lc = lo ; lj ( " \x25 \x64 " , & lg ) ; ll ( le = 0  ; le < lg ; le ++ ) { lj ( " " " \x25 \x64 " , & la ) ; lf ^= la ; ld += la ; lm ( la < lc ) lc = la ; } lm ( lf != 0 )  lk ( " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , lb + 1 ) ; lp lk ( " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , lb + 1 , ld - lc ) ; } ln 0 ; }
>>>Func
METHOD lk
METHOD_RETURN lg
PARAM lf lc
PARAM lf le
<operator>.assignment ld=0
<operator>.assignment lb=0
<operator>.lessThan la<le
<operator>.postIncrement la++
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 3->6 4->1 4->1 5->1 5->1 6->1 6->1 6->7 7->1 7->1
>>>Token lg lk ( lf lc , lf le ) { lf la ; lg ld , lb ; ld = 0 ; lb = 0 ; lj ( la = 0  ; la < le ; la ++ ) { lh ( la == lc || ll [ lc ] [ la ] == ' ' )  { ln ; } ld += li ( la , le , lc ) ; lb += 1.0 ; } lm ld / lb ; }
>>>Func
METHOD lo
METHOD_RETURN lk
PARAM lp*lb
PARAM ln*lc
<operator>.assignment la=&(lc->la)
le le(lb->ld!=lf)
BLOCK <empty> <empty>
le le(lb->lg!=lf)
BLOCK <empty> <empty>
ll ll(lc)
ld lb->ld(la->lm)
lg lb->lg(la->lh)
<operator>.notEquals lb->ld!=lf
<operator>.notEquals lb->lg!=lf
>>>PDG&14 0->2 0->3 0->6 0->8 0->9 0->12 0->13 2->1 3->9 4->1 4->1 4->1 5->1 5->1 7->1 7->1 9->1 9->1 10->1 10->1 10->1 11->1 11->1 11->1 12->5 12->5 12->10 12->13 13->1 13->7 13->7 13->11
>>>Token lj lk lo ( lp * lb , ln * lc ) { li * la ; la = & ( lc -> la ) ; le ( lb -> ld != lf )  { lb -> ld ( la -> lm ) ; } le ( lb -> lg != lf )  { lb -> lg ( la -> lh ) ; } ll ( lc ) ; }
>>>Func
METHOD ll
METHOD_RETURN lj
PARAM lg ld
<operator>.lessThan la<ld
<operator>.postIncrement la++
<operator>.lessEqualsThan la<=ld
<operator>.postIncrement la++
IDENTIFIER lh <empty>
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->3 3->1 3->4 3->5 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token lj ll ( lg ld ) { lg la , lb , lc ; lf ( la = 0  ; la < ld ; la ++ ) le [ la ] = 0 ; lf ( la = 1 , lb = -1  ; la <= ld ; la ++ ) { lf ( lc = 0  ; lc < la ; lc ++ ) { li lb = ( lb + 1 ) % ld ; lk ( le [ lb ] ) ; } le [ lb ] = la ; } lh ; }
>>>Func
METHOD l5
METHOD_RETURN lb
<operator>.assignment lz=0
li li("\x25\x64\n",&lu)
l3 l3(lu--)
BLOCK <empty> <empty>
IDENTIFIER l6 <empty>
LITERAL 0 <empty>
<operator>.lessEqualsThan la<=(lb)'Z'
<operator>.postIncrement la++
li li("\x25\x64\x20",&ls)
<operator>.lessThan la<ls
<operator>.postIncrement la++
li li("\x25\x64\x20",&lr)
<operator>.lessThan la<lr
<operator>.postIncrement la++
li li("\x25\x64\x20",&lq)
<operator>.assignment lp=0
<operator>.lessThan la<lq
<operator>.postIncrement la++
<operator>.lessThan le<lh
<operator>.greaterThan ';'>("\n\n")
<operator>.lessThan la<lp-1
<operator>.postIncrement la++
lx lx(lp>0)
le le("\x25\x63",lv[lp-1])
le le("\x5d""\n")
<operator>.postDecrement lu--
<operator>.cast (lb)'Z'
<operator>.subtraction lp-1
<operator>.greaterThan lp>0
<operator>.subtraction lp-1
>>>PDG&32 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->1 2->1 3->1 3->1 3->27 4->1 4->1 8->1 8->1 8->9 9->11 10->1 10->1 10->11 11->1 11->1 11->12 12->14 13->1 13->1 13->14 14->1 14->1 14->15 15->18 16->1 16->1 16->18 17->1 17->29 18->1 18->1 18->19 19->22 20->1 20->1 20->1 21->1 22->1 22->23 23->1 23->1 24->1 24->1 25->1 25->1 26->1 27->1 27->4 29->22 29->22 29->30 30->24 30->24 30->31 31->1
>>>Token lb l5 ( ) { lb lu , lz = 0 ; li ( " \x25 \x64 \n " , & lu ) ; l3 ( lu -- )  { lb ls , lr , lq ; lb la , lo ; lk lf [ 10 ] ; ln ( la = ( lb ) ' '  ; la <= ( lb ) ' ' ; la ++ ) { lt [ la ] = 0 ; l2 [ la ] = 0 ; ln ( lo = ( lb ) ' '  ; lo <= ( lb ) ' ' ; lo ++ ) lw [ la ] [ lo ] = ' ' ; } li ( " \x25 \x64 \x20 " , & ls ) ; ln ( la = 0  ; la < ls ; la ++ ) { lb ld , lc ; li ( " \x25 \x73 \x20 " , lf ) ; ld = ( lb ) lf [ 0 ] , lc = ( lb ) lf [ 1 ] ; lj ll  le < lh ' ' > ( " \n \x43 \x6f \x6d \x62 \x69 \x6e \x65 \x3a \x20 \x25 \x63 \x20 " " \x25 \x63 \x20 \x2d \x3e \x20 \x25 \x63 " , ( lk ) ld , ( lk ) lc , lf [ 2 ] ) ; lm lw [ ld ] [ lc ] = lw [ lc ] [ ld ] = lf [ 2 ] ; } li ( " \x25 \x64 \x20 " , & lr ) ; ln ( la = 0  ; la < lr ; la ++ ) { lb ld , lc ; li ( " \x25 \x73 \x20 " , lf ) ; ld = ( lb ) lf [ 0 ] , lc = ( lb ) lf [ 1 ] ; lj ll  le < lh ' ' > ( " " " \n \x4f \x70 \x70 \x6f \x73 \x65 \x64 \x3a \x20 \x25 \x63 \x20 \x25 \x63 " , ( lk ) ld , ( lk ) lc ) ; lm ly [ ld ] [ lt [ ld ] ++ ] = lc ; ly [ lc ] [ lt [ lc ] ++ ] = ld ; } li ( " \x25 \x64 \x20 " , & lq ) ; lp = 0 ; ln ( la = 0  ; la < lq ; la ++ ) { lk lg ; li ( " \x25 \x63 " , & lg ) ; lj ll  le < lh ' ' > ( " \n \x45 \x6c \x65 \x6d \x65 \x6e \x74 \x3a \x20 \x25 \x63 \x20 " , lg ) ; lm lx ( l4 ( lg ) == l1 ) l0 ; lj ll  le < lh ' ' > ( " \x2d \x2d \x20 \x6e \x6f \x74 \x20 \x63 \x6f \x6d " " \x62 \x69 \x6e \x65 \x20 " ) ; lm lx ( l7 ( lg ) == l1 ) l0 ; lj ll  le < lh ' ' > ( " \x2d \x2d " " \x20 \x6e \x6f \x74 \x20 \x6f \x70 \x70 \x6f \x73 \x65 \x64 \x20 " ) ; lm lv [ lp ++ ] = lg ; l2 [ ( lb ) lg ] ++ ; } lj ll  le < lh ' ' > ( " \n \n " ) ; lm le < lh ' ' > ( " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , ++ lz ) ; ln ( la = 0  ; la < lp - 1 ; la ++ ) le ( " " " \x25 \x63 \x2c \x20 " , lv [ la ] ) ; lx ( lp > 0 )  le ( " \x25 \x63 " , lv [ lp - 1 ] ) ; le ( " \x5d " " \n " ) ; } l6 0 ; }
>>>Func
METHOD lm
METHOD_RETURN le
PARAM ld li[]
PARAM ld la
lg lg(lb=lf(lc,ln*2,la)<0)
<operator>.subtraction lh-1
lg lg(la==lc[2*lb])
<operator>.assignment la=lc[2*lb+1]
<operator>.assignment la=lc[2*lb]
<operator>.assignment lb=lf(lc,ln*2,la)<0
<operator>.equals la==lc[2*lb]
<operator>.lessThan lf(lc,ln*2,la)<0
<operator>.addition 2*lb+1
<operator>.multiplication 2*lb
lf lf(lc,ln*2,la)
<operator>.multiplication 2*lb
<operator>.multiplication 2*lb
<operator>.multiplication ln*2
>>>PDG&18 0->2 0->3 0->5 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->1 3->14 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 8->1 9->1 9->4 9->15 10->6 10->6 10->8 11->1 11->4 11->4 11->9 11->9 13->1 14->1 14->1 14->7 14->8 14->10 14->10 14->11 14->11 14->11 15->16 16->12 16->12 16->13 17->1 17->14 17->14
>>>Token le lm ( ld li [ ] , ld la ) { le lb ; lg ( lb = lf ( lc , ln * 2 , la ) < 0 )  lh - 1 ; lg ( la == lc [ 2 * lb ] ) la = lc [ 2 * lb + 1 ] ; lj la = lc [ 2 * lb ] ; lh lf ( ll , lk , la ) ; }
>>>Func
METHOD lq
METHOD_RETURN lj
<operator>.assignment lc=0
lk lk("\x41\x2d\x73\x6d\x61\x6c""\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e","\x72",lw)
lk lk("""\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e""\x6f\x75\x74","\x77",lt)
ll ll("\x25\x64",&lh)
ls ls(lh--)
BLOCK <empty> <empty>
IDENTIFIER lm <empty>
LITERAL 0 <empty>
<operator>.postIncrement lc++
ll ll("\x25""\x49\x36\x34\x64\x25\x64\x25\x64",&le,&lb,&ld)
lf lf(lb!=100&&ld==100||lb!=0&&ld==0)
BLOCK <empty> <empty>
<operator>.lessEqualsThan la<=le
<operator>.postIncrement la++
lf lf(la==le+1)
BLOCK <empty> <empty>
IDENTIFIER lu <empty>
BLOCK <empty> <empty>
<operator>.postDecrement lh--
lg lg("\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x42\x72""\x6f\x6b\x65\x6e\n",lc)
IDENTIFIER li <empty>
lg lg("\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x42\x72""\x6f\x6b\x65\x6e\n",lc)
IDENTIFIER li <empty>
lg lg("\x43\x61\x73\x65\x20\x23\x25\x64""\x3a\x20\x50\x6f\x73\x73\x69\x62\x6c\x65\n",lc)
IDENTIFIER li <empty>
<operator>.logicalOr lb!=100&&ld==100||lb!=0&&ld==0
<operator>.equals la==le+1
<operator>.logicalAnd lb!=100&&ld==100
<operator>.logicalAnd lb!=0&&ld==0
<operator>.addition le+1
<operator>.notEquals lb!=100
<operator>.equals ld==100
<operator>.notEquals lb!=0
<operator>.equals ld==0
>>>PDG&36 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->31 0->32 0->33 0->34 0->35 2->1 2->10 3->1 3->1 4->1 4->1 5->1 5->1 5->20 6->1 6->1 10->1 10->21 11->1 11->1 11->1 11->1 11->14 11->28 11->31 11->32 11->33 11->34 11->35 12->1 12->1 14->1 14->15 14->28 14->31 15->1 15->28 16->1 16->1 20->1 20->6 21->23 23->1 23->25 25->1 25->1 27->1 27->1 27->12 27->12 28->1 28->1 28->16 28->16 29->1 29->1 29->27 29->27 29->30 29->34 30->1 30->1 30->27 30->27 31->1 32->1 32->29 32->29 32->33 32->34 33->1 33->29 33->29 33->35 34->1 34->30 34->30 34->35 35->1 35->30 35->30
>>>Token lj lq ( ) { lj lb , ld , lh , lc = 0 ; lr le , la , lp , ln ; lk ( " \x41 \x2d \x73 \x6d \x61 \x6c " " \x6c \x2d \x61 \x74 \x74 \x65 \x6d \x70 \x74 \x30 \x2e \x69 \x6e " , " \x72 " , lw ) ; lk ( " " " \x41 \x2d \x73 \x6d \x61 \x6c \x6c \x2d \x61 \x74 \x74 \x65 \x6d \x70 \x74 \x30 \x2e " " \x6f \x75 \x74 " , " \x77 " , lt ) ; ll ( " \x25 \x64 " , & lh ) ; ls ( lh -- )  { lc ++ ; ll ( " \x25 " " \x49 \x36 \x34 \x64 \x25 \x64 \x25 \x64 " , & le , & lb , & ld ) ; lf ( lb != 100 && ld == 100 || lb != 0 && ld == 0 )  { lg ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x42 \x72 " " \x6f \x6b \x65 \x6e \n " , lc ) ; li ; } lo ( la = 1  ; la <= le ; la ++ ) { lf ( la * lb % 100 == 0 ) lv ; } lf ( la == le + 1 )  { lg ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x42 \x72 " " \x6f \x6b \x65 \x6e \n " , lc ) ; li ; } lu  { lg ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 " " \x3a \x20 \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " , lc ) ; li ; } } lm 0 ; }
>>>Func
METHOD l9
METHOD_RETURN lh
PARAM lh lz
PARAM lx* *lt
l12 l12(lz==3)
<operator>.assignment lm=l3(lt[1],"""\x72")
<operator>.assignment ll=l3(lt[2],"\x77")
l6 l6(ln,5000,lm)
<operator>.assignment l4=lg(ln)
<operator>.assignment lo=1
l2 l2(l6(ln,5000,lm)!=le)
BLOCK <empty> <empty>
ly ly(lm)
ly ly(ll)
<operator>.assignment lb=li(ln,"\x20")
<operator>.assignment l0=lg(lb)
<operator>.assignment lb=li(le,"\x20")
<operator>.assignment lf=lg(lb)
<operator>.assignment lb=li(le,"\x20")
<operator>.assignment lp=lg(lb)
<operator>.assignment lb=li(le,"\x20")
<operator>.assignment lv=lg(lb)
<operator>.assignment lb=li(le,"\x20")
<operator>.assignment la=0
l2 l2(lb!=le)
BLOCK <empty> <empty>
<operator>.lessThan la<lp
<operator>.postIncrement la++
<operator>.assignment lq=0
<operator>.assignment ld=0
<operator>.lessThan la<lp
<operator>.postIncrement la++
l8 l8(ll "\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x25""\x64\n" lo (lh)ld)
l7 l7(ll)
<operator>.postIncrement lo++
<operator>.equals lz==3
l3 l3(lt[1],"""\x72")
l3 l3(lt[2],"\x77")
lg lg(ln)
<operator>.notEquals l6(ln,5000,lm)!=le
<operator>.assignment lu[la++]=lg(lb)
<operator>.assignment lb=li(le,"\x20")
l6 l6(ln,5000,lm)
li li(ln,"\x20")
lg lg(lb)
li li(le,"\x20")
lg lg(lb)
li li(le,"\x20")
lg lg(lb)
li li(le,"\x20")
lg lg(lb)
li li(le,"\x20")
<operator>.notEquals lb!=le
<operator>.cast (lh)ld
lg lg(lb)
li li(le,"\x20")
<operator>.postIncrement la++
>>>PDG&57 0->2 0->3 0->7 0->9 0->11 0->12 0->13 0->23 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 2->35 3->1 3->36 3->37 4->1 4->1 5->1 5->1 5->7 6->1 6->1 6->32 7->38 7->42 8->1 8->1 8->1 9->1 9->32 10->1 10->1 12->1 12->1 13->1 13->1 14->1 14->1 14->44 15->1 15->1 16->46 17->1 17->1 18->48 19->1 19->26 20->50 21->1 21->1 22->52 23->1 23->56 24->1 24->1 26->27 26->30 27->30 28->1 28->1 29->1 29->32 29->53 30->1 30->1 30->31 31->1 31->1 32->1 32->1 32->33 32->34 33->1 33->13 34->1 34->1 35->1 35->4 35->4 36->1 36->5 36->5 37->1 37->6 37->6 38->8 38->42 39->1 39->10 39->10 39->45 40->1 40->1 40->1 41->1 41->1 41->1 42->12 42->39 42->39 42->39 42->43 43->1 43->14 43->14 44->15 45->16 45->16 45->47 46->17 47->18 47->18 47->49 48->19 49->20 49->20 49->51 50->21 51->22 51->22 51->52 52->24 52->24 52->54 52->55 53->1 54->40 55->1 55->41 55->41 56->26
>>>Token lh l9 ( lh lz , lx * * lt ) { l12 ( lz == 3 ) ; l10 * lm , * ll ; lh lo , l4 ; lh lf , lp , lv , lq ; lh la , l11 , lj , lc [ l5 ] , lu [ l5 ] ; lx ln [ 5000 ] , * lb ; lw lk , ld ; lm = l3 ( lt [ 1 ] , " " " \x72 " ) ; ll = l3 ( lt [ 2 ] , " \x77 " ) ; l6 ( ln , 5000 , lm ) ; l4 = lg ( ln ) ; lo = 1 ; l2 ( l6 ( ln , 5000 , lm ) != le )  { lb = li ( ln , " \x20 " ) ; l0 = lg ( lb ) ; lb = li ( le , " \x20 " ) ; lf = lg ( lb ) ; lb = li ( le , " \x20 " ) ; lp = lg ( lb ) ; lb = li ( le , " \x20 " ) ; lv = lg ( lb ) ; lb = li ( le , " \x20 " ) ; la = 0 ; l2 ( lb != le )  { lu [ la ++ ] = lg ( lb ) ; lb = li ( le , " \x20 " ) ; } l1 ( la = 0  ; la < lp ; la ++ ) lc [ la ] = lu [ la % lv ] ; lq = 0 ; ld = 0 ; l1 ( la = 0  ; la < lp ; la ++ ) { lk = lc [ la ] / 0.5 ; ls ( lk <= lf ) ld += lk ; lr ls ( lq < l0 ) { ld += ( lw ) ( lc [ la ] + 0.5 * lf ) ; lq ++ ; } lr { lj = l13 ( la , lc ) ; ls ( lc [ lj ] > lc [ la ] ) ld += lk ; lr ld = ( ld - ( lc [ lj ] + 0.5 * lf ) + ( lc [ lj ] / 0.5 ) + ( lc [ la ] + 0.5 * lf ) ) ; } } l8 ( ll , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 " " \x64 \n " , lo , ( lh ) ld ) ; l7 ( ll ) ; lo ++ ; } ly ( lm ) ; ly ( ll ) ; }
>>>Func
METHOD lr
METHOD_RETURN lb
PARAM lb lu
PARAM lq* *lp
lk lk("\x25\x64",&ll)
<operator>.lessThan ld<ll
<operator>.postIncrement ld++
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token lb lr ( lb lu , lq * * lp ) { lb ll ; lb ld ; lk ( " \x25 \x64 " , & ll ) ; lf ( ld = 0  ; ld < ll ; ld ++ ) { lb lc , la ; lb lh [ 800 ] ; lb lj [ 800 ] ; lb li ; lk ( " \x25 \x64 " , & lc ) ; lf ( la = 0  ; la < lc ; la ++ ) { lk ( " \x25 \x64 " , & lh [ la ] ) ; } lf ( la = 0  ; la < lc ; la ++ ) { lk ( " \x25 \x64 " , & lj [ la ] ) ; } ln ( lh , lc , lm ( lb ) , ( lb ( * ) ( le lg * , le lg * ) ) ls ) ; ln ( lj , lc , lm ( lb ) , ( lb ( * ) ( le lg * , le lg * ) ) lo ) ; lf ( la = 0 , li = 0  ; la < lc ; la ++ ) { li += lh [ la ] * lj [ la ] ; } lt ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , ld + 1 , li ) ; } }
>>>Func
METHOD lt
METHOD_RETURN lm
PARAM lm
<operator>.lessThan lj<lo
<operator>.greaterThan ';'>("\x74\x65\x73""\x74\x2e\x69\x6e","\x72",lr)
lj lj("\x74\x65\x73\x74\x2e\x6f\x75\x74","""\x77",lq)
<operator>.lessEqualsThan lb<=lh
<operator>.postIncrement lb++
<operator>.bracketedPrimary ("\x74\x65\x73""\x74\x2e\x69\x6e","\x72",lr)
<operator>.expressionList "\x74\x65\x73""\x74\x2e\x69\x6e" "\x72" lr
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->9 2->1 3->1 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 6->7 7->1 7->1 8->1 8->4 9->1 9->8 9->8 9->8
>>>Token lm lt ( lm ) { ln lb , lh ; ln la , li , le , lf , ld ; lw lv  lj < lo ' ' > ( " \x74 \x65 \x73 " " \x74 \x2e \x69 \x6e " , " \x72 " , lr ) ; lj ( " \x74 \x65 \x73 \x74 \x2e \x6f \x75 \x74 " , " " " \x77 " , lq ) ; lu lg < lo ' ' > ( " \x25 \x64 \n " , & lh ) ; lp ( lb = 1  ; lb <= lh ; lb ++ ) { lg ( " " " \x25 \x64 \n " , & li ) ; le = lf = 0 ; ld = 1000001 ; lp ( la = 0  ; la < li ; la ++ ) { lg ( " \x25 \x64 " " \x20 " , & lc [ la ] ) ; le ^= lc [ la ] ; lf += lc [ la ] ; lk ( lc [ la ] < ld ) ld = lc [ la ] ; } lk ( le != 0 )  ll ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , lb ) ; ls ll ( " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , lb , lf - ld ) ; } }
>>>Func
METHOD ll
METHOD_RETURN lg
PARAM lf la
PARAM ld lb
PARAM ld lc
lh lh(la!=lk&&le(la,lb)&&le(la,lc))
lj lj(la->li[lb][lc]!=0)
<operator>.logicalAnd la!=lk&&le(la,lb)&&le(la,lc)
<operator>.notEquals la->li[lb][lc]!=0
<operator>.logicalAnd la!=lk&&le(la,lb)
le le(la,lc)
<operator>.notEquals la!=lk
le le(la,lb)
>>>PDG&13 0->2 0->3 0->4 0->8 0->10 0->11 0->12 2->11 3->1 3->12 4->1 4->10 5->1 5->1 6->1 6->1 7->1 7->1 7->5 7->5 8->1 8->6 8->6 9->1 9->1 9->7 9->7 9->10 10->1 10->1 10->7 10->7 11->1 11->1 11->9 11->9 11->10 11->12 11->12 12->1 12->1 12->9 12->9 12->10
>>>Token lg ll ( lf la , ld lb , ld lc ) { lh ( la != lk && le ( la , lb ) && le ( la , lc ) ) ; lj ( la -> li [ lb ] [ lc ] != 0 ) ; }
>>>Func
METHOD lh
METHOD_RETURN li
PARAM lf*ld
PARAM lf*lb
le le(ld[0].la<lb[0].la)
BLOCK <empty> <empty>
le le(ld[0].la>lb[0].la)
BLOCK <empty> <empty>
le le(ld[0].lg>lb[0].lg)
BLOCK <empty> <empty>
IDENTIFIER lc <empty>
LITERAL 0 <empty>
IDENTIFIER lc <empty>
LITERAL 1 <empty>
IDENTIFIER lc <empty>
LITERAL 0 <empty>
IDENTIFIER lc <empty>
LITERAL 1 <empty>
<operator>.lessThan ld[0].la<lb[0].la
<operator>.greaterThan ld[0].la>lb[0].la
<operator>.greaterThan ld[0].lg>lb[0].lg
>>>PDG&21 0->2 0->3 0->5 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->1 3->1 4->1 4->1 6->1 6->1 8->1 8->1 18->4 18->4 18->19 18->19 19->1 19->1 19->6 19->6 20->1 20->1 20->8 20->8
>>>Token li lh ( lf * ld , lf * lb ) { le ( ld [ 0 ] . la < lb [ 0 ] . la )  { lc 1 ; } le ( ld [ 0 ] . la > lb [ 0 ] . la )  { lc 0 ; } le ( ld [ 0 ] . lg > lb [ 0 ] . lg )  { lc 1 ; } lc 0 ; }
>>>Func
METHOD li
METHOD_RETURN lk
PARAM lh*lb
<operator>.expressionList lc la
<operator>.assignment lc=lo(lb)
lm lm("\x25\x73\x2e\x2e\x2e\x2e\n",lb)
<operator>.assignment ld[la]=lf(lb,le,0)
<operator>.lessThan la<lc
<operator>.postIncrement la++
lo lo(lb)
lf lf(lb,le,0)
>>>PDG&11 0->2 0->3 0->5 0->7 0->8 0->9 0->10 2->9 3->1 3->7 4->1 4->1 4->7 5->1 5->10 6->1 6->1 6->1 7->1 7->1 7->8 8->1 8->1 9->4 9->5 10->1 10->1 10->6 10->6 10->6
>>>Token lk li ( lh * lb ) { lj ll lc , la ; lc = lo ( lb ) ; lm ( " \x25 \x73 \x2e \x2e \x2e \x2e \n " , lb ) ; ld [ la ] = lf ( lb , le , 0 ) ; lg ( la = 1  ; la < lc ; la ++ ) { ln ( lb [ la ] == 32 )  { ld [ la ] = lf ( & lb [ la + 1 ] , le , 0 ) ; } } }
>>>Func
METHOD l1
METHOD_RETURN lg
lr lr("\x25\x64",&ls)
<operator>.notEquals ll!=ls
<operator>.postIncrement ll++
IDENTIFIER l2 <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lg l1 ( ) { lg ls ; lr ( " \x25 \x64 " , & ls ) ; lg ll ; ln ( ll = 0  ; ll != ls ; ll ++ ) { lr ( " \x25 " " \x64 \x20 \x25 \x64 \x20 \x25 \x64 \x20 \x25 \x6c \x66 \x20 \x25 \x64 " , & lq , & lk , & lp , & lf , & lo ) ; lg la ; ln ( la = 0  ; la < lo ; la ++ ) { lr ( " \x25 \x64 \x20 \x25 \x64 \x20 " " \x25 \x64 " , & le [ la ] . ld , & le [ la ] . lb , & le [ la ] . lw ) ; } ly ( le , lo , lx ( lv lu ) , lz ) ; lg lh = 0 ; lg lb = 0 ; ln ( la = 0  ; la < lo ; la ++ ) { lt ( le [ la ] . ld != lh )  { lc [ lb ] . ld = lk ; lc [ lb ] . lb = le [ la ] . ld - lh ; ++ lb ; } lc [ lb ] . ld = le [ la ] . lw + lk ; lc [ lb ] . lb = le [ la ] . lb - le [ la ] . ld ; ++ lb ; lh = le [ la ] . lb ; } lt ( lh != lq )  { lc [ lb ] . ld = lk ; lc [ lb ] . lb = lq - lh ; ++ lb ; } ly ( lc , lb , lx ( lv lu ) , lz ) ; lm li = 0.0 ; lp -= lk ; ln ( la = 0  ; la < lb && lf > 1e-10 ; la ++ ) { lm lj = lc [ la ] . lb / ( lm ) ( lc [ la ] . ld + lp ) ; lt ( lj < lf || l4 ( lj - lf ) < 1e-10 )  { lf -= lj ; li += lj ; } l0  { li += lf ; li += ( lc [ la ] . lb - lf * ( lc [ la ] . ld + lp ) ) / ( lm ) ( lc [ la ] . ld ) ; lf = 0.0 ; } } ln ( ; la < lb ; la ++ ) { li += lc [ la ] . lb / ( lm ) lc [ la ] . ld ; } l3 ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x2e \x31 \x30 \x6c \x66 " " \n " , ll + 1 , li ) ; } l2 0 ; }
>>>Func
METHOD ly
METHOD_RETURN lv
PARAM ln lk
lz lz()
ld ld(le,"\x25\x64",&ll)
<operator>.lessThan la<ll
<operator>.preIncrement ++la
ld ld(le,"\x25\x64",&lq)
<operator>.lessThan la<lq
<operator>.preIncrement ++la
ld ld(le,"\x25\x64\x20\x25\x73",&lo,lb)
<operator>.lessThan la<lo
<operator>.preIncrement ++la
lh lh(lf,"\x43""\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x5b",lk)
<operator>.lessThan la<lc
<operator>.preIncrement ++la
lp lp(lc!=-1)
lh lh(lf,"\x25\x63\x5d\n",li[lc])
IDENTIFIER lr <empty>
lh lh(lf,"\x5d\n")
<operator>.notEquals lc!=-1
<operator>.minus -1
>>>PDG&22 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 2->13 3->1 4->1 4->1 4->5 4->7 5->1 5->1 5->6 6->8 7->1 7->1 7->8 7->10 8->1 8->1 8->9 9->11 10->1 10->1 10->1 10->1 10->11 11->1 11->1 11->12 12->14 13->1 13->1 13->17 14->1 14->15 14->20 15->1 15->1 16->1 16->1 17->1 17->1 17->19 19->1 19->1 20->1 20->1 20->16 20->16 21->20
>>>Token lv ly ( ln lk ) { ln la , lu ; lt lb [ 200 ] ; lz ( ) ; ld ( le , " \x25 \x64 " , & ll ) ; lg ( la = 0  ; la < ll ; ++ la ) { ld ( le , " \x25 \x73 " , lb ) ; lj [ lb [ 0 ] - ' ' ] [ lb [ 1 ] - ' ' ] = lb [ 2 ] - ' ' ; lj [ lb [ 1 ] - ' ' ] [ lb [ 0 ] - ' ' ] = lb [ 2 ] - ' ' ; } ld ( le , " \x25 \x64 " , & lq ) ; lg ( la = 0  ; la < lq ; ++ la ) { ld ( le , " \x25 \x73 " , lb ) ; lm [ lb [ 0 ] - ' ' ] [ lb [ 1 ] - ' ' ] = 1 ; lm [ lb [ 1 ] - ' ' ] [ lb [ 0 ] - ' ' ] = 1 ; } ld ( le , " \x25 \x64 \x20 \x25 \x73 " , & lo , lb ) ; lg ( la = 0  ; la < lo ; ++ la ) { li [ ++ lc ] = lb [ la ] ; lx [ li [ lc ] - ' ' ] ++ ; lp ( lc > 0 )  { lw ( ) ; ls ( ) ; } } lh ( lf , " \x43 " " \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lk ) ; lg ( la = 0  ; la < lc ; ++ la ) { lh ( lf , " \x25 \x63 \x2c \x20 " , li [ la ] ) ; } lp ( lc != -1 )  lh ( lf , " \x25 \x63 \x5d \n " , li [ lc ] ) ; lr lh ( lf , " \x5d \n " ) ; }
>>>Func
METHOD lh
METHOD_RETURN lf
ld ld("\x25\x64\n",&lc)
<operator>.lessEqualsThan lb<=lc
<operator>.preIncrement ++lb
IDENTIFIER li <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lf lh ( ) { lf lc , lb , la ; ld ( " \x25 \x64 \n " , & lc ) ; lg ( lb = 1  ; lb <= lc ; ++ lb ) { ld ( " " " \x25 \x64 \n " , & le ) ; lg ( la = 0  ; la < le ; ++ la ) { ld ( " \x25 \x64 " , & lk [ la ] ) ; } lj ( lb ) ; } li 0 ; }
>>>Func
METHOD ln
METHOD_RETURN lj
PARAM lj* *lg
PARAM lt lk
lh lh(lg==la||lk==la)
BLOCK <empty> <empty>
lh lh( *lg==la||( *lg)->le==la)
BLOCK <empty> <empty>
<operator>.assignment ld= *lg
<operator>.assignment lf=la
<operator>.assignment lc=la
<operator>.assignment lb=( *lg)->le
ls ls(lb!=la)
BLOCK <empty> <empty>
<operator>.assignment lm=ln(&lf,lk)
<operator>.assignment lo=ln(&lc,lk)
<operator>.assignment *lg=lf
lh lh(lf==la)
BLOCK <empty> <empty>
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
<operator>.assignment ld->le=lc
lh lh(lc!=la)
BLOCK <empty> <empty>
lh lh(lc==la)
BLOCK <empty> <empty>
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
<operator>.multiplication ll*lg
<operator>.assignment *le=lb->le
lh lh(lk(lb->lq,ld->lq)<0)
BLOCK <empty> <empty>
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
<operator>.assignment lb=le
<operator>.assignment ld->li=la
<operator>.assignment *lg=ld
<operator>.assignment ld->li=lm
<operator>.assignment lm->le=ld
<operator>.assignment lc->li=ld
<operator>.logicalOr lg==la||lk==la
<operator>.logicalOr *lg==la||( *lg)->le==la
<operator>.notEquals lb!=la
<operator>.assignment lb->li=la
<operator>.assignment lb->le=lf
lh lh(lf!=la)
BLOCK <empty> <empty>
<operator>.assignment lf=lb
<operator>.assignment lb->li=la
<operator>.assignment lb->le=lc
lh lh(lc!=la)
BLOCK <empty> <empty>
<operator>.assignment lc=lb
ln ln(&lf,lk)
ln ln(&lc,lk)
<operator>.equals lf==la
<operator>.notEquals lc!=la
<operator>.equals lc==la
<operator>.equals lg==la
<operator>.equals lk==la
<operator>.equals *lg==la
<operator>.equals ( *lg)->le==la
<operator>.lessThan lk(lb->lq,ld->lq)<0
<operator>.assignment lf->li=lb
<operator>.assignment lc->li=lb
lk lk(lb->lq,ld->lq)
<operator>.notEquals lf!=la
<operator>.notEquals lc!=la
<operator>.indirectFieldAccess ( *lg)->le
<operator>.indirection *lg
FIELD_IDENTIFIER le le
>>>PDG&71 0->2 0->3 0->5 0->7 0->9 0->10 0->13 0->16 0->18 0->19 0->20 0->21 0->23 0->25 0->26 0->27 0->28 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->42 0->43 0->44 0->46 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->66 0->67 2->58 3->53 3->59 4->1 4->1 6->1 6->1 8->1 8->36 8->38 8->39 9->1 9->44 9->66 10->1 10->49 10->67 11->1 11->1 11->42 12->1 12->1 14->1 14->1 14->37 15->1 15->1 15->1 16->1 17->1 17->1 21->1 21->1 22->1 22->1 24->1 24->1 28->1 28->1 28->1 29->1 29->34 30->1 30->1 34->1 34->1 34->1 35->1 36->1 36->1 37->1 37->1 37->1 38->1 38->1 39->1 39->1 39->1 40->1 40->1 40->4 40->4 41->1 41->1 41->6 41->6 42->12 42->12 42->43 42->47 42->52 42->63 42->64 42->66 44->1 45->1 45->1 47->1 47->16 47->53 47->55 48->1 48->1 49->1 49->1 52->1 52->21 52->54 52->56 53->1 53->14 53->14 53->16 53->54 53->55 54->1 54->1 54->15 54->15 54->21 54->56 54->57 55->1 55->17 55->17 55->35 55->56 56->22 56->22 56->57 56->57 57->1 57->1 57->24 57->24 58->28 58->40 58->40 58->59 58->59 58->60 59->40 59->40 59->53 59->60 60->8 60->9 60->10 60->28 60->41 60->41 60->42 60->61 60->61 60->68 60->69 60->70 61->9 61->10 61->11 61->41 61->41 61->42 62->1 62->30 62->30 63->1 63->1 64->1 65->1 65->1 65->62 65->62 66->45 66->45 66->48 66->67 67->50 67->50 67->55
>>>Token lr lj * ln ( lj * * lg , lt lk ) { lj * ld ; lj * lb ; lj * lf , * lc ; lj * lm , * lo ; lh ( lg == la || lk == la )  { ll la ; } lh ( * lg == la || ( * lg ) -> le == la )  { ll * lg ; } ld = * lg ; lf = la ; lc = la ; lb = ( * lg ) -> le ; ls ( lb != la )  { lj * le = lb -> le ; lh ( lk ( lb -> lq , ld -> lq ) < 0 )  { lb -> li = la ; lb -> le = lf ; lh ( lf != la )  { lf -> li = lb ; } lf = lb ; } lp  { lb -> li = la ; lb -> le = lc ; lh ( lc != la )  { lc -> li = lb ; } lc = lb ; } lb = le ; } lm = ln ( & lf , lk ) ; lo = ln ( & lc , lk ) ; * lg = lf ; lh ( lf == la )  { ld -> li = la ; * lg = ld ; } lp  { ld -> li = lm ; lm -> le = ld ; } ld -> le = lc ; lh ( lc != la )  { lc -> li = ld ; } lh ( lc == la )  { ll ld ; } lp  { ll lo ; } }
>>>Func
METHOD ln
METHOD_RETURN lc
PARAM lc lb[29][2]
PARAM lf ll
PARAM lc li[101]
PARAM lf lj
PARAM lc lh
<operator>.assignment ld='0'
<operator>.lessThan la<ll
<operator>.postIncrement la++
IDENTIFIER lm <empty>
le le(lb[la][1]==lh)
<operator>.assignment ld=lb[la][0]
le le(ld=='0')
IDENTIFIER lg <empty>
LITERAL 0 <empty>
<operator>.lessThan la<lj
<operator>.postIncrement la++
IDENTIFIER lg <empty>
LITERAL 0 <empty>
<operator>.equals lb[la][1]==lh
<operator>.equals ld=='0'
>>>PDG&22 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 2->1 3->8 4->1 5->16 6->20 7->1 8->1 8->1 8->9 9->16 11->1 11->1 12->1 12->1 12->21 13->1 13->1 16->1 16->1 16->17 17->1 17->1 20->1 20->1 20->11 20->11 21->1 21->13 21->13
>>>Token lc ln ( lc lb [ 29 ] [ 2 ] , lf ll , lc li [ 101 ] , lf lj , lc lh ) { lf la ; lc ld = ' ' ; lk ( la = 0  ; la < ll ; la ++ ) le ( lb [ la ] [ 0 ] == lh ) ld = lb [ la ] [ 1 ] ; lm le ( lb [ la ] [ 1 ] = = lh ) ld = lb [ la ] [ 0 ] ; le ( ld == ' ' ) lg 0 ; lk ( la = 0  ; la < lj ; la ++ ) le ( li [ la ] == ld ) lg 1 ; lg 0 ; }
>>>Func
METHOD l10
METHOD_RETURN la
PARAM la l4
PARAM lj*l0[]
<operator>.assignment *lq=lz
<operator>.assignment *ls=lz
<operator>.multiplication lj*lh
<operator>.multiplication lj*lg
lm lm(l4!=2)
BLOCK <empty> <empty>
<operator>.assignment lq=l1(l0[1],"\x72")
lr lr(lq)
<operator>.assignment ls=l1("\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74","\x77")
lr lr(ls)
l9 l9(lq,"\x25\x64",&lv)
<operator>.lessThan li(ly,lv)<lf
l3 l3(ls)
l3 l3(lq)
IDENTIFIER l8 <empty>
LITERAL 0 <empty>
l11 l11("\x49\x6e\x63\x6f\x72\x72\x65\x63\x74\x20\x6e""\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x63\x6f\x6d\x6d\x61\x6e\x64\x20""\x6c\x69\x6e\x65\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x2c\x20\x65""\x78\x69\x74\x69\x6e\x67\x2e\x2e\x2e\n")
IDENTIFIER l8 <empty>
LITERAL 1 <empty>
<operator>.notEquals l4!=2
l1 l1(l0[1],"\x72")
l1 l1("\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74","\x77")
li li(ly,lv)
>>>PDG&27 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->11 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->23 3->1 3->24 4->1 5->1 5->1 6->1 6->1 6->7 7->1 7->1 7->1 8->1 8->1 10->1 10->1 10->11 11->1 11->14 12->1 12->1 12->13 13->1 13->16 14->1 14->1 14->17 14->26 15->1 15->1 15->1 16->1 16->1 17->1 17->1 20->1 23->1 23->8 23->8 24->1 24->10 24->10 25->12 25->12 26->1 26->1 26->15 26->15
>>>Token la l10 ( la l4 , lj * l0 [ ] ) { l5 * lq = lz ; l5 * ls = lz ; la lb , lo , ly ; la lv ; l12 lj ll [ 26 ] [ 26 ] ; la lp [ 26 ] [ 26 ] ; la lw ; la lx ; lj lc [ 3 ] ; lj le [ 2 ] ; la ln ; lj * lh ; lj * lg ; la ld ; lm ( l4 != 2 )  { l11 ( " \x49 \x6e \x63 \x6f \x72 \x72 \x65 \x63 \x74 \x20 \x6e " " \x75 \x6d \x62 \x65 \x72 \x20 \x6f \x66 \x20 \x63 \x6f \x6d \x6d \x61 \x6e \x64 \x20 " " \x6c \x69 \x6e \x65 \x20 \x61 \x72 \x67 \x75 \x6d \x65 \x6e \x74 \x73 \x2c \x20 \x65 " " \x78 \x69 \x74 \x69 \x6e \x67 \x2e \x2e \x2e \n " ) ; l8 1 ; } lq = l1 ( l0 [ 1 ] , " \x72 " ) ; lr ( lq ) ; ls = l1 ( " \x6f \x75 \x74 \x70 \x75 \x74 \x2e \x74 \x78 \x74 " , " \x77 " ) ; lr ( ls ) ; l9 ( lq , " \x25 \x64 " , & lv ) ; li ( ly , lv ) < lf ' ; ' { li ( lb , 26 ) < lf ' ; ' { li ( lo , 26 ) < lf ' ; ' { ll [ lb ] [ lo ] = 0 ; lp [ lb ] [ lo ] = 0 ; } } lk ( " \x25 \x64 " , & lw ) ; li ( lb , lw ) < lf ' ; ' { lk ( " \x25 \x2a \x63 \x25 \x63 \x25 \x63 \x25 \x63 " , & lc [ 0 ] , & lc [ 1 ] , & lc [ 2 ] ) ; lc [ 0 ] -= 65 ; lc [ 1 ] -= 65 ; lu ( lc [ 0 ] < 26 && lc [ 0 ] >= 0 ) ; lu ( lc [ 1 ] < 26 && lc [ 1 ] >= 0 ) ; ll [ ( la ) lc [ 0 ] ] [ ( la ) lc [ 1 ] ] = lc [ 2 ] ; ll [ ( la ) lc [ 1 ] ] [ ( la ) lc [ 0 ] ] = lc [ 2 ] ; } lk ( " \x25 \x64 " , & lx ) ; li ( lb , lx ) < lf ' ; ' { lk ( " \x25 \x2a \x63 \x25 \x63 \x25 \x63 " , & le [ 0 ] , & le [ 1 ] ) ; le [ 0 ] -= 65 ; le [ 1 ] -= 65 ; lu ( le [ 0 ] < 26 && le [ 0 ] >= 0 ) ; lu ( le [ 1 ] < 26 && le [ 1 ] >= 0 ) ; lp [ ( la ) le [ 0 ] ] [ ( la ) le [ 1 ] ] = -1 ; lp [ ( la ) le [ 1 ] ] [ ( la ) le [ 0 ] ] = -1 ; } lk ( " \x25 \x64 " , & ln ) ; lh = < lf ' ' > l7 ( < lf ' ' > lj , ln ) ; lr ( lh ) ; lg = < lf ' ' > l7 ( < lf ' ' > lj , ln ) ; lr ( lg ) ; lk ( " \x25 \x2a \x63 " ) ; li ( lb , ln ) < lf ' ; ' { lk ( " \x25 \x63 " , & lh [ lb ] ) ; } ld = 0 ; li ( lb , ln ) < lf ' ; ' { lm ( ld ) { lm ( ll [ ( la ) lg [ ld - 1 ] - 65 ] [ ( la ) lh [ lb ] - 65 ] ) lg [ ld - 1 ] = ll [ ( la ) lg [ ld - 1 ] - 65 ] [ ( la ) lh [ lb ] - 65 ] ; l2  { li ( lo , ld ) < lf ' ; ' { lm ( lp [ ( la ) lg [ lo ] - 65 ] [ ( la ) lh [ lb ] - 65 ] == -1 )  { ld = 0 ; } } lm ( ld ) { lg [ ld ] = lh [ lb ] ; ld ++ ; } } } l2 { lg [ 0 ] = lh [ lb ] ; ld ++ ; } } lt ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , ly + 1 ) ; li ( lb , ld - 1 ) < lf ' ' > lt ( " \x25 \x63 \x2c \x20 " , lg [ lb ] ) ; lm ( ld ) lt ( " \x25 " " \x63 " , lg [ lb ] ) ; lt ( " \x5d \n " ) ; l6 ( lh ) ; l6 ( lg ) ; } l3 ( ls ) ; l3 ( lq ) ; l8 0 ; }
>>>Func
METHOD lh
METHOD_RETURN lg
PARAM li ld
PARAM lb lf[9][9]
PARAM lb le[9][9]
<operator>.assignment lc=lj[ld-'A']
<operator>.lessThan la<8
<operator>.postIncrement la++
<operator>.subtraction ld-'A'
>>>PDG&9 0->2 0->3 0->4 0->6 0->7 0->8 2->8 3->1 4->1 5->1 5->1 5->1 6->1 6->7 7->1 7->1 8->1
>>>Token lk lg lh ( li ld , lb lf [ 9 ] [ 9 ] , lb le [ 9 ] [ 9 ] ) { lb la ; lb lc = lj [ ld - ' ' ] ; ll ( la = 0  ; la < 8 ; la ++ ) { le [ lc ] [ la ] -= lf [ lc ] [ la ] ; } }
>>>Func
METHOD lv
METHOD_RETURN lc
PARAM lc lp
PARAM ll*lq[]
<operator>.assignment *la=lu
<operator>.assignment lh=0
li li(lp<2)
BLOCK <empty> <empty>
<operator>.assignment la=lx(lq[1],"\x72")
li li(lu==la)
BLOCK <empty> <empty>
ly ly(la,"\x25\x64\n",&lh)
<operator>.lessEqualsThan lf<=lh
<operator>.postIncrement lf++
ln ln(lm,"\x44\x75\x64\x65\x2c\x20\x70\x61""\x73\x73\x20\x61\x20\x66\x69\x6c\x65\x6e\x61\x6d\x65\n")
<operator>.subtraction lr-1
ln ln(lm,"\x44\x75\x64\x65\x2c\x20\x70\x61\x73""\x73\x20\x61\x20\x56\x41\x4c\x49\x44\x20\x66\x69\x6c\x65\n")
<operator>.subtraction lr-1
<operator>.lessThan lp<2
lx lx(lq[1],"\x72")
<operator>.equals lu==la
>>>PDG&21 0->2 0->3 0->4 0->5 0->7 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 2->18 3->1 3->19 4->1 5->1 5->11 5->12 6->1 6->1 8->1 8->1 8->20 9->1 9->1 11->1 11->1 11->1 11->12 12->1 12->1 12->13 13->1 13->1 14->1 14->16 15->17 16->1 16->1 17->1 17->1 18->1 18->6 18->6 19->1 19->8 19->8 20->1 20->9 20->9 20->11
>>>Token lc lv ( lc lp , ll * lq [ ] ) { lz * la = lu ; lc lh = 0 ; lc lk ; lc lf , lb ; ll lj [ l1 + 300 ] ; llld [ 9 ] [ 9 ] ; lc le [ 9 ] [ 9 ] ; li ( lp < 2 )  { ln ( lm , " \x44 \x75 \x64 \x65 \x2c \x20 \x70 \x61 " " \x73 \x73 \x20 \x61 \x20 \x66 \x69 \x6c \x65 \x6e \x61 \x6d \x65 \n " ) ; lr - 1 ; } la = lx ( lq [ 1 ] , " \x72 " ) ; li ( lu == la )  { ln ( lm , " \x44 \x75 \x64 \x65 \x2c \x20 \x70 \x61 \x73 " " \x73 \x20 \x61 \x20 \x56 \x41 \x4c \x49 \x44 \x20 \x66 \x69 \x6c \x65 \n " ) ; lr - 1 ; } ly ( la , " \x25 \x64 \n " , & lh ) ; lo ( lf = 1  ; lf <= lh ; lf ++ ) { lt ( ld , 0 , ls ( ld ) ) ; lt ( le , 0 , ls ( le ) ) ; lw ( la , ld , le ) ; l0 ( la , ld , le , lj , & lk ) ; lg ( " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a \x20 \x5b " , lf ) ; lo ( lb = 0  ; lb < lk ; lb ++ ) { li ( lb > 0 ) { lg ( " \x2c \x20 " ) ; } lg ( " \x25 \x63 " , lj [ lb ] ) ; } lg ( " \x5d \n " ) ; } }
>>>Func
METHOD l16
METHOD_RETURN lf
l0 l0("\x25\x64",&l6)
<operator>.lessThan lx<l6
<operator>.postIncrement lx++
IDENTIFIER l14 <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lf l16 ( ) { lf l6 , lx ; l0 ( " \x25 \x64 " , & l6 ) ; lo l12  l18 lg [ lt ] ; lo l4 lh [ lt ] [ lt ] ; lo lf ls [ lt ] [ lt ] ; lo l12  l13 ll [ lt ] ; lo lf l3 [ 10 ] ; lo lf lq [ 10 ] ; lo l4lk [ 10 ] ; lf li ; le ( lx = 0  ; lx < l6 ; lx ++ ) { lf ld , lw ; l0 ( " \x25 \x64 \x20 \x25 \x64 " , & ld , & lw ) ; lf la ; le ( la = 0  ; la < lw ; la ++ ) { l0 ( " \x25 \x64 " , & ( lg [ la ] . lg ) ) ; ( lg [ la ] . lg ) -- ; } le ( la = 0  ; la < lw ; la ++ ) { l0 ( " \x25 \x64 " , & ( lg [ la ] . lh ) ) ; ( lg [ la ] . lh ) -- ; } l8 ( lh , 0 , l1 ( lh ) ) ; le ( la = 0  ; la < lw ; la ++ ) { lh [ lg [ la ] . lg ] [ lg [ la ] . lh ] = 1 ; lh [ lg [ la ] . lh ] [ lg [ la ] . lg ] = 1 ; } le ( la = 0  ; la < ld ; la ++ ) { lh [ la ] [ ( la - 1 + ld ) % ld ] = 1 ; lh [ la ] [ ( la + 1 ) % ld ] = 1 ; } lf lb ; le ( la = 0  ; la < ld ; la ++ ) { le ( lb = 0  ; lb < ld ; lb ++ ) { ls [ la ] [ lb ] = -1 ; } } lf lc , l10 ; le ( la = 0  ; la < ld ; la ++ ) { l10 = ( la - 1 + ld ) % ld ; lb = ( la + 1 ) % ld ; lp ( lb != l10 )  { lc = lb ; l11 { lc = ( lc + 1 ) % ld ; } lp ( lh [ la ] [ lc ] == 0 ) ; ls [ lb ] [ la ] = lc ; lb = lc ; } } li = 0 ; lf ly = ld ; le ( la = 0  ; la < ld ; la ++ ) { le ( lb = 0  ; lb < ld ; lb ++ ) { lj ( ls [ la ] [ lb ] != -1 )  { ll [ li ] . lu = 0 ; lf ln , lm , l5 ; ln = la ; lm = lb ; l11  { ll [ li ] . lg [ ll [ li ] . lu ] = ln ; ( ll [ li ] . lu ) ++ ; l5 = ls [ ln ] [ lm ] ; ls [ ln ] [ lm ] = -1 ; ln = lm ; lm = l5 ; } lp ( ( ln != la ) || ( lm != lb ) ) ; lj ( ll [ li ] . lu < ly ) ly = ll [ li ] . lu ; li ++ ; } } } lf lv = 0 ; lf l9 = 1 ; le ( la = 0  ; la < ld ; la ++ ) l9 *= ld ; le ( la = 0  ; la < l9 ; la ++ ) { lc = la ; l8 ( lk , 0 , l1 ( lk ) ) ; le ( lb = 0  ; lb < ld ; lb ++ ) { lq [ lb ] = lc % ld ; lc /= ld ; lk [ lq [ lb ] ] = 1 ; } lb = 0 ; lp ( lk [ lb ] ) lb ++ ; lc = lb + 1 ; lp ( lc < 8 )  { lj ( lk [ lc ] ) l2 ; lc ++ ; } lj ( lc < 8 ) l15 ; lf lr ; l4 l7 = 1 ; le ( lr = 0  ; lr < li ; lr ++ ) { l8 ( lk , 0 , l1 ( lk ) ) ; le ( lc = 0  ; lc < ll [ lr ] . lu ; lc ++ ) { lk [ lq [ ll [ lr ] . lg [ lc ] ] ] = 1 ; } lc = 0 ; lp ( lc < lb )  { lj ( lk [ lc ] == 0 ) l2 ; lc ++ ; } lj ( lc != lb )  { l7 = 0 ; l2 ; } } lj ( l7 ) { lj ( lb > lv ) { lv = lb ; l17 ( l3 , lq , l1 ( lq ) ) ; lj ( lv == ly ) l2 ; } } } lz ( " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , lx + 1 , lv ) ; le ( la = 0  ; la < ld ; la ++ ) { lj ( la ) lz ( " \x20 " ) ; lz ( " \x25 \x64 " , l3 [ la ] + 1 ) ; } lz ( " \n " ) ; } l14 0 ; }
>>>Func
METHOD l7
METHOD_RETURN l2
<operator>.expressionList lq ly lx lw lr lu lp
<operator>.assignment la=(l0)l9(l15)
<operator>.assignment lv=lg(&la)
lh lh(&la,'\n')
<operator>.lessEqualsThan lm<=lv
<operator>.postIncrement lm++
IDENTIFIER l12 <empty>
LITERAL 0 <empty>
<operator>.cast (l0)l9(l15)
lg lg(&la)
l9 l9(l15)
>>>PDG&13 0->2 0->5 0->6 0->7 0->8 0->9 0->11 0->12 2->1 2->1 2->1 2->1 2->1 2->1 2->1 2->1 3->1 3->1 3->1 3->5 3->11 4->1 4->1 4->6 5->1 5->1 6->1 6->1 6->7 7->1 7->1 10->1 11->4 11->5 12->1 12->3 12->10
>>>Token l2 l7 ( ) { l0 la ; l2 lv , lj , ln , lm , ld , li , lk , l11 ; lb lb lq , ly , lx , lw , lr , lu , lp ; lo ls * lc ; lo l13 * l10 ; lt le , lf ; la = ( l0 ) l9 ( l15 ) ; lv = lg ( & la ) ; lh ( & la , ' \n ' ) ; ll ( lm = 1  ; lm <= lv ; lm ++ ) { lj = lg ( & la ) ; lh ( & la , ' ' ) ; lq = ( lb lb ) lg ( & la ) ; lh ( & la , ' ' ) ; ly = ( lb lb ) lg ( & la ) ; lh ( & la , ' ' ) ; lx = ( lb lb ) lg ( & la ) ; lh ( & la , ' ' ) ; lw = ( lb lb ) lg ( & la ) ; lh ( & la , ' ' ) ; lr = ( lb lb ) lg ( & la ) ; lh ( & la , ' ' ) ; lu = ( lb lb ) lg ( & la ) ; lh ( & la , ' ' ) ; lp = ( lb lb ) lg ( & la ) ; lh ( & la , ' \n ' ) ; lc = ( lo ls * ) l3 ( l14 ( lols ) * lj ) ; lc [ 0 ] . le = lr ; lc [ 0 ] . lf = lu ; ll ( ld = 1  ; ld < lj ; ld ++ ) { lc [ ld ] . le = ( lq * lc [ ld - 1 ] . le + ly ) % lp ; lc [ ld ] . lf = ( lx * lc [ ld - 1 ] . lf + lw ) % lp ; } ln = 0 ; ll ( ld = 0  ; ld < lj - 2 ; ld ++ ) { ll ( li = ld + 1  ; li < lj - 1 ; li ++ ) { ll ( lk = li + 1  ; lk < lj ; lk ++ ) { le = ( lt ) ( lc [ ld ] . le + lc [ li ] . le + lc [ lk ] . le ) / 3.0 ; lf = ( lt ) ( lc [ ld ] . lf + lc [ li ] . lf + lc [ lk ] . lf ) / 3.0 ; l6 ( le == lz ( le ) && lf == lz ( lf ) )  { ln ++ ; } } } } l5 ( l1 , " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x69 \x3a \x20 \x25 \x69 \n " , lm , ln ) ; l4 ( l1 ) ; l8 ( lc ) ; } l12 0 ; }
>>>Func
METHOD ld
METHOD_RETURN lf
PARAM lf*la
PARAM li lb
lc lc(la==lk)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
lc lc(lb>la->lb)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
lc lc(lb<la->lb)
BLOCK <empty> <empty>
<operator>.assignment la=ll(lb)
<operator>.assignment la->lh=ld(la->lh,lb)
<operator>.assignment la->lg=ld(la->lg,lb)
<operator>.equals la==lk
<operator>.greaterThan lb>la->lb
<operator>.lessThan lb<la->lb
ll ll(lb)
ld ld(la->lh,lb)
ld ld(la->lg,lb)
>>>PDG&21 0->2 0->3 0->5 0->6 0->8 0->9 0->11 0->15 0->16 0->17 0->18 0->19 0->20 2->15 3->18 4->1 4->1 7->1 7->1 10->1 10->1 12->1 12->1 12->1 13->1 13->1 13->1 14->1 14->1 14->1 15->1 15->4 15->4 16->7 16->7 16->17 16->19 17->1 17->10 17->10 17->20 18->12 18->16 19->13 19->13 19->17 20->1 20->14 20->14
>>>Token lf * ld ( lf * la , li lb ) { lc ( la == lk ) { la = ll ( lb ) ; } le lc ( lb > la - > lb ) { la -> lh = ld ( la -> lh , lb ) ; } le lc ( lb < la - > lb ) { la -> lg = ld ( la -> lg , lb ) ; } lj la ; }
>>>Func
METHOD ll
METHOD_RETURN lf
PARAM lk*la
PARAM li le[]
<operator>.assignment lb=lj(le)
lm lm(la->ld[lb])
BLOCK <empty> <empty>
lg lg("""\x4e\x6f\x6e\x65\x20\x65\x6e\x74\x72\x79\x20\x61\x74\x20\x67\x69\x76""\x65\x6e\x20\x6c\x61\x62\x65\x6c\n")
lj lj(le)
>>>PDG&9 0->2 0->3 0->6 0->7 0->8 2->1 3->8 4->1 4->1 4->1 5->1 5->1 7->1 8->1 8->4
>>>Token lf * ll ( lk * la , li le [ ] ) { lh lb = lj ( le ) ; lm ( la -> ld [ lb ] )  { lc la - > ld [ lb ] ; } lg ( " " " \x4e \x6f \x6e \x65 \x20 \x65 \x6e \x74 \x72 \x79 \x20 \x61 \x74 \x20 \x67 \x69 \x76 " " \x65 \x6e \x20 \x6c \x61 \x62 \x65 \x6c \n " ) ; lc ln ; }
>>>Func
METHOD ls
METHOD_RETURN lj
lr lr("""\x25\x64",&lq)
<operator>.lessEqualsThan ll<=lq
<operator>.postIncrement ll++
IDENTIFIER lt <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lj ls ( ) { lj lq , lk , li , ln ; lj ll ; lj ld , lh , lg , lc , lf , le ; lj lp ; lj la ; lr ( " " " \x25 \x64 " , & lq ) ; lb ( ll = 1  ; ll <= lq ; ll ++ ) { lr ( " \x25 \x64 \x25 \x64 \x25 \x64 " , & lk , & li , & ln ) ; lm ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , ll ) ; lo ( ln > lk * li )  { lm ( " \x49 \x4d \x50 \x4f \x53 \x53 \x49 \x42 \x4c \x45 \n " ) ; lu ; } la = 1 ; lb ( ld = 0  ; ld <= lk && la ; ld ++ ) { lb ( lg = 0  ; lg <= lk && la ; lg ++ ) { lb ( lf = 0  ; lf <= lk && la ; lf ++ ) { lb ( lh = 0  ; lh <= li && la ; lh ++ ) { lb ( lc = 0  ; lc <= li && la ; lc ++ ) { lb ( le = 0  ; le <= li && la ; le ++ ) { lp = lv ( ( lg * lh - ld * lc ) + ( lf * lc - lg * le ) + ( ld * le - lf * lh ) ) ; lo ( lp == ln )  { lm ( " \x25 \x64 \x20 \x25 \x64 \x20 \x25 \x64 \x20 \x25 \x64 \x20 \x25 \x64 \x20 " " \x25 \x64 \n " , ld , lh , lg , lc , lf , le ) ; la = 0 ; } } } } } } } lo ( la ) lm ( " \x49 \x4d \x50 " " \x4f \x53 \x53 \x49 \x42 \x4c \x45 \n " ) ; } lt 0 ; }
>>>Func
METHOD lg
METHOD_RETURN le
PARAM lf la
ld ld(la=='+'||la=='-')
BLOCK <empty> <empty>
IDENTIFIER lc <empty>
ld ld(la=='/'||la=='*'||la=='%')
BLOCK <empty> <empty>
IDENTIFIER lc <empty>
BLOCK <empty> <empty>
IDENTIFIER lb <empty>
LITERAL 0 <empty>
IDENTIFIER lb <empty>
LITERAL 1 <empty>
<operator>.subtraction lb-1
<operator>.logicalOr la=='+'||la=='-'
<operator>.logicalOr la=='/'||la=='*'||la=='%'
<operator>.equals la=='+'
<operator>.equals la=='-'
<operator>.logicalOr la=='/'||la=='*'
<operator>.equals la=='%'
<operator>.equals la=='/'
<operator>.equals la=='*'
>>>PDG&23 0->2 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->17 0->18 0->20 0->21 0->22 2->17 3->1 3->1 6->1 6->1 14->1 14->1 15->1 15->1 15->3 15->3 16->1 16->1 16->6 16->6 17->15 17->15 17->18 17->18 17->21 18->15 18->15 18->21 19->1 19->1 19->16 19->16 19->20 20->1 20->16 20->16 21->1 21->19 21->19 21->20 21->22 21->22 22->1 22->19 22->19 22->20
>>>Token le lg ( lf la ) { ld ( la == ' ' || la == ' ' )  { lb 0 ; } lc ld ( la == ' ' || la == ' ' || la == ' ' ) { lb 1 ; } lc  { lb - 1 ; } }
>>>Func
METHOD lg
METHOD_RETURN lh
lb lb("\x25\x64\n",ld)
lb lb("\x31\x20\x32")
<operator>.lessEqualsThan la<=le
<operator>.postIncrement la++
lb lb("\n")
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 3->1 4->1 4->1 4->5 5->1 5->1 6->1
>>>Token lh lg ( ) { lf la ; lb ( " \x25 \x64 \n " , ld ) ; lb ( " \x31 \x20 \x32 " ) ; li ( la = 3  ; la <= le ; la ++ ) { lj ( lc [ la ] <= ld ) ; lb ( " \x20 \x25 \x64 " , lc [ la ] ) ; } lb ( " \n " ) ; }
>>>Func
METHOD lh
METHOD_RETURN lb
lf lf("\x25\x64\n",&lc)
<operator>.lessThan la<lc
<operator>.postIncrement la++
>>>PDG&5 0->2 0->3 0->4 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lb lh ( ) { lb la ; lb lc ; lf ( " \x25 \x64 \n " , & lc ) ; li ( la = 0  ; la < lc ; la ++ ) { lb ld = lk ( ) ; lj ( ld < 0 )  { le ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , la + 1 ) ; } lg  { le ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , la + 1 , ld ) ; } } }
>>>Func
METHOD lv
METHOD_RETURN lt
<operator>.assignment ld=500
<operator>.assignment lf=2
<operator>.assignment lc=20
<operator>.lessThan la<lp(lc,ld)
<operator>.postIncrement la++
lq lq(lg,ld)
ln ln("""\x74\x65\x73\x74\x32\x2e\x63\x73\x76",lg,ld,lf)
ln ln("\x77\x32\x31\x2e""\x63\x73\x76",le,lc,lf)
lx lx(lg,le,ld,lf,lc,0.01)
ln ln("\x77\x32\x32\x2e""\x63\x73\x76",le,lc,lf)
<operator>.lessThan la<lp(lc,ld)
<operator>.postIncrement la++
ll ll(lg)
ll ll(le)
lp lp(lc,ld)
lp lp(lc,ld)
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->1 2->16 3->1 3->8 4->1 4->16 5->6 6->12 7->1 7->8 7->8 8->1 8->9 8->10 8->10 9->1 9->10 9->10 9->10 10->1 10->11 10->11 10->11 10->14 10->17 11->1 11->1 11->15 11->17 12->1 12->1 12->13 13->1 13->1 14->1 14->1 15->1 15->1 16->5 16->5 16->7 16->9 17->1 17->1 17->12 17->12
>>>Token lt lv ( ) { lh li , ld = 500 ; lh lf = 2 ; lh lc = 20 ; lb * * lg = ( lb * * ) lm ( ld * lk ( lb *  ) ) ; lb * * le = ( lb * * ) lm ( lc * lk ( lb *  ) ) ; lo ( lh  la = 0 ; la < lp ( lc , ld ) ; la ++ ) { lj ( la < ld ) lg [ la ] = ( lb * ) lm ( lf * lk ( lb ) ) ; lj ( la < lc )  { le [ la ] = ( lb * ) lm ( lf * lk ( lb ) ) ; lylr lw  lo ( li < ls ' ' >= 0  ; li < lf ; li ++ ) le [ la ] [ li ] = lu ( -1 , 1 ) ; } } lq ( lg , ld ) ; ln ( " " " \x74 \x65 \x73 \x74 \x32 \x2e \x63 \x73 \x76 " , lg , ld , lf ) ; ln ( " \x77 \x32 \x31 \x2e " " \x63 \x73 \x76 " , le , lc , lf ) ; lx ( lg , le , ld , lf , lc , 0.01 ) ; ln ( " \x77 \x32 \x32 \x2e " " \x63 \x73 \x76 " , le , lc , lf ) ; lo ( lh  la = 0 ; la < lp ( lc , ld ) ; la ++ ) { lj ( la < ld ) ll ( lg [ la ] ) ; lj ( la < lc ) ll ( le [ la ] ) ; } ll ( lg ) ; ll ( le ) ; }
>>>Func
METHOD li
METHOD_RETURN lh
PARAM le*lc
PARAM le ld
<operator>.assignment lb=0
<operator>.assignment la=0
<operator>.lessThan lb<ld
<operator>.postIncrement lb++
<operator>.postIncrement la++
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->6 4->1 4->6 5->1 5->8 6->1 6->1 6->7 7->1 7->1 8->1 8->1
>>>Token lh li ( le * lc , le ld ) { le lb = 0 , la = 0 ; lf ( lb = 0  ; lb < ld ; lb ++ ) { lg ( lc [ lb ] ) lc [ la ++ ] = lc [ lb ] ; } lf ( la  ; la < ld ; la ++ ) { lc [ la ] = 0 ; } }
>>>Func
METHOD lp
METHOD_RETURN lb
lf lf("\x25\x64",&lg)
<operator>.lessEqualsThan le<=lg
<operator>.postIncrement le++
IDENTIFIER lq <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lb lp ( ) { lb lg ; lf ( " \x25 \x64 " , & lg ) ; li ( lb  le = 1 ; le <= lg ; le ++ ) { lr lh [ 20 ] = " " " \x4e \x4f " ; lb la ; lf ( " \x25 \x64 " , & la ) ; lb lc [ la ] ; li ( lb  ld = 0 ; ld < la ; ld ++ ) lf ( " \x25 \x64 " , lc + ld ) ; lk ( lc , la , lo ( * lc ) , ll ) ; lj ( ! ln ( lc , la ) )  { ls ( lh , " \x25 " " \x64 " , lt ( lc + 1 , la - 1 ) ) ; } lm ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " " \x25 \x73 \n " , le , lh ) ; } lq 0 ; }
>>>Func
METHOD ln
METHOD_RETURN lt
<operator>.expressionList lc la
IDENTIFIER ld <empty>
<operator>.assignment lc=0
<operator>.assignment la=lu
lj lj("\x25\x64\x20\x25""\x64",&lm,&lh)
<operator>.assignmentMultiplication lh*=2
<operator>.lessThan lb<lm
<operator>.postIncrement lb++
lg lg(ll(0))
BLOCK <empty> <empty>
lq lq(la-lc>1)
BLOCK <empty> <empty>
lg lg(la&1)
lf lf("\x25\x6c""\x6c\x64\x2e\x35\n",la/2)
IDENTIFIER lk <empty>
lf lf("\x25\x6c\x6c\x64\x2e\x30\n",la/2)
lf lf("\x30\x2e\x30\n")
IDENTIFIER lr <empty>
<operator>.assignment ld=lc+(la-lc)/2
<operator>.assignment la=ld
<operator>.assignment lc=ld
ll ll(0)
<operator>.greaterThan la-lc>1
<operator>.and la&1
<operator>.division la/2
<operator>.division la/2
<operator>.subtraction la-lc
<operator>.addition lc+(la-lc)/2
<operator>.division (la-lc)/2
<operator>.subtraction la-lc
>>>PDG&32 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->1 4->1 4->28 5->1 5->1 5->28 6->1 6->1 6->1 6->7 6->8 7->1 7->1 8->1 8->1 8->9 9->1 9->1 10->1 10->1 12->1 12->1 14->1 14->1 15->1 17->1 17->1 18->1 20->1 20->1 20->21 20->22 21->1 21->25 22->1 22->1 22->1 23->10 24->12 24->12 25->14 25->14 25->26 26->15 26->15 26->27 27->1 27->17 27->17 28->24 28->24 28->31 28->31 29->1 30->1 30->20 30->20 30->29 30->29 31->20 31->29 31->30 31->30
>>>Token lt ln ( ) { le le lc , la ; le le ld ; ls lb ; lc = 0 ; la = lu ; lj ( " \x25 \x64 \x20 \x25 " " \x64 " , & lm , & lh ) ; lh *= 2 ; lo ( lb = 0  ; lb < lm ; lb ++ ) { lj ( " \x25 \x64 \x20 \x25 \x64 " , & li [ lb ] , & lp [ lb ] ) ; li [ lb ] *= 2 ; } lg ( ll ( 0 ) )  { lf ( " \x30 \x2e \x30 \n " ) ; lr ; } lq ( la - lc > 1 )  { ld = lc + ( la - lc ) / 2 ; lg ( ll ( ld ) ) la = ld ; lk lc = ld ; } lg ( la & 1 )  lf ( " \x25 \x6c " " \x6c \x64 \x2e \x35 \n " , la / 2 ) ; lk lf ( " \x25 \x6c \x6c \x64 \x2e \x30 \n " , la / 2 ) ; }
>>>Func
METHOD lw
METHOD_RETURN lf
lg lg("\x25\x64",&ls)
<operator>.lessThan lj<ls
<operator>.postIncrement lj++
IDENTIFIER lx <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lf lw ( ) { lf ls , lj ; lg ( " \x25 \x64 " , & ls ) ; lh ( lj = 0  ; lj < ls ; lj ++ ) { lf le , lb ; lo li [ 1000 ] [ 1000 ] , ll [ 1000 ] [ 1000 ] ; lt ( li , 0 , 1000000 ) ; lt ( ll , 0 , 1000000 ) ; lg ( " " " \x25 \x64 " , & le ) ; lo la [ 100 ] ; lh ( lb = 0  ; lb < le ; lb ++ ) { lg ( " \x25 \x73 " , la ) ; li [ la [ 0 ] ] [ la [ 1 ] ] = li [ la [ 1 ] ] [ la [ 0 ] ] = la [ 2 ] ; } lg ( " \x25 \x64 " , & le ) ; lh ( lb = 0  ; lb < le ; lb ++ ) { lg ( " \x25 \x73 " , la ) ; ll [ la [ 0 ] ] [ la [ 1 ] ] = la [ 1 ] ; ll [ la [ 1 ] ] [ la [ 0 ] ] = la [ 0 ] ; } lo ld [ 10000 ] ; lf lc = 0 ; lg ( " \x25 \x64 \x25 \x73 " , & le , la ) ; lh ( lb = 0  ; lb < le ; lb ++ ) { lf lr = 0 ; lo lp = la [ lb ] ; ly ( lc != 0 && li [ lp ] [ ld [ lc - 1 ] ] != 0 )  { lr = 1 ; ld [ lc - 1 ] = li [ lp ] [ ld [ lc - 1 ] ] ; lp = ld [ -- lc ] ; } lm ( lr == 1 )  { lc ++ ; lu ; } lf lk , lq = 1 ; lh ( lk = 0  ; lk < lc ; lk ++ ) { lm ( ll [ la [ lb ] ] [ ld [ lk ] ] != 0 )  { lc = 0 ; lq = 0 ; lv ; } } lm ( lq == 0 ) lu ; ld [ lc ++ ] = la [ lb ] ; } ln ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lj + 1 ) ; lm ( lc != 0 )  ln ( " \x25 \x63 " , ld [ 0 ] ) ; lh ( lb = 1  ; lb < lc ; lb ++ ) { ln ( " \x2c \x20 " " \x25 \x63 " , ld [ lb ] ) ; } ln ( " \x5d \n " ) ; } lx 0 ; }
>>>Func
METHOD l13
METHOD_RETURN le
PARAM le l5
PARAM l7* *lu
<operator>.assignment lm=0
<operator>.assignment lj=0
<operator>.expressionList lq=0 lp=0
<operator>.expressionList ls=0 ln=0
<operator>.assignment lv=0
<operator>.assignment lz=0
<operator>.assignment lt=0
<operator>.assignment ly=0
<operator>.assignment lo=0
<operator>.assignment lf=0
<operator>.assignment lc=0
<operator>.assignment lh=0
<operator>.assignment ll=0
<operator>.assignment lx[l10]={0}
lw lw(l5==3)
BLOCK <empty> <empty>
IDENTIFIER l11 <empty>
BLOCK <empty> <empty>
IDENTIFIER l2 <empty>
LITERAL 0 <empty>
<operator>.assignment lb=l6(lu[1],"\x72")
<operator>.assignment lr=l6(lu[2],"\x77")
lw lw(lb==l14)
BLOCK <empty> <empty>
lg lg(lb,"\x25\x64",&lm)
l1 l1(lb)
<operator>.lessThan lf<lm
<operator>.postIncrement lf++
<operator>.lessThan lf<lm
<operator>.postIncrement lf++
l3 l3(lb)
l3 l3(lr)
l0 l0("\x45\x52\x52""\x4f\x52")
<operator>.assignment lq=0
<operator>.assignment lp=0
<operator>.assignment ls=0
<operator>.assignment ln=0
<operator>.arrayInitializer {0}
<operator>.equals l5==3
l0 l0("\x66\x69\x6c\x65\x20\x6f\x70\x65\x6e\x20\x66\x61\x69\x6c""\x65\x64")
<operator>.subtraction l2-1
l6 l6(lu[1],"\x72")
l6 l6(lu[2],"\x77")
<operator>.equals lb==l14
>>>PDG&48 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->19 0->20 0->21 0->22 0->23 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 2->42 3->1 3->45 3->46 4->1 4->28 4->30 5->1 5->1 6->1 6->1 6->1 7->1 7->1 7->1 8->1 8->1 9->1 9->1 10->1 10->1 11->1 11->1 12->1 12->1 13->1 13->30 14->1 14->1 15->1 15->1 16->1 16->1 17->1 17->1 17->1 18->1 18->1 24->1 24->1 24->47 25->1 25->1 25->35 26->1 26->1 28->1 28->1 28->29 28->30 28->32 29->1 29->34 30->31 30->32 31->32 32->1 32->1 32->33 33->1 33->1 34->1 34->1 35->1 35->1 36->1 37->1 37->6 38->1 38->6 39->1 39->7 40->1 40->7 41->17 42->1 42->18 42->18 43->1 44->1 44->1 45->1 45->24 45->24 46->1 46->25 46->25 47->1 47->26 47->26 47->28
>>>Token le l13 ( le l5 , l7 * * lu ) { l4 * lb ; l4 * lr ; le lm = 0 ; la la ld [ l12 ] [ 2 ] = { { 0 } } ; le lj = 0 ; la la lq = 0 , lp = 0 ; la la ls = 0 , ln = 0 ; la la lv = 0 ; la la lz = 0 ; la la lt = 0 ; la la ly = 0 ; la la lo = 0 ; le lf = 0 ; le lc = 0 ; le lh = 0 ; le ll = 0 ; le lx [ l10 ] = { 0 } ; la l8 li [ 2 ] = { 0 } ; lw ( l5 == 3 )  { lb = l6 ( lu [ 1 ] , " \x72 " ) ; lr = l6 ( lu [ 2 ] , " \x77 " ) ; lw ( lb == l14 )  { l0 ( " \x66 \x69 \x6c \x65 \x20 \x6f \x70 \x65 \x6e \x20 \x66 \x61 \x69 \x6c " " \x65 \x64 " ) ; l2 - 1 ; } lg ( lb , " \x25 \x64 " , & lm ) ; l1 ( lb ) ; lk ( lf = 0  ; lf < lm ; lf ++ ) { lg ( lb , " \x25 \x64 " , & lj ) ; lg ( lb , " \x25 \x4c \x64 " , & lv ) ; lg ( lb , " \x25 \x4c \x64 " , & lz ) ; lg ( lb , " \x25 \x4c \x64 " , & lt ) ; lg ( lb , " \x25 \x4c \x64 " , & ly ) ; lg ( lb , " \x25 " " \x4c \x64 " , & lq ) ; lg ( lb , " \x25 \x4c \x64 " , & lp ) ; lg ( lb , " \x25 \x4c \x64 " , & lo ) ; l1 ( lb ) ; ld [ 0 ] [ 0 ] = lq ; ld [ 0 ] [ 1 ] = lp ; ls = lq ; ln = lp ; lk ( lc = 1  ; lc < lj ; lc ++ ) { ld [ lc ] [ 0 ] = ( lv * ls + lz ) % lo ; ld [ lc ] [ 1 ] = ( lt * ln + ly ) % lo ; ls = ld [ lc ] [ 0 ] ; ln = ld [ lc ] [ 1 ] ; } lk ( lc = 0  ; lc < lj - 2 ; lc ++ ) { lk ( lh = lc + 1  ; lh < lj - 1 ; lh ++ ) { lk ( ll = lh + 1  ; ll < lj ; ll ++ ) { li [ 0 ] = ( ld [ lc ] [ 0 ] + ld [ lh ] [ 0 ] + ld [ ll ] [ 0 ] ) / 3.0 ; li [ 1 ] = ( ld [ lc ] [ 1 ] + ld [ lh ] [ 1 ] + ld [ ll ] [ 1 ] ) / 3.0 ; lw ( ( li [ 0 ] == ( le ) li [ 0 ] ) && ( li [ 1 ] == ( le ) li [ 1 ] ) )  { lx [ lf ] ++ ; } } } } } lk ( lf = 0  ; lf < lm ; lf ++ ) { l9 ( lr , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a " " \x20 \x25 \x64 \n " , ( lf + 1 ) , lx [ lf ] ) ; } l3 ( lb ) ; l3 ( lr ) ; } l11  { l0 ( " \x45 \x52 \x52 " " \x4f \x52 " ) ; } l2 0 ; }
>>>Func
METHOD li
METHOD_RETURN le
PARAM lf*la
<operator>.assignment lc=lg(la)-1
<operator>.lessThan lb<(lg(la)/2)
<operator>.postIncrement lb++
IDENTIFIER lh <empty>
LITERAL 0 <empty>
<operator>.subtraction lg(la)-1
<operator>.division lg(la)/2
lg lg(la)
lg lg(la)
>>>PDG&12 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->10 3->1 3->1 3->1 4->1 4->1 4->5 5->1 5->1 8->3 8->3 9->1 9->4 9->4 10->8 10->11 11->1 11->9
>>>Token le li ( lf * la ) { le lc = lg ( la ) - 1 ; lf ld ; lj ( le  lb = 0 ; lb < ( lg ( la ) / 2 ) ; lb ++ ) { ld = la [ lb ] ; la [ lb ] = la [ lc ] ; la [ lc ] = ld ; lc -- ; } lh 0 ; }
>>>Func
METHOD ls
METHOD_RETURN lf
PARAM lf*ld
PARAM lv li
PARAM lp le
lh lh(ld==lm)
BLOCK <empty> <empty>
lh lh(le>0)
BLOCK <empty> <empty>
<operator>.assignment ld=lq(li)
<operator>.assignment *la=ld
<operator>.assignment *lj=la
<operator>.assignment lk=1
<operator>.assignment ln=1
<operator>.assignment lo=0
lr lr(lj!=lm)
BLOCK <empty> <empty>
lh lh(le==1)
BLOCK <empty> <empty>
lh lh(lo+2>le)
BLOCK <empty> <empty>
<operator>.equals ld==lm
<operator>.greaterThan le>0
<operator>.postIncrement lo++
<operator>.assignment lj=lj->lc
<operator>.assignment *lb=lq(li)
<operator>.assignment lb->lc=la
<operator>.assignment la->lg=lb
<operator>.assignment ld=lb
lr lr(la->lc!=lm&&ln<le)
BLOCK <empty> <empty>
<operator>.assignment *lb=(lf* )lt(lu(lf))
<operator>.assignment lb->li=li
lh lh(lk==le)
BLOCK <empty> <empty>
lh lh(lk<le)
BLOCK <empty> <empty>
lq lq(li)
<operator>.notEquals lj!=lm
<operator>.equals le==1
<operator>.greaterThan lo+2>le
<operator>.postIncrement lk++
<operator>.postIncrement ln++
<operator>.assignment la=la->lc
<operator>.assignment la->lg->lc=lb
<operator>.assignment lb->lc=la
<operator>.assignment lb->lg=la->lg
<operator>.assignment la->lg=lb
<operator>.assignment lb->lc=la->lc
<operator>.assignment lb->lg=la
<operator>.assignment la->lc=lb
lq lq(li)
<operator>.addition lo+2
<operator>.logicalAnd la->lc!=lm&&ln<le
<operator>.cast (lf* )lt(lu(lf))
<operator>.equals lk==le
<operator>.lessThan lk<le
<operator>.notEquals la->lc!=lm
<operator>.lessThan ln<le
lt lt(lu(lf))
lu lu(lf)
>>>PDG&61 0->2 0->3 0->4 0->6 0->8 0->10 0->11 0->12 0->13 0->14 0->16 0->18 0->20 0->21 0->22 0->23 0->26 0->27 0->28 0->30 0->32 0->34 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->47 0->49 0->50 0->51 0->52 0->55 0->56 0->57 0->58 0->60 2->21 3->37 4->22 5->1 5->1 7->1 7->1 9->1 9->10 10->1 10->11 10->26 11->1 11->38 12->1 12->41 13->1 13->42 13->58 14->1 14->23 15->1 15->1 17->1 17->1 19->1 19->1 21->5 21->5 21->38 22->7 22->7 22->39 23->1 23->40 23->52 24->1 24->1 24->1 25->1 25->1 25->27 25->28 27->46 28->1 28->1 29->1 29->1 31->1 31->1 31->44 31->47 31->50 32->1 32->1 32->1 33->1 33->1 35->1 35->1 37->9 37->51 38->15 38->15 38->57 39->17 39->17 39->40 40->1 40->19 40->19 40->55 40->58 41->1 41->55 42->1 42->1 43->1 43->45 43->49 44->1 44->1 45->1 46->1 47->1 47->1 48->1 48->1 49->1 49->1 49->1 50->1 50->1 50->1 51->25 51->32 52->1 53->1 53->1 53->29 53->29 54->1 55->33 55->33 55->56 55->56 56->1 56->1 56->35 56->35 57->1 57->43 57->48 57->53 57->53 57->58 58->42 58->53 58->53 58->55 59->1 59->31 59->54 60->1 60->59
>>>Token lf * ls ( lf * ld , lv li , lp le ) { lh ( ld == lm ) { ld = lq ( li ) ; ll ld ; } lh ( le > 0 ) { lf * la = ld , * lj = la ; lp lk = 1 , ln = 1 , lo = 0 ; lr ( lj != lm )  { lo ++ ; lj = lj -> lc ; } lh ( le == 1 )  { lf * lb = lq ( li ) ; lb -> lc = la ; la -> lg = lb ; ld = lb ; ll ld ; } lh ( lo + 2 > le )  { lr ( la -> lc != lm && ln < le )  { lk ++ ; ln ++ ; la = la -> lc ; } lf * lb = ( lf * ) lt ( lu ( lf ) ) ; lb -> li = li ; lh ( lk == le )  { la -> lg -> lc = lb ; lb -> lc = la ; lb -> lg = la -> lg ; la -> lg = lb ; } lh ( lk < le )  { lb -> lc = la -> lc ; lb -> lg = la ; la -> lc = lb ; } } ll ld ; } }
>>>Func
METHOD ln
METHOD_RETURN lc
lm lm("\x25\x64",&lh)
<operator>.lessEqualsThan lg<=lh
<operator>.postIncrement lg++
IDENTIFIER lp <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lc ln ( ) { lc lh ; lm ( " \x25 \x64 " , & lh ) ; lk ( lc  lg = 1 ; lg <= lh ; lg ++ ) { lc lb = 0 ; lo llll lf , le , la ; lm ( " \x25 \x6c \x6c \x64 \x20 \x25 \x6c \x6c \x64 \x20 \x25 \x6c \x6c " " \x64 " , & lf , & le , & la ) ; li ( la == 100 || la == 0 ) lb = ( le == la ) ; lj li ( lf >= 100 ) lb = 1 ; lj lk ( lc ld  = 1 ; ld <= lf ; ld ++ ) li ( ( ld * le ) % 100 == 0 ) lb = 1 ; lq ( " \x43 \x61 \x73 \x65 " " \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x73 \n " , lg , lb ? " \x50 \x6f \x73 \x73 \x69 \x62 " " \x6c \x65 " : " \x42 \x72 \x6f \x6b \x65 \x6e " ) ; } lp 0 ; }
>>>Func
METHOD lu
METHOD_RETURN lt
PARAM lh lg[10][10]
PARAM lh lc
le le(lc==1)
BLOCK <empty> <empty>
IDENTIFIER ln <empty>
BLOCK <empty> <empty>
<operator>.assignment lf=lk-'A'
<operator>.assignmentMinus ld-=1
le le(lc==1)
BLOCK <empty> <empty>
le le(ll=='H')
BLOCK <empty> <empty>
le le(ll=='V')
BLOCK <empty> <empty>
lm lm("\x25\x64""\x20\x25\x63",&ld,&lk)
lq lq(lo(ld,lk)!=1||lp(lg lc (ld-1) (lk-65),'H')!=1)
BLOCK <empty> <empty>
lm lm("\x25\x64\x20\x25\x63\x20\x25\x63",&ld,&lk,&ll)
lq lq(lo(ld,lk)==0||lp(lg lc (ld-1) (lk-65),ll)==0)
BLOCK <empty> <empty>
<operator>.lessThan lj<(lf+lc)
<operator>.postIncrement lj++
<operator>.lessThan la<(ld+lc+1)
<operator>.postIncrement la++
<operator>.lessThan lj<(lf+lc)
<operator>.postIncrement lj++
le le(lc==3)
BLOCK <empty> <empty>
IDENTIFIER ln <empty>
BLOCK <empty> <empty>
<operator>.lessThan lj<(ld+lc)
<operator>.postIncrement lj++
le le(lc==3)
BLOCK <empty> <empty>
IDENTIFIER ln <empty>
BLOCK <empty> <empty>
<operator>.equals lc==1
lr lr("\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x75\x6e\x61\x76\x61\x69""\x6c\x61\x62\x6c\x65\x21\n")
lm lm("\x25\x64\x20\x25\x63",&ld,&lk)
lr lr("\x50\x6f\x73\x69\x74\x69\x6f\x6e""\x20\x75\x6e\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x21\n")
lm lm("\x25""\x64\x20\x25\x63\x20\x25\x63",&ld,&lk,&ll)
<operator>.subtraction lk-'A'
<operator>.equals lc==1
<operator>.equals ll=='H'
<operator>.lessThan la<(ld+lc-1)
<operator>.postIncrement la++
<operator>.lessThan la<(ld+lc)
<operator>.postIncrement la++
<operator>.equals ll=='V'
<operator>.lessThan la<(ld+lc+1)
<operator>.postIncrement la++
<operator>.lessThan la<(ld+lc+1)
<operator>.postIncrement la++
<operator>.logicalOr lo(ld,lk)!=1||lp(lg lc (ld-1) (lk-65),'H')!=1
<operator>.logicalOr lo(ld,lk)==0||lp(lg lc (ld-1) (lk-65),ll)==0
<operator>.addition lf+lc
<operator>.addition ld+lc+1
<operator>.addition lf+lc
<operator>.equals lc==3
<operator>.addition ld+lc
<operator>.equals lc==3
<operator>.notEquals lo(ld,lk)!=1
<operator>.notEquals lp(lg lc (ld-1) (lk-65),'H')!=1
<operator>.equals lo(ld,lk)==0
<operator>.equals lp(lg lc (ld-1) (lk-65),ll)==0
<operator>.addition ld+lc
<operator>.subtraction ld+lc-1
<operator>.addition ld+lc
<operator>.addition ld+lc+1
<operator>.addition ld+lc+1
lo lo(ld,lk)
lp lp(lg lc (ld-1) (lk-65),'H')
lo lo(ld,lk)
lp lp(lg lc (ld-1) (lk-65),ll)
<operator>.addition ld+lc
<operator>.addition ld+lc
<operator>.addition ld+lc
<operator>.subtraction ld-1
<operator>.subtraction lk-65
<operator>.subtraction ld-1
<operator>.subtraction lk-65
>>>PDG&83 0->2 0->3 0->5 0->6 0->7 0->9 0->11 0->13 0->15 0->16 0->18 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 2->1 2->73 2->75 3->38 8->1 8->1 8->22 8->26 8->57 8->59 9->1 9->24 9->32 9->48 9->51 9->53 9->58 9->61 9->67 9->68 9->69 9->70 9->71 9->76 9->77 9->78 10->1 10->1 12->1 12->1 14->1 14->1 16->1 16->19 16->19 16->40 16->40 16->72 16->72 16->74 16->74 16->79 16->80 17->1 17->1 19->1 19->9 19->42 19->42 19->42 19->43 19->45 19->74 19->74 19->75 19->81 19->82 20->1 20->1 22->23 23->26 24->25 25->46 26->1 26->1 26->27 27->32 32->1 32->33 33->1 33->1 34->1 34->1 38->4 38->4 38->44 38->73 38->75 39->1 40->1 40->19 40->19 40->74 40->74 41->1 42->1 42->1 42->1 42->1 42->9 42->24 42->32 42->43 42->45 42->48 42->50 42->51 42->53 42->58 42->61 42->67 42->68 42->69 42->70 42->71 42->76 42->77 42->78 43->1 43->8 43->8 44->10 44->10 44->22 44->24 44->26 44->57 44->58 44->59 44->60 44->67 45->12 45->12 45->50 46->1 46->1 46->47 47->48 48->1 48->49 49->51 50->1 50->14 50->14 51->52 52->53 53->1 53->1 53->54 54->1 54->1 55->1 55->1 55->17 55->17 56->1 56->1 56->20 56->20 59->1 60->28 60->28 60->32 60->48 60->61 60->62 60->68 60->69 60->76 62->34 62->34 62->51 62->53 62->70 62->71 62->77 62->78 63->55 63->55 63->64 63->73 63->79 63->80 64->1 64->55 64->55 65->1 65->56 65->56 65->66 65->75 65->81 65->82 66->1 66->56 66->56 68->46 68->46 71->1 72->19 72->19 72->40 72->40 72->63 72->63 72->74 72->74 72->79 72->80 73->1 73->1 73->1 73->44 73->64 73->64 73->64 73->64 73->64 73->75 73->75 74->9 74->42 74->42 74->43 74->65 74->65 74->81 74->82 75->1 75->1 75->1 75->42 75->44 75->45 75->66 75->66 75->66 75->66 75->66 78->1 78->1 79->19 79->40 79->73 79->73 79->74 80->19 80->40 80->73 80->73 80->74 81->9 81->42 81->75 81->75 82->42 82->43 82->75 82->75
>>>Token lt lu ( lh lg [ 10 ] [ 10 ] , lh lc ) { lh ld , lj ; ls lk , ll ; le ( lc == 1 )  { lm ( " \x25 \x64 " " \x20 \x25 \x63 " , & ld , & lk ) ; lq ( lo ( ld , lk ) != 1 || lp ( lg , lc , ( ld - 1 ) , ( lk - 65 ) , ' ' ) != 1 )  { lr ( " \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x75 \x6e \x61 \x76 \x61 \x69 " " \x6c \x61 \x62 \x6c \x65 \x21 \n " ) ; lm ( " \x25 \x64 \x20 \x25 \x63 " , & ld , & lk ) ; } } ln  { lm ( " \x25 \x64 \x20 \x25 \x63 \x20 \x25 \x63 " , & ld , & lk , & ll ) ; lq ( lo ( ld , lk ) == 0 || lp ( lg , lc , ( ld - 1 ) , ( lk - 65 ) , ll ) == 0 )  { lr ( " \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e " " \x20 \x75 \x6e \x61 \x76 \x61 \x69 \x6c \x61 \x62 \x6c \x65 \x21 \n " ) ; lm ( " \x25 " " \x64 \x20 \x25 \x63 \x20 \x25 \x63 " , & ld , & lk , & ll ) ; } } lh lf = lk - ' ' ; ld -= 1 ; le ( lc == 1 )  { li ( lj = lf  ; lj < ( lf + lc ) ; lj ++ ) { lg [ ld ] [ lj ] = lc ; } li ( lh  la = ld - 1 ; la < ( ld + lc + 1 ) ; la ++ ) { li ( lh  lb = lf - 1 ; lb < ( lf + lc + 1 ) ; lb ++ ) { le ( la >= 0 && la <= 9 && lb >= 0 && lb <= 9 )  { le ( lg [ la ] [ lb ] != lc )  { lg [ la ] [ lb ] = -1 ; } } } } } le ( ll == ' ' )  { li ( lj = lf  ; lj < ( lf + lc ) ; lj ++ ) { lg [ ld ] [ lj ] = lc ; } le ( lc == 3 )  { li ( lh  la = ld - 1 ; la < ( ld + lc - 1 ) ; la ++ ) { li ( lh  lb = lf - 1 ; lb < ( lf + lc + 1 ) ; lb ++ ) { le ( la >= 0 && la <= 9 && lb >= 0 && lb <= 9 )  { le ( lg [ la ] [ lb ] != lc )  { lg [ la ] [ lb ] = -1 ; } } } } } ln { li ( lh la  = ld - 1 ; la < ( ld + lc ) ; la ++ ) { li ( lh  lb = lf - 1 ; lb < ( lf + lc + 1 ) ; lb ++ ) { le ( la >= 0 && la <= 9 && lb >= 0 && lb <= 9 )  { le ( lg [ la ] [ lb ] != lc )  { lg [ la ] [ lb ] = -1 ; } } } } } } le ( ll == ' ' )  { li ( lj = ld  ; lj < ( ld + lc ) ; lj ++ ) { lg [ lj ] [ lf ] = lc ; } le ( lc == 3 )  { li ( lh  la = ld - 1 ; la < ( ld + lc + 1 ) ; la ++ ) { li ( lh  lb = lf - 1 ; lb < ( lf + lc - 1 ) ; lb ++ ) { le ( la >= 0 && la <= 9 && lb >= 0 && lb <= 9 )  { le ( lg [ la ] [ lb ] != lc )  { lg [ la ] [ lb ] = -1 ; } } } } } ln { li ( lh la  = ld - 1 ; la < ( ld + lc + 1 ) ; la ++ ) { li ( lh  lb = lf - 1 ; lb < ( lf + lc ) ; lb ++ ) { le ( la >= 0 && la <= 9 && lb >= 0 && lb <= 9 )  { le ( lg [ la ] [ lb ] != lc )  { lg [ la ] [ lb ] = -1 ; } } } } } } }
>>>Func
METHOD l0
METHOD_RETURN lr
<operator>.assignment lq=0
<operator>.assignment lc=0
<operator>.assignment lg=0
<operator>.assignment lh=0
<operator>.assignment le=0
<operator>.assignment lp=0
<operator>.assignment lx=0
<operator>.assignment lv=0
<operator>.assignment lw=0
lj lj("\x25\x64",&lq)
<operator>.lessEqualsThan lb<=lq
<operator>.postIncrement lb++
<operator>.lessEqualsThan lb<=lq
<operator>.postIncrement lb++
IDENTIFIER l1 <empty>
LITERAL 0 <empty>
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->1 2->11 2->12 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 9->1 9->1 10->1 10->1 11->1 11->1 11->12 11->14 12->13 12->14 13->14 14->1 14->1 14->15 15->1 15->1
>>>Token lr l0 ( ) { lr lq = 0 ; lz li [ 101 ] [ 5 ] , ll [ 101 ] [ 4 ] , lm [ 101 ] [ 12 ] ; lr lb , ld , lc = 0 , lg = 0 , lh = 0 , le = 0 , lp = 0 ; lr lx = 0 , lv = 0 , lw = 0 ; lz * la , lu [ 12 ] ; lj ( " \x25 \x64 " , & lq ) ; ln ( lb = 1  ; lb <= lq ; lb ++ ) { lj ( " \x25 \x64 " , & lx ) ; lf ( lx != 0 )  lj ( " \x25 \x73 " , li [ lb ] ) ; lj ( " \x25 \x64 " , & lv ) ; lf ( lv != 0 )  lj ( " \x25 \x73 " , ll [ lb ] ) ; lj ( " \x25 \x64 " , & lw ) ; lf ( lw != 0 )  lj ( " \x25 \x73 " , lm [ lb ] ) ; } ln ( lb = 1  ; lb <= lq ; lb ++ ) { la = lm [ lb ] ; lp = lo ( la ) ; lu [ 0 ] = lm [ lb ] [ 0 ] ; ln ( ld = 1  ; ld < ( lo ( la ) ) ; ld ++ ) { lf ( ( ( la [ ld - 1 ] == li [ lb ] [ 0 ] ) && ( la [ ld ] == li [ lb ] [ 1 ] ) ) || ( ( la [ ld - 1 ] == li [ lb ] [ 1 ] ) && ( la [ ld ] == li [ lb ] [ 0 ] ) ) )  { lc = ld ; la [ ld - 1 ] = li [ lb ] [ 2 ] ; lt ( lc <= ( lo ( la ) - 1 ) )  { la [ lc ] = la [ lc + 1 ] ; lc ++ ; } lc = 0 ; } lk lf ( la [ ld ] = = ll [ lb ] [ 1 ] ) { lc = ld - 1 ; lt ( lc >= 0 )  { lf ( la [ lc ] == ll [ lb ] [ 0 ] )  { ln ( le = 0  ; le < lp ; le ++ ) { lf ( ( le >= lc && le <= ld ) )  { la [ lh ++ ] = ' ' ; } lk { la [ lh ++ ] = lm [ lb ] [ le ] ; } } la [ lh ] = ' \0 ' ; lh = 0 ; ly ; } lc -- ; } } lk lf ( la [ ld ] = = ll [ lb ] [ 0 ] ) { lc = ld - 1 ; lt ( lc >= 0 )  { lf ( la [ lc ] == ll [ lb ] [ 1 ] )  { ln ( le = 0  ; le < lp ; le ++ ) { lf ( ( le >= lc && le <= ld ) )  { la [ lh ++ ] = ' ' ; } lk { la [ lh ++ ] = lm [ lb ] [ le ] ; } } la [ lh ] = ' \0 ' ; lh = 0 ; ly ; } lc -- ; } } lk  { } } lu [ lg ] = ' \0 ' ; ls ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a " " \x20 \x5b " , lb ) ; ln ( lg = 0  ; lg < lo ( la ) ; lg ++ ) { lf ( la [ lg ] == ' ' )  { } lk  { lf ( lg == lo ( la ) - 1 )  { ls ( " \x25 \x63 " , la [ lg ] ) ; } lk  { ls ( " \x25 \x63 \x2c \x20 " , la [ lg ] ) ; } } } ls ( " " " \x5d \n " ) ; lg = 0 , lh = 0 ; } l1 0 ; }
>>>Func
METHOD ly
METHOD_RETURN li
lf lf("\x25\x64",&lw)
<operator>.lessThan lk<lw
<operator>.postIncrement lk++
IDENTIFIER lz <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token li ly ( ) { li lk , la ; li lw , lq , lp , lj ; lv lh [ 4 ] , ls [ 3 ] ; lv lb [ 100 ] , l3 [ 100 ] , ln [ 100 ] ; li le , lx , ld , lo ; lv lt , l2 ; li lg , ll ; lf ( " \x25 \x64 " , & lw ) ; lm ( lk = 0  ; lk < lw ; lk ++ ) { lg = 0 ; lf ( " \x25 \x64 " , & lq ) ; lm ( la = 0  ; la < lq ; la ++ ) { lf ( " \x25 \x73 " , lh ) ; } lf ( " \x25 \x64 " , & lp ) ; lm ( la = 0  ; la < lp ; la ++ ) { lf ( " \x25 \x73 " , ls ) ; } lf ( " \x25 " " \x64 " , & lj ) ; lf ( " \x25 \x73 " , lb ) ; le = -1 ; lx = -1 ; ld = -1 ; lo = -1 ; lm ( la = 0  ; la < lj ; la ++ ) { li l0 ; lc ( lp > 0 )  lc ( lb [ la ] == ls [ 0 ] || lb [ la ] == ls [ 1 ] )  { lc ( le == -1 ) { le = la ; lt = lb [ la ] ; ll = 0 ; } lu lc ( lb [ la ] ! = lt ) { le = -1 ; lg -= ll ; l1 ; } } lc ( lq > 0 )  lc ( lb [ la ] == lh [ 0 ] && lb [ la + 1 ] == lh [ 1 ] && la < lj - 1 )  { ld = la ; lo = la + 1 ; } lu lc ( lb [ la ] = = lh [ 1 ] && lb [ la + 1 ] == lh [ 0 ] && la < lj - 1 ) { ld = la ; lo = la + 1 ; } lc ( ld != -1 )  { lc ( le == ld ) le = -1 ; ln [ lg ++ ] = lh [ 2 ] ; ll ++ ; la ++ ; ld = -1 ; } lu { ln [ lg ++ ] = lb [ la ] ; ll ++ ; } } lc ( la + 1 == lj ) ln [ lg ++ ] = lb [ la ] ; lr ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lk + 1 ) ; lm ( la = 0  ; la < lg ; la ++ ) { lc ( la != 0 ) lr ( " \x2c \x20 " ) ; lr ( " \x25 \x63 " , ln [ la ] ) ; } lr ( " \x5d \n " ) ; } lz 0 ; }
>>>Func
METHOD lj
METHOD_RETURN lc
PARAM lc lf
PARAM lc lg
<operator>.assignment lb=ld(lf)
<operator>.assignment la=ld(lg)
li li(lb==-1||la==-1)
IDENTIFIER le <empty>
LITERAL 0 <empty>
ld ld(lf)
ld ld(lg)
<operator>.logicalOr lb==-1||la==-1
<operator>.equals lb==-1
<operator>.equals la==-1
<operator>.minus -1
<operator>.minus -1
>>>PDG&16 0->2 0->3 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 2->9 3->10 4->1 4->1 4->12 5->1 5->1 5->1 5->13 6->1 6->1 9->1 9->4 10->1 10->5 11->1 11->1 11->6 11->6 12->1 12->1 12->11 12->11 12->13 12->15 13->1 13->1 13->11 13->11 14->12 15->13
>>>Token lc lj ( lc lf , lc lg ) { lk lb , la ; lb = ld ( lf ) ; la = ld ( lg ) ; li ( lb == -1 || la == -1 ) le 0 ; le lh [ lb ] [ la ] ; }
>>>Func
METHOD li
METHOD_RETURN lg
<operator>.assignment ld=10
<operator>.assignment *lb=(lc* )lh(ld lf(lc))
<operator>.lessThan la<ld
<operator>.postIncrement la++
ll ll(lb,ld)
<operator>.lessThan la<ld-1
<operator>.preIncrement ++la
lk lk(lb)
<operator>.cast (lc* )lh(ld lf(lc))
<operator>.subtraction ld-1
lh lh(ld lf(lc))
lf lf(lc)
>>>PDG&14 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 2->1 2->12 3->1 3->1 3->6 4->1 4->5 4->6 5->1 5->7 6->1 6->9 6->11 7->1 7->1 7->8 8->1 8->1 9->1 9->1 10->1 11->1 11->7 11->7 12->1 12->3 12->3 12->4 12->10 12->10 13->1 13->12
>>>Token lg li ( ) { ln lc ld = 10 ; lc * lb = ( lc * ) lh ( ld , lf ( lc ) ) ; le ( lc  la = 0 ; la < ld ; la ++ ) { lb [ la ] = lm ( ) % 100 ; } ll ( lb , ld ) ; le ( lc  la = 0 ; la < ld - 1 ; ++ la ) { lj ( lb [ la ] <= lb [ la + 1 ] ) ; } lk ( lb ) ; }
>>>Func
METHOD lv
METHOD_RETURN lr
ld ld("\x25\x64",&ls)
<operator>.lessEqualsThan lh<=ls
<operator>.postIncrement lh++
IDENTIFIER lx <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lr lv ( ) { lr ls , lq , lm , lp ; lw la , le , ll ; lr lh , lc ; ld ( " \x25 \x64 " , & ls ) ; lk ( lh = 1  ; lh <= ls ; lh ++ ) { lz ( ) ; lb = 0 ; ld ( " \x25 \x64 " , & lq ) ; ln ( lq -- )  { ld ( " \x20 \x25 \x63 " " \x25 \x63 \x25 \x63 " , & la , & le , & ll ) ; li [ la ] [ le ] = li [ le ] [ la ] = ll ; } ld ( " \x25 " " \x64 " , & lm ) ; ln ( lm -- )  { ld ( " \x20 \x25 \x63 \x25 \x63 " , & la , & le ) ; lo [ la ] [ le ] = lo [ le ] [ la ] = 1 ; } ld ( " \x25 \x64 " , & lp ) ; ld ( " \x20 " ) ; ln ( lp -- )  { ld ( " \x25 \x63 " , & la ) ; lj ( lb == 0 )  { lf [ lb ++ ] = la ; } lt lj ( li [ lf [ lb - 1 ] ] [ la ] ) { lf [ lb - 1 ] = li [ lf [ lb - 1 ] ] [ la ] ; } lt  { lk ( lc = 0  ; lc < lb ; lc ++ ) { lj ( lo [ lf [ lc ] ] [ la ] ) { lb = 0 ; ly lu ; } } lf [ lb ++ ] = la ; } lu : ; } lg ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , lh ) ; lg ( " \x5b " ) ; lk ( lc = 0  ; lc < lb ; lc ++ ) { lg ( " \x25 \x63 " , lf [ lc ] ) ; lj ( lc < lb - 1 )  lg ( " \x2c \x20 " ) ; } lg ( " \x5d \n " ) ; } lx 0 ; }
>>>Func
METHOD l69
METHOD_RETURN l1
PARAM l1 lu
PARAM lc* *lj
<operator>.assignment *lk=le
<operator>.assignment *ly=le
IDENTIFIER li <empty>
<operator>.assignment lr=lx
<operator>.assignment *lb=le
<operator>.assignment l2=lx
<operator>.assignment *l0=le
<operator>.assignment *lv=le
IDENTIFIER l16 <empty>
<operator>.assignment l11=lx
<operator>.assignment l13=lx
l67 l67(&lu,&lj)
l40 l40(lj[0])
l39 l39(l68,"")
l71 l71(l31,l56)
l59 l59(l31)
l57 l57(l44)
l55 l55((l10=l53(lu,lj,l65,l48,le))!=-1)
BLOCK <empty> <empty>
<operator>.assignment lz=(! !lk+! !l0+! !lv+l2)
la la(lz>1)
BLOCK <empty> <empty>
la la(lr&&lz)
BLOCK <empty> <empty>
la la(l11&&(l6&l18))
ln ln(0 0 lg("\x6f\x6e\x6c\x79\x20\x75\x73\x69\x6e\x67\x20\x6c\x61\x73\x74\x20""\x6f\x66\x20\x6d\x75\x6c\x74\x69\x70\x6c\x65\x20\x2d\x64\x20\x6f\x70""\x74\x69\x6f\x6e\x73"))
la la(l13&&(l6&l18))
ln ln(0 0 lg("\x6f\x6e\x6c\x79""\x20\x75\x73\x69\x6e\x67\x20\x6c\x61\x73\x74\x20\x6f\x66\x20\x6d\x75""\x6c\x74\x69\x70\x6c\x65\x20\x2d\x73\x20\x6f\x70\x74\x69\x6f\x6e\x73"))
la la(ll<lu)
BLOCK <empty> <empty>
la la(!lb)
BLOCK <empty> <empty>
<operator>.assignment *l14=l63(lb)
<operator>.assignment *l15=l14?l14:lb
<operator>.assignment *l8=l64("\x54\x5a")
<operator>.assignment l5=l46(l8)
la la(l0!=le)
<operator>.assignment ls=l72(l0,l15,l5,l8)
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
l47 l47(ls?l60:ld)
<operator>.assignment *lw=le
l50 l50(l10)
BLOCK <empty> <empty>
la la(lw)
BLOCK <empty> <empty>
ln ln(0 0 lg("\x74\x68\x65\x20\x6f\x70\x74\x69""\x6f\x6e\x73\x20\x74\x6f\x20\x73\x70\x65\x63\x69\x66\x79\x20\x64\x61""\x74\x65\x73\x20\x66\x6f\x72\x20\x70\x72\x69\x6e\x74\x69\x6e\x67\x20""\x61\x72\x65\x20\x6d\x75\x74\x75\x61\x6c\x6c\x79\x20\x65\x78\x63\x6c""\x75\x73\x69\x76\x65"))
l3 l3(ld)
ln ln(0 0 lg("\x74\x68\x65""\x20\x6f\x70\x74\x69\x6f\x6e\x73\x20\x74\x6f\x20\x70\x72\x69\x6e\x74""\x20\x61\x6e\x64\x20\x73\x65\x74\x20\x74\x68\x65\x20\x74\x69\x6d\x65""\x20\x6d\x61\x79\x20\x6e\x6f\x74\x20\x62\x65\x20\x75\x73\x65\x64\x20""\x74\x6f\x67\x65\x74\x68\x65\x72"))
l3 l3(ld)
la la(ll+1<lu)
BLOCK <empty> <empty>
la la(lj[ll][0]=='+')
BLOCK <empty> <empty>
IDENTIFIER lp <empty>
la la(lr||lz)
BLOCK <empty> <empty>
<operator>.assignment lb="\x25\x73\x2e\x25\x4e"
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
<operator>.assignment ltl9=lo
<operator>.assignment ls=lo
la la(!lz&&!lr)
BLOCK <empty> <empty>
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
la la(!l9)
l4 l4(ld 0 lg("\x69\x6e\x76\x61\x6c\x69\x64\x20\x64""\x61\x74\x65\x20\x25\x73") l12(lk))
la la(lr)
BLOCK <empty> <empty>
<operators>.assignmentAnd ls&=l70(l15,li,l5)
<operator>.notEquals (l10=l53(lu,lj,l65,l48,le))!=-1
IDENTIFIER lh <empty>
LITERAL 'd' <empty>
<operator>.assignment lk=lq
IDENTIFIER lf <empty>
IDENTIFIER lh <empty>
<operators>.assignmentOr l6|=l18
IDENTIFIER lf <empty>
IDENTIFIER lh <empty>
LITERAL 'f' <empty>
IDENTIFIER lf <empty>
IDENTIFIER lh <empty>
<operator>.assignment l2=lo
IDENTIFIER lf <empty>
IDENTIFIER lh <empty>
BLOCK <empty> <empty>
IDENTIFIER lh <empty>
LITERAL 'I' <empty>
IDENTIFIER lh <empty>
LITERAL 'r' <empty>
IDENTIFIER lf <empty>
IDENTIFIER lh <empty>
LITERAL 'R' <empty>
IDENTIFIER lf <empty>
IDENTIFIER lh <empty>
LITERAL 's' <empty>
<operator>.assignment ly=lq
<operator>.assignment lr=lo
IDENTIFIER lf <empty>
IDENTIFIER lh <empty>
LITERAL 'u' <empty>
IDENTIFIER l43 <empty>
IDENTIFIER lf <empty>
IDENTIFIER l77 <empty>
l80 l80(l36,l81)
l3 l3(ld)
l4 l4(ld 0 lg("\x6d\x75\x6c\x74\x69""\x70\x6c\x65\x20\x6f\x75\x74\x70\x75\x74\x20\x66\x6f\x72\x6d\x61\x74""\x73\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64"))
<operator>.assignment lb=lw
<operator>.addition ! !lk+! !l0+! !lv+l2
<operator>.greaterThan lz>1
<operator>.logicalAnd lr&&lz
<operator>.logicalAnd l11&&(l6&l18)
lg lg("\x6f\x6e\x6c\x79\x20\x75\x73\x69\x6e\x67\x20\x6c\x61\x73\x74\x20""\x6f\x66\x20\x6d\x75\x6c\x74\x69\x70\x6c\x65\x20\x2d\x64\x20\x6f\x70""\x74\x69\x6f\x6e\x73")
<operator>.logicalAnd l13&&(l6&l18)
lg lg("\x6f\x6e\x6c\x79""\x20\x75\x73\x69\x6e\x67\x20\x6c\x61\x73\x74\x20\x6f\x66\x20\x6d\x75""\x6c\x74\x69\x70\x6c\x65\x20\x2d\x73\x20\x6f\x70\x74\x69\x6f\x6e\x73")
<operator>.lessThan ll<lu
ln ln(0 0 lg("\x65\x78\x74\x72\x61\x20\x6f\x70""\x65\x72\x61\x6e\x64\x20\x25\x73") l12(lj[ll+1]))
l3 l3(ld)
l4 l4(ld 0 lg("\x6d\x75\x6c\x74\x69\x70\x6c\x65\x20\x6f""\x75\x74\x70\x75\x74\x20\x66\x6f\x72\x6d\x61\x74\x73\x20\x73\x70\x65""\x63\x69\x66\x69\x65\x64"))
<operator>.assignment lb=lj[ll++]+1
ln ln(0 0 lg("""\x74\x68\x65\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x25\x73\x20\x6c""\x61\x63\x6b\x73\x20\x61\x20\x6c\x65\x61\x64\x69\x6e\x67\x20\x27\x2b""\x27\x3b\n" "\x77\x68\x65\x6e\x20\x75\x73\x69\x6e\x67\x20\x61\x6e""\x20\x6f\x70\x74\x69\x6f\x6e\x20\x74\x6f\x20\x73\x70\x65\x63\x69\x66""\x79\x20\x64\x61\x74\x65\x28\x73\x29\x2c\x20\x61\x6e\x79\x20\x6e\x6f""\x6e\x2d\x6f\x70\x74\x69\x6f\x6e\n" "\x61\x72\x67\x75\x6d\x65\x6e""\x74\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x61\x20\x66\x6f\x72\x6d\x61""\x74\x20\x73\x74\x72\x69\x6e\x67\x20\x62\x65\x67\x69\x6e\x6e\x69\x6e""\x67\x20\x77\x69\x74\x68\x20\x27\x2b\x27") l12(lj[ll]))
l3 l3(ld)
<operator>.logicalNot !lb
<operator>.assignment lb=l52()
la la(! *lb)
<operator>.assignment lb="\x25""\x61\x20\x25\x62\x20\x25\x65\x20\x25\x48\x3a\x25\x4d\x3a\x25\x53\x20""\x25\x5a\x20\x25\x59"
l63 l63(lb)
<operator>.conditional l14?l14:lb
l64 l64("\x54\x5a")
l46 l46(l8)
<operator>.notEquals l0!=le
l72 l72(l0,l15,l5,l8)
la la(ll<lu)
BLOCK <empty> <empty>
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
la la(lv!=le)
BLOCK <empty> <empty>
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
la la(l66(&li)!=0)
BLOCK <empty> <empty>
<operator>.conditional ls?l60:ld
<operator>.assignment l10=l53(lu,lj,l65,l48,le)
<operator>.minus -1
<operator>.assignment l20[][32]={"\x25\x59\x2d\x25\x6d\x2d\x25""\x64" "\x25\x59\x2d\x25\x6d\x2d\x25\x64\x20\x25\x48\x3a\x25\x4d\x3a""\x25\x53\x25\x3a\x7a" "\x25\x59\x2d\x25\x6d\x2d\x25\x64\x20\x25\x48""\x3a\x25\x4d\x3a\x25\x53\x2e\x25\x4e\x25\x3a\x7a"}
<operator>.assignment l7=l19("""\x2d\x2d\x72\x66\x63\x2d\x33\x33\x33\x39",lq,l30+2,l27+2)
<operator>.assignment lw=l20[l7]
IDENTIFIER lf <empty>
<operator>.addition ! !lk+! !l0+! !lv
lg lg("\x74\x68\x65\x20\x6f\x70\x74\x69""\x6f\x6e\x73\x20\x74\x6f\x20\x73\x70\x65\x63\x69\x66\x79\x20\x64\x61""\x74\x65\x73\x20\x66\x6f\x72\x20\x70\x72\x69\x6e\x74\x69\x6e\x67\x20""\x61\x72\x65\x20\x6d\x75\x74\x75\x61\x6c\x6c\x79\x20\x65\x78\x63\x6c""\x75\x73\x69\x76\x65")
lg lg("\x74\x68\x65""\x20\x6f\x70\x74\x69\x6f\x6e\x73\x20\x74\x6f\x20\x70\x72\x69\x6e\x74""\x20\x61\x6e\x64\x20\x73\x65\x74\x20\x74\x68\x65\x20\x74\x69\x6d\x65""\x20\x6d\x61\x79\x20\x6e\x6f\x74\x20\x62\x65\x20\x75\x73\x65\x64\x20""\x74\x6f\x67\x65\x74\x68\x65\x72")
<operator>.and l6&l18
<operator>.and l6&l18
<operator>.lessThan ll+1<lu
<operator>.equals lj[ll][0]=='+'
<operator>.logicalOr lr||lz
<operator>.logicalAnd !lz&&!lr
<operator>.assignment lr=lo
<operator>.assignment lk=lj[ll]
<operator>.assignment l9=l58(&li.l21 lk (l51|l75|l83))
<operator>.assignment li.l25=0
l76 l76(&li)
la la(l29(lv,&l16)!=0)
l4 l4(ld l23 "\x25\x73" l49(lv))
<operator>.assignment li=l78(&l16)
<operator>.assignment lk=ly
<operator>.assignment l9=l79(&li,lk,le,l6,l5,l8)
<operator>.logicalNot !l9
lg lg("\x69\x6e\x76\x61\x6c\x69\x64\x20\x64""\x61\x74\x65\x20\x25\x73")
l12 l12(lk)
ln ln(0 l23 lg("\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x74\x20\x64\x61\x74\x65"))
<operator>.assignment ls=lx
l70 l70(l15,li,l5)
l53 l53(lu,lj,l65,l48,le)
lg lg("\x6d\x75\x6c\x74\x69""\x70\x6c\x65\x20\x6f\x75\x74\x70\x75\x74\x20\x66\x6f\x72\x6d\x61\x74""\x73\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64")
<operator>.addition ! !lk+! !l0
<operator>.logicalNot ! !lv
<operator>.addition ll+1
lg lg("\x65\x78\x74\x72\x61\x20\x6f\x70""\x65\x72\x61\x6e\x64\x20\x25\x73")
l12 l12(lj[ll+1])
lg lg("\x6d\x75\x6c\x74\x69\x70\x6c\x65\x20\x6f""\x75\x74\x70\x75\x74\x20\x66\x6f\x72\x6d\x61\x74\x73\x20\x73\x70\x65""\x63\x69\x66\x69\x65\x64")
<operator>.addition lj[ll++]+1
lg lg("""\x74\x68\x65\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x25\x73\x20\x6c""\x61\x63\x6b\x73\x20\x61\x20\x6c\x65\x61\x64\x69\x6e\x67\x20\x27\x2b""\x27\x3b\n" "\x77\x68\x65\x6e\x20\x75\x73\x69\x6e\x67\x20\x61\x6e""\x20\x6f\x70\x74\x69\x6f\x6e\x20\x74\x6f\x20\x73\x70\x65\x63\x69\x66""\x79\x20\x64\x61\x74\x65\x28\x73\x29\x2c\x20\x61\x6e\x79\x20\x6e\x6f""\x6e\x2d\x6f\x70\x74\x69\x6f\x6e\n" "\x61\x72\x67\x75\x6d\x65\x6e""\x74\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x61\x20\x66\x6f\x72\x6d\x61""\x74\x20\x73\x74\x72\x69\x6e\x67\x20\x62\x65\x67\x69\x6e\x6e\x69\x6e""\x67\x20\x77\x69\x74\x68\x20\x27\x2b\x27")
l12 l12(lj[ll])
<operator>.logicalNot ! *lb
<operator>.logicalNot !lz
<operator>.logicalNot !lr
<operator>.lessThan ll<lu
<operator>.notEquals lv!=le
<operator>.notEquals l66(&li)!=0
<operator>.arrayInitializer {"\x25\x59\x2d\x25\x6d\x2d\x25""\x64" "\x25\x59\x2d\x25\x6d\x2d\x25\x64\x20\x25\x48\x3a\x25\x4d\x3a""\x25\x53\x25\x3a\x7a" "\x25\x59\x2d\x25\x6d\x2d\x25\x64\x20\x25\x48""\x3a\x25\x4d\x3a\x25\x53\x2e\x25\x4e\x25\x3a\x7a"}
l19 l19("""\x2d\x2d\x72\x66\x63\x2d\x33\x33\x33\x39",lq,l30+2,l27+2)
<operator>.logicalNot ! !lk
<operator>.logicalNot ! !l0
<operator>.logicalNot !lv
l58 l58(&li.l21 lk (l51|l75|l83))
<operator>.notEquals l29(lv,&l16)!=0
l49 l49(lv)
l78 l78(&l16)
l79 l79(&li,lk,le,l6,l5,l8)
l66 l66(&li)
lg lg("\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x74\x20\x64\x61\x74\x65")
<operator>.addition l30+2
<operator>.addition l27+2
<operator>.logicalNot !lk
<operator>.logicalNot !l0
<operator>.addition ll+1
<operator>.postIncrement ll++
<operator>.or l51|l75|l83
l29 l29(lv,&l16)
<operator>.or l51|l75
>>>PDG&217 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->25 0->27 0->29 0->31 0->33 0->35 0->37 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->55 0->57 0->58 0->60 0->61 0->62 0->63 0->64 0->65 0->67 0->68 0->69 0->71 0->72 0->73 0->74 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->127 0->128 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->138 0->139 0->140 0->142 0->143 0->144 0->146 0->147 0->149 0->153 0->155 0->156 0->157 0->158 0->159 0->160 0->161 0->163 0->166 0->167 0->169 0->171 0->173 0->174 0->175 0->176 0->177 0->178 0->179 0->180 0->183 0->184 0->186 0->187 0->188 0->191 0->192 0->193 0->194 0->195 0->196 0->197 0->200 0->201 0->202 0->203 0->204 0->205 0->206 0->207 0->208 0->209 0->210 0->211 0->212 0->213 0->214 0->215 0->216 2->15 2->179 3->15 3->16 3->179 4->1 4->1 4->175 4->201 4->205 4->210 5->1 5->1 5->171 7->1 8->1 8->127 8->190 9->1 10->1 10->211 11->1 11->200 13->1 13->116 14->1 14->118 15->1 15->1 15->1 15->120 15->159 15->179 15->179 15->193 16->1 16->1 16->179 17->1 17->1 18->1 18->1 18->19 19->1 19->1 20->1 20->1 21->1 21->1 23->1 23->1 23->114 24->1 24->1 26->1 26->1 28->1 28->1 29->1 29->1 30->1 30->1 31->1 31->1 34->1 34->1 36->1 36->1 36->37 36->132 37->1 37->1 37->1 37->136 37->178 38->1 38->1 38->1 38->134 38->136 38->205 39->1 39->1 39->136 40->1 40->1 41->1 41->1 44->1 44->1 45->1 45->1 45->48 45->112 46->1 46->1 48->1 48->112 50->1 50->1 51->53 52->1 52->1 53->122 54->1 54->1 56->1 56->1 59->1 59->1 61->1 64->1 64->1 65->1 66->1 66->1 70->1 70->1 71->1 71->1 71->1 71->44 71->147 72->1 72->1 74->1 75->1 75->1 75->21 75->21 78->1 78->210 81->1 81->157 81->158 81->205 87->1 87->23 87->113 101->1 101->1 101->171 102->115 109->1 109->1 109->1 110->111 111->1 111->1 111->51 112->1 112->1 113->1 113->1 114->24 114->24 114->115 115->26 115->26 115->161 115->161 116->1 116->28 116->28 116->118 117->29 118->1 118->1 118->30 118->30 119->31 120->32 120->32 120->159 120->159 120->183 120->212 120->213 121->1 121->1 121->1 122->123 123->1 123->1 123->126 124->1 124->1 124->127 125->1 125->1 125->1 126->1 126->169 127->34 128->1 128->1 129->1 129->1 130->1 130->131 131->36 131->37 131->132 132->1 132->1 133->38 134->39 134->136 135->40 135->40 135->136 135->194 136->1 136->41 136->41 136->41 136->41 136->178 136->205 136->205 137->1 137->1 141->1 141->1 145->1 145->1 147->1 147->1 147->1 148->1 148->46 148->75 149->75 150->1 150->1 150->1 150->152 151->1 151->1 151->1 152->1 152->1 152->48 154->1 154->1 155->50 156->52 157->1 157->116 157->116 157->158 157->158 157->205 158->1 158->118 158->118 158->205 159->54 159->54 159->193 160->1 160->56 160->56 160->164 160->189 161->59 161->59 161->191 161->192 162->1 162->1 162->66 162->66 163->1 163->1 163->72 164->1 164->1 164->201 165->1 165->1 166->1 166->167 167->1 167->178 167->205 167->206 168->1 168->1 169->1 169->1 169->71 169->176 170->1 170->1 170->178 170->205 170->206 171->1 171->1 171->205 172->1 172->1 172->173 173->1 173->70 174->71 175->1 175->71 176->1 176->1 176->1 177->1 177->1 177->74 178->1 178->1 178->1 178->74 178->74 178->74 179->1 179->1 179->1 179->45 179->75 179->75 179->75 179->75 179->75 179->120 179->124 179->135 179->148 179->148 179->148 179->148 179->148 179->164 179->185 179->187 179->189 180->111 181->1 181->1 182->1 182->23 182->113 182->154 184->121 185->1 185->121 186->123 187->1 188->125 189->125 189->164 190->1 190->37 190->129 190->131 190->132 191->1 191->162 191->192 192->162 193->1 193->1 193->137 193->137 194->141 194->141 194->205 194->215 195->1 195->145 195->145 196->150 196->150 196->150 197->1 197->1 197->101 197->151 197->151 197->151 197->151 198->1 198->23 198->113 198->154 198->181 199->1 199->23 199->113 199->154 199->181 200->182 200->194 201->1 201->1 201->165 201->165 201->165 202->1 202->168 202->168 203->1 203->169 204->1 204->170 205->1 205->1 205->1 205->172 205->172 205->172 205->172 205->172 205->172 205->175 205->178 205->178 205->206 206->1 206->178 206->195 207->176 208->1 209->1 210->198 211->135 211->199 213->193 214->1 214->1 214->201 214->201 215->202 215->202 215->203 215->204 216->1 216->1 216->214 216->214
>>>Token l1 l69 ( l1 lu , lc * * lj ) { l1 l10 ; lc lm * lk = le ; lc lm * ly = le ; l26 l82 li ; lt lr = lx ; lc lm * lb = le ; lt l2 = lx ; lc * l0 = le ; lc * lv = le ; l26 l29 l16 ; lt ls ; lt l11 = lx ; lt l13 = lx ; l67 ( & lu , & lj ) ; l40 ( lj [ 0 ] ) ; l39 ( l68 , " " ) ; l71 ( l31 , l56 ) ; l59 ( l31 ) ; l57 ( l44 ) ; l55 ( ( l10 = l53 ( lu , lj , l65 , l48 , le ) ) != -1 )  { lc lm * lw = le ; l50 ( l10 ) { lh ' ' : la ( lk ) l11 = lo ; lk = lq ; lf ; lh l74 : l6 |= l18 ; lf ; lh  ' ' : l0 = lq ; lf ; lh l54 : l2 = lo ; lf ; lh l61 : { l22 lc  lm l20 [ ] [ 32 ] = { " \x25 \x59 \x2d \x25 \x6d \x2d \x25 " " \x64 " , " \x25 \x59 \x2d \x25 \x6d \x2d \x25 \x64 \x20 \x25 \x48 \x3a \x25 \x4d \x3a " " \x25 \x53 \x25 \x3a \x7a " , " \x25 \x59 \x2d \x25 \x6d \x2d \x25 \x64 \x20 \x25 \x48 " " \x3a \x25 \x4d \x3a \x25 \x53 \x2e \x25 \x4e \x25 \x3a \x7a " } ; l32 l24 l7 = l19 ( " " " \x2d \x2d \x72 \x66 \x63 \x2d \x33 \x33 \x33 \x39 " , lq , l30 + 2 , l27 + 2 ) ; lw = l20 [ l7 ] ; lf ; } lh  ' ' : { l22 lc  lm l33 [ ] [ 32 ] = { " \x25 \x59 \x2d \x25 \x6d \x2d \x25 \x64 " , " " " \x25 \x59 \x2d \x25 \x6d \x2d \x25 \x64 \x54 \x25 \x48 \x3a \x25 \x4d \x3a \x25 \x53 " " \x25 \x3a \x7a " , " \x25 \x59 \x2d \x25 \x6d \x2d \x25 \x64 \x54 \x25 \x48 \x3a \x25 " " \x4d \x3a \x25 \x53 \x2c \x25 \x4e \x25 \x3a \x7a " , " \x25 \x59 \x2d \x25 \x6d \x2d " " \x25 \x64 \x54 \x25 \x48 \x25 \x3a \x7a " , " \x25 \x59 \x2d \x25 \x6d \x2d \x25 \x64 " " \x54 \x25 \x48 \x3a \x25 \x4d \x25 \x3a \x7a " } ; l32 l24 l7 = ( lq ? l19 ( " \x2d \x2d " " \x69 \x73 \x6f \x2d \x38 \x36 \x30 \x31 " , lq , l30 , l27 ) : l62 ) ; lw = l33 [ l7 ] ; lf ; } lh  ' ' : lv = lq ; lf ; lh  ' ' : lw = l34 ; lf ; lh  ' ' : la ( ly ) l13 = lo ; ly = lq ; lr = lo ; lf ; lh ' u' la ( l38 ( l45 ( " \x54 \x5a \x3d \x55 \x54 \x43 \x30 " ) ) != 0 )  l41 ( ) ; l43 ; lf ; l77 ; l80 ( l36 , l81 ) ; l35 : l3 ( ld ) ; } la ( lw ) { la ( lb ) l4 ( ld , 0 , lg ( " \x6d \x75 \x6c \x74 \x69 " " \x70 \x6c \x65 \x20 \x6f \x75 \x74 \x70 \x75 \x74 \x20 \x66 \x6f \x72 \x6d \x61 \x74 " " \x73 \x20 \x73 \x70 \x65 \x63 \x69 \x66 \x69 \x65 \x64 " ) ) ; lb = lw ; } } l1 lz = ( ! ! lk + ! ! l0 + ! ! lv + l2 ) ; la ( lz > 1 )  { ln ( 0 , 0 , lg ( " \x74 \x68 \x65 \x20 \x6f \x70 \x74 \x69 " " \x6f \x6e \x73 \x20 \x74 \x6f \x20 \x73 \x70 \x65 \x63 \x69 \x66 \x79 \x20 \x64 \x61 " " \x74 \x65 \x73 \x20 \x66 \x6f \x72 \x20 \x70 \x72 \x69 \x6e \x74 \x69 \x6e \x67 \x20 " " \x61 \x72 \x65 \x20 \x6d \x75 \x74 \x75 \x61 \x6c \x6c \x79 \x20 \x65 \x78 \x63 \x6c " " \x75 \x73 \x69 \x76 \x65 " ) ) ; l3 ( ld ) ; } la ( lr && lz )  { ln ( 0 , 0 , lg ( " \x74 \x68 \x65 " " \x20 \x6f \x70 \x74 \x69 \x6f \x6e \x73 \x20 \x74 \x6f \x20 \x70 \x72 \x69 \x6e \x74 " " \x20 \x61 \x6e \x64 \x20 \x73 \x65 \x74 \x20 \x74 \x68 \x65 \x20 \x74 \x69 \x6d \x65 " " \x20 \x6d \x61 \x79 \x20 \x6e \x6f \x74 \x20 \x62 \x65 \x20 \x75 \x73 \x65 \x64 \x20 " " \x74 \x6f \x67 \x65 \x74 \x68 \x65 \x72 " ) ) ; l3 ( ld ) ; } la ( l11 && ( l6 & l18 ) )  ln ( 0 , 0 , lg ( " \x6f \x6e \x6c \x79 \x20 \x75 \x73 \x69 \x6e \x67 \x20 \x6c \x61 \x73 \x74 \x20 " " \x6f \x66 \x20 \x6d \x75 \x6c \x74 \x69 \x70 \x6c \x65 \x20 \x2d \x64 \x20 \x6f \x70 " " \x74 \x69 \x6f \x6e \x73 " ) ) ; la ( l13 && ( l6 & l18 ) )  ln ( 0 , 0 , lg ( " \x6f \x6e \x6c \x79 " " \x20 \x75 \x73 \x69 \x6e \x67 \x20 \x6c \x61 \x73 \x74 \x20 \x6f \x66 \x20 \x6d \x75 " " \x6c \x74 \x69 \x70 \x6c \x65 \x20 \x2d \x73 \x20 \x6f \x70 \x74 \x69 \x6f \x6e \x73 " ) ) ; la ( ll < lu )  { la ( ll + 1 < lu )  { ln ( 0 , 0 , lg ( " \x65 \x78 \x74 \x72 \x61 \x20 \x6f \x70 " " \x65 \x72 \x61 \x6e \x64 \x20 \x25 \x73 " ) , l12 ( lj [ ll + 1 ] ) ) ; l3 ( ld ) ; } la ( lj [ ll ] [ 0 ] == ' ' )  { la ( lb ) l4 ( ld , 0 , lg ( " \x6d \x75 \x6c \x74 \x69 \x70 \x6c \x65 \x20 \x6f " " \x75 \x74 \x70 \x75 \x74 \x20 \x66 \x6f \x72 \x6d \x61 \x74 \x73 \x20 \x73 \x70 \x65 " " \x63 \x69 \x66 \x69 \x65 \x64 " ) ) ; lb = lj [ ll ++ ] + 1 ; } lp la ( lr || lz ) { ln ( 0 , 0 , lg ( " " " \x74 \x68 \x65 \x20 \x61 \x72 \x67 \x75 \x6d \x65 \x6e \x74 \x20 \x25 \x73 \x20 \x6c " " \x61 \x63 \x6b \x73 \x20 \x61 \x20 \x6c \x65 \x61 \x64 \x69 \x6e \x67 \x20 \x27 \x2b " " \x27 \x3b \n " " \x77 \x68 \x65 \x6e \x20 \x75 \x73 \x69 \x6e \x67 \x20 \x61 \x6e " " \x20 \x6f \x70 \x74 \x69 \x6f \x6e \x20 \x74 \x6f \x20 \x73 \x70 \x65 \x63 \x69 \x66 " " \x79 \x20 \x64 \x61 \x74 \x65 \x28 \x73 \x29 \x2c \x20 \x61 \x6e \x79 \x20 \x6e \x6f " " \x6e \x2d \x6f \x70 \x74 \x69 \x6f \x6e \n " " \x61 \x72 \x67 \x75 \x6d \x65 \x6e " " \x74 \x20 \x6d \x75 \x73 \x74 \x20 \x62 \x65 \x20 \x61 \x20 \x66 \x6f \x72 \x6d \x61 " " \x74 \x20 \x73 \x74 \x72 \x69 \x6e \x67 \x20 \x62 \x65 \x67 \x69 \x6e \x6e \x69 \x6e " " \x67 \x20 \x77 \x69 \x74 \x68 \x20 \x27 \x2b \x27 " ) , l12 ( lj [ ll ] ) ) ; l3 ( ld ) ; } } la ( ! lb )  { la ( l2 ) lb = " \x25 \x73 \x2e \x25 \x4e " ; lp { lb = l52 ( ) ; la ( ! * lb ) lb = " \x25 " " \x61 \x20 \x25 \x62 \x20 \x25 \x65 \x20 \x25 \x48 \x3a \x25 \x4d \x3a \x25 \x53 \x20 " " \x25 \x5a \x20 \x25 \x59 " ; } } lc * l14 = l63 ( lb ) ; lc lm * l15 = l14 ? l14 : lb ; lc lm * l8 = l64 ( " \x54 \x5a " ) ; l73 l5 = l46 ( l8 ) ; la ( l0 != le ) ls = l72 ( l0 , l15 , l5 , l8 ) ; lp { ltl9 = lo ; ls = lo ; la ( ! lz && ! lr )  { la ( ll < lu ) { lr = lo ; lk = lj [ ll ] ; l9 = l58 ( & li . l21 , lk , ( l51 | l75 | l83 ) ) ; li . l25 = 0 ; } lp { l76 ( & li ) ; } } lp  { la ( lv != le ) { la ( l29 ( lv , & l16 ) != 0 )  l4 ( ld , l23 , " \x25 \x73 " , l49 ( lv ) ) ; li = l78 ( & l16 ) ; } lp la ( l2 ) { l42 l1 l17 = l37 ( ) ; li . l21 = l17 / l28 ; li . l25 = l17 % l28 ; } lp { la ( ly ) lk = ly ; l9 = l79 ( & li , lk , le , l6 , l5 , l8 ) ; } } la ( ! l9 )  l4 ( ld , 0 , lg ( " \x69 \x6e \x76 \x61 \x6c \x69 \x64 \x20 \x64 " " \x61 \x74 \x65 \x20 \x25 \x73 " ) , l12 ( lk ) ) ; la ( lr ) { la ( l66 ( & li ) != 0 )  { ln ( 0 , l23 , lg ( " \x63 \x61 \x6e \x6e \x6f \x74 \x20 \x73 \x65 \x74 \x20 \x64 \x61 \x74 \x65 " ) ) ; ls = lx ; } } ls &= l70 ( l15 , li , l5 ) ; } l47 ( ls ? l60 : ld ) ; }
>>>Func
METHOD le
METHOD_RETURN ln
PARAM lg lf
<operator>.lessThan lb<lf
<operator>.postIncrement lb++
>>>PDG&5 0->2 0->3 0->4 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token ln le ( lg lf ) { lo ld ; lk ( lg  lb = 0 ; lb < lf ; lb ++ ) { lk ( lg  lc = 0 ; lc < lf ; lc ++ ) li ( la [ lb ] . lj [ lc ] ) { li ( la [ lb ] . lj [ lc ] == lp ) { ld = ( la [ lc ] . ll - 1 ) / ( la [ lc ] . lh - 1 ) ; la [ lb ] . le += ld ; } lm  { ld = ( la [ lc ] . ll ) / ( la [ lc ] . lh - 1 ) ; la [ lb ] . le += ld ; } } la [ lb ] . le /= ( la [ lb ] . lh ) ; } }
>>>Func
METHOD le
METHOD_RETURN ld
PARAM ld la
PARAM ld lb
lh lh(la!=lb)
BLOCK <empty> <empty>
lf lf(la>lb)
IDENTIFIER lc <empty>
le le(la-lb,lb)
le le(la,lb-la)
<operator>.notEquals la!=lb
<operator>.greaterThan la>lb
<operator>.subtraction la-lb
<operator>.subtraction lb-la
>>>PDG&14 0->2 0->3 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->10 3->10 4->1 4->1 6->1 6->1 8->1 8->1 8->13 9->1 9->1 9->1 10->4 10->4 10->11 10->11 11->6 11->6 11->12 11->12 12->8 12->8 12->13 13->1 13->9 13->9
>>>Token ld le ( ld la , ld lb ) { lh ( la != lb ) { lf ( la > lb ) lc le ( la - lb , lb ) ; lg lc  le ( la , lb - la ) ; } lc la ; }
>>>Func
METHOD l5
METHOD_RETURN l10
<operator>.assignment *lc=ly("\x63\x6f\x64\x65\x31\x2e\x69\x6e","\x72")
<operator>.assignment *lu=ly("\x72\x65\x73\x75\x6c\x74\x31\x2e\x69\x6e","\x77")
<operator>.assignment lh=(lb* )ll(li(lb) *100)
ls ls(lc,"""\x25\x64",&lr)
<operator>.lessEqualsThan lm<=lr
<operator>.postIncrement lm++
l1 l1(lu)
l1 l1(lc)
ly ly("\x63\x6f\x64\x65\x31\x2e\x69\x6e","\x72")
ly ly("\x72\x65\x73\x75\x6c\x74\x31\x2e\x69\x6e","\x77")
<operator>.cast (lb* )ll(li(lb) *100)
ll ll(li(lb) *100)
<operator>.multiplication li(lb) *100
li li(lb)
>>>PDG&16 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->14 0->15 2->1 2->1 2->5 3->1 3->1 3->8 4->1 4->1 4->1 5->1 5->1 5->6 5->9 6->1 6->1 6->7 7->1 7->1 8->1 8->1 9->1 9->1 10->2 10->2 11->3 11->3 12->1 13->1 13->4 13->12 14->1 14->13 14->13 15->1 15->14
>>>Token l10 l5 ( ) { l2 * lc = ly ( " \x63 \x6f \x64 \x65 \x31 \x2e \x69 \x6e " , " \x72 " ) ; l2 * lu = ly ( " \x72 \x65 \x73 \x75 \x6c \x74 \x31 \x2e \x69 \x6e " , " \x77 " ) ; lb * * lf , * lh , * * lk , lv ; lq lm , la , lj , lp ; lq lr , le , ld , * ln ; lh = ( lb * ) ll ( li ( lb ) * 100 ) ; ls ( lc , " " " \x25 \x64 " , & lr ) ; lg ( lm = 1  ; lm <= lr ; lm ++ ) { ls ( lc , " \x25 \x64 " , & le ) ; lv = l0 ( lc ) ; lf = ( lb * * ) ll ( li ( lb *  ) * le ) ; lg ( la = 0  ; la < le ; la ++ ) { lb * lo = ( lb * ) ll ( li ( lb ) * 100 ) ; lf [ la ] = lo ; } lg ( la = 0  ; la < le ; la ++ ) { lx ( lh , 100 , lc ) ; lz ( lf [ la ] , lh ) ; lt ( " " " \x25 \x73 " , lf [ la ] ) ; } ls ( lc , " \x25 \x64 " , & ld ) ; lt ( " \x25 \x64 " , ld ) ; lv = l0 ( lc ) ; ln = ( lq * ) l8 ( li ( lq ) , ld ) ; lk = ( lb * * ) ll ( li ( lb *  ) * ld ) ; lg ( la = 0  ; la < ld ; la ++ ) { lb * lo = ( lb * ) ll ( li ( lb ) * 100 ) ; lk [ la ] = lo ; } lg ( la = 0  ; la < ld ; la ++ ) { lx ( lh , 100 , lc ) ; lz ( lk [ la ] , lh ) ; lt ( " \x25 \x73 " , lk [ la ] ) ; lg ( lj = 0  ; lj < le ; lj ++ ) l9 ( l7 ( lh , lf [ lj ] ) == 0 ) { ln [ la ] = lj ; l6 ; } } lp = 0 ; lp = l3 ( le , ld , ln ) ; l4 ( lu , " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \x25 \x63 " , lm , lp , 10 ) ; lg ( la = 0  ; la < le ; la ++ ) lw ( lf [ la ] ) ; lw ( ln ) ; } l1 ( lu ) ; l1 ( lc ) ; }
>>>Func
METHOD lx
METHOD_RETURN lz
lq lq("\x25\x64",&lk)
<operator>.lessThan lc<lk
<operator>.postIncrement lc++
<operator>.lessThan lc<lk
<operator>.postIncrement lc++
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 2->5 3->4 3->5 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token lz lx ( ) { lm lk , lc , la ; lq ( " \x25 \x64 " , & lk ) ; le ( lc = 0  ; lc < lk ; lc ++ ) { lm ld , lb ; lq ( " \x25 \x64 " , & ld ) ; lu [ lc ] = ld ; le ( la = 0  ; la < ld ; la ++ ) { lm ln = 0 ; ly lj [ 100 ] ; lq ( " \x25 \x73 " , lj ) ; lm lr = 0 ; le ( lb = 0  ; lb < ld ; lb ++ ) { lf ( lj [ lb ] == ' ' ) lh [ la ] [ lb ] = -1 ; lt lf ( lj [ lb ] = = ' ' ) lh [ la ] [ lb ] = 0 ; lt lf ( lj [ lb ] = = ' ' ) lh [ la ] [ lb ] = 1 ; lf ( lh [ la ] [ lb ] != -1 )  { lr += lh [ la ] [ lb ] ; ln ++ ; } } lg [ la ] [ 0 ] = lr / ( ll ) ln ; lg [ la ] [ 1 ] = ln ; } le ( la = 0  ; la < ld ; la ++ ) { ll li = 0 ; le ( lb = 0  ; lb < ld ; lb ++ ) { lf ( la != lb ) { lf ( lh [ lb ] [ la ] != -1 ) li += ( lg [ lb ] [ 0 ] * lg [ lb ] [ 1 ] - lh [ lb ] [ la ] ) / ( lg [ lb ] [ 1 ] - 1 ) ; } } lp [ la ] = li / lg [ la ] [ 1 ] ; } le ( la = 0  ; la < ld ; la ++ ) { ll li = 0 ; le ( lb = 0  ; lb < ld ; lb ++ ) { lf ( la != lb ) { lf ( lh [ la ] [ lb ] != -1 ) li += lp [ lb ] ; } } ls [ la ] = li / lg [ la ] [ 1 ] ; } le ( la = 0  ; la < ld ; la ++ ) { ll lv = 0.25 * lg [ la ] [ 0 ] + 0.50 * lp [ la ] + 0.25 * ls [ la ] ; lo [ lc ] [ la ] = lv ; } } le ( lc = 0  ; lc < lk ; lc ++ ) { lw ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a " " \n " , lc + 1 , lo [ lc ] ) ; le ( la = 0  ; la < lu [ lc ] ; la ++ ) { lw ( " \x25 \x67 \n " , lo [ lc ] [ la ] ) ; } } }
>>>Func
METHOD li
METHOD_RETURN lj
PARAM lf le
PARAM lf ld
lg lg(le>=ld)
IDENTIFIER ll <empty>
<operator>.lessEqualsThan la<=ld-1
<operator>.postIncrement la++
<operator>.lessEqualsThan lb<=ld
<operator>.postIncrement lb++
<operator>.greaterEqualsThan le>=ld
<operator>.subtraction ld-1
>>>PDG&12 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->10 3->10 4->1 4->1 6->1 6->1 6->7 7->1 7->1 8->1 8->1 8->9 9->1 9->1 10->1 10->4 10->4 10->11 11->6 11->6 11->8
>>>Token lj li ( lf le , lf ld ) { lf la , lb ; lg ( le >= ld ) ll ; lh ( la = le  ; la <= ld - 1 ; la ++ ) lh ( lb = la + 1 ; lb <= ld ; lb ++ ) lg ( lc [ la ] > lc [ lb ] )  lk ( & lc [ la ] , & lc [ lb ] ) ; }
>>>Func
METHOD lj
METHOD_RETURN lg
PARAM ld le
PARAM ld lf
<operator>.assignment lc=0
<operator>.assignment lb=0
<operator>.lessThan la<lf
<operator>.postIncrement la++
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 3->6 4->1 4->1 5->1 5->1 6->1 6->1 6->7 7->1 7->1
>>>Token lg lj ( ld le , ld lf ) { ld la ; lg lc , lb ; lc = 0 ; lb = 0 ; ll ( la = 0  ; la < lf ; la ++ ) { lh ( la == le || lk [ le ] [ la ] == ' ' )  { ln ; } lc += li ( la , lf ) ; lb += 1.0 ; } lm lc / lb ; }
>>>Func
METHOD lt
METHOD_RETURN le
PARAM le lk
PARAM ls*ln[]
la la(lk<2)
BLOCK <empty> <empty>
<operator>.assignment *lf=lv(ln[1],"\x72")
la la(lf==ly)
BLOCK <empty> <empty>
lh lh(lf,"\x25\x64",&lj)
<operator>.lessEqualsThan lg<=lj
<operator>.postIncrement lg++
IDENTIFIER lo <empty>
LITERAL 0 <empty>
lp lp(ll,"\x6e\x6f\x20\x66\x69\x6c""\x65\x6e\x61\x6d\x65\x20\x67\x69\x76\x65\x6e\n")
lu lu(1)
lp lp(ll,"\x65\x72\x72\x6f\x72\x20\x77\x68\x69\x6c""\x65\x20\x6c\x6f\x61\x64\x69\x6e\x67\x20\x66\x69\x6c\x65\n")
IDENTIFIER lo <empty>
LITERAL 1 <empty>
<operator>.lessThan lk<2
lv lv(ln[1],"\x72")
<operator>.equals lf==ly
>>>PDG&22 0->2 0->3 0->5 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 2->19 3->1 3->20 4->1 4->1 6->1 6->1 6->21 7->1 7->1 9->1 9->1 9->1 9->10 10->1 10->1 10->11 11->1 11->1 14->1 14->16 15->1 16->1 16->1 19->1 19->4 19->4 20->1 20->6 20->6 21->1 21->7 21->7 21->9
>>>Token le lt ( le lk , ls * ln [ ] ) { le lj ; la ( lk < 2 )  { lp ( ll , " \x6e \x6f \x20 \x66 \x69 \x6c " " \x65 \x6e \x61 \x6d \x65 \x20 \x67 \x69 \x76 \x65 \x6e \n " ) ; lu ( 1 ) ; } lr * lf = lv ( ln [ 1 ] , " \x72 " ) ; la ( lf == ly )  { lp ( ll , " \x65 \x72 \x72 \x6f \x72 \x20 \x77 \x68 \x69 \x6c " " \x65 \x20 \x6c \x6f \x61 \x64 \x69 \x6e \x67 \x20 \x66 \x69 \x6c \x65 \n " ) ; lo 1 ; } lh ( lf , " \x25 \x64 " , & lj ) ; le lg ; le lq ; lx ( lg = 1  ; lg <= lj ; lg ++ ) { le lb = 0 ; le ld ; le lc ; le li ; lh ( lf , " \x25 \x64 " , & ld ) ; lh ( lf , " \x25 \x64 " , & lc ) ; lh ( lf , " \x25 " " \x64 " , & li ) ; la ( ld >= 100 )  { lb ++ ; } lm  { la ( ld >= 50 ) { la ( lc % 2 == 0 )  { lb ++ ; } } la ( lb == 0 && ld >= 25 ) { la ( lc % 4 == 0 )  { lb ++ ; } } la ( lb == 0 && ld >= 20 ) { la ( lc % 5 == 0 )  { lb ++ ; } } la ( lb == 0 && ld >= 10 ) { la ( lc % 10 == 0 )  { lb ++ ; } } la ( lb == 0 && ld >= 5 ) { la ( lc % 20 == 0 )  { lb ++ ; } } la ( lb == 0 && ld >= 4 ) { la ( lc % 25 == 0 )  { lb ++ ; } } la ( lb == 0 && ld >= 2 ) { la ( lc % 50 == 0 )  { lb ++ ; } } la ( lb == 0 ) { la ( lc % 100 == 0 )  { lb ++ ; } } } la ( lb == 1 )  { la ( lc != 0 && li == 0 )  { lb -- ; } lm la ( lc != 100 && li = = 100 ) { lb -- ; } } lw ( " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a \x20 \x25 \x73 \n " , lg , lb == 1 ? " \x50 \x6f \x73 \x73 \x69 \x62 \x6c " " \x65 " : " \x42 \x72 \x6f \x6b \x65 \x6e " ) ; } lo 0 ; }
>>>Func
METHOD lv
METHOD_RETURN ls
PARAM lz
ll ll("\x25\x64",&lo)
<operator>.lessThan lf<lo
<operator>.postIncrement lf++
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token ls lv ( lz ) { ls lo , lf , lj , lb , lg , la , ld , le , li , lh , lk [ 100 ] [ 1000 ] ; ly ln [ 101 ] , lm [ 100 ] [ 101 ] ; ll ( " \x25 \x64 " , & lo ) ; lc ( lf = 0  ; lf < lo ; lf ++ ) { lc ( la = 0  ; la < 100 ; la ++ ) { lc ( lb = 0  ; lb < 1000 ; lb ++ ) lk [ la ] [ lb ] = 0 ; } ll ( " \x25 \x64 " , & lg ) ; lt ( ) ; lc ( lb = 0  ; lb < lg ; lb ++ ) { lq ( lm [ lb ] ) ; } ll ( " \x25 \x64 " , & lj ) ; lt ( ) ; lc ( lb = 0  ; lb < lj ; lb ++ ) { lq ( ln ) ; lc ( la = 0  ; la < lg ; la ++ ) { lp ( ! lw ( ln , lm [ la ] ) )  { lk [ la ] [ lb ] = 1 ; lu ; } } } le = -1 ; li = -1 ; lh = -1 ; lr ( le < lj )  { li ++ ; le ++ ; lc ( la = 0  ; la < lg ; la ++ ) { ld = le ; lr ( lk [ la ] [ ld ] != 1 ) ld ++ ; lp ( lh < ld - 1 )  { lh = ld - 1 ; } } le = lh ; } lx ( " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , lf + 1 , li ) ; } }
>>>Func
METHOD lk
METHOD_RETURN lb
PARAM lb li
PARAM lb lf
PARAM lb le
<operator>.assignment ld=0
lg lg(0,le-1)
<operator>.assignment lc=1
<operator>.lessThan la<le
<operator>.postIncrement la++
<operator>.subtraction le-1
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 3->1 4->10 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 8->9 9->1 9->1 10->6 10->6 10->8
>>>Token lb lk ( lb li , lb lf , lb le ) { lb la , lc , ld = 0 ; lg ( 0 , le - 1 ) ; lc = 1 ; ll ( la = 0  ; la < le ; la ++ ) { lc = la / lf + 1 ; ld += lj [ la ] * lc ; } lh ld ; }
>>>Func
METHOD lx
METHOD_RETURN lt
<operator>.assignment lo=1
lj lj("\x25\x64",&ls)
lw lw(lo<=ls)
BLOCK <empty> <empty>
IDENTIFIER ly <empty>
LITERAL 0 <empty>
<operator>.assignment lr=0
<operator>.assignment lq=0
<operator>.assignment lp=0
<operator>.assignment lb=0
<operator>.assignment ll=0
<operator>.lessThan la<26
<operator>.postIncrement la++
lj lj("\x25\x64",&lr)
<operator>.lessThan la<lr
<operator>.postIncrement la++
<operator>.assignment lf[la][0]='\0'
lj lj("\x25\x64",&lq)
<operator>.lessThan la<lq
<operator>.postIncrement la++
<operator>.assignment li[la][0]='\0'
lj lj("\x25\x64",&lp)
lk lk(lp>0)
BLOCK <empty> <empty>
IDENTIFIER lv <empty>
BLOCK <empty> <empty>
<operator>.lessThan la<lp
<operator>.postIncrement la++
ln ln("\x43\x61\x73\x65\x20\x23\x25""\x64\x3a\x20\x5b",lo)
<operator>.lessThan la<lb
<operator>.postIncrement la++
lk lk(lb==0)
BLOCK <empty> <empty>
ln ln("\n")
<operator>.assignment lo=lo+1
<operator>.lessEqualsThan lo<=ls
lj lj("\x25\x73",lg)
<operator>.assignment le[0]=lg[0]
<operator>.assignment ld[lg[0]-65]=ld[lg[0]-65]+1
<operator>.assignment lb=lb+1
<operator>.assignment le[lb]='\0'
<operator>.assignment lg[0]='\0'
ln ln("""\x5d")
<operator>.greaterThan lp>0
<operator>.equals lb==0
<operator>.addition lo+1
<operator>.addition ld[lg[0]-65]+1
<operator>.addition lb+1
<operator>.subtraction lg[0]-65
<operator>.subtraction lg[0]-65
>>>PDG&52 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 2->1 2->37 3->1 3->1 3->37 4->1 4->1 8->1 8->15 8->16 9->1 9->19 9->20 10->1 10->23 10->45 11->1 11->41 11->49 12->1 12->1 13->1 13->14 14->16 15->1 15->1 15->16 16->1 16->1 16->17 17->20 18->1 18->1 19->1 19->1 19->20 20->1 20->1 20->21 21->28 22->1 22->1 23->1 23->1 23->28 23->45 24->1 24->1 28->1 28->1 28->29 29->31 30->1 30->36 30->47 31->1 31->32 31->46 32->1 32->1 33->1 33->1 35->1 36->1 36->1 36->1 37->1 37->4 37->4 37->30 38->1 38->1 38->39 38->50 38->51 39->1 39->1 40->1 40->1 40->1 41->1 41->1 41->31 42->1 42->1 43->1 43->1 44->1 45->24 45->24 45->28 46->1 46->33 46->33 50->51
>>>Token lt lx ( ) { lt ls , lo = 1 ; lj ( " \x25 \x64 " , & ls ) ; lw ( lo <= ls )  { lz lf [ 36 ] [ 3 ] , li [ 36 ] [ 2 ] , lg [ 100 ] , le [ 100 ] ; lt lr = 0 , lq = 0 , lp = 0 , lb = 0 , ll = 0 , la , lc , ld [ 26 ] , lm ; lh ( la = 0  ; la < 26 ; la ++ ) { ld [ la ] = 0 ; } lj ( " \x25 \x64 " , & lr ) ; lh ( la = 0  ; la < lr ; la ++ ) { lj ( " " " \x25 \x73 " , lf [ la ] ) ; } lf [ la ] [ 0 ] = ' \0 ' ; lj ( " \x25 \x64 " , & lq ) ; lh ( la = 0  ; la < lq ; la ++ ) { lj ( " \x25 \x73 " , li [ la ] ) ; } li [ la ] [ 0 ] = ' \0 ' ; lj ( " \x25 \x64 " , & lp ) ; lk ( lp > 0 )  { lj ( " \x25 \x73 " , lg ) ; le [ 0 ] = lg [ 0 ] ; ld [ lg [ 0 ] - 65 ] = ld [ lg [ 0 ] - 65 ] + 1 ; lb = lb + 1 ; le [ lb ] = ' \0 ' ; } lv { lg [ 0 ] = ' \0 ' ; } lh ( la = 1  ; la < lp ; la ++ ) { ll = 1 ; le [ lb ] = lg [ la ] ; lb = lb + 1 ; le [ lb ] = ' \0 ' ; ld [ lg [ la ] - 65 ] = ld [ lg [ la ] - 65 ] + 1 ; lw ( ll == 1 )  { ll = 0 ; lh ( lc = 0  ; lc < lr ; lc ++ ) { lk ( ( le [ lb - 1 ] == lf [ lc ] [ 0 ] && le [ lb - 2 ] == lf [ lc ] [ 1 ] ) || ( le [ lb - 2 ] == lf [ lc ] [ 0 ] && le [ lb - 1 ] == lf [ lc ] [ 1 ] ) )  { le [ lb - 2 ] = lf [ lc ] [ 2 ] ; ll = 1 ; lb = lb - 1 ; le [ lb ] = ' \0 ' ; ld [ lf [ lc ] [ 0 ] - 65 ] -- ; ld [ lf [ lc ] [ 1 ] - 65 ] -- ; ld [ lf [ lc ] [ 2 ] - 65 ] ++ ; lu ; } } lk ( ll == 0 )  { lh ( lc = 0  ; lc < lq ; lc ++ ) { lk ( ( ld [ li [ lc ] [ 0 ] - 65 ] > 0 && ld [ li [ lc ] [ 1 ] - 65 ] > 0 ) )  { lb = 0 ; le [ lb ] = ' \0 ' ; ld [ li [ lc ] [ 0 ] - 65 ] -- ; ld [ li [ lc ] [ 1 ] - 65 ] -- ; lh ( lm = 0  ; lm < 26 ; lm ++ ) { ld [ lm ] = 0 ; } lu ; } } } } } ln ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 " " \x64 \x3a \x20 \x5b " , lo ) ; lh ( la = 0  ; la < lb ; la ++ ) { lk ( la == ( lb - 1 ) )  { ln ( " \x25 " " \x63 \x5d " , le [ la ] ) ; } lv  { ln ( " \x25 \x63 \x2c \x20 " , le [ la ] ) ; } } lk ( lb == 0 )  { ln ( " " " \x5d " ) ; } ln ( " \n " ) ; lo = lo + 1 ; } ly 0 ; }
>>>Func
METHOD li
METHOD_RETURN lc
PARAM ll*lf
PARAM lc lg
PARAM lc*lb
<operator>.assignment la=0
<operator>.assignment le=0
<operator>.assignment ld=0
<operator>.lessThan la<lg
<operator>.expressionList la++ le+=ld
IDENTIFIER lmla <empty>
<operator>.postIncrement la++
<operator>.assignmentPlus le+=ld
>>>PDG&13 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 3->8 4->1 5->1 5->8 6->1 6->12 7->1 7->9 7->12 8->1 8->1 8->11 9->1 9->1 9->1 11->1 11->9 12->1 12->1 12->9
>>>Token lc li ( ll * lf , lc lg , lc * lb ) { lc la = 0 , le = 0 , ld = 0 ; ln ( la = 0  ; la < lg ; la ++ , le += ld ) { lb [ la ] = -1 ; lk ( lf + le , " \x25 \x64 \x25 \x6e " , lb + la , & ld ) ; lj ( lb [ la ] == -1 ) lh ; } lmla ; }
>>>Func
METHOD ls
METHOD_RETURN ln
lb lb("\x25\x64",&lk)
<operator>.lessEqualsThan ld<=lk
<operator>.preIncrement ++ld
IDENTIFIER lt <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token ln ls ( ) { ln lk , ld , la ; lb ( " \x25 \x64 " , & lk ) ; lh ( ld = 1  ; ld <= lk ; ++ ld ) { lb ( " \x25 " " \x64 " , & lm ) ; lh ( la = 0  ; la < lm ; ++ la ) lb ( " \x25 \x73 " , lw [ la ] ) ; lb ( " \x25 \x64 " , & ll ) ; lh ( la = 0  ; la < ll ; ++ la ) lb ( " \x25 \x73 " , lu [ la ] ) ; lb ( " \x25 \x64 " , & le ) ; lb ( " " " \x25 \x73 " , lf ) ; lj ( le == 1 )  { li ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " " \x5b \x25 \x63 \x5d \n " , ld , lf [ 0 ] ) ; lo ; } lc = 1 ; lg [ 0 ] = lf [ 0 ] ; lh ( la = 1  ; la < le ; ++ la ) { lg [ lc ++ ] = lf [ la ] ; lq ( ) ; { lj ( lp ( ) ) { lj ( la == le - 2 )  { lg [ lc ++ ] = lf [ le - 1 ] ; lv ; } lr lj ( la != le -1 ) { lg [ lc ++ ] = lf [ ++ la ] ; } } } } li ( " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a \x20 \x5b " , ld ) ; lh ( la = 0  ; la < lc - 1 ; ++ la ) li ( " \x25 \x63 \x2c \x20 " , lg [ la ] ) ; lj ( lc != 0 )  li ( " \x25 \x63 " , lg [ lc - 1 ] ) ; li ( " \x5d \n " ) ; } lt 0 ; }
>>>Func
METHOD ll
METHOD_RETURN lh
<operator>.lessThan la<lo
<operator>.preIncrement ++la
IDENTIFIER li <empty>
LITERAL 0 <empty>
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 2->1 2->3 3->1 3->1
>>>Token ln lh ll ( ) { lh la , lb ; lm lc ; lj ( la = 0  ; la < lo ; ++ la ) { lf ( lg [ ld - 1 ] == le [ la ] [ 0 ] )  { lc = le [ la ] [ 1 ] ; } lk lf ( lg [ ld - 1 ] = = le [ la ] [ 1 ] ) { lc = le [ la ] [ 0 ] ; } lj ( lb = ld - 2  ; lb >= 0 ; -- lb ) { lf ( lg [ lb ] == lc )  { ld = 0 ; li 1 ; } } } li 0 ; }
>>>Func
METHOD li
METHOD_RETURN lh
PARAM ll lb
<operator>.assignment lf=1
le le(la)
BLOCK <empty> <empty>
<operator>.assignment lc[la++]=lb
le le(lg[lb][lc[la-1]])
BLOCK <empty> <empty>
IDENTIFIER lk <empty>
BLOCK <empty> <empty>
<operator>.assignment lc[la-1]=lg[lb][lc[la-1]]
<operator>.assignment lf=0
<operator>.lessThan ld<la
<operator>.preIncrement ++ld
<operator>.postIncrement la++
<operator>.subtraction la-1
<operator>.subtraction la-1
<operator>.subtraction la-1
>>>PDG&19 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 2->6 3->1 4->1 4->16 6->1 6->1 6->1 7->1 7->11 11->1 11->1 11->1 12->1 12->1 13->1 13->14 13->15 14->1 14->1 15->1 16->17 17->18 18->13
>>>Token lh li ( ll lb ) { lm ld , lf = 1 ; le ( la ) { le ( lg [ lb ] [ lc [ la - 1 ] ] ) { lc [ la - 1 ] = lg [ lb ] [ lc [ la - 1 ] ] ; lf = 0 ; } lk  { ln ( ld = 0  ; ld < la ; ++ ld ) le ( lj [ lb ] [ lc [ ld ] ] ) la = lf = 0 ; } } le ( lf ) lc [ la ++ ] = lb ; }
>>>Func
METHOD lk
METHOD_RETURN la
PARAM la li
PARAM la lb
PARAM la le
ld ld(lb>0&&le==0)
IDENTIFIER lc <empty>
LITERAL 0 <empty>
<operator>.assignment lh=100-lb
<operator>.assignment lf=100-le
ld ld(lf==0&&lh>0)
IDENTIFIER lc <empty>
LITERAL 0 <empty>
ld ld((lf==0&&lh==0)||(le==0&&lb==0))
IDENTIFIER lc <empty>
LITERAL 1 <empty>
<operator>.assignment lg=ll(lb)
<operator>.assignment lj=100/lg
<operator>.assignment lm=lb/lg
ld ld(lj<=li)
IDENTIFIER lc <empty>
LITERAL 1 <empty>
IDENTIFIER lc <empty>
LITERAL 0 <empty>
<operator>.logicalAnd lb>0&&le==0
<operator>.subtraction 100-lb
<operator>.subtraction 100-le
<operator>.logicalAnd lf==0&&lh>0
<operator>.logicalOr (lf==0&&lh==0)||(le==0&&lb==0)
ll ll(lb)
<operator>.division 100/lg
<operator>.division lb/lg
<operator>.lessEqualsThan lj<=li
<operator>.greaterThan lb>0
<operator>.equals le==0
<operator>.equals lf==0
<operator>.greaterThan lh>0
<operator>.logicalAnd lf==0&&lh==0
<operator>.logicalAnd le==0&&lb==0
<operator>.equals lf==0
<operator>.equals lh==0
<operator>.equals le==0
<operator>.equals lb==0
>>>PDG&43 0->2 0->3 0->4 0->6 0->7 0->11 0->12 0->14 0->15 0->20 0->21 0->22 0->23 0->25 0->26 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->39 0->40 0->41 0->42 2->32 3->33 4->26 4->34 5->1 5->1 8->1 8->1 8->1 8->36 8->40 9->1 9->1 9->35 10->1 10->1 13->1 13->1 16->1 16->1 16->30 17->1 17->1 17->32 18->1 18->1 18->1 19->1 19->1 24->1 24->1 24->5 24->5 25->8 25->8 25->29 25->42 26->1 26->9 26->9 26->41 27->1 27->10 27->10 28->1 28->1 28->13 28->13 29->16 29->31 30->17 30->17 30->31 31->1 31->1 31->18 31->18 32->1 32->1 32->19 32->19 33->24 33->24 33->25 33->34 34->24 34->24 34->26 35->27 35->27 35->36 35->39 36->1 36->27 36->27 36->40 37->1 37->1 37->28 37->28 37->38 37->41 38->1 38->1 38->28 38->28 39->1 39->37 39->37 39->40 40->1 40->37 40->37 41->1 41->38 41->38 41->42 42->29 42->38 42->38
>>>Token la lk ( la li , la lb , la le ) { ld ( lb > 0 && le == 0 ) lc 0 ; la lh = 100 - lb , lf = 100 - le ; ld ( lf == 0 && lh > 0 ) lc 0 ; ld ( ( lf == 0 && lh == 0 ) || ( le == 0 && lb == 0 ) ) lc 1 ; la lg = ll ( lb ) ; la lj = 100 / lg , lm = lb / lg ; ld ( lj <= li ) lc 1 ; lc 0 ; }
>>>Func
METHOD lp
METHOD_RETURN lj
la la("\x45\x6e\x74\x65\x72\x20\x74\x68\x65""\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x76\x65\x72\x74\x69\x63""\x65\x73\n")
lb lb("\x25\x64",&li)
<operator>.assignment *lg=ln(li)
la la("\x45\x6e\x74\x65""\x72\x20\x74\x68\x65\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x65""\x64\x67\x65\x73\n")
lb lb("\x25\x64",&le)
<operator>.lessThan lc<le
<operator>.postIncrement lc++
la la("\x45\x6e\x74\x65\x72\x20\x73\x6f""\x75\x72\x63\x65\x20\x6f\x66\x20\x44\x46\x53\n")
lb lb("\x25\x64",&ld)
la la("\x44\x46\x53\x20\x66\x72\x6f\x6d\x20\x25\x64\x20\x69\x73\x3a\n",ld)
lk lk(lg,ld)
la la("\n")
IDENTIFIER ll <empty>
LITERAL 0 <empty>
ln ln(li)
>>>PDG&17 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 2->1 3->1 3->1 3->16 4->1 4->1 4->1 4->12 5->1 6->1 6->1 6->7 7->1 7->1 7->8 8->1 8->1 9->1 10->1 10->1 10->11 10->12 11->1 11->12 12->1 12->1 12->1 13->1 16->1 16->4
>>>Token lj lp ( ) { lj li , le , ld , lc , lh , lf ; la ( " \x45 \x6e \x74 \x65 \x72 \x20 \x74 \x68 \x65 " " \x20 \x6e \x75 \x6d \x62 \x65 \x72 \x20 \x6f \x66 \x20 \x76 \x65 \x72 \x74 \x69 \x63 " " \x65 \x73 \n " ) ; lb ( " \x25 \x64 " , & li ) ; lq lm * lg = ln ( li ) ; la ( " \x45 \x6e \x74 \x65 " " \x72 \x20 \x74 \x68 \x65 \x20 \x6e \x75 \x6d \x62 \x65 \x72 \x20 \x6f \x66 \x20 \x65 " " \x64 \x67 \x65 \x73 \n " ) ; lb ( " \x25 \x64 " , & le ) ; lr ( lc = 0  ; lc < le ; lc ++ ) { la ( " \x45 " " \x64 \x67 \x65 \x20 \x25 \x64 \x20 \n \x45 \x6e \x74 \x65 \x72 \x20 \x73 \x6f \x75 " " \x72 \x63 \x65 \x3a \x20 " , lc + 1 ) ; lb ( " \x25 \x64 " , & lh ) ; la ( " \x45 \x6e \x74 \x65 " " \x72 \x20 \x64 \x65 \x73 \x74 \x69 \x6e \x61 \x74 \x69 \x6f \x6e \x3a \x20 " ) ; lb ( " " " \x25 \x64 " , & lf ) ; lo ( lg , lh , lf ) ; } la ( " \x45 \x6e \x74 \x65 \x72 \x20 \x73 \x6f " " \x75 \x72 \x63 \x65 \x20 \x6f \x66 \x20 \x44 \x46 \x53 \n " ) ; lb ( " \x25 \x64 " , & ld ) ; la ( " \x44 \x46 \x53 \x20 \x66 \x72 \x6f \x6d \x20 \x25 \x64 \x20 \x69 \x73 \x3a \n " , ld ) ; lk ( lg , ld ) ; la ( " \n " ) ; ll 0 ; }
>>>Func
METHOD lm
METHOD_RETURN lk
<operator>.assignment lj=1
lh lh("\x25\x64",&lg)
lo lo(lg--)
BLOCK <empty> <empty>
IDENTIFIER ln <empty>
LITERAL 0 <empty>
lh lh("""\x25\x64",&li)
<operator>.assignment ld=0
<operator>.assignment le=0
<operator>.assignment lb=10000000
<operator>.lessThan lc<li
<operator>.postIncrement lc++
lf lf("\x43\x61\x73\x65\x20""\x23\x25\x64\x3a\x20",lj++)
ll ll(le==0)
lf lf("\x25\x64\n",ld-lb)
IDENTIFIER lp <empty>
lf lf("""\x4e\x4f\n")
<operator>.postDecrement lg--
<operator>.postIncrement lj++
<operator>.equals le==0
<operator>.subtraction ld-lb
>>>PDG&23 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 2->1 2->20 3->1 3->1 3->19 4->1 4->1 8->1 8->1 8->12 9->1 9->22 10->1 10->21 11->1 11->22 12->1 12->1 12->13 13->1 13->1 14->1 14->1 15->1 15->1 16->1 16->1 18->1 19->1 19->4 20->1 20->14 21->1 21->15 21->15 22->1 22->1 22->16 22->16
>>>Token lk lm ( ) { lk lj = 1 , la , lg , li , lb , ld , lc , le ; lh ( " \x25 \x64 " , & lg ) ; lo ( lg -- )  { lh ( " " " \x25 \x64 " , & li ) ; ld = 0 ; le = 0 ; lb = 10000000 ; lq ( lc = 0  ; lc < li ; lc ++ ) { lh ( " \x25 " " \x64 " , & la ) ; ld += la ; ll ( la < lb ) lb = la ; le ^= la ; } lf ( " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x64 \x3a \x20 " , lj ++ ) ; ll ( le == 0 )  lf ( " \x25 \x64 \n " , ld - lb ) ; lp lf ( " " " \x4e \x4f \n " ) ; } ln 0 ; }
>>>Func
METHOD l10
METHOD_RETURN l3
<operator>.assignment l4=l0(l11,"\x72",l12)
<operator>.assignment l2=l0(l9,"\x77",l7)
li li("\x25\x64",&ly)
<operator>.lessThan ll<ly
<operator>.postIncrement ll++
IDENTIFIER l6 <empty>
LITERAL 0 <empty>
l0 l0(l11,"\x72",l12)
l0 l0(l9,"\x77",l7)
>>>PDG&11 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 2->1 3->1 3->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1 9->1 9->1 9->2 9->2 9->2 10->1 10->1 10->3 10->3 10->3
>>>Token l3 l10 ( ) { l8 * l4 , * l2 ; l4 = l0 ( l11 , " \x72 " , l12 ) ; l2 = l0 ( l9 , " \x77 " , l7 ) ; l3 ly , lo , lq , lm , ll , la , lb , ld , lj , lh ; lr lt [ lx ] , ls [ lx ] , lw [ lx ] ; lr lp [ l1 ] , ln [ l1 ] ; lr le [ lz ] ; lr lc [ lz ] ; li ( " \x25 \x64 " , & ly ) ; lg ( ll = 0  ; ll < ly ; ll ++ ) { ld = 0 ; li ( " " " \x25 \x64 \x20 " , & lo ) ; lg ( la = 0  ; la < lo ; la ++ ) li ( " \x25 \x63 \x25 \x63 \x25 \x63 " " \x20 " , & lt [ la ] , & ls [ la ] , & lw [ la ] ) ; li ( " \x25 \x64 \x20 " , & lq ) ; lg ( la = 0  ; la < lq ; la ++ ) li ( " \x25 \x63 \x25 \x63 \x20 " , & lp [ la ] , & ln [ la ] ) ; li ( " \x25 \x64 \x20 " , & lm ) ; li ( " \x25 \x73 " , lc ) ; lk ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , ll + 1 ) ; lf ( lm == 1 )  { lk ( " \x25 \x63 \x5d \n " , lc [ 0 ] ) ; lv ; } la = 0 ; l5 ( la < lm )  { lh = 0 ; lg ( lj = 0  ; lj < ld ; lj ++ ) { lg ( lb = 0  ; lb < lq ; lb ++ ) lf ( ( lp [ lb ] == lc [ la ] && ln [ lb ] == le [ lj ] ) || ( ln [ lb ] == lc [ la ] && lp [ lb ] == le [ lj ] ) ) { ld = 0 ; lh = 1 ; la ++ ; lu ; } lf ( lh ) lu ; } lf ( lh ) lv ; lf ( la == lm - 1 )  { le [ ld ++ ] = lc [ la ] ; lu ; } lg ( lb = 0  ; lb < lo ; lb ++ ) lf ( ( lt [ lb ] == lc [ la ] && ls [ lb ] == lc [ la + 1 ] ) || ( ls [ lb ] == lc [ la ] && lt [ lb ] == lc [ la + 1 ] ) ) { le [ ld ++ ] = lw [ lb ] ; la += 2 ; lh = 1 ; lu ; } lf ( lh ) lv ; le [ ld ++ ] = lc [ la ] ; la ++ ; } lf ( ld ) { lk ( " \x25 \x63 " , le [ 0 ] ) ; lg ( lb = 1  ; lb < ld ; lb ++ ) lk ( " \x2c \x20 \x25 \x63 " , le [ lb ] ) ; } lk ( " \x5d \n " ) ; } l6 0 ; }
>>>Func
METHOD lj
METHOD_RETURN lb
PARAM lb lf
PARAM lb lg
PARAM lk*lc
<operator>.assignment lh=lm("\x20\x25\x64\x20\n",&la)
ld ld(lh!=1)
BLOCK <empty> <empty>
ld ld(la<lf)
BLOCK <empty> <empty>
ld ld(la>lg)
BLOCK <empty> <empty>
IDENTIFIER llla <empty>
li li("\x73\x63\x61\x6e\x66\x20\x72\x65\x74\x75\x72\x6e\x65\x64""\x20\x25\x64\x20\x69\x6e\x73\x74\x65\x61\x64\x20\x6f\x66\x20\x31\x20""\x66\x6f\x72\x20\x25\x73\n",lh,lc)
le le(1)
li li("\x73\x63\x61""\x6e\x66\x20\x72\x65\x61\x64\x20\x25\x64\x2c\x20\x6c\x65\x73\x73\x20""\x74\x68\x61\x6e\x20\x25\x64\x2c\x20\x66\x6f\x72\x20\x25\x73\n",la,lf,lc)
le le(1)
li li("\x73\x63\x61\x6e\x66\x20\x72\x65\x61\x64""\x20\x25\x64\x2c\x20\x67\x72\x65\x61\x74\x65\x72\x20\x74\x68\x61\x6e""\x20\x25\x64\x2c\x20\x66\x6f\x72\x20\x25\x73\n",la,lg,lc)
le le(1)
lm lm("\x20\x25\x64\x20\n",&la)
<operator>.notEquals lh!=1
<operator>.lessThan la<lf
<operator>.greaterThan la>lg
>>>PDG&23 0->2 0->3 0->4 0->7 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 2->21 3->22 4->13 5->1 5->1 5->20 6->1 6->1 8->1 8->1 10->1 10->1 13->1 13->1 13->15 15->1 15->1 15->17 15->22 17->1 17->1 17->1 17->1 18->1 19->1 19->5 19->5 19->15 19->17 19->21 19->22 20->6 20->6 20->13 21->8 21->8 21->15 21->15 22->10 22->10 22->17 22->17
>>>Token lb lj ( lb lf , lb lg , lk * lc ) { lb la ; lb lh = lm ( " \x20 \x25 \x64 \x20 \n " , & la ) ; ld ( lh != 1 )  { li ( " \x73 \x63 \x61 \x6e \x66 \x20 \x72 \x65 \x74 \x75 \x72 \x6e \x65 \x64 " " \x20 \x25 \x64 \x20 \x69 \x6e \x73 \x74 \x65 \x61 \x64 \x20 \x6f \x66 \x20 \x31 \x20 " " \x66 \x6f \x72 \x20 \x25 \x73 \n " , lh , lc ) ; le ( 1 ) ; } ld ( la < lf )  { li ( " \x73 \x63 \x61 " " \x6e \x66 \x20 \x72 \x65 \x61 \x64 \x20 \x25 \x64 \x2c \x20 \x6c \x65 \x73 \x73 \x20 " " \x74 \x68 \x61 \x6e \x20 \x25 \x64 \x2c \x20 \x66 \x6f \x72 \x20 \x25 \x73 \n " , la , lf , lc ) ; le ( 1 ) ; } ld ( la > lg )  { li ( " \x73 \x63 \x61 \x6e \x66 \x20 \x72 \x65 \x61 \x64 " " \x20 \x25 \x64 \x2c \x20 \x67 \x72 \x65 \x61 \x74 \x65 \x72 \x20 \x74 \x68 \x61 \x6e " " \x20 \x25 \x64 \x2c \x20 \x66 \x6f \x72 \x20 \x25 \x73 \n " , la , lg , lc ) ; le ( 1 ) ; } llla ; }
>>>Func
METHOD lu
METHOD_RETURN lt
PARAM lk li[]
PARAM lk ld[]
IDENTIFIER la <empty>
<operator>.assignment la.lp=-1
<operator>.assignment lb=0
<operator>.notEquals li[le]!='\0'
<operator>.postIncrement le++
lg lg(ln(la)==0)
BLOCK <empty> <empty>
<operator>.assignment ld[lb]='\0'
<operator>.assignment ld[lb]=lh(&la)
<operator>.postIncrement lb++
<operator>.minus -1
<operator>.equals ln(la)==0
ln ln(la)
lh lh(&la)
>>>PDG&18 0->2 0->3 0->4 0->6 0->7 0->8 0->10 0->11 0->13 0->14 0->15 0->16 0->17 2->1 2->7 3->1 5->1 5->1 5->16 6->1 6->13 7->1 7->1 8->1 8->1 9->1 9->1 11->1 11->1 12->1 12->1 13->1 13->1 14->5 15->1 15->9 15->9 16->1 16->15 16->17 17->1 17->12
>>>Token lt lu ( lk li [ ] , lk ld [ ] ) { lw lx la ; la . lp = -1 ; lv le , lb = 0 , lm ; lk lc , ll ; ly ( le = 0  ; li [ le ] != ' \0 ' ; le ++ ) { lc = li [ le ] ; lf ( lr ( lc ) == 1 )  { ld [ lb ] = lc ; lb ++ ; } lj  { lf ( lc == ' ' )  { lo ( & la , lc ) ; } lj  { lf ( lc == ' ' )  { lg ( ( ll = lh ( & la ) ) != ' ' )  { ld [ lb ] = ll ; lb ++ ; } } lj  { lg ( ln ( la ) == 0 )  { lm = lz ( lc , la . lq [ la . lp ] ) ; lf ( lm == 1 )  { ls ; } ld [ lb ] = lh ( & la ) ; lb ++ ; } lo ( & la , lc ) ; } } } } lg ( ln ( la ) == 0 )  { ld [ lb ] = lh ( & la ) ; lb ++ ; } ld [ lb ] = ' \0 ' ; }
>>>Func
METHOD ld
METHOD_RETURN lg
PARAM li*la
lc lc(la!=lb)
BLOCK <empty> <empty>
lc lc(la->lf!=lb)
BLOCK <empty> <empty>
lc lc(la->le!=lb)
BLOCK <empty> <empty>
lh lh(la)
<operator>.assignment la=lb
<operator>.notEquals la!=lb
ld ld(la->lf)
ld ld(la->le)
<operator>.notEquals la->lf!=lb
<operator>.notEquals la->le!=lb
>>>PDG&16 0->2 0->4 0->6 0->8 0->9 0->10 0->11 0->14 0->15 2->11 3->1 3->1 5->1 5->1 7->1 7->1 9->1 10->1 10->1 10->1 11->3 11->3 11->9 11->14 12->1 12->1 13->1 13->1 14->5 14->5 14->12 14->15 15->7 15->7 15->10 15->13
>>>Token lg ld ( li * la ) { lc ( la != lb ) { lc ( la -> lf != lb )  { ld ( la -> lf ) ; } lc ( la -> le != lb )  { ld ( la -> le ) ; } lh ( la ) ; la = lb ; } }
>>>Func
METHOD lu
METHOD_RETURN lp
lr lr("\x20\x25""\x64",&ln)
<operator>.lessEqualsThan ll<=ln
<operator>.preIncrement ++ll
IDENTIFIER ly <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lp lu ( ) { lp la , l1 , ll , ln ; lk lf , li , ld ; lp lj ; lk lc ; lk le , l2 ; lr ( " \x20 \x25 " " \x64 " , & ln ) ; lo ( ll = 1  ; ll <= ln ; ++ ll ) { lr ( " \x20 \x25 \x6c \x66 \x20 \x25 \x6c \x66 " " \x20 \x25 \x6c \x66 \x20 \x25 \x6c \x66 \x20 \x25 \x64 " , & lf , & li , & ld , & lc , & lj ) ; lo ( la = 0  ; la < lj ; ++ la ) { lr ( " \x20 \x25 \x6c \x66 \x20 \x25 \x6c \x66 \x20 \x25 \x6c " " \x66 " , & lb [ la ] . lt , & lb [ la ] . ls , & lb [ la ] . lh ) ; lb [ la ] . lg = lb [ la ] . ls - lb [ la ] . lt ; lf -= ( lb [ la ] . ls - lb [ la ] . lt ) ; } lx ( lb , lj , lw ( l0 lz ) , l3 ) ; le = 0 ; lq ( lf >= lc * ld )  { le += lc ; lf -= lc * ld ; le += ( lf ) / ( li ) ; lc = 0 ; } lm  { le += ( lf ) / ( ld ) ; lc -= ( lf ) / ( ld ) ; } lo ( la = 0  ; la < lj ; ++ la ) { lq ( lc > 0.0 ) { lq ( lb [ la ] . lg >= ( lb [ la ] . lh + ld ) * lc )  { le += lc ; lb [ la ] . lg -= ( lb [ la ] . lh + ld ) * lc ; le += lb [ la ] . lg / ( lb [ la ] . lh + li ) ; lc = 0 ; } lm  { le += lb [ la ] . lg / ( lb [ la ] . lh + ld ) ; lc -= lb [ la ] . lg / ( lb [ la ] . lh + ld ) ; } } lm  { le += ( lk ) ( lb [ la ] . lg ) / ( lk ) ( lb [ la ] . lh + li ) ; } } lv ( " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a \x20 \x25 \x6c \x66 \n " , ll , le ) ; } ly 0 ; }
>>>Func
METHOD l5
METHOD_RETURN l3
PARAM lu*lx
PARAM lg* *ly
PARAM lg* *lv
PARAM lg lb
PARAM lg lr
PARAM lg ls
<operator>.assignment lq=(lg)l7((0.2f/lb) *l6(3.142f*l4(2*lb/3)))
<operator>.assignment ld=lw(lq*lb*l0(lg))
<operator>.lessThan la<lq
<operator>.postIncrement la++
<operator>.assignment ll=lw(lq*l0(lg))
lk lk(lr==0)
BLOCK <empty> <empty>
IDENTIFIER lt <empty>
BLOCK <empty> <empty>
<operator>.assignment la=0
<operator>.lessEqualsThan lf<=lo
<operator>.postIncrement lf++
<operator>.assignment ln=la
lk lk(ls>=2)
BLOCK <empty> <empty>
<operator>.assignment *lx=ln
<operator>.assignment *ly=ll
<operator>.assignment *lv=ld
IDENTIFIER l2 <empty>
<operator>.assignment lp=1
<operator>.assignment lo=lb
<operator>.assignment lp=lo=lr
<operator>.lessThan la<ln
<operator>.postIncrement la++
<operator>.cast (lg)l7((0.2f/lb) *l6(3.142f*l4(2*lb/3)))
lw lw(lq*lb*l0(lg))
lw lw(lq*l0(lg))
<operator>.equals lr==0
<operator>.greaterEqualsThan ls>=2
l7 l7((0.2f/lb) *l6(3.142f*l4(2*lb/3)))
<operator>.multiplication lq*lb*l0(lg)
<operator>.multiplication lq*l0(lg)
<operator>.assignment lo=lr
<operator>.multiplication (0.2f/lb) *l6(3.142f*l4(2*lb/3))
<operator>.multiplication lq*lb
l0 l0(lg)
l0 l0(lg)
<operator>.division 0.2f/lb
l6 l6(3.142f*l4(2*lb/3))
<operator>.multiplication 3.142f*l4(2*lb/3)
l4 l4(2*lb/3)
<operator>.division 2*lb/3
<operator>.multiplication 2*lb
>>>PDG&51 0->2 0->3 0->4 0->5 0->6 0->7 0->10 0->11 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->35 0->36 0->39 0->40 0->42 0->43 0->44 0->45 0->47 0->49 0->50 2->1 3->1 4->1 5->45 6->35 7->36 8->1 8->1 8->42 9->1 9->1 9->25 10->1 10->11 10->39 12->1 12->1 12->24 13->1 13->1 17->1 17->20 17->30 18->1 18->1 18->19 19->1 19->1 20->1 20->30 21->1 21->1 23->1 23->1 23->1 24->1 24->1 24->1 25->1 25->1 25->1 27->1 28->1 28->1 29->1 29->1 29->1 30->1 30->23 30->31 31->1 31->1 32->1 33->1 33->9 34->1 34->12 35->13 35->13 35->29 35->40 36->1 36->21 36->21 37->1 37->8 37->32 38->1 38->33 38->33 39->1 39->1 39->34 39->34 40->1 40->18 40->29 41->1 41->1 41->37 41->37 42->10 42->28 42->38 42->38 43->38 43->44 44->1 44->39 45->41 45->41 45->50 46->1 46->41 47->1 47->46 47->46 48->1 48->47 49->1 49->48 49->48 50->42 50->49 50->49
>>>Token l3 l5 ( lu * lx , lg * * ly , lg * * lv , lg lb , lg lr , lg ls ) { lg le , lh , lc , lf ; lu ln , la ; lg * ll , * ld ; lg lp , lo ; lu lq = ( lg ) l7 ( ( 0.2f / lb ) * l6 ( 3.142f * l4 ( 2 * lb / 3 ) ) ) ; lg lm ; ld = lw ( lq * lb * l0 ( lg ) ) ; li ( la = 0  ; la < lq ; la ++ ) { li ( le = 0  ; le < lb ; le ++ ) { ld [ la * lb + le ] = 0 ; } } ll = lw ( lq * l0 ( lg ) ) ; lk ( lr == 0 )  { lp = 1 ; lo = lb ; } lt { lp = lo = lr ; } la = 0 ; li ( lf = lp  ; lf <= lo ; lf ++ ) { ld [ la * lb + 0 ] = lb - lf + 1 ; li ( le = 1  ; le <= lf - 1 ; le ++ ) { ld [ la * lb + le ] = 1 ; } ll [ la ] = lf ; l1 ( 1 )  { lk ( ls >= 3 ) { lj ( " \x70 \x61 \x72 \x74 \x69 \x74 " " \x69 \x6f \x6e \x20 \x23 \x25 \x6c \x64 \x20 \x3a " , la ) ; li ( le = 0  ; le < lf ; le ++ ) { lj ( " \x20 \x25 \x64 \x20 " , ld [ la * lb + le ] ) ; } lj ( " \n " ) ; } ll [ la ] = lf ; li ( lh = lf - 2  ; lh >= 0 ; lh -- ) { lk ( ld [ la * lb + lh ] >= ld [ la * lb + ( lf - 1 ) ] + 2 )  { lz ; } } lk ( lh == -1 )  { la ++ ; lz ; } lt  { li ( lc = 0  ; lc <= lh - 1 ; lc ++ ) { ld [ ( la + 1 ) * lb + lc ] = ld [ la * lb + lc ] ; } ld [ ( la + 1 ) * lb + lh ] = ld [ la * lb + lh ] - 1 ; lm = 1 ; li ( lc = lh + 1  ; lc <= lf - 1 ; lc ++ ) { lm += ld [ la * lb + lc ] ; } li ( lc = lh + 1  ; lc <= lf - 1 ; lc ++ ) { lk ( ld [ ( la + 1 ) * lb + ( lc - 1 ) ] + ( lf - lc - 1 ) <= lm )  { ld [ ( la + 1 ) * lb + lc ] = ld [ ( la + 1 ) * lb + ( lc - 1 ) ] ; } lt  { ld [ ( la + 1 ) * lb + lc ] = lm - ( lf - lc - 1 ) ; } lm -= ld [ ( la + 1 ) * lb + lc ] ; } la ++ ; } } } ln = la ; lk ( ls >= 2 )  { li ( la = 0  ; la < ln ; la ++ ) { lj ( " \x20 \x20 \x70 \x61 \x72 \x74 \x69 \x74 \x69 \x6f \x6e \x20 \x23 \x25 " " \x6c \x64 \x2f \x25 \x6c \x64 \x20 \x3a " , la , ln ) ; li ( le = 0  ; le < ll [ la ] ; le ++ ) { lj ( " " " \x20 \x25 \x64 \x20 " , ld [ la * lb + le ] ) ; } lj ( " \n " ) ; } } * lx = ln ; * ly = ll ; * lv = ld ; l2 ; }
>>>Func
METHOD ll
METHOD_RETURN le
PARAM le la
PARAM lo ld
<operator>.lessThan lb<lc[la].lp.lj
<operator>.postIncrement lb++
li li(lm(la,ld)==0)
BLOCK <empty> <empty>
<operator>.assignment lc[la].lf.lq[lc[la].lf.lh]=ld
<operator>.postIncrement lc[la].lf.lh++
IDENTIFIER lg <empty>
LITERAL 0 <empty>
IDENTIFIER lg <empty>
LITERAL 0 <empty>
<operator>.equals lm(la,ld)==0
lm lm(la,ld)
>>>PDG&16 0->2 0->3 0->4 0->5 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 2->15 3->15 4->1 4->5 5->1 5->1 6->1 6->1 8->1 8->1 8->1 9->1 9->1 14->1 14->6 14->6 15->1 15->8 15->14 15->14
>>>Token le ll ( le la , lo ld ) { le lb ; lk ( lb = 0  ; lb < lc [ la ] . lp . lj ; lb ++ ) { li ( ln ( la , lb , ld ) == 0 )  { lg 0 ; } } li ( lm ( la , ld ) == 0 )  { lg 0 ; } lc [ la ] . lf . lq [ lc [ la ] . lf . lh ] = ld ; lc [ la ] . lf . lh ++ ; lg 0 ; }
>>>Func
METHOD lg
METHOD_RETURN lf
PARAM lh ld[100][101]
PARAM lc lb
<operator>.notEquals la!=lb
<operator>.preIncrement ++la
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token lf lg ( lh ld [ 100 ] [ 101 ] , lc lb ) { lj ( lc  la = 0 ; la != lb ; ++ la ) { le ( ld , lb , la ) ; li ( " " " \n " ) ; } }
>>>Func
METHOD l1
METHOD_RETURN lh
lm lm("\x25\x64",&ly)
<operator>.lessEqualsThan lp<=ly
<operator>.postIncrement lp++
IDENTIFIER l2 <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lh l1 ( ) { lh ly , lp ; lm ( " \x25 \x64 " , & ly ) ; ll ( lp = 1  ; lp <= ly ; lp ++ ) { lh lt , ls , lz ; lh lc , lg ; lx ld [ 101 ] ; lh lb , la , lu ; lh ln [ 28 ] ; lh lr ; lx li [ 8 ] [ 8 ] ; lx lq [ 100 ] ; lh lj [ 101 ] ; lh lf ; lh lo ; lw ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " " \x5b " , lp ) ; l0 ( li , 0 , l7 ( li ) ) ; lm ( " \x25 \x64 " , & lt ) ; ll ( lc = 0  ; lc < lt ; lc ++ ) { lo = lm ( " \x25 \x33 \x73 " , ld ) ; le ( lo == 1 ) ; lb = lk ( ld [ 0 ] ) ; la = lk ( ld [ 1 ] ) ; lu = lk ( ld [ 2 ] ) ; le ( lb >= 0 ) ; le ( la >= 0 ) ; le ( lu < 0 ) ; le ( li [ lb ] [ la ] == 0 ) ; le ( li [ la ] [ lb ] == 0 ) ; li [ lb ] [ la ] = ld [ 2 ] ; li [ la ] [ lb ] = ld [ 2 ] ; } lr = 0 ; lm ( " \x25 \x64 " , & ls ) ; ll ( lc = 0  ; lc < ls ; lc ++ ) { lo = lm ( " \x25 \x32 \x73 " , ld ) ; le ( lo == 1 ) ; lb = lk ( ld [ 0 ] ) ; la = lk ( ld [ 1 ] ) ; le ( lb >= 0 ) ; le ( la >= 0 ) ; le ( lb != la ) ; ln [ lr ] = ( 1 << lb ) | ( 1 << la ) ; lr ++ ; } lj [ 0 ] = 0 ; lf = 0 ; la = -1 ; lm ( " \x25 \x64 \x20 \x25 \x73 " , & lz , ld ) ; ll ( lg = 0  ; lg < lz ; lg ++ ) { lb = lk ( ld [ lg ] ) ; le ( lb >= 0 ) ; lv ( la >= 0 && li [ lb ] [ la ] != 0 )  { lq [ lf - 1 ] = li [ lb ] [ la ] ; la = -1 ; lj [ lf ] = lj [ lf - 1 ] ; l6 ; } lq [ lf ] = ld [ lg ] ; lf ++ ; la = lb ; lj [ lf ] = lj [ lf - 1 ] | ( 1 << lb ) ; ll ( lc = 0  ; lc < ls ; lc ++ ) { le ( ln [ lc ] != 0 ) ; lv ( ( lj [ lf ] & ln [ lc ] ) == ln [ lc ] )  { lf = 0 ; la = -1 ; l4 ; } } } ll ( lg = 0  ; lg < lf ; lg ++ ) { lv ( lg > 0 ) { l5 ( " \x2c \x20 " , l3 ) ; } lw ( " " " \x25 \x63 " , lq [ lg ] ) ; } lw ( " \x5d \n " ) ; } l2 0 ; }
>>>Func
METHOD li
METHOD_RETURN lh
PARAM lc lb[100]
PARAM lc*ld
PARAM lc*le
lg lg("\x68\x65\x6c\x6c\x6f")
<operator>.lessEqualsThan la<=le-lb
<operator>.postIncrement la++
<operator>.subtraction le-lb
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->8 3->1 4->8 5->1 6->1 6->1 6->7 7->1 7->1 8->1 8->1 8->6 8->6
>>>Token lh li ( lc lb [ 100 ] , lc * ld , lc * le ) { lg ( " \x68 \x65 \x6c \x6c \x6f " ) ; lf la ; lj ( la = ld - lb  ; la <= le - lb ; la ++ ) { lb [ la ] = ' ' ; } }
>>>Func
METHOD lf
METHOD_RETURN lg
PARAM ld le
<operator>.assignment lb[0]=lc*le
<operator>.lessThan la<521
<operator>.postIncrement la++
<operator>.assignment ll=lk
<operator>.assignment lj=0
<operator>.assignment lm=521
IDENTIFIER li <empty>
<operator>.multiplication lc*le
>>>PDG&11 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->10 3->1 3->1 3->1 4->1 4->5 5->1 5->1 6->1 6->1 6->1 7->1 7->1 8->1 8->1 10->1 10->1 10->3 10->3
>>>Token lg lf ( ld le ) { ld la ; lb [ 0 ] = lc * le ; lh ( la = 1  ; la < 521 ; la ++ ) { lb [ la ] = lc * lb [ la - 1 ] + ln ; } ll = lk ; lj = 0 ; lm = 521 ; li ; }
>>>Func
METHOD lj
METHOD_RETURN lc
PARAM lf*la
PARAM lc lb
le le(lb>=0&&lb<la->lk)
BLOCK <empty> <empty>
le le(la->la[lb]!=0)
BLOCK <empty> <empty>
IDENTIFIER li <empty>
<operator>.logicalAnd lb>=0&&lb<la->lk
<operator>.assignment la->la[lb]=0
<operator>.greaterEqualsThan lb>=0
<operator>.lessThan lb<la->lk
<operator>.notEquals la->la[lb]!=0
<operator>.indirectFieldAccess la->lk
FIELD_IDENTIFIER lk lk
>>>PDG&16 0->2 0->3 0->5 0->7 0->8 0->10 0->11 0->12 0->13 2->1 3->11 4->1 4->1 6->1 6->1 9->1 9->1 9->4 9->4 10->1 10->1 11->1 11->9 11->9 11->12 11->12 11->14 11->15 12->1 12->1 12->9 12->9 13->6 13->6
>>>Token lc lj ( lf * la , lc lb ) { le ( lb >= 0 && lb < la -> lk )  { le ( la -> la [ lb ] != 0 )  { la -> la [ lb ] = 0 ; } lh ld li ; } ld lg ; }
>>>Func
METHOD lr
METHOD_RETURN ln
PARAM lq lb[100][101]
PARAM ld la
PARAM ld lf
<operator>.assignment ll=ls(lb,la,lf,-1)
<operator>.assignment li=lj(lb,la,lf,-1)
<operator>.assignment lg=0
<operator>.assignment lh=0
<operator>.notEquals lc!=la
<operator>.preIncrement ++lc
<operator>.assignment lk=lg/lh
lo lo("\x25\x66\x20",0.25*ll+0.5*li+0.25*lk)
ls ls(lb,la,lf,-1)
lj lj(lb,la,lf,-1)
<operator>.division lg/lh
<operator>.addition 0.25*ll+0.5*li+0.25*lk
<operator>.minus -1
<operator>.minus -1
<operator>.addition 0.25*ll+0.5*li
<operator>.multiplication 0.25*lk
<operator>.multiplication 0.25*ll
<operator>.multiplication 0.5*li
>>>PDG&23 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->17 0->18 0->20 0->21 0->22 2->13 3->13 4->13 5->1 5->1 5->21 6->1 6->1 6->22 7->1 7->15 8->1 8->15 9->1 9->1 9->10 10->1 10->1 11->1 11->1 11->20 12->1 12->1 13->5 13->5 13->5 13->5 13->14 13->14 13->14 14->1 14->1 14->1 14->6 14->6 14->6 14->6 14->9 15->1 15->1 15->11 15->11 16->1 16->1 17->13 18->14 19->1 19->1 20->1 20->12 20->12 20->16 20->16 21->1 21->12 21->12 21->16 21->16 21->19 21->19 22->1 22->12 22->12 22->16 22->16 22->19 22->19
>>>Token ln lr ( lq lb [ 100 ] [ 101 ] , ld la , ld lf ) { le ll = ls ( lb , la , lf , -1 ) ; le li = lj ( lb , la , lf , -1 ) ; le lg = 0 ; ld lh = 0 ; lp ( ld  lc = 0 ; lc != la ; ++ lc ) { lm ( lb [ lf ] [ lc ] != ' ' )  { lg += lj ( lb , la , lc , -1 ) ; ++ lh ; } } le lk = lg / lh ; lo ( " \x25 \x66 \x20 " , 0.25 * ll + 0.5 * li + 0.25 * lk ) ; }
>>>Func
METHOD ll
METHOD_RETURN lf
PARAM lf*lb
<operator>.assignment la=0
IDENTIFIER lc <empty>
<operator>.assignment lc=la
lk lk(lb[la]!='\n'&&lb[la]!=0)
BLOCK <empty> <empty>
lh lh(lb[la]=='\n')
BLOCK <empty> <empty>
IDENTIFIER li <empty>
<operator>.postIncrement la++
<operator>.assignment lb[la]=0
<operator>.postIncrement la++
<operator>.plus +lc
<operator>.logicalAnd lb[la]!='\n'&&lb[la]!=0
<operator>.equals lb[la]=='\n'
<operator>.notEquals lb[la]!='\n'
<operator>.notEquals lb[la]!=0
<operator>.indirectIndexAccess lb[la]
>>>PDG&20 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 2->1 2->16 2->17 2->18 3->1 3->5 3->11 5->1 5->14 6->1 6->1 8->1 8->1 11->13 12->1 12->1 13->1 13->1 14->1 14->1 15->1 15->1 15->6 15->6 16->8 16->8 17->15 17->15 17->16 17->18 17->18 17->19 18->15 18->15 18->16
>>>Token lf * ll ( lf * lb ) { lg le la = 0 ; lg le lc ; lc = la ; lk ( lb [ la ] != ' \n ' && lb [ la ] != 0 )  { la ++ ; } lh ( lb [ la ] == ' \n ' )  { lb [ la ] = 0 ; la ++ ; ld lb  + lc ; } lj ld li ; }
>>>Func
METHOD lo
METHOD_RETURN ld
PARAM lb*lg
PARAM ld lf
PARAM lb* *lj
PARAM lb*le
<operator>.assignment lc=0
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 4->1 5->1 6->1 6->1
>>>Token ln ld lo ( lb * lg , ld lf , lb * * lj , lb * le ) { ld lc = 0 ; lb * la ; lp ( la = lg  ; ; ) { ll ( * la && li ( le , * la ) ) la ++ ; lh ( ! * la ) lk ; lq ( lc < lf ) ; lj [ lc ++ ] = la ; ll ( * la && ! li ( le , * la ) ) la ++ ; lh ( ! * la ) lk ; * la ++ = 0 ; } lm lc ; }
>>>Func
METHOD ln
METHOD_RETURN lm
PARAM ld* *lf
PARAM ld* *lh
PARAM ld li
PARAM ll*la
<operator>.lessThan lg(lb,26)<le
<operator>.lessThan ';'>lg(lc,26)<le
<operator>.lessThan lg(lb,li)<le
<operator>.lessThan lg(lb,li)<le
lg lg(lb,26)
<operator>.greaterThan ';'>lg(lc,26)
lg lg(lb,li)
lg lg(lb,li)
lg lg(lc,26)
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 4->12 5->1 6->1 6->1 6->7 7->1 7->1 7->8 8->9 9->1 9->1 9->1 10->6 10->6 10->12 11->1 11->7 11->7 12->8 12->8 12->13 12->13 13->1 13->1 13->9 13->9 14->1 14->11 14->11
>>>Token lm ln ( ld * * lf , ld * * lh , ld li , ll * la ) { ld lb , lc ; lg ( lb , 26 ) < le ' ' > lg ( lc , 26 ) < le ' ; ' { lf [ lb ] [ lc ] = -1 ; lh [ lb ] [ lc ] = 0 ; } lg ( lb , li ) < le ' ; ' { lj ( " \x25 \x73 " , la ) ; lf [ la [ 0 ] - 65 ] [ la [ 1 ] - 65 ] = la [ 2 ] - 65 ; lf [ la [ 1 ] - 65 ] [ la [ 0 ] - 65 ] = la [ 2 ] - 65 ; } lk ( li ) lg ( lb , li ) < le ' ; ' { lj ( " \x25 \x73 " , la ) ; lh [ la [ 0 ] - 65 ] [ la [ 1 ] - 65 ] = 1 ; lh [ la [ 1 ] - 65 ] [ la [ 0 ] - 65 ] = 1 ; } }
>>>Func
METHOD ly
METHOD_RETURN la
<operator>.assignment lj=0
lk lk("\x25\x64",&lw)
<operator>.lessThan lm<lw
<operator>.postIncrement lm++
IDENTIFIER lz <empty>
LITERAL 0 <empty>
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token la ly ( ) { la lw , lx , lu , lt ; la lm , lb , le , lo , ld , lj = 0 ; lv lc , lg , lr ; lv ll [ 26 ] [ 26 ] ; la lp [ 26 ] [ 26 ] ; la li [ 26 ] ; lk ( " \x25 \x64 " , & lw ) ; lh ( lm = 0  ; lm < lw ; lm ++ ) { ld = 0 ; lj = 0 ; lh ( lb = 0  ; lb < 26 ; lb ++ ) { li [ lb ] = 0 ; lh ( le = 0  ; le < 26 ; le ++ ) { ll [ lb ] [ le ] = ' \0 ' ; lp [ lb ] [ le ] = 0 ; } } lv lf [ 100 ] = " " ; lk ( " \x20 \x25 \x64 " , & lx ) ; lh ( lb = 0  ; lb < lx ; lb ++ ) { lk ( " \x20 \x25 \x63 \x25 \x63 \x25 \x63 " , & lc , & lg , & lr ) ; ll [ ( la ) lc - 65 ] [ ( la ) lg - 65 ] = lr ; ll [ ( la ) lg - 65 ] [ ( la ) lc - 65 ] = lr ; } lk ( " \x20 \x25 \x64 " , & lu ) ; lh ( lb = 0  ; lb < lu ; lb ++ ) { lk ( " \x20 \x25 \x63 \x25 \x63 " , & lc , & lg ) ; lp [ ( la ) lc - 65 ] [ ( la ) lg - 65 ] = 1 ; lp [ ( la ) lg - 65 ] [ ( la ) lc - 65 ] = 1 ; } lk ( " \x20 \x25 \x64 \x20 " , & lt ) ; lh ( lb = 0  ; lb < lt ; lb ++ ) { lk ( " \x25 \x63 " , & lc ) ; lj = 0 ; lg = lf [ ld - 1 ] ; ln ( ld == 0 )  { lf [ ld ++ ] = lc ; li [ ( la ) lc - 65 ] ++ ; lj = 1 ; } ls ln ( ll [ ( la ) lc - 65 ] [ ( la ) lg - 65 ] ! = ' \0 ' ) { li [ ( la ) lf [ ld - 1 ] - 65 ] -- ; lf [ ld - 1 ] = ll [ ( la ) lc - 65 ] [ ( la ) lg - 65 ] ; li [ ( la ) lf [ ld - 1 ] - 65 ] ++ ; lj = 1 ; } ls  { lh ( le = 0  ; le < 26 ; le ++ ) { ln ( lp [ ( la ) lc - 65 ] [ le ] == 1 && li [ le ] > 0 ) { * lf = " " ; lj = 1 ; ld = 0 ; lh ( lo = 0  ; lo < 26 ; lo ++ ) { li [ lo ] = 0 ; } } } } ln ( lj == 0 && ld > 0 )  { lf [ ld ++ ] = lc ; li [ ( la ) lc - 65 ] ++ ; } } lq ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 " " \x3a \x20 \x5b " , lm + 1 ) ; lh ( lb = 0  ; lb < ld - 1 ; lb ++ ) { lq ( " \x25 \x63 \x2c \x20 " , lf [ lb ] ) ; } ln ( ld > 0 )  { lq ( " \x25 \x63 \x5d \n " , lf [ ld - 1 ] ) ; } ls  { lq ( " \x5d \n " ) ; } } lz 0 ; }
>>>Func
METHOD lv
METHOD_RETURN lo
lz lz()
li li("\x25\x64",&ls)
<operator>.lessThan ll<ls
<operator>.preIncrement ++ll
IDENTIFIER ly <empty>
LITERAL 0 <empty>
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token lo lv ( ) { lz ( ) ; lo ls , ll , le , la , ld , lq , lp , lu ; li ( " \x25 \x64 " , & ls ) ; lf ( ll = 0  ; ll < ls ; ++ ll ) { li ( " \x25 \x64 " , & lq ) ; lr lg [ 40 ] [ 4 ] ; lr lk [ 30 ] [ 3 ] ; lr lt [ 101 ] ; lrlc [ 101 ] ; lo lb = 0 ; lo lj ; lf ( le = 0  ; le < lq ; ++ le ) { li ( " \x25 \x73 " , lg [ le ] ) ; } li ( " " " \x25 \x64 " , & lp ) ; lf ( la = 0  ; la < lp ; ++ la ) { li ( " \x25 \x73 " , lk [ la ] ) ; } li ( " \x25 " " \x64 " , & lu ) ; li ( " \x25 \x73 " , lt ) ; lf ( le = 0  ; le < lu ; ++ le ) { lc [ lb ] = lt [ le ] ; ++ lb ; lx ( 1 )  { lh ( lb < 2 ) { lm ; } lj = 0 ; lf ( la = 0  ; la < lq ; ++ la ) { lh ( ( lg [ la ] [ 0 ] == lc [ lb - 1 ] && lg [ la ] [ 1 ] == lc [ lb - 2 ] ) || ( lg [ la ] [ 1 ] == lc [ lb - 1 ] && lg [ la ] [ 0 ] == lc [ lb - 2 ] ) )  { lj = 1 ; lc [ lb - 2 ] = lg [ la ] [ 2 ] ; -- lb ; lm ; } } lh ( lj ) { lw ; } lf ( ld = 0  ; ld < lb - 1 ; ++ ld ) { lf ( la = 0  ; la < lp ; ++ la ) { lh ( ( lk [ la ] [ 0 ] == lc [ lb - 1 ] && lk [ la ] [ 1 ] == lc [ ld ] ) || ( lk [ la ] [ 1 ] == lc [ lb - 1 ] && lk [ la ] [ 0 ] == lc [ ld ] ) )  { lj = 1 ; lm ; } } lh ( lj ) { lb = 0 ; lm ; } } lh ( ! lj )  { lm ; } } } ln ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , ll + 1 ) ; ln ( " \x5b " ) ; lf ( ld = 0  ; ld < lb ; ++ ld ) { lh ( ld != 0 ) { ln ( " \x2c \x20 " ) ; } ln ( " \x25 \x63 " , lc [ ld ] ) ; } ln ( " \x5d \n " ) ; } ly 0 ; }
>>>Func
METHOD l62
METHOD_RETURN l0
PARAM l0 lg
PARAM lp* *lc
<operator>.assignment *lw=lh
<operator>.assignment *lj=lh
<operator>.assignment *ll=lh
l43 l43(&lg,&lc)
l64 l64(lc[0])
l47 l47(l61,"")
l36 l36(l16,l59)
l70 l70(l16)
l57 l57(l39)
l68 l68((l9=l44(lg,lc,"\x6d\x3a\x5a",l30,lh))!=-1)
BLOCK <empty> <empty>
<operator>.assignment li=l71
la la(lw)
BLOCK <empty> <empty>
<operator>.assignment lk=(lg<=lb||(lb+1<lg&&lc[lb+1][0]=='p')?2:4)
la la(lg-lb<lk)
BLOCK <empty> <empty>
la la(lk<lg-lb)
BLOCK <empty> <empty>
la la(lj)
BLOCK <empty> <empty>
l24 l24(lc[lb+1][0])
BLOCK <empty> <empty>
la la(lw&&l33(lc[lb],li)!=0)
lf lf(le lu ld("\x63\x61\x6e\x6e\x6f\x74""\x20\x73\x65\x74\x20\x70\x65\x72\x6d\x69\x73\x73\x69\x6f\x6e\x73\x20""\x6f\x66\x20\x25\x73") l58(lc[lb]))
l24 l24(l9)
BLOCK <empty> <empty>
<operator>.assignment *l1=l31(lw)
la la(!l1)
lf lf(le 0 ld("\x69\x6e\x76\x61\x6c\x69\x64\x20\x6d\x6f\x64\x65"))
<operator>.assignment lx=l28(0)
l28 l28(lx)
<operator>.assignment li=l66(li,l55,lx,l1,lh)
l45 l45(l1)
la la(li&~l72)
lf lf(le 0 ld("\x6d\x6f\x64\x65\x20\x6d\x75\x73\x74\x20\x73\x70\x65\x63\x69\x66""\x79\x20\x6f\x6e\x6c\x79\x20\x66\x69\x6c\x65\x20\x70\x65\x72\x6d\x69""\x73\x73\x69\x6f\x6e\x20\x62\x69\x74\x73"))
la la(lg<=lb)
lo lo(0 0 ld("\x6d\x69\x73""\x73\x69\x6e\x67\x20\x6f\x70\x65\x72\x61\x6e\x64"))
IDENTIFIER lr <empty>
lo lo(0 0 ld("""\x6d\x69\x73\x73\x69\x6e\x67\x20\x6f\x70\x65\x72\x61\x6e\x64\x20\x61""\x66\x74\x65\x72\x20\x25\x73") ln(lc[lg-1]))
la la(lk==4&&lg-lb==2)
l17 l17(l27 "\x25\x73\n" ld("\x53\x70\x65\x63\x69\x61\x6c\x20\x66\x69\x6c\x65""\x73\x20\x72\x65\x71\x75\x69\x72\x65\x20\x6d\x61\x6a\x6f\x72\x20\x61""\x6e\x64\x20\x6d\x69\x6e\x6f\x72\x20\x64\x65\x76\x69\x63\x65\x20\x6e""\x75\x6d\x62\x65\x72\x73\x2e"))
l6 l6(le)
lo lo(0 0 ld("\x65""\x78\x74\x72\x61\x20\x6f\x70\x65\x72\x61\x6e\x64\x20\x25\x73") ln(lc[lb+lk]))
la la(lk==2&&lg-lb==4)
l17 l17(l27 "\x25\x73\n" ld("\x46\x69\x66""\x6f\x73\x20\x64\x6f\x20\x6e\x6f\x74\x20\x68\x61\x76\x65\x20\x6d\x61""\x6a\x6f\x72\x20\x61\x6e\x64\x20\x6d\x69\x6e\x6f\x72\x20\x64\x65\x76""\x69\x63\x65\x20\x6e\x75\x6d\x62\x65\x72\x73\x2e"))
l6 l6(le)
<operator>.assignment l5=0
<operator>.assignment l5=l60(lj)
<operator>.assignment l5=l54(lj)
la la(l5<0)
lf lf(le lu ld("\x66""\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x73\x65\x74\x20\x64\x65\x66\x61""\x75\x6c\x74\x20\x66\x69\x6c\x65\x20\x63\x72\x65\x61\x74\x69\x6f\x6e""\x20\x63\x6f\x6e\x74\x65\x78\x74\x20\x74\x6f\x20\x25\x73") ln(lj))
IDENTIFIER lm <empty>
LITERAL 'b' <empty>
<operator>.assignment ls=l14
IDENTIFIER lm <empty>
LITERAL 'c' <empty>
<operator>.assignment ls=l21
IDENTIFIER l8 <empty>
BLOCK <empty> <empty>
IDENTIFIER lz <empty>
IDENTIFIER lm <empty>
LITERAL 'p' <empty>
la la(l41(lc[lb],li)!=0)
lf lf(le lu "\x25\x73" l26(lc[lb]))
IDENTIFIER lz <empty>
lo lo(0 0 ld("\x69\x6e\x76\x61\x6c\x69\x64\x20\x64\x65""\x76\x69\x63\x65\x20\x74\x79\x70\x65\x20\x25\x73") ln(lc[lb+1]))
l6 l6(le)
<operator>.notEquals (l9=l44(lg,lc,"\x6d\x3a\x5a",l30,lh))!=-1
IDENTIFIER lm <empty>
LITERAL 'm' <empty>
IDENTIFIER lz <empty>
IDENTIFIER lm <empty>
LITERAL 'Z' <empty>
IDENTIFIER lr <empty>
la la(l50()>0)
BLOCK <empty> <empty>
IDENTIFIER lz <empty>
IDENTIFIER l69 <empty>
l32 l32(l37,l42)
l6 l6(le)
<operator>.conditional lg<=lb||(lb+1<lg&&lc[lb+1][0]=='p')?2:4
<operator>.lessThan lg-lb<lk
<operator>.lessThan lk<lg-lb
<operator>.assignment *l3=lc[lb+2]
<operator>.assignment *l4=lc[lb+3]
la la(l22(l3,lh,0,&lv,"")!=l20||lv!=(l40)lv)
lf lf(le 0 ld("\x69\x6e\x76""\x61\x6c\x69\x64\x20\x6d\x61\x6a\x6f\x72\x20\x64\x65\x76\x69\x63\x65""\x20\x6e\x75\x6d\x62\x65\x72\x20\x25\x73") ln(l3))
la la(l22(l4,lh,0,&lt,"")!=l20||lt!=(l46)lt)
lf lf(le 0 ld("\x69\x6e\x76\x61\x6c\x69\x64\x20""\x6d\x69\x6e\x6f\x72\x20\x64\x65\x76\x69\x63\x65\x20\x6e\x75\x6d\x62""\x65\x72\x20\x25\x73") ln(l4))
<operator>.assignment ly=l51(lv,lt)
l29 l29(ll,lc[lb],ls)
la la(l49(lc[lb],li|ls,ly)!=0)
lf lf(le lu "\x25\x73" l26(lc[lb]))
<operator>.logicalAnd lw&&l33(lc[lb],li)!=0
ld ld("\x63\x61\x6e\x6e\x6f\x74""\x20\x73\x65\x74\x20\x70\x65\x72\x6d\x69\x73\x73\x69\x6f\x6e\x73\x20""\x6f\x66\x20\x25\x73")
l58 l58(lc[lb])
<operator>.assignment l9=l44(lg,lc,"\x6d\x3a\x5a",l30,lh)
<operator>.minus -1
<operator>.assignment lj=lq
IDENTIFIER lr <empty>
BLOCK <empty> <empty>
l31 l31(lw)
<operator>.logicalNot !l1
ld ld("\x69\x6e\x76\x61\x6c\x69\x64\x20\x6d\x6f\x64\x65")
l28 l28(0)
l66 l66(li,l55,lx,l1,lh)
<operator>.and li&~l72
ld ld("\x6d\x6f\x64\x65\x20\x6d\x75\x73\x74\x20\x73\x70\x65\x63\x69\x66""\x79\x20\x6f\x6e\x6c\x79\x20\x66\x69\x6c\x65\x20\x70\x65\x72\x6d\x69""\x73\x73\x69\x6f\x6e\x20\x62\x69\x74\x73")
<operator>.logicalOr lg<=lb||(lb+1<lg&&lc[lb+1][0]=='p')
<operator>.subtraction lg-lb
<operator>.lessEqualsThan lg<=lb
ld ld("\x6d\x69\x73""\x73\x69\x6e\x67\x20\x6f\x70\x65\x72\x61\x6e\x64")
ld ld("""\x6d\x69\x73\x73\x69\x6e\x67\x20\x6f\x70\x65\x72\x61\x6e\x64\x20\x61""\x66\x74\x65\x72\x20\x25\x73")
ln ln(lc[lg-1])
<operator>.logicalAnd lk==4&&lg-lb==2
ld ld("\x53\x70\x65\x63\x69\x61\x6c\x20\x66\x69\x6c\x65""\x73\x20\x72\x65\x71\x75\x69\x72\x65\x20\x6d\x61\x6a\x6f\x72\x20\x61""\x6e\x64\x20\x6d\x69\x6e\x6f\x72\x20\x64\x65\x76\x69\x63\x65\x20\x6e""\x75\x6d\x62\x65\x72\x73\x2e")
<operator>.subtraction lg-lb
ld ld("\x65""\x78\x74\x72\x61\x20\x6f\x70\x65\x72\x61\x6e\x64\x20\x25\x73")
ln ln(lc[lb+lk])
<operator>.logicalAnd lk==2&&lg-lb==4
ld ld("\x46\x69\x66""\x6f\x73\x20\x64\x6f\x20\x6e\x6f\x74\x20\x68\x61\x76\x65\x20\x6d\x61""\x6a\x6f\x72\x20\x61\x6e\x64\x20\x6d\x69\x6e\x6f\x72\x20\x64\x65\x76""\x69\x63\x65\x20\x6e\x75\x6d\x62\x65\x72\x73\x2e")
l60 l60(lj)
l54 l54(lj)
<operator>.lessThan l5<0
ld ld("\x66""\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x73\x65\x74\x20\x64\x65\x66\x61""\x75\x6c\x74\x20\x66\x69\x6c\x65\x20\x63\x72\x65\x61\x74\x69\x6f\x6e""\x20\x63\x6f\x6e\x74\x65\x78\x74\x20\x74\x6f\x20\x25\x73")
ln ln(lj)
<operator>.notEquals l41(lc[lb],li)!=0
l26 l26(lc[lb])
ld ld("\x69\x6e\x76\x61\x6c\x69\x64\x20\x64\x65""\x76\x69\x63\x65\x20\x74\x79\x70\x65\x20\x25\x73")
ln ln(lc[lb+1])
<operator>.notEquals l33(lc[lb],li)!=0
l44 l44(lg,lc,"\x6d\x3a\x5a",l30,lh)
<operator>.greaterThan l50()>0
<operator>.assignment ll=l35(l34,lh,0)
la la(!ll)
lo lo(0 lu ld("\x77\x61\x72\x6e\x69\x6e\x67""\x3a\x20\x69\x67\x6e\x6f\x72\x69\x6e\x67\x20\x2d\x2d\x63\x6f\x6e\x74""\x65\x78\x74"))
<operator>.not ~l72
<operator>.lessEqualsThan lg<=lb
<operator>.logicalAnd lb+1<lg&&lc[lb+1][0]=='p'
<operator>.equals lk==4
<operator>.equals lg-lb==2
<operator>.equals lk==2
<operator>.equals lg-lb==4
<operator>.addition lb+1
<operator>.logicalOr l22(l3,lh,0,&lv,"")!=l20||lv!=(l40)lv
ld ld("\x69\x6e\x76""\x61\x6c\x69\x64\x20\x6d\x61\x6a\x6f\x72\x20\x64\x65\x76\x69\x63\x65""\x20\x6e\x75\x6d\x62\x65\x72\x20\x25\x73")
ln ln(l3)
<operator>.logicalOr l22(l4,lh,0,&lt,"")!=l20||lt!=(l46)lt
ld ld("\x69\x6e\x76\x61\x6c\x69\x64\x20""\x6d\x69\x6e\x6f\x72\x20\x64\x65\x76\x69\x63\x65\x20\x6e\x75\x6d\x62""\x65\x72\x20\x25\x73")
ln ln(l4)
l51 l51(lv,lt)
<operator>.notEquals l49(lc[lb],li|ls,ly)!=0
l26 l26(lc[lb])
l41 l41(lc[lb],li)
l33 l33(lc[lb],li)
<operator>.lessThan lb+1<lg
<operator>.equals lc[lb+1][0]=='p'
<operator>.subtraction lg-1
<operator>.subtraction lg-lb
<operator>.addition lb+lk
<operator>.subtraction lg-lb
<operator>.addition lb+2
<operator>.addition lb+3
<operator>.notEquals l22(l3,lh,0,&lv,"")!=l20
<operator>.notEquals lv!=(l40)lv
<operator>.notEquals l22(l4,lh,0,&lt,"")!=l20
<operator>.notEquals lt!=(l46)lt
l49 l49(lc[lb],li|ls,ly)
<operator>.addition lb+1
l35 l35(l34,lh,0)
<operator>.logicalNot !ll
ld ld("\x77\x61\x72\x6e\x69\x6e\x67""\x3a\x20\x69\x67\x6e\x6f\x72\x69\x6e\x67\x20\x2d\x2d\x63\x6f\x6e\x74""\x65\x78\x74")
<operator>.addition lb+1
l22 l22(l3,lh,0,&lv,"")
<operator>.cast (l40)lv
l22 l22(l4,lh,0,&lt,"")
<operator>.cast (l46)lt
<operator>.or li|ls
<operator>.addition lb+1
<operator>.indirectIndexAccess lc[lb+1][0]
<operator>.indirectIndexAccess lc[lb+1]
UNKNOWN l40 l40
UNKNOWN l46 l46
>>>PDG&188 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->20 0->22 0->23 0->24 0->26 0->28 0->29 0->30 0->33 0->35 0->37 0->39 0->41 0->42 0->43 0->45 0->46 0->47 0->49 0->50 0->51 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->68 0->69 0->70 0->71 0->73 0->74 0->75 0->76 0->77 0->78 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->91 0->93 0->95 0->97 0->98 0->99 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->114 0->115 0->116 0->117 0->120 0->121 0->122 0->125 0->126 0->127 0->128 0->129 0->130 0->131 0->133 0->135 0->136 0->137 0->140 0->141 0->142 0->144 0->145 0->146 0->147 0->148 0->150 0->151 0->153 0->154 0->155 0->156 0->158 0->159 0->160 0->161 0->162 0->163 0->164 0->165 0->166 0->167 0->168 0->169 0->170 0->171 0->172 0->173 0->174 0->175 0->176 0->177 0->178 0->179 0->180 0->181 0->182 0->183 2->7 2->136 3->7 3->8 3->136 4->1 4->1 4->16 4->98 4->106 5->1 5->1 5->23 5->126 5->127 5->130 6->1 6->1 6->95 6->175 7->1 7->1 7->1 7->114 7->115 7->121 7->136 7->136 7->142 7->160 7->162 7->163 7->165 8->1 8->1 8->136 9->1 9->1 10->1 10->1 10->11 11->1 11->1 12->1 12->1 13->1 13->1 15->1 15->1 15->110 16->1 16->106 18->1 18->1 18->86 19->1 19->1 21->1 21->1 23->1 23->126 25->1 25->1 25->134 27->1 27->1 28->1 28->1 28->1 28->1 28->1 29->1 29->1 31->1 31->1 31->1 31->37 31->107 31->110 32->1 32->1 33->1 33->1 33->39 34->1 34->1 34->35 35->1 35->110 36->1 36->1 36->111 37->1 37->1 38->1 38->1 39->1 39->1 39->46 40->1 40->1 41->1 41->1 43->1 43->1 43->1 44->1 44->1 45->1 45->1 45->49 46->50 47->1 47->1 47->1 48->1 48->1 49->1 49->1 49->1 50->55 51->1 52->1 52->1 53->1 53->1 53->128 54->1 54->1 55->1 55->1 55->1 55->91 55->97 58->1 58->1 61->1 61->1 61->95 67->1 67->1 68->1 68->1 68->28 68->71 70->1 70->1 70->1 71->1 71->28 72->1 72->1 72->13 72->13 79->1 79->1 83->1 83->1 83->1 84->33 85->1 86->19 86->19 86->144 87->1 87->21 87->21 87->146 87->164 88->1 88->1 88->1 88->151 88->178 89->1 89->1 89->1 89->154 89->180 90->1 90->1 91->1 91->1 91->1 91->93 92->1 92->1 93->1 93->1 93->1 93->97 94->1 94->1 94->172 95->1 95->1 95->172 95->182 96->1 96->1 97->68 97->68 98->1 98->1 98->27 98->27 99->28 100->1 100->28 101->1 101->29 101->72 102->72 103->1 103->1 103->23 106->31 106->98 107->32 107->110 108->33 109->34 110->1 110->1 110->36 110->36 110->36 110->36 110->36 110->37 110->178 111->1 111->38 111->38 111->182 112->39 113->1 114->86 114->86 114->115 114->115 115->40 115->40 115->121 115->162 115->163 116->41 117->43 118->1 118->43 119->1 119->1 119->44 119->44 120->45 121->1 121->87 121->87 121->148 121->164 121->165 121->165 121->166 121->167 121->173 122->47 123->1 123->47 124->1 124->1 124->48 124->48 125->49 126->52 126->127 127->53 127->130 128->1 128->54 128->54 129->55 130->1 130->55 131->1 131->67 131->67 132->68 132->100 132->159 133->70 134->1 134->70 135->1 135->98 135->98 136->1 136->1 136->72 136->72 136->72 136->72 136->72 136->88 136->89 136->95 136->100 136->101 136->101 136->101 136->101 136->101 136->118 136->123 136->132 136->134 136->142 136->157 136->158 136->159 136->172 136->174 137->1 137->79 137->79 138->1 138->1 138->175 139->1 139->1 140->1 140->1 140->55 141->1 141->111 142->113 142->113 142->114 142->114 142->143 142->160 142->160 142->160 142->177 142->177 142->183 143->1 143->1 143->113 143->113 144->87 144->119 144->119 144->145 144->163 145->119 145->119 146->1 146->124 146->124 146->147 146->165 147->1 147->124 147->124 149->1 149->1 149->90 149->90 150->91 151->1 151->91 152->1 152->1 152->92 152->92 153->93 154->1 154->93 155->1 155->1 155->94 155->94 156->1 156->96 156->96 157->97 157->158 158->1 158->131 158->131 158->132 158->159 159->1 159->100 159->135 159->135 160->114 160->143 160->143 160->161 160->183 160->184 160->185 161->25 161->143 161->143 162->121 162->163 163->121 163->121 163->145 163->145 165->1 165->147 165->147 165->148 165->166 165->167 165->173 168->1 168->149 168->149 168->169 168->170 168->179 168->186 169->1 169->149 169->149 169->155 170->1 170->1 170->152 170->152 170->171 170->181 170->187 171->1 171->152 171->152 171->155 172->1 172->1 172->156 172->156 172->156 172->157 173->1 174->1 174->110 174->138 174->138 174->138 175->95 175->139 176->140 178->1 178->151 178->155 178->168 178->168 178->168 178->168 178->168 178->169 178->179 178->180 180->1 180->1 180->154 180->155 180->170 180->170 180->170 180->170 180->170 180->171 180->181 182->1 182->158 182->172 182->172
>>>Token l0 l62 ( l0 lg , lp * * lc ) { l11 li ; lp l2 * lw = lh ; l0 l9 ; l65 lk ; l11 ls ; lp l2 * lj = lh ; l18 l48 * ll = lh ; l43 ( & lg , & lc ) ; l64 ( lc [ 0 ] ) ; l47 ( l61 , " " ) ; l36 ( l16 , l59 ) ; l70 ( l16 ) ; l57 ( l39 ) ; l68 ( ( l9 = l44 ( lg , lc , " \x6d \x3a \x5a " , l30 , lh ) ) != -1 )  { l24 ( l9 ) { lm ' ' : lw = lq ; lz ; lm ' ' : la ( l13 ( ) ) { lj = lq ; } lr la ( l50 ( ) > 0 ) { la ( lq ) lj = lq ; lr { ll = l35 ( l34 , lh , 0 ) ; la ( ! ll )  lo ( 0 , lu , ld ( " \x77 \x61 \x72 \x6e \x69 \x6e \x67 " " \x3a \x20 \x69 \x67 \x6e \x6f \x72 \x69 \x6e \x67 \x20 \x2d \x2d \x63 \x6f \x6e \x74 " " \x65 \x78 \x74 " ) ) ; } } lr la ( lq ) { lo ( 0 , 0 , ld ( " \x77 \x61 \x72 \x6e \x69 \x6e \x67 " " \x3a \x20 \x69 \x67 \x6e \x6f \x72 \x69 \x6e \x67 \x20 \x2d \x2d \x63 \x6f \x6e \x74 " " \x65 \x78 \x74 \x3b \x20 " " \x69 \x74 \x20 \x72 \x65 \x71 \x75 \x69 \x72 \x65 \x73 " " \x20 \x61 \x6e \x20 \x53 \x45 \x4c \x69 \x6e \x75 \x78 \x2f \x53 \x4d \x41 \x43 \x4b " " \x2d \x65 \x6e \x61 \x62 \x6c \x65 \x64 \x20 \x6b \x65 \x72 \x6e \x65 \x6c " ) ) ; } lz ; l69 ; l32 ( l37 , l42 ) ; l15 : l6 ( le ) ; } } li = l71 ; la ( lw ) { l11 lx ; l18 l52 * l1 = l31 ( lw ) ; la ( ! l1 )  lf ( le , 0 , ld ( " \x69 \x6e \x76 \x61 \x6c \x69 \x64 \x20 \x6d \x6f \x64 \x65 " ) ) ; lx = l28 ( 0 ) ; l28 ( lx ) ; li = l66 ( li , l55 , lx , l1 , lh ) ; l45 ( l1 ) ; la ( li & ~ l72 )  lf ( le , 0 , ld ( " \x6d \x6f \x64 \x65 \x20 \x6d \x75 \x73 \x74 \x20 \x73 \x70 \x65 \x63 \x69 \x66 " " \x79 \x20 \x6f \x6e \x6c \x79 \x20 \x66 \x69 \x6c \x65 \x20 \x70 \x65 \x72 \x6d \x69 " " \x73 \x73 \x69 \x6f \x6e \x20 \x62 \x69 \x74 \x73 " ) ) ; } lk = ( lg <= lb || ( lb + 1 < lg && lc [ lb + 1 ] [ 0 ] == ' ' ) ? 2 : 4 ) ; la ( lg - lb < lk )  { la ( lg <= lb ) lo ( 0 , 0 , ld ( " \x6d \x69 \x73 " " \x73 \x69 \x6e \x67 \x20 \x6f \x70 \x65 \x72 \x61 \x6e \x64 " ) ) ; lr lo ( 0 , 0 , ld ( " " " \x6d \x69 \x73 \x73 \x69 \x6e \x67 \x20 \x6f \x70 \x65 \x72 \x61 \x6e \x64 \x20 \x61 " " \x66 \x74 \x65 \x72 \x20 \x25 \x73 " ) , ln ( lc [ lg - 1 ] ) ) ; la ( lk == 4 && lg - lb == 2 )  l17 ( l27 , " \x25 \x73 \n " , ld ( " \x53 \x70 \x65 \x63 \x69 \x61 \x6c \x20 \x66 \x69 \x6c \x65 " " \x73 \x20 \x72 \x65 \x71 \x75 \x69 \x72 \x65 \x20 \x6d \x61 \x6a \x6f \x72 \x20 \x61 " " \x6e \x64 \x20 \x6d \x69 \x6e \x6f \x72 \x20 \x64 \x65 \x76 \x69 \x63 \x65 \x20 \x6e " " \x75 \x6d \x62 \x65 \x72 \x73 \x2e " ) ) ; l6 ( le ) ; } la ( lk < lg - lb )  { lo ( 0 , 0 , ld ( " \x65 " " \x78 \x74 \x72 \x61 \x20 \x6f \x70 \x65 \x72 \x61 \x6e \x64 \x20 \x25 \x73 " ) , ln ( lc [ lb + lk ] ) ) ; la ( lk == 2 && lg - lb == 4 )  l17 ( l27 , " \x25 \x73 \n " , ld ( " \x46 \x69 \x66 " " \x6f \x73 \x20 \x64 \x6f \x20 \x6e \x6f \x74 \x20 \x68 \x61 \x76 \x65 \x20 \x6d \x61 " " \x6a \x6f \x72 \x20 \x61 \x6e \x64 \x20 \x6d \x69 \x6e \x6f \x72 \x20 \x64 \x65 \x76 " " \x69 \x63 \x65 \x20 \x6e \x75 \x6d \x62 \x65 \x72 \x73 \x2e " ) ) ; l6 ( le ) ; } la ( lj ) { l0 l5 = 0 ; la ( l13 ( ) ) l5 = l60 ( lj ) ; lr l5 = l54 ( lj ) ; la ( l5 < 0 )  lf ( le , lu , ld ( " \x66 " " \x61 \x69 \x6c \x65 \x64 \x20 \x74 \x6f \x20 \x73 \x65 \x74 \x20 \x64 \x65 \x66 \x61 " " \x75 \x6c \x74 \x20 \x66 \x69 \x6c \x65 \x20 \x63 \x72 \x65 \x61 \x74 \x69 \x6f \x6e " " \x20 \x63 \x6f \x6e \x74 \x65 \x78 \x74 \x20 \x74 \x6f \x20 \x25 \x73 " ) , ln ( lj ) ) ; } l24 ( lc [ lb + 1 ] [ 0 ] ) { lm ' ' : l25 l14  lf < l10 ' ' > ( le , 0 , ld ( " \x62 \x6c \x6f \x63 " " \x6b \x20 \x73 \x70 \x65 \x63 \x69 \x61 \x6c \x20 \x66 \x69 \x6c \x65 \x73 \x20 \x6e " " \x6f \x74 \x20 \x73 \x75 \x70 \x70 \x6f \x72 \x74 \x65 \x64 " ) ) ; l19 ls = l14 ; l7 l23l8 ; lm  ' ' : lm ' ' : l25 l21  lf < l10 ' ' > ( le , 0 , ld ( " \x63 \x68 \x61 \x72 \x61 \x63 " " \x74 \x65 \x72 \x20 \x73 \x70 \x65 \x63 \x69 \x61 \x6c \x20 \x66 \x69 \x6c \x65 \x73 " " \x20 \x6e \x6f \x74 \x20 \x73 \x75 \x70 \x70 \x6f \x72 \x74 \x65 \x64 " ) ) ; l19 ls = l21 ; l7 l23 l8 ; l8 : { lp l2 * l3 = lc [ lb + 2 ] ; lp l2 * l4 = lc [ lb + 3 ] ; l38 lv , lt ; l53 ly ; la ( l22 ( l3 , lh , 0 , & lv , " " ) != l20 || lv != ( l40 ) lv )  lf ( le , 0 , ld ( " \x69 \x6e \x76 " " \x61 \x6c \x69 \x64 \x20 \x6d \x61 \x6a \x6f \x72 \x20 \x64 \x65 \x76 \x69 \x63 \x65 " " \x20 \x6e \x75 \x6d \x62 \x65 \x72 \x20 \x25 \x73 " ) , ln ( l3 ) ) ; la ( l22 ( l4 , lh , 0 , & lt , " " ) != l20 || lt != ( l46 ) lt )  lf ( le , 0 , ld ( " \x69 \x6e \x76 \x61 \x6c \x69 \x64 \x20 " " \x6d \x69 \x6e \x6f \x72 \x20 \x64 \x65 \x76 \x69 \x63 \x65 \x20 \x6e \x75 \x6d \x62 " " \x65 \x72 \x20 \x25 \x73 " ) , ln ( l4 ) ) ; ly = l51 ( lv , lt ) ; l73 l12  la ( ly == < l10 ' ' > l12 )  lf ( le , 0 , ld ( " \x69 \x6e \x76 \x61 \x6c \x69 \x64 \x20 \x64 \x65 \x76 \x69 \x63 " " \x65 \x20 \x25 \x73 \x20 \x25 \x73 " ) , l3 , l4 ) ; l7 la ( ll ) l29 ( ll , lc [ lb ] , ls ) ; la ( l49 ( lc [ lb ] , li | ls , ly ) != 0 )  lf ( le , lu , " \x25 \x73 " , l26 ( lc [ lb ] ) ) ; } lz ; lm  ' ' : la ( ll ) l29 ( ll , lc [ lb ] , l67 ) ; la ( l41 ( lc [ lb ] , li ) != 0 )  lf ( le , lu , " \x25 \x73 " , l26 ( lc [ lb ] ) ) ; lz ; l15 : lo ( 0 , 0 , ld ( " \x69 \x6e \x76 \x61 \x6c \x69 \x64 \x20 \x64 \x65 " " \x76 \x69 \x63 \x65 \x20 \x74 \x79 \x70 \x65 \x20 \x25 \x73 " ) , ln ( lc [ lb + 1 ] ) ) ; l6 ( le ) ; } la ( lw && l33 ( lc [ lb ] , li ) != 0 )  lf ( le , lu , ld ( " \x63 \x61 \x6e \x6e \x6f \x74 " " \x20 \x73 \x65 \x74 \x20 \x70 \x65 \x72 \x6d \x69 \x73 \x73 \x69 \x6f \x6e \x73 \x20 " " \x6f \x66 \x20 \x25 \x73 " ) , l58 ( lc [ lb ] ) ) ; l63 l56 ; }
>>>Func
METHOD lt
METHOD_RETURN ld
PARAM ld lm
PARAM ls* *li
lx lx(lm<3)
BLOCK <empty> <empty>
<operator>.assignment la=lo(li[1],"\x72")
<operator>.assignment lf=lo(li[2],"\x77")
lk lk(la,"\x20\x25\x64",&lg)
<operator>.lessThan lc<lg
<operator>.postIncrement lc++
ln ln(la)
ln ln(lf)
IDENTIFIER lu <empty>
LITERAL 0 <empty>
lq lq(lv,"\x57\x72""\x6f\x6e\x67\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x61\x72\x67""\x75\x6d\x65\x6e\x74\x73\x21\n")
lw lw(1)
<operator>.lessThan lm<3
lo lo(li[1],"\x72")
lo lo(li[2],"\x77")
>>>PDG&20 0->2 0->3 0->5 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 2->17 3->1 3->18 3->19 4->1 4->1 6->1 6->1 6->8 7->1 7->1 7->12 8->1 8->1 8->9 8->11 9->1 9->1 9->10 10->1 10->1 11->1 11->1 12->1 12->1 15->1 15->1 16->1 17->1 17->4 17->4 18->1 18->6 18->6 19->1 19->7 19->7
>>>Token ld lt ( ld lm , ls * * li ) { ld lc , lb , lg ; lr * la , * lf ; lx ( lm < 3 )  { lq ( lv , " \x57 \x72 " " \x6f \x6e \x67 \x20 \x6e \x75 \x6d \x62 \x65 \x72 \x20 \x6f \x66 \x20 \x61 \x72 \x67 " " \x75 \x6d \x65 \x6e \x74 \x73 \x21 \n " ) ; lw ( 1 ) ; } la = lo ( li [ 1 ] , " \x72 " ) ; lf = lo ( li [ 2 ] , " \x77 " ) ; lk ( la , " \x20 \x25 \x64 " , & lg ) ; lp ( lc = 0  ; lc < lg ; lc ++ ) { ld lh , ll , le ; ld lj [ 1001 ] ; lk ( la , " \x20 \x25 \x64 \x20 \x25 \x64 \x20 \x25 \x64 " , & lh , & ll , & le ) ; lp ( lb = 0  ; lb < le ; lb ++ ) { lk ( la , " \x20 \x25 \x64 " , & lj [ lb ] ) ; } lq ( lf , " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x6c \x6c \x64 \n " , lc + 1 , ly ( lh , ll , le , lj ) ) ; } ln ( la ) ; ln ( lf ) ; lu 0 ; }
>>>Func
METHOD lg
METHOD_RETURN ld
IDENTIFIER lf <empty>
IDENTIFIER le <empty>
BLOCK <empty> <empty>
<operator>.lessThan le<la
>>>PDG&6 0->2 0->3 0->4 0->5 5->1 5->1 5->1
>>>Token li lh  ld lg ( ) { lf le { ld lc [ 256 ] ; le < la ' ' > < la ' ' > < la ' ' > (  ) < la ' ; ' { lj ( ldlb = ' '  ; lb <= ' ' ; ++ lb ) lc [ lb ] = 1 ; lc [ ' ' ] = 1 ; } }
>>>Func
METHOD l15
METHOD_RETURN lk
PARAM lk ln
PARAM lu* *lb
<operator>.assignment *ll=lh
<operator>.assignment ls=l27
<operator>.assignment *lf=lh
<operator>.assignment *li=lh
l45 l45(&ln,&lb)
l13 l13(lb[0])
l28 l28(l25,"")
l19 l19(l0,l35)
l12 l12(l0)
l33 l33(l42)
l9 l9((lv=l40(ln,lb,"\x6d\x3a\x5a",l24,lh))!=-1)
BLOCK <empty> <empty>
la la(lc==ln)
BLOCK <empty> <empty>
la la(lf)
BLOCK <empty> <empty>
<operator>.assignment lg=l20
la la(ll)
BLOCK <empty> <empty>
<operator>.lessThan lc<ln
<operator>.preIncrement ++lc
l43 l43(lv)
BLOCK <empty> <empty>
lm lm(0 0 ld("\x6d\x69\x73\x73\x69\x6e\x67""\x20\x6f\x70\x65\x72\x61\x6e\x64"))
lz lz(le)
<operator>.assignment lp=0
<operator>.assignment lp=l14(lf)
<operator>.assignment lp=l34(lf)
la la(lp<0)
lw lw(le lt ld("\x66\x61\x69\x6c\x65\x64""\x20\x74\x6f\x20\x73\x65\x74\x20\x64\x65\x66\x61\x75\x6c\x74\x20\x66""\x69\x6c\x65\x20\x63\x72\x65\x61\x74\x69\x6f\x6e\x20\x63\x6f\x6e\x74""\x65\x78\x74\x20\x74\x6f\x20\x25\x73") l41(lf))
<operator>.assignment *lr=l26(ll)
la la(!lr)
lw lw(le 0 ld("\x69\x6e\x76\x61\x6c\x69\x64""\x20\x6d\x6f\x64\x65"))
<operator>.assignment lq=l4(0)
l4 l4(lq)
<operator>.assignment lg=l17(lg,l44,lq,lr,lh)
l7 l7(lr)
la la(lg&~l46)
lw lw(le 0 ld("\x6d\x6f\x64\x65\x20\x6d\x75\x73\x74\x20""\x73\x70\x65\x63\x69\x66\x79\x20\x6f\x6e\x6c\x79\x20\x66\x69\x6c\x65""\x20\x70\x65\x72\x6d\x69\x73\x73\x69\x6f\x6e\x20\x62\x69\x74\x73"))
<operator>.notEquals (lv=l40(ln,lb,"\x6d\x3a\x5a",l24,lh))!=-1
IDENTIFIER ly <empty>
LITERAL 'm' <empty>
IDENTIFIER l3 <empty>
IDENTIFIER ly <empty>
LITERAL 'Z' <empty>
IDENTIFIER lo <empty>
la la(l32()>0)
BLOCK <empty> <empty>
IDENTIFIER l3 <empty>
IDENTIFIER l22 <empty>
l16 l16(l39,l29)
lz lz(le)
<operator>.equals lc==ln
<operator>.assignment lv=l40(ln,lb,"\x6d\x3a\x5a",l24,lh)
<operator>.minus -1
<operator>.assignment lf=lj
IDENTIFIER lo <empty>
BLOCK <empty> <empty>
ld ld("\x6d\x69\x73\x73\x69\x6e\x67""\x20\x6f\x70\x65\x72\x61\x6e\x64")
l14 l14(lf)
l34 l34(lf)
<operator>.lessThan lp<0
ld ld("\x66\x61\x69\x6c\x65\x64""\x20\x74\x6f\x20\x73\x65\x74\x20\x64\x65\x66\x61\x75\x6c\x74\x20\x66""\x69\x6c\x65\x20\x63\x72\x65\x61\x74\x69\x6f\x6e\x20\x63\x6f\x6e\x74""\x65\x78\x74\x20\x74\x6f\x20\x25\x73")
l41 l41(lf)
l26 l26(ll)
<operator>.logicalNot !lr
ld ld("\x69\x6e\x76\x61\x6c\x69\x64""\x20\x6d\x6f\x64\x65")
l4 l4(0)
l17 l17(lg,l44,lq,lr,lh)
<operator>.and lg&~l46
ld ld("\x6d\x6f\x64\x65\x20\x6d\x75\x73\x74\x20""\x73\x70\x65\x63\x69\x66\x79\x20\x6f\x6e\x6c\x79\x20\x66\x69\x6c\x65""\x20\x70\x65\x72\x6d\x69\x73\x73\x69\x6f\x6e\x20\x62\x69\x74\x73")
l40 l40(ln,lb,"\x6d\x3a\x5a",l24,lh)
<operator>.greaterThan l32()>0
<operator>.assignment li=l36(l31,lh,0)
la la(!li)
lm lm(0 lt ld("\x77\x61\x72\x6e\x69\x6e\x67\x3a\x20\x69""\x67\x6e\x6f\x72\x69\x6e\x67\x20\x2d\x2d\x63\x6f\x6e\x74\x65\x78\x74"))
<operator>.not ~l46
l36 l36(l31,lh,0)
<operator>.logicalNot !li
ld ld("\x77\x61\x72\x6e\x69\x6e\x67\x3a\x20\x69""\x67\x6e\x6f\x72\x69\x6e\x67\x20\x2d\x2d\x63\x6f\x6e\x74\x65\x78\x74")
>>>PDG&84 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->33 0->36 0->38 0->40 0->42 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->56 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->79 0->80 0->81 0->82 0->83 2->8 2->75 3->8 3->9 3->75 4->1 4->1 4->21 4->68 5->1 5->1 5->1 6->1 6->1 6->18 6->63 6->64 6->67 7->1 7->1 7->82 8->1 8->1 8->1 8->23 8->56 8->75 8->75 9->1 9->1 9->75 10->1 10->1 11->1 11->1 11->12 12->1 12->1 13->1 13->1 14->1 14->1 16->1 16->1 18->1 18->63 20->1 20->1 20->72 21->1 21->68 23->1 23->1 23->24 24->1 24->1 25->1 25->1 27->1 27->1 28->1 28->33 29->1 30->1 30->1 31->1 31->1 31->65 32->1 32->1 33->1 33->1 33->1 33->1 33->36 34->1 34->1 34->1 34->40 34->69 34->72 35->1 35->1 36->1 36->1 36->42 37->1 37->1 37->38 38->1 38->72 39->1 39->1 39->73 40->1 40->1 41->1 41->1 42->1 42->1 42->1 43->1 43->1 43->14 43->14 50->1 50->1 54->1 54->1 54->1 55->28 56->16 56->16 56->23 56->23 57->1 57->25 57->43 58->43 59->1 59->1 59->18 62->27 63->30 63->64 64->31 64->67 65->1 65->32 65->32 66->33 67->1 67->33 68->1 68->34 69->35 69->72 70->36 71->37 72->1 72->1 72->1 72->39 72->39 72->39 72->39 72->39 72->40 73->1 73->1 73->41 73->41 74->42 75->1 75->1 75->43 75->43 75->43 75->43 75->43 75->56 75->57 75->57 75->57 75->57 75->57 75->81 76->1 76->50 76->50 77->1 77->1 77->82 78->1 78->1 79->1 79->1 79->33 80->1 80->73 81->1 81->72 81->77 81->77 81->77 82->1 82->78 83->79
>>>Token lk l15 ( lk ln , lu * * lb ) { l5 lg ; lu l2 * ll = lh ; lk ls = l27 ; lk lv ; lu l2 * lf = lh ; l6 l38 * li = lh ; l45 ( & ln , & lb ) ; l13 ( lb [ 0 ] ) ; l28 ( l25 , " " ) ; l19 ( l0 , l35 ) ; l12 ( l0 ) ; l33 ( l42 ) ; l9 ( ( lv = l40 ( ln , lb , " \x6d \x3a \x5a " , l24 , lh ) ) != -1 )  { l43 ( lv ) { ly ' ' : ll = lj ; l3 ; ly ' ' : la ( l1 ( ) ) { lf = lj ; } lo la ( l32 ( ) > 0 ) { la ( lj ) lf = lj ; lo { li = l36 ( l31 , lh , 0 ) ; la ( ! li )  lm ( 0 , lt , ld ( " \x77 \x61 \x72 \x6e \x69 \x6e \x67 \x3a \x20 \x69 " " \x67 \x6e \x6f \x72 \x69 \x6e \x67 \x20 \x2d \x2d \x63 \x6f \x6e \x74 \x65 \x78 \x74 " ) ) ; } } lo la ( lj ) { lm ( 0 , 0 , ld ( " \x77 \x61 \x72 \x6e \x69 \x6e \x67 \x3a \x20 \x69 " " \x67 \x6e \x6f \x72 \x69 \x6e \x67 \x20 \x2d \x2d \x63 \x6f \x6e \x74 \x65 \x78 \x74 " " \x3b \x20 " " \x69 \x74 \x20 \x72 \x65 \x71 \x75 \x69 \x72 \x65 \x73 \x20 \x61 \x6e " " \x20 \x53 \x45 \x4c \x69 \x6e \x75 \x78 \x2f \x53 \x4d \x41 \x43 \x4b \x2d \x65 \x6e " " \x61 \x62 \x6c \x65 \x64 \x20 \x6b \x65 \x72 \x6e \x65 \x6c " ) ) ; } l3 ; l22 ; l16 ( l39 , l29 ) ; l23 : lz ( le ) ; } } la ( lc == ln )  { lm ( 0 , 0 , ld ( " \x6d \x69 \x73 \x73 \x69 \x6e \x67 " " \x20 \x6f \x70 \x65 \x72 \x61 \x6e \x64 " ) ) ; lz ( le ) ; } la ( lf ) { lk lp = 0 ; la ( l1 ( ) ) lp = l14 ( lf ) ; lo lp = l34 ( lf ) ; la ( lp < 0 )  lw ( le , lt , ld ( " \x66 \x61 \x69 \x6c \x65 \x64 " " \x20 \x74 \x6f \x20 \x73 \x65 \x74 \x20 \x64 \x65 \x66 \x61 \x75 \x6c \x74 \x20 \x66 " " \x69 \x6c \x65 \x20 \x63 \x72 \x65 \x61 \x74 \x69 \x6f \x6e \x20 \x63 \x6f \x6e \x74 " " \x65 \x78 \x74 \x20 \x74 \x6f \x20 \x25 \x73 " ) , l41 ( lf ) ) ; } lg = l20 ; la ( ll ) { l5 lq ; l6 l10 * lr = l26 ( ll ) ; la ( ! lr )  lw ( le , 0 , ld ( " \x69 \x6e \x76 \x61 \x6c \x69 \x64 " " \x20 \x6d \x6f \x64 \x65 " ) ) ; lq = l4 ( 0 ) ; l4 ( lq ) ; lg = l17 ( lg , l44 , lq , lr , lh ) ; l7 ( lr ) ; la ( lg & ~ l46 )  lw ( le , 0 , ld ( " \x6d \x6f \x64 \x65 \x20 \x6d \x75 \x73 \x74 \x20 " " \x73 \x70 \x65 \x63 \x69 \x66 \x79 \x20 \x6f \x6e \x6c \x79 \x20 \x66 \x69 \x6c \x65 " " \x20 \x70 \x65 \x72 \x6d \x69 \x73 \x73 \x69 \x6f \x6e \x20 \x62 \x69 \x74 \x73 " ) ) ; } l11 ( ; lc < ln ; ++ lc ) { la ( li ) l21 ( li , lb [ lc ] , l18 ) ; la ( l8 ( lb [ lc ] , lg ) != 0 )  { lm ( 0 , lt , ld ( " \x63 \x61 \x6e \x6e \x6f \x74 \x20 \x63 \x72 \x65 \x61 \x74 \x65 \x20 \x66 " " \x69 \x66 \x6f \x20 \x25 \x73 " ) , lx ( lb [ lc ] ) ) ; ls = le ; } lo la ( ll && l30 ( lb [ lc ] , lg ) != 0 ) { lm ( 0 , lt , ld ( " \x63 \x61 \x6e \x6e \x6f \x74 \x20 \x73 \x65 \x74 \x20 \x70 " " \x65 \x72 \x6d \x69 \x73 \x73 \x69 \x6f \x6e \x73 \x20 \x6f \x66 \x20 \x25 \x73 " ) , lx ( lb [ lc ] ) ) ; ls = le ; } } l37 ls ; }
>>>Func
METHOD lj
METHOD_RETURN lg
PARAM ln ld
lm lm(ld!=ls)
lk lk()
IDENTIFIER lq <empty>
BLOCK <empty> <empty>
li li(ld)
lf lf(lc("\x55\x73\x61\x67\x65\x3a\x20""\x25\x73\x20\x5b\x4f\x50\x54\x49\x4f\x4e\x5d\x2e\x2e\x2e\x20\x4e\x41""\x4d\x45\x2e\x2e\x2e\n"),ll)
la la(lc("\xa\x43\x72\x65\x61\x74\x65\x20""\x6e\x61\x6d\x65\x64\x20\x70\x69\x70\x65\x73\x20\x28\x46\x49\x46\x4f""\x73\x29\x20\x77\x69\x74\x68\x20\x74\x68\x65\x20\x67\x69\x76\x65\x6e""\x20\x4e\x41\x4d\x45\x73\x2e\n\xa"),lb)
lo lo()
la la(lc("\xa\x20\x20""\x2d\x6d\x2c\x20\x2d\x2d\x6d\x6f\x64\x65\x3d\x4d\x4f\x44\x45\x20\x20""\x20\x20\x73\x65\x74\x20\x66\x69\x6c\x65\x20\x70\x65\x72\x6d\x69\x73""\x73\x69\x6f\x6e\x20\x62\x69\x74\x73\x20\x74\x6f\x20\x4d\x4f\x44\x45""\x2c\x20\x6e\x6f\x74\x20\x61\x3d\x72\x77\x20\x2d\x20\x75\x6d\x61\x73""\x6b\n\xa"),lb)
la la(lc("\xa\x20\x20\x2d\x5a\x20\x20\x20\x20\x20\x20""\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x73\x65\x74\x20""\x74\x68\x65\x20\x53\x45\x4c\x69\x6e\x75\x78\x20\x73\x65\x63\x75\x72""\x69\x74\x79\x20\x63\x6f\x6e\x74\x65\x78\x74\x20\x74\x6f\x20\x64\x65""\x66\x61\x75\x6c\x74\x20\x74\x79\x70\x65\n\xa\x20\x20\x20\x20\x20""\x20\x2d\x2d\x63\x6f\x6e\x74\x65\x78\x74\x5b\x3d\x43\x54\x58\x5d\x20""\x20\x6c\x69\x6b\x65\x20\x2d\x5a\x2c\x20\x6f\x72\x20\x69\x66\x20\x43""\x54\x58\x20\x69\x73\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64\x20\x74""\x68\x65\x6e\x20\x73\x65\x74\x20\x74\x68\x65\x20\x53\x45\x4c\x69\x6e""\x75\x78\n\xa\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20""\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x6f\x72\x20\x53\x4d""\x41\x43\x4b\x20\x73\x65\x63\x75\x72\x69\x74\x79\x20\x63\x6f\x6e\x74""\x65\x78\x74\x20\x74\x6f\x20\x43\x54\x58\n\xa"),lb)
la la(lh,lb)
la la(lr,lb)
le le(lp)
<operator>.notEquals ld!=ls
lc lc("\x55\x73\x61\x67\x65\x3a\x20""\x25\x73\x20\x5b\x4f\x50\x54\x49\x4f\x4e\x5d\x2e\x2e\x2e\x20\x4e\x41""\x4d\x45\x2e\x2e\x2e\n")
lc lc("\xa\x43\x72\x65\x61\x74\x65\x20""\x6e\x61\x6d\x65\x64\x20\x70\x69\x70\x65\x73\x20\x28\x46\x49\x46\x4f""\x73\x29\x20\x77\x69\x74\x68\x20\x74\x68\x65\x20\x67\x69\x76\x65\x6e""\x20\x4e\x41\x4d\x45\x73\x2e\n\xa")
lc lc("\xa\x20\x20""\x2d\x6d\x2c\x20\x2d\x2d\x6d\x6f\x64\x65\x3d\x4d\x4f\x44\x45\x20\x20""\x20\x20\x73\x65\x74\x20\x66\x69\x6c\x65\x20\x70\x65\x72\x6d\x69\x73""\x73\x69\x6f\x6e\x20\x62\x69\x74\x73\x20\x74\x6f\x20\x4d\x4f\x44\x45""\x2c\x20\x6e\x6f\x74\x20\x61\x3d\x72\x77\x20\x2d\x20\x75\x6d\x61\x73""\x6b\n\xa")
lc lc("\xa\x20\x20\x2d\x5a\x20\x20\x20\x20\x20\x20""\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x73\x65\x74\x20""\x74\x68\x65\x20\x53\x45\x4c\x69\x6e\x75\x78\x20\x73\x65\x63\x75\x72""\x69\x74\x79\x20\x63\x6f\x6e\x74\x65\x78\x74\x20\x74\x6f\x20\x64\x65""\x66\x61\x75\x6c\x74\x20\x74\x79\x70\x65\n\xa\x20\x20\x20\x20\x20""\x20\x2d\x2d\x63\x6f\x6e\x74\x65\x78\x74\x5b\x3d\x43\x54\x58\x5d\x20""\x20\x6c\x69\x6b\x65\x20\x2d\x5a\x2c\x20\x6f\x72\x20\x69\x66\x20\x43""\x54\x58\x20\x69\x73\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64\x20\x74""\x68\x65\x6e\x20\x73\x65\x74\x20\x74\x68\x65\x20\x53\x45\x4c\x69\x6e""\x75\x78\n\xa\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20""\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x6f\x72\x20\x53\x4d""\x41\x43\x4b\x20\x73\x65\x63\x75\x72\x69\x74\x79\x20\x63\x6f\x6e\x74""\x65\x78\x74\x20\x74\x6f\x20\x43\x54\x58\n\xa")
>>>PDG&21 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 2->16 3->1 3->1 4->1 7->1 7->1 8->1 8->1 8->1 9->1 9->1 9->11 10->1 11->1 11->1 11->12 12->1 12->1 12->13 13->1 13->1 13->14 14->1 14->1 14->1 15->1 15->1 16->1 16->3 16->3 16->7 17->8 18->9 19->11 20->12
>>>Token lg lj ( ln ld ) { lm ( ld != ls ) lk ( ) ; lq { lf ( lc ( " \x55 \x73 \x61 \x67 \x65 \x3a \x20 " " \x25 \x73 \x20 \x5b \x4f \x50 \x54 \x49 \x4f \x4e \x5d \x2e \x2e \x2e \x20 \x4e \x41 " " \x4d \x45 \x2e \x2e \x2e \n " ) , ll ) ; la ( lc ( " x a x 43 x 72 x 65 x 61 x 74 x 65 x 20 " " \x6e \x61 \x6d \x65 \x64 \x20 \x70 \x69 \x70 \x65 \x73 \x20 \x28 \x46 \x49 \x46 \x4f " " \x73 \x29 \x20 \x77 \x69 \x74 \x68 \x20 \x74 \x68 \x65 \x20 \x67 \x69 \x76 \x65 \x6e " " \x20 \x4e \x41 \x4d \x45 \x73 \x2e \n x a " ) , lb ) ; lo ( ) ; la ( lc ( " x a x 20 x 20 " " \x2d \x6d \x2c \x20 \x2d \x2d \x6d \x6f \x64 \x65 \x3d \x4d \x4f \x44 \x45 \x20 \x20 " " \x20 \x20 \x73 \x65 \x74 \x20 \x66 \x69 \x6c \x65 \x20 \x70 \x65 \x72 \x6d \x69 \x73 " " \x73 \x69 \x6f \x6e \x20 \x62 \x69 \x74 \x73 \x20 \x74 \x6f \x20 \x4d \x4f \x44 \x45 " " \x2c \x20 \x6e \x6f \x74 \x20 \x61 \x3d \x72 \x77 \x20 \x2d \x20 \x75 \x6d \x61 \x73 " " \x6b \n x a " ) , lb ) ; la ( lc ( " x a x 20 x 20 x 2 d x 5 a x 20 x 20 x 20 x 20 x 20 x 20 " " \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x73 \x65 \x74 \x20 " " \x74 \x68 \x65 \x20 \x53 \x45 \x4c \x69 \x6e \x75 \x78 \x20 \x73 \x65 \x63 \x75 \x72 " " \x69 \x74 \x79 \x20 \x63 \x6f \x6e \x74 \x65 \x78 \x74 \x20 \x74 \x6f \x20 \x64 \x65 " " \x66 \x61 \x75 \x6c \x74 \x20 \x74 \x79 \x70 \x65 \n x a x 20 x 20 x 20 x 20 x 20 " " \x20 \x2d \x2d \x63 \x6f \x6e \x74 \x65 \x78 \x74 \x5b \x3d \x43 \x54 \x58 \x5d \x20 " " \x20 \x6c \x69 \x6b \x65 \x20 \x2d \x5a \x2c \x20 \x6f \x72 \x20 \x69 \x66 \x20 \x43 " " \x54 \x58 \x20 \x69 \x73 \x20 \x73 \x70 \x65 \x63 \x69 \x66 \x69 \x65 \x64 \x20 \x74 " " \x68 \x65 \x6e \x20 \x73 \x65 \x74 \x20 \x74 \x68 \x65 \x20 \x53 \x45 \x4c \x69 \x6e " " \x75 \x78 \n x a x 20 x 20 x 20 x 20 x 20 x 20 x 20 x 20 x 20 x 20 x 20 x 20 x 20 " " \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x20 \x6f \x72 \x20 \x53 \x4d " " \x41 \x43 \x4b \x20 \x73 \x65 \x63 \x75 \x72 \x69 \x74 \x79 \x20 \x63 \x6f \x6e \x74 " " \x65 \x78 \x74 \x20 \x74 \x6f \x20 \x43 \x54 \x58 \n x a " ) , lb ) ; la ( lh , lb ) ; la ( lr , lb ) ; le ( lp ) ; } li ( ld ) ; }
>>>Func
METHOD lk
METHOD_RETURN lj
PARAM lc lf
PARAM lc*lh
<operator>.assignment ld=ll[lm]
lg lg(li==0)
BLOCK <empty> <empty>
<operator>.lessThan la<li
<operator>.postIncrement la++
IDENTIFIER le <empty>
LITERAL 0 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals li==0
>>>PDG&14 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->1 3->1 4->1 4->1 4->1 5->1 5->1 7->1 7->1 7->8 8->1 8->1 13->5 13->5 13->7
>>>Token lj lk ( lc lf , lc * lh ) { lj la ; lc ld = ll [ lm ] ; lg ( li == 0 )  { le 0 ; } ln ( la = 0  ; la < li ; la ++ ) { lg ( ( lb [ la ] [ 0 ] == lf && lb [ la ] [ 1 ] == ld ) || ( lb [ la ] [ 1 ] == lf && lb [ la ] [ 0 ] == ld ) ) { * lh = lb [ la ] [ 2 ] ; le 1 ; } } le 0 ; }
>>>Func
METHOD lj
METHOD_RETURN lk
<operator>.assignment ld=0
lc lc(lb<1)
IDENTIFIER ll <empty>
<operator>.lessThan la<26
<operator>.preIncrement ++la
lc lc(ld==1)
BLOCK <empty> <empty>
<operator>.lessThan la<26
<operator>.preIncrement ++la
<operator>.assignment lb=-1
<operator>.lessThan lb<1
<operator>.equals ld==1
<operator>.minus -1
>>>PDG&15 0->2 0->4 0->5 0->6 0->8 0->9 0->10 0->12 0->13 0->14 2->1 2->13 3->1 3->1 5->6 6->9 7->1 7->1 9->1 9->10 10->1 10->1 11->1 11->1 11->1 12->3 12->3 13->1 13->7 13->7 14->11
>>>Token lk lj ( ) { li la , ld = 0 ; lc ( lb < 1 ) ll ; lh ( la = 0  ; la < 26 ; ++ la ) lc ( lm [ le [ lb ] - ' ' ] [ la ] == 1 ) { lc ( le [ lb ] - ' ' == la && lf [ la ] > 1 ) { ld = 1 ; lg ; } lc ( le [ lb ] - ' ' != la && lf [ la ] > 0 )  { ld = 1 ; lg ; } } lc ( ld == 1 ) { lh ( la = 0 ; la < 26 ; ++ la ) lf [ la ] = 0 ; lb = -1 ; } }
>>>Func
METHOD l9
METHOD_RETURN lm
<operator>.assignment lx=0
<operator>.assignment lo=0
<operator>.assignment lc=0
<operator>.assignment lp=0
<operator>.assignment lb=0
<operator>.assignment l13=0
<operator>.assignment l0=0
<operator>.assignment lz=0
<operator>.assignment lw=0
<operator>.expressionList lmlh=0 lg=0 lq=0
<operator>.assignment ld[26]={0 }
<operator>.assignment la=l3("\x53\x6f\x6c\x33\x2e""\x69\x6e","\x72")
lj lj(la==l4)
BLOCK <empty> <empty>
<operator>.assignment lk=l3("\x53\x6f\x6c\x33\x2e""\x6f\x75\x74","\x77")
lj lj(lk==l4)
BLOCK <empty> <empty>
ls ls(la,"\x25""\x64",&lx)
<operator>.lessThan lo<lx
<operator>.postIncrement lo++
l2 l2(la)
l2 l2(lk)
IDENTIFIER lv <empty>
LITERAL 0 <empty>
l1 l1("\x46\x69\x6c\x65\x20\x4e\x6f\x74""\x20\x46\x6f\x75\x6e\x64")
l6 l6()
IDENTIFIER lv <empty>
LITERAL 0 <empty>
l1 l1("\x43\x61\x6e\x27\x74\x20\x43""\x72\x65\x61\x74\x65\x20\x46\x69\x6c\x65")
l6 l6()
IDENTIFIER lv <empty>
LITERAL 0 <empty>
<operator>.assignment lmlh=0
<operator>.assignment lg=0
<operator>.assignment lq=0
<operator>.arrayInitializer {0 }
l3 l3("\x53\x6f\x6c\x33\x2e""\x69\x6e","\x72")
<operator>.equals la==l4
l3 l3("\x53\x6f\x6c\x33\x2e""\x6f\x75\x74","\x77")
<operator>.equals lk==l4
>>>PDG&42 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->15 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 2->1 2->19 2->20 3->1 3->20 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 9->1 9->1 10->1 10->1 11->1 11->1 11->1 11->1 12->1 12->1 12->1 13->1 13->1 13->39 14->1 14->1 16->1 16->1 16->41 17->1 17->1 19->1 19->1 19->20 19->22 20->1 20->1 20->21 21->1 21->1 22->1 22->1 23->1 23->1 26->1 30->1 31->1 34->1 34->11 35->1 35->11 36->1 36->11 37->12 38->13 38->13 39->14 39->14 39->19 39->41 40->16 40->16 41->1 41->17 41->17 41->23
>>>Token lm l9 ( ) { lm lx = 0 , lo = 0 , lc = 0 , lp = 0 ; lm lb = 0 ; lm l13 = 0 ; lm l0 = 0 , lz = 0 , lw = 0 ; lmlh = 0 , lg = 0 , lq = 0 ; l8 le [ 100 ] ; l5 ld [ 26 ] = { 0 , } ; la = l3 ( " \x53 \x6f \x6c \x33 \x2e " " \x69 \x6e " , " \x72 " ) ; lj ( la == l4 )  { l1 ( " \x46 \x69 \x6c \x65 \x20 \x4e \x6f \x74 " " \x20 \x46 \x6f \x75 \x6e \x64 " ) ; l6 ( ) ; lv 0 ; } lk = l3 ( " \x53 \x6f \x6c \x33 \x2e " " \x6f \x75 \x74 " , " \x77 " ) ; lj ( lk == l4 )  { l1 ( " \x43 \x61 \x6e \x27 \x74 \x20 \x43 " " \x72 \x65 \x61 \x74 \x65 \x20 \x46 \x69 \x6c \x65 " ) ; l6 ( ) ; lv 0 ; } ls ( la , " \x25 " " \x64 " , & lx ) ; ll ( lo = 0  ; lo < lx ; lo ++ ) { l11 ( ld , 0 , 26 * ( l12 ( l5 ) ) ) ; ls ( la , " \x25 " " \x64 " , & l0 ) ; lf ( la ) ; ll ( lc = 0  ; lc < l0 ; lc ++ ) { lh = lf ( la ) - 65 ; lg = lf ( la ) - 65 ; lq = lf ( la ) - 65 ; lf ( la ) ; ld [ lh ] . ln = 1 ; ld [ lg ] . ln = 1 ; ld [ lh ] . li [ lg ] . lu = 1 ; ld [ lh ] . li [ lg ] . ly = lq ; ld [ lg ] . li [ lh ] . lu = 1 ; ld [ lg ] . li [ lh ] . ly = lq ; } ls ( la , " \x25 \x64 " , & lz ) ; lf ( la ) ; ll ( lc = 0  ; lc < lz ; lc ++ ) { lh = lf ( la ) - 65 ; lg = lf ( la ) - 65 ; lf ( la ) ; ld [ lh ] . ln = 1 ; ld [ lg ] . ln = 1 ; ld [ lh ] . li [ lg ] . lt = 1 ; ld [ lg ] . li [ lh ] . lt = 1 ; } ls ( la , " \x25 " " \x64 " , & lw ) ; lf ( la ) ; lb = 0 ; ll ( lc = 0  ; lc < lw ; lc ++ ) { le [ lb ] = lf ( la ) - 65 ; lj ( lb != 0 )  { lj ( 1 == ld [ le [ lb ] ] . li [ le [ lb - 1 ] ] . lu )  { le [ lb - 1 ] = ld [ le [ lb ] ] . li [ le [ lb - 1 ] ] . ly ; lb -- ; } l7  { lj ( 1 == ld [ le [ lb ] ] . ln )  { ll ( lp = 0  ; lp <= lb - 1 ; lp ++ ) { lj ( 1 == ld [ le [ lb ] ] . li [ le [ lp ] ] . lt )  { lb = -1 ; l10 ; } } } } } lb ++ ; } lr ( lk , " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x64 \x3a \x20 \x5b " , lo + 1 ) ; ll ( lc = 0  ; lc < lb ; lc ++ ) { lj ( lc == lb - 1 )  { lr ( lk , " \x25 \x63 " , le [ lc ] + 65 ) ; } l7  { lr ( lk , " \x25 \x63 \x2c \x20 " , le [ lc ] + 65 ) ; } } lr ( lk , " \x5d \n " ) ; } l2 ( la ) ; l2 ( lk ) ; lv 0 ; }
>>>Func
METHOD ly
METHOD_RETURN lg
lu lu("\x25\x64",&lr)
<operator>.lessThan lj<lr
<operator>.postIncrement lj++
IDENTIFIER lz <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lg ly ( ) { lg lr ; lu ( " \x25 \x64 " , & lr ) ; lg lj ; lh ( lj = 0  ; lj < lr ; lj ++ ) { lu ( " \x25 " " \x64 \x20 \x25 \x6c \x6c \x64 \x20 \x25 \x64 \x20 \x25 \x64 " , & lx , & lt , & ll , & ld ) ; lc lc li = 0 ; lg la ; lh ( la = 0  ; la < ld ; la ++ ) { lu ( " \x25 \x6c \x6c \x64 " , & lb [ la ] . lf ) ; lb [ la ] . lf <<= 1 ; li += lb [ la ] . lf ; } lc lc lo = ( ll / ld ) * li ; lc lc lw = ll / ld - lt / li ; lg ls = 0 ; lh ( la = 0  ; la < ld ; la ++ ) { lb [ la ] . le = lw ; } lc lc lv = ll % ld ; lc lc lp = lt % li ; lc lc lq = -1 ; lh ( la = 0  ; la < ld ; la ++ ) { ln ( lv ) { lo += lb [ la ] . lf ; ++ lb [ la ] . le ; -- lv ; } ln ( lp > 0 )  { -- lb [ la ] . le ; lp -= lb [ la ] . lf ; lq = la ; } ls += lb [ la ] . le < 0 ; } ln ( ! ls )  { ln ( lq != -1 ) { lb [ ld ] . lf = - lp ; lb [ ld ] . le = 1 ; ++ ld ; } l0 ( lb , ld , l3 ( l4 l5 ) , l1 ) ; lc lc lm = lx ; lh ( la = 0  ; la < ld ; la ++ ) { lc lc lk = lm < lb [ la ] . le ? lm : lb [ la ] . le ; lb [ la ] . le -= lk ; lm -= lk ; lo -= ( lb [ la ] . lf * lk ) >> 1 ; } } l2 ( " \x43 \x61 \x73 \x65 " " \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x6c \x6c \x64 \n " , lj + 1 , lo ) ; } lz 0 ; }
>>>Func
METHOD lp
METHOD_RETURN lh
lb lb("\x25\x64",&lj)
<operator>.lessEqualsThan ld<=lj
<operator>.postIncrement ld++
IDENTIFIER lq <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lh lp ( ) { lh lj , lf , le , lc ; lb ( " \x25 \x64 " , & lj ) ; lh ld , la , lr ; lg ( ld = 1  ; ld <= lj ; ld ++ ) { lb ( " \x25 \x64 \x20 " , & lf ) ; lg ( la = 0  ; la < lf ; la ++ ) { lb ( " \x25 \x63 \x20 " , & li [ la ] . lk ) ; lb ( " \x25 \x63 \x20 " , & li [ la ] . ln ) ; lb ( " \x25 \x63 \x20 " , & li [ la ] . ls ) ; } lb ( " \x25 \x64 \x20 " , & le ) ; lg ( la = 0  ; la < le ; la ++ ) { lb ( " \x25 \x63 \x20 " , & lm [ la ] . lk ) ; lb ( " \x25 \x63 \x20 " , & lm [ la ] . ln ) ; } lb ( " \x25 \x64 \x20 " , & lc ) ; lg ( la = 0  ; la < lc - 1 ; la ++ ) lb ( " \x25 \x63 \x20 " , & ll [ la ] ) ; lb ( " \x25 \x63 " , & ll [ lc - 1 ] ) ; lo ( ld , lf , le , lc ) ; } lq 0 ; }
>>>Func
METHOD lg
METHOD_RETURN lc
PARAM lc lb
PARAM lc la
ld ld(!lb)
lh lh(la!=0)
BLOCK <empty> <empty>
ld ld(lb>la)
<operator>.assignmentMinus lb-=la
<operator>.logicalNot !lb
<operator>.notEquals la!=0
<operator>.greaterThan lb>la
>>>PDG&12 0->2 0->3 0->6 0->8 0->9 0->10 0->11 2->9 3->10 4->1 4->1 5->1 5->1 7->1 7->1 8->1 8->1 8->1 9->4 9->11 10->5 10->5 10->11 11->7 11->7 11->8 11->8
>>>Token lc lg ( lc lb , lc la ) { ld ( ! lb ) le la ; lh ( la != 0 ) { ld ( lb > la ) lb -= la ; lf la - = lb ; } le lb ; }
>>>Func
METHOD lp
METHOD_RETURN lh
lg lg("\x25\x64",&lj)
<operator>.lessEqualsThan lc<=lj
<operator>.postIncrement lc++
IDENTIFIER lq <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lh lp ( ) { lh lj , lc , la , le , li ; lg ( " \x25 \x64 " , & lj ) ; lk ( lc = 1  ; lc <= lj ; lc ++ ) { lnlh lb = 0 , ld = 1000001 , lf = 0 ; lg ( " \x25 \x64 " , & li ) ; lk ( le = 0  ; le < li ; le ++ ) { lg ( " " " \x25 \x75 " , & la ) ; lf = lf ^ la ; lm ( la < ld ) ld = la ; lb = lb + la ; } lm ( ! lf )  { lb = lb - ld ; ll ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , lc , lb ) ; } lo ll ( " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , lc ) ; } lq 0 ; }
>>>Func
METHOD lm
METHOD_RETURN lo
PARAM lc ld
<operator>.lessThan la<ld
<operator>.postIncrement la++
<operator>.lessThan la<ld
<operator>.postIncrement la++
<operator>.lessThan la<ld
<operator>.postIncrement la++
<operator>.lessThan la<ld
<operator>.postIncrement la++
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->3 3->4 3->5 4->5 5->6 5->7 6->7 7->8 7->9 8->9 9->1 9->1 9->10 10->1 10->1
>>>Token lo lm ( lc ld ) { lj lh [ 100 ] ; lj lf [ 100 ] ; lj lg [ 100 ] ; le ( lc  la = 0 ; la < ld ; la ++ ) lh [ la ] = lk [ la ] / li [ la ] ; le ( lc  la = 0 ; la < ld ; la ++ ) { lf [ la ] = 0 ; le ( lc  lb = 0 ; lb < ld ; lb ++ ) lf [ la ] += ll ( la , lb ) ; lf [ la ] /= li [ la ] ; } le ( lc  la = 0 ; la < ld ; la ++ ) { lg [ la ] = 0 ; le ( lc  lb = 0 ; lb < ld ; lb ++ ) lg [ la ] += ( la != lb && ln [ la ] [ lb ] != -1 ) ? lf [ lb ] : 0 ; lg [ la ] /= li [ la ] ; } le ( lc  la = 0 ; la < ld ; la ++ ) lp ( " \x25 \x2e \x31 \x30 \x66 \n " , 0.25 * lh [ la ] + 0.5 * lf [ la ] + 0.25 * lg [ la ] ) ; }
>>>Func
METHOD ll
METHOD_RETURN li
PARAM lf la
ld ld(lh>0)
BLOCK <empty> <empty>
<operator>.assignment lc=lg[lj()][la]
ld ld(lc)
BLOCK <empty> <empty>
lm lm()
<operator>.greaterThan lh>0
lk lk()
lb lb(lc)
>>>PDG&12 0->2 0->4 0->6 0->7 0->8 0->9 0->10 0->11 2->1 3->1 3->1 5->1 5->1 5->6 6->1 6->11 8->1 9->1 9->3 9->3 10->1 11->1 11->1
>>>Token li ll ( lf la ) { ld ( lh > 0 ) { lf lc = lg [ lj ( ) ] [ la ] ; ld ( lc ) { lk ( ) ; lb ( lc ) ; } le ld ( ln [ la ] ) lm ( ) ; le lb ( la ) ; } le lb ( la ) ; }
>>>Func
METHOD lj
METHOD_RETURN lg
<operator>.assignment lh=0
<operator>.assignment le=5
<operator>.assignment lb=0
lc lc("\x49\x6e\x70\x75\x74\x20\x61\x20""\x6e\x75\x6d\x62\x65\x72\x2c\x20\x74\x68\x69\x73\x20\x69\x73\x20\x74""\x68\x65\x20\x62\x69\x67\x67\x65\x72\x20\x62\x6f\x75\x6e\x64\x20\x6f""\x66\x20\x74\x68\x65\x20\x6c\x65\x72\x70\x3a\n")
lf lf("\x25\x66",&le)
lc lc("\x49\x6e\x70\x75\x74\x20\x61\x20\x6e\x75\x6d\x62\x65\x72\x2c\x20""\x74\x68\x69\x73\x20\x69\x73\x20\x69\x6e\x20\x68\x6f\x77\x20\x6d\x61""\x6e\x79\x20\x73\x74\x65\x70\x73\x20\x79\x6f\x75\x20\x77\x61\x6e\x74""\x20\x74\x6f\x20\x64\x69\x76\x69\x64\x65\x20\x74\x68\x65\x20" "\x6c""\x65\x72\x70\x3a\n")
lf lf("\x25\x66",&lb)
<operator>.lessThan la<lb+1
<operator>.postIncrement la++
IDENTIFIER li <empty>
LITERAL 0 <empty>
<operator>.addition lb+1
>>>PDG&14 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->1 2->1 3->1 3->1 3->6 4->1 4->8 4->9 4->13 5->1 6->1 6->1 7->1 8->1 8->1 8->9 8->13 9->1 9->1 9->10 10->1 10->1 13->1
>>>Token lg lj ( ) { ld lh = 0 ; ld le = 5 ; ld lb = 0 ; lc ( " \x49 \x6e \x70 \x75 \x74 \x20 \x61 \x20 " " \x6e \x75 \x6d \x62 \x65 \x72 \x2c \x20 \x74 \x68 \x69 \x73 \x20 \x69 \x73 \x20 \x74 " " \x68 \x65 \x20 \x62 \x69 \x67 \x67 \x65 \x72 \x20 \x62 \x6f \x75 \x6e \x64 \x20 \x6f " " \x66 \x20 \x74 \x68 \x65 \x20 \x6c \x65 \x72 \x70 \x3a \n " ) ; lf ( " \x25 \x66 " , & le ) ; lc ( " \x49 \x6e \x70 \x75 \x74 \x20 \x61 \x20 \x6e \x75 \x6d \x62 \x65 \x72 \x2c \x20 " " \x74 \x68 \x69 \x73 \x20 \x69 \x73 \x20 \x69 \x6e \x20 \x68 \x6f \x77 \x20 \x6d \x61 " " \x6e \x79 \x20 \x73 \x74 \x65 \x70 \x73 \x20 \x79 \x6f \x75 \x20 \x77 \x61 \x6e \x74 " " \x20 \x74 \x6f \x20 \x64 \x69 \x76 \x69 \x64 \x65 \x20 \x74 \x68 \x65 \x20 " " \x6c " " \x65 \x72 \x70 \x3a \n " ) ; lf ( " \x25 \x66 " , & lb ) ; ll ( lg  la = 0 ; la < lb + 1 ; la ++ ) { lc ( " " " \x25 \x66 \n " , lk ( lh , le , la / lb ) ) ; } li 0 ; }
>>>Func
METHOD ll
METHOD_RETURN lk
PARAM lk la[10][10]
PARAM lk lc
PARAM lk lb
<operator>.assignment lh=0
<operator>.assignment lg=0
<operator>.assignment li=0
<operator>.assignment lj=0
ld ld(la[lc][lb]==10)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
ld ld(la[lc][lb]==20)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
ld ld(la[lc][lb]==30)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.assignment la[lc][lb]=50
IDENTIFIER le <empty>
LITERAL 2 <empty>
ld ld(la[lc+1][lb]==20)
BLOCK <empty> <empty>
ld ld(la[lc-1][lb]==20)
BLOCK <empty> <empty>
ld ld(la[lc][lb+1]==20)
BLOCK <empty> <empty>
ld ld(la[lc][lb-1]==20)
BLOCK <empty> <empty>
ld ld(lg==1)
BLOCK <empty> <empty>
ld ld(lh==1)
BLOCK <empty> <empty>
ld ld(lj==1)
BLOCK <empty> <empty>
ld ld(li==1)
BLOCK <empty> <empty>
ld ld(la[lc+1][lb]==30)
BLOCK <empty> <empty>
ld ld(la[lc-1][lb]==30)
BLOCK <empty> <empty>
ld ld(la[lc][lb+1]==30)
BLOCK <empty> <empty>
ld ld(la[lc][lb-1]==30)
BLOCK <empty> <empty>
ld ld(lg==1&&lh==1)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
ld ld(lj==1&&li==1)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
ld ld(lj==1)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
ld ld(li==1)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
ld ld(lh==1)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
ld ld(lg==1)
BLOCK <empty> <empty>
<operator>.equals la[lc][lb]==10
<operator>.equals la[lc][lb]==20
<operator>.assignment lg=1
<operator>.assignment lh=1
<operator>.assignment lj=1
<operator>.assignment li=1
ld ld(la[lc+1][lb]==20)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
BLOCK <empty> <empty>
ld ld(la[lc-1][lb]==20)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
BLOCK <empty> <empty>
ld ld(la[lc][lb+1]==20)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
BLOCK <empty> <empty>
ld ld(la[lc][lb-1]==20)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
BLOCK <empty> <empty>
<operator>.equals la[lc][lb]==30
<operator>.assignment lg=1
<operator>.assignment lh=1
<operator>.assignment lj=1
<operator>.assignment li=1
ld ld(la[lc+1][lb]==30&&la[lc-1][lb]==30)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
BLOCK <empty> <empty>
ld ld(la[lc][lb+1]==30&&la[lc][lb-1]==30)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
BLOCK <empty> <empty>
ld ld(la[lc][lb+1]==30&&la[lc][lb+2]==30)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
BLOCK <empty> <empty>
ld ld(la[lc][lb-1]==30&&la[lc][lb-2]==30)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
BLOCK <empty> <empty>
ld ld(la[lc-1][lb]==30&&la[lc-2][lb]==30)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
BLOCK <empty> <empty>
ld ld(la[lc+1][lb]==30&&la[lc+2][lb]==30)
BLOCK <empty> <empty>
IDENTIFIER lf <empty>
BLOCK <empty> <empty>
<operator>.equals la[lc+1][lb]==20
<operator>.equals la[lc-1][lb]==20
<operator>.equals la[lc][lb+1]==20
<operator>.equals la[lc][lb-1]==20
<operator>.equals lg==1
<operator>.assignment la[lc][lb]=50
<operator>.assignment la[lc+1][lb]=50
IDENTIFIER le <empty>
LITERAL 4 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals lh==1
<operator>.assignment la[lc][lb]=50
<operator>.assignment la[lc-1][lb]=50
IDENTIFIER le <empty>
LITERAL 4 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals lj==1
<operator>.assignment la[lc][lb]=50
<operator>.assignment la[lc][lb+1]=50
IDENTIFIER le <empty>
LITERAL 4 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals li==1
<operator>.assignment la[lc][lb]=50
<operator>.assignment la[lc][lb-1]=50
IDENTIFIER le <empty>
LITERAL 4 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals la[lc+1][lb]==30
<operator>.equals la[lc-1][lb]==30
<operator>.equals la[lc][lb+1]==30
<operator>.equals la[lc][lb-1]==30
<operator>.logicalAnd lg==1&&lh==1
<operator>.assignment la[lc][lb]=50
<operator>.assignment la[lc+1][lb]=50
<operator>.assignment la[lc-1][lb]=50
IDENTIFIER le <empty>
LITERAL 7 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.logicalAnd lj==1&&li==1
<operator>.assignment la[lc][lb]=50
<operator>.assignment la[lc][lb-1]=50
<operator>.assignment la[lc][lb+1]=50
IDENTIFIER le <empty>
LITERAL 7 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals lj==1
<operator>.assignment la[lc][lb]=50
<operator>.assignment la[lc][lb+1]=50
<operator>.assignment la[lc][lb+2]=50
IDENTIFIER le <empty>
LITERAL 7 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals li==1
<operator>.assignment la[lc][lb]=50
<operator>.assignment la[lc][lb-1]=50
<operator>.assignment la[lc][lb-2]=50
IDENTIFIER le <empty>
LITERAL 7 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals lh==1
<operator>.assignment la[lc][lb]=50
<operator>.assignment la[lc-1][lb]=50
<operator>.assignment la[lc-2][lb]=50
IDENTIFIER le <empty>
LITERAL 7 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals lg==1
<operator>.assignment la[lc][lb]=50
<operator>.assignment la[lc+1][lb]=50
<operator>.assignment la[lc+2][lb]=50
IDENTIFIER le <empty>
LITERAL 7 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals la[lc+1][lb]==20
<operator>.equals la[lc-1][lb]==20
<operator>.equals la[lc][lb+1]==20
<operator>.equals la[lc][lb-1]==20
<operator>.equals lg==1
<operator>.equals lh==1
<operator>.logicalAnd la[lc+1][lb]==30&&la[lc-1][lb]==30
<operator>.equals lj==1
<operator>.equals li==1
<operator>.logicalAnd la[lc][lb+1]==30&&la[lc][lb-1]==30
<operator>.logicalAnd la[lc][lb+1]==30&&la[lc][lb+2]==30
<operator>.logicalAnd la[lc][lb-1]==30&&la[lc][lb-2]==30
<operator>.logicalAnd la[lc-1][lb]==30&&la[lc-2][lb]==30
<operator>.logicalAnd la[lc+1][lb]==30&&la[lc+2][lb]==30
<operator>.addition lb+1
<operator>.subtraction lb-1
<operator>.addition lb+1
<operator>.subtraction lb-1
<operator>.equals la[lc+1][lb]==30
<operator>.equals la[lc-1][lb]==30
<operator>.equals la[lc][lb+1]==30
<operator>.equals la[lc][lb-1]==30
<operator>.equals la[lc][lb+1]==30
<operator>.equals la[lc][lb+2]==30
<operator>.equals la[lc][lb-1]==30
<operator>.equals la[lc][lb-2]==30
<operator>.equals la[lc-1][lb]==30
<operator>.equals la[lc-2][lb]==30
<operator>.equals la[lc+1][lb]==30
<operator>.equals la[lc+2][lb]==30
<operator>.addition lc+1
<operator>.subtraction lc-1
<operator>.addition lb+1
<operator>.addition lb+1
<operator>.subtraction lb-1
<operator>.subtraction lb-1
<operator>.addition lc+1
<operator>.subtraction lc-1
<operator>.subtraction lb-1
<operator>.addition lb+1
<operator>.addition lb+1
<operator>.addition lb+2
<operator>.subtraction lb-1
<operator>.subtraction lb-2
<operator>.addition lc+1
<operator>.addition lc+1
<operator>.subtraction lc-1
<operator>.subtraction lc-1
<operator>.addition lc+1
<operator>.subtraction lc-1
<operator>.addition lb+1
<operator>.subtraction lb-1
<operator>.addition lb+1
<operator>.addition lb+2
<operator>.subtraction lb-1
<operator>.subtraction lb-2
<operator>.subtraction lc-1
<operator>.subtraction lc-2
<operator>.addition lc+1
<operator>.addition lc+2
<operator>.addition lc+1
<operator>.subtraction lc-1
<operator>.subtraction lc-1
<operator>.subtraction lc-2
<operator>.addition lc+1
<operator>.addition lc+2
<operator>.indirectIndexAccess la[lc-1][lb]
<operator>.indirectIndexAccess la[lc][lb-1]
<operator>.indirectIndexAccess la[lc][lb+2]
<operator>.indirectIndexAccess la[lc][lb-2]
<operator>.indirectIndexAccess la[lc-2][lb]
<operator>.indirectIndexAccess la[lc+2][lb]
<operator>.indirectIndexAccess la[lc-1]
<operator>.indirectIndexAccess la[lc]
<operator>.indirectIndexAccess la[lc]
<operator>.indirectIndexAccess la[lc]
<operator>.indirectIndexAccess la[lc-2]
<operator>.indirectIndexAccess la[lc+2]
>>>PDG&276 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->25 0->27 0->29 0->31 0->33 0->35 0->37 0->39 0->41 0->43 0->45 0->47 0->48 0->50 0->51 0->53 0->54 0->56 0->57 0->59 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->70 0->71 0->72 0->74 0->75 0->76 0->78 0->79 0->80 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->91 0->92 0->93 0->95 0->96 0->97 0->99 0->100 0->101 0->103 0->104 0->105 0->107 0->108 0->109 0->111 0->112 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->127 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->138 0->139 0->140 0->141 0->142 0->143 0->144 0->145 0->146 0->147 0->148 0->149 0->151 0->152 0->153 0->154 0->155 0->156 0->157 0->159 0->160 0->161 0->162 0->163 0->164 0->165 0->166 0->167 0->168 0->169 0->170 0->171 0->172 0->173 0->174 0->175 0->176 0->177 0->178 0->179 0->180 0->181 0->182 0->183 0->184 0->185 0->186 0->187 0->188 0->189 0->190 0->191 0->192 0->193 0->194 0->195 0->196 0->197 0->198 0->199 0->200 0->201 0->202 0->203 0->205 0->206 0->212 0->213 0->214 0->215 0->216 0->217 0->218 0->219 0->220 0->221 0->222 0->223 0->224 0->225 0->226 0->227 0->228 0->229 0->230 0->231 0->232 0->233 0->234 0->235 0->236 0->237 0->238 0->239 0->240 0->241 0->242 0->243 0->244 0->245 0->246 0->247 0->248 0->249 0->250 0->251 0->252 0->253 0->254 0->255 0->256 0->257 0->258 0->259 0->260 0->261 0->262 0->263 2->1 3->228 3->229 4->212 4->213 5->1 6->1 7->1 8->1 9->1 9->1 12->1 12->1 15->1 15->1 19->64 32->150 36->158 38->1 40->1 40->204 42->1 44->1 44->207 46->1 46->1 49->1 49->1 52->1 52->1 55->1 55->1 58->1 58->1 61->1 61->1 63->9 63->9 64->12 64->12 65->118 66->125 67->132 68->139 69->1 69->1 73->1 73->1 77->1 77->1 81->1 81->1 85->15 85->15 86->1 86->202 87->1 87->182 87->203 88->1 88->205 89->1 89->174 89->206 90->1 90->1 94->1 94->1 98->1 98->1 102->1 102->1 106->1 106->1 110->1 110->1 114->22 114->22 114->198 115->24 115->24 115->199 116->26 116->26 116->200 117->28 117->28 117->201 118->30 118->30 120->146 125->32 125->32 127->147 132->34 132->34 134->148 139->36 139->36 140->85 141->149 146->38 146->38 146->216 147->40 147->40 147->217 148->42 148->42 148->218 149->44 149->44 149->219 150->46 150->46 152->226 153->224 158->49 158->49 160->222 161->220 166->1 166->52 166->52 168->1 168->1 169->1 169->1 174->1 174->55 174->55 176->1 176->1 177->1 177->1 182->1 182->58 182->58 184->1 184->1 185->1 185->1 190->1 190->61 190->61 191->1 191->1 192->1 192->1 193->1 193->1 198->69 198->69 199->73 199->73 200->77 200->77 201->81 201->81 202->150 202->150 202->190 202->203 203->150 203->150 203->182 204->90 204->90 205->158 205->158 205->166 205->206 206->158 206->158 206->174 207->94 207->94 208->1 208->1 208->98 208->98 209->1 209->1 209->102 209->102 210->1 210->1 210->106 210->106 211->1 211->1 211->110 211->110 213->230 213->231 213->232 215->236 215->248 215->249 216->204 216->204 216->217 216->259 216->264 216->270 217->204 217->204 218->207 218->207 218->219 218->249 218->265 218->271 219->207 219->207 220->208 220->208 220->221 220->251 220->266 220->272 221->208 221->208 222->209 222->209 222->223 222->253 222->267 222->273 223->209 223->209 224->210 224->210 224->225 224->261 224->268 224->274 225->210 225->210 226->211 226->211 226->227 226->263 226->269 226->275 227->211 227->211 229->242 229->243 229->244 232->233 233->214 233->215 235->246 235->247 235->258 235->259 236->237 236->238 236->239 236->250 236->251 236->252 240->241 241->1 244->245 245->234 245->235 247->260 249->236 252->240 252->253 253->240 254->255 255->256 255->257 255->262 255->263 257->1 259->246 259->247 260->254 260->261 261->254
>>>Token lk ll ( lk la [ 10 ] [ 10 ] , lk lc , lk lb ) { lk lh = 0 , lg = 0 , li = 0 , lj = 0 ; ld ( la [ lc ] [ lb ] == 10 )  { la [ lc ] [ lb ] = 50 ; le 2 ; } lf ld ( la [ lc ] [ lb ] = = 20 ) { ld ( la [ lc + 1 ] [ lb ] == 20 )  { lg = 1 ; } ld ( la [ lc - 1 ] [ lb ] == 20 )  { lh = 1 ; } ld ( la [ lc ] [ lb + 1 ] == 20 )  { lj = 1 ; } ld ( la [ lc ] [ lb - 1 ] == 20 )  { li = 1 ; } ld ( lg == 1 )  { ld ( la [ lc + 1 ] [ lb ] == 20 )  { la [ lc ] [ lb ] = 50 ; la [ lc + 1 ] [ lb ] = 50 ; le 4 ; } lf { le 0 ; } } ld ( lh == 1 )  { ld ( la [ lc - 1 ] [ lb ] == 20 )  { la [ lc ] [ lb ] = 50 ; la [ lc - 1 ] [ lb ] = 50 ; le 4 ; } lf { le 0 ; } } ld ( lj == 1 )  { ld ( la [ lc ] [ lb + 1 ] == 20 )  { la [ lc ] [ lb ] = 50 ; la [ lc ] [ lb + 1 ] = 50 ; le 4 ; } lf { le 0 ; } } ld ( li == 1 ) { ld ( la [ lc ] [ lb - 1 ] == 20 ) { la [ lc ] [ lb ] = 50 ; la [ lc ] [ lb - 1 ] = 50 ; le 4 ; } lf { le 0 ; } } } lf ld ( la [ lc ] [ lb ] = = 30 ) { ld ( la [ lc + 1 ] [ lb ] == 30 )  { lg = 1 ; } ld ( la [ lc - 1 ] [ lb ] == 30 )  { lh = 1 ; } ld ( la [ lc ] [ lb + 1 ] == 30 )  { lj = 1 ; } ld ( la [ lc ] [ lb - 1 ] == 30 )  { li = 1 ; } ld ( lg == 1 && lh == 1 )  { ld ( la [ lc + 1 ] [ lb ] == 30 && la [ lc - 1 ] [ lb ] == 30 )  { la [ lc ] [ lb ] = 50 ; la [ lc + 1 ] [ lb ] = 50 ; la [ lc - 1 ] [ lb ] = 50 ; le 7 ; } lf { le 0 ; } } lf ld ( lj == 1 && li = = 1 ) { ld ( la [ lc ] [ lb + 1 ] == 30 && la [ lc ] [ lb - 1 ] == 30 )  { la [ lc ] [ lb ] = 50 ; la [ lc ] [ lb - 1 ] = 50 ; la [ lc ] [ lb + 1 ] = 50 ; le 7 ; } lf { le 0 ; } } lf ld ( lj == 1 ) { ld ( la [ lc ] [ lb + 1 ] == 30 && la [ lc ] [ lb + 2 ] == 30 )  { la [ lc ] [ lb ] = 50 ; la [ lc ] [ lb + 1 ] = 50 ; la [ lc ] [ lb + 2 ] = 50 ; le 7 ; } lf { le 0 ; } } lf ld ( li == 1 ) { ld ( la [ lc ] [ lb - 1 ] == 30 && la [ lc ] [ lb - 2 ] == 30 )  { la [ lc ] [ lb ] = 50 ; la [ lc ] [ lb - 1 ] = 50 ; la [ lc ] [ lb - 2 ] = 50 ; le 7 ; } lf { le 0 ; } } lf ld ( lh == 1 ) { ld ( la [ lc - 1 ] [ lb ] == 30 && la [ lc - 2 ] [ lb ] == 30 )  { la [ lc ] [ lb ] = 50 ; la [ lc - 1 ] [ lb ] = 50 ; la [ lc - 2 ] [ lb ] = 50 ; le 7 ; } lf { le 0 ; } } lf ld ( lg == 1 ) { ld ( la [ lc + 1 ] [ lb ] == 30 && la [ lc + 2 ] [ lb ] == 30 )  { la [ lc ] [ lb ] = 50 ; la [ lc + 1 ] [ lb ] = 50 ; la [ lc + 2 ] [ lb ] = 50 ; le 7 ; } lf { le 0 ; } } } le 0 ; }
>>>Func
METHOD ly
METHOD_RETURN lx
lr lr("\x25\x64",&lt)
<operator>.lessEqualsThan li<=lt
<operator>.postIncrement li++
IDENTIFIER lz <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lx ly ( ) { lx lt , li , l1 , ld , lp [ lf ] , la , lb ; l0 lg [ lf ] [ lf ] , ls [ lf ] ; lw lj , lc , lk , ll , lo [ lf ] ; lr ( " \x25 \x64 " , & lt ) ; le ( li = 1  ; li <= lt ; li ++ ) { lw ln [ lf ] = { 0 } , lm [ lf ] = { 0 } , lq [ lf ] = { 0 } ; lr ( " \x25 \x64 " , & ld ) ; le ( la = 0  ; la < ld ; la ++ ) { lr ( " \x25 \x73 " , ls ) ; le ( lb = 0  ; lb < ld ; lb ++ ) lg [ la ] [ lb ] = ls [ lb ] ; } le ( la = 0  ; la < ld ; la ++ ) { lc = 0 ; lj = 0 ; le ( lb = 0  ; lb < ld ; lb ++ ) { lh ( lg [ la ] [ lb ] != ' ' )  { lc ++ ; lh ( lg [ la ] [ lb ] == ' ' ) lj ++ ; } } lh ( lc == 0 ) ln [ la ] = 0 ; lu ln [ la ] = lj / lc ; lo [ la ] = lj ; lp [ la ] = lc ; } le ( la = 0  ; la < ld ; la ++ ) { lk = 0 ; lc = 0 ; le ( lb = 0  ; lb < ld ; lb ++ ) { lh ( lg [ la ] [ lb ] != ' ' )  { lc ++ ; lh ( lg [ la ] [ lb ] == ' ' )  { lk += ( lo [ lb ] ) / ( lp [ lb ] - 1 ) ; } lu lk + = ( lo [ lb ] - 1 ) / ( lp [ lb ] - 1 ) ; } } lm [ la ] = lk / lc ; } le ( la = 0  ; la < ld ; la ++ ) { ll = lc = 0 ; le ( lb = 0  ; lb < ld ; lb ++ ) { lh ( lg [ la ] [ lb ] != ' ' )  { lc ++ ; ll += lm [ lb ] ; } } lq [ la ] = ll / lc ; } lv ( " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \n " , li ) ; le ( la = 0  ; la < ld ; la ++ ) lv ( " \x25 \x2e \x31 " " \x32 \x6c \x66 \n " , 0.25 * ln [ la ] + 0.50 * lm [ la ] + 0.25 * lq [ la ] ) ; } lz 0 ; }
>>>Func
METHOD lj
METHOD_RETURN le
PARAM lg*la
<operator>.lessThan lc<la->lk
<operator>.postIncrement lc++
IDENTIFIER li <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 3->1 3->4 4->1 4->1
>>>Token le lj ( lg * la ) { le lc , lb , ld ; lf ( lc = 1  ; lc < la -> lk ; lc ++ ) { ld = la -> la [ lc ] ; lb = lc - 1 ; lh ( lb >= 0 && la -> la [ lb ] > ld )  { la -> la [ lb + 1 ] = la -> la [ lb ] ; lb -- ; } la -> la [ lb + 1 ] = ld ; } li 0 ; }
>>>Func
METHOD lo
METHOD_RETURN lj
ll ll("\x25\x64",&lk)
<operator>.lessEqualsThan ld<=lk
<operator>.postIncrement ld++
IDENTIFIER lp <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lj lo ( ) { lj lk , lg , lf , lh , ld ; lj li , le ; ll ( " \x25 \x64 " , & lk ) ; lm ( ld = 1  ; ld <= lk ; ld ++ ) { la ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , ld ) ; ll ( " \x25 \x64 " " \x25 \x64 \x25 \x64 " , & lg , & lf , & lh ) ; lb ( lh == 0 )  { lb ( lf == 0 ) { la ( " \x50 \x6f \x73 " " \x73 \x69 \x62 \x6c \x65 " ) ; } lc { la ( " \x42 \x72 \x6f \x6b \x65 \x6e " ) ; } } lc  { lb ( lf == 100 )  { la ( " \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 " ) ; } lc lb ( lh == 100 ) { la ( " " " \x42 \x72 \x6f \x6b \x65 \x6e " ) ; } lc  { lb ( lg >= 100 )  { la ( " \x50 \x6f \x73 \x73 \x69 " " \x62 \x6c \x65 " ) ; } lc { li = 0 ; lm ( le = 1  ; le <= lg ; le ++ ) { lb ( le * lf % 100 == 0 )  { li = 1 ; ln ; } } lb ( li ) { la ( " \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 " ) ; } lc  { la ( " \x42 \x72 " " \x6f \x6b \x65 \x6e " ) ; } } } } la ( " \n " ) ; } lp 0 ; }
>>>Func
METHOD lj
METHOD_RETURN le
<operator>.assignment lb=0
<operator>.assignment la=0
lh lh("\x25\x64",&ld)
<operator>.postIncrement lc++
lg lg("\x25\x64\n",la)
IDENTIFIER lf <empty>
LITERAL 0 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 2->1 3->1 3->6 4->1 4->1 5->1 5->1 6->1 6->1
>>>Token le lj ( ) { le lc , ld , lb = 0 , la = 0 ; lh ( " \x25 \x64 " , & ld ) ; ln ( lc = 1  ; ; lc ++ ) { lb = ld / lk ( 5 , lc ) ; ll ( lb != 0 )  { la = la + lb ; } li lm ; } lg ( " \x25 \x64 \n " , la ) ; lf 0 ; }
>>>Func
METHOD l0
METHOD_RETURN lz
le le("\x25\x64",&lv)
<operator>.lessThan lh<lv
<operator>.postIncrement lh++
IDENTIFIER l1 <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lz l0 ( ) { lz lh , lv , la , lm , ll , lt , lb , lg , li , lf ; ly ln [ 3 ] , lr [ 2 ] , lq [ 10 ] , ls , ld [ 10 ] ; ly lu , lp , lw , lx ; le ( " \x25 \x64 " , & lv ) ; lj ( lh = 0  ; lh < lv ; lh ++ ) { lb = -1 ; le ( " " " \x25 \x64 " , & lm ) ; lc ( lm != 0 )  { le ( " \x25 \x63 " , & ls ) ; lj ( la = 0  ; la < 3 ; la ++ ) le ( " " " \x25 \x63 " , & ln [ la ] ) ; } le ( " \x25 \x64 " , & ll ) ; lc ( ll != 0 )  { le ( " \x25 \x63 " , & ls ) ; lj ( la = 0  ; la < 2 ; la ++ ) le ( " \x25 \x63 " , & lr [ la ] ) ; } le ( " \x25 \x64 " , & lt ) ; le ( " \x25 " " \x63 " , & ls ) ; lj ( la = 0  ; la < lt ; la ++ ) le ( " \x25 \x63 " , & lq [ la ] ) ; ld [ ++ lb ] = lq [ 0 ] ; lc ( lm != 0 )  { lu = ln [ 0 ] ; lp = ln [ 1 ] ; } lc ( ll != 0 )  { lw = lr [ 0 ] ; lx = lr [ 1 ] ; } lj ( la = 1  ; la < lt ; la ++ ) { ld [ ++ lb ] = lq [ la ] ; lc ( lb > 0 )  { lc ( lm != 0 ) { lc ( ( ld [ lb ] == lu && ld [ lb - 1 ] == lp ) || ( ld [ lb ] == lp && ld [ lb - 1 ] == lu ) )  { ld [ -- lb ] = ln [ 2 ] ; } } lc ( ll != 0 )  { lg = -1 ; li = -1 ; lj ( lf = 0  ; lf <= lb ; lf ++ ) { lc ( ld [ lf ] == lw && lg == -1 ) lg = lf ; lo lc ( ld [ lf ] = = lx && li == -1 ) li = lf ; } lc ( lg >= 0 && li >= 0 )  { lc ( lg < li ) lb = -1 ; lo lc ( li < lg ) lb = -1 ; } } } } lc ( lb < 0 )  lk ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b \x5d " , lh + 1 ) ; lo lc ( lb == 0 )  lk ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b \x25 " " \x63 \x5d " , lh + 1 , ld [ 0 ] ) ; lo lc ( lb > 0 ) { lk ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 " " \x64 \x3a \x20 \x5b \x25 \x63 " , lh + 1 , ld [ 0 ] ) ; lj ( la = 1  ; la <= lb ; la ++ ) lk ( " \x2c " " \x20 \x25 \x63 " , ld [ la ] ) ; lk ( " \x5d " ) ; } lk ( " \n " ) ; } l1 0 ; }
>>>Func
METHOD ll
METHOD_RETURN lk
ld ld("\x25\x64\n",&le)
<operator>.lessThan la<le
<operator>.postIncrement la++
>>>PDG&5 0->2 0->3 0->4 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lk ll ( ) { lj lc ; ld ( " \x25 \x64 \n " , & le ) ; lf ( la = 0  ; la < le ; la ++ ) { lf ( lb = 0  ; lb < le ; lb ++ ) { ld ( " \x25 \x63 " , & lc ) ; lh ( lc == ' ' )  { lg [ la ] [ lb ] = -1 ; } li  { lg [ la ] [ lb ] = lc - ' ' ; } } ld ( " \n " ) ; } }
>>>Func
METHOD lm
METHOD_RETURN lh
PARAM lg lc
<operator>.assignment la->ln=lc
<operator>.assignment la->li=le(lc*lf(lg))
<operator>.lessThan lb<lc
<operator>.postIncrement lb++
le le(lc*lf(lg))
<operator>.multiplication lc*lf(lg)
lf lf(lg)
>>>PDG&10 0->2 0->3 0->5 0->6 0->8 0->9 2->3 2->8 3->1 3->1 4->1 4->1 4->1 5->1 5->1 5->6 6->1 6->1 7->1 7->4 8->1 8->5 8->7 8->7 9->1 9->8
>>>Token ld lh * lm ( lg lc ) { ld lh * la = le ( lf ( ld lh ) ) ; la -> ln = lc ; la -> lj = le ( lc * lf ( ld lp * ) ) ; la -> li = le ( lc * lf ( lg ) ) ; lg lb ; ll ( lb = 0  ; lb < lc ; lb ++ ) { la -> lj [ lb ] = lo ; la -> li [ lb ] = 0 ; } lk la ; }
>>>Func
METHOD ln
METHOD_RETURN li
<operator>.assignment lc=lj("\x42\x2e\x74\x78\x74","\x72")
lk lk(lc==lg)
le le("\n\x45\x52""\x52\x4f\x52\x20\x2d\x20\x6f\x70\x65\x6e\x69\x6e\x67\x20\x69\x6e\x70""\x75\x74\x20\x66\x69\x6c\x65\n")
<operator>.assignment lb=lj("\x6f\x75\x74\x70\x75\x74","""\x77")
lk lk(lb==lg)
le le("\n\x45\x52\x52\x4f\x52\x20\x2d\x20\x6f\x70\x65""\x6e\x69\x6e\x67\x20\x6f\x75\x74\x70\x75\x74\x20\x66\x69\x6c\x65\n")
<operator>.assignment ld=0
lm lm(lc,"\x25\x64",&ld)
<operator>.lessThan la<ld
<operator>.postIncrement la++
lf lf(lb,"""\n")
lh lh(lc)
lh lh(lb)
IDENTIFIER ll <empty>
LITERAL 0 <empty>
lj lj("\x42\x2e\x74\x78\x74","\x72")
<operator>.equals lc==lg
lj lj("\x6f\x75\x74\x70\x75\x74","""\x77")
<operator>.equals lb==lg
>>>PDG&21 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 2->1 2->1 2->18 3->1 3->1 4->1 5->1 5->1 5->20 6->1 6->1 7->1 8->1 8->9 8->10 9->1 9->1 9->10 9->13 10->1 10->1 10->11 11->1 11->1 12->1 12->14 13->1 13->1 14->1 14->1 17->2 17->2 18->3 18->3 18->9 18->20 19->5 19->5 20->1 20->6 20->6 20->12
>>>Token li ln ( ) { lc = lj ( " \x42 \x2e \x74 \x78 \x74 " , " \x72 " ) ; lk ( lc == lg )  le ( " \n \x45 \x52 " " \x52 \x4f \x52 \x20 \x2d \x20 \x6f \x70 \x65 \x6e \x69 \x6e \x67 \x20 \x69 \x6e \x70 " " \x75 \x74 \x20 \x66 \x69 \x6c \x65 \n " ) ; lb = lj ( " \x6f \x75 \x74 \x70 \x75 \x74 " , " " " \x77 " ) ; lk ( lb == lg )  le ( " \n \x45 \x52 \x52 \x4f \x52 \x20 \x2d \x20 \x6f \x70 \x65 " " \x6e \x69 \x6e \x67 \x20 \x6f \x75 \x74 \x70 \x75 \x74 \x20 \x66 \x69 \x6c \x65 \n " ) ; li ld , la ; ld = 0 ; lm ( lc , " \x25 \x64 " , & ld ) ; lq ( la = 0  ; la < ld ; la ++ ) { le ( " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , la + 1 ) ; lf ( lb , " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x64 \x3a \x20 " , la + 1 ) ; lp ( ) ; lo ( ) ; le ( " \n " ) ; lf ( lb , " \n " ) ; } lf ( lb , " " " \n " ) ; lh ( lc ) ; lh ( lb ) ; ll 0 ; }
>>>Func
METHOD lw
METHOD_RETURN lg
PARAM l1
<operator>.assignment lb=lr("\x43""\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x31\x2e\x69""\x6e","\x72")
<operator>.assignment lf=lr("\x43\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74""\x65\x6d\x70\x74\x31\x2e\x6f\x75\x74","\x77")
<operator>.assignment lo=lk(lb)
<operator>.lessEqualsThan ld<=lo
<operator>.postIncrement ld++
lq lq(lb)
lq lq(lf)
IDENTIFIER ly <empty>
LITERAL 0 <empty>
lr lr("\x43""\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x31\x2e\x69""\x6e","\x72")
lr lr("\x43\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74""\x65\x6d\x70\x74\x31\x2e\x6f\x75\x74","\x77")
lk lk(lb)
>>>PDG&15 0->2 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 3->1 3->14 4->1 4->1 4->9 5->1 5->1 5->6 6->1 6->1 6->7 7->1 7->1 8->1 8->1 9->1 9->1 12->3 12->3 13->4 13->4 14->5 14->8
>>>Token lg lw ( l1 ) { lu * lb , * lf ; lg lo , lm , lc ; lg ld , la ; lp li ; lg le , lh ; lb = lr ( " \x43 " " \x2d \x73 \x6d \x61 \x6c \x6c \x2d \x61 \x74 \x74 \x65 \x6d \x70 \x74 \x31 \x2e \x69 " " \x6e " , " \x72 " ) ; lf = lr ( " \x43 \x2d \x73 \x6d \x61 \x6c \x6c \x2d \x61 \x74 \x74 " " \x65 \x6d \x70 \x74 \x31 \x2e \x6f \x75 \x74 " , " \x77 " ) ; lo = lk ( lb ) ; lj ( ld = 1  ; ld <= lo ; ld ++ ) { lm = lk ( lb ) ; li = lh = 0 ; le = 1000001 ; l0 ( ll , 0 , lx ( ll ) ) ; lj ( la = 0  ; la < lm ; la ++ ) { lc = lk ( lb ) ; lz ( lc ) ; li += lc ; ln ( le > lc ) le = lc ; } lj ( la = 0  ; la < 20 ; la ++ ) { ln ( ll [ la ] % 2 != 0 )  { lh = 1 ; lt ; } } ln ( lh == 1 )  ls ( lf , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 " " \x64 \x3a \x20 \x4e \x4f \n " , ld ) ; lv ls ( lf , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 " " \x64 \x3a \x20 \x25 \x49 \x36 \x34 \x64 \n " , ld , ( lp ) ( li - le ) ) ; } lq ( lb ) ; lq ( lf ) ; ly 0 ; }
>>>Func
METHOD lb
METHOD_RETURN le
PARAM lf*la
li li(la==lc)
IDENTIFIER ld <empty>
lb lb(la->lh)
lg lg("\x20\x20\x25\x64\x20\x20" (la->lj))
lb lb(la->lk)
<operator>.equals la==lc
>>>PDG&9 0->2 0->4 0->6 0->8 2->8 3->1 3->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 8->3 8->3
>>>Token le lb ( lf * la ) { li ( la == lc ) ld ; lb ( la -> lh ) ; lg ( " \x20 \x20 \x25 \x64 \x20 \x20 " , ( la -> lj ) ) ; lb ( la -> lk ) ; }
>>>Func
METHOD lm
METHOD_RETURN lh
PARAM li ld[]
PARAM lh lb
PARAM li lf[][3]
PARAM li ll
<operator>.assignment lc=0
<operator>.assignment la=0
<operator>.lessThan lc<ll
<operator>.postIncrement lc++
IDENTIFIER lg <empty>
LITERAL 0 <empty>
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->1 3->1 4->1 5->8 6->1 6->8 7->1 7->1 8->1 8->1 8->9 9->1 9->1
>>>Token lh lm ( li ld [ ] , lh lb , li lf [ ] [ 3 ] , li ll ) { lh lc = 0 ; lh la = 0 ; lj ( lc = 0  ; lc < ll ; lc ++ ) { le ( lb < 2 ) lg 0 ; le ( ld [ lb - 1 ] == lf [ lc ] [ 0 ] )  { lj ( la = 0  ; la < lb - 1 ; la ++ ) { le ( ld [ la ] == lf [ lc ] [ 1 ] )  { lk ( ld , 0 , lb ) ; lg 1 ; } } } le ( ld [ lb - 1 ] == lf [ lc ] [ 1 ] )  { lj ( la = 0  ; la < lb - 1 ; la ++ ) { le ( ld [ la ] == lf [ lc ] [ 0 ] )  { lk ( ld , 0 , lb ) ; lg 1 ; } } } } lg 0 ; }
>>>Func
METHOD ly
METHOD_RETURN li
<operator>.assignment lx=1
ln ln("\x25\x64",&ls)
lz lz(ls--)
BLOCK <empty> <empty>
IDENTIFIER l0 <empty>
LITERAL 0 <empty>
ln ln("\x25\x64",&lb)
<operator>.assignment lm=(ld* )lh(lg(ld) *lb)
<operator>.assignment ll=(ld* )lh(lg(ld) *lb)
<operator>.assignment lp=(ld* )lh(lg(ld) *lb)
<operator>.assignment lo=(ld* )lh(lg(ld) *lb)
<operator>.assignment lj=(li* )lh(lg(li) *lb)
<operator>.lessThan la<lb
<operator>.postIncrement la++
<operator>.lessThan la<lb
<operator>.postIncrement la++
<operator>.lessThan la<lb
<operator>.postIncrement la++
<operator>.lessThan la<lb
<operator>.postIncrement la++
lu lu("\x43\x61\x73\x65\x20\x23\x25\x64\x3a\n",lx++)
<operator>.lessThan la<lb
<operator>.postIncrement la++
<operator>.postDecrement ls--
<operator>.cast (ld* )lh(lg(ld) *lb)
<operator>.cast (ld* )lh(lg(ld) *lb)
<operator>.cast (ld* )lh(lg(ld) *lb)
<operator>.cast (ld* )lh(lg(ld) *lb)
<operator>.cast (li* )lh(lg(li) *lb)
<operator>.postIncrement lx++
lh lh(lg(ld) *lb)
lh lh(lg(ld) *lb)
lh lh(lg(ld) *lb)
lh lh(lg(ld) *lb)
lh lh(lg(li) *lb)
<operator>.multiplication lg(ld) *lb
<operator>.multiplication lg(ld) *lb
<operator>.multiplication lg(ld) *lb
<operator>.multiplication lg(ld) *lb
<operator>.multiplication lg(li) *lb
lg lg(ld)
lg lg(ld)
lg lg(ld)
lg lg(ld)
lg lg(li)
>>>PDG&47 0->2 0->3 0->5 0->6 0->7 0->8 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->31 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 2->1 2->31 3->1 3->1 3->25 4->1 4->1 8->1 8->1 8->14 8->16 8->18 8->20 8->23 8->37 8->38 8->39 8->40 8->41 9->1 9->1 10->1 10->1 11->1 11->1 12->1 12->1 12->1 13->1 13->1 13->1 14->15 14->16 15->16 16->17 16->18 17->18 18->19 18->20 19->20 20->21 20->23 21->23 22->1 22->1 23->1 23->1 23->24 24->1 24->1 25->1 25->4 29->1 30->1 31->1 31->22 32->9 32->26 33->10 33->27 34->11 34->28 35->1 35->12 35->29 36->1 36->13 36->30 37->32 37->32 37->38 38->33 38->33 38->39 39->34 39->34 39->40 40->1 40->35 40->35 40->41 41->1 41->14 41->36 41->36 42->37 42->43 43->38 43->44 44->39 44->45 45->1 45->40 46->1 46->41
>>>Token li ly ( ) { li ls , lx = 1 ; ln ( " \x25 \x64 " , & ls ) ; lz ( ls -- )  { li lb ; ln ( " \x25 \x64 " , & lb ) ; ld * lm ; ld * ll ; ld * lp ; ld * lo ; li * lj ; lm = ( ld * ) lh ( lg ( ld ) * lb ) ; ll = ( ld * ) lh ( lg ( ld ) * lb ) ; lp = ( ld * ) lh ( lg ( ld ) * lb ) ; lo = ( ld * ) lh ( lg ( ld ) * lb ) ; lj = ( li * ) lh ( lg ( li ) * lb ) ; lk * * lf ; lf = ( lk * * ) lh ( lg ( lk *  ) * lb ) ; li la , lc ; lk lv ; le ( la = 0  ; la < lb ; la ++ ) { lf [ la ] = ( lk * ) lh ( lg ( lk ) * lb ) ; ln ( " \x25 \x63 " , & lv ) ; le ( lc = 0  ; lc < lb ; lc ++ ) { ln ( " \x25 \x63 " , & lf [ la ] [ lc ] ) ; } } le ( la = 0  ; la < lb ; la ++ ) { lj [ la ] = l3 ( lf [ la ] , lb ) ; lm [ la ] = l2 ( lf [ la ] , lb ) * 1.0 / lj [ la ] ; } le ( la = 0  ; la < lb ; la ++ ) { ld lt = 0 ; ld * lq ; lq = ( ld * ) lh ( lg ( ld ) * ( lb - 1 ) ) ; le ( lc = 0  ; lc < lb ; lc ++ ) { lq [ lc ] = l1 ( lf [ lc ] , lb , la ) * 1.0 / ( lj [ lc ] - 1 ) ; } le ( lc = 0  ; lc < lb ; lc ++ ) { lw ( lf [ la ] [ lc ] != ' ' )  { lt += lq [ lc ] ; } } ll [ la ] = lt / ( lj [ la ] ) ; } le ( la = 0  ; la < lb ; la ++ ) { ld lr = 0 ; le ( lc = 0  ; lc < lb ; lc ++ ) { lw ( lf [ la ] [ lc ] != ' ' )  { lr += ll [ lc ] ; } } lp [ la ] = lr / lj [ la ] ; } lu ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \n " , lx ++ ) ; le ( la = 0  ; la < lb ; la ++ ) { lo [ la ] = 0.25 * lm [ la ] + 0.5 * ll [ la ] + 0.25 * lp [ la ] ; lu ( " \x25 \x2e \x31 \x32 " " \x67 \n " , lo [ la ] ) ; } } l0 0 ; }
>>>Func
METHOD l0
METHOD_RETURN lz
PARAM l3
<operator>.assignment ln=0
<operator>.assignment ll=0
<operator>.assignment *lh=ly("\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74""\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e","\x72")
<operator>.assignment *lk=ly("\x6f\x75\x74""\x70\x75\x74\x33\x2e\x74\x78\x74","\x77")
lj lj(lh,"\x25\x64",&lr)
<operator>.lessThan lo<lr
<operator>.postIncrement lo++
l4 l4(lk)
IDENTIFIER l1 <empty>
LITERAL 0 <empty>
ly ly("\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74""\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e","\x72")
ly ly("\x6f\x75\x74""\x70\x75\x74\x33\x2e\x74\x78\x74","\x77")
>>>PDG&15 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 3->1 4->1 4->1 5->1 5->1 5->7 6->1 6->1 6->10 7->1 7->1 7->1 7->8 8->1 8->1 8->9 9->1 9->1 10->1 10->1 13->5 13->5 14->6 14->6
>>>Token lz l0 ( l3 ) { lz lo , la , lc , le , lu , lt , ls , lr , lp , ln = 0 , ll = 0 , ld , lv ; l2 li [ 40 ] [ 3 ] , lm [ 30 ] [ 2 ] , lb [ 200 ] ; lx * lh = ly ( " \x42 \x2d \x73 \x6d \x61 \x6c \x6c \x2d \x61 \x74 " " \x74 \x65 \x6d \x70 \x74 \x30 \x2e \x69 \x6e " , " \x72 " ) ; lx * lk = ly ( " \x6f \x75 \x74 " " \x70 \x75 \x74 \x33 \x2e \x74 \x78 \x74 " , " \x77 " ) ; lj ( lh , " \x25 \x64 " , & lr ) ; lf ( lo = 0  ; lo < lr ; lo ++ ) { lj ( lh , " \x25 \x64 " , & lt ) ; lf ( la = 0  ; la < lt ; la ++ ) { lj ( lh , " " " \x25 \x73 " , li [ la ] ) ; } lj ( lh , " \x25 \x64 " , & ls ) ; lf ( la = 0  ; la < ls ; la ++ ) { lj ( lh , " " " \x25 \x73 " , lm [ la ] ) ; } lj ( lh , " \x25 \x64 " , & lu ) ; la = 0 ; lj ( lh , " \x25 \x73 " , lb ) ; lf ( la = 0  ; la < lu ; la ++ ) { lf ( lc = 0  ; lc < lt ; lc ++ ) { lf ( ld = 0  ; ld < la ; ld ++ ) { lg ( lb [ ld ] == li [ lc ] [ 0 ] && lb [ ld + 1 ] == li [ lc ] [ 1 ] )  { lb [ ld ] = ' ' ; lb [ ld + 1 ] = ' ' ; lb [ ld ] = li [ lc ] [ 2 ] ; } lw lg ( lb [ ld ] = = li [ lc ] [ 1 ] && lb [ ld + 1 ] == li [ lc ] [ 0 ] ) { lb [ ld ] = ' ' ; lb [ ld + 1 ] = ' ' ; lb [ ld ] = li [ lc ] [ 2 ] ; } } } lf ( lc = 0  ; lc < ls ; lc ++ ) { lf ( le = 0  ; le <= la ; le ++ ) { lg ( lb [ le ] == lm [ lc ] [ 0 ] ) ln ++ ; lg ( ( ln > 0 ) && ( lb [ le ] == lm [ lc ] [ 1 ] ) ) ln = 2000 ; } lf ( le = 0  ; le <= la ; le ++ ) { lg ( lb [ le ] == lm [ lc ] [ 1 ] ) ll ++ ; lg ( ll > 0 && lb [ le ] == lm [ lc ] [ 0 ] ) ll = 2000 ; } lg ( ln == 2000 || ll == 2000 )  { lf ( lp = 0  ; lp <= la ; lp ++ ) lb [ lp ] = ' ' ; } ln = 0 ; ll = 0 ; } } lv = 0 ; lq ( lk , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lo + 1 ) ; lf ( la = 0  ; la < lu ; la ++ ) { lg ( lb [ la ] != ' ' )  { lg ( lv == 0 ) { lq ( lk , " \x25 \x63 " , lb [ la ] ) ; lv ++ ; } lw { lq ( lk , " \x2c \x20 \x25 \x63 " , lb [ la ] ) ; } } } lg ( lo < lr - 1 )  lq ( lk , " \x5d \n " ) ; lw lq ( lk , " x 5 d " ) ; } l4 ( lk ) ; l1 0 ; }
>>>Func
METHOD ly
METHOD_RETURN lo
PARAM l4
<operator>.assignment lc=0
li li("\x25\x64",&lv)
<operator>.lessThan lq<lv
<operator>.postIncrement lq++
IDENTIFIER l0 <empty>
LITERAL 1 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token lo ly ( l4 ) { lo lq , la , lb , ld , lh ; lo lv , lr , ls , lw ; l3 lf [ 4 ] , lj [ 3 ] , lx [ 100 ] , ll [ 100 ] ; lo lc = 0 ; lo lg , lk ; li ( " \x25 \x64 " , & lv ) ; le ( lq = 0  ; lq < lv ; lq ++ ) { lc = 0 ; le ( la = 0  ; la < 26 ; la ++ ) { ln [ la ] = 0 ; le ( lb = 0  ; lb < 26 ; lb ++ ) { lp [ la ] [ lb ] = -1 ; lu [ la ] [ lb ] = 0 ; } } li ( " \x25 \x64 " , & lr ) ; le ( ; lr > 0 ; lr -- ) { li ( " \x20 \x25 \x73 " , lf ) ; lp [ lf [ 0 ] - ' ' ] [ lf [ 1 ] - ' ' ] = lf [ 2 ] - ' ' ; lp [ lf [ 1 ] - ' ' ] [ lf [ 0 ] - ' ' ] = lf [ 2 ] - ' ' ; } li ( " " " \x25 \x64 " , & ls ) ; le ( ; ls > 0 ; ls -- ) { li ( " \x20 \x25 \x73 " , lj ) ; lu [ lj [ 0 ] - ' ' ] [ lj [ 1 ] - ' ' ] = 1 ; lu [ lj [ 1 ] - ' ' ] [ lj [ 0 ] - ' ' ] = 1 ; } li ( " \x25 \x64 " , & lw ) ; li ( " \x20 " " \x25 \x73 " , lx ) ; le ( la = 0  ; la < lw ; la ++ ) { lg = lx [ la ] - ' ' ; l5 { lh = 0 ; lm ( lc != 0 )  { lk = ll [ lc - 1 ] - ' ' ; lm ( lp [ lg ] [ lk ] != -1 )  { lh = 1 ; lg = lp [ lg ] [ lk ] ; lc -- ; ln [ lk ] -- ; l1 ; } le ( lb = 0  ; lb < 26 ; lb ++ ) { lm ( lu [ lg ] [ lb ] && ln [ lb ] )  { lh = 2 ; le ( ld = 0  ; ld < 26 ; ld ++ ) { ln [ ld ] = 0 ; lc = 0 ; } l2 ; } } } } lz ( ( lh != 0 ) && ( lh != 2 ) ) ; lm ( lh != 2 )  { ll [ lc ++ ] = lg + ' ' ; ln [ lg ] ++ ; } } lt ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lq + 1 ) ; le ( ld = 0  ; ld < lc - 1 ; ld ++ ) lt ( " \x25 \x63 \x2c \x20 " , ll [ ld ] ) ; lm ( lc != 0 )  lt ( " \x25 " " \x63 " , ll [ lc - 1 ] ) ; lt ( " \x5d \n " ) ; } l0 1 ; }
>>>Func
METHOD ln
METHOD_RETURN lj
PARAM lc*lb
PARAM lc le
<operator>.lessThan ld<le-1
<operator>.postIncrement ld++
<operator>.subtraction le-1
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->6 4->1 4->1 4->5 5->1 5->1 6->1 6->4 6->4
>>>Token lj ln ( lc * lb , lc le ) { lg ( lc  ld = 0 ; ld < le - 1 ; ld ++ ) { lk lf = lo ; lg ( lc  la = 0 ; la < le - 1 - ld ; la ++ ) { lh ( lb [ la ] > lb [ la + 1 ] )  { ll ( & lb [ la ] , & lb [ la + 1 ] ) ; lf = lm ; } } lh ( ! lf )  { li ; } } }
>>>Func
METHOD l19
METHOD_RETURN lr
PARAM lr lh
PARAM lu* *lj
<operator>.assignment *le=lc
<operator>.assignment *ld=lc
IDENTIFIER la <empty>
<operator>.assignment la.lw=lc
<operator>.assignment la.lo=lx
<operator>.assignment la.l2=0
<operator>.assignment la.l10=lc
<operator>.assignment la.ly=lc
l23 l23(&lh,&lj)
l47 l47(lj[0])
l34 l34(l18,"")
l25 l25(l7,l11)
l22 l22(l7)
l33 l33(l12)
l17 l17((ls=l42(lh,lj,"\x70\x6d\x3a""\x76\x5a",l26,lc))!=-1)
BLOCK <empty> <empty>
lb lb(lt==lh)
BLOCK <empty> <empty>
lb lb(ld)
BLOCK <empty> <empty>
lb lb(la.lw||le)
BLOCK <empty> <empty>
IDENTIFIER l13 <empty>
l44 l44(lh-lt,lj+lt,l15,&la)
l45 l45(ls)
BLOCK <empty> <empty>
lv lv(0 0 lf("\x6d\x69\x73\x73\x69\x6e\x67\x20\x6f\x70\x65\x72\x61\x6e\x64"))
l1 l1(ll)
<operator>.assignment lm=0
<operator>.assignment lm=l27(ld)
<operator>.assignment lm=l40(ld)
lb lb(lm<0)
l8 l8(ll l5 lf("\x66\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x73\x65\x74\x20\x64""\x65\x66\x61\x75\x6c\x74\x20\x66\x69\x6c\x65\x20\x63\x72\x65\x61\x74""\x69\x6f\x6e\x20\x63\x6f\x6e\x74\x65\x78\x74\x20\x74\x6f\x20\x25\x73") l4(ld))
<operator>.assignment li=l6(0)
<operator>.assignment la.l14=li&~(l28|l46)
lb lb(le)
BLOCK <empty> <empty>
IDENTIFIER lk <empty>
BLOCK <empty> <empty>
l6 l6(la.lz)
<operator>.notEquals (ls=l42(lh,lj,"\x70\x6d\x3a""\x76\x5a",l26,lc))!=-1
IDENTIFIER lp <empty>
LITERAL 'p' <empty>
IDENTIFIER lq <empty>
IDENTIFIER lp <empty>
LITERAL 'm' <empty>
IDENTIFIER lq <empty>
IDENTIFIER lp <empty>
LITERAL 'v' <empty>
IDENTIFIER lq <empty>
IDENTIFIER lp <empty>
LITERAL 'Z' <empty>
IDENTIFIER lk <empty>
lb lb(l32()>0)
BLOCK <empty> <empty>
IDENTIFIER lq <empty>
IDENTIFIER l24 <empty>
l21 l21(l41,l35)
l1 l1(ll)
<operator>.equals lt==lh
<operator>.logicalOr la.lw||le
<operator>.assignment *ln=l31(le)
lb lb(!ln)
l8 l8(ll 0 lf("\x69\x6e\x76\x61\x6c\x69\x64\x20""\x6d\x6f\x64\x65\x20\x25\x73") l4(le))
<operator>.assignment la.lo=l20(lx,l37,li,ln,&la.l2)
<operator>.assignment la.lz=li&~la.lo
l16 l16(ln)
<operator>.assignment la.lo=lx
<operator>.assignment la.lz=li
<operator>.subtraction lh-lt
<operator>.addition lj+lt
<operator>.assignment ls=l42(lh,lj,"\x70\x6d\x3a""\x76\x5a",l26,lc)
<operator>.minus -1
<operator>.assignment ld=lg
IDENTIFIER lk <empty>
BLOCK <empty> <empty>
lf lf("\x6d\x69\x73\x73\x69\x6e\x67\x20\x6f\x70\x65\x72\x61\x6e\x64")
l27 l27(ld)
l40 l40(ld)
<operator>.lessThan lm<0
lf lf("\x66\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x73\x65\x74\x20\x64""\x65\x66\x61\x75\x6c\x74\x20\x66\x69\x6c\x65\x20\x63\x72\x65\x61\x74""\x69\x6f\x6e\x20\x63\x6f\x6e\x74\x65\x78\x74\x20\x74\x6f\x20\x25\x73")
l4 l4(ld)
l6 l6(0)
<operator>.and li&~(l28|l46)
l42 l42(lh,lj,"\x70\x6d\x3a""\x76\x5a",l26,lc)
<operator>.greaterThan l32()>0
<operator>.assignment la.ly=l39(l36,lc,0)
lb lb(!la.ly)
lv lv(0 l5 lf("\x77\x61""\x72\x6e\x69\x6e\x67\x3a\x20\x69\x67\x6e\x6f\x72\x69\x6e\x67\x20\x2d""\x2d\x63\x6f\x6e\x74\x65\x78\x74"))
<operator>.not ~(l28|l46)
l31 l31(le)
<operator>.logicalNot !ln
lf lf("\x69\x6e\x76\x61\x6c\x69\x64\x20""\x6d\x6f\x64\x65\x20\x25\x73")
l4 l4(le)
l20 l20(lx,l37,li,ln,&la.l2)
<operator>.and li&~la.lo
<operator>.or l28|l46
<operator>.not ~la.lo
l39 l39(l36,lc,0)
<operator>.logicalNot !la.ly
lf lf("\x77\x61""\x72\x6e\x69\x6e\x67\x3a\x20\x69\x67\x6e\x6f\x72\x69\x6e\x67\x20\x2d""\x2d\x63\x6f\x6e\x74\x65\x78\x74")
>>>PDG&105 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->36 0->39 0->40 0->41 0->42 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->67 0->70 0->71 0->72 0->73 0->74 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->92 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->102 0->104 2->12 2->88 3->12 3->13 3->88 4->1 4->1 4->39 4->64 4->94 4->97 5->1 5->1 5->22 5->81 5->82 5->85 7->1 7->64 9->1 9->1 9->27 9->98 10->1 10->1 10->27 11->1 12->1 12->1 12->1 12->27 12->63 12->73 12->74 12->88 12->88 13->1 13->1 13->27 13->74 13->88 14->1 14->1 15->1 15->1 15->16 16->1 16->1 17->1 17->1 18->1 18->1 20->1 20->1 22->1 22->81 24->1 24->1 27->1 27->1 27->1 27->1 27->1 28->1 28->1 30->1 30->1 31->1 31->36 32->1 33->1 33->1 34->1 34->1 34->83 35->1 35->1 36->1 36->1 36->1 36->1 36->67 37->1 37->1 37->87 38->1 38->1 38->1 38->27 39->1 39->94 43->1 43->1 43->27 44->1 44->1 44->18 44->18 57->1 57->1 61->1 61->1 61->1 62->31 63->20 63->20 63->73 63->73 64->1 64->24 64->24 64->27 64->39 65->1 65->1 65->95 66->1 66->1 67->1 67->1 67->1 67->1 68->1 68->1 68->101 69->1 69->1 70->1 70->1 71->1 71->1 71->1 71->27 72->1 72->1 72->43 73->1 73->27 73->27 73->74 74->1 74->1 75->1 75->28 75->44 76->44 77->1 77->1 77->22 80->30 81->33 81->82 82->34 82->85 83->1 83->35 83->35 84->36 85->1 85->36 86->37 87->1 87->38 87->38 87->98 88->1 88->27 88->44 88->44 88->44 88->44 88->44 88->63 88->74 88->75 88->75 88->75 88->75 88->75 88->102 89->1 89->57 89->57 90->1 90->1 90->103 91->1 91->1 92->1 92->1 92->36 93->1 93->87 94->65 94->97 95->66 95->98 96->67 97->1 97->67 98->1 98->1 98->68 98->68 98->68 98->68 98->68 98->70 98->71 98->99 99->1 99->69 99->69 99->72 100->1 100->1 100->93 100->93 101->99 102->1 102->1 102->90 102->90 102->90 103->1 103->27 103->91 104->92
>>>Token lr l19 ( lr lh , lu * * lj ) { lu l0 * le = lc ; lr ls ; lu l0 * ld = lc ; l9 l38 la ; la . lw = lc ; la . lo = lx ; la . l2 = 0 ; la . l10 = lc ; la . ly = lc ; l23 ( & lh , & lj ) ; l47 ( lj [ 0 ] ) ; l34 ( l18 , " " ) ; l25 ( l7 , l11 ) ; l22 ( l7 ) ; l33 ( l12 ) ; l17 ( ( ls = l42 ( lh , lj , " \x70 \x6d \x3a " " \x76 \x5a " , l26 , lc ) ) != -1 )  { l45 ( ls ) { lp ' ' : la . lw = l48 ; lq ; lp ' ' : le = lg ; lq ; lp ' ' : la . l10 = lf ( " \x63 \x72 \x65 \x61 \x74 \x65 \x64 \x20 \x64 \x69 \x72 \x65 \x63 " " \x74 \x6f \x72 \x79 \x20 \x25 \x73 " ) ; lq ; lp ' ' : lb ( l3 ( ) ) { ld = lg ; } lk lb ( l32 ( ) > 0 ) { lb ( lg ) ld = lg ; lk  { la . ly = l39 ( l36 , lc , 0 ) ; lb ( ! la . ly )  lv ( 0 , l5 , lf ( " \x77 \x61 " " \x72 \x6e \x69 \x6e \x67 \x3a \x20 \x69 \x67 \x6e \x6f \x72 \x69 \x6e \x67 \x20 \x2d " " \x2d \x63 \x6f \x6e \x74 \x65 \x78 \x74 " ) ) ; } } lk lb ( lg ) { lv ( 0 , 0 , lf ( " \x77 \x61 " " \x72 \x6e \x69 \x6e \x67 \x3a \x20 \x69 \x67 \x6e \x6f \x72 \x69 \x6e \x67 \x20 \x2d " " \x2d \x63 \x6f \x6e \x74 \x65 \x78 \x74 \x3b \x20 " " \x69 \x74 \x20 \x72 \x65 \x71 " " \x75 \x69 \x72 \x65 \x73 \x20 \x61 \x6e \x20 \x53 \x45 \x4c \x69 \x6e \x75 \x78 \x2f " " \x53 \x4d \x41 \x43 \x4b \x2d \x65 \x6e \x61 \x62 \x6c \x65 \x64 \x20 \x6b \x65 \x72 " " \x6e \x65 \x6c " ) ) ; } lq ; l24 ; l21 ( l41 , l35 ) ; l29 : l1 ( ll ) ; } } lb ( lt == lh )  { lv ( 0 , 0 , lf ( " \x6d \x69 \x73 \x73 \x69 \x6e \x67 \x20 \x6f \x70 \x65 \x72 \x61 \x6e \x64 " ) ) ; l1 ( ll ) ; } lb ( ld ) { lr lm = 0 ; lb ( l3 ( ) ) lm = l27 ( ld ) ; lk lm = l40 ( ld ) ; lb ( lm < 0 )  l8 ( ll , l5 , lf ( " \x66 \x61 \x69 \x6c \x65 \x64 \x20 \x74 \x6f \x20 \x73 \x65 \x74 \x20 \x64 " " \x65 \x66 \x61 \x75 \x6c \x74 \x20 \x66 \x69 \x6c \x65 \x20 \x63 \x72 \x65 \x61 \x74 " " \x69 \x6f \x6e \x20 \x63 \x6f \x6e \x74 \x65 \x78 \x74 \x20 \x74 \x6f \x20 \x25 \x73 " ) , l4 ( ld ) ) ; } lb ( la . lw || le )  { l43 li = l6 ( 0 ) ; la . l14 = li & ~ ( l28 | l46 ) ; lb ( le ) { l9l30 * ln = l31 ( le ) ; lb ( ! ln )  l8 ( ll , 0 , lf ( " \x69 \x6e \x76 \x61 \x6c \x69 \x64 \x20 " " \x6d \x6f \x64 \x65 \x20 \x25 \x73 " ) , l4 ( le ) ) ; la . lo = l20 ( lx , l37 , li , ln , & la . l2 ) ; la . lz = li & ~ la . lo ; l16 ( ln ) ; } lk  { la . lo = lx ; la . lz = li ; } l6 ( la . lz ) ; } l13 l44 ( lh - lt , lj + lt , l15 , & la ) ; }
>>>Func
METHOD l4
METHOD_RETURN ld
PARAM ld l6
PARAM lx* *l3
lf lf("\x25\x64",&ly)
<operator>.lessThan ln<ly
<operator>.postIncrement ln++
IDENTIFIER l7 <empty>
LITERAL 0 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token ld l4 ( ld l6 , lx * * l3 ) { ld ly , l0 , l1 , lz ; lf ( " \x25 \x64 " , & ly ) ; ld la , lc , ln , lq ; ld li [ lj ] ; le ( ln = 0  ; ln < ly ; ln ++ ) { le ( la = 0  ; la < lj ; la ++ ) { le ( lc = 0  ; lc < lj ; lc ++ ) { ls [ la ] [ lc ] = 0 ; lt [ la ] [ lc ] = 0 ; } } le ( la = 0  ; la < lj ; la ++ ) { li [ la ] = 0 ; } lf ( " \x25 " " \x64 " , & l0 ) ; lx lo , lp , lu ; le ( la = 0  ; la < l0 ; la ++ ) { lf ( " \x20 \x25 \x63 \x25 \x63 " " \x25 \x63 " , & lo , & lp , & lu ) ; ld ll = lh ( lo ) ; ld lk = lh ( lp ) ; lt [ ll ] [ lk ] = lu ; lt [ lk ] [ ll ] = lu ; } lf ( " \x25 \x64 " , & l1 ) ; le ( la = 0  ; la < l1 ; la ++ ) { lf ( " \x20 \x25 \x63 \x25 " " \x63 " , & lo , & lp ) ; ld ll = lh ( lo ) ; ld lk = lh ( lp ) ; ls [ ll ] [ lk ] = 42 ; ls [ lk ] [ ll ] = 42 ; } lf ( " \x25 \x64 \x20 " , & lz ) ; ld lb = 0 ; lx lw ; ld lm ; le ( la = 0  ; la < lz ; la ++ ) { lf ( " " " \x25 \x63 " , & lg [ lb ++ ] ) ; lm = lh ( lg [ lb - 1 ] ) ; li [ lm ] ++ ; lv ( lb > 1 )  { lv ( ( lw = lt [ lm ] [ lh ( lg [ lb - 2 ] ) ] ) )  { li [ lm ] -- ; li [ lh ( lg [ lb - 2 ] ) ] -- ; lb -= 2 ; lg [ lb ++ ] = lw ; } l2  { le ( lc = 0  ; lc < lj ; lc ++ ) { lv ( ls [ lm ] [ lc ] && li [ lc ] )  { lb = 0 ; le ( lq = 0  ; lq < lj ; lq ++ ) { li [ lq ] = 0 ; } l5 ; } } } } } lr ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , ln + 1 ) ; le ( la = 0  ; la < lb - 1 ; la ++ ) { lr ( " \x25 \x63 \x2c \x20 " , lg [ la ] ) ; } lv ( lb == 0 )  lr ( " " " \x5d \n " ) ; l2 lr ( " \x25 \x63 \x5d \n " , lg [ lb - 1 ] ) ; } l7 0 ; }
>>>Func
METHOD lw
METHOD_RETURN lq
lv lv("\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70""\x74\x30\x2e\x69\x6e","\x72",l2)
lv lv("\x41\x2d\x73\x6d\x61\x6c\x6c""\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x6f\x75\x74","\x77",l1)
<operator>.expressionList lqln la lb lh lz lc
lm lm("\x25\x64",&ln)
<operator>.lessEqualsThan lh<=ln
<operator>.postIncrement lh++
IDENTIFIER lx <empty>
LITERAL 0 <empty>
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 2->1 3->1 3->1 4->1 4->1 4->1 4->1 4->1 4->1 4->6 5->1 5->1 5->6 6->1 6->1 6->7 7->1 7->1
>>>Token lq lw ( ) { lv ( " \x41 \x2d \x73 \x6d \x61 \x6c \x6c \x2d \x61 \x74 \x74 \x65 \x6d \x70 " " \x74 \x30 \x2e \x69 \x6e " , " \x72 " , l2 ) ; lv ( " \x41 \x2d \x73 \x6d \x61 \x6c \x6c " " \x2d \x61 \x74 \x74 \x65 \x6d \x70 \x74 \x30 \x2e \x6f \x75 \x74 " , " \x77 " , l1 ) ; lqln , la , lb , lh , lz , lc ; ly lf [ 101 ] [ 101 ] ; le lp [ 101 ] , li [ 101 ] , ll [ 101 ] , lr [ 101 ] ; lm ( " \x25 \x64 " , & ln ) ; ld ( lh = 1  ; lh <= ln ; lh ++ ) { lo ( " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a " , lh ) ; lm ( " \n \x25 \x64 " , & lc ) ; ld ( la = 0  ; la < lc ; la ++ ) { lm ( " \n " ) ; ld ( lb = 0  ; lb < lc ; lb ++ ) lm ( " \x25 \x63 " , & lf [ la ] [ lb ] ) ; } lq lg [ lu ] , lk [ lu ] ; ld ( la = 0  ; la < lc ; la ++ ) { lk [ la ] = lg [ la ] = 0 ; ld ( lb = 0  ; lb < lc ; lb ++ ) { lj ( la == lb ) ls ; lj ( lf [ la ] [ lb ] != ' ' ) lg [ la ] ++ ; lj ( lf [ la ] [ lb ] == ' ' ) lk [ la ] ++ ; } lp [ la ] = ( ( le ) lk [ la ] ) / ( ( le ) lg [ la ] ) ; } le lt , l0 [ lu ] ; ld ( la = 0  ; la < lc ; la ++ ) { li [ la ] = 0 ; ld ( lb = 0  ; lb < lc ; lb ++ ) { lj ( la == lb || lf [ la ] [ lb ] == ' ' ) ls ; lt = ( ( le ) ( lk [ lb ] - ( lf [ lb ] [ la ] - ' ' ) ) ) / ( ( le ) ( lg [ lb ] - 1 ) ) ; li [ la ] += lt ; } li [ la ] /= ( ( le ) ( lg [ la ] ) ) ; } ld ( la = 0  ; la < lc ; la ++ ) { ll [ la ] = 0 ; ld ( lb = 0  ; lb < lc ; lb ++ ) { lj ( la == lb || lf [ la ] [ lb ] == ' ' ) ls ; ll [ la ] += li [ lb ] ; } ll [ la ] /= ( ( le ) ( lg [ la ] ) ) ; lr [ la ] = 0.25000000 * lp [ la ] + 0.50000000 * li [ la ] + 0.25000000 * ll [ la ] ; lo ( " \n \x25 \x30 \x2e \x31 \x32 \x6c " " \x66 " , lr [ la ] ) ; } lj ( lh < ln )  lo ( " \n " ) ; } lx 0 ; }
>>>Func
METHOD le
METHOD_RETURN lf
PARAM lc*la
PARAM lc*lb
ld ld(!( *la%2)&&!( *lb%2))
BLOCK <empty> <empty>
ld ld(!( *la%5)&&!( *lb%5))
BLOCK <empty> <empty>
<operator>.assignmentDivision *la/=2
<operator>.assignmentDivision *lb/=2
<operator>.assignmentDivision *la/=5
<operator>.assignmentDivision *lb/=5
<operator>.logicalAnd !( *la%2)&&!( *lb%2)
<operator>.logicalAnd !( *la%5)&&!( *lb%5)
<operator>.logicalNot !( *la%2)
<operator>.logicalNot !( *lb%2)
<operator>.logicalNot !( *la%5)
<operator>.logicalNot !( *lb%5)
<operator>.modulo *la%2
<operator>.modulo *lb%2
<operator>.modulo *la%5
<operator>.modulo *lb%5
<operator>.indirection *lb
<operator>.indirection *lb
>>>PDG&24 0->2 0->3 0->5 0->7 0->8 0->9 0->10 0->11 0->18 0->19 0->20 0->21 2->1 3->1 4->1 4->1 6->1 6->1 8->1 8->20 9->1 9->11 9->21 10->1 10->1 11->1 11->1 12->1 12->1 12->4 12->4 13->1 13->1 13->6 13->6 14->1 14->12 14->15 14->19 14->22 15->1 15->12 16->1 16->13 16->17 16->21 16->23 17->1 17->13 18->8 18->14 18->14 19->9 19->15 19->15 20->10 20->16 20->16 21->11 21->17 21->17
>>>Token lf le ( lc * la , lc * lb ) { ld ( ! ( * la % 2 ) && ! ( * lb % 2 ) ) { * la /= 2 ; * lb /= 2 ; } ld ( ! ( * la % 5 ) && ! ( * lb % 5 ) )  { * la /= 5 ; * lb /= 5 ; } }
>>>Func
METHOD l1
METHOD_RETURN lr
<operator>.expressionList l7lk lo lb ln lm
<operator>.assignment lw=lv(l2,"\x72",l10)
<operator>.assignment lu=lv(lz,"\x77",l8)
lt lt("\x25\x64",&ls)
<operator>.lessThan lg<ls
<operator>.postIncrement lg++
IDENTIFIER l9 <empty>
LITERAL 0 <empty>
lv lv(l2,"\x72",l10)
lv lv(lz,"\x77",l8)
>>>PDG&12 0->2 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->1 2->1 2->1 2->1 2->1 2->1 3->1 3->1 3->1 4->1 4->1 4->1 5->1 5->1 5->6 6->1 6->1 6->7 7->1 7->1 10->1 10->1 10->3 10->3 10->3 11->1 11->1 11->4 11->4 11->4
>>>Token lr l1 ( ) { l6 * lw , * lu ; lr ls , lg , la , ld , li , le [ lx ] , lc [ lx ] ; lr lp , lh , lf , lj ; l7lk , lo , lb , ln , lm ; lw = lv ( l2 , " \x72 " , l10 ) ; lu = lv ( lz , " \x77 " , l8 ) ; lt ( " \x25 \x64 " , & ls ) ; lq ( lg = 0  ; lg < ls ; lg ++ ) { lp = 0 ; lt ( " \x25 \x64 \x25 \x64 " , & ld , & lj ) ; lq ( la = 0  ; la < ld ; la ++ ) { lt ( " \x25 \x64 \x25 \x64 " , & le [ la ] , & lc [ la ] ) ; lp += lc [ la ] ; } lk = 0 ; lo = lp * lj ; lq ( li = 0  ; li < 65 ; li ++ ) { lb = ( lk + lo ) / 2.0 ; la = ld - 1 ; lm = le [ ld - 1 ] + lb ; lf = lc [ la ] - 1 ; lh = 1 ; l5 ( lh && la >= 0 )  { ll ( lf == 0 ) { la -- ; ll ( la < 0 ) ly ; lf = lc [ la ] ; } ln = lm - lj ; ll ( le [ la ] - lb > ln )  { lh = 0 ; ly ; } lm = l3 ( ln , le [ la ] + lb ) ; lf -- ; } ll ( lh ) lo = lb ; l0 lk = lb ; } l4 ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x2e \x37 " " \x6c \x66 \n " , lg + 1 , lb ) ; } l9 0 ; }
>>>Func
METHOD lq
METHOD_RETURN li
PARAM lr
lk lk("\x25\x64",&lj)
<operator>.lessEqualsThan lb<=lj
<operator>.preIncrement ++lb
lo lo(0)
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1 6->1
>>>Token li lq ( lr ) { li lj , lb ; li lh , ld ; lf la ; lf le ; lf lc ; lf lg ; lk ( " \x25 \x64 " , & lj ) ; ll ( lb = 1  ; lb <= lj ; ++ lb ) { le = 0 ; lc = ls ; lg = 0 ; lk ( " \x25 \x64 " , & lh ) ; ll ( ld = 1  ; ld <= lh ; ++ ld ) { lk ( " \x25 \x6c \x64 " , & la ) ; le += la ; lm ( la < lc )  { lc = la ; } lg ^= la ; } lm ( 0 == lg )  { ln ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , lb , le - lc ) ; } lp  { ln ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , lb ) ; } } lo ( 0 ) ; }
>>>Func
METHOD lr
METHOD_RETURN ld
PARAM lo*lg
PARAM lw*lf
<operator>.assignment lh=-1
<operator>.assignment lp=-1
<operator>.assignment lb=lu(lf,"\x72")
lv lv(lb==lx)
BLOCK <empty> <empty>
lk lk("\x52\x65\x61\x64\x69""\x6e\x67\x20\x69\x6e\x70\x75\x74\x20\x66\x72\x6f\x6d\x20\x25\x73\n",lf)
li li(lb,"\x25\x64",&le)
<operator>.assignment lh=le
<operator>.lessThan la<le
<operator>.postIncrement la++
lk lk("\x25\x64\x20\x63\x61\x73\x65\x73\x20\x77\x65\x72""\x65\x20\x72\x65\x61\x64\n",lh)
lq lq(ln,"\x63\x61\x6e\x6e\x6f\x74\x20\x6f\x70\x65\x6e\x20""\x66\x69\x6c\x65\x20\x25\x73\n",lf)
<operator>.subtraction lj-1
<operator>.minus -1
<operator>.minus -1
lu lu(lf,"\x72")
<operator>.equals lb==lx
>>>PDG&21 0->2 0->3 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 2->1 3->19 4->1 5->1 5->1 5->1 6->1 6->1 6->20 7->1 7->1 9->1 9->1 10->1 10->1 10->1 10->11 10->12 11->1 11->14 12->1 12->1 12->13 13->1 13->1 14->1 14->1 15->1 15->1 15->9 16->1 16->1 17->4 18->5 19->6 19->6 19->15 20->1 20->7 20->7 20->10
>>>Token ld lr ( lo * lg , lw * lf ) { lt * lb ; ld lh = -1 ; ld lp = -1 ; ld le , la , lc ; lb = lu ( lf , " \x72 " ) ; lv ( lb == lx )  { lq ( ln , " \x63 \x61 \x6e \x6e \x6f \x74 \x20 \x6f \x70 \x65 \x6e \x20 " " \x66 \x69 \x6c \x65 \x20 \x25 \x73 \n " , lf ) ; lj - 1 ; } lk ( " \x52 \x65 \x61 \x64 \x69 " " \x6e \x67 \x20 \x69 \x6e \x70 \x75 \x74 \x20 \x66 \x72 \x6f \x6d \x20 \x25 \x73 \n " , lf ) ; li ( lb , " \x25 \x64 " , & le ) ; lh = le ; lm ( la = 0  ; la < le ; la ++ ) { li ( lb , " \x20 \x25 " " \x64 " , & lg [ la ] . ll ) ; lm ( lc = 0  ; lc < lg [ la ] . ll ; lc ++ ) li ( lb , " \x20 \x25 \x64 " , & lg [ la ] . ls [ lc ] ) ; } lk ( " \x25 \x64 \x20 \x63 \x61 \x73 \x65 \x73 \x20 \x77 \x65 \x72 " " \x65 \x20 \x72 \x65 \x61 \x64 \n " , lh ) ; lj lh ; }
>>>Func
METHOD lw
METHOD_RETURN lj
<operator>.assignment ls=0
lr lr("\x25\x64",&lo)
lx lx(lo--)
BLOCK <empty> <empty>
IDENTIFIER ly <empty>
LITERAL 0 <empty>
<operator>.assignment ln=0
<operator>.assignment ll=1000000000000.0
lr lr("\x25\x64\x20\x25\x64",&le,&lp)
<operator>.assignment lg=(lc)lp
<operator>.lessThan la<le
<operator>.postIncrement la++
l2 l2(lb le l0(lv),l1)
<operator>.lessThan ld<2* (lc)lb[le-1].li
<operator>.assignmentPlus ld+=0.5
lz lz("\x43\x61\x73\x65""\x20\x23\x25\x64\x3a\x20\x25\x2e\x31\x32\x66\n",++ls,ll)
<operator>.postDecrement lo--
<operator>.cast (lc)lp
l0 l0(lv)
<operator>.multiplication 2* (lc)lb[le-1].li
<operator>.preIncrement ++ls
<operator>.cast (lc)lb[le-1].li
<operator>.subtraction le-1
>>>PDG&25 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 2->1 2->22 3->1 3->1 3->18 4->1 4->1 8->1 8->1 9->1 9->17 10->1 10->1 10->1 10->11 10->12 10->14 10->19 10->24 11->1 11->1 11->1 12->1 12->13 12->14 13->1 13->1 14->1 14->1 14->1 14->1 14->24 15->1 15->1 15->16 16->1 16->1 17->1 17->1 17->1 18->1 18->4 19->1 20->1 20->14 21->1 21->15 21->15 22->1 22->17 23->1 24->1
>>>Token lj lw ( ) { lj lo , ls = 0 ; lr ( " \x25 \x64 " , & lo ) ; lx ( lo -- )  { lj le , lp , ln = 0 ; lc lg , lf , ll = 1000000000000.0 ; lj la , lk ; lc ld , lh ; lr ( " \x25 \x64 \x20 \x25 \x64 " , & le , & lp ) ; lg = ( lc ) lp ; lm ( la = 0  ; la < le ; la ++ ) { lr ( " \x25 \x64 \x20 \x25 \x64 " , & lb [ la ] . li , & lb [ la ] . lq ) ; ln += lb [ la ] . lq ; } l2 ( lb , le , l0 ( lv ) , l1 ) ; lm ( ld = ( lc ) lb [ 0 ] . li - ( lc ) ln * lg  ; ld < 2 * ( lc ) lb [ le - 1 ] . li ; ld += 0.5 ) { lf = 0 ; lh = 0 ; lm ( la = 0  ; la < le ; la ++ ) lm ( lk = 0 ; lk < lb [ la ] . lq ; lk ++ , lh += 1 ) lu ( lt ( ( lc ) lb [ la ] . li - ( ld + lh * lg ) ) > lf ) lf = lt ( ( lc ) lb [ la ] . li - ( ld + lh * lg ) ) ; lu ( lf < ll ) ll = lf ; } lz ( " \x43 \x61 \x73 \x65 " " \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x2e \x31 \x32 \x66 \n " , ++ ls , ll ) ; } ly 0 ; }
>>>Func
METHOD l5
METHOD_RETURN lt
<operator>.assignment *le=l1("\x69\x6e\x2e\x69\x6e","\x72")
<operator>.assignment *ll=l1("\x6f\x75""\x74\x2e\x74\x78\x74","\x77")
lu lu(le,"\x25""\x64",&lz)
<operator>.lessThan ln<lz
<operator>.postIncrement ln++
IDENTIFIER l6 <empty>
LITERAL 0 <empty>
l1 l1("\x69\x6e\x2e\x69\x6e","\x72")
l1 l1("\x6f\x75""\x74\x2e\x74\x78\x74","\x77")
>>>PDG&11 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 2->4 3->1 3->1 3->1 4->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1 9->2 9->2 10->3 10->3
>>>Token lt l5 ( ) { l3 * le = l1 ( " \x69 \x6e \x2e \x69 \x6e " , " \x72 " ) ; l3 * ll = l1 ( " \x6f \x75 " " \x74 \x2e \x74 \x78 \x74 " , " \x77 " ) ; lt ln , la , lb , lf , lc ; lt lz , lq , lr , lv ; lo lg ; lo lk [ l8 ] [ 3 ] ; lo lm [ l7 ] [ 3 ] ; lo ly [ l2 ] ; lo ld [ l2 ] ; lt lp , lx ; lu ( le , " \x25 " " \x64 " , & lz ) ; lh ( ln = 0  ; ln < lz ; ln ++ ) { lu ( le , " \x25 \x64 " , & lq ) ; li ( lq != 0 )  { lh ( la = 0  ; la < lq ; la ++ ) { lg = lj ( le ) ; l0 ( lg == ' ' ) lg = lj ( le ) ; lh ( lb = 0  ; lb < 3 ; lb ++ ) { lk [ la ] [ lb ] = lg ; lg = lj ( le ) ; } } } lu ( le , " \x25 \x64 " , & lr ) ; li ( lr != 0 )  { lh ( la = 0  ; la < lr ; la ++ ) { lg = lj ( le ) ; l0 ( lg == ' ' ) lg = lj ( le ) ; lh ( lb = 0  ; lb < 2 ; lb ++ ) { lm [ la ] [ lb ] = lg ; lg = lj ( le ) ; } } } li ( lu ( le , " \x25 \x64 " , & lv ) )  { lg = lj ( le ) ; lh ( la = 0  ; la < lv ; la ++ ) { ly [ la ] = lj ( le ) ; } } lb = 0 ; lh ( la = 0  ; la < lv ; la ++ ) { ld [ lb ] = ly [ la ] ; lp = 0 ; lx = 0 ; lh ( lf = lb - 1  ; lf < lb ; lf ++ ) { lh ( lc = 0  ; lc < lq ; lc ++ ) { li ( ( lk [ lc ] [ 1 ] == ld [ lb ] && lk [ lc ] [ 0 ] == ld [ lf ] ) || ( lk [ lc ] [ 0 ] == ld [ lb ] && lk [ lc ] [ 1 ] == ld [ lf ] ) )  { ld [ lf ] = lk [ lc ] [ 2 ] ; lb = lf ; lp = 1 ; lw ; } } li ( lp == 1 ) lw ; } li ( lp == 0 )  { lh ( lf = 0  ; lf < lb ; lf ++ ) { lh ( lc = 0  ; lc < lr ; lc ++ ) { li ( ( lm [ lc ] [ 0 ] == ld [ lb ] && lm [ lc ] [ 1 ] == ld [ lf ] ) || ( lm [ lc ] [ 1 ] == ld [ lb ] && lm [ lc ] [ 0 ] == ld [ lf ] ) )  { lb = -1 ; lx = 1 ; lw ; } } li ( lx == 1 ) lw ; } } lb ++ ; } ld [ lb ] = ' \0 ' ; la = 0 ; ls ( ll , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , ln + 1 ) ; li ( ld [ la ] == ' \0 ' )  { ls ( ll , " \x5d \n " ) ; l9 ; } l4 ls ( ll , " \x25 \x63 " , ld [ la ++ ] ) ; l0 ( ld [ la ] != ' \0 ' )  { ls ( ll , " \x2c \x20 \x25 \x63 " , ld [ la ++ ] ) ; } ls ( ll , " \x5d " " \n " ) ; } l6 0 ; }
>>>Func
METHOD ll
METHOD_RETURN lk
<operator>.assignment lc=lj("\x61\x2e\x74\x78\x74","\x72")
lg lg(lc==lh)
le le("\n\x65\x72""\x72\x6f\x72\x20\x69\x6e\x70\x75\x74\x20\x66\x69\x6c\x65\n")
<operator>.assignment lb=lj("""\x6f\x75\x74\x70\x75\x74","\x77")
lg lg(lb==lh)
le le("\n\x45\x52\x52\x4f""\x52\x20\x2d\x6f\x75\x74\x70\x75\x74\x20\x66\x69\x6c\x65\n")
<operator>.assignment ld=0
lp lp(lc,"\x25\x64",&ld)
<operator>.lessThan la<ld
<operator>.postIncrement la++
lf lf(lb,"\n")
li li(lc)
li li(lb)
IDENTIFIER ln <empty>
LITERAL 0 <empty>
lj lj("\x61\x2e\x74\x78\x74","\x72")
<operator>.equals lc==lh
lj lj("""\x6f\x75\x74\x70\x75\x74","\x77")
<operator>.equals lb==lh
>>>PDG&21 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 2->1 2->1 2->18 3->1 3->1 4->1 5->1 5->1 5->20 6->1 6->1 7->1 8->1 8->9 8->10 9->1 9->1 9->10 9->13 10->1 10->1 10->11 11->1 11->1 12->1 12->14 13->1 13->1 14->1 14->1 17->2 17->2 18->3 18->3 18->9 18->20 19->5 19->5 20->1 20->6 20->6 20->12
>>>Token lk ll ( ) { lc = lj ( " \x61 \x2e \x74 \x78 \x74 " , " \x72 " ) ; lg ( lc == lh )  le ( " \n \x65 \x72 " " \x72 \x6f \x72 \x20 \x69 \x6e \x70 \x75 \x74 \x20 \x66 \x69 \x6c \x65 \n " ) ; lb = lj ( " " " \x6f \x75 \x74 \x70 \x75 \x74 " , " \x77 " ) ; lg ( lb == lh )  le ( " \n \x45 \x52 \x52 \x4f " " \x52 \x20 \x2d \x6f \x75 \x74 \x70 \x75 \x74 \x20 \x66 \x69 \x6c \x65 \n " ) ; lk ld , la ; ld = 0 ; lp ( lc , " \x25 \x64 " , & ld ) ; lo ( la = 0  ; la < ld ; la ++ ) { le ( " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , la + 1 ) ; lf ( lb , " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a \x20 " , la + 1 ) ; lm ( ) ; le ( " \n " ) ; lf ( lb , " \n " ) ; } lf ( lb , " \n " ) ; li ( lc ) ; li ( lb ) ; ln 0 ; }
>>>Func
METHOD lr
METHOD_RETURN ll
PARAM ls
ld ld("""\x25\x64",&ln)
<operator>.lessThan le<ln
<operator>.postIncrement le++
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token ll lr ( ls ) { ll ln , lh , lg ; la * * lk ; la * * lj ; la * lb ; la * lo ; ll lc , le , lp ; ld ( " " " \x25 \x64 " , & ln ) ; lm ( le = 0  ; le < ln ; le ++ ) { ld ( " \x25 \x64 " , & lh ) ; lk = ( la * * ) li ( lf ( la *  ) * lh ) ; lm ( lc = 0  ; lc < lh ; lc ++ ) { lb = ( la * ) li ( lf ( la ) * 3 ) ; ld ( " \x25 \x73 " , lb ) ; lk [ lc ] = lb ; } ld ( " \x25 \x64 " , & lg ) ; lj = ( la * * ) li ( lf ( la *  ) * lg ) ; lm ( lc = 0  ; lc < lg ; lc ++ ) { lb = ( la * ) li ( lf ( la ) * 2 ) ; ld ( " \x25 \x73 " , lb ) ; lj [ lc ] = lb ; } ld ( " " " \x25 \x64 " , & lp ) ; lb = ( la * ) li ( lf ( la ) * lt ) ; ld ( " \x25 \x73 " , lb ) ; lo = lb ; lq ( le , lk , lh , lj , lg , lo ) ; } }
>>>Func
METHOD lp
METHOD_RETURN lk
PARAM lt
ll ll("\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d""\x70\x74\x30\x2e\x69\x6e","\x72",lv)
ll ll("\x67\x63\x6a\x5f\x32\x2e""\x6f\x75\x74","\x77",lu)
lb lb("\x25\x64",&lg)
<operator>.lessEqualsThan lc<=lg
<operator>.postIncrement lc++
IDENTIFIER lq <empty>
LITERAL 0 <empty>
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 3->1 3->1 4->1 4->1 5->1 5->1 5->6 6->1 6->1 6->7 7->1 7->1
>>>Token lk lp ( lt ) { ll ( " \x42 \x2d \x73 \x6d \x61 \x6c \x6c \x2d \x61 \x74 \x74 \x65 \x6d " " \x70 \x74 \x30 \x2e \x69 \x6e " , " \x72 " , lv ) ; ll ( " \x67 \x63 \x6a \x5f \x32 \x2e " " \x6f \x75 \x74 " , " \x77 " , lu ) ; lk lg , lc , la ; lb ( " \x25 \x64 " , & lg ) ; le ( lc = 1  ; lc <= lg ; lc ++ ) { lb ( " \x25 \x64 " , & lh ) ; le ( la = 0  ; la < lh ; la ++ ) lb ( " \x25 \x73 " , li [ la ] ) ; lb ( " \x25 \x64 " , & lf ) ; le ( la = 0  ; la < lf ; la ++ ) lb ( " \x25 \x73 " , lj [ la ] ) ; lb ( " \x25 " " \x64 " , & ls ) ; lb ( " \x25 \x73 " , lr ) ; ld ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 " " \x3a \x20 " , lc ) ; lo ( ) ; 0 < ln ' ' > ld ( " \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d " " \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \n " ) ; le ( la = 0  ; la < lh ; la ++ ) ld ( " \x25 \x73 \n " , li [ la ] ) ; le ( la = 0  ; la < lf ; la ++ ) ld ( " \x25 \x73 \n " , lj [ la ] ) ; ld ( " \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d " " \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \n " ) ; lm } lq 0 ; }
>>>Func
METHOD ly
METHOD_RETURN lt
PARAM lk ls
lo lo("\x25\x64\n",&ld)
<operator>.lessThan la<ld
<operator>.postIncrement la++
<operator>.lessThan la<ld
<operator>.postIncrement la++
<operator>.lessThan lb<ld
<operator>.postIncrement lb++
<operator>.lessThan lb<ld
<operator>.postIncrement lb++
lu lu(ls+1)
<operator>.addition ls+1
>>>PDG&14 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->12 2->13 3->1 3->1 3->4 3->6 3->8 3->10 4->5 4->6 5->6 6->1 6->7 6->8 7->1 7->1 8->9 8->10 9->10 10->1 10->1 10->11 11->1 11->1 12->1 12->1 13->1
>>>Token lt ly ( lk ls ) { lo ( " \x25 \x64 \n " , & ld ) ; lk la , lc ; lg ( la = 0  ; la < ld ; la ++ ) { lg ( lc = 0  ; lc < ld ; lc ++ ) { lx lw ; lf ( lc == ld - 1 )  lo ( " \x25 \x63 \n " , & li [ la ] [ lc ] ) ; lp lo ( " " " \x25 \x63 " , & li [ la ] [ lc ] ) ; } } lg ( la = 0  ; la < ld ; la ++ ) { lk lj = 0 ; lk lm = 0 ; lg ( lc = 0  ; lc < ld ; lc ++ ) { lf ( li [ la ] [ lc ] != ' ' && lc != la )  { lj ++ ; lf ( li [ la ] [ lc ] == ' ' ) lm ++ ; } } lf ( lj > 0 ) lr [ la ] = ( le ) lm / ( le ) lj ; lp lr [ la ] = 0.0 ; } lk lb , lh ; lg ( lb = 0  ; lb < ld ; lb ++ ) { le ln = 0.0 ; le ll = 0.0 ; lg ( lh = 0  ; lh < ld ; lh ++ ) { lf ( lb != lh && li [ lh ] [ lb ] != ' ' )  { lk lj = 0 ; lk lm = 0 ; lg ( la = 0  ; la < ld ; la ++ ) { lf ( li [ lh ] [ la ] != ' ' && la != lb )  { lj ++ ; lf ( li [ lh ] [ la ] == ' ' ) lm ++ ; } } ln += ( le ) lm / ( le ) lj ; ll += 1 ; } } lf ( ll > 0 ) lq [ lb ] = ln / ( ll ) ; lp lq [ lb ] = 0.0 ; } lg ( lb = 0  ; lb < ld ; lb ++ ) { le ln = 0.0 ; le ll = 0.0 ; lg ( la = 0  ; la < ld ; la ++ ) { lf ( la != lb && li [ la ] [ lb ] != ' ' )  { ln += lq [ la ] ; ll += 1.0 ; } } lv [ lb ] = ln / ( le ) ( ll ) ; } lu ( ls + 1 ) ; }
>>>Func
METHOD lk
METHOD_RETURN lh
PARAM li* *le
PARAM lc ld
<operator>.lessThan la<ld
<operator>.postIncrement la++
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token lh lk ( li * * le , lc ld ) { lf ( lc  la = 0 ; la < ld ; la ++ ) { lf ( lc  lb = 0 ; lb < ld ; lb ++ ) { lj ( " \x25 \x20 \x33 \x2e \x33 \x67 \x20 \t " , le [ la ] [ lb ] ) ; } lg ( ' \n ' ) ; } }
>>>Func
METHOD l3
METHOD_RETURN lw
PARAM l7
ln ln(!(le=l0("\x42\x2e\x69\x6e","\x72")))
BLOCK <empty> <empty>
<operator>.assignment li=l0("\x42\x2e\x6f\x75\x74","\x77\x2b")
<operator>.expressionList lwlm la lc ll lx
lj lj(le,"\x25\x64\n",&lx)
<operator>.lessThan lm<lx
<operator>.postIncrement lm++
lz lz(le)
lz lz(li)
l6 l6("\x45""\x52\x52\x4f\x52\x3a\x20\x6e\x6f\x20\x69\x6e\x70\x75\x74\x20\x66\x69""\x6c\x65\x2e\n")
<operator>.logicalNot !(le=l0("\x42\x2e\x69\x6e","\x72"))
l0 l0("\x42\x2e\x6f\x75\x74","\x77\x2b")
<operator>.assignment le=l0("\x42\x2e\x69\x6e","\x72")
l0 l0("\x42\x2e\x69\x6e","\x72")
>>>PDG&17 0->2 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->16 2->1 3->1 3->1 5->1 5->1 5->11 6->1 6->1 6->1 6->1 6->1 6->7 6->8 7->1 7->1 7->8 7->10 8->1 8->1 8->9 9->1 9->1 10->1 10->1 11->1 11->1 12->1 13->1 13->3 14->5 14->5 15->1 15->7 15->13 16->13 16->13 16->15 16->15
>>>Token lw l3 ( l7 ) { l5 * le , * li ; ln ( ! ( le = l0 ( " \x42 \x2e \x69 \x6e " , " \x72 " ) ) )  { l6 ( " \x45 " " \x52 \x52 \x4f \x52 \x3a \x20 \x6e \x6f \x20 \x69 \x6e \x70 \x75 \x74 \x20 \x66 \x69 " " \x6c \x65 \x2e \n " ) ; ly l1 ; } li = l0 ( " \x42 \x2e \x6f \x75 \x74 " , " \x77 \x2b " ) ; lwlm , la , lc , ll , lx ; lq lk , lp , lo ; lq lf [ 36 ] [ 3 ] ; lq lh [ 28 ] [ 3 ] ; lq lv [ 100 ] ; lq ld [ 100 ] ; lw lt , lu , ls , lb ; lj ( le , " \x25 \x64 \n " , & lx ) ; lg ( lm = 0  ; lm < lx ; lm ++ ) { lr ( li , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lm + 1 ) ; lj ( le , " \x25 " " \x64 \x20 " , & ls ) ; lg ( la = 0  ; la < ls ; la ++ ) { lj ( le , " \x25 \x63 \x25 \x63 \x25 \x63 " " \x20 " , & lk , & lp , & lo ) ; lf [ la ] [ 0 ] = lk ; lf [ la ] [ 1 ] = lp ; lf [ la ] [ 2 ] = lo ; } lj ( le , " " " \x25 \x64 \x20 " , & lt ) ; lg ( la = 0  ; la < lt ; la ++ ) { lj ( le , " \x25 \x63 \x25 \x63 \x25 " " \x63 \x20 " , & lk , & lp , & lo ) ; lh [ la ] [ 0 ] = lk ; lh [ la ] [ 1 ] = lp ; lh [ la ] [ 2 ] = lo ; } lj ( le , " \x25 \x64 \x20 " , & lu ) ; lg ( la = 0  ; la < lu ; la ++ ) { lj ( le , " \x25 \x63 " , & lk ) ; lv [ la ] = lk ; } lb = 0 ; lg ( la = 0  ; la < lu ; la ++ ) { ld [ lb ] = lv [ la ] ; lb ++ ; ln ( lb > 1 )  { lg ( lc = 0  ; lc < ls ; lc ++ ) { ln ( ( ld [ lb - 1 ] == lf [ lc ] [ 0 ] && ld [ lb - 2 ] == lf [ lc ] [ 1 ] ) || ( ld [ lb - 1 ] == lf [ lc ] [ 1 ] && ld [ lb - 2 ] == lf [ lc ] [ 0 ] ) )  { lb -- ; ld [ lb - 1 ] = lf [ lc ] [ 2 ] ; lc = -1 ; } } lg ( lc = 0  ; lc < lt ; lc ++ ) { lg ( ll = 0  ; ll < ( lb - 1 ) ; ll ++ ) { ln ( ( ld [ lb - 1 ] == lh [ lc ] [ 0 ] && ld [ ll ] == lh [ lc ] [ 1 ] ) || ( ld [ lb - 1 ] == lh [ lc ] [ 1 ] && ld [ ll ] == lh [ lc ] [ 0 ] ) )  { lb = 0 ; l4 ; } } } } } lg ( la = 0  ; la < lb ; la ++ ) { lr ( li , " \x25 \x63 " , ld [ la ] ) ; ln ( la != ( lb - 1 ) )  { lr ( li , " " " \x2c \x20 " ) ; } } lr ( li , " \x5d \n " ) ; } lz ( le ) ; lz ( li ) ; ly l2 ; }
>>>Func
METHOD lx
METHOD_RETURN ls
<operator>.assignment lk=l0("\x6f""\x75\x74\x2e\x74\x78\x74","\x77\x2b")
ln ln("\x25\x64",&lt)
<operator>.lessEqualsThan la<=lt
<operator>.postIncrement la++
<operator>.lessEqualsThan la<=lt
<operator>.postIncrement la++
l1 l1(lk)
IDENTIFIER lz <empty>
LITERAL 0 <empty>
l0 l0("\x6f""\x75\x74\x2e\x74\x78\x74","\x77\x2b")
>>>PDG&12 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->1 2->1 2->8 3->1 3->1 3->4 3->6 4->5 4->6 5->6 6->1 6->1 6->7 7->1 7->1 8->1 8->1 11->2 11->2
>>>Token ls lx ( ) { lw * ly , * lk ; ls la , lb , lc , lj , lm , lt ; ls lq , lr ; ls li ; lk = l0 ( " \x6f " " \x75 \x74 \x2e \x74 \x78 \x74 " , " \x77 \x2b " ) ; ln ( " \x25 \x64 " , & lt ) ; lh ( la = 1  ; la <= lt ; la ++ ) { lv lf [ 4 ] ; lv ll [ 3 ] ; li = lq = lr = 0 ; ln ( " \x25 \x64 \x20 " , & lq ) ; lg ( lq ) { ln ( " \x25 \x63 \x25 \x63 \x25 \x63 " , & lf [ 1 ] , & lf [ 2 ] , & lf [ 3 ] ) ; } ln ( " \x25 \x64 \x20 " , & lr ) ; lg ( lr ) { ln ( " \x25 \x63 \x25 \x63 " , & ll [ 1 ] , & ll [ 2 ] ) ; } ln ( " \x25 \x64 \x20 " , & le [ la ] ) ; lh ( lb = 1  ; lb <= le [ la ] ; lb ++ ) { ln ( " \x25 \x63 " , & ld [ la ] [ lb ] ) ; } lh ( lb = 1  ; lb <= le [ la ] ; lb ++ ) { lg ( ld [ la ] [ lb ] == lf [ 1 ] )  { lg ( ld [ la ] [ lb + 1 ] == lf [ 2 ] )  { ld [ la ] [ lb + 1 ] = lf [ 3 ] ; lh ( lc = lb + 1  ; lc <= le [ la ] ; lc ++ ) { ld [ la ] [ lc - 1 ] = ld [ la ] [ lc ] ; } lb = 0 ; le [ la ] -= 1 ; li = 1 ; } } lo lg ( ld [ la ] [ lb ] = = lf [ 2 ] ) { lg ( ld [ la ] [ lb + 1 ] == lf [ 1 ] )  { ld [ la ] [ lb + 1 ] = lf [ 3 ] ; lh ( lc = lb + 1  ; lc <= le [ la ] ; lc ++ ) { ld [ la ] [ lc - 1 ] = ld [ la ] [ lc ] ; } lb = 0 ; le [ la ] -= 1 ; li = 1 ; } } lo lg ( ld [ la ] [ lb + 1 ] = = lf [ 1 ] ) { lg ( ld [ la ] [ lb + 2 ] == lf [ 2 ] )  { ld [ la ] [ lb + 2 ] = lf [ 3 ] ; lh ( lc = lb + 2  ; lc <= le [ la ] ; lc ++ ) { ld [ la ] [ lc - 1 ] = ld [ la ] [ lc ] ; } lb = 0 ; le [ la ] -= 1 ; li = 1 ; } } lo lg ( ld [ la ] [ lb + 1 ] = = lf [ 2 ] ) { lg ( ld [ la ] [ lb + 2 ] == lf [ 1 ] )  { ld [ la ] [ lb + 2 ] = lf [ 3 ] ; lh ( lc = lb + 2  ; lc <= le [ la ] ; lc ++ ) { ld [ la ] [ lc - 1 ] = ld [ la ] [ lc ] ; } lb = 0 ; le [ la ] -= 1 ; li = 1 ; } } lg ( ! li )  { lg ( ld [ la ] [ lb ] == ll [ 1 ] )  { lh ( lc = lb + 1  ; lc <= lb + 2 ; lc ++ ) { lg ( ld [ la ] [ lc ] == ll [ 2 ] )  { lh ( lj = lc + 1 , lm = lb  ; lj <= le [ la ] ; lj ++ , lm ++ ) { ld [ la ] [ lm ] = ld [ la ] [ lj ] ; } le [ la ] = le [ la ] - ( lc - lb + 1 ) ; lb = 0 ; li = 1 ; lu ; } } } lo lg ( ld [ la ] [ lb ] = = ll [ 2 ] ) { lh ( lc = lb + 1  ; lc <= lb + 2 ; lc ++ ) { lg ( ld [ la ] [ lc ] == ll [ 1 ] )  { lh ( lj = lc + 1 , lm = lb  ; lj <= le [ la ] ; lj ++ , lm ++ ) { ld [ la ] [ lm ] = ld [ la ] [ lj ] ; } le [ la ] = le [ la ] - ( lc - lb + 1 ) ; lb = 0 ; li = 1 ; lu ; } } } } } } lh ( la = 1  ; la <= lt ; la ++ ) { lp ( lk , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , la ) ; lp ( lk , " \x5b " ) ; lh ( lb = 1  ; lb <= le [ la ] ; lb ++ ) { lg ( lb == le [ la ] )  lp ( lk , " \x25 \x63 " , ld [ la ] [ lb ] ) ; lo lp ( lk , " \x25 \x63 \x2c \x20 " , ld [ la ] [ lb ] ) ; } lp ( lk , " \x5d \n " ) ; } l1 ( lk ) ; lz 0 ; }
>>>Func
METHOD lp
METHOD_RETURN ld
lj lj("\x25\x64",&li)
<operator>.lessThan la<li
<operator>.postIncrement la++
IDENTIFIER lr <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token ld lp ( ) { ld li , lh ; ld lc , lf ; ld la , le , lb ; lm lm  ld lg ; lj ( " \x25 \x64 " , & li ) ; lk ( la = 0  ; la < li ; la ++ ) { lj ( " \x25 \x64 " , & lh ) ; lc = lq ; lf = 0 ; lg = 0 ; lk ( le = 0  ; le < lh ; le ++ ) { lj ( " \x25 \x64 " , & lb ) ; ll ( lb < lc ) lc = lb ; lg += lb ; lf ^= lb ; } ll ( lf == 0 )  { ln ( " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x6c \x6c \x64 \n " , la + 1 , lg - lc ) ; } lo  { ln ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , la + 1 ) ; } } lr 0 ; }
>>>Func
METHOD ln
METHOD_RETURN lo
<operator>.lessThan lb<lj
<operator>.postIncrement lb++
<operator>.lessThan ld<lj
<operator>.postIncrement ld++
lf lf("\x25\x64",&le)
<operator>.lessThan lb<le
<operator>.postIncrement lb++
lf lf("\x25\x64",&le)
<operator>.lessThan lb<le
<operator>.postIncrement lb++
lf lf("\x25\x64\x20\x25\x73",&lm,lp)
>>>PDG&13 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 2->3 2->4 3->7 4->1 4->1 4->5 5->1 5->1 6->7 6->9 6->10 7->8 7->9 7->10 8->10 9->1 9->1 9->10 10->1 10->1 10->11 11->1 11->1 12->1 12->1 12->1
>>>Token lo ln ( ) { lc le , lb , ld ; ll la [ lk ] ; lg ( lb = 0  ; lb < lj ; lb ++ ) lg ( ld = 0 ; ld < lj ; ld ++ ) li [ lb ] [ ld ] = lh [ lb ] [ ld ] = 0 ; lf ( " \x25 \x64 " , & le ) ; lg ( lb = 0  ; lb < le ; lb ++ ) { lf ( " \x25 " " \x73 " , la ) ; li [ ( lc ) la [ 0 ] ] [ ( lc ) la [ 1 ] ] = li [ ( lc ) la [ 1 ] ] [ ( lc ) la [ 0 ] ] = la [ 2 ] ; } lf ( " \x25 \x64 " , & le ) ; lg ( lb = 0  ; lb < le ; lb ++ ) { lf ( " \x25 \x73 " , la ) ; lh [ ( lc ) la [ 0 ] ] [ ( lc ) la [ 1 ] ] = lh [ ( lc ) la [ 1 ] ] [ ( lc ) la [ 0 ] ] = 1 ; } lf ( " \x25 \x64 \x20 \x25 \x73 " , & lm , lp ) ; }
>>>Func
METHOD l9
METHOD_RETURN lk
PARAM lk l12
PARAM le* *lj
<operator>.assignment lb=l2(lj[1],"\x72")
l3 l3(lb==l1)
BLOCK <empty> <empty>
<operator>.assignment li=l2(lj[2],"\x77")
l3 l3(li==l1)
BLOCK <empty> <empty>
lh lh(lb,"\x25\x64\x20",&lr)
<operator>.lessThan ln<lr
<operator>.postIncrement ln++
l0 l0(lb)
l0 l0(li)
IDENTIFIER l13 <empty>
LITERAL 0 <empty>
l4 l4(lj[1])
l6 l6(1)
l4 l4(lj[2])
l6 l6(1)
l2 l2(lj[1],"\x72")
<operator>.equals lb==l1
l2 l2(lj[2],"\x77")
<operator>.equals li==l1
>>>PDG&25 0->2 0->3 0->6 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->20 0->21 0->22 0->23 0->24 2->1 3->1 3->17 3->19 3->21 3->23 4->1 4->1 4->22 5->1 5->1 7->1 7->1 7->24 8->1 8->1 10->1 10->1 10->11 10->13 11->1 11->1 11->12 12->1 12->1 13->1 13->1 14->1 14->1 17->1 17->1 19->1 19->1 20->1 21->4 21->4 21->17 22->5 22->5 22->10 22->24 23->7 23->7 23->19 24->1 24->8 24->8 24->14
>>>Token lk l9 ( lk l12 , le * * lj ) { l10 * lb , * li ; lk lr , lx , lw , lq ; lk ln , la , lc ; lk lu ; lel5 [ 700 ] ; le lf , lg , lo ; le lm [ 37 ] [ 4 ] ; le lp [ 29 ] [ 3 ] ; le lv [ 101 ] ; le lt [ 101 ] ; le ls [ 101 ] ; lb = l2 ( lj [ 1 ] , " \x72 " ) ; l3 ( lb == l1 )  { l4 ( lj [ 1 ] ) ; l6 ( 1 ) ; } li = l2 ( lj [ 2 ] , " \x77 " ) ; l3 ( li == l1 )  { l4 ( lj [ 2 ] ) ; l6 ( 1 ) ; } lh ( lb , " \x25 \x64 \x20 " , & lr ) ; ld ( ln = 0  ; ln < lr ; ln ++ ) { ld ( la = 0  ; la < 8 ; la ++ ) ld ( lc = 0 ; lc < 8 ; lc ++ ) lz [ la ] [ lc ] = -1 ; lh ( lb , " \x25 \x64 \x20 " , & lx ) ; ld ( la = 0  ; la < lx ; la ++ ) { lh ( lb , " \x25 \x73 \x20 " , lm [ la ] ) ; lf = ll ( lm [ la ] [ 0 ] ) ; lg = ll ( lm [ la ] [ 1 ] ) ; lo = lm [ la ] [ 2 ] ; lz [ lf ] [ lg ] = lo ; lz [ lg ] [ lf ] = lo ; } ld ( la = 0  ; la < 8 ; la ++ ) ld ( lc = 0 ; lc < 8 ; lc ++ ) ly [ la ] [ lc ] = 0 ; lh ( lb , " " " \x25 \x64 \x20 " , & lw ) ; ld ( la = 0  ; la < lw ; la ++ ) { lh ( lb , " \x25 \x73 \x20 " , lp [ la ] ) ; lf = ll ( lp [ la ] [ 0 ] ) ; lg = ll ( lp [ la ] [ 1 ] ) ; ly [ lf ] [ lg ] = 1 ; ly [ lg ] [ lf ] = 1 ; } lh ( lb , " " " \x25 \x64 \x20 " , & lq ) ; lh ( lb , " \x25 \x73 \x20 " , lv ) ; ld ( la = 0  ; la < lq ; la ++ ) lt [ la ] = ll ( lv [ la ] ) ; lu = l11 ( lt , lq , ls ) ; l7 ( li , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 " " \x3a \x20 \x5b \x25 \x73 \x5d \n " , ln + 1 , l8 ( ls , lu , l5 ) ) ; } l0 ( lb ) ; l0 ( li ) ; l13 0 ; }
>>>Func
METHOD lq
METHOD_RETURN lf
IDENTIFIER lc <empty>
lb lb("\x45\x6e\x74\x65\x72\x20""\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x76\x65\x72\x74\x69\x63\x65""\x73\x3a\x20")
la la("\x25\x64",&lg)
lb lb("\x45\x6e\x74\x65\x72\x20\x6e""\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x65\x64\x67\x65\x73\x3a\x20")
la la("\x25\x64",&ld)
ln ln(&lc,lg,ld)
<operator>.lessThan le<ld
<operator>.postIncrement le++
lb lb("\n\x45\x6e\x74""\x65\x72\x20\x73\x6f\x75\x72\x63\x65\x3a")
la la("\x25\x64",&lk)
lr lr(&lc,lk)
IDENTIFIER ll <empty>
LITERAL 0 <empty>
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 3->1 4->1 4->1 4->7 5->1 6->1 6->1 6->7 6->8 7->1 7->1 7->8 7->12 8->1 8->1 8->9 9->1 9->1 10->1 11->1 11->1 11->12 12->1 12->1 12->1
>>>Token lf lq ( ) { lf lg , ld , lk ; lf lh , li , lj ; lo lm lc ; lb ( " \x45 \x6e \x74 \x65 \x72 \x20 " " \x6e \x75 \x6d \x62 \x65 \x72 \x20 \x6f \x66 \x20 \x76 \x65 \x72 \x74 \x69 \x63 \x65 " " \x73 \x3a \x20 " ) ; la ( " \x25 \x64 " , & lg ) ; lb ( " \x45 \x6e \x74 \x65 \x72 \x20 \x6e " " \x75 \x6d \x62 \x65 \x72 \x20 \x6f \x66 \x20 \x65 \x64 \x67 \x65 \x73 \x3a \x20 " ) ; la ( " \x25 \x64 " , & ld ) ; ln ( & lc , lg , ld ) ; ls ( lf  le = 0 ; le < ld ; le ++ ) { lb ( " \n \x45 " " \x64 \x67 \x65 \x20 \x25 \x64 \x20 \n \x45 \x6e \x74 \x65 \x72 \x20 \x73 \x6f \x75 " " \x72 \x63 \x65 \x3a \x20 " , le + 1 ) ; la ( " \x25 \x64 " , & lh ) ; lb ( " \x45 \x6e \x74 \x65 " " \x72 \x20 \x64 \x65 \x73 \x74 \x69 \x6e \x61 \x74 \x69 \x6f \x6e \x3a \x20 " ) ; la ( " " " \x25 \x64 " , & li ) ; lb ( " \x45 \x6e \x74 \x65 \x72 \x20 \x77 \x65 \x69 \x67 \x68 \x74 " " \x3a \x20 " ) ; la ( " \x25 \x64 " , & lj ) ; lp ( & lc , lh , li , lj ) ; } lb ( " \n \x45 \x6e \x74 " " \x65 \x72 \x20 \x73 \x6f \x75 \x72 \x63 \x65 \x3a " ) ; la ( " \x25 \x64 " , & lk ) ; lr ( & lc , lk ) ; ll 0 ; }
>>>Func
METHOD lw
METHOD_RETURN ly
PARAM ln lt
<operator>.expressionList ll lm lk
lz lz(3==lv("\x25\x6c\x6c\x64\x20\x25\x6c\x6c\x64\x20\x25\x6c\x6c\x64\n",&ll,&lm,&lk))
<operator>.assignment lc=lm-ll+1
<operator>.lessThan la<lc
<operator>.postIncrement la++
<operator>.assignment lq=(lk>lc)?lc:lk
<operator>.lessThan lb<lc
<operator>.postIncrement lb++
<operator>.lessThan la<lc
<operator>.postIncrement la++
<operator>.lessThan la<lc
<operator>.postIncrement la++
lx lx("\x43\x61\x73""\x65\x20\x23\x25\x64\x3a\x20\x25\x64\n",lt,lj)
<operator>.equals 3==lv("\x25\x6c\x6c\x64\x20\x25\x6c\x6c\x64\x20\x25\x6c\x6c\x64\n",&ll,&lm,&lk)
<operator>.addition lm-ll+1
<operator>.conditional (lk>lc)?lc:lk
lv lv("\x25\x6c\x6c\x64\x20\x25\x6c\x6c\x64\x20\x25\x6c\x6c\x64\n",&ll,&lm,&lk)
<operator>.subtraction lm-ll
<operator>.greaterThan lk>lc
>>>PDG&22 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 2->15 3->1 3->19 3->19 3->19 3->20 3->20 3->21 4->1 4->1 5->1 5->1 5->6 6->7 6->21 7->11 8->1 8->1 8->1 9->1 9->10 9->11 10->1 10->1 11->12 11->13 12->13 13->1 13->1 13->14 14->1 14->1 15->1 15->1 15->1 16->1 16->4 16->4 17->1 18->1 18->1 19->1 19->1 19->1 19->8 19->16 19->16 19->16 19->16 19->18 19->20 19->20 19->21 20->1 20->1 20->5 20->5 20->17 20->17 21->8 21->8 21->9 21->18 21->18
>>>Token ly lw ( ln lt ) { lr lr ll , lm , lk ; ln lc , lb , ld , lq ; ln la , lj , le , lg , lo ; lz ( 3 == lv ( " \x25 \x6c \x6c \x64 \x20 \x25 \x6c \x6c \x64 \x20 \x25 \x6c \x6c \x64 \n " , & ll , & lm , & lk ) ) ; lc = lm - ll + 1 ; lf ( la = 0  ; la < lc ; la ++ ) lh [ la ] = la ; lq = ( lk > lc ) ? lc : lk ; lf ( lb = lq  ; lb < lc ; lb ++ ) { li ( lb > 2 && ( lb & 1 ) == 0 ) ls ; lf ( ld = 3  ; ld * ld <= lb ; ld += 2 ) li ( lb % ld == 0 ) lu ; li ( ld * ld <= lb ) ls ; le = lb - ( ll % lb ) ; li ( le == lb ) le = 0 ; lp ( le ) ; lo = lh [ le ] ; lf ( lg = le + lb  ; lg < lc ; lg += lb ) { lp ( lg ) ; lh [ lh [ lg ] ] = lo ; } } lf ( la = 0  ; la < lc ; la ++ ) lp ( la ) ; lf ( la = lj = 0  ; la < lc ; la ++ ) li ( lh [ la ] == la ) { lj ++ ; } lx ( " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , lt , lj ) ; }
>>>Func
METHOD lz
METHOD_RETURN ld
PARAM lv*lp
PARAM ld*le
<operator>.assignment lh=le->lc[lr]
<operator>.assignment lg=le->lc[ln]
ll ll(lh==lf&&lg==lf)
BLOCK <empty> <empty>
<operator>.assignment li=lm(lh)
<operator>.assignment lj=lm(lg)
ll ll(li<lj)
BLOCK <empty> <empty>
IDENTIFIER lt <empty>
BLOCK <empty> <empty>
<operator>.assignment la=le->lc[lb]
lw lw(la->lc[1-lb]!=lf)
BLOCK <empty> <empty>
<operator>.assignment lk=la->lc[lb]
lu lu(lp,la,lk)
ls ls(la->ly)
<operator>.assignment lb=ln
<operator>.assignment lb=lr
<operator>.assignment la=la->lc[1-lb]
<operator>.logicalAnd lh==lf&&lg==lf
lm lm(lh)
lm lm(lg)
<operator>.lessThan li<lj
<operator>.notEquals la->lc[1-lb]!=lf
<operator>.equals lh==lf
<operator>.equals lg==lf
<operator>.subtraction 1-lb
<operator>.subtraction 1-lb
>>>PDG&32 0->2 0->3 0->7 0->11 0->12 0->13 0->16 0->18 0->20 0->21 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->18 3->1 4->1 4->1 4->28 5->1 5->1 5->25 5->29 6->1 6->1 8->1 8->1 8->26 9->1 9->1 9->26 10->1 10->1 14->1 14->1 15->1 15->1 17->1 17->1 17->18 18->1 18->1 18->1 18->1 19->1 19->1 20->1 20->1 21->1 21->1 21->30 22->1 22->1 22->18 23->1 23->1 23->6 23->6 24->1 24->8 25->1 25->9 26->1 26->1 26->10 26->10 27->1 27->15 27->15 27->22 28->23 28->23 28->24 28->27 28->29 28->29 29->23 29->23 29->25 29->27 30->31 31->1
>>>Token lx ld * lz ( lv * lp , ld * le ) { ld * lh ; ld * lg ; ld * la ; ld * lk ; lq li , lj ; lq lb ; lh = le -> lc [ lr ] ; lg = le -> lc [ ln ] ; ll ( lh == lf && lg == lf )  { lo lf ; } li = lm ( lh ) ; lj = lm ( lg ) ; ll ( li < lj )  { lb = ln ; } lt { lb = lr ; } la = le -> lc [ lb ] ; lw ( la -> lc [ 1 - lb ] != lf )  { la = la -> lc [ 1 - lb ] ; } lk = la -> lc [ lb ] ; lu ( lp , la , lk ) ; ls ( la -> ly ) ; lo la ; }
>>>Func
METHOD ll
METHOD_RETURN lj
PARAM ld*lb
<operator>.assignment lc=lf
lh lh(!lc)
BLOCK <empty> <empty>
<operator>.assignment lc=li
<operator>.lessThan la<ln-1
<operator>.postIncrement la++
<operator>.logicalNot !lc
<operator>.subtraction ln-1
>>>PDG&11 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 2->1 3->1 3->1 3->9 4->1 4->1 6->1 6->1 6->1 7->1 7->1 7->8 8->1 8->1 9->4 10->1 10->7 10->7
>>>Token lj ll ( ld * lb ) { lk lc = lf ; lh ( ! lc )  { lc = li ; lm ( ld  la = 0 ; la < ln - 1 ; la ++ ) { lg ( lb [ la ] > lb [ la + 1 ] )  { ld le = lb [ la ] ; lb [ la ] = lb [ la + 1 ] ; lb [ la + 1 ] = le ; lc = lf ; } } } }
>>>Func
METHOD lj
METHOD_RETURN lc
PARAM lc*le
PARAM lc lg
<operator>.assignment ld=1
<operator>.assignment lb=1
lf lf(lg==0)
IDENTIFIER lh <empty>
LITERAL 0 <empty>
<operator>.lessThan la<lg
<operator>.postIncrement la++
<operator>.equals lg==0
>>>PDG&12 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 2->1 3->11 4->1 4->1 5->1 5->1 6->1 6->1 9->1 9->1 9->10 10->1 10->1 11->6 11->6 11->9
>>>Token lc lj ( lc * le , lc lg ) { lc ld = 1 , la , lb = 1 ; lf ( lg == 0 ) lh 0 ; lk ( la = 1  ; la < lg ; la ++ ) { lf ( le [ la ] > le [ la - 1 ] )  { lb ++ ; lf ( lb >= ld ) ld = lb ; } li  { lb = 1 ; } } lh ld ; }
>>>Func
METHOD lk
METHOD_RETURN la
PARAM la lc
<operator>.assignment le=lj(lc)
<operator>.assignment lb=lc
<operator>.assignment ld=0
li li(lb)
BLOCK <empty> <empty>
ll ll(ld==lc)
IDENTIFIER lf <empty>
LITERAL 1 <empty>
LITERAL 0 <empty>
<operator>.assignment lg=lb%10
<operator>.assignmentPlus ld+=lm(lg,le)
<operator>.assignment lb=lb/10
lj lj(lc)
<operator>.equals ld==lc
<operator>.modulo lb%10
lm lm(lg,le)
<operator>.division lb/10
>>>PDG&20 0->2 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->13 0->15 0->16 0->17 0->18 0->19 2->15 3->1 3->1 3->18 4->1 4->6 5->1 5->13 6->1 6->17 8->1 8->1 12->1 12->1 12->18 13->1 13->1 13->16 14->1 14->1 14->1 15->3 15->4 15->16 16->1 16->1 16->8 16->8 17->12 17->12 17->19 18->1 18->1 18->13 18->13 19->14 19->14
>>>Token la lk ( la lc ) { la le = lj ( lc ) ; la lb = lc , ld = 0 ; li ( lb ) { la lg = lb % 10 ; ld += lm ( lg , le ) ; lb = lb / 10 ; } ll ( ld == lc ) lf 1 ; lh lf 0 ; }
>>>Func
METHOD lq
METHOD_RETURN lc
PARAM lr*ln
<operator>.assignment lf=0
<operator>.assignment *lb=ld
<operator>.assignment *la=ld
lt lt((lh=(lc)ls(ln))!=lu)
BLOCK <empty> <empty>
<operator>.assignment lb=la
le le(lb!=ld)
BLOCK <empty> <empty>
le le((lf%lo)==0)
BLOCK <empty> <empty>
le le(lh=='\n')
BLOCK <empty> <empty>
IDENTIFIER lv <empty>
BLOCK <empty> <empty>
<operator>.assignment la=(lc* )lj(lk(lc) * (l0(lb)+1))
<operator>.assignment la=lx(la,lb)
li li(lb)
<operator>.notEquals (lh=(lc)ls(ln))!=lu
<operator>.assignment lb=la
<operator>.assignment la=(lc* )lj(lk(lc) * (lf+lo))
le le(la==ld)
BLOCK <empty> <empty>
le le(lb!=ld)
BLOCK <empty> <empty>
<operator>.assignment la[lf]='\0'
IDENTIFIER lp <empty>
<operator>.assignment la[lf++]=lh
<operator>.notEquals lb!=ld
<operator>.assignment lh=(lc)ls(ln)
<operator>.equals (lf%lo)==0
le le(lb!=ld)
li li(lb)
ly ly("\x43\x72\x69\x74\x69\x63\x61\x6c\x20\x65\x72""\x72\x6f\x72")
<operator>.lessThan lg<lf
<operator>.postIncrement lg++
li li(lb)
<operator>.equals lh=='\n'
<operator>.cast (lc* )lj(lk(lc) * (l0(lb)+1))
lx lx(la,lb)
<operator>.cast (lc)ls(ln)
<operator>.modulo lf%lo
<operator>.cast (lc* )lj(lk(lc) * (lf+lo))
<operator>.equals la==ld
<operator>.notEquals lb!=ld
lj lj(lk(lc) * (l0(lb)+1))
ls ls(ln)
lj lj(lk(lc) * (lf+lo))
<operator>.notEquals lb!=ld
<operator>.postIncrement lf++
<operator>.multiplication lk(lc) * (l0(lb)+1)
<operator>.multiplication lk(lc) * (lf+lo)
lk lk(lc)
<operator>.addition l0(lb)+1
lk lk(lc)
<operator>.addition lf+lo
l0 l0(lb)
>>>PDG&59 0->2 0->3 0->4 0->5 0->7 0->8 0->10 0->12 0->14 0->15 0->16 0->19 0->20 0->21 0->24 0->26 0->27 0->28 0->29 0->30 0->32 0->34 0->35 0->36 0->37 0->38 0->39 0->41 0->43 0->45 0->46 0->48 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 2->48 3->1 3->43 4->1 5->1 5->21 6->1 6->1 8->1 8->30 9->1 9->1 11->1 11->1 13->1 13->1 17->1 17->1 17->41 18->1 18->1 18->1 19->1 19->1 20->1 20->1 20->6 20->6 21->50 22->1 22->1 22->45 23->1 23->1 27->1 27->1 27->8 27->41 29->1 29->1 29->1 29->8 29->41 30->1 30->9 30->9 30->58 31->1 31->20 31->39 32->1 32->11 32->11 34->46 35->1 36->1 36->37 36->51 37->1 37->1 39->13 39->13 39->29 40->1 41->18 41->18 41->19 42->1 43->32 43->32 43->36 43->53 43->53 43->57 43->57 44->1 45->8 45->23 45->23 45->50 46->25 46->25 46->30 46->38 47->1 47->17 47->40 48->1 48->20 48->31 48->42 49->1 49->22 49->44 50->33 50->33 50->34 50->46 51->1 52->1 52->1 52->47 52->47 53->1 53->49 53->49 54->1 54->52 55->1 56->53 56->54 57->1 58->41 58->52 58->55
>>>Token lc * lq ( lr * ln ) { lm lw , lg ; lm lf = 0 ; lc lh ; lc * lb = ld ; lc * la = ld ; lt ( ( lh = ( lc ) ls ( ln ) ) != lu )  { le ( ( lf % lo ) == 0 )  { lb = la ; la = ( lc * ) lj ( lk ( lc ) * ( lf + lo ) ) ; le ( la == ld )  { le ( lb != ld ) li ( lb ) ; ly ( " \x43 \x72 \x69 \x74 \x69 \x63 \x61 \x6c \x20 \x65 \x72 " " \x72 \x6f \x72 " ) ; ll ld ; } le ( lb != ld )  { lz ( lg = 0  ; lg < lf ; lg ++ ) la [ lg ] = lb [ lg ] ; li ( lb ) ; } } le ( lh == ' \n ' )  { la [ lf ] = ' \0 ' ; lp ; } lv { la [ lf ++ ] = lh ; } } lb = la ; le ( lb != ld )  { la = ( lc * ) lj ( lk ( lc ) * ( l0 ( lb ) + 1 ) ) ; la = lx ( la , lb ) ; li ( lb ) ; } ll la ; }
>>>Func
METHOD lt
METHOD_RETURN lr
lf lf("""\x25\x64",&ln)
<operator>.lessThan lj<ln
<operator>.postIncrement lj++
IDENTIFIER lv <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lr lt ( ) { lr ln , lp , lo , le , la , lb , li , lj ; ly lk [ 40 ] [ 3 ] , lh [ 30 ] [ 2 ] , lc [ lx ] ; lf ( " " " \x25 \x64 " , & ln ) ; ld ( lj = 0  ; lj < ln ; lj ++ ) { lf ( " \n \x25 \x64 " , & lp ) ; ld ( la = 0  ; la < lp ; la ++ ) { lf ( " \x20 " ) ; ld ( lb = 0  ; lb < 3 ; lb ++ ) { lf ( " \x25 \x63 " , & lk [ la ] [ lb ] ) ; } } lf ( " \x20 \x25 \x64 " , & lo ) ; ld ( la = 0  ; la < lo ; la ++ ) { lf ( " \x20 " ) ; ld ( lb = 0  ; lb < 2 ; lb ++ ) { lf ( " \x25 \x63 " , & lh [ la ] [ lb ] ) ; } } lf ( " \x20 \x25 \x64 \x20 " , & le ) ; ld ( la = 0  ; la < le ; la ++ ) { lf ( " \x25 \x63 " , & lc [ la ] ) ; } lr ll ; ld ( la = 1  ; la < le ; la ++ ) { ll = 0 ; ld ( lb = 0  ; lb < lp ; lb ++ ) lg ( ( lc [ la ] == lk [ lb ] [ 0 ] && lc [ la - 1 ] == lk [ lb ] [ 1 ] ) || ( lc [ la ] == lk [ lb ] [ 1 ] && lc [ la - 1 ] == lk [ lb ] [ 0 ] ) ) { le = lu ( lc , la - 1 , lk [ lb ] [ 2 ] , le ) ; la -= 2 ; ll = 1 ; lq ; } lg ( ! ll )  { ld ( lb = 0  ; lb < lo ; lb ++ ) lg ( lc [ la ] == lh [ lb ] [ 0 ] || lc [ la ] == lh [ lb ] [ 1 ] ) { ld ( li = la - 1 ; li >= 0 ; li -- ) { lg ( ( lc [ li ] == lh [ lb ] [ 0 ] && lc [ la ] == lh [ lb ] [ 1 ] ) || ( lc [ li ] == lh [ lb ] [ 1 ] && lc [ la ] == lh [ lb ] [ 0 ] ) )  { le = lw ( lc , li , la , le ) ; la = li - 1 ; ll = 1 ; lq ; } lg ( ll == 1 ) lq ; } } } lg ( la < 0 ) la = 0 ; } lg ( le > 0 )  lm ( " \x43 \x61 \x73 \x65 " " \x20 \x23 \x25 \x64 \x3a \x20 \x5b \x25 \x63 " , lj + 1 , lc [ 0 ] ) ; ls lm ( " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lj + 1 ) ; ld ( la = 1  ; la < le ; la ++ ) lm ( " " " \x2c \x20 \x25 \x63 " , lc [ la ] ) ; lm ( " \x5d " ) ; lg ( lj < ln - 1 )  lm ( " \n " ) ; } lv 0 ; }
>>>Func
METHOD lm
METHOD_RETURN lb
li li("\x25\x64",&lg)
<operator>.lessEqualsThan lc<=lg
<operator>.preIncrement ++lc
IDENTIFIER ln <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lb lm ( ) { lb lc , lg ; lb lh ; li ( " \x25 \x64 " , & lg ) ; lp ( lc = 1  ; lc <= lg ; ++ lc ) { lb lf , le ; lb ld ; li ( " \x25 \x64 " , & lh ) ; ld = 2000000 ; le = 0 ; lf = 0 ; lo ( lh -- )  { lb la ; li ( " " " \x25 \x64 " , & la ) ; lk ( la < ld )  { ld = la ; } le += la ; lf ^= la ; } lj ( " \x43 \x61 \x73 \x65 " " \x20 \x23 \x25 \x64 \x3a \x20 " , lc ) ; lk ( lf == 0 )  { lj ( " \x25 \x64 \n " , le - ld ) ; } ll  { lj ( " \x4e \x4f \n " ) ; } } ln 0 ; }
>>>Func
METHOD lp
METHOD_RETURN lg
<operator>.assignment lj=0
<operator>.postDecrement ld--
IDENTIFIER ln <empty>
LITERAL 0 <empty>
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 2->1 3->1 3->1
>>>Token lg lp ( ) { lg ld , lj = 0 , la ; lq lc , lb ; le ( lf ( " \x25 \x64 " , & ld )  ; ld -- ; ) { lf ( " \x25 " " \x64 \x20 \x25 \x64 " , & lh , & lm ) ; le ( la = 0  ; la < lh ; la ++ ) lf ( " \x25 \x64 \x20 \x25 " " \x64 " , & li [ la ] [ 0 ] , & li [ la ] [ 1 ] ) ; le ( lc = 0 , lb = 1e20 , la = 0  ; la < 300 ; la ++ ) { lk ( lr ( ( lc + lb ) * 0.5 ) ) lb = ( lc + lb ) * .5 ; lo lc = ( lc + lb ) * .5 ; } ll ( " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x2e \x31 \x30 \x6c \x66 \n " , ++ lj , ( lc + lb ) * .5 ) ; } ln 0 ; }
>>>Func
METHOD lz
METHOD_RETURN lc
ln ln("\x25\x64",&lu)
<operator>.lessThan lp<lu
<operator>.postIncrement lp++
IDENTIFIER l0 <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lc lz ( ) { lc lu ; ln ( " \x25 \x64 " , & lu ) ; le ( lc  lp = 0 ; lp < lu ; lp ++ ) { lc ld , lg [ 100 ] = { } ; l1 lh [ 100 ] [ 100 ] , lv ; ll ls [ 100 ] = { } , lr [ 100 ] = { } , lm [ 100 ] = { } , lo [ 100 ] = { } ; ln ( " \x25 \x64 " , & ld ) ; ln ( " \x25 \x63 " , & lv ) ; le ( lc  lb = 0 ; lb < ld ; lb ++ ) { le ( lc  lq = 0 ; lq < ld ; lq ++ ) ln ( " \x25 \x63 " , & lh [ lb ] [ lq ] ) ; ln ( " \x25 \x63 " , & lv ) ; } le ( lc  la = 0 ; la < ld ; la ++ ) { le ( lc  lb = 0 ; lb < ld ; lb ++ ) { lk ( lh [ la ] [ lb ] == ' ' ) lg [ la ] ++ , ls [ la ] ++ ; lx lk ( lh [ la ] [ lb ] = = ' ' ) lg [ la ] ++ ; } lr [ la ] = ls [ la ] / ( ll ) lg [ la ] ; } le ( lcla = 0  ; la < ld ; la ++ ) { ll lw [ 100 ] = { } , lt [ 100 ] = { } , lg [ 100 ] = { } ; le ( lc  lf = 0 ; lf < ld ; lf ++ ) { le ( lc  li = 0 ; li < ld ; li ++ ) { lk ( lh [ lf ] [ li ] == ' ' && li != la ) lg [ lf ] ++ , lt [ lf ] ++ ; lx lk ( lh [ lf ] [ li ] = = ' ' && li != la ) lg [ lf ] ++ ; } lw [ lf ] = lt [ lf ] / ( ll ) lg [ lf ] ; } ll lj = 0 ; le ( lc  lb = 0 ; lb < ld ; lb ++ ) { lk ( lh [ la ] [ lb ] != ' ' ) lm [ la ] += lw [ lb ] , lj ++ ; } lm [ la ] /= lj ; } le ( lc  la = 0 ; la < ld ; la ++ ) { ll lj = 0 ; le ( lc  lb = 0 ; lb < ld ; lb ++ ) { lk ( lh [ la ] [ lb ] != ' ' ) lo [ la ] += lm [ lb ] , lj ++ ; } lo [ la ] /= lj ; } ly ( " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \n " , lp + 1 ) ; le ( lc  la = 0 ; la < ld ; la ++ ) { ly ( " " " \x25 \x66 \n " , 0.25 * lr [ la ] + 0.50 * lm [ la ] + 0.25 * lo [ la ] ) ; } } l0 0 ; }
>>>Func
METHOD lj
METHOD_RETURN le
PARAM lf
lh lh("\x25\x64",&lb)
<operator>.lessThan la<lb
<operator>.postIncrement la++
IDENTIFIER lg <empty>
LITERAL 0 <empty>
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token le lj ( lf ) { le la , lb , lc ; lh ( " \x25 \x64 " , & lb ) ; lm ( la = 0  ; la < lb ; la ++ ) { lc = ll ( ) ; lk ( lc ) ld ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x50 \x6f \x73 \x73 " " \x69 \x62 \x6c \x65 \n " , la + 1 ) ; li ld ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 " " \x3a \x20 \x42 \x72 \x6f \x6b \x65 \x6e \n " , la + 1 ) ; } lg 0 ; }
>>>Func
METHOD lw
METHOD_RETURN li
lj lj("\x25\x64",&lr)
<operator>.lessEqualsThan lm<=lr
<operator>.postIncrement lm++
IDENTIFIER lx <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token li lw ( ) { li lb , lc , lm ; li lk , ll ; li lh ; li lr , la ; li lp , lo , lq ; lz lt [ 200 ] ; lj ( " \x25 \x64 " , & lr ) ; le ( lm = 1  ; lm <= lr ; lm ++ ) { lj ( " \x25 \x64 " , & lp ) ; le ( lb = 0  ; lb < lp ; lb ++ ) lj ( " \x25 \x73 " , lg [ lb ] ) ; lj ( " \x25 \x64 " , & lo ) ; le ( lb = 0  ; lb < lo ; lb ++ ) lj ( " \x25 \x73 " , ls [ lb ] ) ; lj ( " \x25 \x64 \x25 \x73 " , & lq , lt ) ; la = -1 ; le ( lb = 0  ; lb < lq ; lb ++ ) { ++ la ; ld [ la ] = lt [ lb ] ; le ( lc = 0  ; lc < lp && la >= 1 ; lc ++ ) { lf ( ld [ la ] == lg [ lc ] [ 0 ] && ld [ la - 1 ] == lg [ lc ] [ 1 ] )  { la -- ; la -- ; la ++ ; ld [ la ] = lg [ lc ] [ 2 ] ; } lv lf ( ld [ la - 1 ] = = lg [ lc ] [ 0 ] && ld [ la ] == lg [ lc ] [ 1 ] ) { la -- ; la -- ; la ++ ; ld [ la ] = lg [ lc ] [ 2 ] ; } } le ( lc = 0 , lh = 0  ; lc < lo && la >= 1 ; lc ++ ) { le ( lk = 0  ; lh == 0 && lk <= la ; lk ++ ) { le ( ll = 0  ; lh == 0 && ll <= la ; ll ++ ) { lf ( lk == ll ) ly ; lf ( ls [ lc ] [ 0 ] == ld [ lk ] && ls [ lc ] [ 1 ] == ld [ ll ] )  { lh = 1 ; } } } lf ( lh ) lu ; } lf ( lh ) { la = -1 ; } } ln ( " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a \x20 \x5b " , lm ) ; le ( lb = 0  ; lb <= la ; lb ++ ) { lf ( lb ) ln ( " \x2c \x20 " ) ; ln ( " \x25 \x63 " , ld [ lb ] ) ; } ln ( " \x5d \n " ) ; } lx 0 ; }
>>>Func
METHOD lt
METHOD_RETURN lf
<operator>.assignment ld=0
<operator>.assignment lm=-1
<operator>.assignment lo=-1
<operator>.lessThan lb<lg
<operator>.postIncrement lb++
IDENTIFIER lj <empty>
LITERAL 0 <empty>
lk lk(lm==-1)
IDENTIFIER lj <empty>
LITERAL 0 <empty>
<operator>.assignment lb=lm
<operator>.assignment lh=lo
<operator>.lessThan la<lb
<operator>.postIncrement la++
<operator>.lessThan la<lg
<operator>.postIncrement la++
<operator>.assignment le[ld]='\0'
<operator>.assignment lg=ld
ll ll(lc,le)
IDENTIFIER lj <empty>
LITERAL 1 <empty>
<operator>.minus -1
<operator>.minus -1
<operator>.equals lm==-1
<operator>.minus -1
>>>PDG&27 0->2 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->1 2->19 3->1 3->25 4->1 4->13 5->1 5->6 5->16 6->1 9->1 9->1 12->1 12->1 12->14 13->1 13->1 13->1 14->1 14->1 14->15 15->16 16->1 16->17 17->1 17->1 18->1 18->1 18->20 19->1 19->1 19->1 20->1 20->1 20->1 23->3 24->4 25->1 25->9 25->9 25->12 26->25
>>>Token lf lt ( ) { lf ld = 0 ; lp le [ 110 ] ; lf lr [ 110 ] ; lf lb ; lf la ; lf lh ; lf ls ; lf lm = -1 ; lf lo = -1 ; li ( lb = 1  ; lb < lg ; lb ++ ) { lk ( ln [ lc [ lb ] - ' ' ] [ lc [ lb - 1 ] - ' ' ] > 0 )  { li ( la = 0  ; la < lb - 1 ; la ++ ) le [ ld ++ ] = lc [ la ] ; le [ ld ++ ] = ln [ lc [ lb ] - ' ' ] [ lc [ lb - 1 ] - ' ' ] ; li ( la = lb + 1  ; la < lg ; la ++ ) le [ ld ++ ] = lc [ la ] ; le [ ld ] = ' \0 ' ; lg = ld ; ll ( lc , le ) ; lj 1 ; } li ( lh = 0  ; lh < lb ; lh ++ ) { lk ( lq [ lc [ lb ] - ' ' ] [ lc [ lh ] - ' ' ] > 0 )  { li ( la = lb + 1  ; la < lg ; la ++ ) le [ ld ++ ] = lc [ la ] ; le [ ld ] = ' \0 ' ; lg = ld ; ll ( lc , le ) ; lj 1 ; } } } lj 0 ; lk ( lm == -1 ) lj 0 ; lb = lm ; lh = lo ; li ( la = 0  ; la < lb ; la ++ ) le [ ld ++ ] = lc [ la ] ; li ( la = lh + 1  ; la < lg ; la ++ ) le [ ld ++ ] = lc [ la ] ; le [ ld ] = ' \0 ' ; lg = ld ; ll ( lc , le ) ; lj 1 ; }
>>>Func
METHOD lu
METHOD_RETURN lv
PARAM lt ls
PARAM lt lf
PARAM lt lb
la la(ls==1)
BLOCK <empty> <empty>
la la(ls==2)
BLOCK <empty> <empty>
<operator>.assignment lg[60]="\x50\x6c\x61\x79\x65""\x72\x20\x31\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68""\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x31\x20\x28\x31\x2f""\x36\x29"
<operator>.assignment lq[60]="\x50\x6c\x61\x79\x65\x72\x20\x31\x20\x2d\x20""\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65""\x20\x62\x6f\x61\x74\x20\x31\x20\x28\x32\x2f\x36\x29"
<operator>.assignment lm[60]="""\x50\x6c\x61\x79\x65\x72\x20\x31\x20\x2d\x20\x50\x6f\x73\x69\x74\x69""\x6f\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20""\x31\x20\x28\x33\x2f\x36\x29"
<operator>.assignment li[60]="\x50\x6c\x61\x79\x65\x72""\x20\x31\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65""\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x31\x20\x28\x34\x2f\x36""\x29"
<operator>.assignment ln[60]="\x50\x6c\x61\x79\x65\x72\x20\x31\x20\x2d\x20\x50""\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65\x20""\x62\x6f\x61\x74\x20\x31\x20\x28\x35\x2f\x36\x29"
<operator>.assignment lj[60]="\x50""\x6c\x61\x79\x65\x72\x20\x31\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f""\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x31""\x20\x28\x36\x2f\x36\x29"
<operator>.assignment lk[60]="\x50\x6c\x61\x79\x65\x72\x20""\x31\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20""\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x32\x20\x28\x31\x2f\x34\x29"
<operator>.assignment ll[60]="\x50\x6c\x61\x79\x65\x72\x20\x31\x20\x2d\x20\x50\x6f\x73""\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65\x20\x62\x6f""\x61\x74\x20\x32\x20\x28\x32\x2f\x34\x29"
<operator>.assignment lh[60]="\x50\x6c\x61""\x79\x65\x72\x20\x31\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20""\x74\x68\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x32\x20\x28""\x33\x2f\x34\x29"
<operator>.assignment lp[60]="\x50\x6c\x61\x79\x65\x72\x20\x31\x20""\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20\x73\x69""\x7a\x65\x20\x62\x6f\x61\x74\x20\x32\x20\x28\x34\x2f\x34\x29"
<operator>.assignment lo[60]="\x50\x6c\x61\x79\x65\x72\x20\x31\x20\x2d\x20\x50\x6f\x73\x69\x74""\x69\x6f\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74""\x20\x33\x20\x28\x31\x2f\x32\x29"
<operator>.assignment lr[60]="\x50\x6c\x61\x79\x65""\x72\x20\x31\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68""\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x33\x20\x28\x32\x2f""\x32\x29"
la la(lf==1)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lf==2)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lf==3)
BLOCK <empty> <empty>
<operator>.assignment lg[60]="\x50\x6c\x61\x79\x65\x72\x20""\x32\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20""\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x31\x20\x28\x31\x2f\x36\x29"
<operator>.assignment lq[60]="\x50\x6c\x61\x79\x65\x72\x20\x32\x20\x2d\x20\x50\x6f\x73""\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65\x20\x62\x6f""\x61\x74\x20\x31\x20\x28\x32\x2f\x36\x29"
<operator>.assignment lm[60]="\x50\x6c\x61""\x79\x65\x72\x20\x32\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20""\x74\x68\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x31\x20\x28""\x33\x2f\x36\x29"
<operator>.assignment li[60]="\x50\x6c\x61\x79\x65\x72\x20\x32\x20""\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20\x73\x69""\x7a\x65\x20\x62\x6f\x61\x74\x20\x31\x20\x28\x34\x2f\x36\x29"
<operator>.assignment ln[60]="\x50\x6c\x61\x79\x65\x72\x20\x32\x20\x2d\x20\x50\x6f\x73\x69\x74""\x69\x6f\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74""\x20\x31\x20\x28\x35\x2f\x36\x29"
<operator>.assignment lj[60]="\x50\x6c\x61\x79\x65""\x72\x20\x32\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68""\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x31\x20\x28\x36\x2f""\x36\x29"
<operator>.assignment lk[60]="\x50\x6c\x61\x79\x65\x72\x20\x32\x20\x2d\x20""\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65""\x20\x62\x6f\x61\x74\x20\x32\x20\x28\x31\x2f\x34\x29"
<operator>.assignment ll[60]="""\x50\x6c\x61\x79\x65\x72\x20\x32\x20\x2d\x20\x50\x6f\x73\x69\x74\x69""\x6f\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20""\x32\x20\x28\x32\x2f\x34\x29"
<operator>.assignment lh[60]="\x50\x6c\x61\x79\x65\x72""\x20\x32\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65""\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x32\x20\x28\x33\x2f\x34""\x29"
<operator>.assignment lp[60]="\x50\x6c\x61\x79\x65\x72\x20\x32\x20\x2d\x20\x50""\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65\x20""\x62\x6f\x61\x74\x20\x32\x20\x28\x34\x2f\x34\x29"
<operator>.assignment lo[60]="\x50""\x6c\x61\x79\x65\x72\x20\x32\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f""\x6e\x20\x74\x68\x65\x20\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x33""\x20\x28\x31\x2f\x32\x29"
<operator>.assignment lr[60]="\x50\x6c\x61\x79\x65\x72\x20""\x32\x20\x2d\x20\x50\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x68\x65\x20""\x73\x69\x7a\x65\x20\x62\x6f\x61\x74\x20\x33\x20\x28\x32\x2f\x32\x29"
la la(lf==1)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lf==2)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lf==3)
BLOCK <empty> <empty>
<operator>.equals ls==1
la la(lb==1)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==2)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==3)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==4)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==5)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==6)
BLOCK <empty> <empty>
la la(lb==1)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==2)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==3)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==4)
BLOCK <empty> <empty>
la la(lb==1)
BLOCK <empty> <empty>
la la(lb==2)
BLOCK <empty> <empty>
<operator>.equals ls==2
la la(lb==1)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==2)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==3)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==4)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==5)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==6)
BLOCK <empty> <empty>
la la(lb==1)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==2)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==3)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==4)
BLOCK <empty> <empty>
la la(lb==1)
BLOCK <empty> <empty>
IDENTIFIER le <empty>
la la(lb==2)
BLOCK <empty> <empty>
<operator>.equals lf==1
ld ld(lg)
ld ld(lq)
ld ld(lm)
ld ld(li)
ld ld(ln)
ld ld(lj)
<operator>.equals lf==2
ld ld(lk)
ld ld(ll)
ld ld(lh)
ld ld(lp)
<operator>.equals lf==3
ld ld(lo)
ld ld(lr)
<operator>.equals lf==1
ld ld(lg)
ld ld(lq)
ld ld(lm)
ld ld(li)
ld ld(ln)
ld ld(lj)
<operator>.equals lf==2
ld ld(lk)
ld ld(ll)
ld ld(lh)
ld ld(lp)
<operator>.equals lf==3
ld ld(lo)
ld ld(lr)
<operator>.equals lb==1
<operator>.equals lb==2
<operator>.equals lb==3
<operator>.equals lb==4
<operator>.equals lb==5
<operator>.equals lb==6
<operator>.equals lb==1
<operator>.equals lb==2
<operator>.equals lb==3
<operator>.equals lb==4
<operator>.equals lb==1
<operator>.equals lb==2
<operator>.equals lb==1
<operator>.equals lb==2
<operator>.equals lb==3
<operator>.equals lb==4
<operator>.equals lb==5
<operator>.equals lb==6
<operator>.equals lb==1
<operator>.equals lb==2
<operator>.equals lb==3
<operator>.equals lb==4
<operator>.equals lb==1
<operator>.equals lb==2
>>>PDG&170 0->2 0->3 0->4 0->6 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->25 0->26 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->42 0->43 0->45 0->46 0->48 0->49 0->51 0->52 0->54 0->55 0->57 0->58 0->60 0->61 0->63 0->64 0->66 0->68 0->69 0->71 0->72 0->74 0->75 0->77 0->79 0->81 0->82 0->84 0->85 0->87 0->88 0->90 0->91 0->93 0->94 0->96 0->97 0->99 0->101 0->102 0->104 0->105 0->107 0->108 0->110 0->112 0->113 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->127 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->138 0->139 0->140 0->141 0->142 0->143 0->144 0->145 0->146 0->147 0->148 0->149 0->150 0->151 0->152 0->153 0->154 0->155 0->156 0->157 0->158 0->159 0->160 0->161 0->162 0->163 0->164 0->165 0->166 0->167 0->168 0->169 2->49 3->116 4->146 5->1 5->1 7->1 7->1 9->1 9->117 10->1 10->118 11->1 11->119 12->1 12->120 13->1 13->121 14->1 14->122 15->1 15->124 16->1 16->125 17->1 17->126 18->1 18->127 19->1 19->129 20->1 20->130 29->1 29->132 30->1 30->133 31->1 31->134 32->1 32->135 33->1 33->136 34->1 34->137 35->1 35->139 36->1 36->140 37->1 37->141 38->1 38->142 39->1 39->144 40->1 40->145 41->1 41->1 44->1 44->1 47->1 47->1 49->5 49->5 49->82 82->1 82->7 82->7 95->1 95->1 98->1 98->1 106->1 106->1 109->1 109->1 111->1 111->1 114->1 114->1 116->21 116->21 116->123 123->24 123->24 123->128 128->27 128->27 128->131 131->41 131->41 131->138 132->1 132->1 133->1 133->1 134->1 134->1 135->1 135->1 136->1 136->1 137->1 137->1 138->44 138->44 138->143 139->1 139->1 140->1 140->1 141->1 141->1 142->1 142->1 143->1 143->47 143->47 144->1 144->1 145->1 145->1 146->50 146->50 146->147 147->53 147->53 147->148 148->56 148->56 148->149 149->59 149->59 149->150 150->62 150->62 150->151 151->65 151->65 151->152 152->67 152->67 152->153 153->70 153->70 153->154 154->73 154->73 154->155 155->76 155->76 155->156 156->78 156->78 156->157 157->80 157->80 157->158 158->83 158->83 158->159 159->86 159->86 159->160 160->89 160->89 160->161 161->92 161->92 161->162 162->95 162->95 162->163 163->98 163->98 163->164 164->100 164->100 164->165 165->103 165->103 165->166 166->106 166->106 166->167 167->109 167->109 167->168 168->111 168->111 168->169 169->1 169->114 169->114
>>>Token lv lu ( lt ls , lt lf , lt lb ) { la ( ls == 1 ) { lc lg [ 60 ] = " \x50 \x6c \x61 \x79 \x65 " " \x72 \x20 \x31 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 " " \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x31 \x20 \x28 \x31 \x2f " " \x36 \x29 " ; lc lq [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x31 \x20 \x2d \x20 " " \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 " " \x20 \x62 \x6f \x61 \x74 \x20 \x31 \x20 \x28 \x32 \x2f \x36 \x29 " ; lc lm [ 60 ] = " " " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x31 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 " " \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 " " \x31 \x20 \x28 \x33 \x2f \x36 \x29 " ; lc li [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 " " \x20 \x31 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 " " \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x31 \x20 \x28 \x34 \x2f \x36 " " \x29 " ; lc ln [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x31 \x20 \x2d \x20 \x50 " " \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 " " \x62 \x6f \x61 \x74 \x20 \x31 \x20 \x28 \x35 \x2f \x36 \x29 " ; lc lj [ 60 ] = " \x50 " " \x6c \x61 \x79 \x65 \x72 \x20 \x31 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f " " \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x31 " " \x20 \x28 \x36 \x2f \x36 \x29 " ; lc lk [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 " " \x31 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 " " \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x32 \x20 \x28 \x31 \x2f \x34 \x29 " ; lc ll [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x31 \x20 \x2d \x20 \x50 \x6f \x73 " " \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f " " \x61 \x74 \x20 \x32 \x20 \x28 \x32 \x2f \x34 \x29 " ; lc lh [ 60 ] = " \x50 \x6c \x61 " " \x79 \x65 \x72 \x20 \x31 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 " " \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x32 \x20 \x28 " " \x33 \x2f \x34 \x29 " ; lc lp [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x31 \x20 " " \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 " " \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x32 \x20 \x28 \x34 \x2f \x34 \x29 " ; lc lo [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x31 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 " " \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 " " \x20 \x33 \x20 \x28 \x31 \x2f \x32 \x29 " ; lc lr [ 60 ] = " \x50 \x6c \x61 \x79 \x65 " " \x72 \x20 \x31 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 " " \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x33 \x20 \x28 \x32 \x2f " " \x32 \x29 " ; la ( lf == 1 )  { la ( lb == 1 ) { ld ( lg ) ; } le la ( lb == 2 ) { ld ( lq ) ; } le la ( lb == 3 ) { ld ( lm ) ; } le la ( lb == 4 ) { ld ( li ) ; } le la ( lb == 5 ) { ld ( ln ) ; } le la ( lb == 6 ) { ld ( lj ) ; } } le la ( lf == 2 ) { la ( lb == 1 ) { ld ( lk ) ; } le la ( lb == 2 ) { ld ( ll ) ; } le la ( lb == 3 ) { ld ( lh ) ; } le la ( lb == 4 ) { ld ( lp ) ; } } le la ( lf == 3 ) { la ( lb == 1 ) { ld ( lo ) ; } la ( lb == 2 ) { ld ( lr ) ; } } } la ( ls == 2 )  { lc lg [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 " " \x32 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 " " \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x31 \x20 \x28 \x31 \x2f \x36 \x29 " ; lc lq [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x32 \x20 \x2d \x20 \x50 \x6f \x73 " " \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f " " \x61 \x74 \x20 \x31 \x20 \x28 \x32 \x2f \x36 \x29 " ; lc lm [ 60 ] = " \x50 \x6c \x61 " " \x79 \x65 \x72 \x20 \x32 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 " " \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x31 \x20 \x28 " " \x33 \x2f \x36 \x29 " ; lc li [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x32 \x20 " " \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 " " \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x31 \x20 \x28 \x34 \x2f \x36 \x29 " ; lc ln [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x32 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 " " \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 " " \x20 \x31 \x20 \x28 \x35 \x2f \x36 \x29 " ; lc lj [ 60 ] = " \x50 \x6c \x61 \x79 \x65 " " \x72 \x20 \x32 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 " " \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x31 \x20 \x28 \x36 \x2f " " \x36 \x29 " ; lc lk [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x32 \x20 \x2d \x20 " " \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 " " \x20 \x62 \x6f \x61 \x74 \x20 \x32 \x20 \x28 \x31 \x2f \x34 \x29 " ; lc ll [ 60 ] = " " " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x32 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 " " \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 " " \x32 \x20 \x28 \x32 \x2f \x34 \x29 " ; lc lh [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 " " \x20 \x32 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 " " \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x32 \x20 \x28 \x33 \x2f \x34 " " \x29 " ; lc lp [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 \x32 \x20 \x2d \x20 \x50 " " \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 " " \x62 \x6f \x61 \x74 \x20 \x32 \x20 \x28 \x34 \x2f \x34 \x29 " ; lc lo [ 60 ] = " \x50 " " \x6c \x61 \x79 \x65 \x72 \x20 \x32 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f " " \x6e \x20 \x74 \x68 \x65 \x20 \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x33 " " \x20 \x28 \x31 \x2f \x32 \x29 " ; lc lr [ 60 ] = " \x50 \x6c \x61 \x79 \x65 \x72 \x20 " " \x32 \x20 \x2d \x20 \x50 \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x68 \x65 \x20 " " \x73 \x69 \x7a \x65 \x20 \x62 \x6f \x61 \x74 \x20 \x33 \x20 \x28 \x32 \x2f \x32 \x29 " ; la ( lf == 1 )  { la ( lb == 1 ) { ld ( lg ) ; } le la ( lb == 2 ) { ld ( lq ) ; } le la ( lb == 3 ) { ld ( lm ) ; } le la ( lb == 4 ) { ld ( li ) ; } le la ( lb == 5 ) { ld ( ln ) ; } le la ( lb == 6 ) { ld ( lj ) ; } } le la ( lf == 2 ) { la ( lb == 1 ) { ld ( lk ) ; } le la ( lb == 2 ) { ld ( ll ) ; } le la ( lb == 3 ) { ld ( lh ) ; } le la ( lb == 4 ) { ld ( lp ) ; } } le la ( lf == 3 ) { la ( lb == 1 ) { ld ( lo ) ; } le la ( lb == 2 ) { ld ( lr ) ; } } } }
>>>Func
METHOD lk
METHOD_RETURN lm
le le("\x25\x64",&lg)
<operator>.lessEqualsThan lb<=lg
<operator>.preIncrement ++lb
IDENTIFIER li <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lm lk ( ) { le ( " \x25 \x64 " , & lg ) ; lj ( lb = 1  ; lb <= lg ; ++ lb ) { ld ( " \x43 \x61 \x73 \x65 " " \x20 \x23 \x25 \x64 \x3a \x20 " , lb ) ; le ( " \x25 \x6c \x6c \x64 \x25 \x6c \x6c \x64 " " \x25 \x6c \x6c \x64 " , & lf , & la , & lc ) ; lh ( lf >= 100 / ln ( la , 100 ) && ! ( la != 100 && lc == 100 ) && ! ( la && ! lc ) )  ld ( " \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " ) ; ll ld ( " " " \x42 \x72 \x6f \x6b \x65 \x6e \n " ) ; } li 0 ; }
>>>Func
METHOD lm
METHOD_RETURN le
PARAM le
<operator>.lessThan la<lh
<operator>.postIncrement la++
>>>PDG&5 0->2 0->3 0->4 2->1 3->1 3->1 3->4 4->1 4->1
>>>Token le lm ( le ) { lj lb [ ld ] ; lf la ; li ( la = 0  ; la < lh ; la ++ ) { lf lc ; lg ( " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , la + 1 ) ; ln ( lb , ld , lk ) ; lc = ll ( lb ) ; lg ( " \x25 " " \x64 \n " , lc ) ; } }
>>>Func
METHOD lp
METHOD_RETURN lf
PARAM lr
<operator>.lessEqualsThan la<=le
<operator>.postIncrement la++
IDENTIFIER ln <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 3->1 3->4 4->1 4->1
>>>Token lf lp ( lr ) { lf le , la ; lf lc , lb ; ld ( lg ( " \x25 \x64 " , & le ) , la = 1  ; la <= le ; la ++ ) { lg ( " \x25 \x64 " , & lh ) ; ld ( lc = 0  ; lc < 2 ; lc ++ ) { ld ( lb = 0  ; lb < lh ; lb ++ ) { lg ( " \x25 " " \x64 " , & ( lq [ lc ] [ lb ] ) ) ; } } lj = lk ; ll ( li , 0 , lo ( li ) ) ; ls ( 0 , 0 ) ; lm ( " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , la , lj ) ; } ln 0 ; }
>>>Func
METHOD lu
METHOD_RETURN lw
<operator>.assignment le=300
<operator>.assignment lf=2
<operator>.assignment lc=30
IDENTIFIER lb <empty>
<operator>.assignment lb.l2=lc
<operator>.assignment lb.ly=lc
<operator>.assignment lb.lv=lf
<operator>.assignment lb.lp=(ld* )ll(lc*lc*lf*ln(ld))
<operator>.lessThan la<lz(lc,le)
<operator>.postIncrement la++
l4 l4(lg,le)
l3 l3("\x74\x65\x73\x74""\x31\x2e\x63\x73\x76",lg,le,lf)
lq lq("\x77\x31\x31\x2e\x63\x73\x76",&lb)
l6 l6(lg,&lb,le,lf,lc,1e-4)
lq lq("\x77\x31\x32\x2e\x63\x73\x76",&lb)
<operator>.lessThan la<le
<operator>.postIncrement la++
lm lm(lg)
lm lm(lb.lp)
<operator>.cast (ld* )ll(lc*lc*lf*ln(ld))
lz lz(lc,le)
ll ll(lc*lc*lf*ln(ld))
<operator>.multiplication lc*lc*lf*ln(ld)
<operator>.multiplication lc*lc*lf
ln ln(ld)
<operator>.multiplication lc*lc
>>>PDG&28 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->25 0->26 0->27 2->1 2->22 3->1 3->8 3->25 4->1 4->6 4->7 4->27 6->1 6->1 6->14 6->15 6->16 6->20 7->1 7->1 7->14 7->15 7->16 7->20 8->1 8->1 8->14 8->15 8->16 8->20 9->1 9->1 9->14 9->15 9->16 9->20 10->1 10->1 10->11 11->17 12->1 12->13 12->13 13->1 13->15 13->15 13->15 14->1 14->15 14->16 14->20 15->1 15->1 15->1 15->16 15->17 15->19 15->20 16->1 16->1 17->1 17->1 17->18 18->1 18->1 19->1 19->1 20->1 20->1 21->1 22->10 22->10 22->12 22->15 23->1 23->9 23->21 24->1 24->1 24->23 24->23 25->1 25->13 25->24 25->24 26->1 26->24 27->22 27->25
>>>Token lw lu ( ) { lh li , le = 300 ; lh lf = 2 ; lh lc = 30 ; ld * * lg = ( ld * * ) ll ( le * ln ( ld *  ) ) ; lx l5 lb ; lb . l2 = lc ; lb . ly = lc ; lb . lv = lf ; lb . lp = ( ld * ) ll ( lc * lc * lf * ln ( ld ) ) ; lj ( lh  la = 0 ; la < lz ( lc , le ) ; la ++ ) { lo ( la < le ) lg [ la ] = ( ld * ) ll ( lf * ln ( ld ) ) ; lo ( la < lc )  { lj ( lh  lk = 0 ; lk < lc ; lk ++ ) { l8 l7  l1 lj ( li < ls ' ' >= 0 ; li < lf ; li ++ ) { ld * lr = l0 ( & lb , la , lk , li ) ; lr [ 0 ] = lt ( -5 , 5 ) ; } } } } l4 ( lg , le ) ; l3 ( " \x74 \x65 \x73 \x74 " " \x31 \x2e \x63 \x73 \x76 " , lg , le , lf ) ; lq ( " \x77 \x31 \x31 \x2e \x63 \x73 \x76 " , & lb ) ; l6 ( lg , & lb , le , lf , lc , 1e-4 ) ; lq ( " \x77 \x31 \x32 \x2e \x63 \x73 \x76 " , & lb ) ; lj ( lh  la = 0 ; la < le ; la ++ ) lm ( lg [ la ] ) ; lm ( lg ) ; lm ( lb . lp ) ; }
>>>Func
METHOD lp
METHOD_RETURN lo
PARAM lc lg
PARAM lc le
<operator>.assignment lh=lj[0]
<operator>.assignment la=0
<operator>.assignment lb=0
<operator>.assignment ld=0
li li(la<lg)
BLOCK <empty> <empty>
ln ln("\x25\x66\n",ld/4)
<operator>.assignmentPlus ld+=le* (lf[la]-1)
<operator>.assignmentPlus lh+=le* (lf[la]-1)
<operator>.assignment lb=0
li li(la<lg&&lj[la]<lh)
<operator>.assignmentPlus lb+=lf[la++]
lk lk(la==lg)
<operator>.assignmentPlus ld+=le* (lb-1)
<operator>.lessThan la<lg
<operator>.division ld/4
<operator>.multiplication le* (lf[la]-1)
<operator>.multiplication le* (lf[la]-1)
<operator>.logicalAnd la<lg&&lj[la]<lh
<operator>.equals la==lg
<operator>.multiplication le* (lb-1)
<operator>.subtraction lf[la]-1
<operator>.subtraction lf[la]-1
<operator>.lessThan la<lg
<operator>.lessThan lj[la]<lh
<operator>.postIncrement la++
<operator>.subtraction lb-1
<operator>.indirectIndexAccess lj[la]
>>>PDG&32 0->2 0->3 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->15 0->17 0->18 0->19 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 2->18 3->20 4->1 4->1 4->12 5->1 5->18 7->1 7->11 8->1 10->1 10->1 11->1 11->17 12->1 12->1 12->1 12->28 13->1 13->15 14->1 14->1 15->1 15->1 15->30 16->1 16->1 17->1 17->1 17->19 18->8 18->8 18->27 18->27 19->1 19->10 19->10 20->11 20->11 20->21 21->1 21->12 21->12 21->24 22->1 22->1 22->14 22->14 23->1 23->1 23->16 23->16 24->1 24->1 24->17 24->17 25->20 25->20 25->26 26->1 26->21 26->21 27->22 27->22 27->23 27->28 27->29 27->31 28->1 28->1 28->22 28->22 29->23 30->1 30->24 30->24
>>>Token lo lp ( lc lg , lc le ) { lc lh = lj [ 0 ] ; lc la = 0 ; lc lb = 0 ; ll ld = 0 ; li ( la < lg )  { ld += le * ( lf [ la ] - 1 ) ; lh += le * ( lf [ la ] - 1 ) ; lb = 0 ; li ( la < lg && lj [ la ] < lh ) lb += lf [ la ++ ] ; lk ( la == lg ) ld += le * ( lb - 1 ) ; lm lf [ ++ la ] + = lb + 1 ; } ln ( " \x25 \x66 \n " , ld / 4 ) ; }
>>>Func
METHOD ll
METHOD_RETURN lk
<operator>.assignment lc=lj("\x42\x69\x6e\x70\x2e\x74\x78\x74","\x72")
lg lg(lc==lh)
le le("\n\x65\x72\x72\x6f\x72\x20\x69\x6e\x70\x75\x74\x20\x66\x69\x6c\x65""\n")
<operator>.assignment lb=lj("\x6f\x75\x74\x70\x75\x74","\x77")
lg lg(lb==lh)
le le("\n\x45""\x52\x52\x4f\x52\x20\x2d\x6f\x75\x74\x70\x75\x74\x20\x66\x69\x6c\x65""\n")
<operator>.assignment ld=0
lp lp(lc,"\x25\x64",&ld)
<operator>.lessThan la<ld
<operator>.postIncrement la++
lf lf(lb,"\n")
li li(lc)
li li(lb)
IDENTIFIER ln <empty>
LITERAL 0 <empty>
lj lj("\x42\x69\x6e\x70\x2e\x74\x78\x74","\x72")
<operator>.equals lc==lh
lj lj("\x6f\x75\x74\x70\x75\x74","\x77")
<operator>.equals lb==lh
>>>PDG&21 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 2->1 2->1 2->18 3->1 3->1 4->1 5->1 5->1 5->20 6->1 6->1 7->1 8->1 8->9 8->10 9->1 9->1 9->10 9->13 10->1 10->1 10->11 11->1 11->1 12->1 12->14 13->1 13->1 14->1 14->1 17->2 17->2 18->3 18->3 18->9 18->20 19->5 19->5 20->1 20->6 20->6 20->12
>>>Token lk ll ( ) { lc = lj ( " \x42 \x69 \x6e \x70 \x2e \x74 \x78 \x74 " , " \x72 " ) ; lg ( lc == lh )  le ( " \n \x65 \x72 \x72 \x6f \x72 \x20 \x69 \x6e \x70 \x75 \x74 \x20 \x66 \x69 \x6c \x65 " " \n " ) ; lb = lj ( " \x6f \x75 \x74 \x70 \x75 \x74 " , " \x77 " ) ; lg ( lb == lh )  le ( " \n \x45 " " \x52 \x52 \x4f \x52 \x20 \x2d \x6f \x75 \x74 \x70 \x75 \x74 \x20 \x66 \x69 \x6c \x65 " " \n " ) ; lk ld , la ; ld = 0 ; lp ( lc , " \x25 \x64 " , & ld ) ; lo ( la = 0  ; la < ld ; la ++ ) { le ( " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , la + 1 ) ; lf ( lb , " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , la + 1 ) ; lm ( ) ; le ( " \n " ) ; lf ( lb , " \n " ) ; } lf ( lb , " \n " ) ; li ( lc ) ; li ( lb ) ; ln 0 ; }
>>>Func
METHOD lx
METHOD_RETURN lf
PARAM l1 ld[]
PARAM lj lh
PARAM ln le
<operator>.assignment *lb=l3
ls ls(le<=1)
BLOCK <empty> <empty>
IDENTIFIER lu <empty>
ls ls(le<lh)
BLOCK <empty> <empty>
IDENTIFIER lu <empty>
BLOCK <empty> <empty>
<operator>.assignment lb=(lf* )lr(ll(lf))
lt lt(lb 0 ll(lf))
l4 l4(ld,lh,lb)
<operator>.assignment lb=lr(ll(lf) *le)
lt lt(lb 0 le*ll(lf))
<operator>.lessThan la<lh
<operator>.postIncrement la++
<operator>.assignment lq=0
<operator>.assignment lv=lh/10000
<operator>.assignment lg=0
IDENTIFIER ly <empty>
BLOCK <empty> <empty>
l0 l0(lq>lv)
<operator>.assignment lb=(lf* )lr(ll(lf) *le)
lt lt(lb 0 le*ll(lf))
<operator>.lessThan la<lh
<operator>.postIncrement la++
<operator>.lessEqualsThan le<=1
<operator>.lessThan le<lh
<operator>.lessThan lc<le
<operator>.postIncrement lc++
<operator>.lessThan la<lh
<operator>.postIncrement la++
<operator>.lessThan lc<le
<operator>.postIncrement lc++
<operator>.assignment lq=0
<operator>.lessThan la<lh
<operator>.postIncrement la++
<operator>.cast (lf* )lr(ll(lf))
ll ll(lf)
lr lr(ll(lf) *le)
<operator>.multiplication le*ll(lf)
<operator>.division lh/10000
<operator>.greaterThan lq>lv
<operator>.cast (lf* )lr(ll(lf) *le)
<operator>.multiplication le*ll(lf)
lr lr(ll(lf))
<operator>.multiplication ll(lf) *le
ll ll(lf)
lr lr(ll(lf) *le)
ll ll(lf)
ll ll(lf)
ll ll(lf)
<operator>.multiplication ll(lf) *le
ll ll(lf)
>>>PDG&58 0->2 0->3 0->4 0->5 0->7 0->8 0->10 0->11 0->12 0->14 0->15 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->42 0->44 0->45 0->46 0->48 0->50 0->51 0->53 0->54 0->55 0->56 0->57 2->15 3->15 4->30 5->1 5->1 6->1 6->1 9->1 9->1 13->1 13->1 13->14 14->1 14->15 15->1 15->1 15->31 16->1 16->17 18->19 18->45 19->34 21->1 21->1 21->46 22->1 22->1 25->1 25->1 26->1 26->1 26->27 27->1 27->1 27->1 28->1 28->1 28->29 29->1 29->1 30->6 30->6 30->31 31->9 31->9 31->18 31->50 32->33 32->36 33->36 34->35 34->39 35->39 36->1 36->37 36->56 37->1 37->1 38->1 38->46 39->28 39->40 40->28 41->1 42->14 42->55 43->16 44->17 44->17 44->32 45->21 45->21 45->34 46->1 46->1 46->25 46->25 47->1 48->1 48->1 48->27 48->27 49->13 49->41 50->43 50->43 50->44 51->44 51->57 52->1 52->26 52->47 53->1 53->48 54->42 54->49 55->50 55->51 56->48 56->52 56->52 57->53 57->56
>>>Token lf * lx ( l1 ld [ ] , lj lh , ln le ) { lf * lb = l3 ; ls ( le <= 1 )  { lb = ( lf * ) lr ( ll ( lf ) ) ; lt ( lb , 0 , ll ( lf ) ) ; l4 ( ld , lh , lb ) ; } lu ls ( le < lh ) { lb = lr ( ll ( lf ) * le ) ; lt ( lb , 0 , le * ll ( lf ) ) ; lk ( lj  la = 0 ; la < lh ; la ++ ) { ld [ la ] . lo = lw ( ) % le ; } lj lq = 0 ; lj lv = lh / 10000 ; ln lg = 0 ; ly { lk ( ln lc  = 0 ; lc < le ; lc ++ ) { lb [ lc ] . lm = 0 ; lb [ lc ] . li = 0 ; lb [ lc ] . lp = 0 ; } lk ( lj  la = 0 ; la < lh ; la ++ ) { lg = ld [ la ] . lo ; lb [ lg ] . lm += ld [ la ] . lm ; lb [ lg ] . li += ld [ la ] . li ; lb [ lg ] . lp ++ ; } lk ( ln  lc = 0 ; lc < le ; lc ++ ) { lb [ lc ] . lm /= lb [ lc ] . lp ; lb [ lc ] . li /= lb [ lc ] . lp ; } lq = 0 ; lk ( lj  la = 0 ; la < lh ; la ++ ) { lg = l2 ( ld + la , lb , le ) ; ls ( lg != ld [ la ] . lo )  { lq ++ ; ld [ la ] . lo = lg ; } } } l0 ( lq > lv ) ; } lu { lb = ( lf * ) lr ( ll ( lf ) * le ) ; lt ( lb , 0 , le * ll ( lf ) ) ; lk ( ln  la = 0 ; la < lh ; la ++ ) { lb [ la ] . lm = ld [ la ] . lm ; lb [ la ] . li = ld [ la ] . li ; lb [ la ] . lp = 1 ; ld [ la ] . lo = la ; } } lz lb ; }
>>>Func
METHOD li
METHOD_RETURN lh
PARAM lg ld
<operator>.notEquals lc[la]!=la
<operator>.notEquals lc[lb]!=lb
>>>PDG&5 0->2 0->3 0->4 2->1 3->1 3->1 3->1 4->1 4->1 4->1
>>>Token lh li ( lg ld ) { lg la , lb , le ; lf ( la = ld  ; lc [ la ] != la ; ) la = lc [ la ] ; lf ( lb = ld  ; lc [ lb ] != lb ; ) { le = lc [ lb ] ; lc [ lb ] = la ; lb = le ; } }
>>>Func
METHOD l29
METHOD_RETURN ld
PARAM ld lj
PARAM lp* *le
<operator>.assignment lm=10
<operator>.assignment *lh=lt
l22 l22(&lj,&le)
l28 l28(le[0])
l25 l25(l11,"")
l14 l14(lx,l44)
l49 l49(lx)
l12 l12(lf)
l45 l45(l27)
<operator>.lessThan la<lj
lc lc(lh)
BLOCK <empty> <empty>
lc lc(la==lj)
BLOCK <empty> <empty>
<operator>.assignment lb=0
<operator>.assignment ln=(l46(lm)!=-1||lb==0)
<operator>.assignment lg=l5()
lc lc(lg==-1&&lb!=0)
lr lr(lf lb lk("\x63\x61\x6e\x6e\x6f\x74\x20\x67\x65""\x74\x20\x6e\x69\x63\x65\x6e\x65\x73\x73"))
<operator>.assignment ln=(l51(l31,0,lg+lm)==0)
IDENTIFIER l10 <empty>
lc lc(!ln)
BLOCK <empty> <empty>
l30 l30(le[la],&le[la])
<operator>.assignment l3=lb==l17?l19:l41
lv lv(0 lb "\x25\x73" ly(le[la]))
IDENTIFIER l52 <empty>
BLOCK <empty> <empty>
IDENTIFIER lq <empty>
lc lc(l36<l32(lh,lt,10,&lq,""))
lr lr(lf 0 lk("\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x64\x6a\x75\x73""\x74\x6d\x65\x6e\x74\x20\x25\x73") ly(lh))
<operator>.assignment lm=l18(l1 l43(lq,lz))
lc lc(lh)
BLOCK <empty> <empty>
<operator>.assignment lb=0
<operator>.assignment lg=l5()
lc lc(lg==-1&&lb!=0)
lr lr(lf lb lk("\x63\x61\x6e\x6e\x6f""\x74\x20\x67\x65\x74\x20\x6e\x69\x63\x65\x6e\x65\x73\x73"))
l48 l48("""\x25\x64\n",lg)
lv lv(l35(lb)?0:lf lb lk("\x63\x61\x6e\x6e\x6f\x74\x20\x73""\x65\x74\x20\x6e\x69\x63\x65\x6e\x65\x73\x73"))
<operator>.expressionList l1=1-2*l6 lz=2*l6-1
<operator>.equals la==lj
lv lv(0 0 lk("\x61\x20\x63\x6f\x6d\x6d\x61\x6e\x64\x20""\x6d\x75\x73\x74\x20\x62\x65\x20\x67\x69\x76\x65\x6e\x20\x77\x69\x74""\x68\x20\x61\x6e\x20\x61\x64\x6a\x75\x73\x74\x6d\x65\x6e\x74"))
l0 l0(lf)
<operator>.logicalOr l46(lm)!=-1||lb==0
<operator>.logicalAnd lg==-1&&lb!=0
lk lk("\x63\x61\x6e\x6e\x6f\x74\x20\x67\x65""\x74\x20\x6e\x69\x63\x65\x6e\x65\x73\x73")
<operator>.equals l51(l31,0,lg+lm)==0
<operator>.logicalNot !ln
<operator>.conditional lb==l17?l19:l41
ly ly(le[la])
<operator>.lessThan l36<l32(lh,lt,10,&lq,"")
lk lk("\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x64\x6a\x75\x73""\x74\x6d\x65\x6e\x74\x20\x25\x73")
ly ly(lh)
l18 l18(l1 l43(lq,lz))
<operator>.logicalAnd lg==-1&&lb!=0
lk lk("\x63\x61\x6e\x6e\x6f""\x74\x20\x67\x65\x74\x20\x6e\x69\x63\x65\x6e\x65\x73\x73")
<operator>.notEquals l46(lm)!=-1
<operator>.equals lb==0
<operator>.equals lg==-1
<operator>.notEquals lb!=0
l51 l51(l31,0,lg+lm)
<operator>.conditional l35(lb)?0:lf
lk lk("\x63\x61\x6e\x6e\x6f\x74\x20\x73""\x65\x74\x20\x6e\x69\x63\x65\x6e\x65\x73\x73")
<operator>.equals lb==l17
<operator>.assignment l1=1-2*l6
<operator>.assignment lz=2*l6-1
l32 l32(lh,lt,10,&lq,"")
l43 l43(lq,lz)
lk lk("\x61\x20\x63\x6f\x6d\x6d\x61\x6e\x64\x20""\x6d\x75\x73\x74\x20\x62\x65\x20\x67\x69\x76\x65\x6e\x20\x77\x69\x74""\x68\x20\x61\x6e\x20\x61\x64\x6a\x75\x73\x74\x6d\x65\x6e\x74")
<operator>.equals lg==-1
<operator>.notEquals lb!=0
l46 l46(lm)
<operator>.minus -1
<operator>.minus -1
<operator>.addition lg+lm
l35 l35(lb)
<operator>.subtraction 1-2*l6
<operator>.subtraction 2*l6-1
<operator>.minus -1
<operator>.multiplication 2*l6
<operator>.multiplication 2*l6
>>>PDG&86 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->20 0->22 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->34 0->36 0->37 0->38 0->39 0->41 0->42 0->43 0->45 0->46 0->47 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 2->6 2->13 3->1 3->6 3->7 3->27 3->54 4->1 5->1 5->1 5->14 5->36 5->57 5->71 6->1 6->1 6->1 6->13 6->27 6->45 7->1 7->1 8->1 8->1 9->1 9->1 9->10 10->1 10->1 11->1 11->34 12->1 12->1 13->1 13->45 13->45 14->71 16->1 16->1 18->1 18->22 18->62 18->64 19->1 19->1 20->1 20->1 20->63 21->1 21->1 22->1 22->1 22->43 22->66 22->80 23->1 23->1 23->52 25->1 25->1 27->1 27->1 27->54 27->54 28->1 28->1 28->1 29->1 29->1 29->1 33->1 33->1 34->1 34->1 34->1 34->47 35->1 35->1 35->76 36->1 36->1 38->41 38->75 39->74 41->1 41->1 41->22 42->1 43->1 43->1 43->1 43->68 44->1 44->1 44->1 45->1 45->1 45->16 45->16 46->1 46->1 47->1 47->41 48->1 48->1 48->19 48->19 49->1 49->1 49->21 49->21 50->22 51->1 51->23 51->23 52->1 52->25 53->1 53->1 53->1 54->1 54->29 55->1 55->1 55->33 55->33 56->34 57->34 57->36 58->1 58->1 58->35 58->35 59->40 59->40 59->49 60->41 61->1 61->48 61->48 61->62 62->22 62->48 62->48 62->64 63->1 63->49 63->49 63->64 63->65 63->79 64->22 64->49 64->49 65->1 65->1 65->51 65->51 65->51 66->1 66->1 67->43 68->1 68->29 69->1 69->44 69->58 70->1 70->44 70->72 71->1 71->1 71->55 71->55 71->55 71->55 71->55 71->57 71->72 72->1 72->1 72->58 72->58 73->46 74->42 74->59 74->59 74->75 75->41 75->59 75->59 76->61 76->65 76->79 77->61 78->63 79->1 79->1 80->43 81->44 81->44 81->69 81->69 82->1 82->44 82->44 82->70 82->70 83->74 84->81 84->81 84->85 85->1 85->82 85->82
>>>Token ld l29 ( ld lj , lp * * le ) { ld lg ; ld lm = 10 ; lp l7 * lh = lt ; l37 ln ; ld la ; l22 ( & lj , & le ) ; l28 ( le [ 0 ] ) ; l25 ( l11 , " " ) ; l14 ( lx , l44 ) ; l49 ( lx ) ; l12 ( lf ) ; l45 ( l27 ) ; l47 ( la = 1  ; la < lj ; ) { lp l7 * li = le [ la ] ; lc ( li [ 0 ] == ' ' && l50 ( li [ 1 + ( li [ 1 ] == ' ' || li [ 1 ] == ' ' ) ] ) )  { lh = li + 1 ; ++ la ; } l26  { ld lo ; ld lw = lj - ( la - 1 ) ; lp * * ls = le + ( la - 1 ) ; ls [ 0 ] = le [ 0 ] ; l2 = 0 ; lo = l39 ( lw , ls , " \x2b \x6e \x3a " , l16 , lt ) ; la += l2 - 1 ; l38 ( lo ) { l4 ' ' : lh = l8 ; ll ; l4 - 1 : ll ; l15 ; l13 ( l23 , l21 ) ; l20 : l0 ( lf ) ; ll ; } lc ( lo == -1 ) ll ; } } lc ( lh ) { l52 { l1 = 1 - 2 * l6 , lz = 2 * l6 - 1 } ; l24 ld lq ; lc ( l36 < l32 ( lh , lt , 10 , & lq , " " ) )  lr ( lf , 0 , lk ( " \x69 \x6e \x76 \x61 \x6c \x69 \x64 \x20 \x61 \x64 \x6a \x75 \x73 " " \x74 \x6d \x65 \x6e \x74 \x20 \x25 \x73 " ) , ly ( lh ) ) ; lm = l18 ( l1 , l43 ( lq , lz ) ) ; } lc ( la == lj )  { lc ( lh ) { lv ( 0 , 0 , lk ( " \x61 \x20 \x63 \x6f \x6d \x6d \x61 \x6e \x64 \x20 " " \x6d \x75 \x73 \x74 \x20 \x62 \x65 \x20 \x67 \x69 \x76 \x65 \x6e \x20 \x77 \x69 \x74 " " \x68 \x20 \x61 \x6e \x20 \x61 \x64 \x6a \x75 \x73 \x74 \x6d \x65 \x6e \x74 " ) ) ; l0 ( lf ) ; } lb = 0 ; lg = l5 ( ) ; lc ( lg == -1 && lb != 0 )  lr ( lf , lb , lk ( " \x63 \x61 \x6e \x6e \x6f " " \x74 \x20 \x67 \x65 \x74 \x20 \x6e \x69 \x63 \x65 \x6e \x65 \x73 \x73 " ) ) ; l48 ( " " " \x25 \x64 \n " , lg ) ; lu l33 ; } lb = 0 ; l42 ln = ( l46 ( lm ) != -1 || lb == 0 ) ; l9 lg = l5 ( ) ; lc ( lg == -1 && lb != 0 )  lr ( lf , lb , lk ( " \x63 \x61 \x6e \x6e \x6f \x74 \x20 \x67 \x65 " " \x74 \x20 \x6e \x69 \x63 \x65 \x6e \x65 \x73 \x73 " ) ) ; ln = ( l51 ( l31 , 0 , lg + lm ) == 0 ) ; l10 lc ( ! ln ) { lv ( l35 ( lb ) ? 0 : lf , lb , lk ( " \x63 \x61 \x6e \x6e \x6f \x74 \x20 \x73 " " \x65 \x74 \x20 \x6e \x69 \x63 \x65 \x6e \x65 \x73 \x73 " ) ) ; lc ( l40 ( l34 ) ) lu lf ; } l30 ( le [ la ] , & le [ la ] ) ; ld l3 = lb == l17 ? l19 : l41 ; lv ( 0 , lb , " \x25 \x73 " , ly ( le [ la ] ) ) ; lu l3 ; }
>>>Func
METHOD li
METHOD_RETURN lb
PARAM lf* *lg
PARAM lf*lc
PARAM lb le
<operator>.lessThan la<le
<operator>.preIncrement ++la
IDENTIFIER ld <empty>
LITERAL 0 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token lb li ( lf * * lg , lf * lc , lb le ) { lb la ; lk ( la = 0  ; la < le ; ++ la ) lj ( lh ( lg [ la ] , lc ) == 0 ) ld 1 ; ld 0 ; }
>>>Func
METHOD ly
METHOD_RETURN lu
<operator>.assignment *le=lw("\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65""\x6d\x70\x74\x31\x2e\x69\x6e","\x72")
<operator>.assignment *lh=lw("\x42\x2d\x73\x6d\x61""\x6c\x6c\x2d\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74","\x77")
<operator>.assignment li[30]={-1}
lg lg(le,"""\x25\x64",&lp)
<operator>.lessEqualsThan ll<=lp
<operator>.postIncrement ll++
lv lv(le)
lv lv(lh)
IDENTIFIER lz <empty>
LITERAL 0 <empty>
lw lw("\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65""\x6d\x70\x74\x31\x2e\x69\x6e","\x72")
lw lw("\x42\x2d\x73\x6d\x61""\x6c\x6c\x2d\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74","\x77")
<operator>.arrayInitializer {-1}
<operator>.minus -1
>>>PDG&16 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 2->1 2->1 2->5 3->1 3->1 3->9 4->1 4->1 4->1 5->1 5->1 5->6 5->8 6->1 6->1 6->7 7->1 7->1 8->1 8->1 9->1 9->1 12->2 12->2 13->3 13->3 14->1 14->4 15->14
>>>Token lu ly ( ) { lx * le = lw ( " \x42 \x2d \x73 \x6d \x61 \x6c \x6c \x2d \x61 \x74 \x74 \x65 " " \x6d \x70 \x74 \x31 \x2e \x69 \x6e " , " \x72 " ) , * lh = lw ( " \x42 \x2d \x73 \x6d \x61 " " \x6c \x6c \x2d \x6f \x75 \x74 \x70 \x75 \x74 \x2e \x74 \x78 \x74 " , " \x77 " ) ; lu lp , ll , la , lb , lk , lo , ls , lr , lj [ 30 ] [ 30 ] , li [ 30 ] = { -1 } ; lm lc [ 110 ] , ld [ 110 ] ; lg ( le , " " " \x25 \x64 " , & lp ) ; lf ( ll = 1  ; ll <= lp ; ll ++ ) { lg ( le , " \x25 \x64 " , & lo ) ; lf ( la = 0  ; la < 30 ; la ++ ) lf ( lb = 0 ; lb < 30 ; lb ++ ) lj [ la ] [ lb ] = -1 ; lf ( la = 0  ; la < 30 ; la ++ ) li [ la ] = -1 ; lf ( la = 0  ; la < lo ; la ++ ) { lg ( le , " \x25 \x73 " , lc ) ; lj [ lc [ 0 ] - ' ' ] [ lc [ 1 ] - ' ' ] = lj [ lc [ 1 ] - ' ' ] [ lc [ 0 ] - ' ' ] = lc [ 2 ] ; } lg ( le , " \x25 \x64 " , & ls ) ; lf ( la = 0  ; la < ls ; la ++ ) { lg ( le , " \x25 \x73 " , lc ) ; li [ lc [ 0 ] - ' ' ] = lc [ 1 ] ; li [ lc [ 1 ] - ' ' ] = lc [ 0 ] ; } lg ( le , " \x25 \x64 " , & lr ) ; lg ( le , " \x25 \x73 " , lc ) ; lf ( la = 0 , lb = 0  ; la < lr ; la ++ ) { ld [ lb ++ ] = lc [ la ] ; l0 ( lb >= 2 && lj [ ld [ lb - 1 ] - ' ' ] [ ld [ lb - 2 ] - ' ' ] != -1 )  { ld [ lb - 2 ] = ( lm ) lj [ ld [ lb - 1 ] - ' ' ] [ ld [ lb - 2 ] - ' ' ] ; lb -- ; } lq ( lb >= 2 && li [ ld [ lb - 1 ] - ' ' ] != -1 )  { lm lt = ( lm ) li [ ld [ lb - 1 ] - ' ' ] ; lf ( lk = 0  ; lk < lb ; lk ++ ) lq ( lt == ld [ lk ] ) lb = 0 ; } } ln ( lh , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , ll ) ; lf ( la = 0  ; la < lb ; la ++ ) { ln ( lh , " \x25 \x63 " , ld [ la ] ) ; lq ( la + 1 < lb )  ln ( lh , " \x2c \x20 " ) ; } ln ( lh , " \x5d \n " ) ; } lv ( le ) ; lv ( lh ) ; lz 0 ; }
>>>Func
METHOD lo
METHOD_RETURN ln
PARAM lb le
lg lg("\x25\x64",&la)
<operator>.lessThan ld<la
<operator>.postIncrement ld++
lq lq(lf la li(lb),ll)
lr lr(la)
<operator>.assignment lc=lk(la)
lm lm(lc<0)
BLOCK <empty> <empty>
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
lh lh("\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x4e\x4f\n",le)
lh lh("""\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x25\x64\n",le,lc)
li li(lb)
lk lk(la)
<operator>.lessThan lc<0
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->13 3->1 3->1 3->4 3->6 3->7 3->16 4->1 4->5 4->6 5->1 5->1 6->1 6->1 6->1 6->1 6->7 7->1 7->16 8->1 8->1 8->17 9->1 9->1 13->1 13->14 14->1 14->1 14->1 15->1 15->6 16->1 16->8 17->9 17->9 17->14
>>>Token ln lo ( lb le ) { lb la , lc ; lg ( " \x25 \x64 " , & la ) ; lj ( lb  ld = 0 ; ld < la ; ld ++ ) { lg ( " " " \x25 \x64 " , & lf [ ld ] ) ; } lq ( lf , la , li ( lb ) , ll ) ; lr ( la ) ; lc = lk ( la ) ; lm ( lc < 0 )  { lh ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , le ) ; } lp  { lh ( " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , le , lc ) ; } }
>>>Func
METHOD lh
METHOD_RETURN lf
lb lb("\n\x65\x6e\x74\x65\x72\x20\x74\x68\x65\x20\x70""\x6f\x73\x69\x74\x69\x6f\x6e\x20\x74\x6f\x20\x75\x70\x64\x61\x74\x65""\x3f\x20")
ld ld("\x25\x64",&la)
lb lb("\n\x65\x6e\x74\x65\x72\x20\x74\x68""\x65\x20\x69\x74\x65\x6d\x20\x74\x6f\x20\x69\x6e\x73\x65\x72\x74\x3f""\x20")
ld ld("\x25\x64",&lc)
li li(le-la+1<0)
BLOCK <empty> <empty>
IDENTIFIER lj <empty>
BLOCK <empty> <empty>
lb lb("\n\x75\x6e\x64\x65\x72""\x66\x6c\x6f\x77\x20\x63\x6f\x6e\x64\x69\x74\x69\x6f\x6e")
<operator>.assignment lk[le-la+1]=lc
<operator>.lessThan le-la+1<0
<operator>.addition le-la+1
<operator>.subtraction le-la
<operator>.addition le-la+1
<operator>.subtraction le-la
>>>PDG&17 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 2->1 3->1 3->1 3->14 3->16 4->1 5->1 5->1 5->11 6->1 6->1 10->1 11->1 11->1 11->1 12->6 12->6 14->12 14->12 14->13 14->13 14->16 14->16 15->1 16->1 16->1 16->15 16->15
>>>Token lf lh ( ) { lg la , lc ; lb ( " \n \x65 \x6e \x74 \x65 \x72 \x20 \x74 \x68 \x65 \x20 \x70 " " \x6f \x73 \x69 \x74 \x69 \x6f \x6e \x20 \x74 \x6f \x20 \x75 \x70 \x64 \x61 \x74 \x65 " " \x3f \x20 " ) ; ld ( " \x25 \x64 " , & la ) ; lb ( " \n \x65 \x6e \x74 \x65 \x72 \x20 \x74 \x68 " " \x65 \x20 \x69 \x74 \x65 \x6d \x20 \x74 \x6f \x20 \x69 \x6e \x73 \x65 \x72 \x74 \x3f " " \x20 " ) ; ld ( " \x25 \x64 " , & lc ) ; li ( le - la + 1 < 0 )  { lb ( " \n \x75 \x6e \x64 \x65 \x72 " " \x66 \x6c \x6f \x77 \x20 \x63 \x6f \x6e \x64 \x69 \x74 \x69 \x6f \x6e " ) ; } lj  { lk [ le - la + 1 ] = lc ; } }
>>>Func
METHOD lz
METHOD_RETURN ly
l2 l2("\x2e\x2f\x42\x2d\x73\x6d""\x61\x6c\x6c\x2e\x69\x6e","\x72",l5)
lc lc("\x25\x64",&lr)
le le("\x25\x64""\n",lr)
<operator>.lessEqualsThan lh<=lr
<operator>.postIncrement lh++
IDENTIFIER l0 <empty>
LITERAL 0 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 2->1 3->1 3->1 3->4 3->5 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token ly lz ( ) { ly lr , lb , la , lh , lp , lm , ll ; l4 lv ; l2 ( " \x2e \x2f \x42 \x2d \x73 \x6d " " \x61 \x6c \x6c \x2e \x69 \x6e " , " \x72 " , l5 ) ; lc ( " \x25 \x64 " , & lr ) ; le ( " \x25 \x64 " " \n " , lr ) ; lj ( lh = 1  ; lh <= lr ; lh ++ ) { li ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 " " \x3a \x20 " , lh ) ; lt ( lg , 0 , ls ( lg ) ) ; lt ( ln , 0 , ls ( lg ) ) ; lt ( lf , 0 , ls ( lf ) ) ; ld = -1 ; lc ( " \x25 \x64 " , & lx ) ; le ( " \x25 \x64 \n " , lx ) ; lj ( la = 0  ; la < lx ; la ++ ) { lc ( " \x20 " " \x25 \x63 " , & lg [ la ] [ 0 ] ) ; lc ( " \x25 \x63 " , & lg [ la ] [ 1 ] ) ; lc ( " \x25 \x63 " , & lg [ la ] [ 2 ] ) ; le ( " \x25 \x73 \n " , lg [ la ] ) ; } lc ( " \x25 \x64 " , & lu ) ; le ( " \x25 \x64 \n " , lu ) ; lj ( la = 0  ; la < lu ; la ++ ) { lc ( " \x20 \x25 \x63 " , & ln [ la ] [ 0 ] ) ; lc ( " \x25 \x63 " , & ln [ la ] [ 1 ] ) ; le ( " \x25 \x73 \n " , ln [ la ] ) ; } lc ( " \x25 \x64 " , & lp ) ; le ( " \x25 \x64 \n " , lp ) ; lc ( " \x25 \x73 " , lf ) ; le ( " \x25 \x73 \n " , lf ) ; lj ( lb = 0  ; lb < lp ; lb ++ ) { lm = 0 ; ll = 0 ; lq ( ld != -1 )  { lm = l1 ( lf [ lb ] , & lv ) ; lq ( lm ) { lk [ ld ] = lv ; lo ; } lw { ll = l3 ( lf [ lb ] ) ; lq ( ll ) { ld = -1 ; lo ; } lw { lk [ ++ ld ] = lf [ lb ] ; lo ; } } } lw  { lk [ ++ ld ] = lf [ lb ] ; lo ; } } li ( " " " \x5b " ) ; lj ( lb = 0  ; lb <= ld ; lb ++ ) { li ( " \x25 \x63 " , lk [ lb ] ) ; lq ( lb < ld )  { li ( " \x2c " " \x20 " ) ; } } li ( " \x5d \n " ) ; le ( " \x2d \x2d \x2d \x2d \x2d \x2d \x2d \x2d \x2d \x2d " " \x2d \n " ) ; } l0 0 ; }
>>>Func
METHOD lr
METHOD_RETURN lu
PARAM ls*lf
<operator>.assignment lb=0
li li(lf,"\x25\x64\x20\x25\x64\x20\x25\x64\n",&la.lj,&la.ll,&la.lc)
<operator>.lessThan ld<ln
<operator>.greaterThan ';'>("\x25\x64\x20\x25\x64\x20\x25\x64""\n",la.lj,la.ll,la.lc)
<operator>.lessThan lb<la.lc
<operator>.postIncrement lb++
<operator>.lessThan lb<la.lc
<operator>.postIncrement lb++
ld ld("\n")
IDENTIFIER lm <empty>
<operator>.bracketedPrimary ("\x25\x64\x20\x25\x64\x20\x25\x64""\n",la.lj,la.ll,la.lc)
<operator>.expressionList "\x25\x64\x20\x25\x64\x20\x25\x64""\n" la.lj la.ll la.lc
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 2->4 3->1 3->7 4->1 4->1 4->1 4->1 4->1 4->7 4->9 4->14 4->14 4->14 5->1 5->1 5->1 6->1 6->1 7->8 7->9 8->9 9->1 9->1 9->10 10->1 10->1 11->1 13->1 13->6 14->1 14->1 14->7 14->13 14->13 14->13 14->13
>>>Token lu lr ( ls * lf ) { le lb = 0 ; li ( lf , " \x25 \x64 \x20 \x25 \x64 \x20 \x25 \x64 \n " , & la . lj , & la . ll , & la . lc ) ; lk lh  ld < ln ' ' > ( " \x25 \x64 \x20 \x25 \x64 \x20 \x25 \x64 " " \n " , la . lj , la . ll , la . lc ) ; lm la . lg = ( lp le * ) lq ( lt ( lp le ) * la . lc ) ; lo ( lb = 0  ; lb < la . lc ; lb ++ ) { li ( lf , " \x25 \x64 \x20 " , & la . lg [ lb ] ) ; } lk lh  lo ( lb < ln ' ' >= 0  ; lb < la . lc ; lb ++ ) { ld ( " \x25 \x64 \x20 " , la . lg [ lb ] ) ; } ld ( " \n " ) ; lm  }
>>>Func
METHOD lk
METHOD_RETURN lg
PARAM lg
IDENTIFIER ld <empty>
ll ll("\x25\x49\x36\x34\x64\x20\x25\x64\x20""\x25\x64\x20",&ld,&la,&lc)
<operator>.assignment lh=100/lm(100,la)
IDENTIFIER lj <empty>
BLOCK <empty> <empty>
lf lf("\x50\x6f\x73\x73\x69\x62\x6c\x65\n")
<operator>.division 100/lm(100,la)
lm lm(100,la)
>>>PDG&11 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 2->1 4->1 4->1 4->1 4->1 4->10 5->1 5->1 5->1 8->1 9->1 9->5 9->5 10->1 10->9 10->9
>>>Token lg lk ( lg ) { lb lb ld ; le la , lc ; ll ( " \x25 \x49 \x36 \x34 \x64 \x20 \x25 \x64 \x20 " " \x25 \x64 \x20 " , & ld , & la , & lc ) ; le lh = 100 / lm ( 100 , la ) ; li ( ( lc == 0 && la != 0 ) || ( lc == 100 && la != 100 ) || ( ( lb lb ) lh > ld ) )  { lf ( " \x42 \x72 \x6f \x6b \x65 \x6e \n " ) ; } lj  { lf ( " \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " ) ; } }
>>>Func
METHOD lm
METHOD_RETURN li
PARAM lh lb[]
PARAM li la
PARAM lh lj[ld][ld]
PARAM lp lg[ld][ld]
lk lk(la==0)
BLOCK <empty> <empty>
<operator>.assignment ll='\0'
<operator>.assignment lc=0
lk lk((ll=lj[(lf)lb[la]][(lf)lb[la-1]])!='\0')
BLOCK <empty> <empty>
IDENTIFIER lo <empty>
BLOCK <empty> <empty>
IDENTIFIER le0 <empty>
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.assignment lb[la-1]=ll
<operator>.assignment lb[la]='\0'
IDENTIFIER le <empty>
<operator>.addition 1+lm(lb,la-1,lj,lg)
<operator>.lessThan lc<la
<operator>.postIncrement lc++
<operator>.equals la==0
<operator>.notEquals (ll=lj[(lf)lb[la]][(lf)lb[la-1]])!='\0'
<operator>.assignment ll=lj[(lf)lb[la]][(lf)lb[la-1]]
lm lm(lb,la-1,lj,lg)
<operator>.subtraction la-1
<operator>.subtraction la-1
<operator>.cast (lf)lb[la-1]
<operator>.cast (lf)lb[la]
<operator>.subtraction la-1
>>>PDG&32 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->26 0->27 0->28 0->31 2->26 2->29 2->30 3->23 4->26 5->26 6->1 6->1 8->1 9->1 9->21 10->1 10->1 17->1 17->1 17->1 17->26 18->1 18->1 18->26 20->1 20->1 21->1 21->1 21->22 22->1 22->1 23->6 23->6 23->31 24->1 24->10 24->10 25->1 25->17 25->24 26->1 26->1 26->1 26->1 26->20 26->20 26->20 26->20 27->28 28->21 28->26 28->26 31->27
>>>Token li lm ( lh lb [ ] , li la , lh lj [ ld ] [ ld ] , lp lg [ ld ] [ ld ] ) { lk ( la == 0 ) { le 0 ; } lh ll = ' \0 ' ; li lc = 0 ; lk ( ( ll = lj [ ( lf ) lb [ la ] ] [ ( lf ) lb [ la - 1 ] ] ) != ' \0 ' )  { lb [ la - 1 ] = ll ; lb [ la ] = ' \0 ' ; le 1 + lm ( lb , la - 1 , lj , lg ) ; } lo  { ln ( lc = 0  ; lc < la ; lc ++ ) { lk ( lg [ ( lf ) lb [ la ] ] [ ( lf ) lb [ lc ] ] ) { ln ( lc = 0  ; lc <= la ; lc ++ ) { lb [ lc ] = ' \0 ' ; } le la +1 ; } } } le0 ; }
>>>Func
METHOD lt
METHOD_RETURN lj
PARAM lj lu
PARAM lw*ls[]
lm lm("\x25\x64",&ll)
<operator>.lessThan lh<ll
<operator>.postIncrement lh++
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token lj lt ( lj lu , lw * ls [ ] ) { lj la , ll , lb , lh ; lm ( " \x25 \x64 " , & ll ) ; ld ( lh = 0  ; lh < ll ; lh ++ ) { lm ( " \x25 \x64 " , & lc ) ; ld ( la = 0  ; la < lc ; la ++ ) lm ( " \x25 \x73 " , lg [ la ] ) ; ljlk ; ld ( la = 0  ; la < lc ; la ++ ) { le [ la ] = lk = 0 ; ld ( lb = 0  ; lb < lc ; lb ++ ) { li ( lg [ la ] [ lb ] == ' ' ) lk ++ ; li ( lg [ la ] [ lb ] != ' ' ) le [ la ] ++ ; } lo [ la ] = ( lr ) lk / le [ la ] ; } lr lf ; ld ( la = 0  ; la < lc ; la ++ ) { lf = 0.0 ; ld ( lb = 0  ; lb < lc ; lb ++ ) { li ( lg [ la ] [ lb ] != ' ' )  { lf += ( lo [ lb ] * le [ lb ] - ( lg [ la ] [ lb ] == ' ' ? 1 : 0 ) ) / ( le [ lb ] - 1 ) ; } } ln [ la ] = lf / le [ la ] ; } ld ( la = 0  ; la < lc ; la ++ ) { lf = 0.0 ; ld ( lb = 0  ; lb < lc ; lb ++ ) { li ( lg [ la ] [ lb ] != ' ' )  { lf += ln [ lb ] ; } } lq [ la ] = lf / le [ la ] ; } lp ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 " " \x3a \n " , lh + 1 ) ; ld ( la = 0  ; la < lc ; la ++ ) lp ( " \x25 \x2e \x39 \x66 \n " , 0.25 * lo [ la ] + 0.5 * ln [ la ] + 0.25 * lq [ la ] ) ; } lv lx ; }
>>>Func
METHOD ln
METHOD_RETURN lf
PARAM li ld
PARAM lf lh
PARAM lf ll
<operator>.lessThan la<lh
<operator>.postIncrement la++
IDENTIFIER lk <empty>
LITERAL 0 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->5 4->1 5->1 5->1 5->6 6->1 6->1
>>>Token lf ln ( li ld , lf lh , lf ll ) { lf la , lc ; li le ; lj ( la = 0  ; la < lh ; la ++ ) { lg ( ( ld == lb [ la ] [ 0 ] ) || ( ld == lb [ la ] [ 1 ] ) )  { lg ( ld == lb [ la ] [ 0 ] )  { le = lb [ la ] [ 1 ] ; } lm { le = lb [ la ] [ 0 ] ; } lj ( lc = 0  ; lc < ll ; lc ++ ) { lg ( lo [ lc ] == le )  { lk 1 ; } } } } lk 0 ; }
>>>Func
METHOD lr
METHOD_RETURN ln
PARAM lh*la
<operator>.assignment ld=lu(la)
ll ll(la ld lk(lh),li)
<operator>.assignment lg=1
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
ls ls(lg)
lt lt("\x25\x73""\n",la)
<operator>.logicalAnd lb>=0&&la[lb]>=la[lb+1]
<operator>.preDecrement --lb
lj lj(lb>=0)
BLOCK <empty> <empty>
<operator>.assignment lg=0
lu lu(la)
lk lk(lh)
<operator>.expressionList lfle=lb+1 lc
<operator>.logicalAnd lc<ld&&la[lc]
<operator>.postIncrement lc++
lo lo(&la[lb],&la[le])
ll ll(la+lb+1 ld-lb-1 lk(lh),li)
<operator>.greaterEqualsThan lb>=0
<operator>.greaterEqualsThan la[lb]>=la[lb+1]
<operator>.greaterEqualsThan lb>=0
<operator>.assignment lfle=lb+1
<operator>.lessThan lc<ld
<operator>.addition la+lb+1
<operator>.subtraction ld-lb-1
lk lk(lh)
<operator>.addition lb+1
<operator>.addition lb+1
<operator>.addition la+lb
<operator>.subtraction ld-lb
<operator>.indirectIndexAccess la[lb]
<operator>.indirectIndexAccess la[lb+1]
<operator>.indirectIndexAccess la[lc]
>>>PDG&37 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->13 0->14 0->15 0->16 0->17 0->19 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 2->15 3->1 3->1 3->4 4->1 4->9 4->21 4->26 5->1 8->1 8->1 9->1 9->18 9->20 9->21 9->23 9->27 9->32 10->1 10->1 11->1 11->24 12->1 12->1 14->1 14->8 15->3 15->4 16->4 16->29 17->1 17->1 17->26 18->1 18->1 18->1 18->21 18->27 18->32 19->1 19->1 20->1 20->1 20->1 21->1 21->1 21->1 21->1 21->1 22->10 22->10 22->11 22->23 22->30 22->30 22->34 22->35 23->1 23->1 23->10 23->10 23->20 23->21 23->21 23->27 23->27 23->32 23->32 24->12 24->12 24->17 24->21 24->25 24->27 24->31 24->32 24->33 25->1 25->1 25->17 26->18 26->18 26->19 26->33 26->36 27->1 28->1 28->21 28->21 29->1 29->21 32->1 33->1 33->1 33->28 33->28
>>>Token ln lr ( lh * la ) { lf ld = lu ( la ) ; ll ( la , ld , lk ( lh ) , li ) ; lf lg = 1 ; lp  { lt ( " \x25 \x73 " " \n " , la ) ; lf lb ; lm ( lb = ld - 2  ; lb >= 0 && la [ lb ] >= la [ lb + 1 ] ; -- lb ) { } lj ( lb >= 0 )  { lfle = lb + 1 , lc ; lm ( lc = le  ; lc < ld && la [ lc ] ; lc ++ ) { lj ( la [ lc ] > la [ lb ] && la [ lc ] < la [ le ] ) le = lc ; } lo ( & la [ lb ] , & la [ le ] ) ; ll ( la + lb + 1 , ld - lb - 1 , lk ( lh ) , li ) ; } lq lg = 0 ; } ls ( lg ) ; }
>>>Func
METHOD ls
METHOD_RETURN lg
<operator>.assignment lh=1
<operator>.assignment ld=0
<operator>.assignment lj=0
lf lf("\x25\x64\x20",&lp)
lr lr(lp--)
BLOCK <empty> <empty>
IDENTIFIER lt <empty>
LITERAL 1 <empty>
<operator>.lessThan la<17
<operator>.postIncrement la++
<operator>.assignment ld=0
<operator>.assignment lj=0
lf lf("\x25\x64\x20",&lk)
<operator>.lessThan la<4
<operator>.postIncrement la++
lf lf("\x25\x64",&ll)
<operator>.lessThan la<4
<operator>.postIncrement la++
<operator>.lessThan la<4
<operator>.postIncrement la++
<operator>.lessThan la<17
<operator>.postIncrement la++
li li(ld==0)
BLOCK <empty> <empty>
IDENTIFIER lq <empty>
li li(ld==1)
BLOCK <empty> <empty>
IDENTIFIER lq <empty>
li li(ld>=2)
BLOCK <empty> <empty>
<operator>.postDecrement lp--
lm lm("\x43\x61\x73\x65\x20\x23\x25\x64\x3a""\x20\x56\x6f\x6c\x75\x6e\x74\x65\x65\x72\x20\x63\x68\x65\x61\x74\x65""\x64\x21\n",lh++)
lm lm("\x43\x61\x73\x65\x20\x23\x25\x64""\x3a\x20\x25\x64\n",lh++,lj)
lm lm("\x43\x61\x73\x65\x20""\x23\x25\x64\x3a\x20\x42\x61\x64\x20\x6d\x61\x67\x69\x63\x69\x61\x6e""\x21\n",lh++)
<operator>.equals ld==0
<operator>.equals ld==1
<operator>.greaterEqualsThan ld>=2
<operator>.postIncrement lh++
<operator>.postIncrement lh++
<operator>.postIncrement lh++
>>>PDG&42 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->28 0->29 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 2->1 2->39 5->1 5->1 5->32 6->1 6->1 10->11 11->15 12->1 12->36 13->1 13->34 14->1 14->1 15->16 16->18 17->1 17->1 18->19 19->20 20->1 20->21 21->22 22->1 22->23 23->1 23->1 24->1 24->1 27->1 27->1 30->1 30->1 32->1 32->6 33->1 34->1 34->1 35->1 35->1 36->24 36->24 36->37 37->27 37->27 37->38 38->1 38->30 38->30 39->33 39->40 40->34 40->41 41->1 41->35
>>>Token lg ls ( ) { lg la , lb , lp , lh = 1 ; lg ln [ 4 ] [ 4 ] , lo [ 4 ] [ 4 ] , le [ 17 ] ; lg lk , ll ; lg ld = 0 , lj = 0 ; lf ( " \x25 \x64 \x20 " , & lp ) ; lr ( lp -- )  { lc ( la = 0  ; la < 17 ; la ++ ) { le [ la ] = 0 ; } ld = 0 ; lj = 0 ; lf ( " \x25 \x64 \x20 " , & lk ) ; lc ( la = 0  ; la < 4 ; la ++ ) { lc ( lb = 0  ; lb < 4 ; lb ++ ) { lf ( " \x25 \x64 \x20 " , & ln [ la ] [ lb ] ) ; } } lf ( " \x25 \x64 " , & ll ) ; lc ( la = 0  ; la < 4 ; la ++ ) { lc ( lb = 0  ; lb < 4 ; lb ++ ) { lf ( " \x25 \x64 " , & lo [ la ] [ lb ] ) ; } } lc ( la = 0  ; la < 4 ; la ++ ) { le [ ln [ lk - 1 ] [ la ] ] ++ ; le [ lo [ ll - 1 ] [ la ] ] ++ ; } lc ( la = 0  ; la < 17 ; la ++ ) { li ( le [ la ] == 2 )  { lj = la ; ld ++ ; } } li ( ld == 0 )  { lm ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a " " \x20 \x56 \x6f \x6c \x75 \x6e \x74 \x65 \x65 \x72 \x20 \x63 \x68 \x65 \x61 \x74 \x65 " " \x64 \x21 \n " , lh ++ ) ; } lq li ( ld == 1 ) { lm ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 " " \x3a \x20 \x25 \x64 \n " , lh ++ , lj ) ; } lq li ( ld >= 2 ) { lm ( " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x64 \x3a \x20 \x42 \x61 \x64 \x20 \x6d \x61 \x67 \x69 \x63 \x69 \x61 \x6e " " \x21 \n " , lh ++ ) ; } } lt 1 ; }
>>>Func
METHOD lk
METHOD_RETURN lh
PARAM lm
la la("\x45\x6e\x74\x65\x72\x20\x74\x68\x65\x20""\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x76\x65\x72\x74\x69\x63\x65""\x73\x3a\x20")
lb lb("\x25\x64",&lc)
<operator>.assignment lf=ls(lc)
la la("\x45\x6e""\x74\x65\x72\x20\x73\x6f\x75\x72\x63\x65\x20\x6e\x6f\x64\x65\x3a\x20")
lb lb("\x25\x64",&lg)
la la("\x45\x6e\x74\x65\x72\x20\x64\x65\x73\x74\x69""\x6e\x61\x74\x69\x6f\x6e\x20\x6e\x6f\x64\x65\x3a\x20")
lb lb("\x25\x64",&le)
la la("\x45\x6e\x74\x65\x72\x20\x61\x6e\x20\x65\x64\x67\x65\x20""\x28\x66\x72\x6f\x6d\x29\x3a\x20")
lr lr(lb("\x25\x64",&ld.ll)==1)
BLOCK <empty> <empty>
la la("\x46\x69\x6e\x69\x73\x68\x65\x64\x2e\n")
la la("\x54\x68""\x65\x20\x67\x72\x61\x70\x68\x20\x68\x61\x73\x20")
la la("\x61")
IDENTIFIER lv <empty>
la la("\x6e\x6f")
la la("\x20\x48\x61\x6d\x69\x6c\x74\x6f""\x6e\x69\x61\x6e\x20\x70\x61\x74\x68\x20\x66\x72\x6f\x6d\x20\x25\x64""\x20\x74\x6f\x20\x25\x64\x2e\n",lg,le)
lw lw(lf)
IDENTIFIER lo <empty>
LITERAL 0 <empty>
la la("""\x45\x6e\x74\x65\x72\x20\x61\x6e\x20\x65\x64\x67\x65\x20\x28\x74\x6f""\x29\x3a\x20")
lb lb("\x25\x64",&ld.lt)
lj lj(lf,ld)
la la("\x45\x6e\x74\x65""\x72\x20\x61\x6e\x20\x65\x64\x67\x65\x20\x28\x66\x72\x6f\x6d\x29\x3a""\x20")
ls ls(lc)
<operator>.equals lb("\x25\x64",&ld.ll)==1
lb lb("\x25\x64",&ld.ll)
>>>PDG&29 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 2->1 3->1 4->1 4->1 4->26 5->1 5->1 5->24 6->1 7->1 7->1 7->18 8->1 9->1 9->1 9->18 10->1 11->1 11->1 13->1 14->1 15->1 17->1 18->1 18->1 18->1 19->1 19->1 22->1 23->1 23->1 24->1 24->1 24->19 25->1 26->1 26->5 27->1 27->11 27->11 28->1 28->27 28->27
>>>Token lh lk ( lm ) { lp ld ; lh lc ; la ( " \x45 \x6e \x74 \x65 \x72 \x20 \x74 \x68 \x65 \x20 " " \x6e \x75 \x6d \x62 \x65 \x72 \x20 \x6f \x66 \x20 \x76 \x65 \x72 \x74 \x69 \x63 \x65 " " \x73 \x3a \x20 " ) ; lb ( " \x25 \x64 " , & lc ) ; lq lf = ls ( lc ) ; lu lg , le ; la ( " \x45 \x6e " " \x74 \x65 \x72 \x20 \x73 \x6f \x75 \x72 \x63 \x65 \x20 \x6e \x6f \x64 \x65 \x3a \x20 " ) ; lb ( " \x25 \x64 " , & lg ) ; la ( " \x45 \x6e \x74 \x65 \x72 \x20 \x64 \x65 \x73 \x74 \x69 " " \x6e \x61 \x74 \x69 \x6f \x6e \x20 \x6e \x6f \x64 \x65 \x3a \x20 " ) ; lb ( " \x25 \x64 " , & le ) ; la ( " \x45 \x6e \x74 \x65 \x72 \x20 \x61 \x6e \x20 \x65 \x64 \x67 \x65 \x20 " " \x28 \x66 \x72 \x6f \x6d \x29 \x3a \x20 " ) ; lr ( lb ( " \x25 \x64 " , & ld . ll ) == 1 )  { la ( " " " \x45 \x6e \x74 \x65 \x72 \x20 \x61 \x6e \x20 \x65 \x64 \x67 \x65 \x20 \x28 \x74 \x6f " " \x29 \x3a \x20 " ) ; lb ( " \x25 \x64 " , & ld . lt ) ; lj ( lf , ld ) ; la ( " \x45 \x6e \x74 \x65 " " \x72 \x20 \x61 \x6e \x20 \x65 \x64 \x67 \x65 \x20 \x28 \x66 \x72 \x6f \x6d \x29 \x3a " " \x20 " ) ; } la ( " \x46 \x69 \x6e \x69 \x73 \x68 \x65 \x64 \x2e \n " ) ; la ( " \x54 \x68 " " \x65 \x20 \x67 \x72 \x61 \x70 \x68 \x20 \x68 \x61 \x73 \x20 " ) ; ln ( li ( lf , lc , lg , le ) ) la ( " \x61 " ) ; lv la ( " \x6e \x6f " ) ; la ( " \x20 \x48 \x61 \x6d \x69 \x6c \x74 \x6f " " \x6e \x69 \x61 \x6e \x20 \x70 \x61 \x74 \x68 \x20 \x66 \x72 \x6f \x6d \x20 \x25 \x64 " " \x20 \x74 \x6f \x20 \x25 \x64 \x2e \n " , lg , le ) ; lw ( lf ) ; lo 0 ; }
>>>Func
METHOD l1
METHOD_RETURN lg
<operator>.expressionList lf lr
lw lw("""\x25\x64",&lv)
<operator>.lessEqualsThan lp<=lv
<operator>.postIncrement lp++
IDENTIFIER l3 <empty>
LITERAL 0 <empty>
<operator>.multiplication 2*lo
<operator>.multiplication 2*lo
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 2->1 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1 8->1 9->8
>>>Token lg l1 ( ) { lg lp , lv ; lg lj , li ; ly lz ls [ lo ] [ lo ] ; lx lg lc [ 2 * lo ] [ 2 * lo ] ; lg lu [ 2 * lo ] [ 2 * lo ] ; lg la , lb , le , ld ; ly lz * lq ; lx lg lf , lr ; lg lm , lh , lk , lt ; lw ( " " " \x25 \x64 " , & lv ) ; ll ( lp = 1  ; lp <= lv ; lp ++ ) { lw ( " \x25 \x64 \x20 \x25 \x64 " , & lj , & li ) ; ll ( la = 0  ; la < lj ; la ++ ) ll ( lb = 0 ; lb < li ; lb ++ ) lw ( " \x25 \x64 \x20 \x25 \x64 " " \x20 \x25 \x64 " , & ls [ la ] [ lb ] . lh , & ls [ la ] [ lb ] . lk , & ls [ la ] [ lb ] . lt ) ; ll ( la = 0  ; la < 2 * lj ; la ++ ) ll ( lb = 0 ; lb < 2 * li ; lb ++ ) { lu [ la ] [ lb ] = 0 ; lc [ la ] [ lb ] = ~ 0 ; } le = 2 * lj - 1 ; ld = 0 ; lc [ le ] [ ld ] = 0 ; l2 ( le != 0 || ld != 2 * li - 1 )  { la = le , lb = ld ; le = la % 2 ? la + 1 : la - 1 ; ld = lb % 2 ? lb + 1 : lb - 1 ; lf = lc [ la ] [ lb ] + 2 ; ln ( le >= 0 && le < 2 * lj && lf < lc [ le ] [ lb ] ) lc [ le ] [ lb ] = lf ; ln ( ld >= 0 && ld < 2 * li && lf < lc [ la ] [ ld ] ) lc [ la ] [ ld ] = lf ; le = la ^ 1 ; ld = lb ^ 1 ; lq = & ls [ la / 2 ] [ lb / 2 ] ; lh = lq -> lh ; lk = lq -> lk ; lt = lq -> lt ; lm = ( ( lg ) lc [ la ] [ lb ] - lt ) % ( lh + lk ) ; ln ( lm < 0 ) lm += lh + lk ; ln ( lm < lh )  { lf = lc [ la ] [ lb ] + 1 ; lr = lc [ la ] [ lb ] + lh - lm + 1 ; } l0 { lf = lc [ la ] [ lb ] + lh + lk - lm + 1 ; lr = lc [ la ] [ lb ] + 1 ; } ln ( le >= 0 && le < 2 * lj && lf < lc [ le ] [ lb ] ) lc [ le ] [ lb ] = lf ; ln ( ld >= 0 && ld < 2 * li && lr < lc [ la ] [ ld ] ) lc [ la ] [ ld ] = lr ; lu [ la ] [ lb ] = 1 ; lf = ~ 0 ; ll ( la = 0  ; la < 2 * lj ; la ++ ) ll ( lb = 0 ; lb < 2 * li ; lb ++ ) ln ( ! lu [ la ] [ lb ] && lc [ la ] [ lb ] < lf ) le = la , ld = lb , lf = lc [ la ] [ lb ] ; } l4 ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , lp , lc [ le ] [ ld ] ) ; } l3 0 ; }
>>>Func
METHOD lt
METHOD_RETURN lb
lc lc("\x25\x64\n",&lp)
<operator>.lessEqualsThan lm<=lp
<operator>.postIncrement lm++
IDENTIFIER lx <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lb lt ( ) { lb lp ; lc ( " \x25 \x64 \n " , & lp ) ; lk ( lb  lm = 1 ; lm <= lp ; lm ++ ) { lb lg , lf , ll ; lc ( " \x25 \x64 \x20 " , & lg ) ; l1 lh [ lg ] ; lk ( lb  la = 0 ; la < lg ; la ++ ) { lc ( " \x25 " " \x63 \x25 \x63 \x25 \x63 \x20 " , & ( lh [ la ] . ls ) , & ( lh [ la ] . lr ) , & ( lh [ la ] . lu ) ) ; } lc ( " \x25 \x64 \x20 " , & lf ) ; lw lj [ lf ] ; lk ( lb  la = 0 ; la < lf ; la ++ ) { lc ( " \x25 \x63 " " \x25 \x63 \x20 " , & ( lj [ la ] . ls ) , & ( lj [ la ] . lr ) ) ; } lc ( " \x25 \x64 \x20 " , & ll ) ; lole [ ll ] ; lb ld = 0 ; lk ( lb  la = 0 ; la < ll ; la ++ ) { lo li ; lc ( " \x25 \x63 " , & li ) ; ln ( ! l0 ( li , le , ld , lh , lg ) )  ln ( ! l2 ( li , le , & ld , lj , lf ) ) le [ ld ++ ] = li ; } lo * lq = lv ( le , ld ) ; ly ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x73 \n " , lm , lq ) ; ln ( ld ) lz ( lq ) ; } lx 0 ; }
>>>Func
METHOD lo
METHOD_RETURN lm
lg lg("\x25\x64",&lh)
<operator>.lessThan la<lh
<operator>.postIncrement la++
IDENTIFIER lp <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lm lo ( ) { lm la , lf , lh , li , le , lb , lc , ld ; lg ( " \x25 \x64 " , & lh ) ; lk ( la = 0  ; la < lh ; la ++ ) { le = 10000000 ; ld = 0 ; lc = 0 ; lg ( " \x25 \x64 " , & li ) ; lk ( lf = 0  ; lf < li ; lf ++ ) { lg ( " \x25 \x64 " , & lb ) ; ll ( lb < le ) le = lb ; ld = ld ^ lb ; lc = lc + lb ; } ll ( ld == 0 )  lj ( " \x43 " " \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , la + 1 , lc - le ) ; ln lj ( " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f \n " , la + 1 ) ; } lp 0 ; }
>>>Func
METHOD ll
METHOD_RETURN lb
PARAM lb lg
PARAM li*lo[]
lf lf((ld=ln(lc,"\x42\x2d""\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e"))==-1)
<operator>.subtraction le-1
<operator>.lessThan la<ld
<operator>.postIncrement la++
lh lh(lc,ld,"\x42\x2d\x73\x6d""\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x6f\x75\x74")
IDENTIFIER le <empty>
LITERAL 0 <empty>
<operator>.equals (ld=ln(lc,"\x42\x2d""\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e"))==-1
<operator>.assignment ld=ln(lc,"\x42\x2d""\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e")
<operator>.minus -1
ln ln(lc,"\x42\x2d""\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e")
>>>PDG&15 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->13 0->14 2->1 3->1 4->1 4->1 5->1 5->1 6->1 6->7 6->8 7->1 7->1 8->1 8->1 8->1 11->1 11->1 11->4 11->4 12->1 12->6 12->11 13->11 14->8 14->11 14->11 14->12 14->12
>>>Token lb ll ( lb lg , li * lo [ ] ) { lj lc [ 100 ] ; lb la ; lb ld ; lf ( ( ld = ln ( lc , " \x42 \x2d " " \x73 \x6d \x61 \x6c \x6c \x2d \x61 \x74 \x74 \x65 \x6d \x70 \x74 \x30 \x2e \x69 \x6e " ) ) == -1 )  le - 1 ; lm ( la = 0  ; la < ld ; la ++ ) lk ( & lc [ la ] ) ; lh ( lc , ld , " \x42 \x2d \x73 \x6d " " \x61 \x6c \x6c \x2d \x61 \x74 \x74 \x65 \x6d \x70 \x74 \x30 \x2e \x6f \x75 \x74 " ) ; le 0 ; }
>>>Func
METHOD lm
METHOD_RETURN ll
PARAM lg lb
PARAM lg la
PARAM lg*ld
PARAM lg*lc
PARAM lg li
PARAM lg lj
lf lf(lk[lb][la]=='|')
BLOCK <empty> <empty>
IDENTIFIER le <empty>
lf lf(lk[lb][la]=='-')
BLOCK <empty> <empty>
IDENTIFIER le <empty>
lf lf(lk[lb][la]=='/')
BLOCK <empty> <empty>
IDENTIFIER le <empty>
BLOCK <empty> <empty>
<operator>.assignment ( *ld)=(( *ld)+li)%li
<operator>.assignment ( *lc)=(( *lc)+lj)%lj
lf lf(lh[lb][la])
BLOCK <empty> <empty>
IDENTIFIER le <empty>
BLOCK <empty> <empty>
lf lf(lh[lb][la])
BLOCK <empty> <empty>
IDENTIFIER le <empty>
BLOCK <empty> <empty>
lf lf(lh[lb][la])
BLOCK <empty> <empty>
IDENTIFIER le <empty>
BLOCK <empty> <empty>
lf lf(lh[lb][la])
BLOCK <empty> <empty>
IDENTIFIER le <empty>
BLOCK <empty> <empty>
<operator>.equals lk[lb][la]=='|'
<operator>.assignment ( *ld)=lb-1
<operator>.assignment ( *lc)=la
<operator>.assignment ( *ld)=lb+1
<operator>.assignment ( *lc)=la
<operator>.equals lk[lb][la]=='-'
<operator>.assignment ( *ld)=lb
<operator>.assignment ( *lc)=la-1
<operator>.assignment ( *ld)=lb
<operator>.assignment ( *lc)=la+1
<operator>.equals lk[lb][la]=='/'
<operator>.assignment ( *ld)=lb-1
<operator>.assignment ( *lc)=la+1
<operator>.assignment ( *ld)=lb+1
<operator>.assignment ( *lc)=la-1
<operator>.assignment ( *ld)=lb-1
<operator>.assignment ( *lc)=la-1
<operator>.assignment ( *ld)=lb+1
<operator>.assignment ( *lc)=la+1
<operator>.modulo (( *ld)+li)%li
<operator>.modulo (( *lc)+lj)%lj
<operator>.addition ( *ld)+li
<operator>.addition ( *lc)+lj
<operator>.subtraction lb-1
<operator>.addition lb+1
<operator>.subtraction la-1
<operator>.addition la+1
<operator>.subtraction lb-1
<operator>.addition la+1
<operator>.addition lb+1
<operator>.subtraction la-1
<operator>.subtraction lb-1
<operator>.subtraction la-1
<operator>.addition lb+1
<operator>.addition la+1
>>>PDG&71 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->12 0->13 0->15 0->16 0->17 0->21 0->22 0->23 0->25 0->26 0->27 0->29 0->30 0->31 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->48 0->49 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 2->59 3->38 3->40 3->61 4->1 5->1 6->55 6->57 7->56 7->58 8->1 8->1 11->1 11->1 14->1 14->1 18->1 18->1 18->1 19->1 19->1 19->1 20->24 24->28 28->32 32->1 32->1 36->8 36->8 36->41 40->1 41->11 41->11 41->46 44->1 46->1 46->14 46->14 51->1 51->1 52->1 52->1 53->1 53->1 53->55 53->57 54->1 54->1 54->56 54->58 55->1 55->1 55->18 55->18 56->1 56->1 56->19 56->19 59->37 59->37 59->39 59->42 59->44 59->60 59->63 61->43 61->43 61->45 61->48 61->62 61->64 61->66 63->47 63->47 63->49 63->65 63->67 66->50 66->50 66->68 67->51 67->51 67->53 67->69 68->52 68->52 68->54 68->70 69->1 70->1
>>>Token ll lm ( lg lb , lg la , lg * ld , lg * lc , lg li , lg lj ) { lf ( lk [ lb ] [ la ] == ' ' )  { lf ( lh [ lb ] [ la ] ) { ( * ld ) = lb - 1 ; ( * lc ) = la ; } le  { ( * ld ) = lb + 1 ; ( * lc ) = la ; } } le lf ( lk [ lb ] [ la ] = = ' ' ) { lf ( lh [ lb ] [ la ] ) { ( * ld ) = lb ; ( * lc ) = la - 1 ; } le  { ( * ld ) = lb ; ( * lc ) = la + 1 ; } } le lf ( lk [ lb ] [ la ] = = ' ' ) { lf ( lh [ lb ] [ la ] ) { ( * ld ) = lb - 1 ; ( * lc ) = la + 1 ; } le  { ( * ld ) = lb + 1 ; ( * lc ) = la - 1 ; } } le { lf ( lh [ lb ] [ la ] ) { ( * ld ) = lb - 1 ; ( * lc ) = la - 1 ; } le  { ( * ld ) = lb + 1 ; ( * lc ) = la + 1 ; } } ( * ld ) = ( ( * ld ) + li ) % li ; ( * lc ) = ( ( * lc ) + lj ) % lj ; }
>>>Func
METHOD le
METHOD_RETURN lh
<operator>.lessThan la<10000000
<operator>.postIncrement la++
IDENTIFIER lf <empty>
LITERAL 0 <empty>
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 2->3 3->1 3->1
>>>Token lh le ( ) { lc lb  lb la ; lj ( la = 1  ; la < 10000000 ; la ++ ) { li ( ld ( la ) && ld ( ( lc lb lb ) ( la * la ) ) )  { lg ( " \x25 \x6c \x6c \x75 \x2c \n " , ( lc lb lb ) ( la * la ) ) ; } } lf 0 ; }
>>>Func
METHOD lt
METHOD_RETURN lc
ll ll("\x25\x64",&lj)
<operator>.lessEqualsThan ld<=lj
<operator>.preIncrement ++ld
IDENTIFIER lw <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lc lt ( ) { lc ld , lj ; lc la , lq ; lc lk ; lc le , lb , lg , lf ; ll ( " \x25 \x64 " , & lj ) ; lo ( ld = 1  ; ld <= lj ; ++ ld ) { ll ( " \x25 \x64 \x20 \x25 \x64 " , & lp , & li ) ; li = li << 1 ; lo ( la = 0  ; la < lp ; ++ la ) { ll ( " \x25 \x64 \x20 \x25 \x64 " , & lh [ la ] . lm , & lh [ la ] . ly ) ; lh [ la ] . lm *= 2 ; } le = 0 , lg = lf = 100000000 ; lv ( le <= lg )  { lb = ( le + lg ) / 2 ; lk = lu ( lb ) ; ln ( lk ) { le = lb + 1 ; } ls  { ln ( lf > lb ) lf = lb ; lg = lb - 1 ; } } lx ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 " " \x64 \x3a \x20 \x25 \x2e \x31 \x6c \x66 \n " , ld , ( lr ) ( lf ) / 2 ) ; } lw 0 ; }
>>>Func
METHOD lu
METHOD_RETURN lt
<operator>.assignment lb=0
<operator>.lessThan la<2*ld-1
<operator>.postIncrement la++
<operator>.assignmentPlus lr+=lb
<operator>.assignmentPlus lb+=ld
lg lg(lk<lb*lb-ld*ld)
<operator>.assignment lk=lb*lb-ld*ld
<operator>.subtraction 2*ld-1
<operator>.lessThan lk<lb*lb-ld*ld
<operator>.subtraction lb*lb-ld*ld
<operator>.multiplication 2*ld
<operator>.subtraction lb*lb-ld*ld
<operator>.multiplication lb*lb
<operator>.multiplication ld*ld
<operator>.multiplication lb*lb
<operator>.multiplication ld*ld
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->9 0->10 0->12 0->14 0->15 0->16 0->17 2->1 2->5 2->6 3->1 3->1 3->4 4->1 4->1 5->1 5->1 6->1 6->16 7->1 7->1 8->1 8->1 8->1 9->1 9->3 9->3 10->7 10->7 11->1 11->1 11->8 11->8 12->6 12->9 12->9 12->17 13->10 13->10 14->1 14->11 15->1 15->11 16->13 16->14 17->13 17->15
>>>Token lt lu ( ) { ls lb = 0 , la , lc , le , lf , lh , li ; lj ( la = 0  ; la < 2 * ld - 1 ; la ++ ) { lg ( la < ld ) lc = la + 1 ; lq lc = 2 * ld - la - 1 ; lg ( lc == 1 ) lo ; lf = 0 ; lj ( le = 0  ; ; le ++ ) { lg ( le == lc - 1 )  { lf = lc - 1 ; lm ; } lh = le ; li = lc - 1 ; lj ( ; lh < lc ; lh ++ , li -- ) { lg ( ll [ la ] [ lh ] != ll [ la ] [ li ] )  lp ln ; } lf = le ; lm ; ln : ; } lg ( lb < lf ) lb = lf ; } lr += lb ; lb += ld ; lg ( lk < lb * lb - ld * ld ) lk = lb * lb - ld * ld ; }
>>>Func
METHOD lm
METHOD_RETURN lj
PARAM lg*lc
<operator>.assignment lb=0
<operator>.assignment la=ld(lg)
le le(&lk,lc+lb,la)
<operator>.assignmentPlus lb+=la
<operator>.assignment la=ld(lf)
le le(&lh,lc+lb,la)
<operator>.assignmentPlus lb+=la
<operator>.assignment la=ld(lf)
le le(&lo,lc+lb,la)
<operator>.assignmentPlus lb+=la
<operator>.assignment la=521*ld(li)
le le(ln,lc+lb,la)
<operator>.assignmentPlus lb+=la
IDENTIFIER ll <empty>
ld ld(lg)
<operator>.addition lc+lb
ld ld(lf)
<operator>.addition lc+lb
ld ld(lf)
<operator>.addition lc+lb
<operator>.multiplication 521*ld(li)
<operator>.addition lc+lb
ld ld(li)
>>>PDG&26 0->2 0->3 0->5 0->6 0->8 0->9 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 2->5 2->8 2->11 2->14 2->18 2->20 2->22 2->24 3->1 3->5 3->6 3->18 4->1 4->1 4->5 5->1 5->1 5->6 6->8 6->9 6->20 7->8 8->1 8->1 8->9 9->11 9->12 9->22 10->1 10->1 10->11 11->1 11->1 11->12 12->14 12->15 12->24 13->1 13->1 13->14 14->1 14->1 14->1 14->15 15->1 15->1 15->1 17->1 17->4 19->7 19->21 21->1 21->10 23->1 23->13 23->13 24->1 25->1 25->23
>>>Token lj lm ( lg * lc ) { lf lb , la ; lb = 0 ; la = ld ( lg ) ; le ( & lk , lc + lb , la ) ; lb += la ; la = ld ( lf ) ; le ( & lh , lc + lb , la ) ; lb += la ; la = ld ( lf ) ; le ( & lo , lc + lb , la ) ; lb += la ; la = 521 * ld ( li ) ; le ( ln , lc + lb , la ) ; lb += la ; ll ; }
>>>Func
METHOD lx
METHOD_RETURN ly
<operator>.assignment ld=0
lc lc("""\x25\x64",&lq)
<operator>.lessThan lk<lq
<operator>.postIncrement lk++
lv lv()
lv lv()
IDENTIFIER lz <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1 7->1
>>>Token ly lx ( ) { lr lq , lo , ln , ls ; lt lb , lh , lm ; lr la , le , lk ; lt lg [ 100 ] ; lr ld = 0 ; lc ( " " " \x25 \x64 " , & lq ) ; lf ( lk = 0  ; lk < lq ; lk ++ ) { ld = 0 ; lf ( le = 0  ; le < 128 ; le ++ ) lf ( la = 0 ; la < 128 ; la ++ ) { lj [ le ] [ la ] = 0 ; lp [ le ] [ la ] = 0 ; } lc ( " \x25 \x64 " , & lo ) ; lc ( " \x25 " " \x63 " , & lb ) ; li ( lo > 0 )  { lf ( la = 0  ; la < lo ; la ++ ) { lc ( " \x25 \x63 \x25 \x63 \x25 \x63 " , & lb , & lh , & lm ) ; lj [ lb ] [ lh ] = lm ; lj [ lh ] [ lb ] = lm ; lc ( " \x25 \x63 " , & lb ) ; } } lc ( " " " \x25 \x64 " , & ln ) ; lc ( " \x25 \x63 " , & lb ) ; li ( ln > 0 )  { lf ( la = 0  ; la < ln ; la ++ ) { lc ( " " " \x25 \x63 \x25 \x63 " , & lb , & lh ) ; lp [ lb ] [ lh ] = 1 ; lp [ lh ] [ lb ] = 1 ; lc ( " \x25 \x63 " , & lb ) ; } } lc ( " \x25 \x64 " , & ls ) ; lc ( " \x25 \x63 " , & lb ) ; lf ( la = 0  ; la < ls ; la ++ ) { lc ( " " " \x25 \x63 " , & lb ) ; li ( ld > 0 )  { li ( lj [ lg [ ld - 1 ] ] [ lb ] != 0 )  { lg [ ld - 1 ] = lj [ lg [ ld - 1 ] ] [ lb ] ; lu ; } lf ( le = 0  ; le < ld ; le ++ ) li ( lp [ lg [ le ] ] [ lb ] ) l0 ; li ( le < ld )  { ld = 0 ; lu ; } } lg [ ld ++ ] = lb ; } ll ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , lk + 1 ) ; lf ( la = 0  ; la < ld ; la ++ ) { li ( la != ld - 1 )  ll ( " \x25 \x63 \x2c \x20 " , lg [ la ] ) ; lw ll ( " " " \x25 \x63 " , lg [ la ] ) ; } ll ( " \x5d \n " ) ; } lv ( ) ; lv ( ) ; lz ; }
>>>Func
METHOD lq
METHOD_RETURN lb
li li("\x25\x64",&lh)
<operator>.lessThan ld<lh
<operator>.postIncrement ld++
IDENTIFIER lr <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lb lq ( ) { lb ld , lh ; li ( " \x25 \x64 " , & lh ) ; ln lb lc [ ls ] ; ll ( ld = 0  ; ld < lh ; ld ++ ) { lb lg ; lb la ; lb lj = 0 ; lb lf = 0 ; lb le = lo ; li ( " \x25 \x64 " , & lg ) ; ll ( la = 0  ; la < lg ; la ++ ) { li ( " \x25 \x64 " , & ( lc [ la ] ) ) ; lf += lc [ la ] ; lk ( lc [ la ] < le ) le = lc [ la ] ; lj ^= lc [ la ] ; } lk ( lj ) lm ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f " " \n " , ld + 1 ) ; lp lm ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 " " \n " , ld + 1 , lf - le ) ; } lr 0 ; }
>>>Func
METHOD le
METHOD_RETURN lb
ld ld("\x20\x25\x64",&lc)
<operator>.lessEqualsThan la<=lc
<operator>.postIncrement la++
IDENTIFIER lg <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lb le ( ) { lb lc ; lb la ; ld ( " \x20 \x25 \x64 " , & lc ) ; li ( la = 1  ; la <= lc ; la ++ ) { lf ( " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , la ) ; lh ( ) ; } lg 0 ; }
>>>Func
METHOD lq
METHOD_RETURN lb
PARAM lb lt
PARAM ls*lo[]
<operator>.expressionList le lh
<operator>.expressionList la ld
lg lg("""\x25\x64",&lj)
<operator>.lessThan lc<lj
<operator>.postIncrement lc++
IDENTIFIER lr <empty>
LITERAL 0 <empty>
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 3->1 4->1 4->1 4->1 5->1 5->1 5->1 6->1 6->1 6->7 7->1 7->1 7->8 8->1 8->1
>>>Token lb lq ( lb lt , ls * lo [ ] ) { lb lj ; lb li ; lb lc , lf ; lm lb le , lh ; lm lb la , ld ; lg ( " " " \x25 \x64 " , & lj ) ; ln ( lc = 0  ; lc < lj ; lc ++ ) { lg ( " \x25 \x64 " , & li ) ; lg ( " \x25 \x75 " , & la ) ; le = ld = lh = la ; ln ( lf = 1  ; lf < li ; lf ++ ) { lg ( " \x25 \x75 " , & la ) ; lh += la ; ld = ld ^ la ; lk ( la < le )  { le = la ; } } lk ( ! ld )  { ll ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a " " \x20 \x25 \x75 \n " , lc + 1 , ( lh - le ) ) ; } lp  { ll ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 " " \x64 \x3a \x20 \x4e \x4f \n " , lc + 1 ) ; } } lr 0 ; }
>>>Func
METHOD l18
METHOD_RETURN le
PARAM le l26
PARAM l5* *l12
lf lf((l2=l27(l12[1],"\x72"))==l29)
BLOCK <empty> <empty>
l22 l22(l2,"\x25\x64\n",&l8)
<operator>.lessEqualsThan l0<=l8
<operator>.preIncrement ++l0
IDENTIFIER l15 <empty>
LITERAL 0 <empty>
l19 l19("\x74\x65\x73\x74\x20\x73\x65\x71\x75\x65\x6e\x63\x65\x20""\n")
l28 l28(1)
<operator>.equals (l2=l27(l12[1],"\x72"))==l29
<operator>.assignment l2=l27(l12[1],"\x72")
l27 l27(l12[1],"\x72")
>>>PDG&16 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 2->1 3->1 3->15 4->1 4->1 6->1 6->1 6->1 6->7 7->1 7->1 7->8 8->1 8->1 11->1 12->1 13->1 13->1 13->4 13->4 14->1 14->6 14->13 15->1 15->13 15->13 15->14 15->14
>>>Token le l18 ( le l26 , l5 * * l12 ) { l17 * l2 ; le l8 ; le l0 ; lf ( ( l2 = l27 ( l12 [ 1 ] , " \x72 " ) ) == l29 )  { l19 ( " \x74 \x65 \x73 \x74 \x20 \x73 \x65 \x71 \x75 \x65 \x6e \x63 \x65 \x20 " " \n " ) ; l28 ( 1 ) ; } l22 ( l2 , " \x25 \x64 \n " , & l8 ) ; lo ( l0 = 1  ; l0 <= l8 ; ++ l0 ) { l16 lg [ 72 ] ; l20 lb [ 56 ] ; le lu = 0 ; le ln = 0 ; l5 lv [ 100 ] ; l5 lt [ 100 ] ; le l4 ; le l1 ; le lm ; l5 lc [ 33 ] ; le lx ; le li , lk , lh , ld ; le lz ; l10 ( & lg , 0 , l11 ( lg ) ) ; l10 ( & lb , 0 , l11 ( lb ) ) ; lu = 0 ; ln = 0 ; l4 = 0 ; lw ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , l0 ) ; lm = 0 ; lx = 0 ; li = lk = lh = 0 ; l1 = 0 ; l24 ( ! l1 )  { le ll ; ll = l23 ( l2 ) ; lf ( l14 ( ll ) && ( lm % 2 ) ) ++ lm ; l1 = ( ll == l25 ) || ll == ' \n ' ; lf ( l1 || ( ll == ' ' ) || ( ll == ' \t ' ) )  { lc [ lx ] = ' \0 ' ; l21 ( lm ) { ly 0 : lu = l6 ( lc , 0 , 10 ) ; ++ lm ; lp ; ly 2 : ln = l6 ( lc , 0 , 10 ) ; ++ lm ; lp ; ly 4 : l4 = l6 ( lc , 0 , 10 ) ; ++ lm ; lp ; ly 1 : lg [ li ] . ls = lc [ 0 ] ; lg [ li ] . lr = lc [ 1 ] ; lg [ li ] . l7 = lc [ 2 ] ; ++ li ; lg [ li ] . ls = lc [ 1 ] ; lg [ li ] . lr = lc [ 0 ] ; lg [ li ] . l7 = lc [ 2 ] ; ++ li ; lp ; lp ; ly 3 : lb [ lk ] . ls = lc [ 0 ] ; lb [ lk ] . lr = lc [ 1 ] ; lb [ lk ] . lj = 0xfffffff ; ++ lk ; lb [ lk ] . ls = lc [ 1 ] ; lb [ lk ] . lr = lc [ 0 ] ; lb [ lk ] . lj = 0xfffffff ; ++ lk ; lp ; } lx = 0 ; } l9 lf ( lm == 5 ) { lv [ lh ] = ll ; ++ lh ; } l9 { lc [ lx ] = ll ; ++ lx ; } ; } lu *= 2 ; ln *= 2 ; lo ( ld = -1 , lh = 0  ; lh < l4 ; ++ lh ) { le la , l3 ; le lq ; ++ ld ; lt [ ld ] = lv [ lh ] ; lf ( ( ld > 0 ) && ( lh > 0 ) )  { lo ( la = 0  ; la < lu ; ++ la ) { lf ( ( ( lg [ la ] . ls == lv [ lh ] ) && ( lg [ la ] . lr == lt [ ld - 1 ] ) ) )  { -- ld ; lt [ ld ] = lg [ la ] . l7 ; lo ( l3 = 0  ; l3 < ln ; ++ l3 ) lf ( lb [ la ] . lj == ld ) lb [ la ] . lj = 0xfffffff ; lp ; } } lf ( la != lu ) l13 ; } lq = 0xfffffff ; lo ( la = 0  ; la < ln ; ++ la ) lf ( ( lb [ la ] . ls == lv [ lh ] ) && ( lq > lb [ la ] . lj ) ) { lq = lb [ la ] . lj ; } lf ( lq != 0xfffffff )  { ld = lq - 1 ; lo ( la = 0  ; la < ln ; ++ la ) lf ( lb [ la ] . lj >= lq ) lb [ la ] . lj = 0xfffffff ; l13 ; } lo ( la = 0  ; la < ln ; ++ la ) { lf ( ( lb [ la ] . lr == lv [ lh ] ) && ( lb [ la ] . lj > ld ) )  { lb [ la ] . lj = ld ; } } } lw ( " \x5b " ) ; lo ( lz = 0  ; lz < ld ; ++ lz ) lw ( " \x25 \x63 \x2c \x20 " , lt [ lz ] ) ; lf ( ld >= 0 )  lw ( " \x25 \x63 \x5d " , lt [ ld ] ) ; l9 lw ( " \x5d " ) ; lw ( " \n " ) ; } ; l15 0 ; }
>>>Func
METHOD lx
METHOD_RETURN ANY
le le("\x25\x64",&lv)
<operator>.lessEqualsThan ln<=lv
<operator>.postIncrement ln++
>>>PDG&5 0->2 0->3 0->4 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lx ( ) { ly lv , ln , lr , lq , lu , lb , lc , la , lj , lo , lm ; lk ld [ 110 ] ; lk lf [ 36 ] [ 4 ] ; lk lh [ 28 ] [ 3 ] ; lk ls [ 100 ] ; lk ll ; le ( " \x25 \x64 " , & lv ) ; lg ( ln = 1  ; ln <= lv ; ln ++ ) { le ( " " " \x25 \x64 \x20 " , & lr ) ; lg ( lb = 0  ; lb < lr ; lb ++ ) { le ( " \x25 \x63 " , & lf [ lb ] [ 0 ] ) ; le ( " " " \x25 \x63 " , & lf [ lb ] [ 1 ] ) ; le ( " \x25 \x63 \x20 " , & lf [ lb ] [ 2 ] ) ; lf [ lb ] [ 3 ] = ' \0 ' ; } le ( " \x25 \x64 \x20 " , & lq ) ; lg ( lb = 0  ; lb < lq ; lb ++ ) { le ( " \x25 \x63 " , & lh [ lb ] [ 0 ] ) ; le ( " \x25 \x63 \x20 " , & lh [ lb ] [ 1 ] ) ; lh [ lb ] [ 2 ] = ' \0 ' ; } le ( " \x25 \x64 \x20 " , & lu ) ; lc = -1 ; lg ( lb = 0  ; lb < lu ; lb ++ ) { le ( " \x25 \x63 " , & ll ) ; ld [ ++ lc ] = ll ; li ( lc >= 1 )  { lj = 0 ; lg ( la = 0  ; la < lr ; la ++ ) { li ( ( ld [ lc - 1 ] == lf [ la ] [ 0 ] && ld [ lc ] == lf [ la ] [ 1 ] ) || ( ld [ lc - 1 ] == lf [ la ] [ 1 ] && ld [ lc ] == lf [ la ] [ 0 ] ) )  { ld [ -- lc ] = lf [ la ] [ 2 ] ; lj = 1 ; lt ; } } li ( lj ) lz ; lo = 0 ; lg ( la = 0  ; la < lq ; la ++ ) { li ( lh [ la ] [ 0 ] == ll ) ls [ lo ++ ] = lh [ la ] [ 1 ] ; lw li ( lh [ la ] [ 1 ] = = ll ) ls [ lo ++ ] = lh [ la ] [ 0 ] ; } lj = 0 ; lg ( la = 0  ; la < lc ; la ++ ) { lg ( lm = 0  ; lm < lo ; lm ++ ) { li ( ld [ la ] == ls [ lm ] )  { lj = 1 ; lc = -1 ; lt ; } } li ( lj == 1 ) lt ; } } } lp ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x5b " , ln ) ; lg ( la = 0  ; la <= lc ; la ++ ) { li ( la == lc ) lp ( " \x25 \x63 " , ld [ la ] ) ; lw lp ( " \x25 \x63 \x2c \x20 " , ld [ la ] ) ; } lp ( " \x5d \n " ) ; } }
>>>Func
METHOD li
METHOD_RETURN lg
PARAM ld lb[]
PARAM ld le
lc lc("\n\x56\x65\x72\x74\x65\x78\x20\x20\x44\x69""\x73\x74\x61\x6e\x63\x65\n")
<operator>.lessThan la<le
<operator>.postIncrement la++
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->5 4->1 5->1 5->1 5->6 6->1 6->1
>>>Token lg li ( ld lb [ ] , ld le ) { lc ( " \n \x56 \x65 \x72 \x74 \x65 \x78 \x20 \x20 \x44 \x69 " " \x73 \x74 \x61 \x6e \x63 \x65 \n " ) ; lk ( ld  la = 0 ; la < le ; la ++ ) { lj ( lb [ la ] != lf )  lc ( " \x25 \x64 \t \x25 \x64 \n " , la , lb [ la ] ) ; lh lc ( " \x25 \x64 \t \x49 \x4e \x46 " , la ) ; } }
>>>Func
METHOD l9
METHOD_RETURN lf
<operator>.assignment l2=lz()
<operator>.lessEqualsThan ln<=l2
<operator>.preIncrement ++ln
IDENTIFIER l10 <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lf l9 ( ) { lf l2 , lp , lo , ls , lb ; l5 * ld , l8 , * la , lr , lq ; l4 * lg , * lh ; l2 = lz ( ) ; li ( lf  ln = 1 ; ln <= l2 ; ++ ln ) { lt ( ln > 1 ) { lj ( " \n " ) ; } lj ( " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a \x20 " , ln ) ; lp = lz ( ) ; lg = l0 ( l1 ( l4 ) * lp ) ; li ( lf  lc = 0 ; lc < lp ; ++ lc ) { la = l3 ( 3 ) ; lg [ lc ] . lw = lx ( la [ 0 ] , la [ 1 ] ) ; lg [ lc ] . lv = lu ( la [ 0 ] , la [ 1 ] ) ; lg [ lc ] . lc = la [ 2 ] ; lk ( la ) ; } lo = lz ( ) ; lh = l0 ( l1 ( l4 ) * lo ) ; li ( lf  le = 0 ; le < lo ; ++ le ) { la = l3 ( 2 ) ; lh [ le ] . lw = lx ( la [ 0 ] , la [ 1 ] ) ; lh [ le ] . lv = lu ( la [ 0 ] , la [ 1 ] ) ; lh [ le ] . lc = 0 ; lk ( la ) ; } lb = 0 ; ls = lz ( ) ; la = l3 ( ls ) ; ld = l0 ( l1 ( l5 ) * ls ) ; li ( lf  ly = 0 ; ly < ls ; ++ ly ) { ld [ lb ++ ] = la [ ly ] ; lt ( lb >= 2 )  { lr = lx ( ld [ lb - 2 ] , ld [ lb - 1 ] ) ; lq = lu ( ld [ lb - 2 ] , ld [ lb - 1 ] ) ; li ( lf  lc = 0 ; lc < lp ; ++ lc ) { lt ( lg [ lc ] . lw == lr && lg [ lc ] . lv == lq )  { lb -= 1 ; ld [ lb - 1 ] = lg [ lc ] . lc ; } } li ( lf  le = 0 ; le < lo ; ++ le ) { li ( lf  lm = 0 ; lm < lb ; ++ lm ) { lr = lx ( ld [ lm ] , ld [ lb - 1 ] ) ; lq = lu ( ld [ lm ] , ld [ lb - 1 ] ) ; lt ( lh [ le ] . lw == lr && lh [ le ] . lv == lq )  { lb = 0 ; l7 l6 ; } } } l6 : ; } } lj ( " \x5b " ) ; li ( lf  ll = 0 ; ll < lb ; ++ ll ) { lt ( ll > 0 ) { lj ( " \x2c \x20 " ) ; } lj ( " \x25 \x63 " , ld [ ll ] ) ; } lj ( " \x5d " ) ; lk ( ld ) ; lk ( la ) ; lk ( lg ) ; lk ( lh ) ; } l10 0 ; }
>>>Func
METHOD ln
METHOD_RETURN lb
PARAM lb lg
PARAM lm*lj[]
lp lp(lg<2)
IDENTIFIER lh <empty>
LITERAL 1 <empty>
<operator>.assignment le=1
ll ll((lo)lq(&lk))
<operator>.assignment ld=(lb)lj[1][0]
<operator>.lessEqualsThan la<=ld
<operator>.postIncrement la++
IDENTIFIER lh <empty>
LITERAL 0 <empty>
<operator>.lessThan lg<2
<operator>.cast (lo)lq(&lk)
<operator>.cast (lb)lj[1][0]
lq lq(&lk)
>>>PDG&18 0->2 0->3 0->5 0->6 0->7 0->10 0->11 0->12 0->13 0->14 0->17 2->14 3->1 4->1 4->1 7->1 7->1 8->1 8->1 9->1 9->1 9->10 10->1 10->1 10->11 11->1 11->1 14->1 14->4 14->4 15->1 16->1 17->1 17->8 17->15
>>>Token lb ln ( lb lg , lm * lj [ ] ) { lp ( lg < 2 ) lh 1 ; lb ld , la , lc , le = 1 ; lr lk ; ll ( ( lo ) lq ( & lk ) ) ; ld = ( lb ) lj [ 1 ] [ 0 ] ; li ( la = 1  ; la <= ld ; la ++ ) { li ( lc = 1  ; lc <= la ; lc ++ ) { lf ( " " " \x25 \x64 \x20 " , le ) ; le ++ ; } lf ( " \n " ) ; } lh 0 ; }
>>>Func
METHOD l0
METHOD_RETURN le
PARAM le l6
PARAM ld* *l1
<operator>.assignment *lc=lw("\x69\x6e\x70\x75\x74\x2e\x69\x6e","""\x72")
<operator>.assignment *lq=lw("\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74","\x77")
<operator>.assignment la=0
l8 l8(lp,10,lc)
<operator>.assignment ln=l5(lp)
<operator>.lessEqualsThan lh<=ln
<operator>.postIncrement lh++
lx lx(lc)
lx lx(lq)
IDENTIFIER l3 <empty>
LITERAL 0 <empty>
lw lw("\x69\x6e\x70\x75\x74\x2e\x69\x6e","""\x72")
lw lw("\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74","\x77")
l5 l5(lp)
>>>PDG&18 0->2 0->3 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->1 3->1 4->1 4->1 4->7 5->1 5->1 5->12 6->1 6->1 7->1 7->11 7->17 8->1 8->1 8->9 9->1 9->1 9->10 10->1 10->1 11->1 11->1 12->1 12->1 15->4 15->4 16->5 16->5 17->1 17->8
>>>Token le l0 ( le l6 , ld * * l1 ) { ly * lc = lw ( " \x69 \x6e \x70 \x75 \x74 \x2e \x69 \x6e " , " " " \x72 " ) ; ly * lq = lw ( " \x6f \x75 \x74 \x70 \x75 \x74 \x2e \x74 \x78 \x74 " , " \x77 " ) ; ld lp [ 10 ] ; le lh , ln ; le la = 0 ; l8 ( lp , 10 , lc ) ; ln = l5 ( lp ) ; lk ( lh = 1  ; lh <= ln ; lh ++ ) { ld lm [ 101 ] ; ld la [ 500 ] ; ld ls [ 36 ] [ 3 ] ; ld lu [ 28 ] [ 2 ] ; le ll = 0 , lj = 0 ; le lb ; lt ( la , 0 , 101 ) ; lt ( lm , 0 , 101 ) ; lf ( lc , " \x25 \x64 " , & ll ) ; lk ( lb = 0  ; lb < ll ; lb ++ ) { lb = 0 ; lf ( lc , " \x25 \x73 " , ls [ lb ] ) ; } lf ( lc , " \x25 \x64 " , & lj ) ; lk ( lb = 0  ; lb < lj ; lb ++ ) { lb = 0 ; lf ( lc , " \x25 \x73 " , lu [ lb ] ) ; } ld lg ; le lv ; lf ( lc , " \x25 \x64 " , & lv ) ; lf ( lc , " \x25 \x73 " , lm ) ; lk ( lb = 0  ; lb < lv ; lb ++ ) { lg = lm [ lb ] ; lr ( li ( la ) == 0 )  { la [ 0 ] = lg ; l10 ; } ld lo = l4 ( la [ li ( la ) - 1 ] , lg , ls , ll ) ; lr ( lo != 0 )  { la [ li ( la ) - 1 ] = lo ; } lz lr ( l11 ( lg , la , lu , lj ) ) { lt ( la , 0 , 101 ) ; } lz { la [ li ( la ) ] = lg ; } } l7 ( la , li ( la ) ) ; l2 ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x73 \n " , lh , la ) ; l9 ( lq , " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x73 \n " , lh , la ) ; } lx ( lc ) ; lx ( lq ) ; l3 0 ; }
>>>Func
METHOD li
METHOD_RETURN lc
PARAM lf*lb
PARAM lc ld
<operator>.assignment la=0
le le(ld,&lb[la],1)
lg lg(lb[la]!='\n'&&lb[la]!='\0')
le le(ld,&lb[++la],1)
<operator>.assignment lb[la]='\0'
<operator>.postDecrement lh--
IDENTIFIER la <empty>
<operator>.logicalAnd lb[la]!='\n'&&lb[la]!='\0'
<operator>.notEquals lb[la]!='\n'
<operator>.notEquals lb[la]!='\0'
<operator>.preIncrement ++la
<operator>.indirectIndexAccess lb[la]
>>>PDG&16 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->12 0->13 0->14 2->1 2->5 2->7 2->12 2->13 3->5 4->1 4->14 5->1 5->1 5->7 5->12 5->13 6->1 6->1 7->1 7->1 7->1 8->1 8->1 9->1 9->1 11->1 11->1 11->6 11->6 12->11 12->11 12->13 12->13 12->15 13->11 13->11 14->1
>>>Token lc li ( lf * lb , lc ld ) { lc la = 0 ; le ( ld , & lb [ la ] , 1 ) ; lg ( lb [ la ] != ' \n ' && lb [ la ] != ' \0 ' )  le ( ld , & lb [ ++ la ] , 1 ) ; lb [ la ] = ' \0 ' ; lh -- la ; }
>>>Func
METHOD lu
METHOD_RETURN lm
<operator>.assignment *la=li
<operator>.assignment *ld=lj
<operator>.assignment le=0
<operator>.assignment lc=0
ll ll(la)
BLOCK <empty> <empty>
lp lp(la)
BLOCK <empty> <empty>
lb lb("\x53\x55\x4d\x4d\x41\x52\x59\x20\x3a\n\x25""\x6c\x64\x20\x62\x79\x74\x65\x73\x20\x6c\x6f\x73\x74\x20\x69\x6e\x20""\x25\x64\x20\x62\x6c\x6f\x63\x6b\x73\n",le,lc)
lb lb("\x4d\x65\x6d\x6f""\x72\x79\x20\x4c\x65\x61\x6b\x73\x20\x64\x65\x74\x65\x63\x74\x65\x64""\x2e\n")
<operator>.assignment ld=la
lb lb("\n\x25\x6c\x64\x20\x62\x79\x74\x65\x73""\x20\x6c\x6f\x73\x74\n",la->lg)
lb lb("\x61\x64\x64\x72\x65\x73\x73\x20""\x3a\x20\x30\x78\x25\x70\x20\x69\x6e\x20\x25\x73\t\x25\x73\x3a\x25""\x64\n",la->ln,la->lt,la->lk,la->lr)
lb lb("\n\x3d\x3d\x3d\x3d\x3d\x3d""\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d""\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n")
<operator>.assignmentPlus le+=la->lg
<operator>.assignment la=la->lo
lh lh(ld)
<operator>.postIncrement lc++
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 2->1 2->1 2->6 3->1 3->1 4->1 4->16 5->1 5->19 6->1 6->8 8->1 8->12 10->1 10->1 10->1 11->1 12->1 12->18 13->1 13->16 14->1 14->1 14->1 14->1 14->1 15->1 16->1 16->1 16->10 17->1 17->1 17->1 18->1 18->1 19->1 19->10
>>>Token lm lu ( ) { lf * la = li ; lf * ld = lj ; ls le = 0 ; lq lc = 0 ; ll ( la ) { lb ( " \x4d \x65 \x6d \x6f " " \x72 \x79 \x20 \x4c \x65 \x61 \x6b \x73 \x20 \x64 \x65 \x74 \x65 \x63 \x74 \x65 \x64 " " \x2e \n " ) ; } lp ( la ) { ld = la ; lb ( " \n \x25 \x6c \x64 \x20 \x62 \x79 \x74 \x65 \x73 " " \x20 \x6c \x6f \x73 \x74 \n " , la -> lg ) ; lb ( " \x61 \x64 \x64 \x72 \x65 \x73 \x73 \x20 " " \x3a \x20 \x30 \x78 \x25 \x70 \x20 \x69 \x6e \x20 \x25 \x73 \t \x25 \x73 \x3a \x25 " " \x64 \n " , la -> ln , la -> lt , la -> lk , la -> lr ) ; lb ( " \n \x3d \x3d \x3d \x3d \x3d \x3d " " \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d " " \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \x3d \n " ) ; le += la -> lg ; la = la -> lo ; lh ( ld ) ; lc ++ ; } lb ( " \x53 \x55 \x4d \x4d \x41 \x52 \x59 \x20 \x3a \n \x25 " " \x6c \x64 \x20 \x62 \x79 \x74 \x65 \x73 \x20 \x6c \x6f \x73 \x74 \x20 \x69 \x6e \x20 " " \x25 \x64 \x20 \x62 \x6c \x6f \x63 \x6b \x73 \n " , le , lc ) ; }
>>>Func
METHOD ll
METHOD_RETURN le
PARAM le*lc
PARAM lg la
li li(la)
BLOCK <empty> <empty>
<operator>.preDecrement --la
<operator>.lessThan lb<la
<operator>.postIncrement lb++
<operator>.assignment lc[la]='\0'
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 3->4 4->1 4->6 6->1 6->7 7->1 7->1 7->8 8->1 8->1 9->1 9->1
>>>Token le * ll ( le * lc , lg la ) { lo le ld [ ] = " \x61 \x62 \x63 \x64 \x65 \x66 \x67 \x68 \x69 " " \x6a \x6b \x6c \x6d \x6e \x6f \x70 \x71 \x72 \x73 \x74 \x75 \x76 \x77 \x78 \x79 \x7a " " \x31 \x32 \x33 \x34 \x35 \x36 \x37 \x38 \x39 \x30 " ; li ( la ) { -- la ; ln ( lg  lb = 0 ; lb < la ; lb ++ ) { lh lf = lk ( ) % ( lh ) ( lj ld - 1 ) ; lc [ lb ] = ld [ lf ] ; } lc [ la ] = ' \0 ' ; } lm lc ; }
>>>Func
METHOD lo
METHOD_RETURN lb
PARAM lf lj
PARAM lf lh[]
PARAM lb lk
PARAM lb lm
PARAM lf*ll[]
<operator>.lessThan ld<lm
<operator>.postIncrement ld++
IDENTIFIER lg <empty>
LITERAL 0 <empty>
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 3->1 4->1 5->7 6->1 7->1 7->1 7->8 8->1 8->1
>>>Token lb lo ( lf lj , lf lh [ ] , lb lk , lb lm , lf * ll [ ] ) { lb ld ; lb la ; li ( ld = 0  ; ld < lm ; ld ++ ) { lf * lc = ll [ ld ] ; le ( lj == lc [ 0 ] )  { li ( la = 0  ; la < lk ; la ++ ) { le ( lh [ la ] == lc [ 1 ] )  { lg 1 ; } } } ln le ( lj == lc [ 1 ] ) { li ( la = 0  ; la < lk ; la ++ ) { le ( lh [ la ] == lc [ 0 ] )  { lg 1 ; } } } } lg 0 ; }
>>>Func
METHOD lg
METHOD_RETURN lb
PARAM lb li
PARAM lh*lj[]
<operator>.assignment lc=0
<operator>.lessThan la<127
<operator>.postIncrement la++
le le("""\x53\x75\x6d\x20\x69\x73\x3a\x20\x25\x64\n",lc)
IDENTIFIER lf <empty>
LITERAL 0 <empty>
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 3->1 4->1 4->7 5->1 5->6 6->1 6->1 7->1 7->1
>>>Token lb lg ( lb li , lh * lj [ ] ) { lb la ; lb lc = 0 ; ld ( la = 0  ; la < 127 ; la ++ ) lc += la ; le ( " " " \x53 \x75 \x6d \x20 \x69 \x73 \x3a \x20 \x25 \x64 \n " , lc ) ; lf 0 ; }
>>>Func
METHOD lm
METHOD_RETURN lc
PARAM lc li
PARAM lc lh
<operator>.assignment lb=0.0
<operator>.lessThan la<ll
<operator>.preIncrement ++la
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 4->1 4->1 5->1 5->1 5->6 6->1 6->1
>>>Token lc lm ( lc li , lc lh ) { lc lb = 0.0 ; lj ( lc  la = 0 ; la < ll ; ++ la ) { lg ( li == la || lh == la )  { lc ld = ln - lb ; lg ( ld <= 0 )  { lb += le [ la ] ; } lf lg ( ld > 2 * le [ la ] ) { lb += 2 * le [ la ] ; } lf  { lb += ld ; lb += le [ la ] - ld / 2 ; } } lf  { lb += 2 * le [ la ] ; } } lk lb ; }
>>>Func
METHOD ly
METHOD_RETURN lt
PARAM lt l0
PARAM lv* *lz
ll ll("\x25\x64\n",&ls)
<operator>.lessThan lk<ls
<operator>.postIncrement lk++
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token lt ly ( lt l0 , lv * * lz ) { lt lk , la , lc , lb , ls ; lv lh ; lw lm , lf ; lw li , lo ; lv lj [ 100 ] [ 100 ] ; lw lp [ 100 ] , le [ 100 ] , lu [ 100 ] , ln [ 100 ] , lr [ 100 ] ; ll ( " \x25 \x64 \n " , & ls ) ; ld ( lk = 0  ; lk < ls ; lk ++ ) { ll ( " \x25 \x64 \n " , & lc ) ; ld ( la = 0  ; la < lc ; la ++ ) { lm = 0 ; lf = 0 ; ld ( lb = 0  ; lb < lc ; lb ++ ) { ll ( " \x25 \x63 " , & lh ) ; lg ( lh == ' ' )  { lm ++ ; lf ++ ; } lq lg ( lh == ' 0 ' ) { lf ++ ; } lj [ la ] [ lb ] = lh ; } lp [ la ] = lm ; le [ la ] = lf ; lu [ la ] = lm / lf ; ll ( " \n " ) ; } ld ( la = 0  ; la < lc ; la ++ ) { li = 0 ; ld ( lb = 0  ; lb < lc ; lb ++ ) { lg ( lj [ la ] [ lb ] == ' ' )  { li += ( lp [ lb ] ) / ( le [ lb ] - 1 ) ; } lq lg ( lj [ la ] [ lb ] = = ' ' ) { li += ( lp [ lb ] - 1 ) / ( le [ lb ] - 1 ) ; } } ln [ la ] = li / le [ la ] ; } ld ( la = 0  ; la < lc ; la ++ ) { lo = 0 ; ld ( lb = 0  ; lb < lc ; lb ++ ) { lg ( lj [ la ] [ lb ] == ' ' )  { } lq  { lo += ln [ lb ] ; } } lr [ la ] = lo / le [ la ] ; } ll ( " " " \n " ) ; lx ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \n " , lk + 1 ) ; ld ( la = 0  ; la < lc ; la ++ ) { lx ( " \x25 \x30 \x2e \x31 \x30 \x66 \n " , 0.25 * lu [ la ] + 0.5 * ln [ la ] + 0.25 * lr [ la ] ) ; } } }
>>>Func
METHOD ll
METHOD_RETURN lk
PARAM lh le
<operator>.assignment ld[le]=lm[le]
<operator>.greaterEqualsThan lb>=1
<operator>.postDecrement lb--
>>>PDG&6 0->2 0->4 0->5 2->1 3->1 3->1 3->1 4->1 4->5 5->1 5->1
>>>Token lk ll ( lh le ) { lh lf , lc , lb ; ld [ le ] = lm [ le ] ; li ( lb = le - 1  ; lb >= 1 ; lb -- ) { lf = 99999999 ; li ( lc = lb  ; lc <= le ; lc ++ ) { lj ( lg [ la [ lb ] ] [ la [ lc ] ] != 0 && ld [ la [ lc ] ] - lg [ la [ lb ] ] [ la [ lc ] ] < lf )  { ld [ la [ lb ] ] = ld [ la [ lc ] ] - lg [ la [ lb ] ] [ la [ lc ] ] ; lf = ld [ la [ lb ] ] ; } } } }
>>>Func
METHOD lo
METHOD_RETURN lm
lj lj("\x25\x64",&li)
<operator>.lessEqualsThan lc<=li
<operator>.postIncrement lc++
IDENTIFIER ll <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lm lo ( ) { lj ( " \x25 \x64 " , & li ) ; ln ( lc = 1  ; lc <= li ; lc ++ ) { lj ( " \x25 \x64 \x25 \x64 " " \x25 \x64 " , & lh , & la , & lg ) ; lb ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 " , lc ) ; lf ( ( la > 0 && lg == 0 ) || ( la < 100 && lg == 100 ) )  { lb ( " \x42 \x72 \x6f \x6b \x65 " " \x6e \n " ) ; lp ; } lf ( la ) { ld = lq ( la , 100 ) ; la /= ld ; le = 100 / ld ; } lk le = 1 ; lf ( le <= lh )  lb ( " \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " ) ; lk lb ( " \x42 \x72 \x6f \x6b " " \x65 \x6e \n " ) ; } ll 0 ; }
>>>Func
METHOD lo
METHOD_RETURN la
PARAM la lf[]
PARAM la ln[]
PARAM la lj
<operator>.assignment lc=0
<operator>.assignment ld=0
<operator>.assignment le=0
<operator>.assignment lh=0
<operator>.lessThan lb<lj
<operator>.postIncrement lb++
li li(lc==ld)
BLOCK <empty> <empty>
IDENTIFIER ll <empty>
BLOCK <empty> <empty>
IDENTIFIER lg <empty>
LITERAL 1 <empty>
IDENTIFIER lg <empty>
LITERAL 0 <empty>
<operator>.equals lc==ld
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 2->1 3->1 4->9 5->1 5->19 6->1 6->19 7->1 7->1 8->1 8->1 9->1 9->1 9->10 10->1 10->1 11->1 11->1 19->1 19->1 19->11 19->11
>>>Token la lo ( la lf [ ] , la ln [ ] , la lj ) { la lc = 0 ; la ld = 0 ; la lb ; la le = 0 , lh = 0 ; lm ( lb = 0  ; lb < lj ; lb ++ ) { li ( lb == lf [ le ] )  { lc = lc ^ lk [ lb ] ; le ++ ; } ll { ld = ld ^ lk [ lb ] ; lh ++ ; } } li ( lc == ld )  { lg 1 ; } ll { lg 0 ; } }
>>>Func
METHOD lp
METHOD_RETURN ll
PARAM le li
PARAM le lg
PARAM le lc
<operator>.assignment lf=0
lb lb(lc==100&&lg!=100)
IDENTIFIER lk <empty>
LITERAL 0 <empty>
<operator>.lessThan la<li+1
<operator>.postIncrement la++
<operator>.logicalAnd lc==100&&lg!=100
<operator>.addition li+1
<operator>.equals lc==100
<operator>.notEquals lg!=100
>>>PDG&15 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->12 0->13 0->14 2->9 2->12 3->1 3->14 4->13 5->1 5->1 6->1 6->1 9->1 9->1 9->10 10->1 10->1 11->1 11->1 11->6 11->6 12->1 13->1 13->11 13->11 13->14 14->1 14->11 14->11
>>>Token ll lp ( le li , le lg , le lc ) { ll lf = 0 ; le la , ld , lr , lo , lh ; lq ls ; lb ( lc == 100 && lg != 100 ) lk 0 ; lm ( la = 1  ; la < li + 1 ; la ++ ) { lb ( 100 % la ) lj ; lm ( ld = 0  ; ld < li + 1 ; ld ++ ) { lh = 100 * ld / la ; lb ( lh != lg ) lj ; lb ( lg == lc )  { lf = 1 ; ln ; } lb ( lc != 100 && lc != 0 )  { lf = 1 ; ln ; } } } lk lf ; }
>>>Func
METHOD lq
METHOD_RETURN lf
lg lg("\x25\x64",&ll)
<operator>.assignment le=1
ln ln(le<=ll)
BLOCK <empty> <empty>
IDENTIFIER lr <empty>
LITERAL 0 <empty>
<operator>.assignment ld=0
<operator>.expressionList lflc la
lg lg("\x25\x6c\x66",&lj)
<operator>.expressionList lg("\x25\x64",&lc) lg("\x25\x64",&la)
lb lb(lj>=1.00)
BLOCK <empty> <empty>
lb lb(ld==1)
BLOCK <empty> <empty>
IDENTIFIER li <empty>
BLOCK <empty> <empty>
<operator>.postIncrement le++
<operator>.lessEqualsThan le<=ll
<operator>.assignment lk=1
ln ln(lk<=lj)
BLOCK <empty> <empty>
lm lm("\x43\x61\x73""\x65\x20\x23\x25\x64\x3a\x20\x50\x6f\x73\x73\x69\x62\x6c\x65\x20\n",le)
lm lm("\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x42\x72\x6f\x6b""\x65\x6e\x20\n",le)
lg lg("\x25\x64",&lc)
lg lg("\x25\x64",&la)
<operator>.greaterEqualsThan lj>=1.00
lb lb(lp(lk,lc)==1)
BLOCK <empty> <empty>
<operator>.postIncrement lk++
<operator>.equals ld==1
<operator>.lessEqualsThan lk<=lj
lb lb(lc>0&&la==0)
BLOCK <empty> <empty>
IDENTIFIER li <empty>
lb lb(lc==100&&la!=100&&la!=0)
BLOCK <empty> <empty>
IDENTIFIER li <empty>
lb lb(la!=100)
BLOCK <empty> <empty>
IDENTIFIER li <empty>
lb lb(la==100&&lc==100)
BLOCK <empty> <empty>
<operator>.equals lp(lk,lc)==1
<operator>.assignment ld=0
IDENTIFIER lh <empty>
<operator>.assignment ld=1
IDENTIFIER lh <empty>
<operator>.assignment ld=1
IDENTIFIER lh <empty>
<operator>.assignment ld=1
IDENTIFIER lh <empty>
lp lp(lk,lc)
<operator>.logicalAnd lc>0&&la==0
<operator>.logicalAnd lc==100&&la!=100&&la!=0
<operator>.notEquals la!=100
<operator>.logicalAnd la==100&&lc==100
<operator>.greaterThan lc>0
<operator>.equals la==0
<operator>.logicalAnd lc==100&&la!=100
<operator>.notEquals la!=0
<operator>.equals la==100
<operator>.equals lc==100
<operator>.equals lc==100
<operator>.notEquals la!=100
>>>PDG&66 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->34 0->35 0->37 0->38 0->40 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->56 0->58 0->59 0->61 0->62 0->63 0->64 0->65 2->1 2->1 2->19 3->1 3->19 4->1 4->1 9->1 9->1 9->26 9->56 9->59 9->61 9->65 10->1 10->1 10->27 10->32 11->1 11->1 11->1 12->1 12->1 14->1 14->1 18->1 18->1 19->1 19->4 19->4 19->23 20->1 20->32 21->1 21->1 23->1 23->24 24->1 24->18 25->1 25->11 25->11 25->53 25->58 25->63 25->64 26->1 26->11 26->11 26->56 26->59 26->61 26->62 26->65 27->12 27->12 27->32 28->1 28->1 30->1 30->1 31->1 31->14 31->14 32->1 32->21 32->21 32->53 33->1 33->1 36->1 36->1 39->1 39->1 42->1 42->1 44->1 44->28 44->28 45->1 51->1 51->31 53->30 53->44 53->44 53->58 54->1 54->1 54->33 54->33 55->1 55->1 55->36 55->36 56->39 56->39 56->62 57->1 57->1 57->42 57->42 58->54 58->54 58->59 58->64 59->54 59->54 59->56 59->61 59->65 60->55 60->55 60->57 60->61 61->55 61->55 61->56 62->1 62->57 62->57 62->63 63->1 63->57 63->57 64->1 64->60 64->60 64->63 64->65 65->56 65->60 65->60 65->61
>>>Token lf lq ( ) { lf ll ; lg ( " \x25 \x64 " , & ll ) ; lf le = 1 ; ln ( le <= ll )  { lf ld = 0 ; lo lj ; lflc , la ; lg ( " \x25 \x6c \x66 " , & lj ) ; lg ( " \x25 \x64 " , & lc ) , lg ( " \x25 \x64 " , & la ) ; lb ( lj >= 1.00 )  { lo lk = 1 ; ln ( lk <= lj )  { lb ( lp ( lk , lc ) == 1 )  { lb ( lc > 0 && la == 0 )  { ld = 0 ; lh ; } li lb ( lc == 100 && la ! = 100 && la != 0 ) { ld = 1 ; lh ; } li lb ( la != 100 ) { ld = 1 ; lh ; } li lb ( la == 100 && lc = = 100 ) { ld = 1 ; lh ; } } lk ++ ; } } lb ( ld == 1 )  { lm ( " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \x20 \n " , le ) ; } li  { lm ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x42 \x72 \x6f \x6b " " \x65 \x6e \x20 \n " , le ) ; } le ++ ; } lr 0 ; }
>>>Func
METHOD lg
METHOD_RETURN lf
<operator>.assignment lb=153
lc lc(ld(lb)==1)
la la("\x54\x72\x75\x65\n")
IDENTIFIER le <empty>
la la("\x46""\x61\x6c\x73\x65\n")
<operator>.assignment lb=1253
lc lc(ld(lb)==1)
la la("\x54\x72\x75\x65\n")
IDENTIFIER le <empty>
la la("\x46\x61\x6c\x73\x65\n")
IDENTIFIER lh <empty>
LITERAL 0 <empty>
<operator>.equals ld(lb)==1
<operator>.equals ld(lb)==1
ld ld(lb)
ld ld(lb)
>>>PDG&18 0->2 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->1 2->16 6->1 7->1 7->17 8->1 8->1 9->1 11->1 14->3 14->3 15->1 15->8 15->8 16->14 17->1 17->15
>>>Token lf lg ( ) { lf lb = 153 ; lc ( ld ( lb ) == 1 )  la ( " \x54 \x72 \x75 \x65 \n " ) ; le la ( " \x46 " " \x61 \x6c \x73 \x65 \n " ) ; lb = 1253 ; lc ( ld ( lb ) == 1 )  la ( " \x54 \x72 \x75 \x65 \n " ) ; le la ( " \x46 \x61 \x6c \x73 \x65 \n " ) ; lh 0 ; }
>>>Func
METHOD lh
METHOD_RETURN lc
<operator>.assignment la=6
<operator>.assignment *lb=ln(la*lj(lc))
le le("\x49\x6e\x73\x65\x72""\x74\x20\x25\x64\x20\x75\x6e\x73\x6f\x72\x74\x65\x64\x20\x6e\x75\x6d""\x62\x65\x72\x73\x3a\x20\n",la)
<operator>.lessThan ld<la
<operator>.preIncrement ++ld
le le("\x49\x6e\x69\x74\x69\x61\x6c\x20\x61\x72\x72\x61\x79\x3a""\x20")
lf lf(lb,la)
lm lm(lb,la)
le le("\x53\x6f\x72\x74\x65\x64\x20\x61\x72""\x72\x61\x79\x3a\x20")
lf lf(lb,la)
lg lg(lb)
IDENTIFIER ll <empty>
LITERAL 0 <empty>
ln ln(la*lj(lc))
<operator>.multiplication la*lj(lc)
lj lj(lc)
>>>PDG&18 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 2->1 2->16 3->1 3->1 3->8 4->1 4->5 5->1 5->6 5->8 6->1 6->1 7->1 8->9 8->9 9->1 9->11 9->11 10->1 11->1 11->1 11->12 12->1 12->1 15->1 15->3 16->1 16->4 16->15 16->15 17->1 17->16
>>>Token lc lh ( ) { lc la = 6 ; lc ld ; lc * lb = ln ( la * lj ( lc ) ) ; le ( " \x49 \x6e \x73 \x65 \x72 " " \x74 \x20 \x25 \x64 \x20 \x75 \x6e \x73 \x6f \x72 \x74 \x65 \x64 \x20 \x6e \x75 \x6d " " \x62 \x65 \x72 \x73 \x3a \x20 \n " , la ) ; li ( ld = 0  ; ld < la ; ++ ld ) lk ( " \x25 \x64 " , & lb [ ld ] ) ; le ( " \x49 \x6e \x69 \x74 \x69 \x61 \x6c \x20 \x61 \x72 \x72 \x61 \x79 \x3a " " \x20 " ) ; lf ( lb , la ) ; lm ( lb , la ) ; le ( " \x53 \x6f \x72 \x74 \x65 \x64 \x20 \x61 \x72 " " \x72 \x61 \x79 \x3a \x20 " ) ; lf ( lb , la ) ; lg ( lb ) ; ll 0 ; }
>>>Func
METHOD lk
METHOD_RETURN lg
PARAM lg
<operator>.lessEqualsThan la<=10
<operator>.postIncrement la++
>>>PDG&5 0->2 0->3 0->4 2->1 3->1 3->4 4->1 4->1
>>>Token lg lk ( lg ) { lh lb , lj , la ; lf ( la = 2  ; la <= 10 ; la ++ ) { ld = 2 ; lc [ la ] [ 1 ] = 1 ; lf ( lb = 1  ; lb < ll ; lb ++ ) { le ( lc [ la ] [ lb ] == 0 )  { li ( lb , la ) ; } le ( lc [ la ] [ lb ] == ld )  { ld ++ ; } } } }
>>>Func
METHOD ll
METHOD_RETURN li
PARAM li ld
PARAM li*lf
PARAM li lg
le le(lg==ld)
BLOCK <empty> <empty>
<operator>.assignment lh[lg]=0
<operator>.assignment lb=ll(ld,lf,lg+1)
<operator>.assignment lh[lg]=1
<operator>.assignment lc=ll(ld,lf,lg+1)
<operator>.conditional lj(lb>lc)?lb:lc
<operator>.assignment lb=lc=0
<operator>.lessThan la<ld
<operator>.postIncrement la++
<operator>.lessThan la<ld
<operator>.postIncrement la++
le le(lb!=lc)
<operator>.subtraction lj-1
<operator>.assignment lb=lc=0
<operator>.lessThan la<ld
<operator>.postIncrement la++
<operator>.lessThan la<ld
<operator>.postIncrement la++
le le((lb==0)||(lc==0))
<operator>.subtraction lj-1
<operator>.conditional lj(lb>lc)?lb:lc
<operator>.equals lg==ld
ll ll(ld,lf,lg+1)
ll ll(ld,lf,lg+1)
lj lj(lb>lc)
<operator>.assignment lc=0
<operator>.notEquals lb!=lc
<operator>.assignment lc=0
<operator>.logicalOr (lb==0)||(lc==0)
lj lj(lb>lc)
<operator>.addition lg+1
<operator>.addition lg+1
<operator>.greaterThan lb>lc
<operator>.equals lb==0
<operator>.equals lc==0
<operator>.greaterThan lb>lc
>>>PDG&42 0->2 0->3 0->4 0->6 0->7 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->29 0->31 0->32 0->33 0->36 0->37 0->38 0->39 0->40 0->41 2->27 3->28 4->27 5->1 5->1 7->1 8->1 8->38 9->1 9->1 10->1 10->1 10->38 11->1 11->1 11->1 11->1 12->32 13->14 13->15 14->15 15->16 15->20 16->20 17->1 17->1 18->25 19->1 19->1 19->39 20->21 20->22 21->22 22->1 22->23 22->28 23->1 23->1 24->1 24->1 25->1 25->1 27->5 27->5 27->13 27->28 27->29 27->36 27->37 28->8 28->8 28->8 28->29 28->29 29->1 29->1 29->1 29->10 29->10 29->10 30->1 31->12 31->32 32->17 32->17 33->19 33->40 33->41 34->1 34->1 34->24 34->24 37->1 38->11 38->11 38->30 38->30 39->34 39->34 39->40 39->41 40->34 40->34 40->41 41->26 41->26 41->35 41->35
>>>Token li ll ( li ld , li * lf , li lg ) { li lb , lc , la ; le ( lg == ld )  { lb = lc = 0 ; lk ( la = 0  ; la < ld ; la ++ ) le ( lh [ la ] == 0 ) lb = lm ( lb , lf [ la ] ) ; lk ( la = 0  ; la < ld ; la ++ ) le ( lh [ la ] == 1 ) lc = lm ( lc , lf [ la ] ) ; le ( lb != lc )  lj - 1 ; lb = lc = 0 ; lk ( la = 0  ; la < ld ; la ++ ) le ( lh [ la ] == 0 ) lb += lf [ la ] ; lk ( la = 0  ; la < ld ; la ++ ) le ( lh [ la ] == 1 ) lc += lf [ la ] ; le ( ( lb == 0 ) || ( lc == 0 ) )  lj - 1 ; lj ( lb > lc ) ? lb : lc ; } lh [ lg ] = 0 ; lb = ll ( ld , lf , lg + 1 ) ; lh [ lg ] = 1 ; lc = ll ( ld , lf , lg + 1 ) ; lj ( lb > lc ) ? lb : lc ; }
>>>Func
METHOD lt
METHOD_RETURN lq
lm lm("\x25\x64",&ln)
<operator>.lessEqualsThan lj<=ln
<operator>.postIncrement lj++
IDENTIFIER lu <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lq lt ( ) { lq ln , lj , lc [ 100 ] , lf [ 100 ] , la , lb , ld ; ll lo [ 100 ] , lk [ 100 ] , lp [ 100 ] ; lv lg [ 101 ] [ 101 ] ; lm ( " \x25 \x64 " , & ln ) ; le ( lj = 1  ; lj <= ln ; lj ++ ) { lm ( " \x25 \x64 " , & ld ) ; le ( la = 0  ; la < ld ; la ++ ) { lm ( " \x25 \x73 " , lg [ la ] ) ; lc [ la ] = lf [ la ] = 0 ; } le ( la = 0  ; la < ld ; la ++ ) { le ( lb = la + 1  ; lb < ld ; lb ++ ) { li ( lg [ la ] [ lb ] == ' ' )  { lc [ la ] ++ ; lf [ lb ] ++ ; } lr li ( lg [ la ] [ lb ] = = ' ' ) { lf [ la ] ++ ; lc [ lb ] ++ ; } } lo [ la ] = lc [ la ] * 1.0 / ( lc [ la ] + lf [ la ] ) ; } le ( la = 0  ; la < ld ; la ++ ) { ll lh = 0 ; le ( lb = 0  ; lb < ld ; lb ++ ) { li ( lg [ la ] [ lb ] == ' ' )  { lh += lc [ lb ] * 1.0 / ( lc [ lb ] + lf [ lb ] - 1 ) ; } lr li ( lg [ la ] [ lb ] = = ' ' ) { lh += ( lc [ lb ] - 1 ) * 1.0 / ( lc [ lb ] + lf [ lb ] - 1 ) ; } } lk [ la ] = lh / ( lc [ la ] + lf [ la ] ) ; } le ( la = 0  ; la < ld ; la ++ ) { ll lh = 0 ; le ( lb = 0  ; lb < ld ; lb ++ ) { li ( lg [ la ] [ lb ] != ' ' )  { lh += lk [ lb ] ; } } lp [ la ] = lh / ( lc [ la ] + lf [ la ] ) ; } ls ( " \x43 \x61 \x73 \x65 " " \x20 \x23 \x25 \x64 \x3a \n " , lj ) ; le ( la = 0  ; la < ld ; la ++ ) { ls ( " \x25 \x2e \x31 \x36 " " \x6c \x66 \n " , lo [ la ] / 4 + lk [ la ] / 2 + lp [ la ] / 4 ) ; } } lu 0 ; }
>>>Func
METHOD lx
METHOD_RETURN lu
PARAM l1
ls ls("""\x25\x64",&lr)
<operator>.lessThan ll<lr
<operator>.postIncrement ll++
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1
>>>Token lu lx ( l1 ) { lu lr , li , lo , ll , lb , ld , le , lm , lp , lj , ln ; l2 lc [ 15 ] ; ly la ; ls ( " " " \x25 \x64 " , & lr ) ; lk ( ll = 0  ; ll < lr ; ll ++ ) { ls ( " \x25 \x64 " , & li ) ; lk ( lb = 0  ; lb < li ; lb ++ ) { ls ( " \x25 \x64 " , & lo ) ; lc [ lb ] . lf = lo ; lc [ lb ] . lv = l0 ( lo ) ; } lm = 1 ; lz ( lm && lb < 20 )  { le = 0 ; lk ( ld = 0  ; ld < li ; ld ++ ) { lg ( lc [ ld ] . lv [ lb ] )  { le ++ ; } } lm = ! ( le % 2 ) ; lb ++ ; } lg ( ! lm )  { lt ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x4e \x4f " " \n " , ll + 1 ) ; } lq  { la . le = 0 ; la . lw = ( li / 2 ) + ( li % 2 ) ; la . lh = 0 ; lk ( lb = 0  ; lb < li ; lb ++ ) { lg ( la . le < la . lw )  { la . lc [ la . le ] = lc [ lb ] ; lg ( ! la . le )  { la . lh = lc [ lb ] . lf ; } lqlg ( lc [ lb ] . lf < la . lh )  { la . lh = lc [ lb ] . lf ; } la . le ++ ; } lq lg ( lc [ lb ] . lf > la . lh ) { lp = 0 ; lj = 0 ; lk ( ld = 0  ; ld < la . le ; ld ++ ) { lg ( ! lp && la . lc [ ld ] . lf == la . lh )  { la . lc [ ld ] . lf = lc [ lb ] . lf ; lp = 1 ; } lg ( ! lj || la . lc [ ld ] . lf < lj )  { lj = la . lc [ ld ] . lf ; } } la . lh = lj ; } } ln = 0 ; lk ( lb = 0  ; lb < la . le ; lb ++ ) { ln += la . lc [ lb ] . lf ; } lt ( " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , ll + 1 , ln ) ; } } }
>>>Func
METHOD l8
METHOD_RETURN la
PARAM la l2
PARAM l5* *ly
<operator>.assignment lolk=0
<operator>.assignment lp=0
<operator>.assignment ln=0
<operator>.assignment li=0
lj lj(l2!=2)
BLOCK <empty> <empty>
<operator>.assignment lg=lx(ly[1],"\x72")
lj lj(!lg)
BLOCK <empty> <empty>
<operator>.assignment ll=lx("\x6f""\x75\x74\x63\x6f\x6d\x65","\x77")
lj lj(lv(lg,"\x25\x64",&lw)!=1)
BLOCK <empty> <empty>
<operator>.lessEqualsThan le<=lw
<operator>.postIncrement le++
lz lz(ll)
lz lz(lg)
lc lc(lr,"\x50""\x6c\x65\x61\x73\x65\x20\x70\x72\x6f\x76\x69\x64\x65\x20\x69\x6e\x70""\x75\x74\x20\x66\x69\x6c\x65\x20\x6e\x61\x6d\x65\x20\x6f\x6e\x20\x63""\x6f\x6d\x6d\x61\x6e\x64\x20\x6c\x69\x6e\x65\x2e\n")
<operator>.assignment li=1
lc lc(lr,"\x69\x6e\x70\x75\x74\x20\x66\x69\x6c""\x65\x20\x6e\x6f\x74\x20\x66\x6f\x75\x6e\x64\n")
IDENTIFIER l1 <empty>
LITERAL 1 <empty>
lc lc(lr,"\x5b\x54\x5d\x20\x69\x6e\x70\x75\x74\x20\x66\x69\x6c\x65\x20\x66""\x6f\x72\x6d\x61\x74\x20\x77\x72\x6f\x6e\x67\n")
<operator>.assignment li=1
<operator>.notEquals l2!=2
lx lx(ly[1],"\x72")
<operator>.logicalNot !lg
lx lx("\x6f""\x75\x74\x63\x6f\x6d\x65","\x77")
<operator>.notEquals lv(lg,"\x25\x64",&lw)!=1
lv lv(lg,"\x25\x64",&lw)
>>>PDG&33 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->12 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 2->27 3->1 3->28 4->1 4->1 5->1 5->1 6->1 6->1 7->1 8->1 8->1 10->1 10->1 10->29 11->1 11->1 13->1 13->1 13->18 14->1 14->1 16->1 16->1 16->17 17->1 17->1 18->1 18->1 19->1 19->1 20->1 20->22 22->1 22->25 25->1 25->1 26->1 26->1 27->1 27->8 27->8 28->1 28->10 28->10 29->11 29->32 30->13 30->13 31->1 31->14 31->14 32->1 32->16 32->19 32->31 32->31 32->31
>>>Token la l8 ( la l2 , l5 * * ly ) { la lw ; la lh ; l0 * lg ; l0 * ll ; lo ld [ l9 ] ; la lu ; la lq ; lolk = 0 ; lo lp = 0 ; lo ln = 0 ; la lf ; la lb ; la le ; la li = 0 ; lj ( l2 != 2 )  { lc ( lr , " \x50 " " \x6c \x65 \x61 \x73 \x65 \x20 \x70 \x72 \x6f \x76 \x69 \x64 \x65 \x20 \x69 \x6e \x70 " " \x75 \x74 \x20 \x66 \x69 \x6c \x65 \x20 \x6e \x61 \x6d \x65 \x20 \x6f \x6e \x20 \x63 " " \x6f \x6d \x6d \x61 \x6e \x64 \x20 \x6c \x69 \x6e \x65 \x2e \n " ) ; li = 1 ; lt lm ; } lg = lx ( ly [ 1 ] , " \x72 " ) ; lj ( ! lg )  { lc ( lr , " \x69 \x6e \x70 \x75 \x74 \x20 \x66 \x69 \x6c " " \x65 \x20 \x6e \x6f \x74 \x20 \x66 \x6f \x75 \x6e \x64 \n " ) ; l1 1 ; } ll = lx ( " \x6f " " \x75 \x74 \x63 \x6f \x6d \x65 " , " \x77 " ) ; lj ( lv ( lg , " \x25 \x64 " , & lw ) != 1 )  { lc ( lr , " \x5b \x54 \x5d \x20 \x69 \x6e \x70 \x75 \x74 \x20 \x66 \x69 \x6c \x65 \x20 \x66 " " \x6f \x72 \x6d \x61 \x74 \x20 \x77 \x72 \x6f \x6e \x67 \n " ) ; li = 1 ; lt lm ; } ls ( le = 1  ; le <= lw ; le ++ ) { lj ( lv ( lg , " \x25 \x64 " , & lh ) != 1 )  { lc ( lr , " \x5b \x4e \x5d \x20 " " \x69 \x6e \x70 \x75 \x74 \x20 \x66 \x69 \x6c \x65 \x20 \x66 \x6f \x72 \x6d \x61 \x74 " " \x20 \x77 \x72 \x6f \x6e \x67 \n " ) ; li = 1 ; lt lm ; } l4 ( " \x5b \x64 \x65 \x62 \x75 " " \x67 \x5d \x20 \x4e \x3d \x25 \x64 \x20 \x20 \n " , lh ) ; lu = 0 ; ls ( lb = 0  ; lb < lh ; lb ++ ) { lj ( lv ( lg , " \x25 \x6c \x75 " , & ld [ lu ++ ] ) != 1 )  { lc ( lr , " \x5b \x43 \x28 \x25 \x64 " " \x29 \x5d \x20 \x69 \x6e \x70 \x75 \x74 \x20 \x66 \x69 \x6c \x65 \x20 \x66 \x6f \x72 " " \x6d \x61 \x74 \x20 \x77 \x72 \x6f \x6e \x67 \n " , lb ) ; li = 1 ; lt lm ; } } l12 ( ld , lh , l11 ( lo ) , l7 ) ; lp = ld [ 0 ] ; lk = ld [ 1 ] ; ls ( lq = 2  ; lq < lu ; lq ++ ) { lk ^= ld [ lq ] ; } lf = 1 ; l10 ( ( lp != lk ) && ( lf < lh ) )  { lp ^= ld [ lf ] ; lk ^= ld [ lf ] ; lf ++ ; } lj ( lp != lk )  { lc ( ll , " " " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x73 \n " , le , " \x4e \x4f " ) ; lc ( l3 , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x73 \n " , le , " \x4e " " \x4f " ) ; } l6 { ln = 0 ; ls ( lb = lf  ; lb < lh ; lb ++ ) { ln += ld [ lb ] ; } lc ( ll , " \x43 \x61 \x73 " " \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x6c \x75 \n " , le , ln ) ; lc ( l3 , " \x43 \x61 " " \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x6c \x75 \n " , le , ln ) ; } } lm : lz ( ll ) ; lz ( lg ) ; l1 li ; }
>>>Func
METHOD li
METHOD_RETURN lb
PARAM lb lg
PARAM lb lc
PARAM lb lf
<operator>.lessEqualsThan la<=lg
<operator>.postIncrement la++
IDENTIFIER ld <empty>
LITERAL 0 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->5 3->1 4->1 5->1 5->1 5->6 6->1 6->1
>>>Token lb li ( lb lg , lb lc , lb lf ) { lb la ; lj ( la = 1  ; la <= lg ; la ++ ) { le ( ( la * lc ) % 100 == 0 )  le ( lf == 100 ) ld lc == 100 ; lh le ( lf == 0 )  ld lc = = 0 ; lh ld 1 ; } ld 0 ; }
>>>Func
METHOD lo
METHOD_RETURN lh
li li("\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61""\x74\x74\x65\x6d\x70\x74\x31\x2e\x69\x6e","\x72",lr)
li li("\x41\x2d""\x73\x6d\x61\x6c\x6c\x2e\x74\x78\x74","\x77",lq)
lf lf("\x25\x64\n",&lg)
<operator>.lessThan lc<lg
<operator>.postIncrement lc++
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 3->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token lh lo ( ) { lh lb , lg , lc , la ; lm ld ; li ( " \x41 \x2d \x73 \x6d \x61 \x6c \x6c \x2d \x61 " " \x74 \x74 \x65 \x6d \x70 \x74 \x31 \x2e \x69 \x6e " , " \x72 " , lr ) ; li ( " \x41 \x2d " " \x73 \x6d \x61 \x6c \x6c \x2e \x74 \x78 \x74 " , " \x77 " , lq ) ; lf ( " \x25 \x64 \n " , & lg ) ; le ( lc = 0  ; lc < lg ; lc ++ ) { lf ( " \x25 \x64 " , & lb ) ; lj ( " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a \n " , lc + 1 ) ; ld = 0 ; le ( la = 0  ; la < lb ; la ++ ) { lf ( " \x25 \x73 " , lk [ la ] ) ; } le ( la = 0  ; la < lb ; la ++ ) { ld = ( 0.25 * lp ( la , lb ) ) + ( 0.5 * ll ( la , lb ) ) + ( 0.25 * ln ( la , lb ) ) ; lj ( " \x25 \x6c \x66 \n " , ld ) ; } } }
>>>Func
METHOD lz
METHOD_RETURN lg
<operator>.assignment * *lb=l1
ls ls("\x41\x2d\x73\x6d""\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x31\x2e\x69\x6e","\x72",lx)
ls ls("\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74""\x31\x2e\x6f\x75\x74","\x77",l0)
ld ld("\x25\x64",&ll)
<operator>.lessEqualsThan le<=ll
<operator>.preIncrement ++le
IDENTIFIER lv <empty>
LITERAL 0 <empty>
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 2->1 2->1 3->1 3->1 4->1 4->1 5->1 5->1 5->6 6->1 6->1 6->7 7->1 7->1
>>>Token lg lz ( ) { lg ll ; lg le , la ; lh * * lb = l1 ; lg lc ; ly lk ; ls ( " \x41 \x2d \x73 \x6d " " \x61 \x6c \x6c \x2d \x61 \x74 \x74 \x65 \x6d \x70 \x74 \x31 \x2e \x69 \x6e " , " \x72 " , lx ) ; ls ( " \x41 \x2d \x73 \x6d \x61 \x6c \x6c \x2d \x61 \x74 \x74 \x65 \x6d \x70 \x74 " " \x31 \x2e \x6f \x75 \x74 " , " \x77 " , l0 ) ; ld ( " \x25 \x64 " , & ll ) ; li ( le = 1  ; le <= ll ; ++ le ) { ld ( " \x25 \x64 " , & lj ) ; lt ( lf ) ; la = 0 ; lp ( lj -- )  { lt ( lf + la ) ; la += l2 ( lf + la ) ; } lj = la ; lm ( " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \n " , le ) ; ld ( " \x25 \x64 " , & lo ) ; lp ( lo -- )  { ld ( " \x25 \x73 " , lu ) ; ld ( " \x25 \x64 " , & lc ) ; lb = lr ( ln ( lh *  ) * lc ) ; li ( la = 0  ; la < lc ; ++ la ) { lb [ la ] = lr ( ln ( lh ) * 11 ) ; ld ( " \x25 \x73 " , lb [ la ] ) ; } lk = lw ( lf , lb , lc ) ; lm ( " \x25 \x2e \x37 \x66 \n " , lk ) ; li ( la = 0  ; la < lc ; ++ la ) lq ( lb [ la ] ) ; lq ( lb ) ; } } lv 0 ; }
>>>Func
METHOD lq
METHOD_RETURN lj
PARAM lj lv
PARAM ll*lo[]
lb lb(lc,"\x25\x69",&li)
<operator>.lessThan ld<li
<operator>.postIncrement ld++
IDENTIFIER ls <empty>
LITERAL 0 <empty>
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->1 4->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1
>>>Token lj lq ( lj lv , ll * lo [ ] ) { ll lm [ ln ] ; lj ld , la , lg , li , le , lf ; ll lh [ ln * 4 ] ; lb ( lc , " \x25 \x69 " , & li ) ; lk ( ld = 0  ; ld < li ; ld ++ ) { lb ( lc , " \x25 \x69 " , & le ) ; lk ( la = 0  ; la < le ; la ++ ) { lb ( lc , " \x20 \x25 \x33 \x63 " , lr [ la ] ) ; } lb ( lc , " \x25 \x69 " , & lf ) ; lk ( la = 0  ; la < lf ; la ++ ) { lb ( lc , " \x20 \x25 \x32 \x63 " , lu [ la ] ) ; } lb ( lc , " \x25 \x69 " , & lg ) ; lb ( lc , " \x25 \x73 " , lm ) ; lt ( le , lf , lm , lg , lh ) ; lp ( " \x43 \x61 \x73 \x65 \x20 " " \x23 \x25 \x69 \x3a \x20 \x25 \x73 \x5d \n " , ld + 1 , lh ) ; } ls 0 ; }
>>>Func
METHOD ll
METHOD_RETURN lb
le le("\x45\x6e\x74\x65\x72\x20\x73\x69\x7a\x65\x20\x6f""\x66\x20\x61\x72\x72\x61\x79\x3a\n")
lg lg("\x25\x64",&la)
le le("\x45\x6e""\x74\x65\x72\x20\x74\x68\x65\x20\x65\x6c\x65\x6d\x65\x6e\x74\x73\x20""\x6f\x66\x20\x74\x68\x65\x20\x61\x72\x72\x61\x79\n")
<operator>.assignment *lc=(lb * )lm(la*lh(lb))
<operator>.lessThan ld<la
<operator>.postIncrement ld++
le le("""\x4f\x72\x69\x67\x69\x6e\x61\x6c\x20\x61\x72\x72\x61\x79\x3a\x20")
lf lf(lc,la)
ln ln(lc,la)
le le("\x53\x6f\x72\x74\x65\x64\x20\x61\x72\x72\x61""\x79\x3a\x20")
lf lf(lc,la)
lk lk(lc)
IDENTIFIER lj <empty>
LITERAL 0 <empty>
<operator>.cast (lb * )lm(la*lh(lb))
lm lm(la*lh(lb))
<operator>.multiplication la*lh(lb)
lh lh(lb)
>>>PDG&20 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->18 0->19 2->1 3->1 3->1 3->6 3->9 3->10 3->12 3->18 4->1 5->1 5->1 5->9 6->1 6->7 6->9 7->1 7->1 8->1 9->10 9->10 10->1 10->12 10->12 11->1 12->1 12->1 12->13 13->1 13->1 16->1 17->1 17->5 17->16 18->1 18->6 18->17 18->17 19->1 19->18
>>>Token lb ll ( ) { lb la ; le ( " \x45 \x6e \x74 \x65 \x72 \x20 \x73 \x69 \x7a \x65 \x20 \x6f " " \x66 \x20 \x61 \x72 \x72 \x61 \x79 \x3a \n " ) ; lg ( " \x25 \x64 " , & la ) ; le ( " \x45 \x6e " " \x74 \x65 \x72 \x20 \x74 \x68 \x65 \x20 \x65 \x6c \x65 \x6d \x65 \x6e \x74 \x73 \x20 " " \x6f \x66 \x20 \x74 \x68 \x65 \x20 \x61 \x72 \x72 \x61 \x79 \n " ) ; lb ld ; lb * lc = ( lb * ) lm ( la * lh ( lb ) ) ; li ( ld = 0  ; ld < la ; ld ++ ) { lg ( " \x25 \x64 " , & lc [ ld ] ) ; } le ( " " " \x4f \x72 \x69 \x67 \x69 \x6e \x61 \x6c \x20 \x61 \x72 \x72 \x61 \x79 \x3a \x20 " ) ; lf ( lc , la ) ; ln ( lc , la ) ; le ( " \x53 \x6f \x72 \x74 \x65 \x64 \x20 \x61 \x72 \x72 \x61 " " \x79 \x3a \x20 " ) ; lf ( lc , la ) ; lk ( lc ) ; lj 0 ; }
>>>Func
METHOD l3
METHOD_RETURN lc
ls ls("\x25\x64",&lr)
<operator>.lessThan lj<lr
<operator>.postIncrement lj++
IDENTIFIER l5 <empty>
LITERAL 0 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1
>>>Token lc l3 ( ) { lc lr , lj ; ls ( " \x25 \x64 " , & lr ) ; ly lw li [ lv ] [ lv ] ; lf ( lj = 0  ; lj < lr ; lj ++ ) { lc ld , lh ; ls ( " \x25 \x64 \x20 \x25 \x64 \n " , & ld , & lh ) ; lc la , lb ; lf ( la = 0  ; la < ld ; la ++ ) ls ( " \x25 \x73 \n " , l1 [ la ] ) ; lc lu = 1 << ( ld * lh ) ; lc ll , ln ; lc lp = 0 ; lf ( ll = 0  ; ll < lu ; ll ++ ) { ln = ll ; lf ( la = 0  ; la < ld ; la ++ ) { lf ( lb = 0  ; lb < lh ; lb ++ ) { l0 [ la ] [ lb ] = ln % 2 ; ln /= 2 ; } } lz ( li , 0 , l6 ( li ) ) ; lw lm = 1 ; lf ( la = 0  ; la < ld ; la ++ ) { lf ( lb = 0  ; lb < lh ; lb ++ ) { lk ( li [ la ] [ lb ] == 0 )  { lc lg , le , lo , lt ; lg = la ; le = lb ; l7 { lk ( li [ lg ] [ le ] ) { lm = 0 ; lq ; } li [ lg ] [ le ] = 1 ; lx ( lg , le , & lo , & lt , ld , lh ) ; lg = lo ; le = lt ; } l4 ( ( lg != la ) || ( le != lb ) ) ; } lk ( ! lm ) lq ; } lk ( ! lm ) lq ; } lk ( lm ) lp ++ ; } l2 ( " \x43 " " \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x25 \x64 \n " , lj + 1 , lp ) ; } l5 0 ; }
>>>Func
METHOD lk
METHOD_RETURN ld
PARAM lc*lh
PARAM ld lg
PARAM lc* *lf
PARAM lc*le
<operator>.assignment lb=0
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 4->1 5->1 6->1 6->1
>>>Token lo ld lk ( lc * lh , ld lg , lc * * lf , lc * le ) { ld lb = 0 ; lc * la ; lp ( la = lh  ; ; ) { lq ( lb < lg ) ; lf [ lb ++ ] = la ; li ( * la && ! lm ( le , * la ) ) la ++ ; lj ( ! * la ) ln ; * la ++ = 0 ; } ll lb ; }
>>>Func
METHOD ll
METHOD_RETURN lm
PARAM le lo
<operator>.lessThan lb<lh
<operator>.preIncrement ++lb
>>>PDG&5 0->2 0->3 0->4 2->1 3->1 3->1 3->4 4->1 4->1
>>>Token lm ll ( le lo ) { le lb , la ; lg lc ; le ld ; lf ( lb = 0  ; lb < lh ; ++ lb ) { lc = 0 ; ld = 0 ; lf ( la = 0  ; la < lh ; ++ la ) { ln ( lj [ lb ] [ la ] != ' ' )  { lc += lk [ la ] ; ld ++ ; } } li [ lb ] = lc / ( lg ) ( ld ) ; } }
>>>Func
METHOD lj
METHOD_RETURN li
PARAM lb lc
PARAM lb ld[]
PARAM lb le
<operator>.assignment la=0
lf lf(lc!=0)
BLOCK <empty> <empty>
lg lg(lc%2==0)
<operator>.assignment ld[le-1-la]=0
<operator>.assignment ld[le-1-la]=1
<operator>.assignmentDivision lc/=2
<operator>.postIncrement la++
<operator>.notEquals lc!=0
<operator>.equals lc%2==0
<operator>.modulo lc%2
<operator>.subtraction le-1-la
<operator>.subtraction le-1
>>>PDG&18 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->13 4->17 5->1 5->16 6->1 6->1 8->1 8->1 9->1 9->1 10->1 10->1 11->1 11->1 12->1 12->1 13->6 13->6 13->15 14->1 14->8 14->8 15->11 15->14 15->14 16->1 16->12 17->1 17->16 17->16
>>>Token li lj ( lb lc , lb ld [ ] , lb le ) { lb la ; la = 0 ; lf ( lc != 0 )  { lg ( lc % 2 == 0 ) ld [ le - 1 - la ] = 0 ; lh ld [ le - 1 - la ] = 1 ; lc /= 2 ; la ++ ; } }
>>>Func
METHOD lv
METHOD_RETURN ld
PARAM ld lq
PARAM lo* *lj
l4 l4(lq==3)
IDENTIFIER lh <empty>
<operator>.assignment lc=ll(lj[1],"\x72")
<operator>.assignment la=ll(lj[2],"\x77")
l5 l5(li,5000,lc)
<operator>.assignment lk=ly(li)
<operator>.assignment lb=1
lw lw(l2(lc,"\x25\x64\x20\x25\x64\x20\x25\x64""\n",&lh,&le,&lf)!=lx)
BLOCK <empty> <empty>
lm lm(lc)
lm lm(la)
lt lt(lh>=100)
<operator>.assignment lg=1
<operator>.assignment lg=l0((ld)lh,le)
lt lt(lg&&!(lf==100&&le!=100)&&!(lf==0&&le!=0))
BLOCK <empty> <empty>
IDENTIFIER lp <empty>
BLOCK <empty> <empty>
<operator>.postIncrement lb++
<operator>.equals lq==3
ll ll(lj[1],"\x72")
ll ll(lj[2],"\x77")
ly ly(li)
<operator>.notEquals l2(lc,"\x25\x64\x20\x25\x64\x20\x25\x64""\n",&lh,&le,&lf)!=lx
lr lr(la,"\x43\x61\x73\x65\x20\x23""\x25\x64\x3a\x20\x50\x6f\x73\x73\x69\x62\x6c\x65\n",lb)
ln ln(la)
lr lr(la,"\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x42\x72\x6f\x6b\x65""\x6e\n",lb)
ln ln(la)
l2 l2(lc,"\x25\x64\x20\x25\x64\x20\x25\x64""\n",&lh,&le,&lf)
<operator>.greaterEqualsThan lh>=100
l0 l0((ld)lh,le)
<operator>.logicalAnd lg&&!(lf==100&&le!=100)&&!(lf==0&&le!=0)
<operator>.cast (ld)lh
<operator>.logicalAnd lg&&!(lf==100&&le!=100)
<operator>.logicalNot !(lf==0&&le!=0)
<operator>.logicalNot !(lf==100&&le!=100)
<operator>.logicalAnd lf==0&&le!=0
<operator>.logicalAnd lf==100&&le!=100
<operator>.equals lf==0
<operator>.notEquals le!=0
<operator>.equals lf==100
<operator>.notEquals le!=100
>>>PDG&46 0->2 0->3 0->5 0->8 0->10 0->12 0->13 0->14 0->16 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->36 0->37 0->42 0->43 0->44 0->45 2->23 3->1 3->24 3->25 4->1 4->1 6->1 6->1 6->8 7->1 7->1 7->28 8->1 8->26 8->32 9->1 9->1 9->1 10->1 10->28 11->1 11->1 13->1 13->1 14->1 14->1 15->1 15->1 16->1 17->1 17->1 17->37 18->1 18->1 22->1 22->1 23->1 23->4 23->4 24->1 24->6 24->6 25->1 25->7 25->7 26->1 26->9 27->1 27->1 27->11 27->11 28->1 28->29 28->30 29->30 30->1 30->22 30->31 31->1 31->14 32->1 32->1 32->1 32->13 32->27 32->27 32->27 32->27 32->27 32->33 32->34 32->34 32->36 32->42 32->43 32->44 32->45 33->15 33->15 33->34 33->36 34->1 34->1 34->17 34->17 34->43 34->45 35->1 35->1 35->18 35->18 36->1 37->1 37->1 37->35 37->35 37->38 37->40 37->42 38->1 38->35 39->1 39->37 40->1 40->1 40->38 40->38 41->1 41->1 41->39 41->39 42->1 42->40 42->40 42->43 43->1 43->40 43->40 44->1 44->41 44->41 44->42 44->45 45->1 45->41 45->41 45->43
>>>Token ld lv ( ld lq , lo * * lj ) { l4 ( lq == 3 ) ; lu * lc , * la ; ld lk , lb ; ld l1 , le , lf , lz , lg ; lo li [ 5000 ] , * l3 ; ls ls lh ; lc = ll ( lj [ 1 ] , " \x72 " ) ; la = ll ( lj [ 2 ] , " \x77 " ) ; l5 ( li , 5000 , lc ) ; lk = ly ( li ) ; lb = 1 ; lw ( l2 ( lc , " \x25 \x64 \x20 \x25 \x64 \x20 \x25 \x64 " " \n " , & lh , & le , & lf ) != lx )  { lt ( lh >= 100 ) lg = 1 ; lp lg = l0 ( ( ld ) lh , le ) ; lt ( lg && ! ( lf == 100 && le != 100 ) && ! ( lf == 0 && le != 0 ) )  { lr ( la , " \x43 \x61 \x73 \x65 \x20 \x23 " " \x25 \x64 \x3a \x20 \x50 \x6f \x73 \x73 \x69 \x62 \x6c \x65 \n " , lb ) ; ln ( la ) ; } lp  { lr ( la , " \x43 \x61 \x73 \x65 \x20 \x23 \x25 \x64 \x3a \x20 \x42 \x72 \x6f \x6b \x65 " " \x6e \n " , lb ) ; ln ( la ) ; } lb ++ ; } lm ( lc ) ; lm ( la ) ; }
>>>Func
METHOD lj
METHOD_RETURN lg
PARAM lh le
PARAM lh lf
ld ld(la=li(lb,lk*2,le)<0)
<operator>.subtraction lc-1
ld ld(le==lb[2*la]&&lf==lb[2*la+1])
ld ld(lf==lb[2*la])
<operator>.subtraction lc-1
<operator>.assignment la=li(lb,lk*2,le)<0
<operator>.logicalAnd le==lb[2*la]&&lf==lb[2*la+1]
<operator>.equals lf==lb[2*la]
<operator>.lessThan li(lb,lk*2,le)<0
<operator>.equals le==lb[2*la]
<operator>.equals lf==lb[2*la+1]
li li(lb,lk*2,le)
<operator>.multiplication 2*la
<operator>.multiplication lk*2
<operator>.multiplication 2*la
<operator>.addition 2*la+1
<operator>.multiplication 2*la
<operator>.indirectIndexAccess lb[2*la+1]
>>>PDG&22 0->2 0->3 0->5 0->8 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 2->15 3->11 3->14 4->1 4->1 5->8 6->1 6->1 7->1 7->1 8->1 8->1 9->1 9->4 9->18 10->1 10->1 10->6 10->6 11->1 11->1 11->7 11->7 12->1 12->4 12->4 12->9 12->9 13->1 13->10 13->10 13->11 13->14 13->19 13->20 13->21 14->1 14->10 14->10 14->11 15->1 15->1 15->11 15->12 15->12 15->12 15->13 15->13 15->14 16->1 17->1 17->15 17->15 18->16 18->20 20->16 20->19 20->19
>>>Token lg lj ( lh le , lh lf ) { lg la ; ld ( la = li ( lb , lk * 2 , le ) < 0 )  lc - 1 ; ld ( le == lb [ 2 * la ] && lf == lb [ 2 * la + 1 ] )  lc la ; ld ( lf == lb [ 2 * la ] )  lc la ; lc - 1 ; }
>>>Func
METHOD li
METHOD_RETURN lq
PARAM ln lc
PARAM lm lg
PARAM lh le
PARAM lh ld
<operator>.lessThan la<lg
<operator>.postIncrement la++
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 3->6 4->1 5->1 6->1 6->1 6->7 7->1 7->1
>>>Token lq li ( ln lc , lm lg , lh le , lh ld ) { lh la ; lo ( la = 0  ; la < lg ; la ++ ) lb ( lr ( lc , le , la ) && lj [ la ] == -1 ) { lj [ la ] = le ; lb ( la == ld )  lf lk ; lp lb ( li ( lc , lg , la , ld ) )  lf lk ; } lf ll ; }
>>>Func
