METHOD XRTB
METHOD_RETURN int
WMVOD WMVOD ( "%d" , & S )
WMVOD WMVOD ( "%d" , & N )
memset memset ( GNVP   0   sizeof ( GNVP ) )
<operator>.assignment BUYC = N + 1
RETURN return BUYC ; return BUYC ;
<operator>.lessThan i < S
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan j < S
<operator>.postIncrement j ++
<operator>.assignment GNVP [ 0 ] [ j ] = 0
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan j < S
<operator>.postIncrement j ++
IDENTIFIER BUYC return BUYC ;
<operator>.assignment i = 0
<operator>.assignment EKGUVUHUSYOW [ i ] = CJVGSQKBFKHKNKHA ( )
<operator>.assignment i = 0
<operator>.assignment JXFNIOIHJ [ i ] = CJVGSQKBFKHKNKHA ( )
<operator>.assignment RCERSBT [ i ] = DYBXQNBVAI ( & JXFNIOIHJ [ i ] )
<operator>.assignment j = 0
<operator>.assignment i = 1
<operator>.addition N + 1
<operator>.assignment j = 0
<operator>.lessThan j < S
<operator>.postIncrement j ++
<operator>.equals j == RCERSBT [ N - 1 ]
DYBXQNBVAI DYBXQNBVAI ( & JXFNIOIHJ [ i ] )
<operator>.assignment j = 0
<operator>.assignment BUYC = QFO ( BUYC , GNVP [ N - 1 ] [ j ] + 1 )
<operator>.equals RCERSBT [ i - 1 ] == j
<operator>.assignment BUYC = QFO ( BUYC , GNVP [ N - 1 ] [ j ] )
<operator>.assignment GNVP [ i ] [ j ] = N + 1
<operator>.subtraction N - 1
QFO QFO ( BUYC , GNVP [ N - 1 ] [ j ] + 1 )
<operator>.lessThan k < S
<operator>.postIncrement k ++
<operator>.assignment GNVP [ i ] [ j ] = GNVP [ i - 1 ] [ j ]
<operator>.addition GNVP [ N - 1 ] [ j ] + 1
QFO QFO ( BUYC , GNVP [ N - 1 ] [ j ] )
<operator>.subtraction i - 1
<operator>.addition N + 1
<operator>.assignment k = 0
<operator>.notEquals k != j
<operator>.lessThan k < S
<operator>.postIncrement k ++
<operator>.assignment GNVP [ i ] [ j ] = QFO ( GNVP [ i ] [ j ] , GNVP [ i - 1 ] [ k ] + 1 )
<operator>.assignment k = 0
<operator>.notEquals k != j
<operator>.assignment GNVP [ i ] [ j ] = QFO ( GNVP [ i ] [ j ] , GNVP [ i - 1 ] [ k ] + 1 )
<operator>.subtraction N - 1
<operator>.subtraction N - 1
QFO QFO ( GNVP [ i ] [ j ] , GNVP [ i - 1 ] [ k ] + 1 )
<operator>.subtraction i - 1
<operator>.addition GNVP [ i - 1 ] [ k ] + 1
QFO QFO ( GNVP [ i ] [ j ] , GNVP [ i - 1 ] [ k ] + 1 )
<operator>.addition GNVP [ i - 1 ] [ k ] + 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.indirectIndexAccess GNVP [ 0 ] [ j ]
<operator>.indirectIndexAccess EKGUVUHUSYOW [ i ]
CJVGSQKBFKHKNKHA CJVGSQKBFKHKNKHA ( )
<operator>.indirectIndexAccess JXFNIOIHJ [ i ]
CJVGSQKBFKHKNKHA CJVGSQKBFKHKNKHA ( )
<operator>.indirectIndexAccess RCERSBT [ i ]
<operator>.indirectIndexAccess GNVP [ 0 ]
<operator>.addressOf & JXFNIOIHJ [ i ]
<operator>.indirectIndexAccess RCERSBT [ N - 1 ]
<operator>.indirectIndexAccess JXFNIOIHJ [ i ]
<operator>.indirectIndexAccess RCERSBT [ i - 1 ]
<operator>.indirectIndexAccess GNVP [ i ] [ j ]
<operator>.indirectIndexAccess GNVP [ N - 1 ] [ j ]
<operator>.indirectIndexAccess GNVP [ N - 1 ] [ j ]
<operator>.indirectIndexAccess GNVP [ i ]
<operator>.indirectIndexAccess GNVP [ i ] [ j ]
<operator>.indirectIndexAccess GNVP [ i - 1 ] [ j ]
<operator>.indirectIndexAccess GNVP [ N - 1 ]
<operator>.indirectIndexAccess GNVP [ N - 1 ]
<operator>.indirectIndexAccess GNVP [ i ]
<operator>.indirectIndexAccess GNVP [ i - 1 ]
<operator>.indirectIndexAccess GNVP [ i ] [ j ]
<operator>.indirectIndexAccess GNVP [ i ]
<operator>.indirectIndexAccess GNVP [ i ] [ j ]
<operator>.indirectIndexAccess GNVP [ i ] [ j ]
<operator>.indirectIndexAccess GNVP [ i ]
<operator>.indirectIndexAccess GNVP [ i - 1 ] [ k ]
<operator>.indirectIndexAccess GNVP [ i ]
<operator>.indirectIndexAccess GNVP [ i ] [ j ]
<operator>.indirectIndexAccess GNVP [ i - 1 ]
<operator>.indirectIndexAccess GNVP [ i ]
<operator>.indirectIndexAccess GNVP [ i - 1 ] [ k ]
<operator>.indirectIndexAccess GNVP [ i - 1 ]
>>>PDG&96 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->34 0->36 0->37 0->38 0->39 0->40 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->52 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 2->1 2->1 2->7 2->11 2->16 2->28 2->39 2->48 3->1 3->1 3->5 3->9 3->14 3->26 3->36 3->37 3->45 3->54 3->55 4->1 4->1 5->1 5->1 5->1 5->18 5->38 5->43 6->1 7->1 7->7 7->8 7->8 7->11 7->20 7->64 7->65 8->1 8->7 9->9 9->10 9->10 9->14 9->22 9->23 9->31 9->66 9->67 9->68 9->70 9->72 10->1 10->9 11->11 11->12 11->12 11->13 11->16 11->28 11->63 11->69 12->1 12->11 13->1 13->1 14->1 14->1 14->5 14->14 14->15 14->15 14->26 14->28 14->32 14->36 14->37 14->44 14->45 15->1 15->14 16->1 16->1 16->1 16->16 16->17 16->30 16->30 16->37 16->71 17->1 17->16 18->6 19->7 20->1 20->1 20->1 21->1 21->9 22->1 22->1 22->1 22->31 23->1 23->1 23->1 24->11 25->1 25->14 26->1 27->1 27->16 28->16 28->28 28->29 28->34 28->34 28->39 28->44 28->48 28->73 29->1 29->28 30->1 30->1 30->17 30->33 30->35 30->38 30->42 30->43 30->54 30->55 30->75 30->76 30->80 30->81 31->1 31->23 32->28 33->1 33->1 33->1 33->18 33->38 33->43 34->1 34->1 34->29 34->36 34->39 34->41 34->45 34->46 34->47 34->48 34->51 34->52 34->57 34->74 34->77 34->78 34->79 34->82 34->83 35->1 35->1 35->1 35->18 35->38 35->43 36->1 36->1 36->56 37->54 37->55 38->1 38->33 38->33 39->1 39->1 39->28 39->39 39->40 39->47 39->47 40->1 40->39 41->1 41->1 41->1 41->59 42->1 43->1 43->35 43->35 43->38 43->42 44->15 44->57 44->61 46->1 46->39 47->1 47->29 47->40 47->50 47->56 47->58 47->61 47->84 47->85 47->86 47->88 47->89 47->92 48->1 48->1 48->28 48->48 48->49 48->52 48->52 49->1 49->48 50->1 50->1 50->1 50->56 51->1 51->48 52->1 52->29 52->49 52->53 52->59 52->60 52->62 52->87 52->90 52->91 52->93 52->94 52->95 53->1 53->1 53->1 53->59 54->1 54->37 55->1 55->37 56->1 56->50 56->50 57->15 57->44 57->62 58->1 59->1 59->53 59->53 60->1 61->15 61->44 62->15 62->44
>>>Token int XRTB ( ) { int BUYC ; JSDFMXGEBB en ; int i , j , k ; WMVOD ( " " , & S ) ; for ( i = 0 ; i < S ; i ++ ) { EKGUVUHUSYOW [ i ] = CJVGSQKBFKHKNKHA ( ) ; } WMVOD ( " " , & N ) ; for ( i = 0 ; i < N ; i ++ ) { JXFNIOIHJ [ i ] = CJVGSQKBFKHKNKHA ( ) ; RCERSBT [ i ] = DYBXQNBVAI ( & JXFNIOIHJ [ i ] ) ; } memset ( GNVP , 0 , sizeof ( GNVP ) ) ; for ( j = 0 ; j < S ; j ++ ) GNVP [ 0 ] [ j ] = 0 ; for ( i = 1 ; i < N ; i ++ ) { for ( j = 0 ; j < S ; j ++ ) { if ( RCERSBT [ i - 1 ] == j ) { GNVP [ i ] [ j ] = N + 1 ; for ( k = 0 ; k < S ; k ++ ) if ( k != j ) { GNVP [ i ] [ j ] = QFO ( GNVP [ i ] [ j ] , GNVP [ i - 1 ] [ k ] + 1 ) ; } } else { GNVP [ i ] [ j ] = GNVP [ i - 1 ] [ j ] ; for ( k = 0 ; k < S ; k ++ ) if ( k != j ) { GNVP [ i ] [ j ] = QFO ( GNVP [ i ] [ j ] , GNVP [ i - 1 ] [ k ] + 1 ) ; } } } } BUYC = N + 1 ; for ( j = 0 ; j < S ; j ++ ) { if ( j == RCERSBT [ N - 1 ] ) BUYC = QFO ( BUYC , GNVP [ N - 1 ] [ j ] + 1 ) ; else BUYC = QFO ( BUYC , GNVP [ N - 1 ] [ j ] ) ; } return BUYC ; }
>>>Func
METHOD JBTJKNHWWBFYEGLHIF
METHOD_RETURN int
PARAM int IKE [ ]
PARAM int x
PARAM int n
<operator>.assignment KVELITG = 0
<operator>.assignment JVBSWWC = 1
<operator>.assignment HMLH = KVELITG + JVBSWWC
<operator>.assignment JOMKTV = - 1
RETURN return - 1 ; return - 1 ;
<operator>.lessThan HMLH < n
<operator>.greaterThan HMLH > 1
<operator>.logicalAnd JVBSWWC && IKE [ JOMKTV + 1 ] == x
<operator>.minus - 1
<operator>.addition KVELITG + JVBSWWC
<operator>.assignment KVELITG = JVBSWWC
<operator>.assignment JVBSWWC = HMLH
<operator>.assignment HMLH = KVELITG + JVBSWWC
<operator>.minus - 1
<operator>.assignment i = ( ( JOMKTV + KVELITG ) < ( n - 1 ) ) ? ( JOMKTV + KVELITG ) : ( n - 1 )
RETURN return JOMKTV + 1 ; return JOMKTV + 1 ;
<operator>.lessThan IKE [ i ] < x
<operator>.equals IKE [ JOMKTV + 1 ] == x
<operator>.addition JOMKTV + 1
<operator>.addition KVELITG + JVBSWWC
<operator>.conditional ( ( JOMKTV + KVELITG ) < ( n - 1 ) ) ? ( JOMKTV + KVELITG ) : ( n - 1 )
<operator>.assignment HMLH = JVBSWWC
<operator>.assignment JVBSWWC = KVELITG
<operator>.assignment KVELITG = HMLH - JVBSWWC
<operator>.assignment JOMKTV = i
<operator>.lessThan ( JOMKTV + KVELITG ) < ( n - 1 )
<operator>.addition JOMKTV + KVELITG
<operator>.subtraction n - 1
<operator>.addition JOMKTV + 1
<operator>.addition JOMKTV + KVELITG
<operator>.subtraction n - 1
<operator>.subtraction HMLH - JVBSWWC
<operator>.greaterThan IKE [ i ] > x
<operator>.assignment HMLH = KVELITG
<operator>.assignment JVBSWWC = JVBSWWC - KVELITG
<operator>.assignment KVELITG = HMLH - JVBSWWC
RETURN return i ; return i ;
<operator>.subtraction JVBSWWC - KVELITG
<operator>.subtraction HMLH - JVBSWWC
IDENTIFIER i return i ;
<operator>.indirectIndexAccess IKE [ JOMKTV + 1 ]
<operator>.indirectIndexAccess IKE [ i ]
<operator>.indirectIndexAccess IKE [ i ]
>>>PDG&48 0->2 0->3 0->4 0->5 0->6 0->7 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->42 0->43 0->44 2->1 2->21 2->22 2->37 3->21 3->22 4->10 5->1 5->7 5->14 5->19 5->25 5->27 5->30 5->31 5->34 5->38 5->42 6->1 6->7 6->12 6->14 6->15 6->26 6->42 7->1 7->1 7->10 8->1 8->1 8->19 8->23 8->25 8->30 8->31 8->33 8->34 9->1 10->1 10->10 10->11 10->15 10->16 10->16 10->17 10->24 10->35 11->1 11->1 11->12 11->19 11->21 11->22 11->25 11->30 11->33 11->34 11->35 11->45 11->46 12->9 12->13 12->20 12->23 13->9 14->1 15->1 15->17 15->19 15->24 15->25 15->27 15->30 15->31 15->34 15->38 15->42 16->1 16->12 16->15 16->17 16->24 16->26 16->42 17->1 17->1 17->10 18->8 19->1 19->1 19->1 19->29 19->44 20->1 21->1 21->11 21->22 21->26 21->27 21->28 21->29 21->36 21->37 21->37 21->37 21->47 22->12 22->12 23->20 24->1 25->1 25->1 25->1 26->1 26->36 27->1 27->36 28->1 28->1 28->19 28->25 28->27 28->30 28->31 28->34 28->38 28->42 29->1 29->19 29->23 29->25 29->30 29->31 29->33 29->34 30->19 30->19 30->25 30->25 30->31 30->32 31->1 31->1 32->1 32->19 32->19 32->25 32->25 32->35 34->1 34->1 35->1 35->30 35->30 35->32 36->1 36->11 36->12 36->26 36->28 36->28 36->42 37->1 37->1 37->1 37->11 37->21 37->21 37->22 37->38 37->39 37->40 37->41 37->42 37->43 38->1 38->43 39->1 39->1 39->43 40->1 40->1 40->19 40->25 40->27 40->30 40->31 40->34 40->38 40->42 41->1 42->39 42->39 43->1 43->11 43->12 43->26 43->40 43->40 43->42 44->41
>>>Token int JBTJKNHWWBFYEGLHIF ( int IKE [ ] , int x , int n ) { int KVELITG = 0 ; int JVBSWWC = 1 ; int HMLH = KVELITG + JVBSWWC ; while ( HMLH < n ) { KVELITG = JVBSWWC ; JVBSWWC = HMLH ; HMLH = KVELITG + JVBSWWC ; } int JOMKTV = - 1 ; while ( HMLH > 1 ) { int i = ( ( JOMKTV + KVELITG ) < ( n - 1 ) ) ? ( JOMKTV + KVELITG ) : ( n - 1 ) ; if ( IKE [ i ] < x ) { HMLH = JVBSWWC ; JVBSWWC = KVELITG ; KVELITG = HMLH - JVBSWWC ; JOMKTV = i ; } else if ( IKE [ i ] > x ) { HMLH = KVELITG ; JVBSWWC = JVBSWWC - KVELITG ; KVELITG = HMLH - JVBSWWC ; } else return i ; } if ( JVBSWWC && IKE [ JOMKTV + 1 ] == x ) return JOMKTV + 1 ; return - 1 ; }
>>>Func
METHOD ELAAXUPIJJL
METHOD_RETURN int
PARAM L JXIH
RETURN return n ; return n ;
IDENTIFIER JXIH for (n = 0 ;JXIH;JXIH = JXIH -> LOOB)
<operator>.assignment JXIH = JXIH -> LOOB
<operator>.postIncrement n ++
IDENTIFIER n return n ;
<operator>.assignment n = 0
>>>PDG&9 0->2 0->4 0->6 0->7 0->8 2->1 3->1 5->1 5->1 5->1 6->1 6->1 6->7 7->3 8->1 8->1 8->6 8->7
>>>Token int ELAAXUPIJJL ( L JXIH ) { int n ; for ( n = 0 ; JXIH ; JXIH = JXIH -> LOOB ) n ++ ; return n ; }
>>>Func
METHOD PTWW
METHOD_RETURN void
<operator>.assignment IYDNVBVAF [ ] = { }
assert assert ( EUTXDQSNFBLXXIUYLT ( IYDNVBVAF , 0 , 10 ) == - 1 )
<operator>.assignment XVNBHPEUL [ ] = { 1   2   3 }
assert assert ( EUTXDQSNFBLXXIUYLT ( XVNBHPEUL , 3 , 10 ) == - 1 )
<operator>.assignment HSNMYIH [ ] = { 1 }
assert assert ( EUTXDQSNFBLXXIUYLT ( XVNBHPEUL , 1 , 1 ) == 0 )
<operator>.assignment WNXRBGVMETW [ ] = { 1   2 }
assert assert ( EUTXDQSNFBLXXIUYLT ( WNXRBGVMETW , 2 , 1 ) == 0 )
<operator>.assignment BSIWRHKUOA [ ] = { 1   2 }
assert assert ( EUTXDQSNFBLXXIUYLT ( BSIWRHKUOA , 2 , 2 ) == 1 )
<operator>.assignment YLNIEBUFLCE [ ] = { - 1   2   4   6   8 }
assert assert ( EUTXDQSNFBLXXIUYLT ( YLNIEBUFLCE , 5 , - 1 ) == 0 )
<operator>.assignment YDVALTMPNK [ ] = { - 1   2   4   6   8 }
assert assert ( EUTXDQSNFBLXXIUYLT ( YDVALTMPNK , 5 , 8 ) == 4 )
<operator>.assignment QJSNDAXAQB [ ] = { - 1   2   4   6   8 }
assert assert ( EUTXDQSNFBLXXIUYLT ( QJSNDAXAQB , 5 , 6 ) == 3 )
<operator>.equals EUTXDQSNFBLXXIUYLT ( IYDNVBVAF , 0 , 10 ) == - 1
<operator>.arrayInitializer { 1   2   3 }
<operator>.equals EUTXDQSNFBLXXIUYLT ( XVNBHPEUL , 3 , 10 ) == - 1
<operator>.arrayInitializer { 1 }
<operator>.equals EUTXDQSNFBLXXIUYLT ( XVNBHPEUL , 1 , 1 ) == 0
<operator>.arrayInitializer { 1   2 }
<operator>.equals EUTXDQSNFBLXXIUYLT ( WNXRBGVMETW , 2 , 1 ) == 0
<operator>.arrayInitializer { 1   2 }
<operator>.equals EUTXDQSNFBLXXIUYLT ( BSIWRHKUOA , 2 , 2 ) == 1
<operator>.arrayInitializer { - 1   2   4   6   8 }
<operator>.equals EUTXDQSNFBLXXIUYLT ( YLNIEBUFLCE , 5 , - 1 ) == 0
<operator>.arrayInitializer { - 1   2   4   6   8 }
<operator>.equals EUTXDQSNFBLXXIUYLT ( YDVALTMPNK , 5 , 8 ) == 4
<operator>.arrayInitializer { - 1   2   4   6   8 }
<operator>.equals EUTXDQSNFBLXXIUYLT ( QJSNDAXAQB , 5 , 6 ) == 3
EUTXDQSNFBLXXIUYLT EUTXDQSNFBLXXIUYLT ( IYDNVBVAF , 0 , 10 )
<operator>.minus - 1
EUTXDQSNFBLXXIUYLT EUTXDQSNFBLXXIUYLT ( XVNBHPEUL , 3 , 10 )
<operator>.minus - 1
EUTXDQSNFBLXXIUYLT EUTXDQSNFBLXXIUYLT ( XVNBHPEUL , 1 , 1 )
EUTXDQSNFBLXXIUYLT EUTXDQSNFBLXXIUYLT ( WNXRBGVMETW , 2 , 1 )
EUTXDQSNFBLXXIUYLT EUTXDQSNFBLXXIUYLT ( BSIWRHKUOA , 2 , 2 )
<operator>.minus - 1
EUTXDQSNFBLXXIUYLT EUTXDQSNFBLXXIUYLT ( YLNIEBUFLCE , 5 , - 1 )
<operator>.minus - 1
EUTXDQSNFBLXXIUYLT EUTXDQSNFBLXXIUYLT ( YDVALTMPNK , 5 , 8 )
<operator>.minus - 1
EUTXDQSNFBLXXIUYLT EUTXDQSNFBLXXIUYLT ( QJSNDAXAQB , 5 , 6 )
<operator>.minus - 1
>>>PDG&47 0->2 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 2->1 2->1 2->33 3->1 3->1 4->1 4->1 4->35 5->1 5->1 6->1 6->1 6->1 7->1 7->1 8->1 8->38 9->1 9->1 10->1 10->1 10->39 11->1 11->1 12->1 12->41 13->1 13->1 14->1 14->43 15->1 15->1 16->1 16->1 16->45 17->1 17->1 18->1 18->3 18->3 19->4 19->4 19->4 20->1 20->5 20->5 21->6 22->1 22->7 22->7 23->8 23->8 24->1 24->9 24->9 25->10 25->10 26->1 26->11 26->11 27->12 27->12 27->12 27->12 27->12 28->1 28->13 28->13 29->14 29->14 29->14 29->14 29->14 30->1 30->15 30->15 31->1 31->16 31->16 31->16 31->16 31->16 32->1 32->17 32->17 33->1 33->18 33->18 33->18 34->18 35->20 35->20 35->20 35->37 36->20 37->1 37->22 37->22 38->1 38->24 38->24 38->24 39->1 39->26 39->26 40->27 41->1 41->28 41->28 41->28 42->29 43->1 43->30 43->30 43->30 44->31 45->1 45->32 45->32 45->32 46->41
>>>Token static void PTWW ( ) { YAYYKRC IYDNVBVAF [ ] = { } ; assert ( EUTXDQSNFBLXXIUYLT ( IYDNVBVAF , 0 , 10 ) == - 1 ) ; YAYYKRC XVNBHPEUL [ ] = { 1 , 2 , 3 } ; assert ( EUTXDQSNFBLXXIUYLT ( XVNBHPEUL , 3 , 10 ) == - 1 ) ; YAYYKRC HSNMYIH [ ] = { 1 } ; assert ( EUTXDQSNFBLXXIUYLT ( XVNBHPEUL , 1 , 1 ) == 0 ) ; YAYYKRC WNXRBGVMETW [ ] = { 1 , 2 } ; assert ( EUTXDQSNFBLXXIUYLT ( WNXRBGVMETW , 2 , 1 ) == 0 ) ; YAYYKRC BSIWRHKUOA [ ] = { 1 , 2 } ; assert ( EUTXDQSNFBLXXIUYLT ( BSIWRHKUOA , 2 , 2 ) == 1 ) ; YAYYKRC YLNIEBUFLCE [ ] = { - 1 , 2 , 4 , 6 , 8 } ; assert ( EUTXDQSNFBLXXIUYLT ( YLNIEBUFLCE , 5 , - 1 ) == 0 ) ; YAYYKRC YDVALTMPNK [ ] = { - 1 , 2 , 4 , 6 , 8 } ; assert ( EUTXDQSNFBLXXIUYLT ( YDVALTMPNK , 5 , 8 ) == 4 ) ; YAYYKRC QJSNDAXAQB [ ] = { - 1 , 2 , 4 , 6 , 8 } ; assert ( EUTXDQSNFBLXXIUYLT ( QJSNDAXAQB , 5 , 6 ) == 3 ) ; }
>>>Func
METHOD QCHAFTIAEQMWHW
METHOD_RETURN double
PARAM SAFXIPE OQWTUCE
PARAM SAFXIPE DJRTL
RETURN return ( double ) ( DJRTL - OQWTUCE ) / ( double ) BWSUFSYVIYFFTF ; return ( double ) ( DJRTL - OQWTUCE ) / ( double ) BWSUFSYVIYFFTF ;
<operator>.division ( double ) ( DJRTL - OQWTUCE ) / ( double ) BWSUFSYVIYFFTF
<operator>.cast ( double ) ( DJRTL - OQWTUCE )
<operator>.cast ( double ) BWSUFSYVIYFFTF
<operator>.subtraction DJRTL - OQWTUCE
>>>PDG&9 0->2 0->3 0->5 0->7 0->8 2->8 3->8 4->1 5->1 5->1 5->1 5->4 6->1 7->1 8->1 8->1 8->5 8->5 8->6 8->6
>>>Token double QCHAFTIAEQMWHW ( SAFXIPE OQWTUCE , SAFXIPE DJRTL ) { return ( double ) ( DJRTL - OQWTUCE ) / ( double ) BWSUFSYVIYFFTF ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment * c = argv [ 1 ]
<operator>.assignment DEOWA = RPACB ( "program.txt" , "w" )
srand srand ( ( unsigned ) time ( & t ) )
fprintf fprintf ( DEOWA , "%s" , c )
MUXDVS MUXDVS ( DEOWA )
<operator>.assignment CXLKR = RPACB ( "program.txt" , "r" )
printf printf ( "\n" )
MUXDVS MUXDVS ( CXLKR )
RETURN return 0 ; return 0 ;
<operator>.lessThan argc < 2
<operator>.equals DEOWA == NULL
<operator>.equals CXLKR == NULL
<operator>.notEquals ( ch = BAJTC ( CXLKR ) ) != HIM
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
RPACB RPACB ( "program.txt" , "w" )
printf printf ( "Error!" )
exit exit ( 1 )
<operator>.cast ( unsigned ) time ( & t )
RPACB RPACB ( "program.txt" , "r" )
printf printf ( "Error!" )
exit exit ( 1 )
printf printf ( "%c" , ch )
LITERAL 1 return 1 ;
time time ( & t )
<operator>.assignment ch = BAJTC ( CXLKR )
BAJTC BAJTC ( CXLKR )
<operator>.indirectIndexAccess argv [ 1 ]
UNKNOWN unsigned unsigned
<operator>.addressOf & t
>>>PDG&34 0->2 0->3 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->30 2->13 3->1 3->4 4->7 5->14 7->8 9->15 12->1 13->1 13->1 13->4 13->5 13->6 13->7 13->8 13->9 13->10 13->11 13->12 13->14 13->15 13->16 13->18 13->19 13->22 13->23 13->28 13->29 13->30 13->31 13->32 13->33 14->7 14->15 14->20 14->21 15->24 15->25 15->30 16->1 16->16 16->26 16->29 16->30 17->12 18->1 19->5 19->5 23->9 23->9 27->18 28->6 28->22 29->16 29->26 30->11 30->16 30->29
>>>Token int main ( int argc , char * argv [ ] ) { if ( argc < 2 ) return 1 ; char * c = argv [ 1 ] ; WCOQ * CXLKR , * DEOWA ; DEOWA = RPACB ( " " , " " ) ; if ( DEOWA == NULL ) { printf ( " " ) ; exit ( 1 ) ; } OKQDMM t ; srand ( ( unsigned ) time ( & t ) ) ; fprintf ( DEOWA , " " , c ) ; MUXDVS ( DEOWA ) ; CXLKR = RPACB ( " " , " " ) ; if ( CXLKR == NULL ) { printf ( " " ) ; exit ( 1 ) ; } char ch ; while ( ( ch = BAJTC ( CXLKR ) ) != HIM ) { printf ( " " , ch ) ; } printf ( " \n " ) ; MUXDVS ( CXLKR ) ; return 0 ; }
>>>Func
METHOD YMRF
METHOD_RETURN bool
PARAM POGDPJ a
PARAM POGDPJ b
<operator>.expressionList YBQUPG < POGDPJ > FWOG   XMRM
NXRHYKRXXMD NXRHYKRXXMD ( a , " " , FWOG )
NXRHYKRXXMD NXRHYKRXXMD ( b , " " , XMRM )
<operator>.equals FWOG [ 0 ] . PBMTSXU ( XMRM [ 0 ] ) == - 1
<operator>.greaterThan YBQUPG < POGDPJ > FWOG
RETURN return true ; return true ;
<operator>.lessThan YBQUPG < POGDPJ
PBMTSXU FWOG [ 0 ] . PBMTSXU ( XMRM [ 0 ] )
<operator>.minus - 1
IDENTIFIER true return true ;
RETURN return false ; return false ;
IDENTIFIER false return false ;
>>>PDG&16 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->12 0->13 0->14 0->15 2->5 3->6 4->1 4->1 4->6 5->1 5->1 5->1 6->1 6->1 6->1 6->11 7->1 7->1 7->1 7->9 7->14 8->1 8->4 8->4 8->5 9->1 10->1 10->1 10->8 10->8 11->1 11->1 11->7 11->7 12->7 13->9 14->1 15->14
>>>Token bool YMRF ( POGDPJ a , POGDPJ b ) { YBQUPG < POGDPJ > FWOG , XMRM ; NXRHYKRXXMD ( a , " " , FWOG ) ; NXRHYKRXXMD ( b , " " , XMRM ) ; if ( FWOG [ 0 ] . PBMTSXU ( XMRM [ 0 ] ) == - 1 ) return true ; else return false ; }
>>>Func
METHOD main
METHOD_RETURN int
SIXA SIXA ( s )
EPVIKR EPVIKR ( s , "%d" , & ITMLC )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan N <= ITMLC
<operator>.postIncrement N ++
LITERAL 0 return 0 ;
<operator>.assignment N = 1
SIXA SIXA ( s )
EPVIKR EPVIKR ( s , "%d" , & ANHQIA )
SIXA SIXA ( s )
EPVIKR EPVIKR ( s , "%d" , & TPKML )
<operator>.assignment p = 0
<operator>.assignment HHU = 0
printf printf ( "Case #%d: %d\n" , N , HHU )
<operator>.lessThan i < ANHQIA
<operator>.postIncrement i ++
SIXA SIXA ( JCGU [ i ] )
<operator>.lessThan i < TPKML
<operator>.postIncrement i ++
SIXA SIXA ( q [ i ] )
LITERAL 1 while (1)
<operator>.assignment i = 0
<operator>.assignment i = 0
memset memset ( HHBX   0   sizeof ( HHBX ) )
<operator>.assignment DJKX = ANHQIA
<operator>.postIncrement HHU ++
<operator>.assignment p = i
<operator>.lessThan i < TPKML
<operator>.postIncrement i ++
<operator>.equals i == TPKML
<operator>.assignment i = p
<operator>.assignment TEM = FIMS ( q [ i ] )
<operator>.logicalNot ! HHBX [ TEM ]
<operator>.equals DJKX == 0
FIMS FIMS ( q [ i ] )
<operator>.assignment HHBX [ TEM ] = 1
<operator>.postDecrement DJKX --
<operator>.addressOf & ANHQIA
<operator>.addressOf & TPKML
<operator>.indirectIndexAccess JCGU [ i ]
<operator>.indirectIndexAccess q [ i ]
<operator>.sizeOf sizeof ( HHBX )
<operator>.indirectIndexAccess q [ i ]
<operator>.indirectIndexAccess HHBX [ TEM ]
<operator>.indirectIndexAccess HHBX [ TEM ]
>>>PDG&47 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->35 0->37 0->38 2->1 2->3 3->1 3->1 3->1 3->5 3->9 4->1 5->1 5->1 5->1 5->5 5->6 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->15 5->16 5->19 5->23 5->24 5->25 5->26 5->29 5->31 5->32 5->39 5->40 5->43 6->1 6->5 7->4 8->1 8->5 9->10 10->1 10->1 10->11 10->16 10->26 11->1 11->12 12->1 12->1 12->1 12->9 12->19 12->29 12->31 13->1 13->1 13->32 14->1 14->15 14->27 15->1 15->1 15->6 16->1 16->1 16->10 16->16 16->17 16->17 16->18 16->26 16->41 17->1 17->16 18->1 18->1 19->1 19->1 19->1 19->12 19->19 19->20 19->20 19->21 19->29 19->42 20->1 20->19 21->1 21->1 21->36 23->16 24->1 24->19 25->1 25->1 25->34 26->1 26->1 26->1 26->35 26->38 27->1 27->15 28->1 28->1 28->1 28->32 29->1 29->30 29->31 29->31 29->33 29->34 29->35 29->36 29->44 29->45 30->1 30->29 31->1 31->1 31->1 31->12 31->19 31->25 31->26 31->27 31->28 31->28 31->29 31->29 31->31 31->32 31->43 32->1 32->1 32->29 33->1 33->1 33->1 34->1 34->1 34->25 34->37 34->38 34->46 35->1 35->1 35->29 35->30 35->38 36->1 36->21 36->33 37->1 37->1 37->25 37->34 38->1 38->35
>>>Token int main ( ) { SIXA ( s ) ; EPVIKR ( s , " " , & ITMLC ) ; for ( N = 1 ; N <= ITMLC ; N ++ ) { SIXA ( s ) ; EPVIKR ( s , " " , & ANHQIA ) ; for ( i = 0 ; i < ANHQIA ; i ++ ) SIXA ( JCGU [ i ] ) ; SIXA ( s ) ; EPVIKR ( s , " " , & TPKML ) ; for ( i = 0 ; i < TPKML ; i ++ ) SIXA ( q [ i ] ) ; p = 0 ; HHU = 0 ; while ( 1 ) { memset ( HHBX , 0 , sizeof ( HHBX ) ) ; DJKX = ANHQIA ; for ( i = p ; i < TPKML ; i ++ ) { TEM = FIMS ( q [ i ] ) ; if ( ! HHBX [ TEM ] ) { HHBX [ TEM ] = 1 ; DJKX -- ; } if ( DJKX == 0 ) break ; } if ( i == TPKML ) break ; HHU ++ ; p = i ; } printf ( " \n " , N , HHU ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
LTHLCWGPSN LTHLCWGPSN ( argv [ 1 ] )
<operator>.notEquals 2 != argc
printf printf ( "Program expects input file as argument.\n" )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.indirectIndexAccess argv [ 1 ]
>>>PDG&10 0->2 0->3 0->5 0->6 0->7 0->8 2->5 3->1 3->4 5->1 5->1 5->4 5->6 5->7 5->9 6->1 7->1 8->7
>>>Token int main ( int argc , char * argv [ ] ) { if ( 2 != argc ) { printf ( " \n " ) ; return 0 ; } int TDCFWARYIRD ; LTHLCWGPSN ( argv [ 1 ] ) ; }
>>>Func
METHOD JBTJKNHWW
METHOD_RETURN int
PARAM int BFYEGLHIFI
PARAM char const * KEKV
PARAM int ELITG
PARAM JVBSWW CHML
<operator>.assignment fd = open ( KEKV , ELITG , CHML )
<operator>.logicalOr fd == BFYEGLHIFI || fd < 0
open open ( KEKV , ELITG , CHML )
RETURN return fd ; return fd ;
<operator>.equals fd == BFYEGLHIFI
<operator>.lessThan fd < 0
IDENTIFIER fd return fd ;
<operator>.assignment HJO = MKTV ( fd , BFYEGLHIFI )
<operator>.assignment VDGCNRIBPNM = XJSHF
close close ( fd )
<operator>.assignment XJSHF = VDGCNRIBPNM
RETURN return HJO ; return HJO ;
IDENTIFIER HJO return HJO ;
MKTV MKTV ( fd , BFYEGLHIFI )
>>>PDG&20 0->2 0->3 0->4 0->5 0->8 0->10 0->11 0->12 0->14 0->15 0->16 0->18 0->19 2->10 3->8 4->8 5->8 6->1 6->1 6->10 7->1 7->1 7->1 7->9 7->13 7->14 7->15 7->16 7->17 7->19 8->1 8->1 8->1 8->6 8->6 8->6 9->1 10->1 10->1 10->7 10->7 10->11 10->11 10->12 10->19 10->19 11->1 11->7 11->7 11->12 11->19 12->9 13->18 14->16 17->1 18->17 19->13 19->13 19->15
>>>Token int JBTJKNHWW ( int BFYEGLHIFI , char const * KEKV , int ELITG , JVBSWW CHML ) { int fd = open ( KEKV , ELITG , CHML ) ; if ( fd == BFYEGLHIFI || fd < 0 ) return fd ; else { int HJO = MKTV ( fd , BFYEGLHIFI ) ; int VDGCNRIBPNM = XJSHF ; close ( fd ) ; XJSHF = VDGCNRIBPNM ; return HJO ; } }
>>>Func
METHOD AXRCGEIVRT
METHOD_RETURN int
PARAM int S
PARAM char * q
RETURN return 0 ; return 0 ;
<operator>.lessThan i < S
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.logicalNot ! strcmp ( HSUFCQJ [ i ] , q )
<operator>.assignment FSNO [ i ] = 1
strcmp strcmp ( HSUFCQJ [ i ] , q )
<operator>.equals FSNO [ i ] == 0
<operator>.equals ++ WAFHHUM == S
RETURN return 1 ; return 1 ;
<operator>.preIncrement ++ WAFHHUM
LITERAL 1 return 1 ;
<operator>.indirectIndexAccess HSUFCQJ [ i ]
<operator>.indirectIndexAccess FSNO [ i ]
<operator>.indirectIndexAccess FSNO [ i ]
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 2->5 3->11 4->1 5->1 5->1 5->4 5->6 5->9 5->11 5->13 5->17 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->5 9->6 9->12 9->19 11->1 11->1 11->9 11->9 12->1 12->1 12->4 12->10 12->13 12->15 12->18 13->1 13->1 13->1 13->4 13->10 13->14 13->18 14->1 15->1 15->13 16->14
>>>Token int AXRCGEIVRT ( int S , char * q ) { int i ; for ( i = 0 ; i < S ; i ++ ) { if ( ! strcmp ( HSUFCQJ [ i ] , q ) ) { if ( FSNO [ i ] == 0 ) { if ( ++ WAFHHUM == S ) return 1 ; } FSNO [ i ] = 1 ; break ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment OFGGKDTEOPEKY = OTNSSUOKCPOTLJUFCCVJJ
<operator>.assignment * CTOWAFOGPOULENHAETETIAI = "input.txt"
<operator>.assignment * UUPWWMIIQCYPEFF = NULL
<operator>.assignment * KWVHLAWSCBMIUXIFSFVRDKCN = "output.txt"
<operator>.assignment * BENRKUYWRUEDWBXA = NULL
<operator>.assignment YPDVNTLVXSHIJO = LDDDS ( UUPWWMIIQCYPEFF , "r" )
<operator>.assignment CYFVPGBDRVSYTRF = LDDDS ( BENRKUYWRUEDWBXA , "w" )
<operator>.assignment LKTPFV = GHDRUP ( YPDVNTLVXSHIJO , "%d" , & CNKYLTHGY )
JFJNSW JFJNSW ( YPDVNTLVXSHIJO )
JFJNSW JFJNSW ( CYFVPGBDRVSYTRF )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < argc
<operator>.postIncrement i ++
<operator>.equals UUPWWMIIQCYPEFF == NULL
<operator>.equals BENRKUYWRUEDWBXA == NULL
<operator>.equals YPDVNTLVXSHIJO == NULL
<operator>.equals YPDVNTLVXSHIJO == NULL
<operator>.greaterEqualsThan OFGGKDTEOPEKY >= 2
<operator>.lessEqualsThan DXENAUQ <= CNKYLTHGY
<operator>.postIncrement DXENAUQ ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
<operator>.assignment UUPWWMIIQCYPEFF = CTOWAFOGPOULENHAETETIAI
<operator>.assignment BENRKUYWRUEDWBXA = KWVHLAWSCBMIUXIFSFVRDKCN
LDDDS LDDDS ( UUPWWMIIQCYPEFF , "r" )
printf printf ( "Error opening input file.\n" )
RETURN return 0 ; return 0 ;
LDDDS LDDDS ( BENRKUYWRUEDWBXA , "w" )
printf printf ( "Error opening output file.\n" )
RETURN return 0 ; return 0 ;
GHDRUP GHDRUP ( YPDVNTLVXSHIJO , "%d" , & CNKYLTHGY )
printf printf ( "  Number of test cases: %d\n" , CNKYLTHGY )
<operator>.assignment DXENAUQ = 1
<operator>.assignment LKTPFV = GHDRUP ( YPDVNTLVXSHIJO , "%d" , & n )
fprintf fprintf ( CYFVPGBDRVSYTRF , "Case #%d:\n" , DXENAUQ )
<operator>.logicalAnd strcmp ( argv [ i ] , "-i" ) == 0 && i + 1 < argc
LITERAL 0 return 0 ;
LITERAL 0 return 0 ;
<operator>.greaterEqualsThan OFGGKDTEOPEKY >= 1
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.greaterEqualsThan OFGGKDTEOPEKY >= 3
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.greaterEqualsThan OFGGKDTEOPEKY >= 3
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.greaterEqualsThan OFGGKDTEOPEKY >= 3
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.greaterEqualsThan OFGGKDTEOPEKY >= 1
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.greaterEqualsThan OFGGKDTEOPEKY >= 1
<operator>.greaterEqualsThan OFGGKDTEOPEKY >= 1
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment UUPWWMIIQCYPEFF = argv [ ++ i ]
printf printf ( "  Case #%d: " , DXENAUQ )
GHDRUP GHDRUP ( YPDVNTLVXSHIJO , "%d" , & n )
<operator>.assignment i = 0
<operator>.assignment LKTPFV = GHDRUP ( YPDVNTLVXSHIJO , "%c" , & c )
printf printf ( "    input: \n" )
<operator>.assignment i = 0
<operator>.assignment KKOK = 0
<operator>.assignment QEMLVUV = 0
<operator>.assignment wp [ i ] = ( ( double ) KKOK ) / QEMLVUV
<operator>.assignment wt [ i ] = KKOK
<operator>.assignment m [ i ] = QEMLVUV
printf printf ( "    wp: " )
printf printf ( "\n" )
<operator>.assignment i = 0
<operator>.assignment GNBQFBUB [ i ] = 0
<operator>.assignment YEVFCWD [ i ] = 0
<operator>.assignmentDivision YEVFCWD [ i ] /= GNBQFBUB [ i ]
printf printf ( "    owp: \n" )
<operator>.assignment i = 0
<operator>.assignment EBQOCEIJ [ i ] = 0
<operator>.assignmentDivision EBQOCEIJ [ i ] /= GNBQFBUB [ i ]
printf printf ( "avg_oowp: " )
printf printf ( "\n" )
<operator>.assignment i = 0
<operator>.assignment GYA [ i ] = 0.25 * wp [ i ] + 0.5 * YEVFCWD [ i ] + 0.25 * EBQOCEIJ [ i ]
printf printf ( "rpi: " )
printf printf ( "\n" )
printf printf ( "\n" )
<operator>.assignment i = 0
fprintf fprintf ( CYFVPGBDRVSYTRF , "%.10f\n" , GYA [ i ] )
<operator>.equals strcmp ( argv [ i ] , "-i" ) == 0
<operator>.lessThan i + 1 < argc
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
strcmp strcmp ( argv [ i ] , "-i" )
<operator>.addition i + 1
<operator>.logicalAnd strcmp ( argv [ i ] , "-o" ) == 0 && i + 1 < argc
GHDRUP GHDRUP ( YPDVNTLVXSHIJO , "%c" , & c )
<operator>.assignment j = 0
<operator>.assignment LKTPFV = GHDRUP ( YPDVNTLVXSHIJO , "%c" , & c )
<operator>.assignment i = 0
printf printf ( "\n" )
<operator>.assignment j = 0
<operator>.division ( ( double ) KKOK ) / QEMLVUV
<operator>.assignment i = 0
printf printf ( " %0.3f" , wp [ i ] )
<operator>.assignment j = 0
<operator>.assignment i = 0
printf printf ( "  avg_owp = %0.3f, num_opps = %d\n" , YEVFCWD [ i ] , GNBQFBUB [ i ] )
<operator>.assignment j = 0
<operator>.assignment i = 0
printf printf ( " %.3f " , EBQOCEIJ [ i ] )
<operator>.addition 0.25 * wp [ i ] + 0.5 * YEVFCWD [ i ] + 0.25 * EBQOCEIJ [ i ]
<operator>.assignment i = 0
printf printf ( " %.3f " , GYA [ i ] )
<operator>.preIncrement ++ i
<operator>.assignment BENRKUYWRUEDWBXA = argv [ ++ i ]
<operator>.equals c == '.'
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.equals w [ i ] [ j ] == 1
<operator>.cast ( double ) KKOK
<operator>.equals w [ i ] [ j ] == 1
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.logicalOr ( w [ i ] [ j ] == 1 ) || ( w [ i ] [ j ] == 0 )
<operator>.addition 0.25 * wp [ i ] + 0.5 * YEVFCWD [ i ]
<operator>.multiplication 0.25 * EBQOCEIJ [ i ]
<operator>.equals strcmp ( argv [ i ] , "-o" ) == 0
<operator>.lessThan i + 1 < argc
GHDRUP GHDRUP ( YPDVNTLVXSHIJO , "%c" , & c )
<operator>.assignment w [ i ] [ j ] = - 1
<operator>.assignment j = 0
printf printf ( "\t %d" , w [ i ] [ j ] )
<operator>.postIncrement QEMLVUV ++
<operator>.postIncrement KKOK ++
<operator>.assignment KKOK = wt [ j ]
<operator>.assignment QEMLVUV = m [ j ] - 1
<operator>.postIncrement GNBQFBUB [ i ] ++
<operator>.assignment GII [ i ] [ j ] = ( ( double ) KKOK ) / QEMLVUV
<operator>.assignmentPlus YEVFCWD [ i ] += GII [ i ] [ j ]
<operator>.assignment j = 0
printf printf ( "\t %0.3f" , GII [ i ] [ j ] )
<operator>.assignment GII [ i ] [ j ] = ( ( double ) KKOK ) / QEMLVUV
<operator>.assignmentPlus EBQOCEIJ [ i ] += YEVFCWD [ j ]
<operator>.multiplication 0.25 * wp [ i ]
<operator>.multiplication 0.5 * YEVFCWD [ i ]
strcmp strcmp ( argv [ i ] , "-o" )
<operator>.addition i + 1
<operator>.equals strcmp ( argv [ i ] , "-v" ) == 0
<operator>.equals w [ i ] [ j ] == 1
<operator>.equals w [ i ] [ j ] == 0
<operator>.preIncrement ++ i
<operator>.assignment OFGGKDTEOPEKY = atoi ( argv [ ++ i ] )
<operator>.minus - 1
<operator>.equals c == '1'
<operator>.equals w [ i ] [ j ] == 0
<operator>.subtraction m [ j ] - 1
<operator>.division ( ( double ) KKOK ) / QEMLVUV
<operator>.equals w [ i ] [ j ] == 0
<operator>.division ( ( double ) KKOK ) / QEMLVUV
strcmp strcmp ( argv [ i ] , "-v" )
printf printf ( "Error parsing arguments!\n" )
printf printf ( "Usage: template.bin -i <input_file_name> -o <output_file_name>" )
printf printf ( "  -v <verbose_level>\n" )
RETURN return 0 ; return 0 ;
<operator>.assignment w [ i ] [ j ] = 1
<operator>.postIncrement QEMLVUV ++
<operator>.cast ( double ) KKOK
<operator>.assignment KKOK = wt [ j ] - 1
<operator>.assignment QEMLVUV = m [ j ] - 1
<operator>.postIncrement GNBQFBUB [ i ] ++
<operator>.assignment GII [ i ] [ j ] = ( ( double ) KKOK ) / QEMLVUV
<operator>.assignmentPlus YEVFCWD [ i ] += GII [ i ] [ j ]
<operator>.cast ( double ) KKOK
atoi atoi ( argv [ ++ i ] )
LITERAL 0 return 0 ;
<operator>.equals c == '0'
<operator>.subtraction wt [ j ] - 1
<operator>.subtraction m [ j ] - 1
<operator>.division ( ( double ) KKOK ) / QEMLVUV
<operator>.preIncrement ++ i
<operator>.assignment w [ i ] [ j ] = 0
<operator>.cast ( double ) KKOK
<operator>.addressOf & CNKYLTHGY
<operator>.addressOf & n
<operator>.indirectIndexAccess argv [ ++ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess wt [ i ]
<operator>.indirectIndexAccess m [ i ]
<operator>.indirectIndexAccess GNBQFBUB [ i ]
<operator>.indirectIndexAccess YEVFCWD [ i ]
<operator>.indirectIndexAccess YEVFCWD [ i ]
<operator>.indirectIndexAccess GNBQFBUB [ i ]
<operator>.indirectIndexAccess EBQOCEIJ [ i ]
<operator>.indirectIndexAccess EBQOCEIJ [ i ]
<operator>.indirectIndexAccess GNBQFBUB [ i ]
<operator>.indirectIndexAccess GYA [ i ]
<operator>.indirectIndexAccess GYA [ i ]
<operator>.indirectIndexAccess argv [ i ]
<operator>.addressOf & c
UNKNOWN double double
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess YEVFCWD [ i ]
<operator>.indirectIndexAccess GNBQFBUB [ i ]
<operator>.indirectIndexAccess EBQOCEIJ [ i ]
<operator>.indirectIndexAccess EBQOCEIJ [ i ]
<operator>.indirectIndexAccess GYA [ i ]
<operator>.indirectIndexAccess argv [ ++ i ]
<operator>.addressOf & c
<operator>.indirectIndexAccess w [ i ] [ j ]
<operator>.indirectIndexAccess w [ i ] [ j ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess YEVFCWD [ i ]
<operator>.indirectIndexAccess argv [ i ]
<operator>.indirectIndexAccess w [ i ] [ j ]
<operator>.indirectIndexAccess w [ i ] [ j ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess wt [ j ]
<operator>.indirectIndexAccess GNBQFBUB [ i ]
<operator>.indirectIndexAccess GII [ i ] [ j ]
<operator>.indirectIndexAccess YEVFCWD [ i ]
<operator>.indirectIndexAccess GII [ i ] [ j ]
<operator>.indirectIndexAccess GII [ i ] [ j ]
<operator>.indirectIndexAccess w [ i ] [ j ]
<operator>.indirectIndexAccess w [ i ] [ j ]
<operator>.indirectIndexAccess GII [ i ] [ j ]
<operator>.indirectIndexAccess EBQOCEIJ [ i ]
<operator>.indirectIndexAccess YEVFCWD [ j ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess m [ j ]
<operator>.indirectIndexAccess GII [ i ]
<operator>.indirectIndexAccess GII [ i ]
<operator>.indirectIndexAccess GII [ i ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess GII [ i ]
<operator>.indirectIndexAccess argv [ i ]
<operator>.indirectIndexAccess w [ i ] [ j ]
UNKNOWN double double
<operator>.indirectIndexAccess w [ i ] [ j ]
UNKNOWN double double
<operator>.indirectIndexAccess argv [ ++ i ]
<operator>.indirectIndexAccess w [ i ] [ j ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess GNBQFBUB [ i ]
<operator>.indirectIndexAccess GII [ i ] [ j ]
<operator>.indirectIndexAccess YEVFCWD [ i ]
<operator>.indirectIndexAccess GII [ i ] [ j ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess wt [ j ]
<operator>.indirectIndexAccess m [ j ]
<operator>.indirectIndexAccess GII [ i ]
<operator>.indirectIndexAccess GII [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess w [ i ] [ j ]
<operator>.indirectIndexAccess w [ i ]
>>>PDG&278 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->62 0->63 0->64 0->66 0->67 0->68 0->69 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->79 0->80 0->81 0->83 0->84 0->85 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->115 0->116 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->127 0->128 0->129 0->131 0->132 0->133 0->135 0->136 0->137 0->138 0->139 0->140 0->141 0->142 0->145 0->146 0->147 0->148 0->150 0->151 0->152 0->153 0->159 0->160 0->163 0->164 0->165 0->166 0->167 0->168 0->169 0->170 0->172 0->173 0->174 0->175 0->176 0->177 0->178 0->179 0->180 0->181 0->182 0->183 0->184 0->185 0->186 0->192 0->194 0->195 0->196 0->197 0->198 0->199 0->200 0->201 2->15 3->1 3->61 3->112 3->134 3->165 3->179 3->193 4->1 4->1 4->1 4->21 5->1 5->1 5->26 6->1 6->1 6->17 7->1 7->1 7->27 8->1 8->1 8->1 8->18 9->19 10->13 10->38 14->1 15->1 15->1 15->1 15->9 15->17 15->18 15->19 15->28 15->39 15->92 15->93 15->93 15->112 15->113 15->133 15->147 15->147 15->166 15->170 15->199 15->217 16->1 16->15 17->18 17->26 17->28 18->19 18->27 18->31 19->10 19->20 19->20 19->20 19->29 19->30 19->31 20->11 20->12 20->13 20->14 20->21 20->22 20->32 20->33 20->34 20->34 20->36 20->202 21->35 21->42 22->22 22->23 22->37 22->38 22->38 22->42 22->43 22->45 22->46 22->48 22->49 22->51 22->52 22->54 22->55 22->57 22->58 22->59 22->62 22->63 22->64 22->67 22->75 22->80 22->85 22->90 22->203 23->22 24->14 25->1 25->15 26->28 27->31 28->9 28->9 30->1 31->10 31->10 33->1 34->11 34->11 34->11 34->12 34->22 34->35 34->63 35->22 36->22 38->13 38->23 38->91 39->1 39->1 39->15 39->16 39->61 39->114 39->114 39->133 39->146 39->165 39->204 39->232 40->30 41->33 42->45 42->62 43->43 43->44 43->44 43->46 43->65 43->94 43->94 43->96 43->115 43->116 43->218 44->43 45->48 45->66 45->96 45->118 46->46 46->47 46->47 46->49 46->68 46->69 46->70 46->71 46->72 46->98 46->98 46->100 46->120 46->121 46->139 46->205 46->206 46->207 46->219 47->46 48->51 48->73 48->74 48->100 48->122 49->49 49->50 49->50 49->52 49->76 49->77 49->78 49->102 49->102 49->104 49->124 49->208 49->209 49->210 49->211 50->49 51->54 51->79 51->104 51->125 52->52 52->53 52->53 52->55 52->81 52->82 52->106 52->106 52->108 52->127 52->212 52->213 52->214 53->52 54->57 54->83 54->84 54->108 54->128 55->55 55->56 55->56 55->59 55->86 55->110 55->130 55->144 55->145 55->163 55->164 55->215 55->224 55->230 55->231 56->55 57->58 57->87 57->88 57->110 57->131 58->42 58->89 59->43 59->59 59->60 59->60 59->63 59->91 59->216 60->59 61->1 61->1 61->1 61->17 62->38 63->12 63->37 63->37 63->37 63->43 63->46 63->49 63->52 63->55 63->59 63->94 63->96 63->98 63->100 63->102 63->104 63->106 63->108 63->110 63->115 63->136 63->141 64->43 67->46 68->71 68->121 68->139 68->153 68->178 68->192 69->121 69->152 69->185 70->123 70->163 75->49 76->78 76->82 76->126 76->156 76->189 77->78 77->158 77->191 78->126 78->164 80->52 81->82 81->162 82->129 82->145 85->55 86->91 86->132 90->59 91->13 91->38 91->132 92->1 92->39 92->39 92->93 92->113 93->1 93->1 93->15 93->39 93->39 93->147 94->43 94->94 94->95 94->95 94->117 94->135 94->148 94->227 95->94 96->46 96->96 96->97 96->97 96->119 96->136 96->136 96->150 97->96 98->46 98->98 98->99 98->99 98->138 98->228 98->235 99->98 100->49 100->100 100->101 100->101 100->123 100->220 101->100 102->49 102->102 102->103 102->103 102->140 102->229 102->236 103->102 104->52 104->104 104->105 104->105 104->126 104->141 104->141 104->159 104->221 104->222 105->104 106->52 106->106 106->107 106->107 106->143 106->168 106->243 106->254 107->106 108->55 108->108 108->109 108->109 108->129 108->223 109->108 110->59 110->110 110->111 110->111 110->132 110->225 111->110 112->92 112->92 112->165 113->1 114->1 114->1 114->1 114->15 114->16 114->39 114->134 114->167 114->170 114->179 114->226 114->257 115->12 115->63 115->65 115->65 115->65 115->135 115->148 115->148 116->94 118->96 120->98 121->70 121->70 121->72 121->178 122->100 123->163 124->102 125->104 126->82 126->164 127->106 128->108 129->145 131->110 132->91 133->16 134->1 134->1 134->1 134->18 135->115 135->148 135->149 135->172 135->173 135->173 135->233 135->248 136->96 136->136 136->137 136->137 136->151 136->234 136->249 137->136 138->140 138->151 138->152 138->153 138->168 138->174 138->174 138->258 138->264 140->138 140->151 140->154 140->155 140->156 140->157 140->158 140->168 140->175 140->176 140->177 140->177 140->186 140->237 140->238 140->239 140->240 140->241 140->250 140->251 140->252 140->259 140->260 140->265 141->104 141->141 141->142 141->142 141->160 141->242 141->253 142->141 143->161 143->162 143->178 143->192 143->245 143->246 143->247 143->256 143->261 145->86 145->86 145->129 145->130 145->130 146->1 146->114 146->114 146->147 146->166 147->1 147->1 147->15 147->114 147->114 148->12 148->63 148->115 148->115 148->117 148->117 148->117 148->135 148->173 148->195 149->138 149->140 149->151 149->168 150->136 151->138 151->140 151->168 152->121 152->185 153->71 153->121 153->139 153->178 153->192 154->176 154->178 154->186 154->192 155->176 156->78 156->82 156->126 156->189 157->158 157->160 158->78 158->191 159->141 161->160 162->82 163->86 163->86 163->123 163->130 163->130 163->144 163->144 164->86 164->86 164->126 164->130 164->130 164->144 164->144 165->112 165->146 165->146 165->179 166->1 167->1 167->1 167->15 167->16 167->171 167->180 167->181 167->182 167->183 167->193 167->199 167->262 168->138 168->140 168->143 168->143 168->151 168->169 168->169 168->244 168->255 169->138 169->140 169->143 169->143 169->151 169->168 170->16 171->1 171->1 171->1 171->21 172->149 173->115 173->135 173->148 173->184 173->195 173->195 173->263 173->270 174->138 174->140 174->143 174->151 174->168 174->185 175->155 175->155 175->197 176->157 176->157 176->178 177->138 177->140 177->143 177->151 177->168 177->187 177->188 177->189 177->190 177->191 177->196 177->197 177->198 177->201 177->266 177->267 177->268 177->269 177->271 177->272 177->273 177->274 177->275 178->161 178->161 179->1 179->112 179->167 179->167 180->1 181->1 182->1 183->1 184->138 184->140 184->151 184->168 185->121 185->152 187->178 187->192 187->198 187->201 188->198 189->78 189->82 189->126 189->156 190->160 190->191 191->78 191->158 193->1 193->61 193->134 193->171 194->183 195->115 195->135 195->148 195->200 195->276 195->277 196->154 196->187 196->187 197->175 197->188 197->188 198->178 198->190 198->190 199->16 200->138 200->140 200->151 200->168
>>>Token int main ( int argc , char * argv [ ] ) { int i , LKTPFV ; YGUK * YPDVNTLVXSHIJO , * CYFVPGBDRVSYTRF ; int OFGGKDTEOPEKY = OTNSSUOKCPOTLJUFCCVJJ ; char * CTOWAFOGPOULENHAETETIAI = " " ; char * UUPWWMIIQCYPEFF = NULL ; char * KWVHLAWSCBMIUXIFSFVRDKCN = " " ; char * BENRKUYWRUEDWBXA = NULL ; int CNKYLTHGY , DXENAUQ ; int n , w [ 200 ] [ 200 ] ; double wp [ 200 ] , GII [ 200 ] [ 200 ] , SFHP [ 200 ] [ 200 ] , YEVFCWD [ 200 ] , EBQOCEIJ [ 200 ] ; int j ; char c ; int KKOK , QEMLVUV , wt [ 200 ] , m [ 200 ] , GNBQFBUB [ 200 ] ; double GYA [ 200 ] ; for ( i = 1 ; i < argc ; i ++ ) { if ( strcmp ( argv [ i ] , " " ) == 0 && i + 1 < argc ) { UUPWWMIIQCYPEFF = argv [ ++ i ] ; } else if ( strcmp ( argv [ i ] , " " ) == 0 && i + 1 < argc ) { BENRKUYWRUEDWBXA = argv [ ++ i ] ; } else if ( strcmp ( argv [ i ] , " " ) == 0 ) { OFGGKDTEOPEKY = atoi ( argv [ ++ i ] ) ; } else { printf ( " \n " ) ; printf ( " " ) ; printf ( " \n " ) ; return 0 ; } } if ( UUPWWMIIQCYPEFF == NULL ) { UUPWWMIIQCYPEFF = CTOWAFOGPOULENHAETETIAI ; } if ( BENRKUYWRUEDWBXA == NULL ) { BENRKUYWRUEDWBXA = KWVHLAWSCBMIUXIFSFVRDKCN ; } YPDVNTLVXSHIJO = LDDDS ( UUPWWMIIQCYPEFF , " " ) ; if ( YPDVNTLVXSHIJO == NULL ) { printf ( " \n " ) ; return 0 ; } CYFVPGBDRVSYTRF = LDDDS ( BENRKUYWRUEDWBXA , " " ) ; if ( YPDVNTLVXSHIJO == NULL ) { printf ( " \n " ) ; return 0 ; } LKTPFV = GHDRUP ( YPDVNTLVXSHIJO , " " , & CNKYLTHGY ) ; if ( OFGGKDTEOPEKY >= 2 ) { printf ( " \n " , CNKYLTHGY ) ; } for ( DXENAUQ = 1 ; DXENAUQ <= CNKYLTHGY ; DXENAUQ ++ ) { if ( OFGGKDTEOPEKY >= 1 ) { printf ( " " , DXENAUQ ) ; } LKTPFV = GHDRUP ( YPDVNTLVXSHIJO , " " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { LKTPFV = GHDRUP ( YPDVNTLVXSHIJO , " " , & c ) ; for ( j = 0 ; j < n ; j ++ ) { LKTPFV = GHDRUP ( YPDVNTLVXSHIJO , " " , & c ) ; if ( c == ' ' ) { w [ i ] [ j ] = - 1 ; } else if ( c == ' ' ) { w [ i ] [ j ] = 1 ; } else if ( c == ' ' ) { w [ i ] [ j ] = 0 ; } } } if ( OFGGKDTEOPEKY >= 3 ) { printf ( " \n " ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { printf ( " \t " , w [ i ] [ j ] ) ; } printf ( " \n " ) ; } } for ( i = 0 ; i < n ; i ++ ) { KKOK = 0 ; QEMLVUV = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( w [ i ] [ j ] == 1 ) { QEMLVUV ++ ; KKOK ++ ; } else if ( w [ i ] [ j ] == 0 ) { QEMLVUV ++ ; } } wp [ i ] = ( ( double ) KKOK ) / QEMLVUV ; wt [ i ] = KKOK ; m [ i ] = QEMLVUV ; } if ( OFGGKDTEOPEKY >= 3 ) { printf ( " " ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( " " , wp [ i ] ) ; } printf ( " \n " ) ; } for ( i = 0 ; i < n ; i ++ ) { GNBQFBUB [ i ] = 0 ; YEVFCWD [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( w [ i ] [ j ] == 1 ) { KKOK = wt [ j ] ; QEMLVUV = m [ j ] - 1 ; GNBQFBUB [ i ] ++ ; GII [ i ] [ j ] = ( ( double ) KKOK ) / QEMLVUV ; YEVFCWD [ i ] += GII [ i ] [ j ] ; } else if ( w [ i ] [ j ] == 0 ) { KKOK = wt [ j ] - 1 ; QEMLVUV = m [ j ] - 1 ; GNBQFBUB [ i ] ++ ; GII [ i ] [ j ] = ( ( double ) KKOK ) / QEMLVUV ; YEVFCWD [ i ] += GII [ i ] [ j ] ; } } YEVFCWD [ i ] /= GNBQFBUB [ i ] ; } if ( OFGGKDTEOPEKY >= 3 ) { printf ( " \n " ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { printf ( " \t " , GII [ i ] [ j ] ) ; } printf ( " \n " , YEVFCWD [ i ] , GNBQFBUB [ i ] ) ; } } for ( i = 0 ; i < n ; i ++ ) { EBQOCEIJ [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( w [ i ] [ j ] == 1 ) || ( w [ i ] [ j ] == 0 ) ) { GII [ i ] [ j ] = ( ( double ) KKOK ) / QEMLVUV ; EBQOCEIJ [ i ] += YEVFCWD [ j ] ; } } EBQOCEIJ [ i ] /= GNBQFBUB [ i ] ; } if ( OFGGKDTEOPEKY >= 1 ) { printf ( " " ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( " " , EBQOCEIJ [ i ] ) ; } printf ( " \n " ) ; } for ( i = 0 ; i < n ; i ++ ) { GYA [ i ] = 0.25 * wp [ i ] + 0.5 * YEVFCWD [ i ] + 0.25 * EBQOCEIJ [ i ] ; } if ( OFGGKDTEOPEKY >= 1 ) { printf ( " " ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( " " , GYA [ i ] ) ; } printf ( " \n " ) ; } if ( OFGGKDTEOPEKY >= 1 ) { printf ( " \n " ) ; } fprintf ( CYFVPGBDRVSYTRF , " \n " , DXENAUQ ) ; for ( i = 0 ; i < n ; i ++ ) { fprintf ( CYFVPGBDRVSYTRF , " \n " , GYA [ i ] ) ; } } JFJNSW ( YPDVNTLVXSHIJO ) ; JFJNSW ( CYFVPGBDRVSYTRF ) ; return 0 ; }
>>>Func
METHOD QSC
METHOD_RETURN int
PARAM char * Q
PARAM int q
<operator>.assignment w = MIXP ( Q + q - 2 )
<operator>.assignment w = XDDI ( Q , q )
RETURN return q ; return q ;
<operator>.lessThan q < 2
<operator>.greaterEqualsThan w >= 0
<operator>.greaterEqualsThan w >= 0
IDENTIFIER q return q ;
RETURN return q ; return q ;
MIXP MIXP ( Q + q - 2 )
<operator>.assignment Q [ q - 2 ] = Cs [ w ] [ 2 ]
<operator>.postDecrement q --
RETURN return QSC ( Q , q ) ; return QSC ( Q , q ) ;
XDDI XDDI ( Q , q )
<operator>.assignment q = 0
RETURN return QSC ( Q , q ) ; return QSC ( Q , q ) ;
IDENTIFIER q return q ;
<operator>.subtraction Q + q - 2
QSC QSC ( Q , q )
QSC QSC ( Q , q )
<operator>.addition Q + q
<operator>.subtraction q - 2
<operator>.indirectIndexAccess Q [ q - 2 ]
<operator>.indirectIndexAccess Cs [ w ] [ 2 ]
<operator>.indirectIndexAccess Cs [ w ]
>>>PDG&28 0->2 0->3 0->7 0->8 0->9 0->10 0->14 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 2->1 2->16 2->20 2->21 2->23 3->7 4->8 5->9 6->1 7->1 7->1 7->4 7->8 7->11 7->12 7->16 7->19 7->20 7->20 7->23 7->23 7->24 8->5 8->9 8->13 8->14 8->15 8->16 8->21 8->24 8->25 8->26 8->27 9->6 9->17 9->18 9->22 10->6 11->1 12->4 13->21 14->21 15->1 16->5 16->5 16->10 16->22 17->22 18->1 19->11 20->12 20->12 21->15 22->18 24->14
>>>Token int QSC ( char * Q , int q ) { int w ; if ( q < 2 ) return q ; w = MIXP ( Q + q - 2 ) ; if ( w >= 0 ) { Q [ q - 2 ] = Cs [ w ] [ 2 ] ; q -- ; return QSC ( Q , q ) ; } w = XDDI ( Q , q ) ; if ( w >= 0 ) { q = 0 ; return QSC ( Q , q ) ; } return q ; }
>>>Func
METHOD main
METHOD_RETURN int
LKTPF LKTPF ( "%i" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan VYGU <= t
<operator>.postIncrement VYGU ++
LITERAL 0 return 0 ;
<operator>.assignment VYGU = 1
memset memset ( KYPDV   0   sizeof ( KYPDV ) )
memset memset ( NTLV   0   sizeof ( NTLV ) )
LKTPF LKTPF ( "%i\n" , & n )
printf printf ( "Case #%i:\n" , VYGU )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
LKTPF LKTPF ( "\n" )
<operator>.assignment i = 0
<operator>.assignment YFVPGBDRVS [ i ] = YTRFOFGGKDT [ i ] = 0
<operator>.assignment i = 0
<operator>.assignment EOPEK = 0
<operator>.assignment YOT [ i ] = 0
<operator>.assignmentDivision YOT [ i ] /= EOPEK
<operator>.assignment i = 0
<operator>.assignment EOPEK = 0
<operator>.assignment NSSU [ i ] = 0
<operator>.assignmentDivision NSSU [ i ] /= EOPEK
<operator>.assignment i = 0
printf printf ( "%.6lf\n"   0.25 * ( ( double ) YFVPGBDRVS [ i ] / YTRFOFGGKDT [ i ] ) + 0.50 * YOT [ i ] + 0.25 * NSSU [ i ] )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment c = XSHIJOC ( )
<operator>.assignment YTRFOFGGKDT [ i ] = 0
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.addition 0.25 * ( ( double ) YFVPGBDRVS [ i ] / YTRFOFGGKDT [ i ] ) + 0.50 * YOT [ i ] + 0.25 * NSSU [ i ]
<operator>.logicalOr c == '0' || c == '1'
<operator>.notEquals j != n
<operator>.logicalAnd i != j && KYPDV [ j ] [ i ]
<operator>.logicalAnd i != j && KYPDV [ j ] [ i ]
<operator>.addition 0.25 * ( ( double ) YFVPGBDRVS [ i ] / YTRFOFGGKDT [ i ] ) + 0.50 * YOT [ i ]
<operator>.multiplication 0.25 * NSSU [ i ]
<operator>.postIncrement KYPDV [ i ] [ j ] ++
<operator>.assignmentPlus YFVPGBDRVS [ i ] += NTLV [ i ] [ j ]
<operator>.assignmentPlus YTRFOFGGKDT [ i ] += KYPDV [ i ] [ j ]
<operator>.postIncrement EOPEK ++
<operator>.assignmentPlus YOT [ i ] += ( double ) ( YFVPGBDRVS [ j ] - NTLV [ j ] [ i ] ) / ( YTRFOFGGKDT [ j ] - KYPDV [ j ] [ i ] )
<operator>.postIncrement EOPEK ++
<operator>.assignmentPlus NSSU [ i ] += YOT [ j ]
<operator>.multiplication 0.25 * ( ( double ) YFVPGBDRVS [ i ] / YTRFOFGGKDT [ i ] )
<operator>.multiplication 0.50 * YOT [ i ]
<operator>.equals c == '0'
<operator>.equals c == '1'
<operator>.equals c == '1'
assert assert ( c == '.' )
<operator>.notEquals i != j
<operator>.notEquals i != j
<operator>.division ( double ) YFVPGBDRVS [ i ] / YTRFOFGGKDT [ i ]
<operator>.postIncrement NTLV [ i ] [ j ] ++
<operator>.division ( double ) ( YFVPGBDRVS [ j ] - NTLV [ j ] [ i ] ) / ( YTRFOFGGKDT [ j ] - KYPDV [ j ] [ i ] )
<operator>.cast ( double ) YFVPGBDRVS [ i ]
<operator>.equals c == '.'
<operator>.cast ( double ) ( YFVPGBDRVS [ j ] - NTLV [ j ] [ i ] )
<operator>.subtraction YTRFOFGGKDT [ j ] - KYPDV [ j ] [ i ]
<operator>.subtraction YFVPGBDRVS [ j ] - NTLV [ j ] [ i ]
<operator>.sizeOf sizeof ( KYPDV )
<operator>.sizeOf sizeof ( NTLV )
<operator>.addressOf & n
<operator>.indirectIndexAccess YFVPGBDRVS [ i ]
<operator>.indirectIndexAccess YOT [ i ]
<operator>.indirectIndexAccess YOT [ i ]
<operator>.indirectIndexAccess NSSU [ i ]
<operator>.indirectIndexAccess NSSU [ i ]
<operator>.indirectIndexAccess YTRFOFGGKDT [ i ]
XSHIJOC XSHIJOC ( )
<operator>.indirectIndexAccess NSSU [ i ]
<operator>.indirectIndexAccess KYPDV [ j ] [ i ]
<operator>.indirectIndexAccess KYPDV [ j ] [ i ]
<operator>.indirectIndexAccess YOT [ i ]
<operator>.indirectIndexAccess KYPDV [ i ] [ j ]
<operator>.indirectIndexAccess YFVPGBDRVS [ i ]
<operator>.indirectIndexAccess NTLV [ i ] [ j ]
<operator>.indirectIndexAccess YTRFOFGGKDT [ i ]
<operator>.indirectIndexAccess KYPDV [ i ] [ j ]
<operator>.indirectIndexAccess KYPDV [ j ]
<operator>.indirectIndexAccess YOT [ i ]
<operator>.indirectIndexAccess KYPDV [ j ]
<operator>.indirectIndexAccess NSSU [ i ]
<operator>.indirectIndexAccess YOT [ j ]
<operator>.indirectIndexAccess YTRFOFGGKDT [ i ]
<operator>.indirectIndexAccess KYPDV [ i ]
<operator>.indirectIndexAccess NTLV [ i ]
<operator>.indirectIndexAccess KYPDV [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess YFVPGBDRVS [ i ]
<operator>.indirectIndexAccess NTLV [ i ] [ j ]
UNKNOWN double double
<operator>.indirectIndexAccess YTRFOFGGKDT [ j ]
<operator>.indirectIndexAccess KYPDV [ j ] [ i ]
<operator>.indirectIndexAccess NTLV [ i ]
<operator>.indirectIndexAccess YFVPGBDRVS [ j ]
<operator>.indirectIndexAccess NTLV [ j ] [ i ]
<operator>.indirectIndexAccess KYPDV [ j ]
<operator>.indirectIndexAccess NTLV [ j ]
>>>PDG&119 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->52 0->56 0->60 0->62 0->64 0->65 0->66 0->67 0->68 0->70 0->71 0->76 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->11 4->12 4->14 4->16 4->18 4->20 4->22 4->24 4->26 4->30 4->34 4->80 4->81 4->82 5->1 5->4 6->3 7->1 7->4 8->1 8->1 9->1 9->1 10->1 10->1 10->12 10->14 10->16 10->18 10->20 10->36 10->38 10->40 10->42 10->52 11->1 11->5 12->12 12->13 12->13 12->14 12->23 12->36 12->36 12->44 13->1 13->12 14->14 14->15 14->15 14->16 14->25 14->38 14->38 14->46 14->47 14->83 14->88 15->1 15->14 16->16 16->17 16->17 16->18 16->27 16->28 16->29 16->40 16->40 16->48 16->70 16->84 16->85 17->1 17->16 18->18 18->19 18->19 18->20 18->31 18->32 18->33 18->42 18->42 18->49 18->71 18->86 18->87 19->1 19->18 20->1 20->1 20->1 20->10 20->12 20->20 20->21 20->21 20->35 20->50 20->55 20->56 20->64 20->65 20->72 20->75 20->90 20->93 20->104 20->108 20->109 21->1 21->20 22->12 23->1 24->14 25->1 25->1 25->1 25->58 25->72 25->75 26->16 27->1 27->29 27->60 28->1 28->29 28->61 29->1 29->1 29->1 29->65 30->18 31->1 31->33 31->62 32->1 32->33 32->63 33->1 33->1 33->1 33->56 34->1 34->20 35->1 35->1 36->1 36->1 36->12 36->36 36->37 36->37 36->45 36->51 36->66 36->89 37->1 37->36 38->1 38->1 38->14 38->38 38->39 38->52 38->52 38->52 39->1 39->38 40->1 40->1 40->16 40->40 40->41 40->53 40->70 40->70 41->1 41->40 42->1 42->1 42->18 42->42 42->43 42->54 42->71 42->71 43->1 43->42 44->1 44->36 45->1 45->1 45->66 46->1 46->25 46->59 46->72 47->1 47->38 48->1 48->40 49->1 49->42 50->1 50->1 51->1 51->1 51->1 51->57 51->68 51->69 51->76 51->94 51->105 52->1 52->38 52->39 52->58 52->59 52->95 52->96 52->97 52->98 52->106 52->107 53->1 53->1 53->1 53->54 53->60 53->61 53->74 53->77 53->78 53->78 53->79 53->100 53->111 53->112 53->113 53->115 53->116 53->117 53->118 54->1 54->1 54->1 54->53 54->62 54->63 54->102 54->103 55->1 55->1 56->1 56->35 56->35 56->50 56->50 57->1 57->1 57->59 58->1 58->1 58->1 58->72 58->75 59->1 59->1 59->1 59->72 60->1 60->29 61->1 61->1 61->29 62->1 62->33 63->1 63->1 63->33 64->1 64->35 64->35 64->50 64->50 64->55 64->55 65->1 65->35 65->35 65->50 65->50 65->55 65->55 66->51 66->51 66->67 66->67 66->68 66->76 67->51 67->51 67->68 67->76 68->1 68->1 68->51 68->73 68->110 68->114 69->1 69->1 70->17 70->41 70->53 70->53 70->91 70->99 71->19 71->43 71->54 71->54 71->92 71->101 72->1 72->1 72->64 72->64 73->1 73->1 73->58 74->1 74->1 74->61 74->61 75->1 76->1 76->69 76->69 77->1 78->1 78->1 78->53 78->54 78->74 78->74 79->1 79->1 79->74 79->74 79->77 79->77
>>>Token int main ( ) { int t ; LKTPF ( " " , & t ) ; for ( int VYGU = 1 ; VYGU <= t ; VYGU ++ ) { memset ( KYPDV , 0 , sizeof ( KYPDV ) ) ; memset ( NTLV , 0 , sizeof ( NTLV ) ) ; int n ; LKTPF ( " \n " , & n ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { char c = XSHIJOC ( ) ; if ( c == ' ' || c == ' ' ) { KYPDV [ i ] [ j ] ++ ; if ( c == ' ' ) NTLV [ i ] [ j ] ++ ; } else assert ( c == ' ' ) ; } LKTPF ( " \n " ) ; } for ( int i = 0 ; i < n ; i ++ ) { YFVPGBDRVS [ i ] = YTRFOFGGKDT [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != n ) { YFVPGBDRVS [ i ] += NTLV [ i ] [ j ] ; YTRFOFGGKDT [ i ] += KYPDV [ i ] [ j ] ; } } } for ( int i = 0 ; i < n ; i ++ ) { int EOPEK = 0 ; YOT [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && KYPDV [ j ] [ i ] ) { EOPEK ++ ; YOT [ i ] += ( double ) ( YFVPGBDRVS [ j ] - NTLV [ j ] [ i ] ) / ( YTRFOFGGKDT [ j ] - KYPDV [ j ] [ i ] ) ; } } YOT [ i ] /= EOPEK ; } for ( int i = 0 ; i < n ; i ++ ) { int EOPEK = 0 ; NSSU [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && KYPDV [ j ] [ i ] ) { EOPEK ++ ; NSSU [ i ] += YOT [ j ] ; } } NSSU [ i ] /= EOPEK ; } printf ( " \n " , VYGU ) ; for ( int i = 0 ; i < n ; i ++ ) { printf ( " \n " , 0.25 * ( ( double ) YFVPGBDRVS [ i ] / YTRFOFGGKDT [ i ] ) + 0.50 * YOT [ i ] + 0.25 * NSSU [ i ] ) ; } } return 0 ; }
>>>Func
METHOD RLGMJYIHVWHBMXHP
METHOD_RETURN struct ACPGRJEQ
PARAM struct ACPGRJEQ * WFGQ
RETURN return WFGQ ; return WFGQ ;
<operator>.equals WFGQ == NULL
<operator>.logicalAnd WFGQ -> KODK && WFGQ -> TTT == WFGQ -> KODK -> TTT
IDENTIFIER WFGQ return WFGQ ;
RETURN return NULL ; return NULL ;
RETURN return RLGMJYIHVWHBMXHP ( WFGQ -> KODK ) ; return RLGMJYIHVWHBMXHP ( WFGQ -> KODK ) ;
IDENTIFIER NULL return NULL ;
<operator>.equals WFGQ -> TTT == WFGQ -> KODK -> TTT
<operator>.logicalAnd WFGQ -> KODK && WFGQ -> TTT == WFGQ -> KODK -> TTT
RLGMJYIHVWHBMXHP RLGMJYIHVWHBMXHP ( WFGQ -> KODK )
<operator>.assignment WFGQ -> KODK = RLGMJYIHVWHBMXHP ( WFGQ -> KODK )
<operator>.assignment WFGQ = WFGQ -> KODK
<operator>.equals WFGQ -> TTT == WFGQ -> KODK -> TTT
RLGMJYIHVWHBMXHP RLGMJYIHVWHBMXHP ( WFGQ -> KODK )
<operator>.indirectFieldAccess WFGQ -> KODK
FIELD_IDENTIFIER KODK KODK
<operator>.indirectFieldAccess WFGQ -> TTT
<operator>.indirectFieldAccess WFGQ -> KODK -> TTT
FIELD_IDENTIFIER TTT TTT
<operator>.indirectFieldAccess WFGQ -> KODK
FIELD_IDENTIFIER TTT TTT
<operator>.indirectFieldAccess WFGQ -> KODK
<operator>.indirectFieldAccess WFGQ -> KODK
<operator>.indirectFieldAccess WFGQ -> KODK
FIELD_IDENTIFIER KODK KODK
FIELD_IDENTIFIER KODK KODK
<operator>.indirectFieldAccess WFGQ -> TTT
<operator>.indirectFieldAccess WFGQ -> KODK -> TTT
<operator>.indirectFieldAccess WFGQ -> KODK
FIELD_IDENTIFIER KODK KODK
FIELD_IDENTIFIER KODK KODK
<operator>.indirectFieldAccess WFGQ -> KODK
FIELD_IDENTIFIER TTT TTT
<operator>.indirectFieldAccess WFGQ -> KODK
FIELD_IDENTIFIER TTT TTT
FIELD_IDENTIFIER KODK KODK
FIELD_IDENTIFIER KODK KODK
FIELD_IDENTIFIER KODK KODK
>>>PDG&41 0->2 0->4 0->6 0->7 0->9 2->4 3->1 4->1 4->1 4->1 4->5 4->6 4->7 4->17 4->18 5->3 5->8 5->11 5->11 5->11 5->12 5->13 5->16 5->16 5->24 5->25 5->26 5->28 5->32 5->33 5->34 5->39 6->3 7->1 8->1 9->7 10->5 10->5 10->15 10->15 11->11 11->12 11->14 11->14 11->24 11->28 11->31 11->38 12->8 15->11 15->11 16->13 17->10 17->19 17->20 17->21 17->22 17->23 17->27 24->15 24->29 24->30 24->35 24->36 24->37 24->40
>>>Token struct ACPGRJEQ * RLGMJYIHVWHBMXHP ( struct ACPGRJEQ * WFGQ ) { if ( WFGQ == NULL ) return NULL ; if ( WFGQ -> KODK && WFGQ -> TTT == WFGQ -> KODK -> TTT ) { while ( WFGQ -> KODK && WFGQ -> TTT == WFGQ -> KODK -> TTT ) { WFGQ = WFGQ -> KODK ; } return RLGMJYIHVWHBMXHP ( WFGQ -> KODK ) ; } else { WFGQ -> KODK = RLGMJYIHVWHBMXHP ( WFGQ -> KODK ) ; } return WFGQ ; }
>>>Func
METHOD main
METHOD_RETURN int
JAAFT JAAFT ( "%d" , & t )
<operator>.assignment ECUH = 0
RETURN return 0 ; return 0 ;
<operator>.postDecrement t --
LITERAL 0 return 0 ;
<operator>.postIncrement ECUH ++
<operator>.assignment AXQ = 0
JAAFT JAAFT ( "%d" , & c )
JAAFT JAAFT ( "%d" , & d )
JAAFT JAAFT ( "%d" , & n )
JAAFT JAAFT ( "%s" , NCW )
<operator>.assignment PCBMX [ 0 ] = NCW [ 0 ]
<operator>.assignment AXQ = 1
<operator>.assignment PCBMX [ AXQ ++ ] = '\0'
printf printf ( "Case #%d: " , ECUH )
printf printf ( "[" )
printf printf ( "]" )
printf printf ( "\n" )
<operator>.notEquals c != 0
<operator>.notEquals d != 0
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan j < AXQ - 1
<operator>.postIncrement j ++
JAAFT JAAFT ( "%s" , MTE )
JAAFT JAAFT ( "%s" , PLL )
<operator>.assignment i = 1
<operator>.assignment j = 0
printf printf ( "%c" , PCBMX [ j ] )
<operator>.logicalAnd c != 0 && AXQ != 0 && ( ( PCBMX [ AXQ - 1 ] == MTE [ 0 ] && NCW [ i ] == MTE [ 1 ] ) || ( PCBMX [ AXQ - 1 ] == MTE [ 1 ] && NCW [ i ] == MTE [ 0 ] ) )
<operator>.postIncrement AXQ ++
<operator>.subtraction AXQ - 1
<operator>.lessThan j < AXQ - 2
<operator>.assignment PCBMX [ AXQ - 1 ] = MTE [ 2 ]
printf printf ( ", " )
<operator>.logicalAnd c != 0 && AXQ != 0
<operator>.logicalOr ( PCBMX [ AXQ - 1 ] == MTE [ 0 ] && NCW [ i ] == MTE [ 1 ] ) || ( PCBMX [ AXQ - 1 ] == MTE [ 1 ] && NCW [ i ] == MTE [ 0 ] )
<operator>.assignment XQIE = 0
<operator>.subtraction AXQ - 2
<operator>.notEquals c != 0
<operator>.notEquals AXQ != 0
<operator>.logicalAnd PCBMX [ AXQ - 1 ] == MTE [ 0 ] && NCW [ i ] == MTE [ 1 ]
<operator>.logicalAnd PCBMX [ AXQ - 1 ] == MTE [ 1 ] && NCW [ i ] == MTE [ 0 ]
<operator>.logicalAnd d != 0 && NCW [ i ] == PLL [ 0 ]
<operator>.equals XQIE == 0
<operator>.equals PCBMX [ AXQ - 1 ] == MTE [ 0 ]
<operator>.equals NCW [ i ] == MTE [ 1 ]
<operator>.equals PCBMX [ AXQ - 1 ] == MTE [ 1 ]
<operator>.equals NCW [ i ] == MTE [ 0 ]
<operator>.subtraction AXQ - 1
<operator>.assignment PCBMX [ AXQ ++ ] = NCW [ i ]
<operator>.notEquals d != 0
<operator>.equals NCW [ i ] == PLL [ 0 ]
<operator>.lessThan j < AXQ
<operator>.postIncrement j ++
<operator>.equals XQIE == 1
<operator>.subtraction AXQ - 1
<operator>.subtraction AXQ - 1
<operator>.assignment j = 0
<operator>.assignment AXQ = 0
<operator>.logicalAnd d != 0 && NCW [ i ] == PLL [ 1 ]
<operator>.equals PCBMX [ j ] == PLL [ 1 ]
<operator>.postIncrement AXQ ++
<operator>.assignment XQIE = 1
<operator>.notEquals d != 0
<operator>.equals NCW [ i ] == PLL [ 1 ]
<operator>.lessThan j < AXQ
<operator>.postIncrement j ++
<operator>.equals XQIE == 1
<operator>.assignment j = 0
<operator>.assignment AXQ = 0
<operator>.equals PCBMX [ j ] == PLL [ 0 ]
<operator>.assignment XQIE = 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess PCBMX [ 0 ]
<operator>.indirectIndexAccess NCW [ 0 ]
<operator>.indirectIndexAccess PCBMX [ AXQ ++ ]
<operator>.indirectIndexAccess PCBMX [ j ]
<operator>.indirectIndexAccess PCBMX [ AXQ - 1 ]
<operator>.indirectIndexAccess MTE [ 2 ]
<operator>.indirectIndexAccess PCBMX [ AXQ - 1 ]
<operator>.indirectIndexAccess MTE [ 0 ]
<operator>.indirectIndexAccess NCW [ i ]
<operator>.indirectIndexAccess MTE [ 1 ]
<operator>.indirectIndexAccess PCBMX [ AXQ - 1 ]
<operator>.indirectIndexAccess MTE [ 1 ]
<operator>.indirectIndexAccess NCW [ i ]
<operator>.indirectIndexAccess MTE [ 0 ]
<operator>.indirectIndexAccess NCW [ i ]
<operator>.indirectIndexAccess PLL [ 0 ]
<operator>.indirectIndexAccess PCBMX [ AXQ ++ ]
<operator>.indirectIndexAccess NCW [ i ]
<operator>.indirectIndexAccess PCBMX [ j ]
<operator>.indirectIndexAccess PLL [ 1 ]
<operator>.indirectIndexAccess NCW [ i ]
<operator>.indirectIndexAccess PLL [ 1 ]
<operator>.indirectIndexAccess PCBMX [ j ]
<operator>.indirectIndexAccess PLL [ 0 ]
>>>PDG&102 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->34 0->36 0->39 0->40 0->41 0->42 0->46 0->51 0->53 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->64 0->65 0->66 0->68 0->69 0->70 0->71 0->72 0->74 2->1 2->1 2->5 3->1 3->1 3->7 4->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->17 5->18 5->19 5->20 5->21 5->22 5->24 5->28 5->29 5->32 5->33 5->75 5->76 5->77 5->78 5->79 5->80 6->4 7->1 7->16 8->1 9->1 9->1 9->20 9->41 10->1 10->1 10->21 10->53 10->66 11->1 11->1 11->22 12->1 12->1 12->13 12->48 12->50 12->52 12->54 12->67 13->1 13->1 13->1 14->1 14->32 14->42 14->51 14->55 14->58 14->64 14->68 15->1 15->1 16->1 16->1 16->7 17->1 18->1 19->1 20->1 20->1 20->9 20->26 20->41 21->1 21->1 21->10 21->27 21->53 22->1 22->1 22->1 22->11 22->22 22->23 22->23 22->31 22->37 22->41 23->1 23->22 24->1 24->1 24->1 24->24 24->25 24->30 24->33 24->34 24->34 24->40 24->81 25->1 25->24 26->1 26->1 26->35 26->47 26->48 26->49 26->50 27->1 27->1 27->54 27->63 27->67 27->73 28->1 28->22 29->1 29->24 30->1 30->1 30->63 30->73 31->1 31->1 31->1 31->35 31->39 31->45 31->46 31->51 31->53 31->82 31->83 32->33 33->1 33->24 33->24 33->40 34->1 34->1 34->25 34->36 35->1 35->1 35->1 35->47 36->1 37->1 37->1 37->31 37->31 37->38 37->43 37->47 37->58 37->84 37->85 38->1 38->1 38->31 38->31 39->1 39->46 39->57 39->70 40->33 40->34 40->34 41->1 41->9 41->20 41->37 41->37 41->42 42->32 42->37 42->37 42->51 42->55 42->58 42->64 42->68 43->1 43->1 43->38 43->38 43->44 43->49 43->59 43->88 43->89 44->1 44->1 44->38 44->38 45->1 45->1 45->1 45->55 45->57 45->60 45->62 45->66 46->1 46->1 46->52 46->64 46->94 46->95 47->1 47->1 47->26 47->43 47->43 47->48 47->49 47->50 47->86 47->87 48->1 48->1 48->12 48->26 48->43 48->43 48->49 48->50 48->52 48->54 48->67 49->1 49->1 49->26 49->44 49->44 49->47 49->48 49->50 49->90 49->91 50->1 50->1 50->12 50->26 50->44 50->44 50->47 50->48 50->52 50->54 50->67 51->32 51->42 51->55 51->58 51->64 51->68 52->1 52->1 53->1 53->10 53->21 53->45 53->45 53->54 53->66 53->92 53->93 54->1 54->1 54->12 54->27 54->45 54->45 54->48 54->50 54->52 54->67 54->73 55->1 55->32 55->42 55->51 55->55 55->56 55->56 55->58 55->63 55->64 55->68 55->96 55->97 56->1 56->55 57->1 57->46 57->61 58->32 58->42 58->51 58->55 58->59 58->64 58->68 59->32 59->42 59->51 59->55 59->58 59->64 59->68 60->55 61->1 61->32 61->42 61->51 61->55 61->58 61->64 61->68 62->1 62->1 62->1 62->68 62->70 62->71 63->1 63->1 63->1 63->27 63->30 63->65 63->67 63->73 64->32 64->42 64->51 64->55 64->58 64->68 65->1 65->57 66->1 66->10 66->21 66->53 66->62 66->62 66->67 66->98 66->99 67->1 67->1 67->12 67->27 67->48 67->50 67->52 67->54 67->62 67->62 67->63 68->1 68->32 68->42 68->51 68->55 68->58 68->64 68->68 68->69 68->69 68->73 68->100 68->101 69->1 69->68 70->1 70->46 70->72 71->68 72->1 72->32 72->42 72->51 72->55 72->58 72->64 72->68 73->1 73->1 73->1 73->27 73->30 73->54 73->63 73->74 74->1 74->70
>>>Token int main ( ) { int c , d , n , i , j , AXQ , XQIE , ECUH ; char NCW [ 100 ] , MTE [ 5 ] , PLL [ 5 ] , PCBMX [ 100 ] , t ; JAAFT ( " " , & t ) ; ECUH = 0 ; while ( t -- ) { ECUH ++ ; AXQ = 0 ; JAAFT ( " " , & c ) ; if ( c != 0 ) JAAFT ( " " , MTE ) ; JAAFT ( " " , & d ) ; if ( d != 0 ) JAAFT ( " " , PLL ) ; JAAFT ( " " , & n ) ; JAAFT ( " " , NCW ) ; PCBMX [ 0 ] = NCW [ 0 ] ; AXQ = 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( c != 0 && AXQ != 0 && ( ( PCBMX [ AXQ - 1 ] == MTE [ 0 ] && NCW [ i ] == MTE [ 1 ] ) || ( PCBMX [ AXQ - 1 ] == MTE [ 1 ] && NCW [ i ] == MTE [ 0 ] ) ) ) { PCBMX [ AXQ - 1 ] = MTE [ 2 ] ; } else { XQIE = 0 ; if ( d != 0 && NCW [ i ] == PLL [ 0 ] ) { for ( j = 0 ; j < AXQ ; j ++ ) { if ( PCBMX [ j ] == PLL [ 1 ] ) XQIE = 1 ; } if ( XQIE == 1 ) AXQ = 0 ; } else if ( d != 0 && NCW [ i ] == PLL [ 1 ] ) { for ( j = 0 ; j < AXQ ; j ++ ) { if ( PCBMX [ j ] == PLL [ 0 ] ) XQIE = 1 ; } if ( XQIE == 1 ) AXQ = 0 ; } if ( XQIE == 0 ) PCBMX [ AXQ ++ ] = NCW [ i ] ; } } PCBMX [ AXQ ++ ] = ' \0 ' ; printf ( " " , ECUH ) ; printf ( " " ) ; for ( j = 0 ; j < AXQ - 1 ; j ++ ) { printf ( " " , PCBMX [ j ] ) ; if ( j < AXQ - 2 ) printf ( " " ) ; } printf ( " " ) ; printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD RIVSUYVTPF
METHOD_RETURN struct AEHH
PARAM int v
<operator>.assignment * MCNVDKF = malloc ( sizeof ( struct AEHH ) )
<operator>.assignment MCNVDKF -> GWDROK = v
<operator>.assignment MCNVDKF -> WDLS = NULL
RETURN return MCNVDKF ; return MCNVDKF ;
IDENTIFIER MCNVDKF return MCNVDKF ;
<operator>.sizeOf sizeof ( struct AEHH )
>>>PDG&9 0->2 0->4 0->5 0->7 2->4 3->1 3->1 3->1 3->7 4->1 4->1 4->1 5->1 5->1 5->1 6->1 7->6 8->1
>>>Token struct AEHH * RIVSUYVTPF ( int v ) { struct AEHH * MCNVDKF = malloc ( sizeof ( struct AEHH ) ) ; MCNVDKF -> GWDROK = v ; MCNVDKF -> WDLS = NULL ; return MCNVDKF ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment QSC = MIXPX ( "B.in" , "r" )
<operator>.assignment DDIR = MIXPX ( "output.txt" , "w" )
FUTDYA FUTDYA ( QSC , "%d " , & T )
QRUOHU QRUOHU ( QSC )
QRUOHU QRUOHU ( DDIR )
<operator>.lessThan FRPNQOL < T
<operator>.preIncrement ++ FRPNQOL
WQLLQLEJ WQLLQLEJ ( )
MIXPX MIXPX ( "B.in" , "r" )
MIXPX MIXPX ( "output.txt" , "w" )
<operator>.assignment FRPNQOL = 0
>>>PDG&13 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 2->1 2->4 3->1 3->1 3->6 4->1 4->1 4->5 4->7 5->1 5->1 6->1 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->9 8->1 8->7 9->1 10->2 10->2 11->3 11->3 12->1 12->7
>>>Token int main ( ) { int T ; QSC = MIXPX ( " " , " " ) ; DDIR = MIXPX ( " " , " " ) ; FUTDYA ( QSC , " " , & T ) ; for ( FRPNQOL = 0 ; FRPNQOL < T ; ++ FRPNQOL ) WQLLQLEJ ( ) ; QRUOHU ( QSC ) ; QRUOHU ( DDIR ) ; }
>>>Func
METHOD GLJJXVAH
METHOD_RETURN int
PARAM char * QCL
PARAM char * TONWS
PARAM int VIYTSK
PARAM int i
PARAM int * NVRLFEAB
PARAM int * AINJULHW
RETURN return 0 ; return 0 ;
<operator>.lessThan j < VIYTSK
<operator>.postIncrement j ++
LITERAL 0 return 0 ;
<operator>.assignment j = * NVRLFEAB + * AINJULHW + 2
<operator>.equals TONWS [ i ] == QCL [ j * 3 ]
<operator>.equals TONWS [ i ] == QCL [ j * 3 + 1 ]
<operator>.addition * NVRLFEAB + * AINJULHW + 2
<operator>.assignment * NVRLFEAB = j * 3
<operator>.assignment * AINJULHW = - 1
RETURN return 1 ; return 1 ;
<operator>.assignment * NVRLFEAB = - 1
<operator>.assignment * AINJULHW = j * 3 + 1
RETURN return 1 ; return 1 ;
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
<operator>.multiplication j * 3
<operator>.multiplication j * 3
<operator>.minus - 1
<operator>.addition j * 3 + 1
<operator>.minus - 1
<operator>.addition j * 3 + 1
<operator>.multiplication j * 3
<operator>.multiplication j * 3
<operator>.indirectIndexAccess TONWS [ i ]
<operator>.indirectIndexAccess QCL [ j * 3 ]
<operator>.indirectIndexAccess TONWS [ i ]
<operator>.indirectIndexAccess QCL [ j * 3 + 1 ]
<operator>.indirection * NVRLFEAB
<operator>.indirection * AINJULHW
<operator>.indirection * NVRLFEAB
<operator>.indirection * AINJULHW
>>>PDG&40 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->15 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->1 2->13 2->14 3->1 3->13 3->14 4->9 5->1 6->1 7->1 8->1 9->1 9->1 9->8 9->13 9->24 9->24 9->32 9->33 10->1 10->9 11->8 12->1 12->1 12->9 13->1 13->1 13->1 13->14 13->14 13->16 13->17 13->18 13->25 13->26 13->27 13->30 13->34 13->35 13->36 13->37 14->1 14->1 14->9 14->10 14->13 14->19 14->20 14->21 14->28 14->29 14->31 14->38 14->39 15->1 16->1 16->1 16->1 17->1 17->1 17->1 18->1 21->1 22->18 23->21 24->25 24->30 25->1 25->16 25->16 26->17 28->19 30->10 30->27 30->27 30->31 31->20 31->20 31->29 31->29
>>>Token int GLJJXVAH ( char * QCL , char * TONWS , int VIYTSK , int i , int * NVRLFEAB , int * AINJULHW ) { for ( int j = * NVRLFEAB + * AINJULHW + 2 ; j < VIYTSK ; j ++ ) { if ( TONWS [ i ] == QCL [ j * 3 ] ) { * NVRLFEAB = j * 3 ; * AINJULHW = - 1 ; return 1 ; } if ( TONWS [ i ] == QCL [ j * 3 + 1 ] ) { * NVRLFEAB = - 1 ; * AINJULHW = j * 3 + 1 ; return 1 ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
PTWWYAYYKRCIYDN PTWWYAYYKRCIYDN ( & argc , & argv )
VBVAFEUTXDQSNFBL VBVAFEUTXDQSNFBL ( argv [ 0 ] )
XXIUYLTXV XXIUYLTXV ( NBHPEU , "" )
LHSNMYIHWNXRBG LHSNMYIHWNXRBG ( VMETWBS , IWRHKUOAY )
LNIEBUFLCE LNIEBUFLCE ( VMETWBS )
YDVALT YDVALT ( MPNKQJSNDAXA )
<operator>.assignment QBBCOJIQEPCJTEOSEAM = true
UASGBMTITTOAILABYE UASGBMTITTOAILABYE ( )
RFYUUWPKFKEQS RFYUUWPKFKEQS ( ( BQOHUB < argc ) ? & argv [ BQOHUB ] : NULL )
CDWVTY CDWVTY ( )
GFBHGFYLFWJEMTMYADUBVJI GFBHGFYLFWJEMTMYADUBVJI ( )
RETURN return QMMTLIPKQXL ; return QMMTLIPKQXL ;
<operator>.notEquals ( c = RPDEIOYXTCX ( argc , argv , TSYUXOEIH , KYLTSPIN , NULL ) ) != - 1
IDENTIFIER QMMTLIPKQXL return QMMTLIPKQXL ;
<operator>.conditional ( BQOHUB < argc ) ? & argv [ BQOHUB ] : NULL
<operator>.assignment c = RPDEIOYXTCX ( argc , argv , TSYUXOEIH , KYLTSPIN , NULL )
<operator>.minus - 1
IDENTIFIER c switch(c)
<operator>.lessThan BQOHUB < argc
RPDEIOYXTCX RPDEIOYXTCX ( argc , argv , TSYUXOEIH , KYLTSPIN , NULL )
LITERAL 'i' <empty>
<operator>.assignment QBBCOJIQEPCJTEOSEAM = false
LITERAL 't' <empty>
UIBOAESKUTIOVHI UIBOAESKUTIOVHI ( RGFPWJ )
LITERAL '0' <empty>
LITERAL '1' <empty>
LITERAL '2' <empty>
LITERAL '3' <empty>
LITERAL '4' <empty>
LITERAL '5' <empty>
LITERAL '6' <empty>
LITERAL '7' <empty>
LITERAL '8' <empty>
LITERAL '9' <empty>
TAPBWQTNLCOUGYGCMYPKJYQN TAPBWQTNLCOUGYGCMYPKJYQN ( GHWGEOUAQMBN , EUDPXSM )
GTTIG GTTIG ( EXIT_FAILURE )
IDENTIFIER RGFPWJ if (RGFPWJ)
UIBOAESKUTIOVHI UIBOAESKUTIOVHI ( RGFPWJ - 1 )
<operator>.assignment AETYQQUI [ 0 ] = c
<operator>.assignment AETYQQUI [ 1 ] = '\0'
UIBOAESKUTIOVHI UIBOAESKUTIOVHI ( AETYQQUI )
<operator>.subtraction RGFPWJ - 1
<operator>.addressOf & argv [ BQOHUB ]
<operator>.indirectIndexAccess argv [ BQOHUB ]
<operator>.indirectIndexAccess AETYQQUI [ 0 ]
<operator>.indirectIndexAccess AETYQQUI [ 1 ]
>>>PDG&50 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->42 0->43 0->44 0->45 2->4 2->23 3->4 3->5 3->23 4->1 4->1 4->1 4->12 4->18 4->22 4->23 4->23 5->1 5->1 5->23 6->1 6->1 7->1 7->1 7->8 8->1 8->1 9->1 9->1 10->1 10->1 10->1 11->1 12->1 12->1 13->1 14->1 15->1 16->1 16->1 16->1 16->16 16->19 16->20 16->23 16->25 16->27 16->39 16->41 16->42 16->43 16->44 16->45 16->48 16->49 17->15 18->1 18->1 18->1 19->1 19->1 19->16 19->42 20->16 22->1 22->1 22->46 22->47 23->1 23->1 23->1 23->12 23->12 23->16 23->16 23->16 23->16 23->16 23->18 23->18 23->19 23->19 23->19 23->19 23->19 23->22 25->1 25->1 25->1 27->1 27->1 27->45 38->1 38->1 38->1 39->1 39->1 41->1 41->1 42->1 42->1 42->44 43->1 43->1 43->44 44->1 44->1 45->1 45->27 45->41 45->41
>>>Token int main ( int argc , char * * argv ) { int c ; PTWWYAYYKRCIYDN ( & argc , & argv ) ; VBVAFEUTXDQSNFBL ( argv [ 0 ] ) ; XXIUYLTXV ( NBHPEU , " " ) ; LHSNMYIHWNXRBG ( VMETWBS , IWRHKUOAY ) ; LNIEBUFLCE ( VMETWBS ) ; YDVALT ( MPNKQJSNDAXA ) ; QBBCOJIQEPCJTEOSEAM = true ; while ( ( c = RPDEIOYXTCX ( argc , argv , TSYUXOEIH , KYLTSPIN , NULL ) ) != - 1 ) { switch ( c ) { case ' ' : QBBCOJIQEPCJTEOSEAM = false ; break ; case ' ' : UIBOAESKUTIOVHI ( RGFPWJ ) ; break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : if ( RGFPWJ ) UIBOAESKUTIOVHI ( RGFPWJ - 1 ) ; else { char AETYQQUI [ 2 ] ; AETYQQUI [ 0 ] = c ; AETYQQUI [ 1 ] = ' \0 ' ; UIBOAESKUTIOVHI ( AETYQQUI ) ; } break ; YIDKJTKPMXKHGBFNJWWOO ; TAPBWQTNLCOUGYGCMYPKJYQN ( GHWGEOUAQMBN , EUDPXSM ) ; default : GTTIG ( EXIT_FAILURE ) ; } } UASGBMTITTOAILABYE ( ) ; RFYUUWPKFKEQS ( ( BQOHUB < argc ) ? & argv [ BQOHUB ] : NULL ) ; CDWVTY ( ) ; GFBHGFYLFWJEMTMYADUBVJI ( ) ; return QMMTLIPKQXL ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment DNS = 0
<operator>.assignment * WTS = argv [ 1 ]
printf printf ( "Sum is: %d\n" , DNS )
RETURN return 0 ; return 0 ;
<operator>.preIncrement ++ t
LITERAL 0 return 0 ;
<operator>.assignment t = WTS
<operator>.greaterThan * t > 127
<operator>.assignmentPlus DNS += * t
<operator>.assignmentPlus DNS += * t
<operator>.indirection * t
<operator>.indirection * t
<operator>.indirection * t
<operator>.indirection * t
>>>PDG&18 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->1 3->1 3->5 4->1 4->6 4->12 4->13 5->1 5->1 5->10 6->1 6->1 7->1 8->1 8->1 9->7 10->1 10->1 10->1 10->8 11->1 11->8 11->12 11->12 11->13 11->13 11->16 11->17 12->1 12->1 12->6 12->13 13->1 13->1 13->6 13->12 14->8 14->11 14->14 14->15
>>>Token int main ( int argc , char * argv [ ] ) { int i , j ; int DNS = 0 ; const char * WTS = argv [ 1 ] ; register const char * s , * t ; for ( t = WTS ; * t ; ++ t ) { if ( * t > 127 ) DNS += * t ; else DNS += * t ; } printf ( " \n " , DNS ) ; return 0 ; }
>>>Func
METHOD XRPGCGFPSQKIM
METHOD_RETURN long double
PARAM int i
PARAM int n
PARAM int * * EBIFFH
<operator>.assignment KALYAA = 0
<operator>.assignment ETN = 0.0
RETURN return ( ETN ) / ( ( long double ) KALYAA ) ; return ( ETN ) / ( ( long double ) KALYAA ) ;
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.division ( ETN ) / ( ( long double ) KALYAA )
<operator>.assignment j = 0
<operator>.notEquals EBIFFH [ i ] [ j ] != - 1
<operator>.cast ( long double ) KALYAA
<operator>.postIncrement KALYAA ++
<operator>.assignmentPlus ETN += YJHYBWGFGNWBFKJTO ( j , i , n , EBIFFH )
<operator>.minus - 1
YJHYBWGFGNWBFKJTO YJHYBWGFGNWBFKJTO ( j , i , n , EBIFFH )
<operator>.indirectIndexAccess EBIFFH [ i ] [ j ]
<operator>.indirectIndexAccess EBIFFH [ i ]
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 2->1 2->17 3->8 4->1 4->17 5->1 5->10 5->13 5->14 6->1 6->10 6->15 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->12 8->16 8->17 8->17 8->18 8->19 9->1 9->8 10->1 10->1 10->1 10->7 11->1 11->8 12->1 12->1 12->1 12->14 12->15 12->17 13->1 14->1 14->10 14->13 15->1 15->1 15->10 16->12 17->1 17->1 17->8 17->9 17->15 17->15 17->15 17->15
>>>Token long double XRPGCGFPSQKIM ( int i , int n , int * * EBIFFH ) { int j ; int KALYAA = 0 ; long double ETN = 0.0 ; for ( j = 0 ; j < n ; j ++ ) { if ( EBIFFH [ i ] [ j ] != - 1 ) { KALYAA ++ ; ETN += YJHYBWGFGNWBFKJTO ( j , i , n , EBIFFH ) ; } } return ( ETN ) / ( ( long double ) KALYAA ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment YMR [ ] = "AABCAB12AFAABCABFFEGABCAB"
<operator>.assignment FPOG [ ] = "ABCAB"
<operator>.assignment DPJY [ ] = "FFF"
<operator>.assignment BQUP [ ] = "CAB"
printf printf ( "String test: %s\n" , YMR )
printf printf ( "Test1: search pattern %s\n" , FPOG )
GFWOGXMRMNXR GFWOGXMRMNXR ( YMR , FPOG )
printf printf ( "Test2: search pattern %s\n" , DPJY )
GFWOGXMRMNXR GFWOGXMRMNXR ( YMR , DPJY )
printf printf ( "Test3: search pattern %s\n" , BQUP )
GFWOGXMRMNXR GFWOGXMRMNXR ( YMR , BQUP )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 2->6 3->1 3->7 4->1 4->9 5->1 5->11 6->1 6->8 7->1 7->8 8->1 8->1 8->10 9->1 9->10 10->1 10->1 10->12 11->1 11->12 12->1 12->1 12->1 13->1 14->13
>>>Token int main ( ) { char YMR [ ] = " " ; char FPOG [ ] = " " ; char DPJY [ ] = " " ; char BQUP [ ] = " " ; printf ( " \n " , YMR ) ; printf ( " \n " , FPOG ) ; GFWOGXMRMNXR ( YMR , FPOG ) ; printf ( " \n " , DPJY ) ; GFWOGXMRMNXR ( YMR , DPJY ) ; printf ( " \n " , BQUP ) ; GFWOGXMRMNXR ( YMR , BQUP ) ; return 0 ; }
>>>Func
METHOD WQMOYFKYLJBM
METHOD_RETURN void
PARAM char ATQVLF
PARAM char const * VWWE
PARAM char const * TNB
EWNGSFDFMBEKH EWNGSFDFMBEKH ( VWWE )
XXJXIUUNORJ XXJXIUUNORJ ( WIJWDTUVGJUNUVY ? '\t' : '=' )
EWNGSFDFMBEKH EWNGSFDFMBEKH ( TNB )
XXJXIUUNORJ XXJXIUUNORJ ( WIJWDTUVGJUNUVY ? '\n' : ':' )
IDENTIFIER WIJWDTUVGJUNUVY if (WIJWDTUVGJUNUVY)
IDENTIFIER ATQVLF if (ATQVLF)
IDENTIFIER WIJWDTUVGJUNUVY if (WIJWDTUVGJUNUVY)
EWNGSFDFMBEKH EWNGSFDFMBEKH ( "\x1B[" )
EWNGSFDFMBEKH EWNGSFDFMBEKH ( TNB )
XXJXIUUNORJ XXJXIUUNORJ ( 'm' )
XXJXIUUNORJ XXJXIUUNORJ ( ATQVLF )
<operator>.conditional WIJWDTUVGJUNUVY ? '\t' : '='
EWNGSFDFMBEKH EWNGSFDFMBEKH ( "\x1B[0m" )
<operator>.conditional WIJWDTUVGJUNUVY ? '\n' : ':'
>>>PDG&19 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 2->1 2->15 3->5 4->7 4->13 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 12->1 13->7 14->1 15->1 15->1 17->1 18->1
>>>Token static void WQMOYFKYLJBM ( char ATQVLF , char const * VWWE , char const * TNB ) { if ( WIJWDTUVGJUNUVY ) { EWNGSFDFMBEKH ( " \x1B " ) ; EWNGSFDFMBEKH ( TNB ) ; XXJXIUUNORJ ( ' ' ) ; } if ( ATQVLF ) XXJXIUUNORJ ( ATQVLF ) ; EWNGSFDFMBEKH ( VWWE ) ; XXJXIUUNORJ ( WIJWDTUVGJUNUVY ? ' \t ' : ' ' ) ; EWNGSFDFMBEKH ( TNB ) ; if ( WIJWDTUVGJUNUVY ) EWNGSFDFMBEKH ( " \x1B " ) ; XXJXIUUNORJ ( WIJWDTUVGJUNUVY ? ' \n ' : ' ' ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment THLRJP = 1
FPJG FPJG ( t )
CNIPEU CNIPEU ( t , "%d" , & PWBVG )
RETURN return 0 ; return 0 ;
<operator>.postDecrement PWBVG --
LITERAL 0 return 0 ;
FPJG FPJG ( t )
CNIPEU CNIPEU ( t , "%d" , & k )
memset memset ( UBI   - 1   sizeof ( UBI ) )
<operator>.assignment SRX = 0
<operator>.assignment ex = 0
MRFVH MRFVH ( )
<operator>.assignment l = 2 * k - 1
memcpy memcpy ( s   u   sizeof ( s ) )
MRFVH MRFVH ( )
<operator>.assignmentPlus ex += k
<operator>.assignment SRX = ex * ex - k * k
printf printf ( "Case #%d: %d\n" , THLRJP ++ , SRX )
<operator>.lessThan i < 2 * k - 1
<operator>.postIncrement i ++
FPJG FPJG ( s [ i ] )
<operator>.lessThan i < k
<operator>.postIncrement i ++
<operator>.lessThan i < 2 * k - 1
<operator>.postIncrement i ++
<operator>.lessThan i < 2 * k - 1
<operator>.postIncrement i ++
<operator>.lessThan i < k
<operator>.postIncrement i ++
<operator>.lessThan i < 2 * k - 1
<operator>.postIncrement i ++
<operator>.minus - 1
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment i = k
<operator>.assignment m = 2 * k - i
<operator>.subtraction 2 * k - 1
<operator>.assignment i = 0
<operator>.lessThan j < 2 * k - 1
<operator>.postIncrement j ++
<operator>.assignment i = 0
<operator>.assignment i = k
<operator>.assignment m = 2 * k - i
<operator>.subtraction ex * ex - k * k
<operator>.postIncrement THLRJP ++
<operator>.subtraction 2 * k - 1
<operator>.lessEqualsThan j <= i
<operator>.postIncrement j ++
<operator>.assignment UBI [ i ] [ j ] = s [ i ] [ k - i - 1 + j * 2 ] - '0'
<operator>.subtraction 2 * k - 1
<operator>.lessThan j < m
<operator>.postIncrement j ++
<operator>.multiplication 2 * k
<operator>.subtraction 2 * k - 1
<operator>.assignment j = 0
<operator>.assignment u [ l - 1 - j ] [ i ] = s [ i ] [ j ]
<operator>.lessEqualsThan j <= i
<operator>.postIncrement j ++
<operator>.assignment UBI [ i ] [ j ] = s [ i ] [ k - i - 1 + j * 2 ] - '0'
<operator>.subtraction 2 * k - 1
<operator>.lessThan j < m
<operator>.postIncrement j ++
<operator>.multiplication ex * ex
<operator>.multiplication k * k
<operator>.multiplication 2 * k
<operator>.assignment j = 0
<operator>.multiplication 2 * k
<operator>.subtraction 2 * k - i
<operator>.assignment j = 0
<operator>.assignment UBI [ i ] [ j ] = s [ i ] [ i - k + j * 2 + 1 ] - '0'
<operator>.multiplication 2 * k
<operator>.subtraction 2 * k - 1
<operator>.assignment j = 0
<operator>.multiplication 2 * k
<operator>.subtraction 2 * k - i
<operator>.assignment j = 0
<operator>.assignment UBI [ i ] [ j ] = s [ i ] [ i - k + j * 2 + 1 ] - '0'
<operator>.subtraction s [ i ] [ k - i - 1 + j * 2 ] - '0'
<operator>.multiplication 2 * k
<operator>.multiplication 2 * k
<operator>.subtraction s [ i ] [ k - i - 1 + j * 2 ] - '0'
<operator>.multiplication 2 * k
<operator>.subtraction s [ i ] [ i - k + j * 2 + 1 ] - '0'
<operator>.subtraction s [ i ] [ i - k + j * 2 + 1 ] - '0'
<operator>.addition k - i - 1 + j * 2
<operator>.subtraction l - 1 - j
<operator>.addition k - i - 1 + j * 2
<operator>.subtraction k - i - 1
<operator>.multiplication j * 2
<operator>.addition i - k + j * 2 + 1
<operator>.subtraction l - 1
<operator>.subtraction k - i - 1
<operator>.multiplication j * 2
<operator>.addition i - k + j * 2 + 1
<operator>.subtraction k - i
<operator>.addition i - k + j * 2
<operator>.subtraction k - i
<operator>.addition i - k + j * 2
<operator>.subtraction i - k
<operator>.multiplication j * 2
<operator>.subtraction i - k
<operator>.multiplication j * 2
<operator>.addressOf & k
<operator>.sizeOf sizeof ( UBI )
<operator>.sizeOf sizeof ( s )
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess UBI [ i ] [ j ]
<operator>.indirectIndexAccess u [ l - 1 - j ] [ i ]
<operator>.indirectIndexAccess s [ i ] [ j ]
<operator>.indirectIndexAccess UBI [ i ] [ j ]
<operator>.indirectIndexAccess UBI [ i ]
<operator>.indirectIndexAccess s [ i ] [ k - i - 1 + j * 2 ]
<operator>.indirectIndexAccess UBI [ i ] [ j ]
<operator>.indirectIndexAccess u [ l - 1 - j ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess UBI [ i ]
<operator>.indirectIndexAccess s [ i ] [ k - i - 1 + j * 2 ]
<operator>.indirectIndexAccess UBI [ i ] [ j ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess UBI [ i ]
<operator>.indirectIndexAccess s [ i ] [ i - k + j * 2 + 1 ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess UBI [ i ]
<operator>.indirectIndexAccess s [ i ] [ i - k + j * 2 + 1 ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i ]
>>>PDG&128 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->19 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->43 0->46 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->56 0->58 0->59 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->72 0->73 0->74 0->75 0->76 0->77 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->87 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->98 0->100 0->101 0->102 0->103 2->1 2->1 2->46 3->1 3->4 4->1 4->1 4->1 4->6 4->8 5->1 6->1 6->1 6->6 6->8 6->9 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->20 6->23 6->25 6->27 6->29 6->31 6->33 6->34 6->35 6->36 6->38 6->39 6->42 6->43 6->45 6->46 6->47 6->51 6->54 6->55 6->61 6->64 6->65 6->66 6->68 6->72 6->75 6->104 6->105 6->106 7->5 8->1 8->9 9->1 9->1 9->1 9->8 9->17 9->23 9->29 9->36 9->43 9->54 9->65 9->66 9->68 9->72 9->75 9->80 9->81 9->83 9->96 9->98 9->100 9->102 10->1 10->1 10->1 11->1 12->1 12->17 14->1 14->1 14->92 15->1 15->1 15->1 15->22 16->1 17->1 17->64 18->1 18->1 18->19 19->1 19->1 19->1 20->20 20->21 20->21 20->22 20->47 20->66 20->107 21->1 21->20 22->1 22->1 22->15 23->23 23->24 23->36 23->48 23->48 23->67 23->68 23->96 24->1 24->23 25->25 25->26 25->37 25->51 25->52 25->68 25->69 25->69 25->70 25->80 26->1 26->25 27->27 27->28 27->28 27->40 27->55 27->56 27->72 27->73 27->81 28->1 28->27 29->1 29->29 29->30 29->43 29->58 29->58 29->74 29->75 29->98 30->1 30->29 31->1 31->1 31->1 31->31 31->32 31->44 31->61 31->62 31->75 31->76 31->76 31->77 31->83 32->1 32->31 33->10 34->20 35->23 36->25 37->1 37->1 37->52 38->14 38->14 39->27 40->1 40->1 40->40 40->41 40->57 40->73 40->81 40->87 40->87 40->92 40->109 40->110 40->115 40->116 41->1 41->40 42->1 42->29 43->1 43->31 44->1 44->1 44->62 45->1 45->1 45->18 45->18 46->1 46->19 47->20 47->20 48->1 48->1 48->24 48->48 48->49 48->50 48->79 48->86 48->89 48->90 48->90 48->96 48->96 48->108 48->112 48->113 48->120 49->1 49->48 50->1 50->1 50->1 51->25 51->25 52->1 52->1 52->1 52->52 52->53 52->71 52->84 52->91 52->97 52->100 52->101 52->101 52->114 52->121 52->122 52->126 53->1 53->52 54->38 54->38 54->72 55->27 55->27 56->1 56->40 57->1 57->1 57->1 58->1 58->1 58->30 58->58 58->59 58->60 58->82 58->88 58->93 58->94 58->94 58->98 58->98 58->111 58->117 58->118 58->123 59->1 59->58 60->1 60->1 60->1 61->1 61->31 61->31 62->1 62->1 62->1 62->62 62->63 62->78 62->85 62->95 62->99 62->102 62->103 62->103 62->119 62->124 62->125 62->127 63->1 63->62 64->1 64->45 65->1 65->9 65->45 65->66 66->23 66->47 66->47 67->1 67->48 68->51 68->51 68->54 68->80 69->26 69->37 69->37 69->100 70->1 70->52 71->1 71->1 71->1 72->29 72->55 72->55 72->81 73->40 73->40 74->1 74->58 75->17 75->61 75->61 75->65 75->83 76->32 76->44 76->44 76->102 77->1 77->62 78->1 78->1 78->1 79->1 79->22 79->50 79->50 79->82 80->68 80->69 80->69 80->100 81->72 81->73 81->73 82->1 82->22 82->60 82->60 82->79 83->75 83->76 83->76 83->102 84->1 84->22 84->71 84->71 84->85 85->1 85->22 85->78 85->78 85->84 86->1 86->1 87->1 87->41 88->1 88->1 89->1 89->86 89->86 90->49 90->86 90->86 91->1 92->1 92->87 92->87 93->1 93->88 93->88 94->59 94->88 94->88 95->1 96->23 96->48 96->89 96->89 97->1 97->1 98->29 98->58 98->93 98->93 99->1 99->1 100->26 100->68 100->91 100->91 100->97 100->97 101->53 101->91 101->91 101->97 101->97 102->32 102->75 102->95 102->95 102->99 102->99 103->63 103->95 103->95 103->99 103->99
>>>Token int main ( ) { int PWBVG , THLRJP = 1 , i , j , l , m ; FPJG ( t ) ; CNIPEU ( t , " " , & PWBVG ) ; while ( PWBVG -- ) { FPJG ( t ) ; CNIPEU ( t , " " , & k ) ; memset ( UBI , - 1 , sizeof ( UBI ) ) ; for ( i = 0 ; i < 2 * k - 1 ; i ++ ) FPJG ( s [ i ] ) ; for ( i = 0 ; i < k ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) UBI [ i ] [ j ] = s [ i ] [ k - i - 1 + j * 2 ] - ' ' ; } for ( i = k ; i < 2 * k - 1 ; i ++ ) { m = 2 * k - i ; for ( j = 0 ; j < m ; j ++ ) { UBI [ i ] [ j ] = s [ i ] [ i - k + j * 2 + 1 ] - ' ' ; } } SRX = 0 ; ex = 0 ; MRFVH ( ) ; l = 2 * k - 1 ; for ( i = 0 ; i < 2 * k - 1 ; i ++ ) for ( j = 0 ; j < 2 * k - 1 ; j ++ ) { u [ l - 1 - j ] [ i ] = s [ i ] [ j ] ; } memcpy ( s , u , sizeof ( s ) ) ; for ( i = 0 ; i < k ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) UBI [ i ] [ j ] = s [ i ] [ k - i - 1 + j * 2 ] - ' ' ; } for ( i = k ; i < 2 * k - 1 ; i ++ ) { m = 2 * k - i ; for ( j = 0 ; j < m ; j ++ ) { UBI [ i ] [ j ] = s [ i ] [ i - k + j * 2 + 1 ] - ' ' ; } } MRFVH ( ) ; ex += k ; SRX = ex * ex - k * k ; printf ( " \n " , THLRJP ++ , SRX ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment i = 0
CXIGO CXIGO ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < t
LITERAL 0 return 0 ;
<operator>.assignment VQBA = 0
<operator>.assignment j = 0
CXIGO CXIGO ( "%d " , & n )
<operator>.assignment j = 0
CXIGO CXIGO ( "%d " , & n )
<operator>.assignment j = 0
CXIGO CXIGO ( "%d " , & n )
printf printf ( "Case #%d: [" , i + 1 )
printf printf ( "]\n" )
<operator>.postIncrement i ++
<operator>.lessEqualsThan y <= 'Z'
<operator>.postIncrement y ++
<operator>.lessEqualsThan y <= 'Z'
<operator>.postIncrement y ++
<operator>.lessEqualsThan z <= 'Z'
<operator>.postIncrement z ++
<operator>.assignment JKPDBUI [ z ] = '0'
<operator>.lessThan j < n
<operator>.lessThan j < n
<operator>.lessThan j < n
<operator>.lessThan j < VQBA - 1
<operator>.postIncrement j ++
printf printf ( "%c, " , EAPJ [ j ] )
IDENTIFIER VQBA if (VQBA)
<operator>.assignment y = 'A'
<operator>.lessEqualsThan z <= 'Z'
<operator>.postIncrement z ++
<operator>.assignment YNFYIXCO [ y ] [ z ] = '0'
<operator>.assignment y = 'A'
<operator>.lessEqualsThan z <= 'Z'
<operator>.postIncrement z ++
<operator>.assignment XVCGENYE [ y ] [ z ] = '0'
<operator>.assignment z = 'A'
CXIGO CXIGO ( "%c%c%c " , & c1 , & c2 , & CRO )
<operator>.assignment YNFYIXCO [ c1 ] [ c2 ] = CRO
<operator>.assignment YNFYIXCO [ c2 ] [ c1 ] = CRO
<operator>.postIncrement j ++
CXIGO CXIGO ( "%c%c " , & c1 , & c2 )
<operator>.assignment XVCGENYE [ c1 ] [ c2 ] = '1'
<operator>.assignment XVCGENYE [ c2 ] [ c1 ] = '1'
<operator>.postIncrement j ++
CXIGO CXIGO ( "%c" , & CRO )
<operator>.assignment EAPJ [ VQBA ] = CRO
<operator>.postIncrement JKPDBUI [ CRO ] ++
<operator>.postIncrement VQBA ++
<operator>.postIncrement j ++
<operator>.addition i + 1
<operator>.assignment j = 0
printf printf ( "%c" , EAPJ [ VQBA - 1 ] )
<operator>.assignment z = 'A'
<operator>.assignment z = 'A'
<operator>.greaterThan VQBA > 1
<operator>.subtraction VQBA - 1
<operator>.notEquals YNFYIXCO [ EAPJ [ VQBA - 1 ] ] [ EAPJ [ VQBA - 2 ] ] != '0'
<operator>.subtraction VQBA - 1
<operator>.postDecrement JKPDBUI [ EAPJ [ VQBA - 1 ] ] --
<operator>.postDecrement JKPDBUI [ EAPJ [ VQBA - 2 ] ] --
<operator>.assignment EAPJ [ VQBA - 2 ] = YNFYIXCO [ EAPJ [ VQBA - 1 ] ] [ EAPJ [ VQBA - 2 ] ]
<operator>.postDecrement VQBA --
<operator>.lessEqualsThan k <= 'Z'
<operator>.postIncrement k ++
<operator>.subtraction VQBA - 2
<operator>.subtraction VQBA - 2
<operator>.assignment k = 'A'
<operator>.logicalAnd ( XVCGENYE [ EAPJ [ VQBA - 1 ] ] [ k ] != '0' ) && ( JKPDBUI [ k ] != '0' )
<operator>.subtraction VQBA - 1
<operator>.subtraction VQBA - 1
<operator>.subtraction VQBA - 2
<operator>.subtraction VQBA - 2
<operator>.assignment VQBA = 0
<operator>.subtraction VQBA - 1
<operator>.notEquals XVCGENYE [ EAPJ [ VQBA - 1 ] ] [ k ] != '0'
<operator>.notEquals JKPDBUI [ k ] != '0'
<operator>.lessEqualsThan z <= 'Z'
<operator>.postIncrement z ++
<operator>.assignment JKPDBUI [ z ] = '0'
<operator>.assignment z = 'A'
<operator>.subtraction VQBA - 1
<operator>.addressOf & n
<operator>.addressOf & n
<operator>.addressOf & n
<operator>.indirectIndexAccess JKPDBUI [ z ]
<operator>.indirectIndexAccess EAPJ [ j ]
<operator>.indirectIndexAccess YNFYIXCO [ y ] [ z ]
<operator>.indirectIndexAccess XVCGENYE [ y ] [ z ]
<operator>.addressOf & c1
<operator>.addressOf & c2
<operator>.addressOf & CRO
<operator>.indirectIndexAccess YNFYIXCO [ c1 ] [ c2 ]
<operator>.indirectIndexAccess YNFYIXCO [ c2 ] [ c1 ]
<operator>.addressOf & c1
<operator>.addressOf & c2
<operator>.indirectIndexAccess XVCGENYE [ c1 ] [ c2 ]
<operator>.indirectIndexAccess XVCGENYE [ c2 ] [ c1 ]
<operator>.addressOf & CRO
<operator>.indirectIndexAccess EAPJ [ VQBA ]
<operator>.indirectIndexAccess JKPDBUI [ CRO ]
<operator>.indirectIndexAccess EAPJ [ VQBA - 1 ]
<operator>.indirectIndexAccess YNFYIXCO [ y ]
<operator>.indirectIndexAccess XVCGENYE [ y ]
<operator>.indirectIndexAccess YNFYIXCO [ c1 ]
<operator>.indirectIndexAccess YNFYIXCO [ c2 ]
<operator>.indirectIndexAccess XVCGENYE [ c1 ]
<operator>.indirectIndexAccess XVCGENYE [ c2 ]
<operator>.indirectIndexAccess YNFYIXCO [ EAPJ [ VQBA - 1 ] ] [ EAPJ [ VQBA - 2 ] ]
<operator>.indirectIndexAccess YNFYIXCO [ EAPJ [ VQBA - 1 ] ]
<operator>.indirectIndexAccess EAPJ [ VQBA - 2 ]
<operator>.indirectIndexAccess JKPDBUI [ EAPJ [ VQBA - 1 ] ]
<operator>.indirectIndexAccess JKPDBUI [ EAPJ [ VQBA - 2 ] ]
<operator>.indirectIndexAccess EAPJ [ VQBA - 2 ]
<operator>.indirectIndexAccess YNFYIXCO [ EAPJ [ VQBA - 1 ] ] [ EAPJ [ VQBA - 2 ] ]
<operator>.indirectIndexAccess EAPJ [ VQBA - 1 ]
<operator>.indirectIndexAccess EAPJ [ VQBA - 1 ]
<operator>.indirectIndexAccess EAPJ [ VQBA - 2 ]
<operator>.indirectIndexAccess YNFYIXCO [ EAPJ [ VQBA - 1 ] ]
<operator>.indirectIndexAccess EAPJ [ VQBA - 2 ]
<operator>.indirectIndexAccess EAPJ [ VQBA - 1 ]
<operator>.indirectIndexAccess XVCGENYE [ EAPJ [ VQBA - 1 ] ] [ k ]
<operator>.indirectIndexAccess JKPDBUI [ k ]
<operator>.indirectIndexAccess XVCGENYE [ EAPJ [ VQBA - 1 ] ]
<operator>.indirectIndexAccess JKPDBUI [ z ]
<operator>.indirectIndexAccess EAPJ [ VQBA - 1 ]
>>>PDG&129 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->65 0->66 0->67 0->68 0->69 0->70 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 2->1 2->5 3->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->14 5->15 5->16 5->16 5->17 5->19 5->21 5->24 5->25 5->26 5->27 5->31 5->35 5->39 5->53 5->53 5->54 5->55 5->59 5->61 5->85 5->86 5->87 5->104 6->4 7->1 7->51 7->59 8->24 9->11 9->24 9->25 10->25 11->13 11->25 11->26 12->26 13->1 13->1 13->9 13->24 13->26 14->1 14->1 15->1 16->1 16->5 17->17 17->18 17->18 17->32 17->56 18->1 18->17 19->1 19->1 19->19 19->20 19->20 19->36 19->57 20->1 20->19 21->1 21->1 21->21 21->22 21->22 21->23 21->88 22->1 22->21 23->1 23->1 24->11 24->24 24->25 24->40 24->41 24->42 24->43 24->43 24->92 24->93 24->94 24->95 24->96 24->107 24->108 25->13 25->25 25->26 25->44 25->45 25->46 25->47 25->47 25->97 25->98 25->99 25->100 25->109 25->110 26->1 26->1 26->9 26->24 26->26 26->48 26->49 26->50 26->51 26->52 26->52 26->58 26->101 26->102 26->103 27->1 27->1 27->1 27->27 27->28 27->28 27->29 27->59 27->89 28->1 28->27 29->1 29->1 31->17 32->32 32->33 32->33 32->34 32->90 32->105 33->1 33->32 34->1 34->1 35->1 35->19 36->36 36->37 36->37 36->38 36->91 36->106 37->1 37->36 38->1 38->1 39->1 39->21 40->1 40->1 40->1 40->1 40->41 40->42 40->44 40->44 40->48 40->49 41->1 41->1 42->1 42->1 42->1 43->1 43->24 44->1 44->1 44->1 44->40 44->40 45->1 45->1 46->1 46->1 47->1 47->25 48->1 48->1 48->40 48->41 48->49 49->1 49->1 49->1 50->1 50->1 51->1 51->58 52->1 52->26 54->1 54->27 55->1 55->1 56->32 57->36 58->1 58->51 58->59 58->60 58->68 58->72 58->72 58->111 58->112 58->113 58->118 59->1 59->27 59->27 59->61 60->1 60->1 60->62 60->63 60->64 60->64 60->65 60->66 60->69 60->70 60->73 60->74 60->75 60->77 60->114 60->115 60->116 60->117 60->119 60->120 60->121 60->122 60->123 61->1 62->1 62->1 63->1 63->1 64->1 64->1 64->1 65->1 65->51 65->59 66->1 66->1 66->66 66->67 66->67 66->71 66->78 66->84 66->124 66->126 66->128 67->1 67->66 68->51 68->59 68->73 68->84 69->77 70->1 70->66 71->1 71->1 71->1 71->76 71->80 71->83 72->68 73->74 74->69 75->65 76->1 76->51 76->59 76->84 77->75 78->1 78->71 78->71 78->79 78->125 79->1 79->71 79->71 80->1 80->1 80->80 80->81 80->81 80->82 80->127 81->1 81->80 82->1 82->1 83->1 83->80 84->51 84->59
>>>Token int main ( ) { char YNFYIXCO [ 100 ] [ 100 ] , XVCGENYE [ 100 ] [ 100 ] , JKPDBUI [ 100 ] , c1 , c2 , CRO ; int VQBA , i = 0 , j , k , t , n ; char z , y ; char EAPJ [ 100 ] ; CXIGO ( " " , & t ) ; while ( i < t ) { for ( y = ' ' ; y <= ' ' ; y ++ ) for ( z = ' ' ; z <= ' ' ; z ++ ) YNFYIXCO [ y ] [ z ] = ' ' ; for ( y = ' ' ; y <= ' ' ; y ++ ) for ( z = ' ' ; z <= ' ' ; z ++ ) XVCGENYE [ y ] [ z ] = ' ' ; for ( z = ' ' ; z <= ' ' ; z ++ ) JKPDBUI [ z ] = ' ' ; VQBA = 0 ; j = 0 ; CXIGO ( " " , & n ) ; while ( j < n ) { CXIGO ( " " , & c1 , & c2 , & CRO ) ; YNFYIXCO [ c1 ] [ c2 ] = CRO ; YNFYIXCO [ c2 ] [ c1 ] = CRO ; j ++ ; } j = 0 ; CXIGO ( " " , & n ) ; while ( j < n ) { CXIGO ( " " , & c1 , & c2 ) ; XVCGENYE [ c1 ] [ c2 ] = ' ' ; XVCGENYE [ c2 ] [ c1 ] = ' ' ; j ++ ; } j = 0 ; CXIGO ( " " , & n ) ; while ( j < n ) { CXIGO ( " " , & CRO ) ; EAPJ [ VQBA ] = CRO ; JKPDBUI [ CRO ] ++ ; VQBA ++ ; if ( VQBA > 1 ) { if ( YNFYIXCO [ EAPJ [ VQBA - 1 ] ] [ EAPJ [ VQBA - 2 ] ] != ' ' ) { JKPDBUI [ EAPJ [ VQBA - 1 ] ] -- ; JKPDBUI [ EAPJ [ VQBA - 2 ] ] -- ; EAPJ [ VQBA - 2 ] = YNFYIXCO [ EAPJ [ VQBA - 1 ] ] [ EAPJ [ VQBA - 2 ] ] ; VQBA -- ; } else for ( k = ' ' ; k <= ' ' ; k ++ ) if ( ( XVCGENYE [ EAPJ [ VQBA - 1 ] ] [ k ] != ' ' ) && ( JKPDBUI [ k ] != ' ' ) ) { VQBA = 0 ; for ( z = ' ' ; z <= ' ' ; z ++ ) JKPDBUI [ z ] = ' ' ; } } j ++ ; } printf ( " " , i + 1 ) ; for ( j = 0 ; j < VQBA - 1 ; j ++ ) printf ( " " , EAPJ [ j ] ) ; if ( VQBA ) printf ( " " , EAPJ [ VQBA - 1 ] ) ; printf ( " \n " ) ; i ++ ; } return 0 ; }
>>>Func
METHOD DRVAC
METHOD_RETURN void
PARAM char * LSNR
PARAM int STA
<operator>.assignment CXYP = 0
<operator>.assignment JJON = 0
<operator>.assignment JYGG = 0
<operator>.assignment EMUXMWWNPIWG = 0
<operator>.assignment XSH = 0
<operator>.assignmentPlus EMUXMWWNPIWG += 1
<operator>.assignment EFNSA = 0
<operator>.assignment XSH = 0
<operator>.assignmentPlus EMUXMWWNPIWG += 1
<operator>.assignment EFNSA = 0
<operator>.assignment XSH = 0
<operator>.assignmentPlus EMUXMWWNPIWG += 1
<operator>.assignment EFNSA = 0
<operator>.assignment XSH = 0
KCNWK KCNWK ( DNNKCI , XSH , STA )
<operator>.logicalAnd LSNR [ EMUXMWWNPIWG ] >= '0' && LSNR [ EMUXMWWNPIWG ] <= '9'
<operator>.lessThan EFNSA < CXYP
<operator>.logicalAnd LSNR [ EMUXMWWNPIWG ] >= '0' && LSNR [ EMUXMWWNPIWG ] <= '9'
<operator>.lessThan EFNSA < JJON
<operator>.logicalAnd LSNR [ EMUXMWWNPIWG ] >= '0' && LSNR [ EMUXMWWNPIWG ] <= '9'
<operator>.lessThan EFNSA < JYGG
<operator>.assignmentMultiplication CXYP *= 10
<operator>.assignmentPlus CXYP += LSNR [ EMUXMWWNPIWG ] - '0'
<operator>.assignmentPlus EMUXMWWNPIWG += 1
<operator>.assignment VJFFPN [ XSH ] = LSNR [ EMUXMWWNPIWG ++ ]
<operator>.assignment LGUIEHID [ ( int ) VJFFPN [ XSH ++ ] - 'A' ] = 1
<operator>.assignment VJFFPN [ XSH ] = LSNR [ EMUXMWWNPIWG ++ ]
<operator>.assignment WXLUEKGM [ ( int ) VJFFPN [ XSH ++ ] - 'A' ] = 1
<operator>.assignment VJFFPN [ XSH ++ ] = LSNR [ EMUXMWWNPIWG ++ ]
<operator>.assignmentPlus EMUXMWWNPIWG += 1
<operator>.assignmentPlus EFNSA += 1
<operator>.assignmentMultiplication JJON *= 10
<operator>.assignmentPlus JJON += LSNR [ EMUXMWWNPIWG ] - '0'
<operator>.assignmentPlus EMUXMWWNPIWG += 1
<operator>.assignment VKVVCH [ XSH ] = LSNR [ EMUXMWWNPIWG ++ ]
<operator>.assignment RXANJXLNF [ ( int ) VKVVCH [ XSH ++ ] - 'A' ] = 1
<operator>.assignment VKVVCH [ XSH ] = LSNR [ EMUXMWWNPIWG ++ ]
<operator>.assignment OCTAGCNMA [ ( int ) VKVVCH [ XSH ++ ] - 'A' ] = 1
<operator>.assignmentPlus EMUXMWWNPIWG += 1
<operator>.assignmentPlus EFNSA += 1
<operator>.assignmentMultiplication JYGG *= 10
<operator>.assignmentPlus JYGG += LSNR [ EMUXMWWNPIWG ] - '0'
<operator>.assignmentPlus EMUXMWWNPIWG += 1
<operator>.assignment DNNKCI [ XSH ++ ] = LSNR [ EMUXMWWNPIWG ++ ]
<operator>.assignmentPlus EFNSA += 1
<operator>.greaterEqualsThan LSNR [ EMUXMWWNPIWG ] >= '0'
<operator>.lessEqualsThan LSNR [ EMUXMWWNPIWG ] <= '9'
<operator>.greaterEqualsThan LSNR [ EMUXMWWNPIWG ] >= '0'
<operator>.lessEqualsThan LSNR [ EMUXMWWNPIWG ] <= '9'
<operator>.greaterEqualsThan LSNR [ EMUXMWWNPIWG ] >= '0'
<operator>.lessEqualsThan LSNR [ EMUXMWWNPIWG ] <= '9'
<operator>.greaterEqualsThan XSH >= 2
<operator>.greaterEqualsThan XSH >= 2
<operator>.subtraction LSNR [ EMUXMWWNPIWG ] - '0'
<operator>.subtraction LSNR [ EMUXMWWNPIWG ] - '0'
<operator>.subtraction LSNR [ EMUXMWWNPIWG ] - '0'
<operator>.assignment GYFG = 0
<operator>.postIncrement EMUXMWWNPIWG ++
<operator>.subtraction ( int ) VJFFPN [ XSH ++ ] - 'A'
<operator>.postIncrement EMUXMWWNPIWG ++
<operator>.subtraction ( int ) VJFFPN [ XSH ++ ] - 'A'
<operator>.postIncrement XSH ++
<operator>.postIncrement EMUXMWWNPIWG ++
<operator>.postIncrement EMUXMWWNPIWG ++
<operator>.subtraction ( int ) VKVVCH [ XSH ++ ] - 'A'
<operator>.postIncrement EMUXMWWNPIWG ++
<operator>.subtraction ( int ) VKVVCH [ XSH ++ ] - 'A'
<operator>.postIncrement XSH ++
<operator>.postIncrement EMUXMWWNPIWG ++
<operator>.logicalNot ! GYFG
<operator>.logicalAnd OCTAGCNMA [ ( int ) DNNKCI [ XSH - 1 ] - 'A' ] && XSH > 0
<operator>.cast ( int ) VJFFPN [ XSH ++ ]
<operator>.cast ( int ) VJFFPN [ XSH ++ ]
<operator>.cast ( int ) VKVVCH [ XSH ++ ]
<operator>.assignment GYFG = 1
<operator>.logicalAnd LGUIEHID [ ( int ) DNNKCI [ XSH - 2 ] - 'A' ] && WXLUEKGM [ ( int ) DNNKCI [ XSH - 1 ] - 'A' ]
<operator>.logicalAnd WXLUEKGM [ ( int ) DNNKCI [ XSH - 2 ] - 'A' ] && LGUIEHID [ ( int ) DNNKCI [ XSH - 1 ] - 'A' ]
<operator>.subtraction ( int ) DNNKCI [ XSH - 1 ] - 'A'
<operator>.lessThan FOSI < ( JJON * 2 )
<operator>.assignmentPlus FOSI += 2
<operator>.greaterThan XSH > 0
<operator>.lessThan FOSI < ( JJON * 2 )
<operator>.assignmentPlus FOSI += 2
<operator>.postIncrement XSH ++
<operator>.postIncrement XSH ++
<operator>.postIncrement XSH ++
<operator>.postIncrement XSH ++
<operator>.cast ( int ) DNNKCI [ XSH - 1 ]
<operator>.assignment FOSI = 0
<operator>.subtraction ( int ) DNNKCI [ XSH - 1 ] - 'A'
<operator>.assignment FOSI = 1
<operator>.lessThan FOSI < ( CXYP * 3 )
<operator>.assignmentPlus FOSI += 3
<operator>.lessThan FOSI < ( CXYP * 3 )
<operator>.assignmentPlus FOSI += 3
<operator>.multiplication JJON * 2
<operator>.equals DNNKCI [ XSH - 1 ] == VKVVCH [ FOSI ]
<operator>.logicalNot ! XSH
<operator>.cast ( int ) DNNKCI [ XSH - 1 ]
<operator>.multiplication JJON * 2
<operator>.equals DNNKCI [ XSH - 1 ] == VKVVCH [ FOSI ]
<operator>.logicalNot ! XSH
<operator>.subtraction ( int ) DNNKCI [ XSH - 2 ] - 'A'
<operator>.subtraction ( int ) DNNKCI [ XSH - 1 ] - 'A'
<operator>.assignment FOSI = 0
<operator>.subtraction ( int ) DNNKCI [ XSH - 2 ] - 'A'
<operator>.subtraction ( int ) DNNKCI [ XSH - 1 ] - 'A'
<operator>.assignment FOSI = 0
<operator>.subtraction XSH - 1
<operator>.cast ( int ) DNNKCI [ XSH - 2 ]
<operator>.cast ( int ) DNNKCI [ XSH - 1 ]
<operator>.multiplication CXYP * 3
<operator>.logicalAnd VJFFPN [ FOSI ] == DNNKCI [ XSH - 2 ] && VJFFPN [ FOSI + 1 ] == DNNKCI [ XSH - 1 ]
<operator>.cast ( int ) DNNKCI [ XSH - 2 ]
<operator>.cast ( int ) DNNKCI [ XSH - 1 ]
<operator>.multiplication CXYP * 3
<operator>.logicalAnd VJFFPN [ FOSI ] == DNNKCI [ XSH - 1 ] && VJFFPN [ FOSI + 1 ] == DNNKCI [ XSH - 2 ]
<operator>.lessThan YRIFJ < XSH - 1
<operator>.postIncrement YRIFJ ++
<operator>.subtraction XSH - 1
<operator>.lessThan YRIFJ < XSH - 1
<operator>.postIncrement YRIFJ ++
<operator>.postDecrement XSH --
<operator>.assignment DNNKCI [ XSH - 1 ] = VJFFPN [ FOSI + 2 ]
<operator>.assignment GYFG = 0
<operator>.postDecrement XSH --
<operator>.assignment DNNKCI [ XSH - 1 ] = VJFFPN [ FOSI + 2 ]
<operator>.assignment GYFG = 0
<operator>.subtraction XSH - 1
<operator>.assignment YRIFJ = 0
<operator>.subtraction XSH - 1
<operator>.assignment YRIFJ = 0
<operator>.subtraction XSH - 2
<operator>.subtraction XSH - 1
<operator>.equals VJFFPN [ FOSI ] == DNNKCI [ XSH - 2 ]
<operator>.equals VJFFPN [ FOSI + 1 ] == DNNKCI [ XSH - 1 ]
<operator>.subtraction XSH - 2
<operator>.subtraction XSH - 1
<operator>.equals VJFFPN [ FOSI ] == DNNKCI [ XSH - 1 ]
<operator>.equals VJFFPN [ FOSI + 1 ] == DNNKCI [ XSH - 2 ]
<operator>.subtraction XSH - 1
<operator>.equals DNNKCI [ YRIFJ ] == VKVVCH [ FOSI + 1 ]
<operator>.subtraction XSH - 1
<operator>.equals DNNKCI [ YRIFJ ] == VKVVCH [ FOSI - 1 ]
<operator>.assignment XSH = 0
<operator>.assignment XSH = 0
<operator>.subtraction XSH - 2
<operator>.addition FOSI + 1
<operator>.subtraction XSH - 1
<operator>.subtraction XSH - 1
<operator>.addition FOSI + 2
<operator>.subtraction XSH - 1
<operator>.addition FOSI + 1
<operator>.subtraction XSH - 2
<operator>.subtraction XSH - 1
<operator>.addition FOSI + 2
<operator>.addition FOSI + 1
<operator>.subtraction FOSI - 1
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ]
<operator>.indirectIndexAccess VJFFPN [ XSH ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ++ ]
<operator>.indirectIndexAccess LGUIEHID [ ( int ) VJFFPN [ XSH ++ ] - 'A' ]
<operator>.indirectIndexAccess VJFFPN [ XSH ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ++ ]
<operator>.indirectIndexAccess WXLUEKGM [ ( int ) VJFFPN [ XSH ++ ] - 'A' ]
<operator>.indirectIndexAccess VJFFPN [ XSH ++ ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ++ ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ]
<operator>.indirectIndexAccess VKVVCH [ XSH ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ++ ]
<operator>.indirectIndexAccess RXANJXLNF [ ( int ) VKVVCH [ XSH ++ ] - 'A' ]
<operator>.indirectIndexAccess VKVVCH [ XSH ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ++ ]
<operator>.indirectIndexAccess OCTAGCNMA [ ( int ) VKVVCH [ XSH ++ ] - 'A' ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ]
<operator>.indirectIndexAccess DNNKCI [ XSH ++ ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ++ ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ]
<operator>.indirectIndexAccess LSNR [ EMUXMWWNPIWG ]
<operator>.cast ( int ) VKVVCH [ XSH ++ ]
<operator>.indirectIndexAccess RXANJXLNF [ ( int ) DNNKCI [ XSH - 1 ] - 'A' ]
UNKNOWN int int
<operator>.indirectIndexAccess VJFFPN [ XSH ++ ]
UNKNOWN int int
<operator>.indirectIndexAccess VJFFPN [ XSH ++ ]
UNKNOWN int int
<operator>.indirectIndexAccess VKVVCH [ XSH ++ ]
UNKNOWN int int
<operator>.indirectIndexAccess VKVVCH [ XSH ++ ]
<operator>.indirectIndexAccess OCTAGCNMA [ ( int ) DNNKCI [ XSH - 1 ] - 'A' ]
<operator>.indirectIndexAccess LGUIEHID [ ( int ) DNNKCI [ XSH - 2 ] - 'A' ]
<operator>.indirectIndexAccess WXLUEKGM [ ( int ) DNNKCI [ XSH - 1 ] - 'A' ]
<operator>.indirectIndexAccess WXLUEKGM [ ( int ) DNNKCI [ XSH - 2 ] - 'A' ]
<operator>.indirectIndexAccess LGUIEHID [ ( int ) DNNKCI [ XSH - 1 ] - 'A' ]
UNKNOWN int int
<operator>.indirectIndexAccess DNNKCI [ XSH - 1 ]
UNKNOWN int int
<operator>.indirectIndexAccess DNNKCI [ XSH - 1 ]
<operator>.indirectIndexAccess DNNKCI [ XSH - 1 ]
<operator>.indirectIndexAccess VKVVCH [ FOSI ]
<operator>.indirectIndexAccess DNNKCI [ XSH - 1 ]
<operator>.indirectIndexAccess VKVVCH [ FOSI ]
UNKNOWN int int
<operator>.indirectIndexAccess DNNKCI [ XSH - 2 ]
UNKNOWN int int
<operator>.indirectIndexAccess DNNKCI [ XSH - 1 ]
UNKNOWN int int
<operator>.indirectIndexAccess DNNKCI [ XSH - 2 ]
UNKNOWN int int
<operator>.indirectIndexAccess DNNKCI [ XSH - 1 ]
<operator>.indirectIndexAccess VJFFPN [ FOSI ]
<operator>.indirectIndexAccess DNNKCI [ XSH - 2 ]
<operator>.indirectIndexAccess VJFFPN [ FOSI + 1 ]
<operator>.indirectIndexAccess DNNKCI [ XSH - 1 ]
<operator>.indirectIndexAccess DNNKCI [ XSH - 1 ]
<operator>.indirectIndexAccess VJFFPN [ FOSI + 2 ]
<operator>.indirectIndexAccess VJFFPN [ FOSI ]
<operator>.indirectIndexAccess DNNKCI [ XSH - 1 ]
<operator>.indirectIndexAccess VJFFPN [ FOSI + 1 ]
<operator>.indirectIndexAccess DNNKCI [ XSH - 2 ]
<operator>.indirectIndexAccess DNNKCI [ XSH - 1 ]
<operator>.indirectIndexAccess VJFFPN [ FOSI + 2 ]
<operator>.indirectIndexAccess DNNKCI [ YRIFJ ]
<operator>.indirectIndexAccess VKVVCH [ FOSI + 1 ]
<operator>.indirectIndexAccess DNNKCI [ YRIFJ ]
<operator>.indirectIndexAccess VKVVCH [ FOSI - 1 ]
>>>PDG&234 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->22 0->24 0->25 0->26 0->27 0->29 0->31 0->33 0->34 0->35 0->36 0->37 0->39 0->41 0->42 0->43 0->44 0->45 0->46 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->78 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->101 0->103 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->115 0->119 0->121 0->122 0->123 0->124 0->125 0->126 0->128 0->129 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->140 0->141 0->144 0->146 0->148 0->149 0->150 0->151 0->152 0->153 0->154 0->155 0->156 0->157 0->158 0->159 0->160 0->161 2->1 2->28 2->30 2->32 2->38 2->40 2->47 2->49 2->50 2->51 2->52 2->53 2->54 2->57 2->58 2->59 3->18 4->1 4->20 4->25 5->1 5->22 5->35 6->1 6->24 6->44 7->1 7->9 7->27 9->12 9->37 9->61 10->20 11->87 12->15 12->46 12->67 13->22 14->89 15->1 15->1 15->72 16->1 16->24 17->1 17->18 17->71 18->1 18->1 18->1 18->1 19->19 19->21 19->25 19->26 19->27 19->49 19->57 19->162 19->184 20->1 20->1 20->20 20->28 20->29 20->30 20->31 20->32 20->33 20->34 20->34 20->61 20->62 20->63 20->64 20->65 20->66 20->75 20->76 20->87 20->88 20->115 20->119 20->164 20->165 20->166 20->167 20->168 20->169 20->170 20->171 20->189 20->190 20->191 20->192 21->21 21->23 21->35 21->36 21->37 21->51 21->58 21->172 21->185 22->1 22->1 22->22 22->38 22->39 22->40 22->41 22->42 22->43 22->43 22->67 22->68 22->69 22->70 22->77 22->89 22->90 22->99 22->103 22->174 22->175 22->176 22->177 22->178 22->179 22->187 22->193 22->194 22->195 22->196 23->1 23->1 23->1 23->23 23->44 23->45 23->46 23->53 23->59 23->180 23->186 24->1 24->1 24->1 24->24 24->47 24->48 24->48 24->55 24->56 24->71 24->72 24->182 24->183 25->1 25->26 26->1 26->1 26->20 26->25 27->9 29->1 29->1 30->1 30->1 31->1 31->1 32->1 32->1 32->1 32->62 32->64 32->75 32->76 33->12 33->37 33->61 34->1 34->20 35->1 35->36 36->1 36->1 36->22 36->35 37->12 39->1 39->1 40->1 40->1 40->1 41->1 41->1 42->15 42->46 42->67 43->1 43->22 44->1 44->45 45->1 45->1 45->24 45->44 46->15 47->1 47->1 47->1 47->18 48->1 48->24 49->19 49->19 49->50 49->50 49->51 49->57 49->163 50->19 50->19 50->51 50->57 51->21 51->21 51->52 51->52 51->53 51->58 51->173 52->21 52->21 52->53 52->58 53->1 53->23 53->23 53->54 53->54 53->59 53->181 54->1 54->23 54->23 54->59 55->56 55->60 55->73 55->136 56->1 56->18 56->71 56->74 56->81 56->91 56->93 56->102 56->112 56->112 56->123 56->188 56->197 56->202 56->203 56->204 56->205 57->26 57->26 57->49 58->36 58->36 58->51 59->45 59->45 59->53 60->1 60->73 61->63 63->66 64->1 65->87 66->33 67->69 69->42 70->1 71->55 72->1 73->1 73->1 73->73 73->78 73->79 73->80 73->106 73->109 73->113 73->117 73->136 73->140 73->198 73->200 73->210 73->211 73->214 73->215 74->1 74->1 74->1 74->85 74->94 74->103 77->1 78->1 78->73 79->1 79->1 79->1 79->95 79->108 79->115 80->1 80->1 80->1 80->97 80->111 80->119 82->1 82->1 82->1 82->83 82->100 82->101 82->132 82->160 82->206 82->207 83->1 83->82 84->18 84->71 84->74 84->74 84->134 85->1 85->1 85->1 85->86 85->104 85->105 85->134 85->161 85->208 85->209 86->1 86->85 87->88 88->65 89->90 90->89 92->1 92->82 93->1 94->1 94->85 95->1 95->1 95->1 95->96 95->116 95->138 95->150 95->151 95->154 95->218 95->219 96->1 96->95 97->1 97->1 97->1 97->98 97->120 97->142 97->155 97->156 97->159 97->224 97->225 98->1 98->97 99->1 99->82 99->82 99->103 100->1 100->1 100->18 100->93 100->102 100->104 100->104 100->121 100->133 100->139 100->142 100->144 101->1 101->82 101->83 101->99 101->123 101->132 102->1 103->1 103->85 103->85 103->99 104->1 104->1 104->1 104->18 104->81 104->91 104->93 104->100 104->100 104->102 104->107 104->110 104->114 104->118 104->124 104->135 104->139 104->142 104->146 105->1 105->18 105->71 105->85 105->86 105->103 105->134 107->1 108->1 108->95 109->1 110->1 111->1 111->97 112->123 112->132 114->1 115->1 115->95 115->95 115->119 116->1 116->1 116->1 116->95 116->96 116->115 116->126 116->127 116->128 116->153 116->154 116->222 116->223 117->1 118->1 119->1 119->97 119->97 119->115 120->1 120->1 120->1 120->97 120->98 120->119 120->129 120->130 120->131 120->158 120->159 120->228 120->229 121->1 121->1 121->122 121->145 121->160 121->230 121->231 122->1 122->121 123->18 123->71 123->84 123->134 124->1 124->1 124->1 124->125 124->147 124->161 124->232 124->233 125->1 125->124 126->1 126->153 127->1 127->1 127->1 127->18 127->81 127->91 127->93 127->100 127->102 127->104 127->107 127->110 127->114 127->118 127->139 127->142 128->1 128->73 129->1 129->158 130->1 130->1 130->1 130->18 130->81 130->91 130->93 130->100 130->102 130->104 130->107 130->110 130->114 130->118 130->139 130->142 131->1 131->73 132->101 132->144 133->1 133->121 134->105 134->146 135->1 135->124 136->137 136->140 136->150 137->140 137->150 138->1 138->18 138->109 138->116 138->116 138->117 138->139 138->142 138->143 138->151 138->152 138->220 138->221 139->1 139->1 139->18 139->81 139->91 139->93 139->100 139->102 139->104 139->107 139->110 139->114 139->116 139->116 139->118 139->142 139->143 140->56 140->136 140->141 140->155 141->56 141->136 141->155 142->1 142->1 142->18 142->81 142->91 142->93 142->100 142->102 142->104 142->107 142->110 142->114 142->118 142->120 142->120 142->138 142->139 142->143 142->156 142->157 142->226 142->227 143->1 143->1 143->18 143->106 143->109 143->113 143->117 143->120 143->120 143->138 143->139 144->101 144->121 144->121 145->1 145->1 145->1 145->18 145->121 145->122 145->144 145->147 145->148 146->105 146->124 146->124 147->1 147->1 147->1 147->18 147->124 147->125 147->145 147->146 147->149 148->1 148->101 149->1 149->105 150->126 150->140 150->152 152->126 152->140 152->150 153->140 154->1 155->56 155->129 155->136 155->157 157->56 157->129 157->136 157->155 158->56 158->136 159->1 160->1 161->1 161->86 188->82 188->92 188->99 197->84 198->107 198->114 198->137 198->199 198->212 198->213 200->110 200->118 200->141 200->201 200->216 200->217
>>>Token void DRVAC ( char * LSNR , int STA ) { int CXYP = 0 ; int JJON = 0 ; int JYGG = 0 ; int FOSI ; int YRIFJ ; int EFNSA ; int EMUXMWWNPIWG = 0 ; char VJFFPN [ 36 * 3 ] ; char VKVVCH [ 28 * 2 ] ; char DNNKCI [ 100 ] ; char LGUIEHID [ 26 ] ; char WXLUEKGM [ 26 ] ; char RXANJXLNF [ 26 ] ; char OCTAGCNMA [ 26 ] ; int XSH = 0 ; while ( LSNR [ EMUXMWWNPIWG ] >= ' ' && LSNR [ EMUXMWWNPIWG ] <= ' ' ) { CXYP *= 10 ; CXYP += LSNR [ EMUXMWWNPIWG ] - ' ' ; EMUXMWWNPIWG += 1 ; } EMUXMWWNPIWG += 1 ; EFNSA = 0 ; XSH = 0 ; while ( EFNSA < CXYP ) { VJFFPN [ XSH ] = LSNR [ EMUXMWWNPIWG ++ ] ; LGUIEHID [ ( int ) VJFFPN [ XSH ++ ] - ' ' ] = 1 ; VJFFPN [ XSH ] = LSNR [ EMUXMWWNPIWG ++ ] ; WXLUEKGM [ ( int ) VJFFPN [ XSH ++ ] - ' ' ] = 1 ; VJFFPN [ XSH ++ ] = LSNR [ EMUXMWWNPIWG ++ ] ; EMUXMWWNPIWG += 1 ; EFNSA += 1 ; } while ( LSNR [ EMUXMWWNPIWG ] >= ' ' && LSNR [ EMUXMWWNPIWG ] <= ' ' ) { JJON *= 10 ; JJON += LSNR [ EMUXMWWNPIWG ] - ' ' ; EMUXMWWNPIWG += 1 ; } EMUXMWWNPIWG += 1 ; EFNSA = 0 ; XSH = 0 ; while ( EFNSA < JJON ) { VKVVCH [ XSH ] = LSNR [ EMUXMWWNPIWG ++ ] ; RXANJXLNF [ ( int ) VKVVCH [ XSH ++ ] - ' ' ] = 1 ; VKVVCH [ XSH ] = LSNR [ EMUXMWWNPIWG ++ ] ; OCTAGCNMA [ ( int ) VKVVCH [ XSH ++ ] - ' ' ] = 1 ; EMUXMWWNPIWG += 1 ; EFNSA += 1 ; } while ( LSNR [ EMUXMWWNPIWG ] >= ' ' && LSNR [ EMUXMWWNPIWG ] <= ' ' ) { JYGG *= 10 ; JYGG += LSNR [ EMUXMWWNPIWG ] - ' ' ; EMUXMWWNPIWG += 1 ; } EMUXMWWNPIWG += 1 ; EFNSA = 0 ; XSH = 0 ; while ( EFNSA < JYGG ) { DNNKCI [ XSH ++ ] = LSNR [ EMUXMWWNPIWG ++ ] ; if ( XSH >= 2 ) { char GYFG = 0 ; while ( ! GYFG ) { GYFG = 1 ; if ( LGUIEHID [ ( int ) DNNKCI [ XSH - 2 ] - ' ' ] && WXLUEKGM [ ( int ) DNNKCI [ XSH - 1 ] - ' ' ] ) { for ( FOSI = 0 ; FOSI < ( CXYP * 3 ) ; FOSI += 3 ) { if ( VJFFPN [ FOSI ] == DNNKCI [ XSH - 2 ] && VJFFPN [ FOSI + 1 ] == DNNKCI [ XSH - 1 ] ) { XSH -- ; DNNKCI [ XSH - 1 ] = VJFFPN [ FOSI + 2 ] ; GYFG = 0 ; break ; } } } if ( WXLUEKGM [ ( int ) DNNKCI [ XSH - 2 ] - ' ' ] && LGUIEHID [ ( int ) DNNKCI [ XSH - 1 ] - ' ' ] ) { for ( FOSI = 0 ; FOSI < ( CXYP * 3 ) ; FOSI += 3 ) { if ( VJFFPN [ FOSI ] == DNNKCI [ XSH - 1 ] && VJFFPN [ FOSI + 1 ] == DNNKCI [ XSH - 2 ] ) { XSH -- ; DNNKCI [ XSH - 1 ] = VJFFPN [ FOSI + 2 ] ; GYFG = 0 ; break ; } } } } } if ( XSH >= 2 ) { if ( RXANJXLNF [ ( int ) DNNKCI [ XSH - 1 ] - ' ' ] ) { for ( FOSI = 0 ; FOSI < ( JJON * 2 ) ; FOSI += 2 ) { if ( DNNKCI [ XSH - 1 ] == VKVVCH [ FOSI ] ) { for ( YRIFJ = 0 ; YRIFJ < XSH - 1 ; YRIFJ ++ ) { if ( DNNKCI [ YRIFJ ] == VKVVCH [ FOSI + 1 ] ) { XSH = 0 ; break ; } } } if ( ! XSH ) break ; } } if ( OCTAGCNMA [ ( int ) DNNKCI [ XSH - 1 ] - ' ' ] && XSH > 0 ) { for ( FOSI = 1 ; FOSI < ( JJON * 2 ) ; FOSI += 2 ) { if ( DNNKCI [ XSH - 1 ] == VKVVCH [ FOSI ] ) { for ( YRIFJ = 0 ; YRIFJ < XSH - 1 ; YRIFJ ++ ) { if ( DNNKCI [ YRIFJ ] == VKVVCH [ FOSI - 1 ] ) { XSH = 0 ; break ; } } } if ( ! XSH ) break ; } } } EFNSA += 1 ; } KCNWK ( DNNKCI , XSH , STA ) ; }
>>>Func
METHOD main
METHOD_RETURN int
UEVVVCE UEVVVCE ( "input.txt" , "r" , stdin )
UEVVVCE UEVVVCE ( "output.txt" , "w" , CKVXOH )
PRQGA PRQGA ( "%d " , & ATUD )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < ATUD
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
printf printf ( "Case #%d: " , i + 1 )
LGGJVNQMJL LGGJVNQMJL ( )
<operator>.addition i + 1
>>>PDG&13 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 2->1 3->1 3->1 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->10 6->11 6->12 6->12 7->1 7->6 8->5 9->1 9->6 10->1 10->1 11->1
>>>Token int main ( ) { UEVVVCE ( " " , " " , stdin ) ; UEVVVCE ( " " , " " , CKVXOH ) ; int ATUD ; PRQGA ( " " , & ATUD ) ; int i ; for ( i = 0 ; i < ATUD ; i ++ ) { printf ( " " , i + 1 ) ; LGGJVNQMJL ( ) ; } return 0 ; }
>>>Func
METHOD IJALPJH
METHOD_RETURN int
PARAM char * a
PARAM int an
PARAM char ( * d ) [ 5 ]
PARAM int dn
RETURN return an ; return an ;
<operator>.lessThan i < an
<operator>.postIncrement i ++
IDENTIFIER an return an ;
<operator>.assignment i = 0
<operator>.lessThan j < an
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.notEquals i != j
<operator>.lessThan k < dn
<operator>.postIncrement k ++
<operator>.assignment k = 0
<operator>.logicalOr ( * ( a + i ) == * * ( d + k ) && * ( a + j ) == * ( * ( d + k ) + 1 ) ) || ( * ( a + i ) == * ( * ( d + k ) + 1 ) && * ( a + j ) == * * ( d + k ) )
RETURN return 0 ; return 0 ;
<operator>.logicalAnd * ( a + i ) == * * ( d + k ) && * ( a + j ) == * ( * ( d + k ) + 1 )
<operator>.logicalAnd * ( a + i ) == * ( * ( d + k ) + 1 ) && * ( a + j ) == * * ( d + k )
LITERAL 0 return 0 ;
<operator>.equals * ( a + i ) == * * ( d + k )
<operator>.equals * ( a + j ) == * ( * ( d + k ) + 1 )
<operator>.equals * ( a + i ) == * ( * ( d + k ) + 1 )
<operator>.equals * ( a + j ) == * * ( d + k )
<operator>.addition a + i
<operator>.addition a + j
<operator>.addition * ( d + k ) + 1
<operator>.addition a + i
<operator>.addition * ( d + k ) + 1
<operator>.addition a + j
<operator>.addition d + k
<operator>.addition d + k
<operator>.addition d + k
<operator>.addition d + k
<operator>.indirection * ( a + i )
<operator>.indirection * * ( d + k )
<operator>.indirection * ( a + j )
<operator>.indirection * ( * ( d + k ) + 1 )
<operator>.indirection * ( a + i )
<operator>.indirection * ( * ( d + k ) + 1 )
<operator>.indirection * ( a + j )
<operator>.indirection * * ( d + k )
<operator>.indirection * ( d + k )
<operator>.indirection * ( d + k )
<operator>.indirection * ( d + k )
<operator>.indirection * ( d + k )
>>>PDG&49 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->22 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 2->27 3->7 4->1 5->15 6->1 7->1 7->6 7->8 7->9 7->11 7->11 7->13 7->14 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->7 11->7 11->8 11->14 11->14 12->1 12->11 13->1 13->11 14->1 14->1 14->8 14->11 14->12 14->12 14->15 14->17 14->27 14->28 14->32 15->1 15->1 15->11 15->12 15->16 15->18 15->20 15->23 15->27 15->33 15->33 15->34 15->35 15->36 15->37 15->38 15->45 16->1 16->15 17->1 17->15 18->1 18->1 18->1 18->15 18->16 18->19 19->1 20->1 20->1 20->18 20->18 20->21 20->25 20->30 20->31 20->36 20->41 20->42 20->48 21->1 21->1 21->18 21->18 22->19 23->1 23->1 23->20 23->20 23->24 23->28 23->29 23->29 23->31 23->35 23->39 23->40 23->47 24->1 24->1 24->20 24->20 25->1 25->1 25->21 25->21 25->26 25->32 25->34 25->43 25->44 25->46 26->1 26->1 26->21 26->21 27->1 27->1 28->1 28->1 29->1 30->1 30->1 31->1 32->1 32->1 33->1 33->1 34->1 34->1 35->1 35->1 36->1 36->1
>>>Token int IJALPJH ( char * a , int an , char ( * d ) [ 5 ] , int dn ) { int i , j , k ; for ( i = 0 ; i < an ; i ++ ) for ( j = 0 ; j < an ; j ++ ) if ( i != j ) for ( k = 0 ; k < dn ; k ++ ) if ( ( * ( a + i ) == * * ( d + k ) && * ( a + j ) == * ( * ( d + k ) + 1 ) ) || ( * ( a + i ) == * ( * ( d + k ) + 1 ) && * ( a + j ) == * * ( d + k ) ) ) return 0 ; return an ; }
>>>Func
METHOD XRPGCG
METHOD_RETURN void
PARAM char A [ 100 ] [ 100 ]
PARAM int N
PARAM double WP [ 100 ]
PARAM double FPSQ [ 100 ]
PARAM double KIMEB [ 100 ]
<operator>.assignment i = 0
<operator>.lessThan i < N
<operator>.assignment j = 0
<operator>.assignment IFFH = 0
<operator>.assignment KALYA = 0
<operator>.assignment KIMEB [ i ] = KALYA
<operator>.assignment FPSQ [ i ] = IFFH
<operator>.assignment AETNY = IFFH + KALYA
<operator>.assignment l = ( double ) ( IFFH / AETNY )
<operator>.assignment WP [ i ] = l
<operator>.postIncrement i ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.addition IFFH + KALYA
<operator>.cast ( double ) ( IFFH / AETNY )
<operator>.equals A [ i ] [ j ] == '0'
<operator>.division IFFH / AETNY
<operator>.postIncrement KALYA ++
<operator>.equals A [ i ] [ j ] == '1'
<operator>.postIncrement IFFH ++
<operator>.indirectIndexAccess KIMEB [ i ]
<operator>.indirectIndexAccess FPSQ [ i ]
<operator>.indirectIndexAccess WP [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess A [ i ] [ j ]
<operator>.indirectIndexAccess A [ i ]
<operator>.indirectIndexAccess A [ i ] [ j ]
<operator>.indirectIndexAccess A [ i ]
>>>PDG&35 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 2->1 3->8 4->1 5->1 6->1 7->1 7->8 8->1 8->1 8->1 8->8 8->9 8->10 8->11 8->12 8->13 8->14 8->15 8->16 8->17 8->17 8->18 8->18 8->20 8->21 8->23 8->27 8->28 8->29 8->30 9->18 10->13 10->14 10->20 10->23 10->26 11->12 11->14 11->20 11->24 14->23 15->16 17->1 17->8 18->8 18->18 18->19 18->19 18->22 18->31 18->32 19->18 22->24 22->25 22->25 22->33 22->34 23->15 23->15 23->21 23->21 24->12 24->14 24->20 25->22 25->26 26->13 26->14 26->20 26->23
>>>Token void XRPGCG ( char A [ 100 ] [ 100 ] , int N , double WP [ 100 ] , double FPSQ [ 100 ] , double KIMEB [ 100 ] ) { int i = 0 ; while ( i < N ) { int j = 0 ; double IFFH = 0 ; double KALYA = 0 ; while ( j < N ) { if ( A [ i ] [ j ] == ' ' ) { KALYA ++ ; } else if ( A [ i ] [ j ] == ' ' ) { IFFH ++ ; } j ++ ; } KIMEB [ i ] = KALYA ; FPSQ [ i ] = IFFH ; double AETNY = IFFH + KALYA ; double l = ( double ) ( IFFH / AETNY ) ; WP [ i ] = l ; i ++ ; } }
>>>Func
METHOD PAMKL
METHOD_RETURN int
PARAM int * ENWR
PARAM int CEUC
PARAM int NHQU
PARAM int * r
RETURN return 0 ; return 0 ;
<operator>.lessThan i < CEUC
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.equals ENWR [ i ] == NHQU
RETURN return 1 ; return 1 ;
<operator>.notEquals 0 != r
LITERAL 1 return 1 ;
<operator>.assignment * r = i
<operator>.indirectIndexAccess ENWR [ i ]
<operator>.indirection * r
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->1 2->11 3->7 4->11 5->13 6->1 7->1 7->1 7->1 7->6 7->8 7->11 7->15 7->16 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->1 11->7 11->8 11->12 11->13 12->1 13->1 13->1 13->15 13->17 14->12 15->1 15->1 15->1
>>>Token int PAMKL ( int * ENWR , int CEUC , int NHQU , int * r ) { int i ; for ( i = 0 ; i < CEUC ; i ++ ) { if ( ENWR [ i ] == NHQU ) { if ( 0 != r ) * r = i ; return 1 ; } } return 0 ; }
>>>Func
METHOD PTWWY
METHOD_RETURN void
PARAM int AYYKRC
exit exit ( AYYKRC )
<operator>.notEquals AYYKRC != EXIT_SUCCESS
IYDNVBVAFEUTX IYDNVBVAFEUTX ( )
printf printf ( _ ( "\\012Usage: %s [OPTION]... [FILE]...\n\\012" ) , DQSNFBLXXIUY )
LTXVN LTXVN ( _ ( "\\012Convert tabs in each FILE to spaces, writing to standard output.\n\\012" ) , BHPEUL )
HSNMYIHWNXRBGVM HSNMYIHWNXRBGVM ( )
ETWBSIWRHKUOAYLNIEBUFLC ETWBSIWRHKUOAYLNIEBUFLC ( )
LTXVN LTXVN ( _ ( "\\012  -i, --initial    do not convert tabs after non blanks\n\\012  -t, --tabs=N     have tabs N characters apart, not 8\n\\012" ) , BHPEUL )
EYDVALTMPNKQJSNDAX EYDVALTMPNKQJSNDAX ( )
LTXVN LTXVN ( AQBBCOJIQEPCJTEOSEAMRPD , BHPEUL )
LTXVN LTXVN ( EIOYXTCXTSYUXOEIHKYLTSPINU , BHPEUL )
IBOAESKUTIOVHIRGFPW IBOAESKUTIOVHIRGFPW ( JAETYQQUIYID )
_ _ ( "\\012Usage: %s [OPTION]... [FILE]...\n\\012" )
_ _ ( "\\012Convert tabs in each FILE to spaces, writing to standard output.\n\\012" )
_ _ ( "\\012  -i, --initial    do not convert tabs after non blanks\n\\012  -t, --tabs=N     have tabs N characters apart, not 8\n\\012" )
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->4 3->1 4->1 4->1 4->3 4->5 4->6 4->7 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 5->1 6->1 6->1 6->1 7->1 7->1 7->10 8->1 9->1 10->1 10->1 10->12 11->1 12->1 12->1 12->13 13->1 13->1 13->1 14->1 14->1 15->6 16->7 17->10
>>>Token void PTWWY ( int AYYKRC ) { if ( AYYKRC != EXIT_SUCCESS ) IYDNVBVAFEUTX ( ) ; else { printf ( _ ( " \
>>>Func
METHOD BSHTFLILHT
METHOD_RETURN void
PARAM int GYNWSTA [ ] [ 26 ]
PARAM int SBMACA [ ] [ 26 ]
<operator>.lessThan i < 26
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.lessThan j < 26
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment GYNWSTA [ i ] [ j ] = - 1
<operator>.assignment SBMACA [ i ] [ j ] = - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.indirectIndexAccess GYNWSTA [ i ] [ j ]
<operator>.indirectIndexAccess SBMACA [ i ] [ j ]
<operator>.indirectIndexAccess GYNWSTA [ i ]
<operator>.indirectIndexAccess SBMACA [ i ]
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->12 0->13 2->1 3->1 4->1 4->1 4->4 4->5 4->5 4->7 4->9 5->1 5->4 6->1 6->4 7->7 7->8 7->8 7->10 7->11 7->12 7->13 7->14 7->15 7->16 7->17 8->7 9->7 12->10 13->11
>>>Token static void BSHTFLILHT ( int GYNWSTA [ ] [ 26 ] , int SBMACA [ ] [ 26 ] ) { int i , j ; for ( i = 0 ; i < 26 ; i ++ ) { for ( j = 0 ; j < 26 ; j ++ ) { GYNWSTA [ i ] [ j ] = - 1 ; SBMACA [ i ] [ j ] = - 1 ; } } }
>>>Func
METHOD main
METHOD_RETURN int
THDQK THDQK ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan tt <= T
<operator>.postIncrement tt ++
LITERAL 0 return 0 ;
<operator>.assignment tt = 1
<operator>.assignment LCA = 0
<operator>.assignment JILILRD [ 256 ] [ 256 ] = { 0 }
<operator>.assignment WNWPPUQ [ 256 ] [ 256 ] = { 0 }
THDQK THDQK ( "%d " , & c )
THDQK THDQK ( "%d" , & d )
THDQK THDQK ( "%d %s" , & n , & s )
printf printf ( "Case #%d: [" , tt )
printf printf ( "]\n" )
<operator>.lessThan i < c
<operator>.postIncrement i ++
<operator>.lessThan i < d
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < LCA
<operator>.postIncrement i ++
<operator>.arrayInitializer { 0 }
<operator>.arrayInitializer { 0 }
<operator>.assignment i = 0
THDQK THDQK ( "%s" , & s )
<operator>.assignment JILILRD [ s [ 0 ] ] [ s [ 1 ] ] = s [ 2 ]
<operator>.assignment JILILRD [ s [ 1 ] ] [ s [ 0 ] ] = s [ 2 ]
<operator>.assignment i = 0
THDQK THDQK ( "%s" , & s )
<operator>.assignment WNWPPUQ [ s [ 0 ] ] [ s [ 1 ] ] = 1
<operator>.assignment WNWPPUQ [ s [ 1 ] ] [ s [ 0 ] ] = 1
<operator>.assignment i = 0
<operator>.assignment BNPKVMM [ LCA ++ ] = s [ i ]
<operator>.assignment r = JILILRD [ BNPKVMM [ LCA - 1 ] ] [ BNPKVMM [ LCA - 2 ] ]
<operator>.assignment i = 0
printf printf ( "%c" , BNPKVMM [ i ] )
<operator>.lessThan LCA < 2
<operator>.notEquals r != 0
<operator>.greaterThan i > 0
<operator>.assignmentMinus LCA -= 2
<operator>.assignment BNPKVMM [ LCA ++ ] = r
printf printf ( ", " )
<operator>.postIncrement LCA ++
<operator>.subtraction LCA - 2
<operator>.lessThan j < LCA - 1
<operator>.postIncrement j ++
<operator>.subtraction LCA - 1
<operator>.postIncrement LCA ++
<operator>.assignment j = 0
<operator>.subtraction LCA - 1
<operator>.assignment LCA = 0
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.addressOf & s
<operator>.addressOf & s
<operator>.indirectIndexAccess JILILRD [ s [ 0 ] ] [ s [ 1 ] ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess JILILRD [ s [ 1 ] ] [ s [ 0 ] ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.addressOf & s
<operator>.indirectIndexAccess WNWPPUQ [ s [ 0 ] ] [ s [ 1 ] ]
<operator>.indirectIndexAccess WNWPPUQ [ s [ 1 ] ] [ s [ 0 ] ]
<operator>.indirectIndexAccess BNPKVMM [ LCA ++ ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess JILILRD [ BNPKVMM [ LCA - 1 ] ] [ BNPKVMM [ LCA - 2 ] ]
<operator>.indirectIndexAccess BNPKVMM [ i ]
<operator>.indirectIndexAccess JILILRD [ s [ 0 ] ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess JILILRD [ s [ 1 ] ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess WNWPPUQ [ s [ 0 ] ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess WNWPPUQ [ s [ 1 ] ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess JILILRD [ BNPKVMM [ LCA - 1 ] ]
<operator>.indirectIndexAccess BNPKVMM [ LCA - 2 ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess BNPKVMM [ LCA - 1 ]
<operator>.indirectIndexAccess BNPKVMM [ LCA ++ ]
<operator>.indirectIndexAccess WNWPPUQ [ BNPKVMM [ j ] ] [ s [ i ] ]
<operator>.indirectIndexAccess WNWPPUQ [ BNPKVMM [ j ] ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess BNPKVMM [ j ]
>>>PDG&90 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->30 0->31 0->32 0->33 0->34 0->35 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->14 4->15 4->16 4->18 4->20 4->22 4->24 4->25 4->26 4->30 4->34 4->37 4->54 4->55 4->56 4->57 5->1 5->4 6->3 7->1 7->4 8->1 8->22 8->45 9->1 9->1 10->1 10->1 10->1 11->1 11->1 11->16 12->1 12->1 12->18 13->1 13->1 13->1 13->20 13->27 13->31 13->35 14->1 14->5 15->1 16->1 16->1 16->11 16->16 16->17 16->17 16->27 16->28 16->29 16->58 16->59 16->60 16->61 16->62 16->70 16->71 16->72 16->73 16->80 16->81 17->1 17->16 18->1 18->1 18->12 18->18 18->19 18->19 18->31 18->32 18->33 18->63 18->64 18->65 18->74 18->75 18->76 18->77 18->82 18->83 19->1 19->18 20->1 20->1 20->13 20->20 20->21 20->21 20->35 20->39 20->45 20->66 20->67 21->1 21->20 22->1 22->1 22->1 22->22 22->23 22->38 22->41 22->41 22->69 23->1 23->22 24->9 25->10 26->16 27->1 27->13 27->31 27->35 28->1 28->1 29->1 29->1 29->1 30->18 31->1 31->13 31->35 32->1 32->1 33->1 33->1 34->20 35->1 35->1 35->1 36->1 36->1 36->40 37->1 37->22 38->1 38->1 39->1 39->22 39->36 39->40 39->45 39->46 39->49 39->49 39->68 39->78 39->79 39->84 40->1 40->1 40->42 40->43 40->43 40->47 40->50 40->51 40->52 40->85 41->1 41->23 41->44 42->1 42->50 43->1 43->1 43->1 44->1 45->39 46->42 46->52 47->1 47->1 47->1 47->48 47->86 47->87 47->88 47->89 48->1 48->47 49->46 50->22 50->45 51->1 51->47 52->22 52->45 52->47 52->47 53->1 53->22 53->45 86->47 86->48 86->52 86->53
>>>Token int main ( ) { int T ; THDQK ( " " , & T ) ; for ( int tt = 1 ; tt <= T ; tt ++ ) { char BNPKVMM [ 100 ] ; int LCA = 0 ; char JILILRD [ 256 ] [ 256 ] = { 0 } ; char WNWPPUQ [ 256 ] [ 256 ] = { 0 } ; int c ; THDQK ( " " , & c ) ; for ( int i = 0 ; i < c ; i ++ ) { char s [ 4 ] ; THDQK ( " " , & s ) ; JILILRD [ s [ 0 ] ] [ s [ 1 ] ] = s [ 2 ] ; JILILRD [ s [ 1 ] ] [ s [ 0 ] ] = s [ 2 ] ; } int d ; THDQK ( " " , & d ) ; for ( int i = 0 ; i < d ; i ++ ) { char s [ 3 ] ; THDQK ( " " , & s ) ; WNWPPUQ [ s [ 0 ] ] [ s [ 1 ] ] = 1 ; WNWPPUQ [ s [ 1 ] ] [ s [ 0 ] ] = 1 ; } int n ; char s [ 101 ] ; THDQK ( " " , & n , & s ) ; for ( int i = 0 ; i < n ; i ++ ) { BNPKVMM [ LCA ++ ] = s [ i ] ; if ( LCA < 2 ) continue ; char r = JILILRD [ BNPKVMM [ LCA - 1 ] ] [ BNPKVMM [ LCA - 2 ] ] ; if ( r != 0 ) { LCA -= 2 ; BNPKVMM [ LCA ++ ] = r ; } else { for ( int j = 0 ; j < LCA - 1 ; j ++ ) if ( WNWPPUQ [ BNPKVMM [ j ] ] [ s [ i ] ] ) { LCA = 0 ; break ; } } } printf ( " " , tt ) ; for ( int i = 0 ; i < LCA ; i ++ ) { if ( i > 0 ) printf ( " " ) ; printf ( " " , BNPKVMM [ i ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD WIKKF
METHOD_RETURN void
PARAM QKTXCVJBA * WQTU
<operator>.assignment * UOQO = WQTU
printf printf ( "\n" )
<operator>.notEquals UOQO != NULL
printf printf ( "\t" )
printf printf ( "[%lf] -- " , UOQO -> LFMFC )
printf printf ( "[%lf]" , UOQO -> MCT )
<operator>.assignment UOQO = UOQO -> EBCR
<operator>.indirectFieldAccess UOQO -> LFMFC
<operator>.indirectFieldAccess UOQO -> MCT
<operator>.indirectFieldAccess UOQO -> EBCR
FIELD_IDENTIFIER LFMFC LFMFC
FIELD_IDENTIFIER MCT MCT
FIELD_IDENTIFIER EBCR EBCR
>>>PDG&16 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->3 3->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->15 6->1 7->1 7->1 8->1 8->1 9->1 9->1 9->5
>>>Token void WIKKF ( QKTXCVJBA * WQTU ) { QKTXCVJBA * UOQO = WQTU ; while ( UOQO != NULL ) { printf ( " \t " ) ; printf ( " " , UOQO -> LFMFC ) ; printf ( " " , UOQO -> MCT ) ; UOQO = UOQO -> EBCR ; } printf ( " \n " ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment NNL = XDVHK ( "input.in" , "r" )
<operator>.assignment SNII = XDVHK ( "output.txt" , "w" )
TKALUA TKALUA ( NNL , "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
XDVHK XDVHK ( "input.in" , "r" )
XDVHK XDVHK ( "output.txt" , "w" )
<operator>.assignment i = 0
<operator>.assignment EXC = - 1
TKALUA TKALUA ( NNL , "%d" , & c )
TKALUA TKALUA ( NNL , "%d" , & d )
TKALUA TKALUA ( NNL , "%d" , & n )
TKALUA TKALUA ( NNL , "%s" , ip )
fprintf fprintf ( SNII , "Case #%d: [" , i + 1 )
fprintf fprintf ( SNII , "]\n" )
<operator>.lessThan j < c
<operator>.postIncrement j ++
<operator>.lessThan j < d
<operator>.postIncrement j ++
<operator>.lessThan x < n
<operator>.postIncrement x ++
<operator>.lessEqualsThan k <= EXC
<operator>.postIncrement k ++
<operator>.minus - 1
<operator>.assignment j = 0
TKALUA TKALUA ( NNL , "%s" , IBVV )
<operator>.assignment c1 [ j ] = IBVV [ 0 ]
<operator>.assignment c2 [ j ] = IBVV [ 1 ]
<operator>.assignment cr [ j ] = IBVV [ 2 ]
<operator>.assignment j = 0
TKALUA TKALUA ( NNL , "%s" , IBVV )
<operator>.assignment d1 [ j ] = IBVV [ 0 ]
<operator>.assignment d2 [ j ] = IBVV [ 1 ]
<operator>.assignment x = 0
<operator>.addition i + 1
<operator>.assignment k = 0
<operator>.equals EXC == - 1
<operator>.logicalNot ! k
<operator>.assignment EQRWP [ ++ EXC ] = ip [ x ]
fprintf fprintf ( SNII , "%c" , EQRWP [ k ] )
<operator>.minus - 1
<operator>.assignment POKX = 0
fprintf fprintf ( SNII , ", %c" , EQRWP [ k ] )
<operator>.lessThan j < c
<operator>.postIncrement j ++
<operator>.logicalNot ! POKX
<operator>.logicalNot ! POKX
<operator>.preIncrement ++ EXC
<operator>.assignment j = 0
<operator>.assignment EQRWP [ ++ EXC ] = ip [ x ]
<operator>.logicalOr ( c1 [ j ] == EQRWP [ EXC ] && ip [ x ] == c2 [ j ] ) || ( c1 [ j ] == ip [ x ] && EQRWP [ EXC ] == c2 [ j ] )
<operator>.lessEqualsThan k <= EXC
<operator>.postIncrement k ++
<operator>.assignment EQRWP [ EXC ] = cr [ j ]
<operator>.assignment POKX = 1
<operator>.assignment k = 0
<operator>.logicalAnd c1 [ j ] == EQRWP [ EXC ] && ip [ x ] == c2 [ j ]
<operator>.logicalAnd c1 [ j ] == ip [ x ] && EQRWP [ EXC ] == c2 [ j ]
<operator>.lessThan j < d
<operator>.postIncrement j ++
IDENTIFIER POKX if (POKX)
<operator>.preIncrement ++ EXC
<operator>.equals c1 [ j ] == EQRWP [ EXC ]
<operator>.equals ip [ x ] == c2 [ j ]
<operator>.equals c1 [ j ] == ip [ x ]
<operator>.equals EQRWP [ EXC ] == c2 [ j ]
<operator>.assignment j = 0
<operator>.logicalOr ( d1 [ j ] == EQRWP [ k ] && ip [ x ] == d2 [ j ] ) || ( d1 [ j ] == ip [ x ] && EQRWP [ k ] == d2 [ j ] )
<operator>.assignment EXC = - 1
<operator>.assignment POKX = 1
<operator>.logicalAnd d1 [ j ] == EQRWP [ k ] && ip [ x ] == d2 [ j ]
<operator>.logicalAnd d1 [ j ] == ip [ x ] && EQRWP [ k ] == d2 [ j ]
<operator>.equals d1 [ j ] == EQRWP [ k ]
<operator>.equals ip [ x ] == d2 [ j ]
<operator>.equals d1 [ j ] == ip [ x ]
<operator>.equals EQRWP [ k ] == d2 [ j ]
<operator>.minus - 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess c1 [ j ]
<operator>.indirectIndexAccess IBVV [ 0 ]
<operator>.indirectIndexAccess c2 [ j ]
<operator>.indirectIndexAccess IBVV [ 1 ]
<operator>.indirectIndexAccess cr [ j ]
<operator>.indirectIndexAccess IBVV [ 2 ]
<operator>.indirectIndexAccess d1 [ j ]
<operator>.indirectIndexAccess IBVV [ 0 ]
<operator>.indirectIndexAccess d2 [ j ]
<operator>.indirectIndexAccess IBVV [ 1 ]
<operator>.indirectIndexAccess EQRWP [ ++ EXC ]
<operator>.indirectIndexAccess ip [ x ]
<operator>.indirectIndexAccess EQRWP [ k ]
<operator>.indirectIndexAccess EQRWP [ k ]
<operator>.indirectIndexAccess EQRWP [ ++ EXC ]
<operator>.indirectIndexAccess ip [ x ]
<operator>.indirectIndexAccess EQRWP [ EXC ]
<operator>.indirectIndexAccess cr [ j ]
<operator>.indirectIndexAccess c1 [ j ]
<operator>.indirectIndexAccess EQRWP [ EXC ]
<operator>.indirectIndexAccess ip [ x ]
<operator>.indirectIndexAccess c2 [ j ]
<operator>.indirectIndexAccess c1 [ j ]
<operator>.indirectIndexAccess ip [ x ]
<operator>.indirectIndexAccess EQRWP [ EXC ]
<operator>.indirectIndexAccess c2 [ j ]
<operator>.indirectIndexAccess d1 [ j ]
<operator>.indirectIndexAccess EQRWP [ k ]
<operator>.indirectIndexAccess ip [ x ]
<operator>.indirectIndexAccess d2 [ j ]
<operator>.indirectIndexAccess d1 [ j ]
<operator>.indirectIndexAccess ip [ x ]
<operator>.indirectIndexAccess EQRWP [ k ]
<operator>.indirectIndexAccess d2 [ j ]
>>>PDG&118 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->33 0->34 0->37 0->38 0->39 0->40 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->55 0->56 0->58 0->59 0->62 0->63 0->64 0->65 0->70 0->73 0->80 2->1 2->1 2->4 3->1 3->1 3->1 3->17 4->1 4->1 4->1 4->6 4->13 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->12 6->13 6->14 6->15 6->16 6->17 6->17 6->18 6->19 6->21 6->23 6->25 6->27 6->28 6->33 6->37 6->38 6->38 6->39 6->81 6->82 6->83 7->1 7->6 8->5 9->2 9->2 10->3 10->3 11->1 11->6 12->1 12->1 12->25 12->40 13->1 13->1 13->14 13->19 13->29 13->47 14->1 14->1 14->15 14->21 14->34 14->62 15->1 15->1 15->16 15->23 16->1 16->1 16->1 16->13 16->42 16->53 16->67 16->68 16->77 16->78 17->1 17->1 17->18 17->43 17->46 18->1 18->1 18->17 19->1 19->1 19->13 19->19 19->20 19->20 19->29 19->30 19->31 19->32 19->47 19->84 19->85 19->86 19->87 19->88 19->89 20->1 20->19 21->1 21->1 21->1 21->14 21->21 21->22 21->22 21->34 21->35 21->36 21->62 21->90 21->91 21->92 21->93 22->1 22->21 23->1 23->1 23->1 23->15 23->23 23->24 23->24 23->40 23->44 24->1 24->23 25->1 25->1 25->1 25->25 25->26 25->41 25->41 26->1 26->25 27->12 28->19 29->1 29->1 29->14 29->30 29->31 29->32 29->34 30->1 30->1 30->1 30->66 31->1 31->1 31->1 31->67 31->69 32->1 32->1 32->1 32->57 33->1 33->21 34->1 34->1 34->15 34->29 34->30 34->31 34->35 34->36 35->1 35->1 35->1 35->76 36->1 36->1 36->1 36->77 36->79 37->1 37->23 39->1 39->25 40->1 40->1 40->25 40->42 40->45 40->47 40->49 40->50 40->51 40->51 40->52 40->55 40->65 40->94 40->95 41->1 41->26 41->43 41->46 41->96 41->97 42->1 42->1 42->1 43->1 43->1 43->18 43->46 43->46 43->76 44->40 45->1 45->49 46->1 46->1 46->18 46->43 46->43 46->76 47->1 47->1 47->1 47->13 47->19 47->48 47->54 47->60 47->66 47->102 47->103 48->1 48->47 49->50 49->55 49->59 50->1 50->1 50->53 50->65 50->98 50->99 51->25 51->40 52->1 52->47 53->1 53->1 53->1 54->1 54->1 54->1 54->47 54->48 54->57 54->58 54->100 54->101 55->25 55->40 55->55 55->56 55->56 55->62 55->65 55->70 56->1 56->55 57->1 57->1 57->1 57->66 58->1 58->49 59->55 60->1 60->1 60->54 60->54 60->61 60->68 60->106 60->107 61->1 61->1 61->54 61->54 62->1 62->1 62->1 62->14 62->21 62->63 62->71 62->74 62->76 62->110 62->111 63->1 63->62 65->25 65->40 66->1 66->1 66->60 66->60 66->67 66->68 66->69 66->104 66->105 67->1 67->1 67->16 67->42 67->53 67->60 67->60 67->68 67->69 67->77 67->78 68->1 68->1 68->16 68->42 68->53 68->61 68->61 68->66 68->67 68->69 68->77 68->78 68->108 68->109 69->1 69->1 69->61 69->61 69->66 69->67 70->1 70->62 71->1 71->1 71->1 71->62 71->63 71->72 71->73 71->80 72->1 72->1 72->25 72->40 72->55 72->65 73->1 73->50 74->1 74->1 74->71 74->71 74->75 74->78 74->114 74->115 75->1 75->1 75->71 75->71 76->1 76->1 76->43 76->46 76->74 76->74 76->77 76->78 76->79 76->112 76->113 77->1 77->1 77->16 77->42 77->53 77->67 77->68 77->74 77->74 77->78 77->79 78->1 78->1 78->16 78->42 78->53 78->67 78->68 78->75 78->75 78->76 78->77 78->79 78->116 78->117 79->1 79->1 79->43 79->46 79->75 79->75 79->76 79->77 80->72
>>>Token int main ( ) { int T , c , d , n , EXC , i , j , k , x , POKX ; char ip [ 100 ] , c1 [ 10 ] , c2 [ 10 ] , cr [ 10 ] , IBVV [ 4 ] , d1 [ 10 ] , d2 [ 10 ] , EQRWP [ 100 ] ; VJVS * NNL , * SNII ; NNL = XDVHK ( " " , " " ) ; SNII = XDVHK ( " " , " " ) ; TKALUA ( NNL , " " , & T ) ; for ( i = 0 ; i < T ; i ++ ) { EXC = - 1 ; TKALUA ( NNL , " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) { TKALUA ( NNL , " " , IBVV ) ; c1 [ j ] = IBVV [ 0 ] ; c2 [ j ] = IBVV [ 1 ] ; cr [ j ] = IBVV [ 2 ] ; } TKALUA ( NNL , " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) { TKALUA ( NNL , " " , IBVV ) ; d1 [ j ] = IBVV [ 0 ] ; d2 [ j ] = IBVV [ 1 ] ; } TKALUA ( NNL , " " , & n ) ; TKALUA ( NNL , " " , ip ) ; for ( x = 0 ; x < n ; x ++ ) { if ( EXC == - 1 ) EQRWP [ ++ EXC ] = ip [ x ] ; else { POKX = 0 ; for ( j = 0 ; j < c ; j ++ ) { if ( ( c1 [ j ] == EQRWP [ EXC ] && ip [ x ] == c2 [ j ] ) || ( c1 [ j ] == ip [ x ] && EQRWP [ EXC ] == c2 [ j ] ) ) { EQRWP [ EXC ] = cr [ j ] ; POKX = 1 ; break ; } } if ( ! POKX ) { for ( k = 0 ; k <= EXC ; k ++ ) { for ( j = 0 ; j < d ; j ++ ) { if ( ( d1 [ j ] == EQRWP [ k ] && ip [ x ] == d2 [ j ] ) || ( d1 [ j ] == ip [ x ] && EQRWP [ k ] == d2 [ j ] ) ) { EXC = - 1 ; POKX = 1 ; break ; } } if ( POKX ) break ; } } if ( ! POKX ) EQRWP [ ++ EXC ] = ip [ x ] ; } } fprintf ( SNII , " " , i + 1 ) ; for ( k = 0 ; k <= EXC ; k ++ ) { if ( ! k ) fprintf ( SNII , " " , EQRWP [ k ] ) ; else fprintf ( SNII , " " , EQRWP [ k ] ) ; } fprintf ( SNII , " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment VFWU = RCKJL ( "input.txt" , "r" )
<operator>.assignment JKUAI = RCKJL ( "output.txt" , "w" )
OGLNVT OGLNVT ( VFWU , "%d " , & T )
FPPBYA FPPBYA ( VFWU )
FPPBYA FPPBYA ( JKUAI )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
RCKJL RCKJL ( "input.txt" , "r" )
RCKJL RCKJL ( "output.txt" , "w" )
<operator>.assignment i = 1
OGLNVT OGLNVT ( VFWU , "%d " , & C )
OGLNVT OGLNVT ( VFWU , "%d " , & D )
OGLNVT OGLNVT ( VFWU , "%d " , & N )
VJQGTPOFJKS VJQGTPOFJKS ( OHEW , N , YWPG , C , GLU , D )
<operator>.assignment h = 0
<operator>.greaterThan C > 0
<operator>.greaterThan D > 0
<operator>.lessEqualsThan j <= N
<operator>.postIncrement j ++
OGLNVT OGLNVT ( VFWU , "%c" , & OHEW [ j ] )
<operator>.postIncrement h ++
<operator>.logicalOr ( h > N ) || ( OHEW [ h ] == '?' )
<operator>.greaterThan h > N
<operator>.assignment YWPG [ 0 ] [ 0 ] = 'T'
<operator>.assignment GLU [ 0 ] [ 0 ] = 'T'
<operator>.assignment j = 1
fprintf fprintf ( JKUAI , "Case #%d: []\n" , i )
<operator>.lessEqualsThan j <= C
<operator>.postIncrement j ++
<operator>.assignment YWPG [ 0 ] [ 0 ] = 'F'
<operator>.lessEqualsThan j <= D
<operator>.postIncrement j ++
<operator>.assignment GLU [ 0 ] [ 0 ] = 'F'
<operator>.greaterThan h > N
<operator>.equals OHEW [ h ] == '?'
fprintf fprintf ( JKUAI , "Case #%d: [%c" , i , OHEW [ h ] )
<operator>.postIncrement h ++
fprintf fprintf ( JKUAI , "]\n" )
<operator>.assignment j = 1
OGLNVT OGLNVT ( VFWU , "%c" , & HHYI )
<operator>.assignment j = 1
OGLNVT OGLNVT ( VFWU , "%c" , & HHYI )
<operator>.lessEqualsThan j <= N
<operator>.postIncrement j ++
<operator>.lessEqualsThan k <= 3
<operator>.postIncrement k ++
OGLNVT OGLNVT ( VFWU , "%c" , & YWPG [ j ] [ k ] )
<operator>.lessEqualsThan k <= 2
<operator>.postIncrement k ++
OGLNVT OGLNVT ( VFWU , "%c" , & GLU [ j ] [ k ] )
<operator>.assignment j = h
<operator>.notEquals OHEW [ j ] != '?'
<operator>.assignment k = 1
<operator>.assignment k = 1
fprintf fprintf ( JKUAI , ", %c" , OHEW [ j ] )
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.addressOf & OHEW [ j ]
<operator>.indirectIndexAccess YWPG [ 0 ] [ 0 ]
<operator>.indirectIndexAccess GLU [ 0 ] [ 0 ]
<operator>.indirectIndexAccess OHEW [ j ]
<operator>.indirectIndexAccess OHEW [ h ]
<operator>.indirectIndexAccess YWPG [ 0 ]
<operator>.indirectIndexAccess YWPG [ 0 ] [ 0 ]
<operator>.indirectIndexAccess GLU [ 0 ]
<operator>.indirectIndexAccess GLU [ 0 ] [ 0 ]
<operator>.indirectIndexAccess OHEW [ h ]
<operator>.addressOf & HHYI
<operator>.indirectIndexAccess YWPG [ 0 ]
<operator>.addressOf & HHYI
<operator>.indirectIndexAccess GLU [ 0 ]
<operator>.addressOf & YWPG [ j ] [ k ]
<operator>.addressOf & GLU [ j ] [ k ]
<operator>.indirectIndexAccess OHEW [ j ]
<operator>.indirectIndexAccess YWPG [ j ] [ k ]
<operator>.indirectIndexAccess GLU [ j ] [ k ]
<operator>.indirectIndexAccess OHEW [ j ]
<operator>.indirectIndexAccess YWPG [ j ]
<operator>.indirectIndexAccess GLU [ j ]
>>>PDG&84 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 2->1 2->1 2->4 3->1 3->1 3->6 3->30 3->39 4->1 4->1 4->5 4->8 4->14 5->1 5->1 6->1 6->1 7->1 8->1 8->1 8->1 8->8 8->9 8->14 8->15 8->16 8->17 8->18 8->19 8->20 8->21 8->24 8->25 8->26 8->29 8->30 8->37 8->39 8->59 8->60 8->61 9->1 9->8 10->7 11->2 11->2 12->3 12->3 13->1 13->8 14->1 14->1 14->15 14->17 14->19 14->31 14->43 14->50 15->1 15->1 15->16 15->17 15->20 15->34 15->45 15->53 16->1 16->1 16->5 16->14 16->17 16->21 16->23 16->26 16->37 16->46 17->1 17->1 17->1 17->1 17->1 17->1 17->14 17->15 17->19 17->20 17->23 17->37 17->38 17->39 17->55 17->58 18->1 18->24 19->1 19->17 19->27 19->31 19->31 19->33 19->42 19->63 19->67 19->68 19->73 20->1 20->17 20->28 20->34 20->34 20->36 20->44 20->64 20->69 20->70 20->75 21->1 21->1 21->17 21->21 21->22 21->22 21->23 21->62 21->65 22->1 22->21 23->1 23->1 23->5 23->14 23->17 23->55 23->58 24->1 24->37 25->1 25->1 25->24 25->25 25->37 26->1 26->1 26->1 26->16 26->21 26->30 26->39 26->40 26->40 26->41 26->46 26->46 26->54 26->71 27->1 27->1 28->1 28->1 29->1 29->21 30->1 30->6 30->9 30->39 31->1 31->17 31->31 31->32 31->32 31->43 31->48 31->56 31->72 32->1 32->31 33->1 33->1 34->1 34->17 34->34 34->35 34->35 34->45 34->51 34->57 34->74 35->1 35->34 36->1 36->1 37->24 37->25 37->25 37->26 37->26 37->38 37->66 38->1 38->17 38->25 38->25 38->39 39->1 39->1 39->9 39->17 39->38 39->41 39->58 40->1 40->54 41->1 41->6 41->30 41->39 42->31 43->1 43->1 43->15 43->45 43->50 44->34 45->1 45->1 45->16 45->43 45->53 46->1 46->1 46->1 46->16 46->21 46->46 46->47 46->47 46->55 46->78 47->1 47->46 48->1 48->1 48->48 48->49 48->49 48->50 48->76 48->79 48->82 49->1 49->48 50->1 50->1 50->43 51->1 51->1 51->51 51->52 51->52 51->53 51->77 51->80 51->83 52->1 52->51 53->1 53->1 53->45 54->1 54->1 54->46 55->1 55->1 55->17 55->23 55->58 55->58 55->81 56->1 56->48 57->1 57->51 58->1 58->1 58->17 58->23 58->41 58->55
>>>Token int main ( ) { int T , C , i , j , k , D , N , h ; char OHEW [ 101 ] ; char YWPG [ 37 ] [ 4 ] ; char GLU [ 29 ] [ 3 ] ; char HHYI ; LQTL * VFWU ; LQTL * JKUAI ; VFWU = RCKJL ( " " , " " ) ; JKUAI = RCKJL ( " " , " " ) ; OGLNVT ( VFWU , " " , & T ) ; for ( i = 1 ; i <= T ; i ++ ) { OGLNVT ( VFWU , " " , & C ) ; if ( C > 0 ) { YWPG [ 0 ] [ 0 ] = ' ' ; for ( j = 1 ; j <= C ; j ++ ) { for ( k = 1 ; k <= 3 ; k ++ ) OGLNVT ( VFWU , " " , & YWPG [ j ] [ k ] ) ; OGLNVT ( VFWU , " " , & HHYI ) ; } } else YWPG [ 0 ] [ 0 ] = ' ' ; OGLNVT ( VFWU , " " , & D ) ; if ( D > 0 ) { GLU [ 0 ] [ 0 ] = ' ' ; for ( j = 1 ; j <= D ; j ++ ) { for ( k = 1 ; k <= 2 ; k ++ ) OGLNVT ( VFWU , " " , & GLU [ j ] [ k ] ) ; OGLNVT ( VFWU , " " , & HHYI ) ; } } else GLU [ 0 ] [ 0 ] = ' ' ; OGLNVT ( VFWU , " " , & N ) ; for ( j = 1 ; j <= N ; j ++ ) OGLNVT ( VFWU , " " , & OHEW [ j ] ) ; VJQGTPOFJKS ( OHEW , N , YWPG , C , GLU , D ) ; h = 0 ; do h ++ ; while ( ( h > N ) || ( OHEW [ h ] == ' ' ) ) ; if ( h > N ) fprintf ( JKUAI , " \n " , i ) ; else { fprintf ( JKUAI , " " , i , OHEW [ h ] ) ; h ++ ; for ( j = h ; j <= N ; j ++ ) if ( OHEW [ j ] != ' ' ) fprintf ( JKUAI , " " , OHEW [ j ] ) ; fprintf ( JKUAI , " \n " ) ; } } FPPBYA ( VFWU ) ; FPPBYA ( JKUAI ) ; return 0 ; }
>>>Func
METHOD IFBYM
METHOD_RETURN void
PARAM void
<operator>.lessEqualsThan i <= 100
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.lessEqualsThan j <= 100
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment UOVVCHGUOG [ i ] [ j ] = MSLWAVT ( j , 100 - j , i - j )
MSLWAVT MSLWAVT ( j , 100 - j , i - j )
<operator>.subtraction 100 - j
<operator>.subtraction i - j
<operator>.indirectIndexAccess UOVVCHGUOG [ i ] [ j ]
<operator>.indirectIndexAccess UOVVCHGUOG [ i ]
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 2->1 3->1 3->1 3->3 3->4 3->4 3->6 3->8 3->12 4->1 4->3 5->1 5->3 6->6 6->7 6->9 6->10 6->11 6->11 6->12 6->13 6->14 7->6 8->6 10->7 10->9 10->9 10->9 11->10 11->10 11->12 12->4 12->10 12->10
>>>Token void IFBYM ( void ) { int i , j ; for ( i = 0 ; i <= 100 ; i ++ ) { for ( j = 0 ; j <= 100 ; j ++ ) { UOVVCHGUOG [ i ] [ j ] = MSLWAVT ( j , 100 - j , i - j ) ; } } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment OKXIB = KTKAL ( "case2.txt" , "r" )
UATVWQ UATVWQ ( OKXIB , "%d" , & VVEQRWPVJ )
OSFWCG OSFWCG ( OKXIB )
<operator>.equals OKXIB == 0
<operator>.lessThan i < VVEQRWPVJ
<operator>.postIncrement i ++
KTKAL KTKAL ( "case2.txt" , "r" )
printf printf ( "can not opern\n" )
<operator>.assignment i = 0
<operator>.assignment time = DPKAGGKCBXR ( OKXIB , i )
DPKAGGKCBXR DPKAGGKCBXR ( OKXIB , i )
>>>PDG&13 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 2->1 2->1 2->5 3->1 3->1 3->4 3->6 3->12 4->1 4->1 5->1 5->3 5->9 6->1 6->1 6->1 6->6 6->7 6->11 6->12 6->12 7->1 7->6 8->2 8->2 9->1 10->1 10->6 11->1 11->1 11->1 12->4 12->7 12->11 12->11
>>>Token int main ( ) { EXCP * OKXIB ; int VVEQRWPVJ ; int VSNNLSNII ; int i ; int time ; char XDVH [ 101 ] ; OKXIB = KTKAL ( " " , " " ) ; if ( OKXIB == 0 ) { printf ( " \n " ) ; } UATVWQ ( OKXIB , " " , & VVEQRWPVJ ) ; for ( i = 0 ; i < VVEQRWPVJ ; i ++ ) { time = DPKAGGKCBXR ( OKXIB , i ) ; } OSFWCG ( OKXIB ) ; }
>>>Func
METHOD NFBSLBK
METHOD_RETURN int
PARAM int d
<operator>.assignment JCK = 0
RETURN return JCK ; return JCK ;
IDENTIFIER d for (i = 0 ;d;i ++)
<operator>.postIncrement i ++
IDENTIFIER JCK return JCK ;
<operator>.assignment i = 0
<operator>.assignment OQY = d % 10
<operator>.assignmentMultiplication OQY *= OQY
<operator>.assignmentPlus JCK += OQY
<operator>.assignmentDivision d /= 10
<operator>.modulo d % 10
>>>PDG&14 0->2 0->3 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 2->1 2->13 3->1 3->1 3->7 3->11 4->1 6->1 6->1 7->4 8->1 8->1 8->6 9->1 9->1 9->10 9->11 10->1 10->11 11->1 11->1 11->1 11->7 12->1 12->1 12->13 13->9 13->9 13->12
>>>Token int NFBSLBK ( int d ) { int i , JCK , OQY ; JCK = 0 ; for ( i = 0 ; d ; i ++ ) { OQY = d % 10 ; OQY *= OQY ; JCK += OQY ; d /= 10 ; } return JCK ; }
>>>Func
METHOD DRKD
METHOD_RETURN void
PARAM char c
<operator>.assignment QCOCW [ TDC ++ ] = c
<operator>.postIncrement TDC ++
>>>PDG&5 0->2 0->3 0->4 2->3 3->1 3->1 3->1 4->1
>>>Token void DRKD ( char c ) { QCOCW [ TDC ++ ] = c ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment YESK [ ] = { ' '   'Q'   'W'   'E'   'R'   'A'   'S'   'D'   'F' }
PNYTI PNYTI ( "%d" , & TSAC )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= 8
<operator>.postIncrement i ++
<operator>.assignment LQW [ YESK [ i ] ] = i
<operator>.lessEqualsThan m <= TSAC
<operator>.postIncrement m ++
LITERAL 0 return 0 ;
<operator>.arrayInitializer { ' '   'Q'   'W'   'E'   'R'   'A'   'S'   'D'   'F' }
<operator>.assignment i = 0
<operator>.assignment m = 1
<operator>.assignment k = - 1
<operator>.assignment AMYCNRL [ 9 ] = { 0 }
PNYTI PNYTI ( "%d" , & WAA )
PNYTI PNYTI ( "%d" , & WAA )
PNYTI PNYTI ( "%d" , & YQJR )
PNYTI PNYTI ( "%s" , QUH )
printf printf ( "]\n" )
<operator>.lessEqualsThan i <= 8
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= 8
<operator>.postIncrement i ++
<operator>.lessThan j < WAA
<operator>.postIncrement j ++
<operator>.lessThan j < WAA
<operator>.postIncrement j ++
<operator>.lessThan j < strlen ( QUH )
<operator>.postIncrement j ++
<operator>.notEquals k != - 1
<operator>.lessEqualsThan i <= k
<operator>.postIncrement i ++
printf printf ( ", %c" , FCV [ i ] )
<operator>.minus - 1
<operator>.assignment i = 0
<operator>.lessEqualsThan j <= 8
<operator>.postIncrement j ++
<operator>.assignment JPBLSLFN [ i ] [ j ] = 0
<operator>.assignment i = 0
<operator>.lessEqualsThan j <= 8
<operator>.postIncrement j ++
<operator>.assignment YJUAVPX [ i ] [ j ] = 0
<operator>.arrayInitializer { 0 }
<operator>.assignment j = 0
PNYTI PNYTI ( "%s" , PAMKLENW )
FFDEVSDRB FFDEVSDRB ( PAMKLENW )
<operator>.assignment j = 0
PNYTI PNYTI ( "%s" , RCEUCNH )
OIEADRFQ OIEADRFQ ( RCEUCNH )
<operator>.assignment j = 0
printf printf ( "Case #%d: [%c" , m , FCV [ 0 ] )
<operator>.assignment i = 1
<operator>.assignment j = 0
<operator>.assignment j = 0
strlen strlen ( QUH )
<operator>.logicalAnd k != - 1 && ( WAA = JPBLSLFN [ LQW [ FCV [ k ] ] ] [ LQW [ QUH [ j ] ] ] )
<operator>.minus - 1
printf printf ( "Case #%d: [" , m )
<operator>.assignment FCV [ k ] = WAA
<operator>.notEquals k != - 1
<operator>.assignment WAA = JPBLSLFN [ LQW [ FCV [ k ] ] ] [ LQW [ QUH [ j ] ] ]
<operator>.minus - 1
<operator>.logicalAnd k != - 1 && ( WAA = JPBLSLFN [ LQW [ FCV [ k ] ] ] [ LQW [ QUH [ j ] ] ] )
<operator>.assignment FCV [ k ] = WAA
<operator>.notEquals k != - 1
<operator>.assignment WAA = JPBLSLFN [ LQW [ FCV [ k ] ] ] [ LQW [ QUH [ j ] ] ]
<operator>.minus - 1
<operator>.lessEqualsThan i <= 8
<operator>.postIncrement i ++
<operator>.equals i == 9
<operator>.assignment i = 1
<operator>.assignment FCV [ ++ k ] = QUH [ j ]
<operator>.assignment AMYCNRL [ LQW [ QUH [ j ] ] ] = 1
<operator>.logicalOr YJUAVPX [ i ] [ LQW [ QUH [ j ] ] ] || YJUAVPX [ LQW [ QUH [ j ] ] ] [ i ]
<operator>.preIncrement ++ k
SQLSO SQLSO ( AMYCNRL   sizeof ( AMYCNRL ) )
<operator>.assignment k = - 1
<operator>.minus - 1
<operator>.indirectIndexAccess LQW [ YESK [ i ] ]
<operator>.indirectIndexAccess YESK [ i ]
<operator>.addressOf & WAA
<operator>.addressOf & WAA
<operator>.addressOf & YQJR
<operator>.indirectIndexAccess FCV [ i ]
<operator>.indirectIndexAccess JPBLSLFN [ i ] [ j ]
<operator>.indirectIndexAccess YJUAVPX [ i ] [ j ]
<operator>.indirectIndexAccess FCV [ 0 ]
<operator>.indirectIndexAccess JPBLSLFN [ i ]
<operator>.indirectIndexAccess YJUAVPX [ i ]
<operator>.indirectIndexAccess JPBLSLFN [ LQW [ FCV [ k ] ] ] [ LQW [ QUH [ j ] ] ]
<operator>.indirectIndexAccess FCV [ k ]
<operator>.indirectIndexAccess JPBLSLFN [ LQW [ FCV [ k ] ] ]
<operator>.indirectIndexAccess LQW [ QUH [ j ] ]
<operator>.indirectIndexAccess LQW [ FCV [ k ] ]
<operator>.indirectIndexAccess QUH [ j ]
<operator>.indirectIndexAccess FCV [ k ]
<operator>.indirectIndexAccess JPBLSLFN [ LQW [ FCV [ k ] ] ] [ LQW [ QUH [ j ] ] ]
<operator>.indirectIndexAccess FCV [ k ]
<operator>.indirectIndexAccess JPBLSLFN [ LQW [ FCV [ k ] ] ]
<operator>.indirectIndexAccess LQW [ QUH [ j ] ]
<operator>.indirectIndexAccess LQW [ FCV [ k ] ]
<operator>.indirectIndexAccess QUH [ j ]
<operator>.indirectIndexAccess FCV [ k ]
<operator>.indirectIndexAccess AMYCNRL [ i ]
<operator>.indirectIndexAccess FCV [ ++ k ]
<operator>.indirectIndexAccess QUH [ j ]
<operator>.indirectIndexAccess AMYCNRL [ LQW [ QUH [ j ] ] ]
<operator>.indirectIndexAccess LQW [ QUH [ j ] ]
<operator>.indirectIndexAccess QUH [ j ]
<operator>.indirectIndexAccess YJUAVPX [ i ] [ LQW [ QUH [ j ] ] ]
<operator>.indirectIndexAccess YJUAVPX [ LQW [ QUH [ j ] ] ] [ i ]
<operator>.indirectIndexAccess YJUAVPX [ i ]
<operator>.indirectIndexAccess LQW [ QUH [ j ] ]
<operator>.indirectIndexAccess YJUAVPX [ LQW [ QUH [ j ] ] ]
<operator>.sizeOf sizeof ( AMYCNRL )
<operator>.indirectIndexAccess QUH [ j ]
<operator>.indirectIndexAccess LQW [ QUH [ j ] ]
<operator>.indirectIndexAccess QUH [ j ]
>>>PDG&120 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->58 0->59 0->60 0->61 0->63 0->65 0->66 0->68 0->69 0->70 0->71 0->72 0->74 0->76 0->77 0->79 2->1 2->1 2->1 3->1 3->1 3->8 4->1 5->1 5->1 5->5 5->6 5->6 5->7 5->7 5->80 5->81 6->1 6->5 7->1 7->1 8->1 8->1 8->1 8->8 8->9 8->14 8->15 8->16 8->17 8->18 8->19 8->20 8->21 8->23 8->25 8->27 8->29 8->31 8->32 8->35 8->36 8->40 8->44 8->45 8->48 8->51 8->52 8->53 8->56 8->58 8->59 8->82 8->83 8->84 9->1 9->8 10->4 11->2 11->2 11->2 11->2 11->2 11->2 11->2 11->2 11->2 12->1 12->5 13->1 13->8 14->1 14->31 14->61 15->1 15->1 15->1 16->17 16->25 16->27 17->1 17->1 17->16 17->25 17->27 17->60 17->65 18->1 18->1 19->1 19->56 20->1 21->21 21->22 21->22 21->37 21->54 22->1 22->21 23->1 23->23 23->24 23->24 23->41 23->55 24->1 24->23 25->17 25->25 25->26 25->26 25->27 25->46 25->47 26->1 26->25 27->1 27->1 27->16 27->25 27->27 27->28 27->28 27->49 27->50 27->60 27->65 28->1 28->27 29->1 29->1 29->1 29->29 29->30 29->30 29->56 29->57 29->61 29->63 30->1 30->29 31->1 31->1 31->32 31->52 31->59 31->88 32->1 32->1 32->1 32->32 32->33 32->33 32->34 32->85 33->1 33->32 34->1 34->1 35->14 36->21 37->1 37->37 37->38 37->38 37->39 37->86 37->89 38->1 38->37 39->1 39->1 40->1 40->23 41->1 41->41 41->42 41->42 41->43 41->87 41->90 42->1 42->41 43->1 43->1 44->15 45->25 46->1 46->47 47->1 47->1 47->46 48->27 49->1 49->50 50->1 50->1 50->49 51->1 51->29 52->1 52->1 52->9 53->1 53->32 54->37 55->41 56->1 56->19 56->29 56->73 57->1 57->1 57->60 57->64 57->64 57->66 57->68 57->92 58->31 59->1 59->9 60->1 60->1 60->1 61->31 61->57 61->57 61->62 61->66 61->91 61->93 61->94 61->95 61->96 61->97 62->1 62->1 62->16 62->25 62->57 62->60 62->65 63->61 64->1 64->1 64->57 64->65 64->69 64->71 64->72 64->99 65->1 65->1 65->1 66->31 66->61 66->64 66->64 66->67 66->76 66->98 66->100 66->101 66->102 66->103 66->104 67->1 67->1 67->16 67->25 67->60 67->64 67->65 68->66 69->1 69->70 69->71 69->105 70->1 70->69 71->1 71->73 71->74 71->76 71->106 71->107 71->108 71->109 71->110 72->69 73->1 73->1 73->1 74->1 74->1 74->77 75->1 75->1 75->1 75->69 75->70 75->77 75->78 75->79 75->116 76->31 76->61 77->1 77->1 78->1 78->31 78->61 78->76 79->78 105->69 105->70 105->75 105->111 105->113 105->114 105->117 111->112 111->115 111->118 111->119
>>>Token int main ( ) { char PAMKLENW [ 5 ] , RCEUCNH [ 5 ] , QUH [ 100 ] , FCV [ 100 ] ; char YESK [ ] = { ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' } ; int m , TSAC , KRSM , EFY , i , j , KSVE , k , WAA , YQJR ; for ( i = 0 ; i <= 8 ; i ++ ) LQW [ YESK [ i ] ] = i ; PNYTI ( " " , & TSAC ) ; for ( m = 1 ; m <= TSAC ; m ++ ) { k = - 1 ; for ( i = 0 ; i <= 8 ; i ++ ) for ( j = 0 ; j <= 8 ; j ++ ) JPBLSLFN [ i ] [ j ] = 0 ; for ( i = 0 ; i <= 8 ; i ++ ) for ( j = 0 ; j <= 8 ; j ++ ) YJUAVPX [ i ] [ j ] = 0 ; int AMYCNRL [ 9 ] = { 0 } ; PNYTI ( " " , & WAA ) ; for ( j = 0 ; j < WAA ; j ++ ) { PNYTI ( " " , PAMKLENW ) ; FFDEVSDRB ( PAMKLENW ) ; } PNYTI ( " " , & WAA ) ; for ( j = 0 ; j < WAA ; j ++ ) { PNYTI ( " " , RCEUCNH ) ; OIEADRFQ ( RCEUCNH ) ; } PNYTI ( " " , & YQJR ) ; PNYTI ( " " , QUH ) ; for ( j = 0 ; j < strlen ( QUH ) ; j ++ ) { if ( k != - 1 && ( WAA = JPBLSLFN [ LQW [ FCV [ k ] ] ] [ LQW [ QUH [ j ] ] ] ) ) { FCV [ k ] = WAA ; } else if ( k != - 1 && ( WAA = JPBLSLFN [ LQW [ FCV [ k ] ] ] [ LQW [ QUH [ j ] ] ] ) ) { FCV [ k ] = WAA ; } else { for ( i = 1 ; i <= 8 ; i ++ ) { if ( AMYCNRL [ i ] ) { if ( YJUAVPX [ i ] [ LQW [ QUH [ j ] ] ] || YJUAVPX [ LQW [ QUH [ j ] ] ] [ i ] ) { SQLSO ( AMYCNRL , sizeof ( AMYCNRL ) ) ; k = - 1 ; break ; } } } if ( i == 9 ) { FCV [ ++ k ] = QUH [ j ] ; AMYCNRL [ LQW [ QUH [ j ] ] ] = 1 ; } } } if ( k != - 1 ) printf ( " " , m , FCV [ 0 ] ) ; else printf ( " " , m ) ; for ( i = 1 ; i <= k ; i ++ ) printf ( " " , FCV [ i ] ) ; printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD VPUYDEP
METHOD_RETURN int
PARAM char LOFREBMUTSQW [ ]
PARAM int EVNYDBHFX
PARAM char OAANRUM [ ] [ 4 ]
PARAM char C
<operator>.assignment i = 0
RETURN return EVNYDBHFX ; return EVNYDBHFX ;
<operator>.lessThan i < C
<operator>.postIncrement i ++
IDENTIFIER EVNYDBHFX return EVNYDBHFX ;
<operator>.assignment i = 0
<operator>.lessThan EVNYDBHFX < 2
<operator>.logicalOr ( ( LOFREBMUTSQW [ EVNYDBHFX - 2 ] == OAANRUM [ i ] [ 0 ] ) && ( LOFREBMUTSQW [ EVNYDBHFX - 1 ] == OAANRUM [ i ] [ 1 ] ) ) || ( ( LOFREBMUTSQW [ EVNYDBHFX - 1 ] == OAANRUM [ i ] [ 0 ] ) && ( LOFREBMUTSQW [ EVNYDBHFX - 2 ] == OAANRUM [ i ] [ 1 ] ) )
RETURN return EVNYDBHFX ; return EVNYDBHFX ;
<operator>.assignment LOFREBMUTSQW [ EVNYDBHFX - 2 ] = OAANRUM [ i ] [ 2 ]
<operator>.assignment LOFREBMUTSQW [ EVNYDBHFX - 1 ] = 0
<operator>.postDecrement EVNYDBHFX --
IDENTIFIER EVNYDBHFX return EVNYDBHFX ;
<operator>.logicalAnd ( LOFREBMUTSQW [ EVNYDBHFX - 2 ] == OAANRUM [ i ] [ 0 ] ) && ( LOFREBMUTSQW [ EVNYDBHFX - 1 ] == OAANRUM [ i ] [ 1 ] )
<operator>.logicalAnd ( LOFREBMUTSQW [ EVNYDBHFX - 1 ] == OAANRUM [ i ] [ 0 ] ) && ( LOFREBMUTSQW [ EVNYDBHFX - 2 ] == OAANRUM [ i ] [ 1 ] )
<operator>.equals LOFREBMUTSQW [ EVNYDBHFX - 2 ] == OAANRUM [ i ] [ 0 ]
<operator>.equals LOFREBMUTSQW [ EVNYDBHFX - 1 ] == OAANRUM [ i ] [ 1 ]
<operator>.equals LOFREBMUTSQW [ EVNYDBHFX - 1 ] == OAANRUM [ i ] [ 0 ]
<operator>.equals LOFREBMUTSQW [ EVNYDBHFX - 2 ] == OAANRUM [ i ] [ 1 ]
<operator>.subtraction EVNYDBHFX - 2
<operator>.subtraction EVNYDBHFX - 1
<operator>.subtraction EVNYDBHFX - 2
<operator>.subtraction EVNYDBHFX - 1
<operator>.subtraction EVNYDBHFX - 1
<operator>.subtraction EVNYDBHFX - 2
<operator>.indirectIndexAccess LOFREBMUTSQW [ EVNYDBHFX - 2 ]
<operator>.indirectIndexAccess OAANRUM [ i ] [ 2 ]
<operator>.indirectIndexAccess LOFREBMUTSQW [ EVNYDBHFX - 1 ]
<operator>.indirectIndexAccess LOFREBMUTSQW [ EVNYDBHFX - 2 ]
<operator>.indirectIndexAccess OAANRUM [ i ] [ 0 ]
<operator>.indirectIndexAccess LOFREBMUTSQW [ EVNYDBHFX - 1 ]
<operator>.indirectIndexAccess OAANRUM [ i ] [ 1 ]
<operator>.indirectIndexAccess LOFREBMUTSQW [ EVNYDBHFX - 1 ]
<operator>.indirectIndexAccess OAANRUM [ i ] [ 0 ]
<operator>.indirectIndexAccess LOFREBMUTSQW [ EVNYDBHFX - 2 ]
<operator>.indirectIndexAccess OAANRUM [ i ] [ 1 ]
<operator>.indirectIndexAccess OAANRUM [ i ]
<operator>.indirectIndexAccess OAANRUM [ i ]
<operator>.indirectIndexAccess OAANRUM [ i ]
<operator>.indirectIndexAccess OAANRUM [ i ]
<operator>.indirectIndexAccess OAANRUM [ i ]
>>>PDG&47 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->12 0->16 0->17 0->18 0->25 0->26 0->27 0->28 0->29 0->30 2->1 2->21 2->22 2->23 2->24 3->10 3->12 4->1 5->8 7->1 8->1 8->1 8->1 8->7 8->9 8->12 9->1 9->8 10->7 11->1 11->8 12->1 12->1 12->13 12->14 12->18 12->19 12->21 12->27 12->27 12->34 12->35 12->43 13->1 13->1 13->1 13->7 13->8 13->9 13->15 13->16 13->17 13->25 13->26 13->31 13->32 13->33 13->42 14->1 15->1 15->1 15->1 15->21 16->1 16->1 16->22 16->23 17->1 17->10 17->12 18->14 19->1 19->1 19->13 19->13 19->20 19->23 19->29 19->38 19->39 19->45 20->1 20->1 20->13 20->13 21->1 21->19 21->19 21->22 21->23 21->24 21->28 21->36 21->37 21->44 22->1 22->19 22->19 22->23 22->24 23->1 23->20 23->20 23->21 23->24 23->30 23->40 23->41 23->46 24->1 24->20 24->20 24->22 25->26 26->17 27->10 27->25 27->28 27->29 28->10 28->25 28->29 29->10 29->25 29->30 30->10 30->25
>>>Token int VPUYDEP ( char LOFREBMUTSQW [ ] , int EVNYDBHFX , char OAANRUM [ ] [ 4 ] , char C ) { int i = 0 ; for ( i = 0 ; i < C ; i ++ ) { if ( EVNYDBHFX < 2 ) return EVNYDBHFX ; if ( ( ( LOFREBMUTSQW [ EVNYDBHFX - 2 ] == OAANRUM [ i ] [ 0 ] ) && ( LOFREBMUTSQW [ EVNYDBHFX - 1 ] == OAANRUM [ i ] [ 1 ] ) ) || ( ( LOFREBMUTSQW [ EVNYDBHFX - 1 ] == OAANRUM [ i ] [ 0 ] ) && ( LOFREBMUTSQW [ EVNYDBHFX - 2 ] == OAANRUM [ i ] [ 1 ] ) ) ) { LOFREBMUTSQW [ EVNYDBHFX - 2 ] = OAANRUM [ i ] [ 2 ] ; LOFREBMUTSQW [ EVNYDBHFX - 1 ] = 0 ; EVNYDBHFX -- ; } else break ; } return EVNYDBHFX ; }
>>>Func
METHOD FCHVLLUFC
METHOD_RETURN int
PARAM char * p
PARAM char * a
<operator>.assignment M = strlen ( p )
<operator>.assignment N = strlen ( a )
<operator>.logicalAnd j < M && i < N
<operator>.expressionList i ++   j ++
<operator>.equals j == M
strlen strlen ( p )
strlen strlen ( a )
<operator>.expressionList i = 0   j = 0
RETURN return i - M ; return i - M ;
<operator>.lessThan j < M
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.postIncrement j ++
<operator>.notEquals a [ i ] != p [ j ]
<operator>.subtraction i - M
RETURN return - 1 ; return - 1 ;
<operator>.assignment i = 0
<operator>.assignment j = 0
<operator>.assignmentMinus i -= j - 1
<operator>.assignment j = 0
<operator>.minus - 1
<operator>.subtraction j - 1
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess p [ j ]
>>>PDG&28 0->2 0->3 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->18 0->20 0->21 0->22 0->23 0->24 0->25 2->9 3->10 4->1 4->1 4->13 5->1 5->1 5->1 5->14 6->1 6->1 6->1 6->6 6->7 6->13 6->15 6->16 6->17 6->26 6->27 7->1 7->1 7->1 8->1 8->1 8->12 8->18 8->18 8->19 8->24 9->1 9->4 9->17 10->1 10->5 10->17 11->1 11->1 11->1 12->1 13->6 13->6 13->8 13->8 13->14 13->16 13->25 14->1 14->6 14->6 14->15 14->18 14->22 15->7 15->14 15->18 15->22 16->7 16->13 17->1 17->1 17->1 17->17 17->22 17->23 17->25 17->26 17->27 18->1 18->1 18->1 18->12 19->1 20->11 20->14 20->15 20->18 20->22 21->11 21->13 22->1 22->1 22->15 23->1 23->16 23->25 24->19 25->22 25->22
>>>Token int FCHVLLUFC ( char * p , char * a ) { int i , j ; int M = strlen ( p ) , N = strlen ( a ) ; for ( i = 0 , j = 0 ; j < M && i < N ; i ++ , j ++ ) { while ( a [ i ] != p [ j ] ) { i -= j - 1 ; j = 0 ; } } if ( j == M ) return i - M ; else return - 1 ; }
>>>Func
METHOD VPUYDEPL
METHOD_RETURN int
PARAM int n
RETURN return k ; return k ;
<operator>.greaterEqualsThan OFREBM [ n ] [ k ] >= 0
<operator>.postIncrement k ++
IDENTIFIER k return k ;
<operator>.assignment k = 0
<operator>.indirectIndexAccess OFREBM [ n ] [ k ]
<operator>.indirectIndexAccess OFREBM [ n ]
>>>PDG&10 0->2 0->4 0->5 0->6 0->7 2->1 3->1 4->1 4->1 4->4 4->5 4->8 4->9 5->1 5->1 5->6 6->3 7->1 7->1 7->5 7->6
>>>Token int VPUYDEPL ( int n ) { int k ; for ( k = 0 ; OFREBM [ n ] [ k ] >= 0 ; k ++ ) ; return k ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
EFGIA EFGIA ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
<operator>.assignment YGGUB = - 1
EFGIA EFGIA ( "%d" , & HXK )
EFGIA EFGIA ( "%d" , & TQH )
printf printf ( "Case #%d: " , i )
<operator>.lessThan j < 4
<operator>.postIncrement j ++
<operator>.lessThan j < 4
<operator>.postIncrement j ++
<operator>.lessThan j < 4
<operator>.postIncrement j ++
<operator>.logicalNot ! YGGUB
<operator>.minus - 1
<operator>.assignment j = 0
<operator>.lessThan k < 4
<operator>.postIncrement k ++
EFGIA EFGIA ( "%d" , & XRTID [ 0 ] [ j ] [ k ] )
<operator>.assignment j = 0
<operator>.lessThan k < 4
<operator>.postIncrement k ++
EFGIA EFGIA ( "%d" , & XRTID [ 1 ] [ j ] [ k ] )
<operator>.assignment j = 0
printf printf ( "%d\n" , YXL )
<operator>.assignment k = 0
<operator>.assignment k = 0
<operator>.lessThan k < 4
<operator>.postIncrement k ++
<operator>.assignment k = 0
<operator>.greaterThan YGGUB > 0
<operator>.equals XRTID [ 0 ] [ HXK - 1 ] [ j ] == XRTID [ 1 ] [ TQH - 1 ] [ k ]
VPLJ VPLJ ( "Bad magician!" )
<operator>.postIncrement YGGUB ++
<operator>.assignment YXL = XRTID [ 0 ] [ HXK - 1 ] [ j ]
VPLJ VPLJ ( "Volunteer cheated!" )
<operator>.subtraction HXK - 1
<operator>.subtraction TQH - 1
<operator>.subtraction HXK - 1
<operator>.addressOf & HXK
<operator>.addressOf & TQH
<operator>.addressOf & XRTID [ 0 ] [ j ] [ k ]
<operator>.addressOf & XRTID [ 1 ] [ j ] [ k ]
<operator>.indirectIndexAccess XRTID [ 0 ] [ j ] [ k ]
<operator>.indirectIndexAccess XRTID [ 1 ] [ j ] [ k ]
<operator>.indirectIndexAccess XRTID [ 0 ] [ j ]
<operator>.indirectIndexAccess XRTID [ 1 ] [ j ]
<operator>.indirectIndexAccess XRTID [ 0 ]
<operator>.indirectIndexAccess XRTID [ 1 ]
<operator>.indirectIndexAccess XRTID [ 0 ] [ HXK - 1 ] [ j ]
<operator>.indirectIndexAccess XRTID [ 1 ] [ TQH - 1 ] [ k ]
<operator>.indirectIndexAccess XRTID [ 0 ] [ HXK - 1 ]
<operator>.indirectIndexAccess XRTID [ 1 ] [ TQH - 1 ]
<operator>.indirectIndexAccess XRTID [ 0 ] [ HXK - 1 ] [ j ]
<operator>.indirectIndexAccess XRTID [ 0 ]
<operator>.indirectIndexAccess XRTID [ 1 ]
<operator>.indirectIndexAccess XRTID [ 0 ] [ HXK - 1 ]
<operator>.indirectIndexAccess XRTID [ 0 ]
>>>PDG&64 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->41 0->42 0->43 0->44 2->1 3->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->9 5->10 5->11 5->12 5->12 5->13 5->15 5->17 5->19 5->20 5->21 5->25 5->29 5->45 5->46 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->19 9->39 10->1 10->1 10->42 10->44 11->1 11->1 11->43 12->1 12->6 13->13 13->14 13->14 13->22 13->31 14->1 14->13 15->15 15->16 15->16 15->26 15->32 16->1 16->15 17->1 17->1 17->17 17->18 17->18 17->33 17->35 18->1 18->17 19->1 19->1 19->30 19->36 19->36 20->9 21->13 22->1 22->1 22->22 22->23 22->23 22->24 22->47 22->49 22->51 22->53 23->1 23->22 24->1 24->1 25->15 26->1 26->1 26->26 26->27 26->27 26->28 26->48 26->50 26->52 26->54 27->1 27->26 28->1 28->1 29->1 29->17 30->1 30->1 31->1 31->22 32->1 32->26 33->1 33->1 33->33 33->34 33->34 33->37 33->42 33->43 33->55 33->56 33->57 33->58 33->60 33->61 34->1 34->33 35->1 35->33 36->1 36->1 36->38 36->41 37->1 37->1 37->1 37->39 37->40 37->40 37->44 37->59 37->62 37->63 38->1 39->1 39->19 40->1 40->1 40->1 40->30 41->1 42->1 42->10 42->44 43->1 43->11 44->1 44->10 44->42
>>>Token int main ( void ) { int t , XRTID [ 2 ] [ 4 ] [ 4 ] , i , j , k , HXK , TQH , YGGUB , YXL ; EFGIA ( " " , & t ) ; for ( i = 1 ; i <= t ; i ++ ) { YGGUB = - 1 ; EFGIA ( " " , & HXK ) ; for ( j = 0 ; j < 4 ; j ++ ) for ( k = 0 ; k < 4 ; k ++ ) EFGIA ( " " , & XRTID [ 0 ] [ j ] [ k ] ) ; EFGIA ( " " , & TQH ) ; for ( j = 0 ; j < 4 ; j ++ ) for ( k = 0 ; k < 4 ; k ++ ) EFGIA ( " " , & XRTID [ 1 ] [ j ] [ k ] ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( k = 0 ; k < 4 ; k ++ ) { if ( XRTID [ 0 ] [ HXK - 1 ] [ j ] == XRTID [ 1 ] [ TQH - 1 ] [ k ] ) { YGGUB ++ ; YXL = XRTID [ 0 ] [ HXK - 1 ] [ j ] ; } } } printf ( " " , i ) ; if ( ! YGGUB ) printf ( " \n " , YXL ) ; else if ( YGGUB > 0 ) VPLJ ( " " ) ; else VPLJ ( " " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment VJU = 0
printf printf ( "Sum is: %d\n" , VJU )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < argv [ 1 ] [ 0 ]
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.assignmentPlus VJU += i
<operator>.lessThan argc < 2
printf printf ( "Usage: program-name char\n" )
RETURN return 1 ; return 1 ;
LITERAL 1 return 1 ;
<operator>.indirectIndexAccess argv [ 1 ] [ 0 ]
<operator>.indirectIndexAccess argv [ 1 ]
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->12 3->1 4->1 4->1 4->5 4->11 6->1 7->1 7->1 7->1 7->5 7->6 7->8 7->11 7->12 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->5 12->1 12->1 12->7 12->8 12->11 12->13 12->14 12->16 12->17 13->1 14->1 15->14
>>>Token int main ( int argc , char * argv [ ] ) { int i ; int VJU = 0 ; for ( i = 0 ; i < argv [ 1 ] [ 0 ] ; i ++ ) { if ( argc < 2 ) { printf ( " \n " ) ; return 1 ; } VJU += i ; } printf ( " \n " , VJU ) ; return 0 ; }
>>>Func
METHOD YVC
METHOD_RETURN void
PARAM OPWU * FXQH
<operator>.postDecrement FXQH -> BGNEM --
<operator>.assignment AKFU = * ( ( FXQH -> p ) + FXQH -> BGNEM )
<operator>.assignment * ( ( FXQH -> p ) + FXQH -> BGNEM ) = * ( FXQH -> p )
<operator>.assignment * ( FXQH -> p ) = AKFU
ITBDOMXWWGVV ITBDOMXWWGVV ( FXQH , 0 )
<operator>.equals FXQH -> BGNEM == 0
<operator>.lessEqualsThan 4 * FXQH -> BGNEM <= FXQH -> CXLT
RETURN return ; return ;
<operator>.assignmentDivision FXQH -> CXLT /= 2
<operator>.assignment ( FXQH -> p ) = ( int * ) realloc ( ( FXQH -> p )   ( FXQH -> CXLT ) * sizeof ( int ) )
<operator>.addition ( FXQH -> p ) + FXQH -> BGNEM
<operator>.addition ( FXQH -> p ) + FXQH -> BGNEM
<operator>.multiplication 4 * FXQH -> BGNEM
<operator>.cast ( int * ) realloc ( ( FXQH -> p )   ( FXQH -> CXLT ) * sizeof ( int ) )
realloc realloc ( ( FXQH -> p )   ( FXQH -> CXLT ) * sizeof ( int ) )
<operator>.multiplication ( FXQH -> CXLT ) * sizeof ( int )
<operator>.sizeOf sizeof ( int )
<operator>.indirectFieldAccess FXQH -> BGNEM
<operator>.indirection * ( ( FXQH -> p ) + FXQH -> BGNEM )
<operator>.indirection * ( ( FXQH -> p ) + FXQH -> BGNEM )
<operator>.indirection * ( FXQH -> p )
<operator>.indirection * ( FXQH -> p )
FIELD_IDENTIFIER BGNEM BGNEM
<operator>.indirectFieldAccess FXQH -> p
<operator>.indirectFieldAccess FXQH -> p
<operator>.indirectFieldAccess FXQH -> CXLT
<operator>.indirectFieldAccess FXQH -> p
<operator>.indirectFieldAccess FXQH -> BGNEM
<operator>.indirectFieldAccess FXQH -> p
<operator>.indirectFieldAccess FXQH -> BGNEM
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
<operator>.indirectFieldAccess FXQH -> BGNEM
FIELD_IDENTIFIER CXLT CXLT
<operator>.indirectFieldAccess FXQH -> CXLT
<operator>.indirectFieldAccess FXQH -> p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER BGNEM BGNEM
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER BGNEM BGNEM
FIELD_IDENTIFIER BGNEM BGNEM
FIELD_IDENTIFIER CXLT CXLT
FIELD_IDENTIFIER p p
UNKNOWN int * int *
<operator>.indirectFieldAccess FXQH -> p
FIELD_IDENTIFIER p p
<operator>.indirectFieldAccess FXQH -> CXLT
FIELD_IDENTIFIER CXLT CXLT
>>>PDG&51 0->2 0->6 0->7 0->8 0->10 0->11 0->15 2->1 2->7 3->13 3->14 3->15 4->6 6->17 8->1 8->1 8->3 8->3 8->4 8->5 8->6 8->7 8->9 8->10 8->13 8->14 8->15 8->20 8->21 8->22 8->23 8->24 8->25 8->26 8->27 8->28 8->29 8->30 8->31 8->32 8->33 8->34 8->35 8->36 8->39 8->40 8->41 8->42 8->43 9->11 9->11 9->12 9->16 9->17 9->18 9->19 9->37 9->38 9->44 9->45 9->46 9->47 9->48 9->49 9->50 10->1 11->18 15->9 15->9 17->12 17->12 17->16 17->16 18->17 19->1
>>>Token void YVC ( OPWU * FXQH ) { if ( FXQH -> BGNEM == 0 ) return ; FXQH -> BGNEM -- ; int AKFU = * ( ( FXQH -> p ) + FXQH -> BGNEM ) ; * ( ( FXQH -> p ) + FXQH -> BGNEM ) = * ( FXQH -> p ) ; * ( FXQH -> p ) = AKFU ; ITBDOMXWWGVV ( FXQH , 0 ) ; if ( 4 * FXQH -> BGNEM <= FXQH -> CXLT ) { FXQH -> CXLT /= 2 ; ( FXQH -> p ) = ( int * ) realloc ( ( FXQH -> p ) , ( FXQH -> CXLT ) * sizeof ( int ) ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
WMTEPLL WMTEPLL ( "11.in" , "r" , stdin )
WMTEPLL WMTEPLL ( "4.in" , "w" , PCBMXJ )
AAFTM AAFTM ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t1 <= t
<operator>.postIncrement t1 ++
LITERAL 0 return 0 ;
<operator>.assignment t1 = 1
AAFTM AAFTM ( "%d" , & c )
AAFTM AAFTM ( "%d" , & d )
AAFTM AAFTM ( "%d" , & n )
AAFTM AAFTM ( "%s" , HNC )
<operator>.assignment p = 1
<operator>.assignment a [ p ] = HNC [ 0 ]
<operator>.assignment q = p
<operator>.assignment b [ HNC [ 0 ] - 'A' ] = 1
printf printf ( "Case #%d: [" , t1 )
printf printf ( "]\n" )
<operator>.notEquals c != 0
<operator>.notEquals d != 0
<operator>.lessEqualsThan i <= 99
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.notEquals a [ p ] != '\0'
<operator>.lessEqualsThan i <= q
<operator>.postIncrement i ++
printf printf ( ", %c" , a [ i ] )
AAFTM AAFTM ( "%s" , XQIE )
AAFTM AAFTM ( "%s" , ECU )
<operator>.assignment i = 0
<operator>.assignment a [ i ] = '\0'
<operator>.assignment b [ i ] = 0
<operator>.assignment i = 1
<operator>.assignment b [ HNC [ i ] - 'A' ] = 1
<operator>.assignment AXQ = 0
printf printf ( "%c" , a [ p ] )
<operator>.assignment i = p + 1
<operator>.subtraction HNC [ 0 ] - 'A'
<operator>.equals c == 1
<operator>.logicalAnd d == 1 && AXQ == 0
<operator>.equals AXQ == 0
<operator>.addition p + 1
<operator>.subtraction HNC [ i ] - 'A'
<operator>.notEquals a [ q ] != '\0'
<operator>.equals d == 1
<operator>.equals AXQ == 0
<operator>.logicalAnd b [ ECU [ 0 ] - 'A' ] == 1 && b [ ECU [ 1 ] - 'A' ] == 1
<operator>.notEquals a [ q ] != '\0'
<operator>.postIncrement q ++
<operator>.assignment p = q
<operator>.assignment b [ ECU [ 0 ] - 'A' ] = 0
<operator>.assignment b [ ECU [ 1 ] - 'A' ] = 0
<operator>.assignment AXQ = 1
<operator>.assignment a [ q + 1 ] = HNC [ i ]
<operator>.postIncrement q ++
<operator>.logicalOr ( XQIE [ 0 ] == HNC [ i ] && XQIE [ 1 ] == a [ q ] ) || ( XQIE [ 1 ] == HNC [ i ] && XQIE [ 0 ] == a [ q ] )
<operator>.equals b [ ECU [ 0 ] - 'A' ] == 1
<operator>.equals b [ ECU [ 1 ] - 'A' ] == 1
<operator>.assignment a [ q ] = HNC [ i ]
<operator>.assignment a [ q ] = XQIE [ 2 ]
<operator>.assignment AXQ = 1
<operator>.logicalAnd XQIE [ 0 ] == HNC [ i ] && XQIE [ 1 ] == a [ q ]
<operator>.logicalAnd XQIE [ 1 ] == HNC [ i ] && XQIE [ 0 ] == a [ q ]
<operator>.subtraction ECU [ 0 ] - 'A'
<operator>.subtraction ECU [ 1 ] - 'A'
<operator>.subtraction ECU [ 0 ] - 'A'
<operator>.subtraction ECU [ 1 ] - 'A'
<operator>.addition q + 1
<operator>.equals XQIE [ 0 ] == HNC [ i ]
<operator>.equals XQIE [ 1 ] == a [ q ]
<operator>.equals XQIE [ 1 ] == HNC [ i ]
<operator>.equals XQIE [ 0 ] == a [ q ]
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess a [ p ]
<operator>.indirectIndexAccess HNC [ 0 ]
<operator>.indirectIndexAccess b [ HNC [ 0 ] - 'A' ]
<operator>.indirectIndexAccess a [ p ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess b [ i ]
<operator>.indirectIndexAccess HNC [ 0 ]
<operator>.indirectIndexAccess b [ HNC [ i ] - 'A' ]
<operator>.indirectIndexAccess a [ p ]
<operator>.indirectIndexAccess HNC [ i ]
<operator>.indirectIndexAccess a [ q ]
<operator>.indirectIndexAccess a [ q ]
<operator>.indirectIndexAccess b [ ECU [ 0 ] - 'A' ]
<operator>.indirectIndexAccess b [ ECU [ 1 ] - 'A' ]
<operator>.indirectIndexAccess b [ ECU [ 0 ] - 'A' ]
<operator>.indirectIndexAccess b [ ECU [ 1 ] - 'A' ]
<operator>.indirectIndexAccess a [ q + 1 ]
<operator>.indirectIndexAccess HNC [ i ]
<operator>.indirectIndexAccess a [ q ]
<operator>.indirectIndexAccess HNC [ i ]
<operator>.indirectIndexAccess a [ q ]
<operator>.indirectIndexAccess XQIE [ 2 ]
<operator>.indirectIndexAccess ECU [ 0 ]
<operator>.indirectIndexAccess ECU [ 1 ]
<operator>.indirectIndexAccess ECU [ 0 ]
<operator>.indirectIndexAccess ECU [ 1 ]
<operator>.indirectIndexAccess XQIE [ 0 ]
<operator>.indirectIndexAccess HNC [ i ]
<operator>.indirectIndexAccess XQIE [ 1 ]
<operator>.indirectIndexAccess a [ q ]
<operator>.indirectIndexAccess XQIE [ 1 ]
<operator>.indirectIndexAccess HNC [ i ]
<operator>.indirectIndexAccess XQIE [ 0 ]
<operator>.indirectIndexAccess a [ q ]
>>>PDG&113 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->53 0->54 0->55 0->57 0->59 0->60 0->63 0->66 0->67 0->68 0->69 0->70 2->1 2->1 3->1 3->1 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->18 6->19 6->20 6->21 6->22 6->24 6->26 6->27 6->32 6->35 6->39 6->40 6->44 6->75 6->76 6->77 6->78 6->79 6->80 6->81 6->85 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->20 10->41 11->1 11->1 11->21 11->47 12->1 12->1 12->24 13->1 13->1 13->15 13->40 13->45 13->56 13->61 13->71 13->73 14->1 14->16 14->39 14->44 15->1 15->26 16->1 16->27 16->51 16->57 16->70 17->1 17->1 18->1 18->7 19->1 20->1 20->1 20->10 20->30 20->41 21->1 21->1 21->11 21->31 21->47 22->1 22->22 22->23 22->23 22->33 22->34 22->83 22->84 23->1 23->22 24->1 24->1 24->12 24->24 24->25 24->25 24->36 24->37 24->41 24->42 24->43 24->45 24->47 24->86 24->88 25->1 25->24 26->1 26->1 26->38 26->38 26->87 27->1 27->1 27->1 27->27 27->28 27->28 27->29 27->82 28->1 28->27 29->1 29->1 30->1 30->1 30->62 30->71 30->72 30->73 30->74 31->1 31->1 31->66 31->67 31->68 31->69 32->1 32->22 33->1 33->1 33->29 34->1 34->1 35->1 35->24 36->1 36->1 37->1 37->43 37->48 38->1 38->1 39->1 39->1 39->27 40->1 40->13 40->15 41->1 41->1 41->10 41->20 41->46 41->89 42->1 42->1 42->49 42->59 42->66 42->91 42->101 43->1 43->1 43->42 43->50 43->90 44->1 45->1 45->13 45->56 45->61 45->71 46->1 46->1 46->50 46->58 46->64 46->71 46->72 46->74 46->105 46->106 47->1 47->11 47->21 47->42 47->42 47->48 48->42 48->42 48->43 49->1 49->1 49->1 49->51 49->52 49->53 49->54 49->55 49->68 49->69 49->93 49->94 49->103 49->104 50->1 50->1 50->46 50->56 50->57 50->61 50->70 50->95 50->96 50->97 50->98 51->1 51->27 51->52 51->57 51->70 52->1 52->39 52->44 53->1 53->1 53->59 54->1 54->1 54->60 55->1 55->43 56->1 56->1 56->1 57->1 57->27 57->51 57->70 58->1 58->1 58->1 58->62 58->63 58->99 58->100 59->1 59->49 59->49 59->60 59->67 59->92 59->102 60->1 60->49 60->49 61->1 61->1 61->1 61->46 61->50 62->1 62->1 62->1 62->46 62->50 63->1 63->43 63->48 64->1 64->1 64->58 64->58 64->65 64->73 64->109 64->110 65->1 65->1 65->58 65->58 66->1 66->31 66->68 67->1 67->31 67->69 68->1 68->31 68->66 69->1 69->31 69->67 71->1 71->1 71->13 71->30 71->45 71->56 71->61 71->64 71->64 71->72 71->73 71->74 71->107 71->108 72->1 72->1 72->30 72->46 72->50 72->64 72->64 72->73 72->74 73->1 73->1 73->13 73->30 73->45 73->56 73->61 73->65 73->65 73->72 73->74 73->111 73->112 74->1 74->1 74->30 74->46 74->50 74->65 74->65 74->71
>>>Token int main ( ) { int i , AXQ , d , t , t1 , p , q , c , r , n , b [ 100 ] ; char XQIE [ 100 ] , ECU [ 100 ] , HNC [ 100 ] , a [ 100 ] ; WMTEPLL ( " " , " " , stdin ) ; WMTEPLL ( " " , " " , PCBMXJ ) ; AAFTM ( " " , & t ) ; for ( t1 = 1 ; t1 <= t ; t1 ++ ) { AAFTM ( " " , & c ) ; if ( c != 0 ) AAFTM ( " " , XQIE ) ; AAFTM ( " " , & d ) ; if ( d != 0 ) AAFTM ( " " , ECU ) ; AAFTM ( " " , & n ) ; AAFTM ( " " , HNC ) ; for ( i = 0 ; i <= 99 ; i ++ ) { a [ i ] = ' \0 ' ; b [ i ] = 0 ; } p = 1 ; a [ p ] = HNC [ 0 ] ; q = p ; b [ HNC [ 0 ] - ' ' ] = 1 ; for ( i = 1 ; i < n ; i ++ ) { b [ HNC [ i ] - ' ' ] = 1 ; AXQ = 0 ; if ( c == 1 ) { if ( a [ q ] != ' \0 ' ) if ( ( XQIE [ 0 ] == HNC [ i ] && XQIE [ 1 ] == a [ q ] ) || ( XQIE [ 1 ] == HNC [ i ] && XQIE [ 0 ] == a [ q ] ) ) { a [ q ] = XQIE [ 2 ] ; AXQ = 1 ; } } if ( d == 1 && AXQ == 0 ) { if ( b [ ECU [ 0 ] - ' ' ] == 1 && b [ ECU [ 1 ] - ' ' ] == 1 ) { q ++ ; p = q ; b [ ECU [ 0 ] - ' ' ] = 0 ; b [ ECU [ 1 ] - ' ' ] = 0 ; AXQ = 1 ; } } if ( AXQ == 0 ) { if ( a [ q ] != ' \0 ' ) { a [ q + 1 ] = HNC [ i ] ; q ++ ; } else a [ q ] = HNC [ i ] ; } } printf ( " " , t1 ) ; if ( a [ p ] != ' \0 ' ) printf ( " " , a [ p ] ) ; for ( i = p + 1 ; i <= q ; i ++ ) printf ( " " , a [ i ] ) ; printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD YNFYIXCOX
METHOD_RETURN int
PARAM char c
RETURN return i ; return i ;
IDENTIFIER c switch(c)
IDENTIFIER i return i ;
LITERAL 'Q' <empty>
<operator>.assignment i = 0
LITERAL 'W' <empty>
<operator>.assignment i = 1
LITERAL 'E' <empty>
<operator>.assignment i = 2
LITERAL 'R' <empty>
<operator>.assignment i = 3
LITERAL 'A' <empty>
<operator>.assignment i = 4
LITERAL 'S' <empty>
<operator>.assignment i = 5
LITERAL 'D' <empty>
<operator>.assignment i = 6
LITERAL 'F' <empty>
<operator>.assignment i = 7
<operator>.assignment i = - 1
<operator>.minus - 1
>>>PDG&24 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 2->1 3->1 5->3 7->1 7->1 7->5 9->1 9->1 9->5 11->1 11->1 11->5 13->1 13->1 13->5 15->1 15->1 15->5 17->1 17->1 17->5 19->1 19->1 19->5 21->1 21->1 21->5 22->1 22->1 22->1 22->5 23->22
>>>Token int YNFYIXCOX ( char c ) { int i ; switch ( c ) { case ' ' : i = 0 ; break ; case ' ' : i = 1 ; break ; case ' ' : i = 2 ; break ; case ' ' : i = 3 ; break ; case ' ' : i = 4 ; break ; case ' ' : i = 5 ; break ; case ' ' : i = 6 ; break ; case ' ' : i = 7 ; break ; default : i = - 1 ; break ; } return i ; }
>>>Func
METHOD WCOQ
METHOD_RETURN void
assert assert ( strcmp ( CXLKRDE ( "(A/(B-C)*D+E)" ) , "ABC-/D*E+" ) == 0 )
assert assert ( strcmp ( CXLKRDE ( "7-(2*3+5)*(8-4/2)" ) , "723*5+842/-*-" ) == 0 )
printf printf ( "All tests have successfully passed!\n" )
<operator>.equals strcmp ( CXLKRDE ( "(A/(B-C)*D+E)" ) , "ABC-/D*E+" ) == 0
<operator>.equals strcmp ( CXLKRDE ( "7-(2*3+5)*(8-4/2)" ) , "723*5+842/-*-" ) == 0
strcmp strcmp ( CXLKRDE ( "(A/(B-C)*D+E)" ) , "ABC-/D*E+" )
strcmp strcmp ( CXLKRDE ( "7-(2*3+5)*(8-4/2)" ) , "723*5+842/-*-" )
CXLKRDE CXLKRDE ( "(A/(B-C)*D+E)" )
CXLKRDE CXLKRDE ( "7-(2*3+5)*(8-4/2)" )
>>>PDG&11 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 3->1 3->1 4->1 5->1 5->2 5->2 6->1 6->3 6->3 7->1 7->5 7->5 8->1 8->6 8->6 9->7 10->8
>>>Token static void WCOQ ( ) { assert ( strcmp ( CXLKRDE ( " " ) , " " ) == 0 ) ; assert ( strcmp ( CXLKRDE ( " " ) , " " ) == 0 ) ; printf ( " \n " ) ; }
>>>Func
METHOD main
METHOD_RETURN int
IGOIE IGOIE ( "%d" , & N )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan YNFYI <= N
<operator>.postIncrement YNFYI ++
LITERAL 0 return 0 ;
<operator>.assignment YNFYI = 1
IGOIE IGOIE ( "%d" , & JKPDB )
IGOIE IGOIE ( "%d" , & UICRO )
IGOIE IGOIE ( "%d" , & XCO )
IGOIE IGOIE ( "%s" , s )
<operator>.assignment VQB = 0
printf printf ( "Case #%d: [" , YNFYI )
printf printf ( "]\n" )
<operator>.lessThan i < JKPDB
<operator>.postIncrement i ++
IGOIE IGOIE ( "%s" , XVCG [ i ] )
<operator>.lessThan i < UICRO
<operator>.postIncrement i ++
IGOIE IGOIE ( "%s" , ENYE [ i ] )
<operator>.lessThan i < XCO
<operator>.postIncrement i ++
<operator>.lessThan i < VQB
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment st [ VQB ++ ] = s [ i ]
<operator>.assignment AEA = 1
<operator>.assignment i = 0
printf printf ( "%c" , st [ i ] )
IDENTIFIER AEA while (AEA)
<operator>.notEquals i != 0
<operator>.assignment AEA = 0
memset memset ( PJCX   0   sizeof ( PJCX ) )
printf printf ( ", " )
<operator>.postIncrement VQB ++
<operator>.lessEqualsThan VQB <= 1
<operator>.lessThan j < JKPDB
<operator>.postIncrement j ++
IDENTIFIER AEA if (AEA)
<operator>.lessThan j < VQB
<operator>.postIncrement j ++
<operator>.assignment PJCX [ st [ j ] - 'A' ] = 1
<operator>.lessThan j < UICRO
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.logicalOr ( st [ VQB - 1 ] == XVCG [ j ] [ 0 ] && st [ VQB - 2 ] == XVCG [ j ] [ 1 ] ) || ( st [ VQB - 1 ] == XVCG [ j ] [ 1 ] && st [ VQB - 2 ] == XVCG [ j ] [ 0 ] )
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.logicalAnd PJCX [ ENYE [ j ] [ 0 ] - 'A' ] && PJCX [ ENYE [ j ] [ 1 ] - 'A' ]
<operator>.postDecrement VQB --
<operator>.postDecrement VQB --
<operator>.assignment st [ VQB ++ ] = XVCG [ j ] [ 2 ]
<operator>.assignment AEA = 1
<operator>.assignment VQB = 0
<operator>.assignment AEA = 1
<operator>.logicalAnd st [ VQB - 1 ] == XVCG [ j ] [ 0 ] && st [ VQB - 2 ] == XVCG [ j ] [ 1 ]
<operator>.logicalAnd st [ VQB - 1 ] == XVCG [ j ] [ 1 ] && st [ VQB - 2 ] == XVCG [ j ] [ 0 ]
<operator>.subtraction st [ j ] - 'A'
<operator>.equals st [ VQB - 1 ] == XVCG [ j ] [ 0 ]
<operator>.equals st [ VQB - 2 ] == XVCG [ j ] [ 1 ]
<operator>.equals st [ VQB - 1 ] == XVCG [ j ] [ 1 ]
<operator>.equals st [ VQB - 2 ] == XVCG [ j ] [ 0 ]
<operator>.subtraction ENYE [ j ] [ 0 ] - 'A'
<operator>.subtraction ENYE [ j ] [ 1 ] - 'A'
<operator>.postIncrement VQB ++
<operator>.subtraction VQB - 1
<operator>.subtraction VQB - 2
<operator>.subtraction VQB - 1
<operator>.subtraction VQB - 2
<operator>.addressOf & JKPDB
<operator>.addressOf & UICRO
<operator>.addressOf & XCO
<operator>.indirectIndexAccess XVCG [ i ]
<operator>.indirectIndexAccess ENYE [ i ]
<operator>.indirectIndexAccess st [ VQB ++ ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess st [ i ]
<operator>.sizeOf sizeof ( PJCX )
<operator>.indirectIndexAccess PJCX [ st [ j ] - 'A' ]
<operator>.indirectIndexAccess PJCX [ ENYE [ j ] [ 0 ] - 'A' ]
<operator>.indirectIndexAccess PJCX [ ENYE [ j ] [ 1 ] - 'A' ]
<operator>.indirectIndexAccess st [ VQB ++ ]
<operator>.indirectIndexAccess XVCG [ j ] [ 2 ]
<operator>.indirectIndexAccess st [ j ]
<operator>.indirectIndexAccess st [ VQB - 1 ]
<operator>.indirectIndexAccess XVCG [ j ] [ 0 ]
<operator>.indirectIndexAccess st [ VQB - 2 ]
<operator>.indirectIndexAccess XVCG [ j ] [ 1 ]
<operator>.indirectIndexAccess st [ VQB - 1 ]
<operator>.indirectIndexAccess XVCG [ j ] [ 1 ]
<operator>.indirectIndexAccess st [ VQB - 2 ]
<operator>.indirectIndexAccess XVCG [ j ] [ 0 ]
<operator>.indirectIndexAccess XVCG [ j ]
<operator>.indirectIndexAccess ENYE [ j ] [ 0 ]
<operator>.indirectIndexAccess ENYE [ j ] [ 1 ]
<operator>.indirectIndexAccess XVCG [ j ]
<operator>.indirectIndexAccess XVCG [ j ]
<operator>.indirectIndexAccess XVCG [ j ]
<operator>.indirectIndexAccess XVCG [ j ]
<operator>.indirectIndexAccess ENYE [ j ]
<operator>.indirectIndexAccess ENYE [ j ]
>>>PDG&104 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->49 0->50 0->52 0->53 0->55 0->56 0->57 0->60 0->65 0->66 0->67 0->68 0->69 0->70 0->71 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->13 4->14 4->15 4->18 4->21 4->23 4->25 4->26 4->27 4->30 4->72 4->73 4->74 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->15 8->39 9->1 9->1 9->18 9->45 10->1 10->1 10->21 11->1 11->1 11->28 12->1 12->23 12->37 13->1 13->5 14->1 15->1 15->1 15->8 15->15 15->16 15->16 15->17 15->39 15->75 16->1 16->15 17->1 17->1 18->1 18->1 18->9 18->18 18->19 18->19 18->20 18->45 18->76 19->1 19->18 20->1 20->1 21->1 21->1 21->10 21->21 21->22 21->22 21->28 21->29 21->34 21->37 21->38 21->77 21->78 22->1 22->21 23->1 23->1 23->1 23->23 23->24 23->31 23->33 23->33 23->79 24->1 24->23 25->15 26->18 27->21 28->1 28->1 28->1 29->1 29->1 30->1 30->23 31->1 31->1 33->1 33->24 33->36 34->1 34->1 35->1 35->1 35->51 36->1 37->23 37->38 38->1 38->23 38->34 38->35 38->37 38->38 38->39 38->42 38->42 38->45 38->47 38->49 38->50 38->68 38->80 39->1 39->1 39->1 39->8 39->15 39->40 39->48 39->58 39->61 39->68 39->87 39->88 39->98 40->1 40->39 42->1 42->23 42->37 42->38 42->42 42->43 42->43 42->44 42->60 42->81 42->86 43->1 43->42 44->1 44->1 44->35 45->1 45->1 45->1 45->9 45->18 45->46 45->51 45->65 45->82 45->96 45->102 46->1 46->45 47->1 47->39 48->1 48->1 48->1 48->39 48->40 48->52 48->53 48->54 48->55 48->67 48->84 48->85 48->95 49->42 50->1 50->45 51->1 51->1 51->1 51->35 51->35 51->45 51->46 51->56 51->57 52->53 53->1 53->67 54->1 54->1 54->1 55->1 55->1 56->1 56->23 56->37 56->38 57->1 57->1 58->1 58->1 58->48 58->48 58->59 58->63 58->70 58->91 58->92 58->100 59->1 59->1 59->48 59->48 60->1 61->1 61->1 61->58 61->58 61->62 61->63 61->64 61->69 61->89 61->90 61->99 62->1 62->1 62->58 62->58 62->63 62->64 63->1 63->1 63->59 63->59 63->61 63->62 63->64 63->71 63->93 63->94 63->101 64->1 64->1 64->59 64->59 64->61 64->62 65->1 66->1 67->23 67->37 67->38 67->42 68->23 68->37 68->38 68->42 68->52 68->69 68->70 69->23 69->37 69->38 69->42 69->52 69->68 69->70 70->23 70->37 70->38 70->42 70->52 70->68 70->71 71->23 71->37 71->38 71->42 71->52 71->68 82->66 82->83 82->97 82->103
>>>Token int main ( ) { int YNFYI ; int N ; int i , j ; int XCO ; char s [ 1000 ] ; char XVCG [ 100 ] [ 4 ] ; char ENYE [ 100 ] [ 3 ] ; char st [ 1000 ] ; int JKPDB , UICRO ; int VQB , AEA ; int PJCX [ 26 ] ; IGOIE ( " " , & N ) ; for ( YNFYI = 1 ; YNFYI <= N ; YNFYI ++ ) { IGOIE ( " " , & JKPDB ) ; for ( i = 0 ; i < JKPDB ; i ++ ) IGOIE ( " " , XVCG [ i ] ) ; IGOIE ( " " , & UICRO ) ; for ( i = 0 ; i < UICRO ; i ++ ) IGOIE ( " " , ENYE [ i ] ) ; IGOIE ( " " , & XCO ) ; IGOIE ( " " , s ) ; VQB = 0 ; for ( i = 0 ; i < XCO ; i ++ ) { st [ VQB ++ ] = s [ i ] ; AEA = 1 ; while ( AEA ) { AEA = 0 ; if ( VQB <= 1 ) break ; for ( j = 0 ; j < JKPDB ; j ++ ) if ( ( st [ VQB - 1 ] == XVCG [ j ] [ 0 ] && st [ VQB - 2 ] == XVCG [ j ] [ 1 ] ) || ( st [ VQB - 1 ] == XVCG [ j ] [ 1 ] && st [ VQB - 2 ] == XVCG [ j ] [ 0 ] ) ) { VQB -- ; VQB -- ; st [ VQB ++ ] = XVCG [ j ] [ 2 ] ; AEA = 1 ; break ; } if ( AEA ) continue ; memset ( PJCX , 0 , sizeof ( PJCX ) ) ; for ( j = 0 ; j < VQB ; j ++ ) PJCX [ st [ j ] - ' ' ] = 1 ; for ( j = 0 ; j < UICRO ; j ++ ) if ( PJCX [ ENYE [ j ] [ 0 ] - ' ' ] && PJCX [ ENYE [ j ] [ 1 ] - ' ' ] ) { VQB = 0 ; AEA = 1 ; break ; } } } printf ( " " , YNFYI ) ; for ( i = 0 ; i < VQB ; i ++ ) { if ( i != 0 ) printf ( " " ) ; printf ( " " , st [ i ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD AEHHRIV
METHOD_RETURN void
PARAM SUYVTPFMCN * VDKF
free free ( VDKF )
>>>PDG&4 0->2 0->3 2->3 3->1
>>>Token void AEHHRIV ( SUYVTPFMCN * VDKF ) { free ( VDKF ) ; }
>>>Func
METHOD UAIQYDLQHSKKYB
METHOD_RETURN int
PARAM int FQIKSIJ
PARAM int KYFMRXV
<operator>.assignment i = 0
<operator>.assignment XIBSJKMKP = 0
<operator>.assignment SLKRNPKXC = 0
<operator>.preDecrement -- i
RETURN return SLKRNPKXC ; return SLKRNPKXC ;
<operator>.logicalOr FQIKSIJ != 0 || KYFMRXV != 0
<operator>.notEquals XIBSJKMKP != 0
<operator>.greaterEqualsThan i >= 0
<operator>.assignment SLKRNPKXC = SLKRNPKXC * 10 + XBX [ i -- ]
IDENTIFIER SLKRNPKXC return SLKRNPKXC ;
<operator>.assignment XBX [ i ++ ] = ( FQIKSIJ % 10 + KYFMRXV % 10 + XIBSJKMKP ) % 2
<operator>.assignment XIBSJKMKP = ( FQIKSIJ % 10 + KYFMRXV % 10 + XIBSJKMKP ) / 2
<operator>.assignment FQIKSIJ = FQIKSIJ / 10
<operator>.assignment KYFMRXV = KYFMRXV / 10
<operator>.assignment XBX [ i ++ ] = XIBSJKMKP
<operator>.notEquals FQIKSIJ != 0
<operator>.notEquals KYFMRXV != 0
<operator>.addition SLKRNPKXC * 10 + XBX [ i -- ]
<operator>.modulo ( FQIKSIJ % 10 + KYFMRXV % 10 + XIBSJKMKP ) % 2
<operator>.division ( FQIKSIJ % 10 + KYFMRXV % 10 + XIBSJKMKP ) / 2
<operator>.division FQIKSIJ / 10
<operator>.division KYFMRXV / 10
<operator>.multiplication SLKRNPKXC * 10
<operator>.postIncrement i ++
<operator>.addition FQIKSIJ % 10 + KYFMRXV % 10 + XIBSJKMKP
<operator>.addition FQIKSIJ % 10 + KYFMRXV % 10 + XIBSJKMKP
<operator>.postIncrement i ++
<operator>.postDecrement i --
<operator>.addition FQIKSIJ % 10 + KYFMRXV % 10
<operator>.addition FQIKSIJ % 10 + KYFMRXV % 10
<operator>.modulo FQIKSIJ % 10
<operator>.modulo KYFMRXV % 10
<operator>.modulo FQIKSIJ % 10
<operator>.modulo KYFMRXV % 10
<operator>.indirectIndexAccess XBX [ i ++ ]
<operator>.indirectIndexAccess XBX [ i ++ ]
<operator>.indirectIndexAccess XBX [ i -- ]
>>>PDG&41 0->2 0->3 0->4 0->5 0->6 0->7 0->10 0->11 0->13 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->34 0->35 0->36 0->37 2->19 3->1 3->20 3->35 4->1 4->7 4->27 4->30 5->1 5->10 5->22 5->23 5->28 5->29 6->1 6->1 6->13 6->26 7->1 7->11 8->1 9->1 9->1 9->1 9->9 9->14 9->15 9->16 9->17 9->19 9->22 9->23 9->24 9->25 9->27 9->28 9->29 9->32 9->33 9->34 9->35 9->36 9->37 9->38 10->1 10->1 10->18 10->18 10->30 10->39 11->1 11->1 11->11 11->12 11->21 11->26 11->31 11->31 11->40 12->1 12->1 12->1 12->13 12->26 13->8 14->1 14->1 14->1 15->1 15->1 15->10 15->22 15->23 15->28 15->29 16->1 16->1 16->19 17->1 17->1 17->1 17->20 17->35 18->1 18->1 18->1 19->1 19->9 19->9 19->20 19->34 20->1 20->9 20->9 20->35 21->1 21->1 22->14 22->14 23->1 23->15 23->15 24->16 24->16 25->17 25->17 26->12 26->12 26->21 26->21 27->7 27->30 29->1 30->7 31->11 33->1 33->1 34->22 34->22 34->28 34->28 34->32 34->32 34->36 35->22 35->22 35->28 35->28 35->32 35->32 35->37 36->23 36->23 36->24 36->29 36->29 36->33 36->33 37->23 37->23 37->25 37->29 37->29 37->33 37->33
>>>Token int UAIQYDLQHSKKYB ( int FQIKSIJ , int KYFMRXV ) { int i = 0 , XIBSJKMKP = 0 , XBX [ 20 ] ; int SLKRNPKXC = 0 ; while ( FQIKSIJ != 0 || KYFMRXV != 0 ) { XBX [ i ++ ] = ( FQIKSIJ % 10 + KYFMRXV % 10 + XIBSJKMKP ) % 2 ; XIBSJKMKP = ( FQIKSIJ % 10 + KYFMRXV % 10 + XIBSJKMKP ) / 2 ; FQIKSIJ = FQIKSIJ / 10 ; KYFMRXV = KYFMRXV / 10 ; } if ( XIBSJKMKP != 0 ) XBX [ i ++ ] = XIBSJKMKP ; -- i ; while ( i >= 0 ) SLKRNPKXC = SLKRNPKXC * 10 + XBX [ i -- ] ; return SLKRNPKXC ; }
>>>Func
METHOD LUSXA
METHOD_RETURN void
PARAM void
memset memset ( cb   0   sizeof ( cb ) )
memset memset ( op   0   sizeof ( op ) )
PQJBR PQJBR ( "%d" , & C )
PQJBR PQJBR ( "%d" , & D )
PQJBR PQJBR ( "%d" , & N )
PQJBR PQJBR ( "%s" , s )
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.assignment i = 0
PQJBR PQJBR ( "%s" , KSX )
<operator>.assignment cb [ KSX [ 0 ] ] [ KSX [ 1 ] ] = KSX [ 2 ]
<operator>.assignment cb [ KSX [ 1 ] ] [ KSX [ 0 ] ] = KSX [ 2 ]
<operator>.assignment i = 0
PQJBR PQJBR ( "%s" , KSX )
<operator>.assignment op [ KSX [ 0 ] ] = KSX [ 1 ]
<operator>.assignment op [ KSX [ 1 ] ] = KSX [ 0 ]
<operator>.indirectIndexAccess cb [ KSX [ 0 ] ] [ KSX [ 1 ] ]
<operator>.indirectIndexAccess KSX [ 2 ]
<operator>.indirectIndexAccess cb [ KSX [ 1 ] ] [ KSX [ 0 ] ]
<operator>.indirectIndexAccess KSX [ 2 ]
<operator>.indirectIndexAccess op [ KSX [ 0 ] ]
<operator>.indirectIndexAccess KSX [ 1 ]
<operator>.indirectIndexAccess op [ KSX [ 1 ] ]
<operator>.indirectIndexAccess KSX [ 0 ]
<operator>.indirectIndexAccess cb [ KSX [ 0 ] ]
<operator>.indirectIndexAccess KSX [ 1 ]
<operator>.indirectIndexAccess cb [ KSX [ 1 ] ]
<operator>.indirectIndexAccess KSX [ 0 ]
<operator>.indirectIndexAccess KSX [ 0 ]
<operator>.indirectIndexAccess KSX [ 1 ]
<operator>.indirectIndexAccess KSX [ 0 ]
<operator>.indirectIndexAccess KSX [ 1 ]
>>>PDG&37 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->17 0->18 2->1 3->1 3->1 4->1 4->1 5->1 5->1 5->9 6->1 6->1 6->11 7->1 7->1 8->1 8->1 9->1 9->1 9->9 9->10 9->10 9->14 9->15 9->16 9->21 9->22 9->23 9->24 9->29 9->30 9->31 9->32 9->35 9->36 10->1 10->9 11->1 11->1 11->1 11->11 11->12 11->12 11->18 11->19 11->20 11->25 11->26 11->27 11->28 11->33 11->34 12->1 12->11 13->9 14->1 14->1 14->15 14->16 14->18 15->1 15->1 16->1 16->1 16->1 17->1 17->11 18->1 18->1 18->19 18->20 19->1 19->1 19->1 20->1 20->1 20->1
>>>Token void LUSXA ( void ) { int i ; char KSX [ 3 ] ; memset ( cb , 0 , sizeof ( cb ) ) ; memset ( op , 0 , sizeof ( op ) ) ; PQJBR ( " " , & C ) ; for ( i = 0 ; i < C ; i ++ ) { PQJBR ( " " , KSX ) ; cb [ KSX [ 0 ] ] [ KSX [ 1 ] ] = KSX [ 2 ] ; cb [ KSX [ 1 ] ] [ KSX [ 0 ] ] = KSX [ 2 ] ; } PQJBR ( " " , & D ) ; for ( i = 0 ; i < D ; i ++ ) { PQJBR ( " " , KSX ) ; op [ KSX [ 0 ] ] = KSX [ 1 ] ; op [ KSX [ 1 ] ] = KSX [ 0 ] ; } PQJBR ( " " , & N ) ; PQJBR ( " " , s ) ; }
>>>Func
METHOD PWBVG
METHOD_RETURN void
PARAM double THL
<operator>.assignment CNI = PEUUBISRXMR ( 2 , THL )
<operator>.assignment N = 10
<operator>.assignment FVHEYDN [ 10 ] [ 2 ] = { { 0   1 }   { 1   - 2 }   { 2   3 }   { 3   - 1 }   { 4   1 }   { 6   - 5 }   { - 7   - 3 }   { - 8   5 }   { - 9   2 }   { - 10   - 15 } }
<operator>.assignment * * X = ( double * * ) malloc ( N * sizeof ( double * ) )
<operator>.assignment Y [ 10 ] = { 1   - 1   1   - 1   - 1   - 1   1   1   1   - 1 }
printf printf ( "------- Test 1 -------\n" )
printf printf ( "Model before fit: %s\n"   UKYMWORMBAROJHUECVMWPNL ( & CNI ) )
HUHPYJUMEIO HUHPYJUMEIO ( & CNI , X , Y , N )
printf printf ( "Model after fit: %s\n"   UKYMWORMBAROJHUECVMWPNL ( & CNI ) )
<operator>.assignment RHDLTE [ ] = { 5   - 3 }
<operator>.assignment MNVV = WQCBPPXFFLNATFB ( & CNI , RHDLTE , NULL )
printf printf ( "Predict for x=(5,-3): % d\n" , MNVV )
assert assert ( MNVV == - 1 )
printf printf ( " ...passed\n" )
<operator>.assignment FAOJKDB [ ] = { 5   8 }
<operator>.assignment MNVV = WQCBPPXFFLNATFB ( & CNI , FAOJKDB , NULL )
printf printf ( "Predict for x=(5, 8): % d\n" , MNVV )
assert assert ( MNVV == 1 )
printf printf ( " ...passed\n" )
free free ( X )
RIPOPEELCCCEDT RIPOPEELCCCEDT ( & CNI )
<operator>.lessThan i < N
<operator>.postIncrement i ++
PEUUBISRXMR PEUUBISRXMR ( 2 , THL )
<operator>.arrayInitializer { { 0   1 }   { 1   - 2 }   { 2   3 }   { 3   - 1 }   { 4   1 }   { 6   - 5 }   { - 7   - 3 }   { - 8   5 }   { - 9   2 }   { - 10   - 15 } }
<operator>.cast ( double * * ) malloc ( N * sizeof ( double * ) )
<operator>.arrayInitializer { 1   - 1   1   - 1   - 1   - 1   1   1   1   - 1 }
<operator>.assignment i = 0
<operator>.assignment X [ i ] = ( double * ) FVHEYDN [ i ]
UKYMWORMBAROJHUECVMWPNL UKYMWORMBAROJHUECVMWPNL ( & CNI )
UKYMWORMBAROJHUECVMWPNL UKYMWORMBAROJHUECVMWPNL ( & CNI )
<operator>.arrayInitializer { 5   - 3 }
WQCBPPXFFLNATFB WQCBPPXFFLNATFB ( & CNI , RHDLTE , NULL )
<operator>.equals MNVV == - 1
<operator>.arrayInitializer { 5   8 }
WQCBPPXFFLNATFB WQCBPPXFFLNATFB ( & CNI , FAOJKDB , NULL )
<operator>.equals MNVV == 1
<operator>.arrayInitializer { 0   1 }
<operator>.arrayInitializer { 1   - 2 }
<operator>.arrayInitializer { 2   3 }
<operator>.arrayInitializer { 3   - 1 }
<operator>.arrayInitializer { 4   1 }
<operator>.arrayInitializer { 6   - 5 }
<operator>.arrayInitializer { - 7   - 3 }
<operator>.arrayInitializer { - 8   5 }
<operator>.arrayInitializer { - 9   2 }
<operator>.arrayInitializer { - 10   - 15 }
malloc malloc ( N * sizeof ( double * ) )
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 3
<operator>.minus - 1
<operator>.minus - 2
<operator>.minus - 1
<operator>.minus - 5
<operator>.minus - 7
<operator>.minus - 3
<operator>.minus - 8
<operator>.minus - 9
<operator>.minus - 10
<operator>.minus - 15
<operator>.multiplication N * sizeof ( double * )
<operator>.cast ( double * ) FVHEYDN [ i ]
<operator>.sizeOf sizeof ( double * )
<operator>.indirectIndexAccess X [ i ]
UNKNOWN double * double *
<operator>.indirectIndexAccess FVHEYDN [ i ]
>>>PDG&73 0->2 0->4 0->8 0->9 0->10 0->11 0->14 0->16 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->29 0->30 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->47 0->48 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 2->26 3->1 3->1 3->1 3->10 3->23 3->32 3->33 3->35 3->38 4->1 4->67 5->1 5->1 5->1 5->31 5->68 6->1 6->1 6->10 7->1 7->1 7->10 8->1 9->1 10->1 10->1 10->1 10->22 10->23 10->33 10->35 10->38 11->1 11->1 12->1 12->1 12->35 13->1 13->1 13->14 14->1 14->36 15->1 15->1 17->1 17->1 17->38 18->1 18->1 18->19 19->1 19->39 20->1 20->1 21->1 22->1 23->1 23->1 24->1 24->1 24->10 24->24 24->25 24->25 24->31 24->68 24->70 24->71 24->72 25->1 25->24 26->1 26->3 26->3 27->1 27->1 27->1 27->1 27->1 27->1 27->1 27->1 27->1 27->1 27->5 27->5 27->5 27->5 27->5 27->5 27->5 27->5 27->5 27->5 28->1 29->7 29->7 30->1 30->24 31->1 31->1 31->1 31->10 31->22 32->9 32->10 32->23 32->33 32->35 32->38 33->11 33->23 33->35 33->38 34->1 34->12 34->12 35->1 35->13 35->13 35->13 35->23 35->38 35->38 36->1 36->15 36->15 37->17 37->17 38->1 38->1 38->18 38->18 38->18 38->23 39->1 39->20 39->20 40->27 40->27 41->1 41->27 41->27 42->27 42->27 43->27 43->27 44->27 44->27 45->1 45->27 45->27 46->1 46->27 46->27 47->1 47->27 47->27 48->1 48->27 48->27 49->1 49->1 49->27 49->27 50->1 50->6 50->28 51->29 52->29 53->29 54->29 55->29 56->34 57->36 58->41 59->43 60->45 61->46 62->46 63->47 64->48 65->49 66->49 67->24 67->50 68->1 69->1
>>>Token void PWBVG ( double THL ) { struct RJPFPJG CNI = PEUUBISRXMR ( 2 , THL ) ; const int N = 10 ; const double FVHEYDN [ 10 ] [ 2 ] = { { 0 , 1 } , { 1 , - 2 } , { 2 , 3 } , { 3 , - 1 } , { 4 , 1 } , { 6 , - 5 } , { - 7 , - 3 } , { - 8 , 5 } , { - 9 , 2 } , { - 10 , - 15 } } ; double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; const int Y [ 10 ] = { 1 , - 1 , 1 , - 1 , - 1 , - 1 , 1 , 1 , 1 , - 1 } ; for ( int i = 0 ; i < N ; i ++ ) { X [ i ] = ( double * ) FVHEYDN [ i ] ; } printf ( " \n " ) ; printf ( " \n " , UKYMWORMBAROJHUECVMWPNL ( & CNI ) ) ; HUHPYJUMEIO ( & CNI , X , Y , N ) ; printf ( " \n " , UKYMWORMBAROJHUECVMWPNL ( & CNI ) ) ; double RHDLTE [ ] = { 5 , - 3 } ; int MNVV = WQCBPPXFFLNATFB ( & CNI , RHDLTE , NULL ) ; printf ( " \n " , MNVV ) ; assert ( MNVV == - 1 ) ; printf ( " \n " ) ; double FAOJKDB [ ] = { 5 , 8 } ; MNVV = WQCBPPXFFLNATFB ( & CNI , FAOJKDB , NULL ) ; printf ( " \n " , MNVV ) ; assert ( MNVV == 1 ) ; printf ( " \n " ) ; free ( X ) ; RIPOPEELCCCEDT ( & CNI ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment * fp = LGKDX ( "B-small-attempt0.in" , "r" )
<operator>.assignment * QJU = LGKDX ( "output.txt" , "w" )
NAQPGR NAQPGR ( fp , "%d" , & T )
<operator>.lessThan i < T
<operator>.postIncrement i ++
LGKDX LGKDX ( "B-small-attempt0.in" , "r" )
LGKDX LGKDX ( "output.txt" , "w" )
<operator>.assignment i = 0
<operator>.assignment YOOTOI = 0
memset memset ( & HWKTUOFTKWG   0   sizeof ( HWKTUOFTKWG ) )
NAQPGR NAQPGR ( fp , "%d" , & C )
NAQPGR NAQPGR ( fp , "%d" , & D )
NAQPGR NAQPGR ( fp , "%d" , & N )
NAQPGR NAQPGR ( fp , "%s" , SNGAJ )
fprintf fprintf ( QJU , "Case #%d: [" , i + 1 )
fprintf fprintf ( QJU , "]\n" )
<operator>.lessThan j < C
<operator>.postIncrement j ++
<operator>.lessThan j < D
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < YOOTOI
<operator>.postIncrement j ++
<operator>.sizeOf sizeof ( HWKTUOFTKWG )
<operator>.assignment j = 0
NAQPGR NAQPGR ( fp , "%s" , & GWRY )
<operator>.assignment GNAO = QCWSXW ( GWRY [ 0 ] )
<operator>.assignment AEYJ = QCWSXW ( GWRY [ 1 ] )
<operator>.assignment HWKTUOFTKWG [ GNAO ] [ AEYJ ] . A = GWRY [ 2 ]
<operator>.assignment HWKTUOFTKWG [ AEYJ ] [ GNAO ] . A = GWRY [ 2 ]
<operator>.assignment j = 0
NAQPGR NAQPGR ( fp , "%s" , & GWRY )
<operator>.assignment GNAO = QCWSXW ( GWRY [ 0 ] )
<operator>.assignment AEYJ = QCWSXW ( GWRY [ 1 ] )
<operator>.assignment HWKTUOFTKWG [ GNAO ] [ AEYJ ] . B = '-'
<operator>.assignment HWKTUOFTKWG [ AEYJ ] [ GNAO ] . B = '-'
<operator>.assignment j = 0
<operator>.addition i + 1
<operator>.assignment j = 0
<operator>.equals YOOTOI == 0
<operator>.notEquals 0 != HWKTUOFTKWG [ QCWSXW ( NCTAWA [ YOOTOI - 1 ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ] . A
<operator>.equals j == YOOTOI - 1
QCWSXW QCWSXW ( GWRY [ 0 ] )
QCWSXW QCWSXW ( GWRY [ 1 ] )
QCWSXW QCWSXW ( GWRY [ 0 ] )
QCWSXW QCWSXW ( GWRY [ 1 ] )
<operator>.assignment NCTAWA [ YOOTOI ++ ] = SNGAJ [ j ]
<operator>.assignment NCTAWA [ YOOTOI - 1 ] = HWKTUOFTKWG [ QCWSXW ( NCTAWA [ YOOTOI - 1 ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ] . A
fprintf fprintf ( QJU , "%c" , NCTAWA [ j ] )
<operator>.subtraction YOOTOI - 1
fprintf fprintf ( QJU , "%c, " , NCTAWA [ j ] )
<operator>.lessThan k < YOOTOI
<operator>.postIncrement k ++
<operator>.notEquals YOOTOI != 0
<operator>.postIncrement YOOTOI ++
QCWSXW QCWSXW ( SNGAJ [ j ] )
<operator>.subtraction YOOTOI - 1
<operator>.assignment k = 0
<operator>.equals '-' == HWKTUOFTKWG [ QCWSXW ( NCTAWA [ k ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ] . B
<operator>.assignment NCTAWA [ YOOTOI ++ ] = SNGAJ [ j ]
QCWSXW QCWSXW ( NCTAWA [ YOOTOI - 1 ] )
QCWSXW QCWSXW ( SNGAJ [ j ] )
<operator>.assignment YOOTOI = 0
QCWSXW QCWSXW ( NCTAWA [ YOOTOI - 1 ] )
<operator>.subtraction YOOTOI - 1
<operator>.postIncrement YOOTOI ++
<operator>.subtraction YOOTOI - 1
QCWSXW QCWSXW ( SNGAJ [ j ] )
QCWSXW QCWSXW ( NCTAWA [ k ] )
<operator>.addressOf & HWKTUOFTKWG
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.addressOf & GWRY
<operator>.fieldAccess HWKTUOFTKWG [ GNAO ] [ AEYJ ] . A
<operator>.indirectIndexAccess GWRY [ 2 ]
<operator>.fieldAccess HWKTUOFTKWG [ AEYJ ] [ GNAO ] . A
<operator>.indirectIndexAccess GWRY [ 2 ]
<operator>.addressOf & GWRY
<operator>.fieldAccess HWKTUOFTKWG [ GNAO ] [ AEYJ ] . B
<operator>.fieldAccess HWKTUOFTKWG [ AEYJ ] [ GNAO ] . B
<operator>.indirectIndexAccess GWRY [ 0 ]
<operator>.indirectIndexAccess GWRY [ 1 ]
<operator>.indirectIndexAccess HWKTUOFTKWG [ GNAO ] [ AEYJ ]
FIELD_IDENTIFIER A A
<operator>.indirectIndexAccess HWKTUOFTKWG [ AEYJ ] [ GNAO ]
FIELD_IDENTIFIER A A
<operator>.indirectIndexAccess GWRY [ 0 ]
<operator>.indirectIndexAccess GWRY [ 1 ]
<operator>.indirectIndexAccess HWKTUOFTKWG [ GNAO ] [ AEYJ ]
FIELD_IDENTIFIER B B
<operator>.indirectIndexAccess HWKTUOFTKWG [ AEYJ ] [ GNAO ]
FIELD_IDENTIFIER B B
<operator>.fieldAccess HWKTUOFTKWG [ QCWSXW ( NCTAWA [ YOOTOI - 1 ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ] . A
<operator>.indirectIndexAccess HWKTUOFTKWG [ GNAO ]
<operator>.indirectIndexAccess HWKTUOFTKWG [ AEYJ ]
<operator>.indirectIndexAccess HWKTUOFTKWG [ GNAO ]
<operator>.indirectIndexAccess HWKTUOFTKWG [ AEYJ ]
<operator>.indirectIndexAccess NCTAWA [ YOOTOI ++ ]
<operator>.indirectIndexAccess SNGAJ [ j ]
<operator>.indirectIndexAccess HWKTUOFTKWG [ QCWSXW ( NCTAWA [ YOOTOI - 1 ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ]
FIELD_IDENTIFIER A A
<operator>.indirectIndexAccess NCTAWA [ YOOTOI - 1 ]
<operator>.fieldAccess HWKTUOFTKWG [ QCWSXW ( NCTAWA [ YOOTOI - 1 ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ] . A
<operator>.indirectIndexAccess NCTAWA [ j ]
<operator>.indirectIndexAccess HWKTUOFTKWG [ QCWSXW ( NCTAWA [ YOOTOI - 1 ] ) ]
<operator>.indirectIndexAccess HWKTUOFTKWG [ QCWSXW ( NCTAWA [ YOOTOI - 1 ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ]
FIELD_IDENTIFIER A A
<operator>.indirectIndexAccess NCTAWA [ j ]
<operator>.indirectIndexAccess SNGAJ [ j ]
<operator>.indirectIndexAccess HWKTUOFTKWG [ QCWSXW ( NCTAWA [ YOOTOI - 1 ] ) ]
<operator>.indirectIndexAccess NCTAWA [ YOOTOI - 1 ]
<operator>.indirectIndexAccess SNGAJ [ j ]
<operator>.fieldAccess HWKTUOFTKWG [ QCWSXW ( NCTAWA [ k ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ] . B
<operator>.indirectIndexAccess NCTAWA [ YOOTOI ++ ]
<operator>.indirectIndexAccess SNGAJ [ j ]
<operator>.indirectIndexAccess NCTAWA [ YOOTOI - 1 ]
<operator>.indirectIndexAccess HWKTUOFTKWG [ QCWSXW ( NCTAWA [ k ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ]
FIELD_IDENTIFIER B B
<operator>.indirectIndexAccess HWKTUOFTKWG [ QCWSXW ( NCTAWA [ k ] ) ]
<operator>.indirectIndexAccess SNGAJ [ j ]
<operator>.indirectIndexAccess NCTAWA [ k ]
>>>PDG&125 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->28 0->31 0->33 0->34 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->59 0->60 0->61 0->65 0->67 0->68 0->69 2->1 2->1 2->4 3->1 3->1 3->1 3->16 4->1 4->1 4->1 4->5 4->12 5->1 5->1 5->1 5->5 5->6 5->6 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->16 5->17 5->18 5->20 5->22 5->24 5->26 5->27 5->33 5->39 5->40 5->40 5->41 5->72 5->73 5->74 5->75 6->1 6->5 7->2 7->2 8->3 8->3 9->1 9->5 10->1 10->24 10->42 11->1 11->1 12->1 12->1 12->13 12->18 12->28 13->1 13->1 13->14 13->20 13->34 14->1 14->1 14->15 14->22 15->1 15->1 15->1 15->12 15->49 15->58 15->62 15->64 15->70 16->1 16->1 16->17 16->51 16->53 17->1 17->1 17->16 18->1 18->1 18->12 18->18 18->19 18->19 18->28 18->29 18->30 18->31 18->32 18->45 18->46 18->76 18->77 18->78 18->79 18->80 18->84 18->85 18->86 18->87 18->88 18->89 18->97 18->98 19->1 19->18 20->1 20->1 20->13 20->20 20->21 20->21 20->34 20->35 20->36 20->37 20->38 20->47 20->48 20->81 20->82 20->83 20->90 20->91 20->92 20->93 20->94 20->95 20->99 20->100 21->1 21->20 22->1 22->1 22->14 22->22 22->23 22->23 22->42 23->1 23->22 24->1 24->1 24->1 24->24 24->25 24->44 24->44 24->52 24->52 25->1 25->24 26->1 27->18 28->1 28->1 28->13 28->31 28->34 28->45 28->46 28->47 28->48 29->1 29->1 29->1 30->1 30->1 30->1 31->1 31->1 32->1 32->1 32->1 33->20 34->1 34->1 34->14 34->28 34->31 34->45 34->46 34->47 34->48 35->1 35->1 35->1 36->1 36->1 36->1 37->1 37->1 38->1 38->1 39->22 41->1 41->24 42->1 42->43 42->49 42->57 42->57 42->58 42->63 42->67 42->67 42->96 42->101 42->102 42->103 42->104 42->108 42->112 42->114 43->1 43->50 43->54 43->56 43->59 43->60 43->64 43->66 43->69 43->105 43->106 43->109 43->110 43->113 43->115 43->119 44->1 44->1 44->25 44->51 44->53 44->107 44->111 45->1 45->28 45->29 45->31 45->34 45->46 45->47 45->48 46->1 46->28 46->30 46->31 46->34 46->45 46->47 46->48 47->1 47->28 47->31 47->34 47->35 47->45 47->46 47->48 48->1 48->28 48->31 48->34 48->36 48->45 48->46 48->47 49->1 49->1 49->1 50->1 50->1 50->63 51->1 51->1 51->17 51->53 51->53 52->24 52->44 52->44 53->1 53->1 53->17 53->51 53->51 54->1 54->1 54->55 54->56 54->61 54->70 54->71 54->116 54->120 54->121 54->122 54->123 54->124 55->1 55->54 56->1 56->24 56->42 56->62 56->68 56->68 56->117 56->118 57->24 57->42 58->1 58->15 58->49 58->62 58->64 58->70 59->69 60->1 60->54 61->1 61->54 61->55 61->65 62->1 62->1 62->1 63->1 63->66 64->1 64->15 64->49 64->58 65->1 65->56 67->54 67->59 68->24 68->42 69->24 69->42 70->1 70->15 70->49 70->58 70->62 71->1
>>>Token int main ( ) { WYQG * fp = LGKDX ( " " , " " ) ; WYQG * QJU = LGKDX ( " " , " " ) ; int i , j , k , GNAO , AEYJ ; char GWRY [ 4 ] , SNGAJ [ WEJYURKED ] , NCTAWA [ WEJYURKED ] ; NAQPGR ( fp , " " , & T ) ; for ( i = 0 ; i < T ; i ++ ) { YOOTOI = 0 ; memset ( & HWKTUOFTKWG , 0 , sizeof ( HWKTUOFTKWG ) ) ; NAQPGR ( fp , " " , & C ) ; for ( j = 0 ; j < C ; j ++ ) { NAQPGR ( fp , " " , & GWRY ) ; GNAO = QCWSXW ( GWRY [ 0 ] ) ; AEYJ = QCWSXW ( GWRY [ 1 ] ) ; HWKTUOFTKWG [ GNAO ] [ AEYJ ] . A = GWRY [ 2 ] ; HWKTUOFTKWG [ AEYJ ] [ GNAO ] . A = GWRY [ 2 ] ; } NAQPGR ( fp , " " , & D ) ; for ( j = 0 ; j < D ; j ++ ) { NAQPGR ( fp , " " , & GWRY ) ; GNAO = QCWSXW ( GWRY [ 0 ] ) ; AEYJ = QCWSXW ( GWRY [ 1 ] ) ; HWKTUOFTKWG [ GNAO ] [ AEYJ ] . B = ' ' ; HWKTUOFTKWG [ AEYJ ] [ GNAO ] . B = ' ' ; } NAQPGR ( fp , " " , & N ) ; NAQPGR ( fp , " " , SNGAJ ) ; for ( j = 0 ; j < N ; j ++ ) { if ( YOOTOI == 0 ) { NCTAWA [ YOOTOI ++ ] = SNGAJ [ j ] ; continue ; } if ( ( 0 != HWKTUOFTKWG [ QCWSXW ( NCTAWA [ YOOTOI - 1 ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ] . A ) ) { NCTAWA [ YOOTOI - 1 ] = HWKTUOFTKWG [ QCWSXW ( NCTAWA [ YOOTOI - 1 ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ] . A ; } else { for ( k = 0 ; k < YOOTOI ; k ++ ) if ( ' ' == HWKTUOFTKWG [ QCWSXW ( NCTAWA [ k ] ) ] [ QCWSXW ( SNGAJ [ j ] ) ] . B ) { YOOTOI = 0 ; break ; } if ( YOOTOI != 0 ) { NCTAWA [ YOOTOI ++ ] = SNGAJ [ j ] ; } } } fprintf ( QJU , " " , i + 1 ) ; for ( j = 0 ; j < YOOTOI ; j ++ ) { if ( j == YOOTOI - 1 ) { fprintf ( QJU , " " , NCTAWA [ j ] ) ; } else { fprintf ( QJU , " " , NCTAWA [ j ] ) ; } } fprintf ( QJU , " \n " ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
YCBQQ YCBQQ ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
YCBQQ YCBQQ ( "%d %d %d" , & n , & pd , & pg )
<operator>.assignment TJJKEBTNQA = 0
<operator>.logicalAnd ! ( pg == 100 && pd != 100 ) && ! ( pg == 0 && pd != 0 )
IDENTIFIER TJJKEBTNQA if (TJJKEBTNQA)
<operator>.assignment p = ( double ) pd / 100
printf printf ( "Case #%d: Possible\n" , i )
<operator>.logicalNot ! ( pg == 100 && pd != 100 )
<operator>.logicalNot ! ( pg == 0 && pd != 0 )
<operator>.greaterThan j > 0
<operator>.postDecrement j --
printf printf ( "Case #%d: Broken\n" , i )
<operator>.logicalAnd pg == 100 && pd != 100
<operator>.logicalAnd pg == 0 && pd != 0
<operator>.division ( double ) pd / 100
<operator>.assignment j = n
<operator>.assignment JTUYC = j * p
<operator>.equals pg == 100
<operator>.notEquals pd != 100
<operator>.equals pg == 0
<operator>.notEquals pd != 0
<operator>.cast ( double ) pd
<operator>.equals JTUYC == ( int ) JTUYC
<operator>.multiplication j * p
<operator>.assignment TJJKEBTNQA = 1
<operator>.cast ( int ) JTUYC
<operator>.addressOf & n
<operator>.addressOf & pd
<operator>.addressOf & pg
UNKNOWN double double
UNKNOWN int int
>>>PDG&38 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->13 0->16 0->17 0->18 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->13 4->13 4->14 4->18 4->18 4->19 4->24 4->33 4->34 4->35 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->1 8->21 8->22 8->24 8->25 8->26 8->27 8->28 9->1 9->1 10->1 10->1 10->1 10->12 10->16 10->21 10->22 10->28 10->36 12->1 12->1 12->1 12->30 13->1 13->5 14->1 14->10 14->15 14->20 14->26 15->1 15->10 16->1 16->1 16->23 16->29 16->30 16->30 16->32 16->37 17->1 17->16 18->1 18->5 19->1 19->1 19->14 19->14 20->1 20->1 20->15 20->15 21->1 21->12 21->12 22->1 22->1 22->16 23->1 23->1 23->29 23->32 24->1 24->8 24->19 24->19 24->25 24->26 25->1 25->8 25->19 25->19 25->21 25->27 25->28 26->1 26->8 26->20 26->20 26->24 26->27 27->1 27->8 27->20 27->20 27->21 27->25 27->28 28->1 29->1 29->1 29->1 29->16 29->17 29->31 30->1 30->1 30->17 30->23 30->23 31->1 31->1
>>>Token int main ( ) { int i , j , t ; int n , pd , pg ; int TJJKEBTNQA ; YCBQQ ( " " , & t ) ; for ( i = 1 ; i <= t ; i ++ ) { YCBQQ ( " " , & n , & pd , & pg ) ; TJJKEBTNQA = 0 ; if ( ! ( pg == 100 && pd != 100 ) && ! ( pg == 0 && pd != 0 ) ) { double p = ( double ) pd / 100 ; for ( j = n ; j > 0 ; j -- ) { double JTUYC = j * p ; if ( JTUYC == ( int ) JTUYC ) { TJJKEBTNQA = 1 ; break ; } } } if ( TJJKEBTNQA ) printf ( " \n " , i ) ; else printf ( " \n " , i ) ; } return 0 ; }
>>>Func
METHOD XEWN
METHOD_RETURN void
<operator>.assignment KSOHKKCDLJ [ CJM ] = { 0 }
YCMKYBFYAVF YCMKYBFYAVF ( KSOHKKCDLJ )
<operator>.lessThan i < CJM
<operator>.postIncrement i ++
<operator>.lessThan i < CJM - 1
<operator>.postIncrement i ++
<operator>.arrayInitializer { 0 }
<operator>.assignment i = 0
<operator>.assignment KSOHKKCDLJ [ i ] = rand ( ) % 101
<operator>.assignment i = 0
assert assert ( KSOHKKCDLJ [ i ] <= KSOHKKCDLJ [ i + 1 ] )
<operator>.subtraction CJM - 1
<operator>.modulo rand ( ) % 101
<operator>.lessEqualsThan KSOHKKCDLJ [ i ] <= KSOHKKCDLJ [ i + 1 ]
<operator>.addition i + 1
<operator>.indirectIndexAccess KSOHKKCDLJ [ i ]
rand rand ( )
<operator>.indirectIndexAccess KSOHKKCDLJ [ i ]
<operator>.indirectIndexAccess KSOHKKCDLJ [ i + 1 ]
>>>PDG&21 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->13 0->14 0->16 2->1 2->1 2->3 3->1 3->1 3->15 4->1 4->4 4->5 4->5 4->10 4->13 4->14 4->17 4->18 5->1 5->4 6->1 6->1 6->1 6->6 6->7 6->7 6->12 6->13 6->15 6->16 6->16 6->19 6->20 7->1 7->6 8->2 9->4 10->1 10->1 10->1 10->3 10->15 11->1 11->6 12->1 12->1 13->1 13->6 13->6 14->1 14->10 14->10 15->1 15->1 15->12 15->12
>>>Token static void XEWN ( ) { int KSOHKKCDLJ [ CJM ] = { 0 } ; for ( int i = 0 ; i < CJM ; i ++ ) { KSOHKKCDLJ [ i ] = rand ( ) % 101 ; } YCMKYBFYAVF ( KSOHKKCDLJ ) ; for ( int i = 0 ; i < CJM - 1 ; i ++ ) { assert ( KSOHKKCDLJ [ i ] <= KSOHKKCDLJ [ i + 1 ] ) ; } }
>>>Func
METHOD HPBJQQBFWG
METHOD_RETURN struct ACWNAMQN
PARAM struct ACWNAMQN * GWYY
<operator>.assignment NFO = GWYY -> EIHW
<operator>.assignment GWYY -> EIHW = GWYY -> WHYYH
<operator>.assignment GWYY -> WHYYH = NFO
HPBJQQBFWG HPBJQQBFWG ( GWYY -> EIHW )
HPBJQQBFWG HPBJQQBFWG ( GWYY -> WHYYH )
RETURN return GWYY ; return GWYY ;
<operator>.equals GWYY == NULL
IDENTIFIER GWYY return GWYY ;
RETURN return NULL ; return NULL ;
IDENTIFIER NULL return NULL ;
<operator>.indirectFieldAccess GWYY -> EIHW
<operator>.indirectFieldAccess GWYY -> EIHW
<operator>.indirectFieldAccess GWYY -> WHYYH
<operator>.indirectFieldAccess GWYY -> WHYYH
<operator>.indirectFieldAccess GWYY -> EIHW
<operator>.indirectFieldAccess GWYY -> WHYYH
FIELD_IDENTIFIER EIHW EIHW
FIELD_IDENTIFIER EIHW EIHW
FIELD_IDENTIFIER WHYYH WHYYH
FIELD_IDENTIFIER WHYYH WHYYH
FIELD_IDENTIFIER EIHW EIHW
FIELD_IDENTIFIER WHYYH WHYYH
>>>PDG&25 0->2 0->5 0->9 0->10 0->11 0->12 2->9 3->5 4->6 5->7 8->1 9->1 9->1 9->1 9->3 9->4 9->5 9->6 9->7 9->8 9->10 9->11 9->13 9->14 9->15 9->16 9->17 9->18 9->19 9->20 9->21 9->22 9->23 9->24 10->8 11->1 12->11
>>>Token struct ACWNAMQN * HPBJQQBFWG ( struct ACWNAMQN * GWYY ) { struct ACWNAMQN * NFO ; if ( GWYY == NULL ) return NULL ; NFO = GWYY -> EIHW ; GWYY -> EIHW = GWYY -> WHYYH ; GWYY -> WHYYH = NFO ; HPBJQQBFWG ( GWYY -> EIHW ) ; HPBJQQBFWG ( GWYY -> WHYYH ) ; return GWYY ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment * fp = AKSXP ( argv [ 1 ] , "r" )
<operator>.assignment QJBROJ = 256
<operator>.assignment * OKX = ( char * ) malloc ( QJBROJ )
NFTLVTC NFTLVTC ( & OKX , & QJBROJ , fp )
<operator>.assignment DWVQTHCRA = atoi ( OKX )
<operator>.assignment CTKURC = 1
free free ( OKX )
<operator>.logicalNot ! fp
<operator>.notEquals NFTLVTC ( & OKX , & QJBROJ , fp ) != - 1
<operator>.notEquals CTKURC != ( DWVQTHCRA + 1 )
AKSXP AKSXP ( argv [ 1 ] , "r" )
printf printf ( "Can't open file" )
RETURN return 0 ; return 0 ;
<operator>.cast ( char * ) malloc ( QJBROJ )
atoi atoi ( OKX )
PJKKWHEYMBUD PJKKWHEYMBUD ( OKX , & PUF )
<operator>.assignment XDF [ 0 ] = 0
RFKLSFDUTGBA RFKLSFDUTGBA ( & PUF , XDF )
AQVFHHSRE AQVFHHSRE ( CTKURC , XDF )
<operator>.postIncrement CTKURC ++
printf printf ( "Wrong number of tests run... May want to check everything is ok" )
LITERAL 0 return 0 ;
malloc malloc ( QJBROJ )
NFTLVTC NFTLVTC ( & OKX , & QJBROJ , fp )
<operator>.minus - 1
<operator>.addition DWVQTHCRA + 1
<operator>.addressOf & OKX
<operator>.addressOf & QJBROJ
UNKNOWN char * char *
<operator>.addressOf & OKX
<operator>.addressOf & QJBROJ
<operator>.addressOf & PUF
<operator>.indirectIndexAccess XDF [ 0 ]
<operator>.addressOf & PUF
>>>PDG&38 0->2 0->3 0->5 0->7 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 2->1 3->1 3->14 4->1 4->1 4->11 5->26 6->7 6->18 7->10 7->18 7->19 7->27 7->27 7->27 8->13 8->29 9->13 9->22 11->1 11->1 11->5 11->6 11->7 11->7 11->8 11->9 11->10 11->12 11->13 11->15 11->16 11->17 11->18 11->26 11->27 11->28 11->29 11->30 11->31 11->32 11->33 11->34 12->12 12->19 12->20 12->21 12->22 12->23 12->27 12->28 12->33 12->34 12->35 12->36 12->37 13->24 14->1 14->4 14->4 15->1 16->1 18->8 18->10 18->19 18->27 19->10 19->21 19->27 20->21 20->22 21->19 21->22 22->21 22->23 23->13 23->22 25->16 26->6 26->7 26->17 26->27 27->10 27->12 27->12 27->12 27->19 28->12
>>>Token int main ( int argc , char * * argv ) { LUSX * fp = AKSXP ( argv [ 1 ] , " " ) ; if ( ! fp ) { printf ( " " ) ; return 0 ; } size_t QJBROJ = 256 ; char * OKX = ( char * ) malloc ( QJBROJ ) ; NFTLVTC ( & OKX , & QJBROJ , fp ) ; int DWVQTHCRA = atoi ( OKX ) ; int CTKURC = 1 ; while ( NFTLVTC ( & OKX , & QJBROJ , fp ) != - 1 ) { MDEGR PUF ; PJKKWHEYMBUD ( OKX , & PUF ) ; char XDF [ 256 ] ; XDF [ 0 ] = 0 ; RFKLSFDUTGBA ( & PUF , XDF ) ; AQVFHHSRE ( CTKURC , XDF ) ; CTKURC ++ ; } if ( CTKURC != ( DWVQTHCRA + 1 ) ) { printf ( " " ) ; } free ( OKX ) ; }
>>>Func
METHOD DULXTFK
METHOD_RETURN DVCUMUX
PARAM DVCUMUX * WEQH
<operator>.assignment * MIMK = WEQH
RETURN return MIMK ; return MIMK ;
<operator>.notEquals MIMK -> KHON != NULL
<operator>.assignment MIMK = MIMK -> KHON
IDENTIFIER MIMK return MIMK ;
<operator>.indirectFieldAccess MIMK -> KHON
<operator>.indirectFieldAccess MIMK -> KHON
FIELD_IDENTIFIER KHON KHON
FIELD_IDENTIFIER KHON KHON
>>>PDG&12 0->2 0->3 0->5 0->7 2->3 3->1 3->1 3->1 3->7 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->8 5->9 5->10 5->11 6->1 6->1 6->7 7->4
>>>Token DVCUMUX * DULXTFK ( DVCUMUX * WEQH ) { DVCUMUX * MIMK = WEQH ; while ( MIMK -> KHON != NULL ) MIMK = MIMK -> KHON ; return MIMK ; }
>>>Func
METHOD main
METHOD_RETURN int
KBAUW KBAUW ( "%d" , & Z )
RETURN return 0 ; return 0 ;
<operator>.lessThan z < Z
<operator>.postIncrement z ++
LITERAL 0 return 0 ;
<operator>.assignment z = 0
KBAUW KBAUW ( "%d %d" , & K , & n )
<operator>.assignment p = - 1
printf printf ( "Case #%d: " , z + 1 )
printf printf ( "\n" )
<operator>.lessThan i < n
<operator>.postIncrement i ++
KBAUW KBAUW ( "%d" , & DTS [ i ] )
<operator>.lessThan i < K
<operator>.postIncrement i ++
<operator>.lessEqualsThan v <= K
<operator>.postIncrement v ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
printf printf ( "%d " , c [ DTS [ i ] - 1 ] )
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment c [ i ] = 0
<operator>.assignment w [ i ] = i
<operator>.minus - 1
<operator>.assignment v = 1
<operator>.assignment m = K + 1 - v
<operator>.assignment p = ( p + v ) % m
<operator>.assignment c [ w [ p ] ] = v
<operator>.postDecrement p --
<operator>.addition z + 1
<operator>.assignment i = 0
<operator>.lessThan i < m
<operator>.postIncrement i ++
<operator>.assignment w [ i ] = w [ i + 1 ]
<operator>.subtraction K + 1 - v
<operator>.modulo ( p + v ) % m
<operator>.assignment i = p
<operator>.subtraction DTS [ i ] - 1
<operator>.addition K + 1
<operator>.addition p + v
<operator>.addition i + 1
<operator>.addressOf & K
<operator>.addressOf & n
<operator>.addressOf & DTS [ i ]
<operator>.indirectIndexAccess c [ DTS [ i ] - 1 ]
<operator>.indirectIndexAccess DTS [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess c [ w [ p ] ]
<operator>.indirectIndexAccess w [ p ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess w [ i + 1 ]
<operator>.indirectIndexAccess DTS [ i ]
>>>PDG&56 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->30 0->31 0->32 0->33 0->34 0->35 0->37 0->38 0->39 0->40 0->41 0->42 0->43 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->10 4->11 4->12 4->15 4->17 4->19 4->22 4->23 4->26 4->27 4->32 4->32 4->33 4->44 4->45 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->12 8->15 8->17 8->19 8->37 8->41 9->1 9->1 9->1 9->38 9->42 10->1 10->1 11->1 12->12 12->13 12->13 12->14 12->19 12->46 12->48 13->1 13->12 14->1 14->1 14->40 15->1 15->15 15->16 15->16 15->17 15->24 15->25 15->25 15->49 15->50 16->1 16->15 17->1 17->1 17->1 17->8 17->15 17->17 17->18 17->28 17->29 17->30 17->31 17->34 17->37 17->37 17->37 17->38 17->39 17->41 17->41 17->42 17->51 17->52 18->1 18->17 19->1 19->1 19->1 19->8 19->12 19->19 19->20 19->20 19->21 19->40 19->47 19->55 20->1 20->19 21->1 21->1 22->12 23->15 24->1 24->1 25->1 25->1 26->9 27->1 27->17 28->1 28->1 28->38 29->1 29->1 29->31 29->39 30->1 30->1 31->1 31->1 31->38 31->42 33->1 33->19 34->1 34->1 34->34 34->35 34->35 34->36 34->43 34->43 34->53 34->54 35->1 35->34 36->1 36->1 36->1 37->1 37->18 37->28 37->28 37->30 37->38 37->42 38->1 38->29 38->29 38->34 39->1 39->34 40->1 40->14
>>>Token int main ( ) { int c [ 1000000 ] , w [ 1000000 ] , n , Z , z , DTS [ 100 ] , K , i , p , v , m ; KBAUW ( " " , & Z ) ; for ( z = 0 ; z < Z ; z ++ ) { KBAUW ( " " , & K , & n ) ; for ( i = 0 ; i < n ; i ++ ) KBAUW ( " " , & DTS [ i ] ) ; for ( i = 0 ; i < K ; i ++ ) { c [ i ] = 0 ; w [ i ] = i ; } p = - 1 ; for ( v = 1 ; v <= K ; v ++ ) { m = K + 1 - v ; p = ( p + v ) % m ; c [ w [ p ] ] = v ; for ( i = p ; i < m ; i ++ ) w [ i ] = w [ i + 1 ] ; p -- ; } printf ( " " , z + 1 ) ; for ( i = 0 ; i < n ; i ++ ) printf ( " " , c [ DTS [ i ] - 1 ] ) ; printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD ACWNAMQNHPBJQQB
METHOD_RETURN int
PARAM int m
PARAM int n
RETURN return n ; return n ;
<operator>.lessThan m < n
IDENTIFIER n return n ;
<operators>.assignmentAnd n &= n - 1
<operator>.subtraction n - 1
>>>PDG&9 0->2 0->3 0->5 0->6 0->7 0->8 2->5 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->7 5->8 5->8 6->4 8->7 8->7
>>>Token int ACWNAMQNHPBJQQB ( int m , int n ) { while ( m < n ) { n &= n - 1 ; } return n ; }
>>>Func
METHOD MUSY
METHOD_RETURN void
PARAM int * NQIMJDW
PARAM int OTTL
<operator>.assignment RKG = 0
<operator>.lessThan RKG < OTTL
<operator>.greaterEqualsThan NQIMJDW [ RKG ] >= NQIMJDW [ RKG - 1 ]
<operator>.postIncrement RKG ++
<operator>.assignment VIM = NQIMJDW [ RKG - 1 ]
<operator>.assignment NQIMJDW [ RKG - 1 ] = NQIMJDW [ RKG ]
<operator>.assignment NQIMJDW [ RKG ] = VIM
<operator>.postDecrement RKG --
<operator>.subtraction RKG - 1
<operator>.equals RKG == 0
<operator>.assignment RKG = 1
<operator>.subtraction RKG - 1
<operator>.subtraction RKG - 1
<operator>.indirectIndexAccess NQIMJDW [ RKG ]
<operator>.indirectIndexAccess NQIMJDW [ RKG - 1 ]
<operator>.indirectIndexAccess NQIMJDW [ RKG - 1 ]
<operator>.indirectIndexAccess NQIMJDW [ RKG - 1 ]
<operator>.indirectIndexAccess NQIMJDW [ RKG ]
<operator>.indirectIndexAccess NQIMJDW [ RKG ]
>>>PDG&23 0->2 0->3 0->4 0->5 0->7 0->10 0->11 0->12 0->13 0->14 0->15 0->16 2->1 2->6 2->8 2->9 3->5 4->1 4->5 5->1 5->1 5->1 5->5 5->6 5->12 5->12 5->17 5->18 6->7 6->8 6->8 6->9 6->9 6->10 6->11 6->13 6->15 6->16 6->19 6->20 6->21 6->22 7->1 7->5 8->10 9->6 10->6 11->13 12->7 12->15 13->1 13->5 13->14 14->1 14->5 15->16 16->11
>>>Token void MUSY ( int * NQIMJDW , int OTTL ) { int RKG = 0 ; while ( RKG < OTTL ) { if ( NQIMJDW [ RKG ] >= NQIMJDW [ RKG - 1 ] ) RKG ++ ; else { int VIM = NQIMJDW [ RKG - 1 ] ; NQIMJDW [ RKG - 1 ] = NQIMJDW [ RKG ] ; NQIMJDW [ RKG ] = VIM ; RKG -- ; if ( RKG == 0 ) RKG = 1 ; } } }
>>>Func
METHOD WGQMNJ
METHOD_RETURN UBHHX
PARAM char * QJGOYAR
PARAM char LRPWIDWXYR
memset memset ( & BVPVYYG   0   sizeof ( UBHHX ) )
printf printf ( QJGOYAR )
<operator>.assignment XVMQKCCDNJTOL = 0
GHVEFKWRPBVFKPU GHVEFKWRPBVFKPU ( & BVPVYYG )
RETURN return BVPVYYG ; return BVPVYYG ;
<operator>.notEquals XVMQKCCDNJTOL != LRPWIDWXYR
IDENTIFIER BVPVYYG return BVPVYYG ;
<operator>.sizeOf sizeof ( UBHHX )
<operator>.assignment XVMQKCCDNJTOL = MBGEAOH ( )
YPIQQEIP YPIQQEIP ( & BVPVYYG . s , XVMQKCCDNJTOL )
MBGEAOH MBGEAOH ( )
<operator>.addressOf & BVPVYYG . s
<operator>.fieldAccess BVPVYYG . s
FIELD_IDENTIFIER s s
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->12 0->13 2->5 3->9 4->1 4->7 4->10 5->1 5->1 6->1 6->9 7->1 7->1 7->10 8->1 9->1 9->1 9->1 9->9 9->12 9->13 9->14 9->15 9->16 9->17 10->8 11->1 12->1 12->1 12->13 13->1 13->1 13->7 13->9 13->10
>>>Token UBHHX WGQMNJ ( char * QJGOYAR , char LRPWIDWXYR ) { UBHHX BVPVYYG ; memset ( & BVPVYYG , 0 , sizeof ( UBHHX ) ) ; printf ( QJGOYAR ) ; char XVMQKCCDNJTOL = 0 ; while ( XVMQKCCDNJTOL != LRPWIDWXYR ) { XVMQKCCDNJTOL = MBGEAOH ( ) ; YPIQQEIP ( & BVPVYYG . s , XVMQKCCDNJTOL ) ; } GHVEFKWRPBVFKPU ( & BVPVYYG ) ; return BVPVYYG ; }
>>>Func
METHOD IESFUQYUDA
METHOD_RETURN int
PARAM XYDU * f
<operator>.assignment RMGDMPRAT = 0
<operator>.assignment c = FVNGGLVTW ( f   DOCX ( f ) )
RETURN return c ; return c ;
<operator>.equals FEUJGSKJQDXYG == 0
IDENTIFIER c return c ;
FVNGGLVTW FVNGGLVTW ( f   DOCX ( f ) )
<operator>.assignment MQAMKGJXMPLLLIOANM = GRIPXDAJVFKWLWNMM < RMGDMPRAT ? GRIPXDAJVFKWLWNMM : RMGDMPRAT
DOCX DOCX ( f )
<operator>.assignment MQAMKGJXMPLLLIOANM = RMGDMPRAT
<operator>.assignment c = FVNGGLVTW ( f , c )
<operator>.conditional GRIPXDAJVFKWLWNMM < RMGDMPRAT ? GRIPXDAJVFKWLWNMM : RMGDMPRAT
<operator>.notEquals * p != '\0'
<operator>.postIncrement p ++
<operator>.lessThan GRIPXDAJVFKWLWNMM < RMGDMPRAT
<operator>.assignment p = AUVAJN
<operator>.assignment pc = * p
<operator>.postIncrement RMGDMPRAT ++
<operator>.assignment c = DOCX ( f )
FVNGGLVTW FVNGGLVTW ( f , c )
<operator>.notEquals c != pc
RETURN return c ; return c ;
DOCX DOCX ( f )
IDENTIFIER c return c ;
<operator>.indirection * p
<operator>.indirection * p
>>>PDG&28 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 0->19 0->21 0->22 0->24 0->25 2->10 3->1 3->11 3->16 3->19 4->1 4->1 4->7 4->21 4->22 5->1 6->1 6->1 6->5 6->9 6->11 6->13 6->14 6->16 6->17 6->26 7->5 8->1 8->1 8->4 8->4 8->21 8->24 10->8 11->1 11->1 11->1 12->7 14->1 14->5 14->12 14->15 14->18 14->18 14->21 14->22 14->27 15->1 15->1 16->9 16->9 16->13 16->13 17->1 17->1 17->1 17->15 18->1 18->1 18->22 19->1 19->1 20->1 20->1 20->21 20->22 21->12 21->12 22->1 22->1 22->1 22->14 22->15 22->19 22->20 22->23 22->24 22->25 22->26 23->1 24->1 24->20 24->21 25->23
>>>Token static int IESFUQYUDA ( XYDU * f ) { int c ; RMGDMPRAT = 0 ; c = FVNGGLVTW ( f , DOCX ( f ) ) ; if ( FEUJGSKJQDXYG == 0 ) MQAMKGJXMPLLLIOANM = GRIPXDAJVFKWLWNMM < RMGDMPRAT ? GRIPXDAJVFKWLWNMM : RMGDMPRAT ; else { char const * p ; MQAMKGJXMPLLLIOANM = RMGDMPRAT ; for ( p = AUVAJN ; * p != ' \0 ' ; p ++ ) { unsigned char pc = * p ; if ( c != pc ) return c ; RMGDMPRAT ++ ; c = DOCX ( f ) ; } c = FVNGGLVTW ( f , c ) ; } return c ; }
>>>Func
METHOD main
METHOD_RETURN int
SKKLU SKKLU ( "%I64d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan o <= t
<operator>.postIncrement o ++
LITERAL 0 return 0 ;
<operator>.assignment o = 1
SKKLU SKKLU ( "%I64d %I64d %I64d" , & n , & i , & j )
<operator>.equals j == 100
<operator>.equals i == 100
printf printf ( "Case #%I64d: Possible\n" , o )
<operator>.equals j == 0
printf printf ( "Case #%I64d: Broken\n" , o )
<operator>.equals i == 0
printf printf ( "Case #%I64d: Possible\n" , o )
<operator>.greaterEqualsThan n >= 100
printf printf ( "Case #%I64d: Broken\n" , o )
printf printf ( "Case #%I64d: Possible\n" , o )
<operator>.assignment j = 100
<operator>.assignment k = 3
<operator>.logicalAnd i % 2 == 0 && j % 2 == 0
<operator>.logicalAnd i > 1 && i >= k
<operator>.lessEqualsThan j <= n
<operator>.assignment i = i / 2
<operator>.assignment j = j / 2
<operator>.assignment k = k + 2
printf printf ( "Case #%I64d: Possible\n" , o )
<operator>.equals i % 2 == 0
<operator>.equals j % 2 == 0
<operator>.greaterThan i > 1
<operator>.greaterEqualsThan i >= k
<operator>.logicalAnd i % k == 0 && j % k == 0
printf printf ( "Case #%I64d: Broken\n" , o )
<operator>.modulo i % 2
<operator>.modulo j % 2
<operator>.division i / 2
<operator>.division j / 2
<operator>.assignment i = i / k
<operator>.assignment j = j / k
<operator>.addition k + 2
<operator>.equals i % k == 0
<operator>.equals j % k == 0
<operator>.modulo i % k
<operator>.modulo j % k
<operator>.division i / k
<operator>.division j / k
<operator>.addressOf & n
<operator>.addressOf & i
<operator>.addressOf & j
>>>PDG&50 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->23 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->34 0->35 0->36 0->37 0->40 0->41 0->42 0->43 0->44 0->45 0->46 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->11 4->13 4->15 4->17 4->18 4->27 4->33 4->47 4->48 4->49 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->1 8->9 8->10 8->12 8->14 8->16 8->23 8->23 8->30 8->31 8->34 8->35 8->36 8->37 8->43 8->44 8->45 8->46 9->1 9->1 9->8 9->10 9->12 9->12 10->1 10->1 10->8 10->11 10->13 10->14 10->34 11->1 11->5 12->1 12->1 12->8 12->9 12->14 12->16 13->1 13->5 14->1 14->1 14->8 14->10 14->15 14->17 14->34 15->1 15->5 16->1 16->1 16->8 16->18 16->19 16->20 16->21 16->22 16->23 16->23 16->28 16->30 16->34 17->1 17->5 18->1 18->5 19->1 19->23 19->35 19->37 19->44 19->46 20->1 20->1 20->31 20->43 21->1 21->1 21->1 21->21 21->24 21->25 21->28 21->34 21->36 21->37 22->1 22->1 22->1 22->22 22->26 22->30 22->32 22->40 22->41 22->43 23->1 23->1 23->1 23->8 23->8 23->9 23->16 23->27 23->33 24->1 24->1 24->34 25->1 25->1 25->23 25->35 25->37 25->44 25->46 26->1 26->1 26->1 26->31 26->43 27->1 27->5 28->1 28->21 28->21 28->29 28->35 29->1 29->21 29->21 30->1 30->8 30->10 30->14 30->22 30->22 30->31 30->31 30->34 30->43 31->1 31->1 31->8 31->10 31->14 31->22 31->22 31->34 31->43 31->43 32->1 32->1 32->1 32->32 32->38 32->39 32->41 32->43 32->45 32->46 33->1 33->5 34->28 34->28 34->30 34->36 35->23 35->29 35->29 35->37 35->44 35->46 36->24 36->24 37->25 37->25 38->1 38->1 38->43 39->1 39->1 39->23 39->44 39->46 41->1 41->32 41->32 41->42 41->44 42->1 42->32 42->32 43->26 43->30 43->40 43->41 43->41 43->44 43->45 43->45 44->23 44->26 44->40 44->42 44->42 44->45 44->46 45->38 45->38 45->46 46->39 46->39 46->43
>>>Token int main ( ) { long long int i , j , k , l , m , n , o , p , q , r , s , t ; SKKLU ( " " , & t ) ; for ( o = 1 ; o <= t ; o ++ ) { SKKLU ( " " , & n , & i , & j ) ; if ( j == 100 ) { if ( i == 100 ) { printf ( " \n " , o ) ; } else { printf ( " \n " , o ) ; } } else if ( j == 0 ) { if ( i == 0 ) { printf ( " \n " , o ) ; } else { printf ( " \n " , o ) ; } } else { if ( n >= 100 ) { printf ( " \n " , o ) ; } else { j = 100 ; while ( i % 2 == 0 && j % 2 == 0 ) { i = i / 2 ; j = j / 2 ; } k = 3 ; while ( i > 1 && i >= k ) { while ( i % k == 0 && j % k == 0 ) { i = i / k ; j = j / k ; } k = k + 2 ; } if ( j <= n ) { printf ( " \n " , o ) ; } else { printf ( " \n " , o ) ; } } } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf ( "Enter decimal number: " )
HSUFC HSUFC ( "%ld" , & AXRCGEIVRT )
QJFSNOWAFHHUMIEMIEF QJFSNOWAFHHUMIEMIEF ( AXRCGEIVRT )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 3->1 3->4 4->1 4->1 5->1 6->5
>>>Token int main ( ) { long AXRCGEIVRT ; printf ( " " ) ; HSUFC ( " " , & AXRCGEIVRT ) ; QJFSNOWAFHHUMIEMIEF ( AXRCGEIVRT ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
WRCEU WRCEU ( "%d\n" , & PAM )
RETURN return 0 ; return 0 ;
<operator>.lessThan KLEN < PAM
<operator>.postIncrement KLEN ++
LITERAL 0 return 0 ;
<operator>.assignment KLEN = 0
WRCEU WRCEU ( "%d " , & CNH )
WRCEU WRCEU ( "%d " , & SAC )
WRCEU WRCEU ( "%d " , & VEW )
<operator>.assignment NYJ = 0
<operator>.assignment UAV = 0
printf printf ( "Case #%d: [" , KLEN + 1 )
printf printf ( "]\n" )
<operator>.lessThan e < CNH
<operator>.postIncrement e ++
<operator>.lessThan j < SAC
<operator>.postIncrement j ++
<operator>.lessThan i < VEW
<operator>.postIncrement i ++
<operator>.lessThan i < VEW
<operator>.postIncrement i ++
<operator>.lessThan i < VEW
<operator>.postIncrement i ++
<operator>.lessThan i < UAV
<operator>.postIncrement i ++
<operator>.assignment e = 0
WRCEU WRCEU ( "%c%c%c " , & QUHFCVYESKT [ e ] [ 0 ] , & QUHFCVYESKT [ e ] [ 1 ] , & QUHFCVYESKT [ e ] [ 2 ] )
<operator>.assignment j = 0
WRCEU WRCEU ( "%c%c " , & KRSMEFYKS [ j ] [ 0 ] , & KRSMEFYKS [ j ] [ 1 ] )
<operator>.assignment i = 0
WRCEU WRCEU ( "%c" , & AAYQJRLQWPNY [ i ] )
<operator>.assignment i = 0
<operator>.assignment TIJPBLSLF [ i ] = 0
<operator>.assignment i = 0
<operator>.assignment PXAMYCN = 0
<operator>.assignment RLFFD = 0
<operator>.assignment EVSDRB = AAYQJRLQWPNY [ i ]
<operator>.addition KLEN + 1
<operator>.assignment i = 0
printf printf ( "%c" , TIJPBLSLF [ i ] )
<operator>.equals i == VEW
IDENTIFIER UAV if (UAV)
<operator>.logicalAnd ! RLFFD && ! PXAMYCN
IDENTIFIER RLFFD if (RLFFD)
<operator>.lessThan i < UAV - 1
WRCEU WRCEU ( "\n" )
<operator>.assignment OIEADR = TIJPBLSLF [ UAV - 1 ]
<operator>.assignment TIJPBLSLF [ NYJ ] = EVSDRB
<operator>.postIncrement NYJ ++
<operator>.postIncrement UAV ++
<operator>.assignment NYJ = 0
<operator>.assignment UAV = 0
printf printf ( ", " )
<operator>.lessThan j < CNH
<operator>.postIncrement j ++
<operator>.logicalNot ! PXAMYCN
<operator>.logicalNot ! RLFFD
<operator>.logicalNot ! PXAMYCN
<operator>.lessThan j < VEW
<operator>.postIncrement j ++
<operator>.subtraction UAV - 1
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment TIJPBLSLF [ j ] = 0
<operator>.subtraction UAV - 1
<operator>.logicalOr ( EVSDRB == QUHFCVYESKT [ j ] [ 0 ] && OIEADR == QUHFCVYESKT [ j ] [ 1 ] ) || ( EVSDRB == QUHFCVYESKT [ j ] [ 1 ] && OIEADR == QUHFCVYESKT [ j ] [ 0 ] )
<operator>.logicalAnd e < UAV && ! RLFFD
<operator>.postIncrement e ++
<operator>.assignment TIJPBLSLF [ UAV - 1 ] = QUHFCVYESKT [ j ] [ 2 ]
<operator>.assignment PXAMYCN = 1
<operator>.assignment e = 0
<operator>.assignment FQSQLSODRPPSTD = TIJPBLSLF [ e ]
<operator>.logicalAnd EVSDRB == QUHFCVYESKT [ j ] [ 0 ] && OIEADR == QUHFCVYESKT [ j ] [ 1 ]
<operator>.logicalAnd EVSDRB == QUHFCVYESKT [ j ] [ 1 ] && OIEADR == QUHFCVYESKT [ j ] [ 0 ]
<operator>.lessThan e < UAV
<operator>.logicalNot ! RLFFD
<operator>.logicalAnd j < SAC && ! RLFFD
<operator>.postIncrement j ++
<operator>.equals EVSDRB == QUHFCVYESKT [ j ] [ 0 ]
<operator>.equals OIEADR == QUHFCVYESKT [ j ] [ 1 ]
<operator>.equals EVSDRB == QUHFCVYESKT [ j ] [ 1 ]
<operator>.equals OIEADR == QUHFCVYESKT [ j ] [ 0 ]
<operator>.assignment j = 0
<operator>.subtraction UAV - 1
<operator>.lessThan j < SAC
<operator>.logicalNot ! RLFFD
<operator>.logicalOr ( EVSDRB == KRSMEFYKS [ j ] [ 0 ] && FQSQLSODRPPSTD == KRSMEFYKS [ j ] [ 1 ] ) || ( EVSDRB == KRSMEFYKS [ j ] [ 1 ] && FQSQLSODRPPSTD == KRSMEFYKS [ j ] [ 0 ] )
<operator>.assignment RLFFD = 1
<operator>.logicalAnd EVSDRB == KRSMEFYKS [ j ] [ 0 ] && FQSQLSODRPPSTD == KRSMEFYKS [ j ] [ 1 ]
<operator>.logicalAnd EVSDRB == KRSMEFYKS [ j ] [ 1 ] && FQSQLSODRPPSTD == KRSMEFYKS [ j ] [ 0 ]
<operator>.equals EVSDRB == KRSMEFYKS [ j ] [ 0 ]
<operator>.equals FQSQLSODRPPSTD == KRSMEFYKS [ j ] [ 1 ]
<operator>.equals EVSDRB == KRSMEFYKS [ j ] [ 1 ]
<operator>.equals FQSQLSODRPPSTD == KRSMEFYKS [ j ] [ 0 ]
<operator>.addressOf & CNH
<operator>.addressOf & SAC
<operator>.addressOf & VEW
<operator>.addressOf & QUHFCVYESKT [ e ] [ 0 ]
<operator>.addressOf & QUHFCVYESKT [ e ] [ 1 ]
<operator>.addressOf & QUHFCVYESKT [ e ] [ 2 ]
<operator>.addressOf & KRSMEFYKS [ j ] [ 0 ]
<operator>.addressOf & KRSMEFYKS [ j ] [ 1 ]
<operator>.addressOf & AAYQJRLQWPNY [ i ]
<operator>.indirectIndexAccess TIJPBLSLF [ i ]
<operator>.indirectIndexAccess AAYQJRLQWPNY [ i ]
<operator>.indirectIndexAccess TIJPBLSLF [ i ]
<operator>.indirectIndexAccess QUHFCVYESKT [ e ] [ 0 ]
<operator>.indirectIndexAccess QUHFCVYESKT [ e ] [ 1 ]
<operator>.indirectIndexAccess QUHFCVYESKT [ e ] [ 2 ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ] [ 0 ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ] [ 1 ]
<operator>.indirectIndexAccess AAYQJRLQWPNY [ i ]
<operator>.indirectIndexAccess QUHFCVYESKT [ e ]
<operator>.indirectIndexAccess QUHFCVYESKT [ e ]
<operator>.indirectIndexAccess QUHFCVYESKT [ e ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ]
<operator>.indirectIndexAccess TIJPBLSLF [ UAV - 1 ]
<operator>.indirectIndexAccess TIJPBLSLF [ NYJ ]
<operator>.indirectIndexAccess TIJPBLSLF [ j ]
<operator>.indirectIndexAccess TIJPBLSLF [ UAV - 1 ]
<operator>.indirectIndexAccess QUHFCVYESKT [ j ] [ 2 ]
<operator>.indirectIndexAccess TIJPBLSLF [ e ]
<operator>.indirectIndexAccess QUHFCVYESKT [ j ] [ 0 ]
<operator>.indirectIndexAccess QUHFCVYESKT [ j ] [ 1 ]
<operator>.indirectIndexAccess QUHFCVYESKT [ j ] [ 1 ]
<operator>.indirectIndexAccess QUHFCVYESKT [ j ] [ 0 ]
<operator>.indirectIndexAccess QUHFCVYESKT [ j ]
<operator>.indirectIndexAccess QUHFCVYESKT [ j ]
<operator>.indirectIndexAccess QUHFCVYESKT [ j ]
<operator>.indirectIndexAccess QUHFCVYESKT [ j ]
<operator>.indirectIndexAccess QUHFCVYESKT [ j ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ] [ 0 ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ] [ 1 ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ] [ 1 ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ] [ 0 ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ]
<operator>.indirectIndexAccess KRSMEFYKS [ j ]
>>>PDG&142 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->41 0->42 0->43 0->45 0->46 0->47 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->69 0->71 0->72 0->76 0->77 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->89 0->92 0->93 0->94 0->95 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->13 4->14 4->15 4->17 4->19 4->21 4->23 4->25 4->27 4->29 4->31 4->33 4->35 4->39 4->39 4->40 4->96 4->97 4->98 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->15 8->55 9->1 9->1 9->17 9->86 10->1 10->1 10->19 10->21 10->23 10->42 10->60 11->1 11->1 11->50 12->1 12->25 12->51 12->66 13->1 13->1 14->1 15->1 15->1 15->1 15->8 15->15 15->16 15->16 15->28 15->55 15->99 15->100 15->101 15->108 15->109 15->110 15->114 15->115 15->116 16->1 16->15 17->1 17->1 17->1 17->9 17->17 17->18 17->18 17->30 17->86 17->102 17->103 17->111 17->112 17->117 17->118 18->1 18->17 19->19 19->20 19->21 19->32 19->42 19->42 19->42 19->104 19->113 20->1 20->19 21->21 21->22 21->22 21->23 21->34 21->105 22->1 22->21 23->1 23->1 23->10 23->19 23->23 23->24 23->24 23->36 23->37 23->38 23->44 23->48 23->52 23->53 23->55 23->57 23->58 23->60 23->60 23->63 23->64 23->66 23->106 23->119 24->1 24->23 25->1 25->1 25->1 25->25 25->26 25->41 25->46 25->46 25->62 25->62 25->107 26->1 26->25 27->1 27->15 28->1 28->1 28->1 28->1 29->1 29->17 30->1 30->1 30->1 30->92 30->93 30->94 30->95 31->19 32->1 32->1 32->38 33->21 34->1 34->1 34->41 35->23 36->1 36->1 36->57 36->59 37->1 37->58 37->77 37->87 38->1 38->1 38->1 38->49 38->80 38->92 40->1 40->25 41->1 41->1 42->1 42->19 42->20 42->47 44->1 44->1 44->1 44->49 44->50 44->51 44->68 44->120 46->1 46->1 46->26 46->54 47->1 48->1 48->1 48->1 48->81 48->83 49->1 49->1 49->1 50->1 50->1 51->1 51->25 51->66 52->1 52->1 52->50 53->1 53->25 53->51 53->66 54->1 55->1 55->1 55->1 55->8 55->15 55->55 55->56 55->56 55->67 55->74 55->80 55->125 55->130 56->1 56->55 57->1 57->44 57->59 57->68 57->72 57->76 58->1 58->44 58->59 59->1 59->44 60->1 60->1 60->23 60->60 60->61 60->61 60->65 60->121 61->1 61->60 62->25 62->46 62->46 63->1 63->55 64->1 64->60 65->1 65->1 66->25 66->51 66->76 66->85 67->1 67->1 67->1 67->70 67->71 67->85 67->122 67->123 67->129 68->1 68->1 68->68 68->69 68->73 68->76 68->78 68->78 68->84 68->86 68->124 69->1 69->76 70->1 70->1 70->1 70->48 71->1 71->57 72->1 72->76 73->1 73->1 73->1 73->93 73->95 74->1 74->1 74->67 74->67 74->75 74->82 74->127 74->132 75->1 75->1 75->67 75->67 76->1 76->25 76->51 76->66 76->68 76->68 76->69 76->77 77->58 77->68 77->87 78->1 78->1 78->68 78->78 78->79 78->86 78->88 78->90 78->92 78->134 78->138 79->1 79->86 80->1 80->1 80->49 80->74 80->74 80->81 80->82 80->83 80->92 80->126 80->131 81->1 81->1 81->74 81->74 81->82 81->83 82->1 82->1 82->49 82->75 82->75 82->80 82->81 82->83 82->92 82->128 82->133 83->1 83->1 83->75 83->75 83->80 83->81 84->1 84->86 85->25 85->51 85->66 85->76 86->1 86->1 86->9 86->17 86->78 86->78 86->79 86->87 87->58 87->77 87->78 88->1 88->1 88->1 88->89 89->1 89->58 89->77 89->87 90->1 90->1 90->88 90->88 90->91 90->94 90->136 90->140 91->1 91->1 91->88 91->88 92->1 92->1 92->30 92->49 92->90 92->90 92->93 92->94 92->95 92->135 92->139 93->1 93->1 93->30 93->90 93->90 93->94 93->95 94->1 94->1 94->30 94->49 94->91 94->91 94->92 94->93 94->95 94->137 94->141 95->1 95->1 95->30 95->91 95->91 95->92 95->93
>>>Token int main ( ) { int PAM ; int KLEN ; WRCEU ( " \n " , & PAM ) ; for ( KLEN = 0 ; KLEN < PAM ; KLEN ++ ) { int CNH ; WRCEU ( " " , & CNH ) ; char QUHFCVYESKT [ CNH ] [ 3 ] ; int e ; for ( e = 0 ; e < CNH ; e ++ ) { WRCEU ( " " , & QUHFCVYESKT [ e ] [ 0 ] , & QUHFCVYESKT [ e ] [ 1 ] , & QUHFCVYESKT [ e ] [ 2 ] ) ; } int SAC ; WRCEU ( " " , & SAC ) ; char KRSMEFYKS [ SAC ] [ 2 ] ; int j ; for ( j = 0 ; j < SAC ; j ++ ) { WRCEU ( " " , & KRSMEFYKS [ j ] [ 0 ] , & KRSMEFYKS [ j ] [ 1 ] ) ; } int VEW ; WRCEU ( " " , & VEW ) ; char AAYQJRLQWPNY [ VEW ] ; int i ; for ( i = 0 ; i < VEW ; i ++ ) { WRCEU ( " " , & AAYQJRLQWPNY [ i ] ) ; if ( i == VEW ) WRCEU ( " \n " ) ; } char TIJPBLSLF [ VEW ] ; for ( i = 0 ; i < VEW ; i ++ ) { TIJPBLSLF [ i ] = 0 ; } int NYJ = 0 , UAV = 0 ; for ( i = 0 ; i < VEW ; i ++ ) { int PXAMYCN = 0 ; int RLFFD = 0 ; char EVSDRB = AAYQJRLQWPNY [ i ] ; if ( UAV ) { char OIEADR = TIJPBLSLF [ UAV - 1 ] ; for ( j = 0 ; j < CNH ; j ++ ) { if ( ( EVSDRB == QUHFCVYESKT [ j ] [ 0 ] && OIEADR == QUHFCVYESKT [ j ] [ 1 ] ) || ( EVSDRB == QUHFCVYESKT [ j ] [ 1 ] && OIEADR == QUHFCVYESKT [ j ] [ 0 ] ) ) { TIJPBLSLF [ UAV - 1 ] = QUHFCVYESKT [ j ] [ 2 ] ; PXAMYCN = 1 ; } } if ( ! PXAMYCN ) { for ( e = 0 ; e < UAV && ! RLFFD ; e ++ ) { char FQSQLSODRPPSTD = TIJPBLSLF [ e ] ; for ( j = 0 ; j < SAC && ! RLFFD ; j ++ ) { if ( ( EVSDRB == KRSMEFYKS [ j ] [ 0 ] && FQSQLSODRPPSTD == KRSMEFYKS [ j ] [ 1 ] ) || ( EVSDRB == KRSMEFYKS [ j ] [ 1 ] && FQSQLSODRPPSTD == KRSMEFYKS [ j ] [ 0 ] ) ) { RLFFD = 1 ; } } } } } if ( ! RLFFD && ! PXAMYCN ) { TIJPBLSLF [ NYJ ] = EVSDRB ; NYJ ++ ; UAV ++ ; } if ( RLFFD ) { NYJ = 0 ; UAV = 0 ; for ( j = 0 ; j < VEW ; j ++ ) { TIJPBLSLF [ j ] = 0 ; } } } printf ( " " , KLEN + 1 ) ; for ( i = 0 ; i < UAV ; i ++ ) { printf ( " " , TIJPBLSLF [ i ] ) ; if ( i < UAV - 1 ) { printf ( " " ) ; } } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD LUSXAKSXPQJBR
METHOD_RETURN int
PARAM OJOKX * c
PARAM char * NFT
PARAM int * LVT
RETURN return 0 ; return 0 ;
<operator>.lessThan * LVT < 2
<operator>.lessThan i < c -> CDWVQTHC
<operator>.postIncrement i ++
<operator>.lessThan i < c -> FPJKKWHE
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
RETURN return 0 ; return 0 ;
<operator>.assignment i = 0
<operator>.assignment i = 0
LITERAL 0 return 0 ;
RACTKURC RACTKURC ( c -> MDEGRPU + i , NFT , LVT )
YMBUDX YMBUDX ( c -> DFRFKLS + i , NFT , LVT )
RETURN return 1 ; return 1 ;
RETURN return 1 ; return 1 ;
<operator>.addition c -> MDEGRPU + i
LITERAL 1 return 1 ;
<operator>.addition c -> DFRFKLS + i
LITERAL 1 return 1 ;
<operator>.indirectFieldAccess c -> CDWVQTHC
<operator>.indirectFieldAccess c -> FPJKKWHE
FIELD_IDENTIFIER CDWVQTHC CDWVQTHC
FIELD_IDENTIFIER FPJKKWHE FPJKKWHE
<operator>.indirectFieldAccess c -> MDEGRPU
<operator>.indirectFieldAccess c -> DFRFKLS
FIELD_IDENTIFIER MDEGRPU MDEGRPU
FIELD_IDENTIFIER DFRFKLS DFRFKLS
>>>PDG&32 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 2->1 3->1 3->16 3->17 4->1 4->16 4->17 5->1 6->1 6->1 6->7 6->12 6->13 6->16 6->17 6->24 6->26 7->8 7->9 7->14 7->16 7->16 7->20 7->20 7->25 7->27 7->28 7->30 8->7 9->5 9->10 9->17 9->17 9->22 9->22 9->29 9->31 10->9 11->5 12->1 13->7 14->9 15->12 16->7 16->8 16->17 16->17 16->18 16->24 16->26 17->9 17->10 17->19 17->25 17->27 18->1 19->1 21->18 23->19
>>>Token int LUSXAKSXPQJBR ( OJOKX * c , char * NFT , int * LVT ) { if ( * LVT < 2 ) return 0 ; int i ; for ( i = 0 ; i < c -> CDWVQTHC ; i ++ ) { if ( RACTKURC ( c -> MDEGRPU + i , NFT , LVT ) ) return 1 ; } for ( i = 0 ; i < c -> FPJKKWHE ; i ++ ) { if ( YMBUDX ( c -> DFRFKLS + i , NFT , LVT ) ) return 1 ; } return 0 ; }
>>>Func
METHOD EXCPOKXIBVV
METHOD_RETURN void
PARAM int fd
PARAM int EQR
<operator>.assignment WPVJVSN [ 7 ] = { 'C'   'a'   's'   'e'   ' '   '#'   '\0' }
write write ( fd , WPVJVSN , 6 )
<operator>.assignment NLSNII [ 5 ] = { '\0'   '\0'   '\0'   '\0'   '\0' }
XDVHKTK XDVHKTK ( NLSNII , "%d" , EQR )
<operator>.assignment ALUATVWQ [ 3 ] = { ':'   ' '   '\0' }
write write ( fd , ALUATVWQ , 2 )
<operator>.assignment DPKAGGKC = '['
<operator>.assignment BXROSFWC = ']'
write write ( fd , & DPKAGGKC , 1 )
write write ( fd , & BXROSFWC , 1 )
<operator>.assignment HYIHMVDNMNK = '\n'
write write ( fd , & HYIHMVDNMNK , 1 )
<operator>.logicalAnd i < 5 && NLSNII [ i ] != '\0'
<operator>.preIncrement ++ i
write write ( fd , & NLSNII [ i ] , 1 )
<operator>.lessThan i < GCANMVXOHUPE . TOWWEH - 1
<operator>.preIncrement ++ i
<operator>.lessThan i < GCANMVXOHUPE . TOWWEH
<operator>.arrayInitializer { 'C'   'a'   's'   'e'   ' '   '#'   '\0' }
<operator>.arrayInitializer { '\0'   '\0'   '\0'   '\0'   '\0' }
<operator>.assignment i = 0
<operator>.arrayInitializer { ':'   ' '   '\0' }
<operator>.assignment i = 0
<operator>.assignment YMPJQQJKH [ 3 ] = { ' '   ' '   '\0' }
write write ( fd , & GCANMVXOHUPE . DSE [ i ] , 1 )
write write ( fd , YMPJQQJKH , 2 )
write write ( fd , & GCANMVXOHUPE . DSE [ i ] , 1 )
<operator>.lessThan i < 5
<operator>.notEquals NLSNII [ i ] != '\0'
<operator>.subtraction GCANMVXOHUPE . TOWWEH - 1
<operator>.arrayInitializer { ' '   ' '   '\0' }
<operator>.addressOf & NLSNII [ i ]
<operator>.indirectIndexAccess NLSNII [ i ]
<operator>.indirectIndexAccess NLSNII [ i ]
<operator>.fieldAccess GCANMVXOHUPE . TOWWEH
<operator>.addressOf & GCANMVXOHUPE . DSE [ i ]
<operator>.addressOf & GCANMVXOHUPE . DSE [ i ]
FIELD_IDENTIFIER TOWWEH TOWWEH
<operator>.indirectIndexAccess GCANMVXOHUPE . DSE [ i ]
<operator>.indirectIndexAccess GCANMVXOHUPE . DSE [ i ]
<operator>.fieldAccess GCANMVXOHUPE . DSE
<operator>.fieldAccess GCANMVXOHUPE . DSE
FIELD_IDENTIFIER DSE DSE
FIELD_IDENTIFIER DSE DSE
>>>PDG&48 0->2 0->3 0->5 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->29 0->30 0->31 0->32 0->33 0->34 2->5 3->7 4->1 4->1 4->5 5->1 5->1 5->9 5->18 6->1 6->1 6->7 7->1 7->1 7->1 7->18 7->32 8->1 8->1 8->9 9->1 9->1 9->12 10->1 10->1 10->12 11->1 11->1 11->13 12->1 12->1 12->13 12->28 12->30 13->1 13->1 13->15 14->1 14->1 14->15 15->1 15->1 15->1 16->1 16->1 16->1 16->16 16->17 16->18 16->31 16->35 16->37 17->1 17->31 18->1 18->1 18->9 18->32 19->1 19->1 19->19 19->20 19->20 19->21 19->27 19->28 19->29 19->33 19->34 19->38 19->39 19->41 19->42 19->44 19->46 20->1 20->19 21->1 21->1 21->1 21->30 21->40 21->43 21->45 21->47 22->4 22->4 22->4 22->4 22->4 22->4 22->4 23->6 24->31 25->8 25->8 25->8 26->1 26->19 27->1 27->1 27->29 28->1 28->1 28->29 28->30 29->1 29->1 29->13 29->28 29->30 30->1 30->1 30->13 31->16 31->16 31->17 31->32 31->36 32->1 32->16 32->16 32->18 33->19 33->19 33->21 34->27 34->27 34->27
>>>Token void EXCPOKXIBVV ( int fd , int EQR ) { char WPVJVSN [ 7 ] = { ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' \0 ' } ; write ( fd , WPVJVSN , 6 ) ; char NLSNII [ 5 ] = { ' \0 ' , ' \0 ' , ' \0 ' , ' \0 ' , ' \0 ' } ; XDVHKTK ( NLSNII , " " , EQR ) ; int i ; for ( i = 0 ; i < 5 && NLSNII [ i ] != ' \0 ' ; ++ i ) write ( fd , & NLSNII [ i ] , 1 ) ; char ALUATVWQ [ 3 ] = { ' ' , ' ' , ' \0 ' } ; write ( fd , ALUATVWQ , 2 ) ; char DPKAGGKC = ' ' ; char BXROSFWC = ' ' ; write ( fd , & DPKAGGKC , 1 ) ; for ( i = 0 ; i < GCANMVXOHUPE . TOWWEH - 1 ; ++ i ) { char YMPJQQJKH [ 3 ] = { ' ' , ' ' , ' \0 ' } ; write ( fd , & GCANMVXOHUPE . DSE [ i ] , 1 ) ; write ( fd , YMPJQQJKH , 2 ) ; } if ( i < GCANMVXOHUPE . TOWWEH ) write ( fd , & GCANMVXOHUPE . DSE [ i ] , 1 ) ; write ( fd , & BXROSFWC , 1 ) ; char HYIHMVDNMNK = ' \n ' ; write ( fd , & HYIHMVDNMNK , 1 ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment a = 1
SLIXO SLIXO ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan a <= t
LITERAL 0 return 0 ;
printf printf ( "Case #%d: " , a )
<operator>.assignment time = 0
<operator>.assignment j = 0
<operator>.assignment CYAE = 0
<operator>.assignment VTYBD = 0
<operator>.assignment DIPV = 0
SLIXO SLIXO ( "%lld%lld%lld%lld" , & l , & t , & n , & c )
printf printf ( "%lld\n" , VTYBD + t )
<operator>.postIncrement a ++
<operator>.lessThan i < c
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
<operator>.lessThan i < HVGN + 1 + l
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
<operator>.assignment i = 0
SLIXO SLIXO ( "%lld" , & RTG [ i ] )
<operator>.assignment i = 0
<operator>.assignment time = time + RTG [ j ] * 2
<operator>.postIncrement j ++
<operator>.assignment i = HVGN + 1
<operator>.assignment i = HVGN + 1
<operator>.assignment VTYBD = VTYBD + PXKR [ i ]
<operator>.assignment VTYBD = VTYBD + PXKR [ i ] * 2
<operator>.addition VTYBD + t
<operator>.equals j == c
<operator>.logicalAnd time >= t && DIPV == 0
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.addition HVGN + 1 + l
<operator>.assignment j = 0
<operator>.addition time + RTG [ j ] * 2
<operator>.assignment DIPV = 1
<operator>.assignment PXKR [ i ] = RTG [ j ] - ( time - t ) / 2
<operator>.assignment PXKR [ n ] = RTG [ j ] - PXKR [ i ]
<operator>.assignment HVGN = i
<operator>.addition HVGN + 1
<operator>.assignment j = HVGN + 1
<operator>.addition HVGN + 1
<operator>.addition HVGN + 1
<operator>.addition VTYBD + PXKR [ i ]
<operator>.addition VTYBD + PXKR [ i ] * 2
<operator>.multiplication RTG [ j ] * 2
<operator>.greaterEqualsThan time >= t
<operator>.equals DIPV == 0
<operator>.assignment PXKR [ i ] = RTG [ j ]
<operator>.lessThan PXKR [ j ] < PXKR [ j + 1 ]
<operator>.multiplication PXKR [ i ] * 2
<operator>.subtraction RTG [ j ] - ( time - t ) / 2
<operator>.subtraction RTG [ j ] - PXKR [ i ]
<operator>.addition HVGN + 1
<operator>.assignment CYAE = PXKR [ j ]
<operator>.assignment PXKR [ j ] = PXKR [ j + 1 ]
<operator>.assignment PXKR [ j + 1 ] = CYAE
<operator>.division ( time - t ) / 2
<operator>.subtraction time - t
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.addressOf & l
<operator>.addressOf & t
<operator>.addressOf & n
<operator>.addressOf & c
<operator>.addressOf & RTG [ i ]
<operator>.indirectIndexAccess RTG [ i ]
<operator>.indirectIndexAccess PXKR [ i ]
<operator>.indirectIndexAccess RTG [ j ]
<operator>.indirectIndexAccess PXKR [ i ]
<operator>.indirectIndexAccess PXKR [ n ]
<operator>.indirectIndexAccess PXKR [ i ]
<operator>.indirectIndexAccess RTG [ j ]
<operator>.indirectIndexAccess RTG [ j ]
<operator>.indirectIndexAccess PXKR [ i ]
<operator>.indirectIndexAccess PXKR [ i ]
<operator>.indirectIndexAccess RTG [ j ]
<operator>.indirectIndexAccess PXKR [ j ]
<operator>.indirectIndexAccess PXKR [ j + 1 ]
<operator>.indirectIndexAccess PXKR [ j ]
<operator>.indirectIndexAccess PXKR [ j ]
<operator>.indirectIndexAccess PXKR [ j + 1 ]
<operator>.indirectIndexAccess PXKR [ j + 1 ]
>>>PDG&92 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->43 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->58 0->61 0->64 0->65 0->66 0->67 0->68 0->69 2->1 2->5 3->1 3->1 3->5 3->13 3->14 3->35 3->54 4->1 5->1 5->1 5->1 5->5 5->7 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->13 5->14 5->14 5->15 5->16 5->18 5->20 5->22 5->24 5->26 5->28 5->31 5->32 5->35 5->35 5->40 5->47 5->49 5->50 5->54 5->70 5->71 5->72 5->73 6->4 7->1 7->15 8->1 8->1 8->29 8->42 9->1 9->1 9->36 10->1 10->1 11->1 11->14 11->33 11->34 11->35 11->51 11->52 12->1 12->1 12->55 13->1 13->1 13->1 13->1 13->1 13->5 13->14 13->16 13->18 13->20 13->22 13->24 13->35 13->36 13->38 13->40 13->54 13->66 14->1 14->1 15->1 15->5 16->1 16->1 16->13 16->16 16->17 16->17 16->27 16->36 16->74 16->75 17->1 17->16 18->1 18->18 18->19 18->19 18->20 18->29 18->30 18->36 18->37 18->42 18->46 18->53 18->54 18->77 19->1 19->18 20->20 20->21 20->21 20->24 20->38 20->38 20->48 20->61 21->1 21->20 22->1 22->1 22->22 22->23 22->23 22->24 22->33 22->40 22->50 22->51 22->76 23->1 23->22 24->1 24->1 24->1 24->13 24->18 24->24 24->25 24->25 24->34 24->52 24->58 24->80 25->1 25->24 26->16 27->1 27->1 28->1 28->18 29->1 29->1 29->54 30->1 30->1 30->36 31->20 32->1 32->22 33->1 33->1 33->14 33->34 33->35 33->51 33->52 34->1 34->1 34->14 34->35 34->52 35->1 36->1 36->1 36->13 36->16 36->30 36->41 37->1 37->1 37->1 37->43 37->44 37->45 37->46 37->56 37->59 37->60 37->65 37->66 37->78 37->79 37->81 37->82 37->83 37->84 37->85 38->1 38->1 38->20 38->38 38->39 38->39 38->57 38->67 38->67 38->68 38->69 38->86 38->87 39->1 39->38 40->1 40->1 41->1 41->30 42->1 43->1 43->1 43->55 44->1 44->1 44->60 45->1 45->1 45->1 46->1 46->31 46->47 48->1 48->38 50->1 51->1 52->1 53->29 53->29 53->42 53->42 53->56 53->59 54->1 54->5 54->14 54->29 54->35 54->37 54->37 54->42 54->55 54->66 54->66 55->1 55->37 55->37 56->1 56->1 56->1 56->33 56->51 56->58 57->1 57->1 57->1 57->62 57->62 57->63 57->63 57->64 57->68 57->69 57->88 57->89 57->90 57->91 58->1 58->33 58->34 58->34 58->51 58->52 58->52 59->1 59->44 59->44 59->60 60->1 60->1 60->33 60->45 60->45 60->51 60->53 60->58 62->1 62->64 63->1 63->1 63->57 64->1 64->1 64->1 64->57 65->1 65->59 65->59 66->1 66->5 66->14 66->29 66->35 66->42 66->54 66->65 66->65
>>>Token int main ( ) { int t , a = 1 ; SLIXO ( " " , & t ) ; while ( a <= t ) { printf ( " " , a ) ; long long int l , t , n , c , time = 0 , i , j = 0 , HVGN , CYAE = 0 , VTYBD = 0 ; int DIPV = 0 ; SLIXO ( " " , & l , & t , & n , & c ) ; long long int RTG [ c ] , PXKR [ n + 2 ] ; for ( i = 0 ; i < c ; i ++ ) { SLIXO ( " " , & RTG [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { if ( j == c ) { j = 0 ; } time = time + RTG [ j ] * 2 ; if ( time >= t && DIPV == 0 ) { DIPV = 1 ; PXKR [ i ] = RTG [ j ] - ( time - t ) / 2 ; PXKR [ n ] = RTG [ j ] - PXKR [ i ] ; HVGN = i ; } else { PXKR [ i ] = RTG [ j ] ; } j ++ ; } for ( i = HVGN + 1 ; i <= n ; i ++ ) { for ( j = HVGN + 1 ; j < n ; j ++ ) { if ( PXKR [ j ] < PXKR [ j + 1 ] ) { CYAE = PXKR [ j ] ; PXKR [ j ] = PXKR [ j + 1 ] ; PXKR [ j + 1 ] = CYAE ; } } } for ( i = HVGN + 1 ; i < HVGN + 1 + l ; i ++ ) { VTYBD = VTYBD + PXKR [ i ] ; } for ( ; i <= n ; i ++ ) { VTYBD = VTYBD + PXKR [ i ] * 2 ; } printf ( " \n " , VTYBD + t ) ; a ++ ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
srand srand ( time ( NULL ) )
WCOQ WCOQ ( )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
time time ( NULL )
>>>PDG&7 0->3 0->4 0->5 0->6 2->1 2->1 3->1 4->1 5->4 6->1 6->2
>>>Token int main ( ) { srand ( time ( NULL ) ) ; WCOQ ( ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PLLPC PLLPC ( "%d" , & t )
<operator>.assignment AXQ = 1
RETURN return 0 ; return 0 ;
<operator>.notEquals ( t -- ) != 0
LITERAL 0 return 0 ;
PLLPC PLLPC ( "%d" , & c )
<operator>.assignment HNCW = 0
PLLPC PLLPC ( "%d" , & d )
<operator>.assignment XQI = 1
PLLPC PLLPC ( "%d" , & n )
PLLPC PLLPC ( "%s" , N )
printf printf ( "Case #%d: [" , AXQ ++ )
<operator>.postDecrement t --
<operator>.lessThan i < c
<operator>.postIncrement i ++
<operator>.lessThan i < d
<operator>.postIncrement i ++
<operator>.lessEqualsThan k <= n
<operator>.postIncrement k ++
<operator>.notEquals N [ 0 ] != '\0'
<operator>.assignment i = 0
PLLPC PLLPC ( "%s" , ac [ i ] )
<operator>.assignment i = 0
PLLPC PLLPC ( "%s" , ad [ i ] )
<operator>.assignment k = 0
<operator>.assignment EECU = 0
<operator>.postIncrement XQI ++
<operator>.postIncrement AXQ ++
printf printf ( "%c]\n" , N [ n - 1 ] )
<operator>.lessThan i < c
<operator>.postIncrement i ++
<operator>.notEquals HNCW != 1
<operator>.lessThan i < n - 1
<operator>.postIncrement i ++
printf printf ( "]\n" )
<operator>.assignment i = 0
<operator>.assignment i = 0
printf printf ( "%c, " , N [ i ] )
<operator>.lessThan j < 2
<operator>.postIncrement j ++
<operator>.lessThan i < d
<operator>.postIncrement i ++
<operator>.lessThan i < XQI
<operator>.postIncrement i ++
<operator>.subtraction n - 1
<operator>.subtraction n - 1
<operator>.assignment j = 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.equals N [ XQI ] == ac [ i ] [ j ]
<operator>.lessThan j < 2
<operator>.postIncrement j ++
<operator>.lessThan j < EECU
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.equals j == 1
<operator>.equals ad [ i ] [ j ] == N [ XQI ]
<operator>.equals MTE [ j ] == N [ i ]
<operator>.postIncrement EECU ++
<operator>.assignment N [ m ] = '\0'
<operator>.assignment n = m
<operator>.assignment XQI = 0
<operator>.equals N [ XQI - 1 ] == ac [ i ] [ 0 ]
<operator>.equals j == 1
<operator>.lessThan l < n
<operator>.expressionList l ++   m ++
<operator>.assignment N [ XQI - 1 ] = ac [ i ] [ 2 ]
<operator>.assignment N [ n - 1 ] = '\0'
<operator>.postDecrement n --
<operator>.assignment XQI = XQI --
<operator>.assignment HNCW = 1
<operator>.equals N [ XQI - 1 ] == ac [ i ] [ 1 ]
<operator>.assignment MTE [ EECU ] = ad [ i ] [ 0 ]
<operator>.expressionList m = 0   l = XQI + 1
<operator>.assignment N [ m ] = N [ l ]
<operator>.lessThan l < n - 1
<operator>.postIncrement l ++
<operator>.assignment N [ XQI - 1 ] = ac [ i ] [ 2 ]
<operator>.assignment N [ n - 1 ] = '\0'
<operator>.assignment XQI = XQI --
<operator>.postDecrement n --
<operator>.assignment HNCW = 1
<operator>.assignment MTE [ EECU ] = ad [ i ] [ 1 ]
<operator>.postIncrement l ++
<operator>.postIncrement m ++
<operator>.subtraction XQI - 1
<operator>.assignment l = XQI
<operator>.assignment N [ l ] = N [ l + 1 ]
<operator>.postDecrement XQI --
<operator>.lessThan l < n - 1
<operator>.postIncrement l ++
<operator>.assignment m = 0
<operator>.assignment l = XQI + 1
<operator>.subtraction XQI - 1
<operator>.subtraction n - 1
<operator>.subtraction n - 1
<operator>.subtraction XQI - 1
<operator>.assignment l = XQI
<operator>.assignment N [ l ] = N [ l + 1 ]
<operator>.postDecrement XQI --
<operator>.addition XQI + 1
<operator>.subtraction XQI - 1
<operator>.subtraction n - 1
<operator>.subtraction n - 1
<operator>.addition l + 1
<operator>.addition l + 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess N [ 0 ]
<operator>.indirectIndexAccess ac [ i ]
<operator>.indirectIndexAccess ad [ i ]
<operator>.indirectIndexAccess N [ n - 1 ]
<operator>.indirectIndexAccess N [ i ]
<operator>.indirectIndexAccess N [ XQI ]
<operator>.indirectIndexAccess ac [ i ] [ j ]
<operator>.indirectIndexAccess ac [ i ]
<operator>.indirectIndexAccess ad [ i ] [ j ]
<operator>.indirectIndexAccess N [ XQI ]
<operator>.indirectIndexAccess MTE [ j ]
<operator>.indirectIndexAccess N [ i ]
<operator>.indirectIndexAccess ad [ i ]
<operator>.indirectIndexAccess N [ m ]
<operator>.indirectIndexAccess N [ XQI - 1 ]
<operator>.indirectIndexAccess ac [ i ] [ 0 ]
<operator>.indirectIndexAccess ac [ i ]
<operator>.indirectIndexAccess N [ XQI - 1 ]
<operator>.indirectIndexAccess ac [ i ] [ 2 ]
<operator>.indirectIndexAccess N [ n - 1 ]
<operator>.indirectIndexAccess N [ XQI - 1 ]
<operator>.indirectIndexAccess ac [ i ] [ 1 ]
<operator>.indirectIndexAccess MTE [ EECU ]
<operator>.indirectIndexAccess ad [ i ] [ 0 ]
<operator>.indirectIndexAccess N [ m ]
<operator>.indirectIndexAccess N [ l ]
<operator>.indirectIndexAccess ac [ i ]
<operator>.indirectIndexAccess ac [ i ]
<operator>.indirectIndexAccess N [ XQI - 1 ]
<operator>.indirectIndexAccess ac [ i ] [ 2 ]
<operator>.indirectIndexAccess N [ n - 1 ]
<operator>.indirectIndexAccess ad [ i ]
<operator>.indirectIndexAccess MTE [ EECU ]
<operator>.indirectIndexAccess ad [ i ] [ 1 ]
<operator>.indirectIndexAccess N [ l ]
<operator>.indirectIndexAccess N [ l + 1 ]
<operator>.indirectIndexAccess ac [ i ]
<operator>.indirectIndexAccess ad [ i ]
<operator>.indirectIndexAccess N [ l ]
<operator>.indirectIndexAccess N [ l + 1 ]
>>>PDG&152 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->61 0->62 0->63 0->64 0->66 0->67 0->70 0->71 0->73 0->76 0->78 0->79 0->81 0->83 0->84 0->86 0->87 0->88 0->89 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->102 0->103 0->104 0->105 0->106 0->107 0->108 2->1 2->1 2->14 3->1 3->1 3->29 4->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->17 5->19 5->21 5->22 5->24 5->26 5->29 5->109 5->110 5->111 5->112 6->4 7->1 7->1 7->15 7->31 8->1 8->1 8->33 9->1 9->1 9->17 9->42 10->1 10->1 10->28 10->44 10->88 10->99 11->1 11->1 11->19 11->46 11->47 11->67 11->71 11->83 11->97 11->98 11->105 11->106 12->1 12->1 12->21 12->30 12->39 12->51 12->59 12->60 12->65 12->74 12->77 12->90 12->101 13->1 13->1 14->1 14->5 15->1 15->1 15->7 15->15 15->16 15->16 15->23 15->31 15->113 16->1 16->15 17->1 17->1 17->1 17->9 17->17 17->18 17->18 17->25 17->42 17->114 18->1 18->17 19->1 19->1 19->1 19->11 19->19 19->20 19->20 19->27 19->28 19->31 19->33 19->37 19->46 19->67 19->97 19->105 20->1 20->19 21->1 21->1 21->12 21->30 21->34 21->36 21->38 21->46 21->47 21->115 22->15 23->1 23->1 24->1 24->17 25->1 25->1 26->1 26->19 27->1 27->1 27->54 27->61 28->1 28->1 28->44 28->88 28->99 29->1 29->13 30->1 30->1 30->12 31->1 31->1 31->1 31->7 31->15 31->31 31->32 31->32 31->40 31->48 32->1 32->31 33->1 33->1 33->42 33->44 33->49 33->50 34->1 34->1 34->34 34->35 34->35 34->39 34->46 34->116 35->1 35->34 36->1 37->1 37->31 38->1 38->34 39->1 39->1 39->12 39->60 40->1 40->1 40->40 40->41 40->41 40->51 40->58 40->117 40->118 40->119 41->1 41->40 42->1 42->1 42->9 42->17 42->42 42->43 42->43 42->52 42->56 43->1 43->42 44->1 44->1 44->28 44->44 44->45 44->45 44->54 44->57 44->76 44->95 44->103 45->1 45->44 46->34 46->34 46->47 47->1 47->11 47->19 48->1 48->40 49->42 50->1 50->44 51->1 51->1 51->1 51->12 51->23 51->58 51->59 52->1 52->1 52->52 52->53 52->53 52->59 52->66 52->120 52->121 52->124 53->1 53->52 54->1 54->1 54->1 54->55 54->60 54->122 54->123 55->1 55->54 56->1 56->52 57->1 57->54 58->1 58->41 58->65 58->74 58->88 58->99 58->126 58->127 58->128 58->132 58->133 58->139 59->1 59->1 59->1 59->12 59->25 59->51 59->61 59->66 60->1 60->1 60->1 60->12 60->39 60->54 60->55 60->62 60->63 60->64 60->67 60->76 60->94 60->95 60->103 60->125 61->1 61->1 61->54 62->1 62->1 62->12 63->1 63->1 63->19 63->67 64->1 64->44 65->1 65->1 65->1 65->12 65->23 65->69 65->70 65->71 65->72 65->73 65->74 65->78 65->89 65->91 65->96 65->97 65->98 65->129 65->130 65->131 65->138 66->1 66->53 66->75 66->85 66->134 66->135 66->143 66->144 66->145 66->149 67->1 67->1 67->67 67->68 67->77 67->86 67->86 67->87 67->136 67->137 68->1 68->1 68->1 69->1 69->1 69->1 69->12 69->65 69->74 70->1 70->1 70->12 70->30 71->1 71->19 71->67 71->97 71->105 72->1 72->1 72->28 72->44 72->88 72->99 73->1 73->33 74->1 74->1 74->1 74->12 74->23 74->65 74->80 74->81 74->82 74->83 74->84 74->92 74->100 74->102 74->104 74->105 74->106 74->140 74->141 74->142 74->148 75->1 75->1 75->1 76->1 76->1 76->1 77->1 77->1 78->1 78->1 78->78 78->79 78->79 78->90 78->97 78->107 78->107 78->146 78->147 79->1 79->78 80->1 80->1 80->1 80->12 80->65 80->74 81->1 81->1 81->12 81->30 82->1 82->1 82->28 82->44 82->88 82->99 83->1 83->19 83->67 83->97 83->105 84->1 84->33 85->1 85->1 85->1 86->67 86->68 87->63 87->68 88->28 88->44 88->96 88->99 89->1 89->78 90->1 90->1 90->1 90->12 90->77 91->72 92->1 92->1 92->92 92->93 92->93 92->101 92->105 92->108 92->108 92->150 92->151 93->1 93->92 94->63 94->76 94->87 95->1 95->67 95->76 96->89 96->91 97->78 97->78 97->98 98->71 99->28 99->44 99->88 99->104 100->1 100->92 101->1 101->1 101->1 101->12 101->77 102->82 104->100 104->102 105->92 105->92 105->106 106->83
>>>Token int main ( ) { int t , AXQ , c , d , n , i , j , k , l , m , XQI , EECU , HNCW ; char ac [ 36 ] [ 3 ] ; char ad [ 28 ] [ 2 ] ; char N [ 100 ] ; char MTE [ 27 ] ; PLLPC ( " " , & t ) ; AXQ = 1 ; while ( ( t -- ) != 0 ) { PLLPC ( " " , & c ) ; HNCW = 0 ; for ( i = 0 ; i < c ; i ++ ) { PLLPC ( " " , ac [ i ] ) ; } PLLPC ( " " , & d ) ; for ( i = 0 ; i < d ; i ++ ) { PLLPC ( " " , ad [ i ] ) ; } XQI = 1 ; PLLPC ( " " , & n ) ; PLLPC ( " " , N ) ; for ( k = 0 ; k <= n ; k ++ ) { for ( i = 0 ; i < c ; i ++ ) { for ( j = 0 ; j < 2 ; j ++ ) { if ( N [ XQI ] == ac [ i ] [ j ] ) { if ( j == 1 ) { if ( N [ XQI - 1 ] == ac [ i ] [ 0 ] ) { N [ XQI - 1 ] = ac [ i ] [ 2 ] ; for ( l = XQI ; l < n - 1 ; l ++ ) { N [ l ] = N [ l + 1 ] ; } N [ n - 1 ] = ' \0 ' ; n -- ; XQI = XQI -- ; HNCW = 1 ; } } else { if ( N [ XQI - 1 ] == ac [ i ] [ 1 ] ) { N [ XQI - 1 ] = ac [ i ] [ 2 ] ; for ( l = XQI ; l < n - 1 ; l ++ ) { N [ l ] = N [ l + 1 ] ; } N [ n - 1 ] = ' \0 ' ; XQI = XQI -- ; n -- ; HNCW = 1 ; } } } } } EECU = 0 ; if ( HNCW != 1 ) { for ( i = 0 ; i < d ; i ++ ) { for ( j = 0 ; j < 2 ; j ++ ) { if ( ad [ i ] [ j ] == N [ XQI ] ) { if ( j == 1 ) MTE [ EECU ] = ad [ i ] [ 0 ] ; else MTE [ EECU ] = ad [ i ] [ 1 ] ; EECU ++ ; } } } for ( i = 0 ; i < XQI ; i ++ ) { for ( j = 0 ; j < EECU ; j ++ ) { if ( MTE [ j ] == N [ i ] ) { for ( m = 0 , l = XQI + 1 ; l < n ; l ++ , m ++ ) { N [ m ] = N [ l ] ; } N [ m ] = ' \0 ' ; n = m ; XQI = 0 ; break ; } } } } XQI ++ ; } printf ( " " , AXQ ++ ) ; if ( N [ 0 ] != ' \0 ' ) { for ( i = 0 ; i < n - 1 ; i ++ ) { printf ( " " , N [ i ] ) ; } printf ( " \n " , N [ n - 1 ] ) ; } else printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD ROAEWU
METHOD_RETURN int
PARAM int n
PARAM int p [ ]
<operator>.assignment t = p [ i ]
<operator>.assignment p [ i ] = p [ j ]
<operator>.assignment p [ j ] = t
RETURN return 1 ; return 1 ;
<operator>.logicalAnd i >= 0 && p [ i ] > p [ i + 1 ]
<operator>.postDecrement i --
<operator>.lessThan i < 0
<operator>.lessThan j < k
<operator>.expressionList j ++   k --
<operator>.lessThan p [ j ] < t
<operator>.postIncrement j ++
LITERAL 1 return 1 ;
<operator>.assignment i = n - 2
RETURN return 0 ; return 0 ;
<operator>.expressionList j = i + 1   k = n - 1
<operator>.assignment t = p [ j ]
<operator>.assignment p [ j ] = p [ k ]
<operator>.assignment p [ k ] = t
<operator>.assignment j = i + 1
<operator>.greaterEqualsThan i >= 0
<operator>.greaterThan p [ i ] > p [ i + 1 ]
LITERAL 0 return 0 ;
<operator>.postIncrement j ++
<operator>.postDecrement k --
<operator>.subtraction n - 2
<operator>.assignment j = i + 1
<operator>.assignment k = n - 1
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.subtraction n - 1
<operator>.indirectIndexAccess p [ i ]
<operator>.indirectIndexAccess p [ i ]
<operator>.indirectIndexAccess p [ j ]
<operator>.indirectIndexAccess p [ j ]
<operator>.indirectIndexAccess p [ j ]
<operator>.indirectIndexAccess p [ i ]
<operator>.indirectIndexAccess p [ i + 1 ]
<operator>.indirectIndexAccess p [ j ]
<operator>.indirectIndexAccess p [ j ]
<operator>.indirectIndexAccess p [ k ]
<operator>.indirectIndexAccess p [ k ]
>>>PDG&46 0->2 0->3 0->6 0->7 0->9 0->10 0->11 0->13 0->14 0->15 0->17 0->18 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->29 0->31 0->32 0->33 0->34 2->28 3->1 3->4 3->5 3->13 3->19 3->20 3->24 4->13 7->1 8->1 8->1 8->1 8->8 8->9 8->23 9->1 9->23 10->1 10->1 10->4 10->5 10->6 10->7 10->11 10->13 10->17 10->18 10->18 10->22 10->22 10->29 10->29 10->30 10->31 10->31 10->33 10->33 10->34 10->35 10->36 10->37 10->38 10->39 11->11 11->12 11->19 11->20 11->21 11->26 11->26 11->27 11->27 11->42 11->43 11->44 11->45 13->5 13->6 13->13 13->14 13->39 15->7 16->1 16->1 16->23 17->1 19->21 20->13 20->19 21->20 22->14 23->8 23->8 23->9 23->10 23->24 23->32 23->32 23->40 23->41 24->1 24->1 24->4 24->8 24->8 25->17 26->11 26->12 27->11 27->12 28->1 28->16 28->16 28->34 29->11 29->18 30->11 30->18 34->18 34->18 34->30 34->30
>>>Token static int ROAEWU ( int n , int p [ ] ) { int i , j , k , t ; for ( i = n - 2 ; i >= 0 && p [ i ] > p [ i + 1 ] ; i -- ) ; if ( i < 0 ) return 0 ; for ( j = i + 1 , k = n - 1 ; j < k ; j ++ , k -- ) { t = p [ j ] ; p [ j ] = p [ k ] ; p [ k ] = t ; } t = p [ i ] ; for ( j = i + 1 ; p [ j ] < t ; j ++ ) ; p [ i ] = p [ j ] ; p [ j ] = t ; return 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
AHHOG AHHOG ( "%d\n" , & n )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment p = 0
printf printf ( "Case #%d: " , i + 1 )
AHHOG AHHOG ( "%d %d %d\n" , & nc , & pd , & pg )
<operator>.logicalAnd ( pd != 100 ) && ( pg == 100 )
<operator>.greaterEqualsThan nc >= 100
<operator>.addition i + 1
printf printf ( "Broken\n" )
printf printf ( "Possible\n" )
<operator>.notEquals pd != 100
<operator>.equals pg == 100
<operator>.logicalAnd pd != 0 && pg == 0
<operator>.lessEqualsThan j <= nc
<operator>.postIncrement j ++
IDENTIFIER p if (p)
printf printf ( "Broken\n" )
<operator>.assignment j = 1
printf printf ( "Possible\n" )
<operator>.notEquals pd != 0
<operator>.equals pg == 0
<operator>.equals ( pd * j ) % 100 == 0
printf printf ( "Broken\n" )
<operator>.assignment p = 1
<operator>.modulo ( pd * j ) % 100
<operator>.multiplication pd * j
<operator>.addressOf & nc
<operator>.addressOf & pd
<operator>.addressOf & pg
>>>PDG&35 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->1 3->1 4->1 4->1 4->5 5->1 5->1 5->1 5->5 5->6 5->6 5->8 5->9 5->9 5->10 5->11 5->13 5->13 5->16 5->32 5->33 5->34 6->1 6->5 7->1 7->5 10->12 10->16 10->17 10->19 10->25 10->26 10->31 11->14 11->18 11->25 12->10 12->15 12->19 12->19 12->23 12->24 12->28 16->10 16->11 16->11 16->17 16->25 17->10 17->11 17->11 17->26 18->12 18->22 19->10 19->12 19->27 19->30 19->31 19->31 20->19 23->19 25->10 25->16 25->18 25->18 25->26 25->31 26->10 26->17 26->18 26->18 27->19 27->20 27->29 30->27 30->27 31->10 31->16 31->20 31->30 31->30
>>>Token int main ( int argc , char * * argv ) { int i , j , n , nc ; int pd , pg ; int p ; AHHOG ( " \n " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { p = 0 ; printf ( " " , i + 1 ) ; AHHOG ( " \n " , & nc , & pd , & pg ) ; if ( ( pd != 100 ) && ( pg == 100 ) ) { printf ( " \n " ) ; continue ; } else if ( pd != 0 && pg == 0 ) { printf ( " \n " ) ; continue ; } if ( nc >= 100 ) { printf ( " \n " ) ; continue ; } else { for ( j = 1 ; j <= nc ; j ++ ) { if ( ( pd * j ) % 100 == 0 ) { p = 1 ; break ; } } if ( p ) { printf ( " \n " ) ; } else { printf ( " \n " ) ; } } } }
>>>Func
METHOD GPIQJCAACOY
METHOD_RETURN void
printf printf ( "<<<< TEST FUNCTION >>>>\n" )
assert assert ( JYWLXJ ( "123" ) == atoi ( "123" ) )
assert assert ( JYWLXJ ( "-123" ) == atoi ( "-123" ) )
assert assert ( JYWLXJ ( "" ) == atoi ( "" ) )
assert assert ( JYWLXJ ( "-h23" ) == atoi ( "-h23" ) )
assert assert ( JYWLXJ ( "         23" ) == atoi ( "         23" ) )
assert assert ( JYWLXJ ( "999999999" ) == atoi ( "999999999" ) )
printf printf ( "<<<< TEST DONE >>>>\n" )
<operator>.equals JYWLXJ ( "123" ) == atoi ( "123" )
<operator>.equals JYWLXJ ( "-123" ) == atoi ( "-123" )
<operator>.equals JYWLXJ ( "" ) == atoi ( "" )
<operator>.equals JYWLXJ ( "-h23" ) == atoi ( "-h23" )
<operator>.equals JYWLXJ ( "         23" ) == atoi ( "         23" )
<operator>.equals JYWLXJ ( "999999999" ) == atoi ( "999999999" )
JYWLXJ JYWLXJ ( "123" )
atoi atoi ( "123" )
JYWLXJ JYWLXJ ( "-123" )
atoi atoi ( "-123" )
JYWLXJ JYWLXJ ( "" )
atoi atoi ( "" )
JYWLXJ JYWLXJ ( "-h23" )
atoi atoi ( "-h23" )
JYWLXJ JYWLXJ ( "         23" )
atoi atoi ( "         23" )
JYWLXJ JYWLXJ ( "999999999" )
atoi atoi ( "999999999" )
>>>PDG&28 0->2 0->9 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->1 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 9->1 10->1 10->1 10->3 10->3 11->1 11->1 11->4 11->4 12->1 12->1 12->5 12->5 13->1 13->1 13->6 13->6 14->1 14->1 14->7 14->7 15->1 15->1 15->8 15->8 16->10 17->10 18->11 19->11 20->12 21->12 22->13 23->13 24->14 25->14 26->15 27->15
>>>Token void GPIQJCAACOY ( ) { printf ( " \n " ) ; assert ( JYWLXJ ( " " ) == atoi ( " " ) ) ; assert ( JYWLXJ ( " " ) == atoi ( " " ) ) ; assert ( JYWLXJ ( " " ) == atoi ( " " ) ) ; assert ( JYWLXJ ( " " ) == atoi ( " " ) ) ; assert ( JYWLXJ ( " " ) == atoi ( " " ) ) ; assert ( JYWLXJ ( " " ) == atoi ( " " ) ) ; printf ( " \n " ) ; }
>>>Func
METHOD main
METHOD_RETURN int
SKKLU SKKLU ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
SKKLU SKKLU ( "%lld %d %d" , & N , & PD , & PG )
<operator>.assignment n = 100
<operator>.assignment m = PD
printf printf ( "Case #%d: " , i + 1 )
<operator>.lessThan d < 10
<operator>.postIncrement d ++
<operator>.logicalOr PG == 100 && PD != 100 || PG == 0 && PD != 0
<operator>.assignment d = 2
<operator>.addition i + 1
printf printf ( "Broken\n" )
<operator>.logicalAnd n % d == 0 && m % d == 0
<operator>.logicalAnd PG == 100 && PD != 100
<operator>.logicalAnd PG == 0 && PD != 0
<operator>.assignmentDivision n /= d
<operator>.assignmentDivision m /= d
<operator>.equals PG == 100
<operator>.notEquals PD != 100
<operator>.equals PG == 0
<operator>.notEquals PD != 0
<operator>.greaterEqualsThan N >= n
<operator>.equals n % d == 0
<operator>.equals m % d == 0
printf printf ( "Possible\n" )
<operator>.modulo n % d
<operator>.modulo m % d
printf printf ( "Broken\n" )
<operator>.addressOf & N
<operator>.addressOf & PD
<operator>.addressOf & PG
>>>PDG&37 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->11 4->12 4->14 4->15 4->16 4->16 4->19 4->23 4->34 4->35 4->36 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->1 8->10 8->23 8->24 8->25 8->26 8->27 9->1 9->1 9->27 9->31 10->1 10->1 10->1 10->22 10->32 11->1 11->1 12->1 12->1 12->12 12->13 12->18 12->28 12->31 12->31 13->1 13->12 14->1 14->1 14->1 14->17 14->27 15->1 15->12 17->1 18->1 18->1 18->1 18->18 18->21 18->22 18->28 18->31 19->1 19->1 19->14 19->14 19->20 19->25 20->1 20->1 20->14 20->14 21->1 21->31 22->1 22->1 22->32 23->1 23->8 23->19 23->19 23->24 23->25 24->1 24->8 24->10 24->19 24->19 24->26 25->1 25->8 25->20 25->20 25->23 25->26 26->1 26->8 26->10 26->20 26->20 26->24 27->1 27->1 27->1 27->8 27->30 27->33 28->1 28->18 28->18 28->29 28->32 29->1 29->18 29->18 30->1 31->1 31->13 31->21 31->21 31->22 31->27 31->28 31->28 31->32 32->1 32->13 32->21 32->22 32->22 32->29 32->29 32->31 33->1
>>>Token int main ( ) { int T , PD , PG ; long long N ; int i , j , k ; int d , n , m ; SKKLU ( " " , & T ) ; for ( i = 0 ; i < T ; i ++ ) { SKKLU ( " " , & N , & PD , & PG ) ; n = 100 ; m = PD ; for ( d = 2 ; d < 10 ; d ++ ) { while ( n % d == 0 && m % d == 0 ) { n /= d ; m /= d ; } } printf ( " " , i + 1 ) ; if ( PG == 100 && PD != 100 || PG == 0 && PD != 0 ) printf ( " \n " ) ; else if ( N >= n ) printf ( " \n " ) ; else printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD SOISV
METHOD_RETURN void
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment p [ i ] = 0
<operator>.assignment wp [ i ] = 0
<operator>.assignment i = 0
<operator>.assignment KJU [ i ] = 0
<operator>.assignmentDivision KJU [ i ] /= p [ i ]
<operator>.assignment i = 0
<operator>.assignment NCPL [ i ] = 0
<operator>.assignmentDivision NCPL [ i ] /= p [ i ]
<operator>.assignmentDivision wp [ i ] /= p [ i ]
<operator>.assignment NCPL [ i ] = NCPL [ i ] * 0.25 + KJU [ i ] * 0.5 + wp [ i ] * 0.25
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.addition NCPL [ i ] * 0.25 + KJU [ i ] * 0.5 + wp [ i ] * 0.25
<operator>.greaterEqualsThan a [ i ] [ j ] >= 0
<operator>.greaterEqualsThan a [ i ] [ j ] >= 0
<operator>.greaterEqualsThan a [ i ] [ j ] >= 0
<operator>.addition NCPL [ i ] * 0.25 + KJU [ i ] * 0.5
<operator>.multiplication wp [ i ] * 0.25
<operator>.postIncrement p [ i ] ++
<operator>.assignmentPlus wp [ i ] += a [ i ] [ j ]
<operator>.assignmentPlus KJU [ i ] += ( wp [ j ] - a [ j ] [ i ] ) / ( p [ j ] - 1 )
<operator>.assignmentPlus NCPL [ i ] += KJU [ j ]
<operator>.multiplication NCPL [ i ] * 0.25
<operator>.multiplication KJU [ i ] * 0.5
<operator>.division ( wp [ j ] - a [ j ] [ i ] ) / ( p [ j ] - 1 )
<operator>.subtraction wp [ j ] - a [ j ] [ i ]
<operator>.subtraction p [ j ] - 1
<operator>.indirectIndexAccess p [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess KJU [ i ]
<operator>.indirectIndexAccess KJU [ i ]
<operator>.indirectIndexAccess p [ i ]
<operator>.indirectIndexAccess NCPL [ i ]
<operator>.indirectIndexAccess NCPL [ i ]
<operator>.indirectIndexAccess p [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess p [ i ]
<operator>.indirectIndexAccess NCPL [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess a [ i ] [ j ]
<operator>.indirectIndexAccess a [ i ] [ j ]
<operator>.indirectIndexAccess a [ i ] [ j ]
<operator>.indirectIndexAccess NCPL [ i ]
<operator>.indirectIndexAccess KJU [ i ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess p [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess a [ i ] [ j ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess KJU [ i ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess NCPL [ i ]
<operator>.indirectIndexAccess KJU [ j ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess a [ j ] [ i ]
<operator>.indirectIndexAccess p [ j ]
<operator>.indirectIndexAccess a [ j ]
>>>PDG&74 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->33 0->38 0->39 0->42 2->2 2->3 2->3 2->4 2->9 2->10 2->19 2->19 2->25 2->43 2->44 3->1 3->2 4->4 4->5 4->5 4->6 4->12 4->13 4->21 4->21 4->26 4->45 4->46 4->47 5->1 5->4 6->1 6->1 6->1 6->6 6->7 6->7 6->15 6->16 6->17 6->18 6->23 6->23 6->27 6->28 6->32 6->33 6->38 6->39 6->48 6->49 6->50 6->51 6->52 6->53 6->54 6->58 6->59 7->1 7->6 8->2 9->1 9->1 9->13 9->16 9->34 10->1 10->1 10->17 10->35 11->4 12->1 12->13 12->36 13->1 13->1 13->1 13->39 14->1 14->6 15->1 15->16 15->37 16->1 16->38 17->1 17->1 17->33 18->1 18->1 18->1 19->1 19->1 19->2 19->19 19->20 19->20 19->29 19->55 19->60 20->1 20->19 21->1 21->1 21->4 21->21 21->22 21->22 21->30 21->56 21->64 22->1 22->21 23->1 23->1 23->6 23->23 23->24 23->24 23->31 23->57 23->66 24->1 24->23 25->1 25->19 26->1 26->21 27->1 27->23 28->1 28->1 29->1 29->1 29->30 29->31 29->34 29->35 29->35 29->61 29->62 29->63 29->69 30->1 30->1 30->31 30->36 30->40 30->41 30->42 30->65 30->70 30->71 30->72 30->73 31->1 31->1 31->37 31->67 31->68 32->1 32->1 33->1 33->17 33->18 33->18 33->28 33->28 34->1 34->1 34->13 34->16 35->1 35->1 35->1 35->17 36->1 36->1 36->13 37->1 37->1 37->16 38->18 38->18 38->28 38->28 38->32 38->32 39->1 39->18 39->18 39->28 39->28 39->32 39->32 40->1 40->1 40->36 40->36 41->1 41->1 41->40 41->40 42->1 42->40 42->40
>>>Token void SOISV ( ) { for ( i = 0 ; i < n ; i ++ ) { p [ i ] = 0 ; wp [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] >= 0 ) { p [ i ] ++ ; wp [ i ] += a [ i ] [ j ] ; } } } for ( i = 0 ; i < n ; i ++ ) { KJU [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] >= 0 ) { KJU [ i ] += ( wp [ j ] - a [ j ] [ i ] ) / ( p [ j ] - 1 ) ; } } KJU [ i ] /= p [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { NCPL [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] >= 0 ) { NCPL [ i ] += KJU [ j ] ; } } NCPL [ i ] /= p [ i ] ; wp [ i ] /= p [ i ] ; NCPL [ i ] = NCPL [ i ] * 0.25 + KJU [ i ] * 0.5 + wp [ i ] * 0.25 ; } }
>>>Func
METHOD main
METHOD_RETURN ANY
<operator>.assignment fl = 0
<operator>.assignment JSU = CNSVE ( "in.txt" , "r" )
<operator>.assignment XKL = CNSVE ( "out.txt" , "w" )
NCKLNO NCKLNO ( JSU , "%d" , & t )
<operator>.lessThan i < t
<operator>.postIncrement i ++
CNSVE CNSVE ( "in.txt" , "r" )
CNSVE CNSVE ( "out.txt" , "w" )
<operator>.assignment i = 0
<operator>.assignment fl = 0
NCKLNO NCKLNO ( JSU , "%d" , & n )
NCKLNO NCKLNO ( JSU , "%d" , & pd )
NCKLNO NCKLNO ( JSU , "%d" , & pg )
fprintf fprintf ( XKL , "Case #%d: " , i + 1 )
<operator>.logicalAnd ( ! fl ) && j <= n
<operator>.postIncrement j ++
IDENTIFIER fl if (fl)
<operator>.assignment j = 1
<operator>.addition i + 1
fprintf fprintf ( XKL , "Possible\n" )
<operator>.logicalNot ! fl
<operator>.lessEqualsThan j <= n
<operator>.equals ( j * pd ) % 100 == 0
fprintf fprintf ( XKL , "Broken\n" )
<operator>.assignment d = j * pd / 100
<operator>.modulo ( j * pd ) % 100
<operator>.equals pg == 0
<operator>.multiplication j * pd
<operator>.division j * pd / 100
<operator>.multiplication j * pd
<operator>.equals pd == 0
<operator>.assignment fl = 1
<operator>.equals pg == 100
<operator>.assignment fl = 0
<operator>.equals pd == 100
<operator>.assignment fl = 1
<operator>.assignment fl = 1
<operator>.addressOf & n
<operator>.addressOf & pd
<operator>.addressOf & pg
>>>PDG&42 0->2 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 2->1 2->1 3->1 3->1 3->5 4->1 4->1 4->1 4->15 5->1 5->1 5->1 5->6 5->12 6->1 6->1 6->1 6->6 6->7 6->7 6->11 6->12 6->13 6->14 6->15 6->15 6->16 6->19 6->20 6->20 6->21 6->22 6->25 6->39 6->40 6->41 7->1 7->6 8->3 8->3 9->4 9->4 10->1 10->6 11->1 11->22 12->1 12->1 12->13 12->23 13->1 13->1 13->14 13->29 13->31 13->32 13->36 14->1 14->1 14->1 14->12 14->28 14->34 15->1 15->1 15->21 15->25 16->1 16->1 16->1 16->16 16->17 16->22 16->24 16->27 16->29 17->1 17->1 17->23 17->29 19->1 19->1 19->23 19->29 21->1 21->1 21->15 22->1 22->16 22->23 23->1 23->1 23->12 23->16 23->16 23->29 24->1 24->1 24->26 24->28 24->30 24->31 25->1 25->1 25->15 26->1 26->1 26->1 27->1 27->24 27->24 28->1 28->1 28->14 28->32 28->34 28->34 29->1 29->13 29->17 29->27 29->27 29->31 29->31 30->1 30->26 30->26 31->1 31->13 31->17 31->29 31->30 31->30 31->32 31->36 32->1 32->1 32->13 32->29 32->33 32->35 33->1 33->22 34->1 34->1 34->14 34->28 34->36 34->37 35->1 35->22 36->1 36->1 36->13 36->29 36->38 37->1 37->22 38->1 38->22
>>>Token main ( ) { UPBF * JSU , * XKL ; int t , pd , pg , g , d , k , l , i , j , nj , n , fl = 0 ; JSU = CNSVE ( " " , " " ) ; XKL = CNSVE ( " " , " " ) ; NCKLNO ( JSU , " " , & t ) ; for ( i = 0 ; i < t ; i ++ ) { fl = 0 ; NCKLNO ( JSU , " " , & n ) ; NCKLNO ( JSU , " " , & pd ) ; NCKLNO ( JSU , " " , & pg ) ; for ( j = 1 ; ( ! fl ) && j <= n ; j ++ ) { if ( ( j * pd ) % 100 == 0 ) { d = j * pd / 100 ; if ( pg == 0 ) { if ( pd == 0 ) fl = 1 ; else fl = 0 ; } else { if ( pg == 100 ) { if ( pd == 100 ) fl = 1 ; } else fl = 1 ; } } } fprintf ( XKL , " " , i + 1 ) ; if ( fl ) fprintf ( XKL , " \n " ) ; else fprintf ( XKL , " \n " ) ; } }
>>>Func
METHOD THUMQ
METHOD_RETURN void
PARAM int OTL [ 10 ] [ 10 ]
PARAM int QFPQ
PARAM int CTBVJU
<operator>.logicalOr OTL [ QFPQ ] [ CTBVJU ] == 0 || OTL [ QFPQ ] [ CTBVJU ] == - 1
<operator>.assignment OTL [ QFPQ ] [ CTBVJU ] = - 2
<operator>.equals OTL [ QFPQ ] [ CTBVJU ] == 0
<operator>.equals OTL [ QFPQ ] [ CTBVJU ] == - 1
<operator>.minus - 1
<operator>.minus - 2
<operator>.equals OTL [ QFPQ ] [ CTBVJU ] == 1
<operator>.assignment OTL [ QFPQ ] [ CTBVJU ] = 10
<operator>.equals OTL [ QFPQ ] [ CTBVJU ] == 2
<operator>.assignment OTL [ QFPQ ] [ CTBVJU ] = 20
<operator>.equals OTL [ QFPQ ] [ CTBVJU ] == 3
<operator>.assignment OTL [ QFPQ ] [ CTBVJU ] = 30
<operator>.indirectIndexAccess OTL [ QFPQ ] [ CTBVJU ]
<operator>.indirectIndexAccess OTL [ QFPQ ] [ CTBVJU ]
<operator>.indirectIndexAccess OTL [ QFPQ ]
<operator>.indirectIndexAccess OTL [ QFPQ ]
<operator>.indirectIndexAccess OTL [ QFPQ ] [ CTBVJU ]
<operator>.indirectIndexAccess OTL [ QFPQ ]
<operator>.indirectIndexAccess OTL [ QFPQ ] [ CTBVJU ]
<operator>.indirectIndexAccess OTL [ QFPQ ]
<operator>.indirectIndexAccess OTL [ QFPQ ] [ CTBVJU ]
<operator>.indirectIndexAccess OTL [ QFPQ ]
<operator>.indirectIndexAccess OTL [ QFPQ ] [ CTBVJU ]
<operator>.indirectIndexAccess OTL [ QFPQ ]
<operator>.indirectIndexAccess OTL [ QFPQ ] [ CTBVJU ]
<operator>.indirectIndexAccess OTL [ QFPQ ]
<operator>.indirectIndexAccess OTL [ QFPQ ] [ CTBVJU ]
<operator>.indirectIndexAccess OTL [ QFPQ ]
>>>PDG&33 0->2 0->3 0->4 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 2->1 3->1 4->1 5->1 5->1 5->1 5->6 5->10 5->11 5->18 5->20 5->21 5->22 6->1 6->1 6->1 7->5 7->5 7->8 7->8 7->9 7->11 7->17 7->19 8->1 8->5 8->5 8->11 9->8 10->6 11->12 11->13 11->13 11->23 11->24 11->25 11->26 13->14 13->15 13->15 13->27 13->28 13->29 13->30 15->16 15->31 15->32
>>>Token void THUMQ ( int OTL [ 10 ] [ 10 ] , int QFPQ , int CTBVJU ) { if ( OTL [ QFPQ ] [ CTBVJU ] == 0 || OTL [ QFPQ ] [ CTBVJU ] == - 1 ) { OTL [ QFPQ ] [ CTBVJU ] = - 2 ; } else if ( OTL [ QFPQ ] [ CTBVJU ] == 1 ) { OTL [ QFPQ ] [ CTBVJU ] = 10 ; } else if ( OTL [ QFPQ ] [ CTBVJU ] == 2 ) { OTL [ QFPQ ] [ CTBVJU ] = 20 ; } else if ( OTL [ QFPQ ] [ CTBVJU ] == 3 ) { OTL [ QFPQ ] [ CTBVJU ] = 30 ; } }
>>>Func
METHOD QJBXAGYTOPGC
METHOD_RETURN int
PARAM int BWS
PARAM int i
RETURN return BWS * JWU ( 8 , i ) ; return BWS * JWU ( 8 , i ) ;
<operator>.multiplication BWS * JWU ( 8 , i )
JWU JWU ( 8 , i )
>>>PDG&7 0->2 0->3 0->5 0->6 2->5 3->6 4->1 5->1 5->1 5->1 5->4 6->1 6->5 6->5
>>>Token int QJBXAGYTOPGC ( int BWS , int i ) { return BWS * JWU ( 8 , i ) ; }
>>>Func
METHOD MVRTBBQYK
METHOD_RETURN char*
PARAM char const * OEF
PARAM size_t * YOVXI
PARAM SQEBYCLTEXQ KEFWC
PARAM int WSEXK
<operator>.assignment FKBJSAXQAI = * YOVXI
<operator>.assignment JQML = * YOVXI
<operator>.assignment QOY = JQML
<operator>.assignment * MUW = NULL
RETURN return MUW ; return MUW ;
<operator>.greaterEqualsThan QOY >= JQML
IDENTIFIER MUW return MUW ;
<operator>.assignment JQML = QOY + 1
<operator>.assignment DHDI = realloc ( MUW , JQML )
<operator>.assignment MUW = DHDI
<operator>.assignment * YOVXI = FKBJSAXQAI
<operator>.assignment QOY = FGIXMIKR ( OEF , MUW , JQML , YOVXI , KEFWC , WSEXK )
<operator>.equals DHDI == NULL
<operator>.equals QOY == TLDMNDDN
<operator>.addition QOY + 1
realloc realloc ( MUW , JQML )
free free ( MUW )
<operator>.assignment MUW = NULL
FGIXMIKR FGIXMIKR ( OEF , MUW , JQML , YOVXI , KEFWC , WSEXK )
free free ( MUW )
<operator>.assignment MUW = NULL
<operator>.indirection * YOVXI
>>>PDG&28 0->2 0->3 0->4 0->5 0->8 0->9 0->11 0->12 0->13 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->1 2->24 3->1 3->24 4->1 4->24 5->1 5->24 6->1 6->1 6->16 7->1 7->1 7->8 7->11 8->1 8->11 9->1 9->1 9->1 9->12 9->21 10->1 11->1 11->1 11->1 11->13 11->13 11->14 11->18 11->20 11->20 11->21 12->10 13->1 13->1 13->21 14->1 14->1 14->18 15->1 15->1 15->24 16->1 16->1 16->1 16->24 17->1 17->1 17->19 18->1 18->1 18->1 18->15 18->15 18->16 18->17 18->19 18->22 18->23 18->23 18->24 18->26 18->27 19->1 19->1 19->1 19->11 19->11 19->25 19->26 20->1 21->1 21->14 21->14 21->22 21->24 23->1 23->1 23->1 23->12 24->1 24->1 24->1 24->1 24->1 24->1 24->11 24->12 24->17 24->17 24->17 24->17 24->17 24->17 24->21 24->25 26->1 26->1 26->1 26->12
>>>Token char * MVRTBBQYK ( char const * OEF , size_t * YOVXI , SQEBYCLTEXQ KEFWC , int WSEXK ) { size_t FKBJSAXQAI = * YOVXI ; size_t JQML = * YOVXI ; size_t QOY = JQML ; char * MUW = NULL ; while ( QOY >= JQML ) { char * DHDI ; JQML = QOY + 1 ; DHDI = realloc ( MUW , JQML ) ; if ( DHDI == NULL ) { free ( MUW ) ; MUW = NULL ; break ; } MUW = DHDI ; * YOVXI = FKBJSAXQAI ; QOY = FGIXMIKR ( OEF , MUW , JQML , YOVXI , KEFWC , WSEXK ) ; if ( QOY == TLDMNDDN ) { free ( MUW ) ; MUW = NULL ; break ; } } return MUW ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment x = 1
SVKJU SVKJU ( "%d\n" , & t )
RETURN return 0 ; return 0 ;
<operator>.postDecrement t --
LITERAL 0 return 0 ;
SVKJU SVKJU ( "%d\n" , & n )
memset memset ( pg   0   n * sizeof ( int ) )
memset memset ( wg   0   n * sizeof ( int ) )
printf printf ( "Case #%d:\n" , x ++ )
<operator>.lessThan i < n
<operator>.preIncrement ++ i
<operator>.lessThan i < n
<operator>.preIncrement ++ i
<operator>.lessThan i < n
<operator>.preIncrement ++ i
<operator>.lessThan i < n
<operator>.preIncrement ++ i
<operator>.lessThan i < n
<operator>.preIncrement ++ i
printf printf ( "%lf\n" , wp [ i ] * 0.25 + EPC [ i ] * 0.5 + YGER [ i ] * 0.25 )
<operator>.assignment i = 0
SVKJU SVKJU ( "\n" )
<operator>.multiplication n * sizeof ( int )
<operator>.multiplication n * sizeof ( int )
<operator>.assignment i = 0
<operator>.assignment wp [ i ] = ( double ) wg [ i ] / ( double ) pg [ i ]
<operator>.assignment i = 0
<operator>.assignment SOI = 0
<operator>.assignment EPC [ i ] = 0.0
<operator>.assignmentDivision EPC [ i ] /= ( double ) ( SOI )
<operator>.assignment i = 0
<operator>.assignment SOI = YGER [ i ] = 0
<operator>.assignmentDivision YGER [ i ] /= ( double ) ( SOI )
<operator>.postIncrement x ++
<operator>.assignment i = 0
<operator>.lessThan j < n
<operator>.preIncrement ++ j
SVKJU SVKJU ( "%c" , & NCPLO [ i ] [ j ] )
<operator>.sizeOf sizeof ( int )
<operator>.lessThan j < n
<operator>.preIncrement ++ j
<operator>.lessThan j < n
<operator>.preIncrement ++ j
<operator>.lessThan j < n
<operator>.preIncrement ++ j
<operator>.addition wp [ i ] * 0.25 + EPC [ i ] * 0.5 + YGER [ i ] * 0.25
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.division ( double ) wg [ i ] / ( double ) pg [ i ]
<operator>.assignment j = 0
<operator>.cast ( double ) ( SOI )
<operator>.assignment YGER [ i ] = 0
<operator>.assignment j = 0
<operator>.cast ( double ) ( SOI )
<operator>.addition wp [ i ] * 0.25 + EPC [ i ] * 0.5
<operator>.multiplication YGER [ i ] * 0.25
<operator>.cast ( double ) wg [ i ]
<operator>.cast ( double ) pg [ i ]
<operator>.expressionList YGER [ i ] += EPC [ j ]   SOI ++
<operator>.multiplication wp [ i ] * 0.25
<operator>.multiplication EPC [ i ] * 0.5
LITERAL '0' <empty>
<operator>.assignment op [ i ] [ j ] = 1
<operator>.postIncrement pg [ i ] ++
LITERAL '1' <empty>
<operator>.assignment op [ i ] [ j ] = 1
<operator>.postIncrement pg [ i ] ++
<operator>.postIncrement wg [ i ] ++
LITERAL '.' <empty>
<operator>.assignment op [ i ] [ j ] = 0
<operator>.postIncrement SOI ++
<operator>.assignment wg [ 0 ] = pg [ 0 ] = 0
<operator>.assignmentPlus EPC [ i ] += ( double ) wg [ 0 ] / ( double ) pg [ 0 ]
<operator>.lessThan k < n
<operator>.preIncrement ++ k
<operator>.assignmentPlus YGER [ i ] += EPC [ j ]
<operator>.postIncrement SOI ++
<operator>.assignment pg [ 0 ] = 0
<operator>.assignment k = 0
<operator>.division ( double ) wg [ 0 ] / ( double ) pg [ 0 ]
<operator>.notEquals k != i
<operator>.cast ( double ) wg [ 0 ]
<operator>.cast ( double ) pg [ 0 ]
LITERAL '0' <empty>
<operator>.postIncrement pg [ 0 ] ++
LITERAL '1' <empty>
<operator>.postIncrement pg [ 0 ] ++
<operator>.postIncrement wg [ 0 ] ++
LITERAL '.' <empty>
<operator>.addressOf & n
<operator>.sizeOf sizeof ( int )
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess EPC [ i ]
<operator>.indirectIndexAccess EPC [ i ]
<operator>.indirectIndexAccess YGER [ i ]
<operator>.addressOf & NCPLO [ i ] [ j ]
UNKNOWN double double
<operator>.indirectIndexAccess YGER [ i ]
<operator>.indirectIndexAccess op [ i ] [ j ]
UNKNOWN double double
<operator>.indirectIndexAccess YGER [ i ]
<operator>.indirectIndexAccess NCPLO [ i ] [ j ]
<operator>.indirectIndexAccess NCPLO [ i ] [ j ]
UNKNOWN double double
<operator>.indirectIndexAccess wg [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess pg [ i ]
<operator>.indirectIndexAccess op [ i ] [ j ]
<operator>.indirectIndexAccess op [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess EPC [ i ]
<operator>.indirectIndexAccess NCPLO [ i ]
<operator>.indirectIndexAccess NCPLO [ i ]
<operator>.indirectIndexAccess op [ i ]
<operator>.indirectIndexAccess op [ i ] [ j ]
<operator>.indirectIndexAccess pg [ i ]
<operator>.indirectIndexAccess op [ i ] [ j ]
<operator>.indirectIndexAccess pg [ i ]
<operator>.indirectIndexAccess wg [ i ]
<operator>.indirectIndexAccess op [ i ] [ j ]
<operator>.indirectIndexAccess wg [ 0 ]
<operator>.indirectIndexAccess EPC [ i ]
<operator>.indirectIndexAccess YGER [ i ]
<operator>.indirectIndexAccess EPC [ j ]
<operator>.indirectIndexAccess op [ i ]
<operator>.indirectIndexAccess op [ i ]
<operator>.indirectIndexAccess op [ i ]
<operator>.indirectIndexAccess pg [ 0 ]
UNKNOWN double double
<operator>.indirectIndexAccess wg [ 0 ]
UNKNOWN double double
<operator>.indirectIndexAccess pg [ 0 ]
<operator>.indirectIndexAccess NCPLO [ j ] [ k ]
<operator>.indirectIndexAccess NCPLO [ j ]
<operator>.indirectIndexAccess pg [ 0 ]
<operator>.indirectIndexAccess pg [ 0 ]
<operator>.indirectIndexAccess wg [ 0 ]
>>>PDG&139 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->41 0->42 0->43 0->44 0->45 0->46 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->57 0->61 0->62 0->63 0->64 0->66 0->67 0->70 0->71 0->72 0->73 0->75 0->76 0->78 0->79 0->80 0->82 0->85 0->87 0->90 2->1 2->1 2->35 3->1 3->1 3->5 4->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->13 5->15 5->17 5->19 5->22 5->24 5->25 5->26 5->28 5->32 5->35 5->36 5->40 5->91 5->92 6->4 7->1 7->1 7->11 7->13 7->15 7->17 7->19 7->24 7->25 7->37 7->41 7->43 7->45 7->75 8->1 8->1 8->50 8->59 8->65 8->68 8->81 8->84 8->86 8->88 9->1 9->1 9->1 9->50 9->58 9->69 9->81 9->83 9->89 10->1 10->1 11->11 11->12 11->12 11->23 11->24 11->37 11->37 11->48 12->1 12->11 13->13 13->14 13->14 13->15 13->27 13->41 13->41 13->49 13->50 13->58 13->59 13->93 13->105 13->106 13->107 13->108 14->1 14->13 15->15 15->16 15->16 15->17 15->29 15->30 15->31 15->43 15->43 15->51 15->52 15->82 15->94 15->95 15->98 16->1 16->15 17->17 17->18 17->18 17->19 17->33 17->34 17->45 17->45 17->53 17->54 17->55 17->96 17->99 17->101 18->1 18->17 19->1 19->1 19->1 19->7 19->11 19->19 19->20 19->20 19->21 19->47 19->56 19->57 19->61 19->62 19->102 19->111 19->112 20->1 20->19 21->1 21->1 22->11 23->1 24->8 24->25 25->9 25->13 26->13 27->1 27->1 27->1 27->61 28->15 29->1 29->31 29->52 29->72 30->1 30->31 30->74 31->1 31->1 31->1 31->62 32->17 33->1 33->1 33->34 33->55 33->78 34->1 34->1 34->1 34->57 35->1 35->10 36->1 36->19 37->1 37->1 37->11 37->37 37->38 37->38 37->39 37->97 37->103 37->113 38->1 38->37 39->1 39->1 40->1 41->1 41->1 41->13 41->41 41->42 41->42 41->104 41->114 42->1 42->41 43->1 43->1 43->15 43->43 43->44 43->44 43->75 43->109 43->115 44->1 44->43 45->1 45->1 45->17 45->45 45->46 45->46 45->100 45->110 46->1 46->45 47->1 47->1 48->1 48->37 49->1 49->41 50->1 50->1 50->27 50->27 51->1 51->43 52->1 53->33 53->34 53->77 54->1 54->45 55->1 56->1 56->1 57->1 57->21 57->21 57->47 57->47 58->1 59->1 60->1 60->1 60->1 61->1 61->21 61->21 61->47 61->47 61->56 61->56 62->1 62->21 62->21 62->47 62->47 62->56 62->56 64->1 64->1 65->1 65->8 65->50 65->59 65->68 67->1 67->1 68->1 68->8 68->50 68->59 68->65 69->1 69->9 69->50 69->58 71->1 71->1 72->1 72->31 72->52 73->1 73->1 73->9 73->81 73->83 73->89 74->1 74->1 74->31 75->1 75->1 75->43 75->75 75->76 75->82 75->82 76->1 76->75 77->1 77->34 77->60 78->34 78->55 78->60 79->8 79->73 79->81 79->84 79->86 79->88 80->1 80->75 81->1 81->1 81->74 81->74 82->1 82->16 82->76 82->134 82->135 83->1 84->1 86->1 86->8 86->81 86->84 86->88 88->1 88->8 88->81 88->84 88->86 89->1 89->9 89->81 89->83 100->60 100->77 100->78 100->124 100->125 104->64 104->65 104->67 104->68 104->69 104->71 104->116 104->117 104->118 104->119 104->120 104->121 104->126 104->127 104->128 109->72 109->73 109->74 109->75 109->79 109->80 109->81 109->83 109->84 109->122 109->123 109->129 109->130 109->131 109->132 109->133 134->86 134->88 134->89 134->136 134->137 134->138
>>>Token int main ( ) { char c ; int i , j , k , l , n , t , SOI , x = 1 ; SVKJU ( " \n " , & t ) ; while ( t -- ) { SVKJU ( " \n " , & n ) ; for ( i = 0 ; i < n ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) SVKJU ( " " , & NCPLO [ i ] [ j ] ) ; SVKJU ( " \n " ) ; } memset ( pg , 0 , n * sizeof ( int ) ) ; memset ( wg , 0 , n * sizeof ( int ) ) ; for ( i = 0 ; i < n ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) { switch ( NCPLO [ i ] [ j ] ) { case ' ' : op [ i ] [ j ] = 1 ; pg [ i ] ++ ; break ; case ' ' : op [ i ] [ j ] = 1 ; pg [ i ] ++ ; wg [ i ] ++ ; break ; case ' ' : op [ i ] [ j ] = 0 ; break ; } } wp [ i ] = ( double ) wg [ i ] / ( double ) pg [ i ] ; } for ( i = 0 ; i < n ; ++ i ) { SOI = 0 ; EPC [ i ] = 0.0 ; for ( j = 0 ; j < n ; ++ j ) { if ( op [ i ] [ j ] ) { SOI ++ ; wg [ 0 ] = pg [ 0 ] = 0 ; for ( k = 0 ; k < n ; ++ k ) { if ( k != i ) { switch ( NCPLO [ j ] [ k ] ) { case ' ' : pg [ 0 ] ++ ; break ; case ' ' : pg [ 0 ] ++ ; wg [ 0 ] ++ ; break ; case ' ' : break ; } } } EPC [ i ] += ( double ) wg [ 0 ] / ( double ) pg [ 0 ] ; } } EPC [ i ] /= ( double ) ( SOI ) ; } for ( i = 0 ; i < n ; ++ i ) { SOI = YGER [ i ] = 0 ; for ( j = 0 ; j < n ; ++ j ) if ( op [ i ] [ j ] ) YGER [ i ] += EPC [ j ] , SOI ++ ; YGER [ i ] /= ( double ) ( SOI ) ; } printf ( " \n " , x ++ ) ; for ( i = 0 ; i < n ; ++ i ) printf ( " \n " , wp [ i ] * 0.25 + EPC [ i ] * 0.5 + YGER [ i ] * 0.25 ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment YBSCQDMLYENAPXBH = NMGSY ( argv [ 1 ] , "rt" )
<operator>.assignment MMCVOCHNPGQUIKUHN = NMGSY ( argv [ 2 ] , "wt+" )
<operator>.assignment GFOSIYRIFJEFN = ( char * ) malloc ( 102400 )
<operator>.assignment SAEMUXMWWNP = ( char * ) malloc ( 1000 )
<operator>.assignment KVVCHDNNKCILGUI = ( char * ) malloc ( 3002 )
TUFIU TUFIU ( GFOSIYRIFJEFN , 102400 , YBSCQDMLYENAPXBH )
UIXFUM UIXFUM ( GFOSIYRIFJEFN , "%d" , & GSXOBKSLB )
<operator>.lessThan printf <LARBJKY
<operator>.greaterThan ';'> ( "number is %d\n" , GSXOBKSLB )
IDENTIFIER RWVB <empty>
free free ( GFOSIYRIFJEFN )
free free ( SAEMUXMWWNP )
free free ( KVVCHDNNKCILGUI )
RHTWEHGUL RHTWEHGUL ( )
RETURN return 0 ; return 0 ;
<operator>.greaterThan GSXOBKSLB > DRVAC
<operator>.postIncrement DRVAC ++
LITERAL 0 return 0 ;
NMGSY NMGSY ( argv [ 1 ] , "rt" )
NMGSY NMGSY ( argv [ 2 ] , "wt+" )
<operator>.cast ( char * ) malloc ( 102400 )
<operator>.cast ( char * ) malloc ( 1000 )
<operator>.cast ( char * ) malloc ( 3002 )
<operator>.bracketedPrimary ( "number is %d\n" , GSXOBKSLB )
<operator>.assignment DRVAC = 0
TUFIU TUFIU ( GFOSIYRIFJEFN , 102400 , YBSCQDMLYENAPXBH )
<operator>.lessThan printf <LARBJKY
<operator>.greaterThan ';'> ( "%d:input is %s\n" , DRVAC , GFOSIYRIFJEFN )
<operator>.assignment IWGVJFFPNV = NJNTEO ( GFOSIYRIFJEFN , " " )
UIXFUM UIXFUM ( IWGVJFFPNV , "%d" , & BJIKIIBNI )
<operator>.lessThan printf <LARBJKY
<operator>.greaterThan ';'> ( "numberOfC is %d\n" , BJIKIIBNI )
<operator>.assignment CTAGCN = ( char * ) malloc ( 2 * BJIKIIBNI )
<operator>.assignment YFGKCN = ( char * ) malloc ( BJIKIIBNI )
memset memset ( CTAGCN , 0x00 , 2 * BJIKIIBNI )
memset memset ( YFGKCN , 0x00 , BJIKIIBNI )
<operator>.assignment WKAOICDRAOIIG = CTAGCN
<operator>.assignment XLKAYJMBYUDEP = YFGKCN
<operator>.lessThan printf <LARBJKY
<operator>.greaterThan ';'> ( "arrayC\011= %s\n" , CTAGCN )
printf printf ( "transC\011= %s\n" , YFGKCN )
<operator>.assignment IWGVJFFPNV = NJNTEO ( NULL , " " )
UIXFUM UIXFUM ( IWGVJFFPNV , "%d" , & YYUBBENED )
<operator>.lessThan printf <LARBJKY
<operator>.greaterThan ';'> ( "numberOfD is %d\n" , YYUBBENED )
<operator>.assignment MAXSHG = ( char * ) malloc ( YYUBBENED * 2 )
memset memset ( MAXSHG , 0x00 , 2 * YYUBBENED )
<operator>.assignment KCIQGXFGVAQFY = MAXSHG
<operator>.assignment IWGVJFFPNV = NJNTEO ( NULL , " " )
UIXFUM UIXFUM ( IWGVJFFPNV , "%d" , & IUDOIHSVRCX )
<operator>.assignment IWGVJFFPNV = NJNTEO ( NULL , " " )
<operator>.assignment OLTHAXLVNYD = 0
<operator>.assignment NDCVNKFQXNRA = strlen ( MAXSHG )
<operator>.assignment KKHCQDAHGKCS = strlen ( CTAGCN )
memset memset ( SAEMUXMWWNP , 0x00 , 1000 )
<operator>.assignment KVVCHDNNKCILGUI [ 0 ] = '['
<operator>.assignment EHIDWXLUEKGMRXANJXLNFO = KVVCHDNNKCILGUI + 1
<operator>.assignment * ( EHIDWXLUEKGMRXANJXLNFO ) = ']'
<operator>.assignment * ( EHIDWXLUEKGMRXANJXLNFO + 1 ) = 0x00
printf printf ( "Case #%d: %s\n" , DRVAC + 1 , KVVCHDNNKCILGUI )
fprintf fprintf ( MMCVOCHNPGQUIKUHN , "Case #%d: %s\n" , DRVAC + 1 , KVVCHDNNKCILGUI )
free free ( CTAGCN )
free free ( MAXSHG )
free free ( YFGKCN )
malloc malloc ( 102400 )
malloc malloc ( 1000 )
malloc malloc ( 3002 )
<operator>.expressionList "number is %d\n"   GSXOBKSLB
<operator>.greaterThan BJIKIIBNI > LSNRST
<operator>.postIncrement LSNRST ++
<operator>.greaterThan YYUBBENED > LSNRST
<operator>.postIncrement LSNRST ++
<operator>.greaterThan IUDOIHSVRCX > LSNRST
<operator>.postIncrement LSNRST ++
<operator>.greaterThan OLTHAXLVNYD > LSNRST
<operator>.postIncrement LSNRST ++
<operator>.notEquals 0 != OLTHAXLVNYD
<operator>.bracketedPrimary ( "%d:input is %s\n" , DRVAC , GFOSIYRIFJEFN )
NJNTEO NJNTEO ( GFOSIYRIFJEFN , " " )
<operator>.bracketedPrimary ( "numberOfC is %d\n" , BJIKIIBNI )
<operator>.cast ( char * ) malloc ( 2 * BJIKIIBNI )
<operator>.cast ( char * ) malloc ( BJIKIIBNI )
<operator>.multiplication 2 * BJIKIIBNI
<operator>.assignment LSNRST = 0
<operator>.assignment IWGVJFFPNV = NJNTEO ( NULL , " " )
memcpy memcpy ( WKAOICDRAOIIG , IWGVJFFPNV , 2 )
memcpy memcpy ( XLKAYJMBYUDEP , IWGVJFFPNV + 2 , 1 )
<operator>.assignmentPlus WKAOICDRAOIIG += 2
<operator>.postIncrement XLKAYJMBYUDEP ++
<operator>.bracketedPrimary ( "arrayC\011= %s\n" , CTAGCN )
NJNTEO NJNTEO ( NULL , " " )
<operator>.bracketedPrimary ( "numberOfD is %d\n" , YYUBBENED )
<operator>.cast ( char * ) malloc ( YYUBBENED * 2 )
<operator>.multiplication 2 * YYUBBENED
<operator>.assignment LSNRST = 0
<operator>.assignment IWGVJFFPNV = NJNTEO ( NULL , " " )
memcpy memcpy ( KCIQGXFGVAQFY , IWGVJFFPNV , 2 )
<operator>.assignmentPlus KCIQGXFGVAQFY += 2
NJNTEO NJNTEO ( NULL , " " )
NJNTEO NJNTEO ( NULL , " " )
strlen strlen ( MAXSHG )
strlen strlen ( CTAGCN )
<operator>.assignment LSNRST = 0
<operator>.lessThan printf <LARBJKY
<operator>.greaterThan ';'> ( "%d:%s\n" , LSNRST , SAEMUXMWWNP )
IDENTIFIER RWVB <empty>
<operator>.addition KVVCHDNNKCILGUI + 1
<operator>.assignment LSNRST = 0
<operator>.assignment EHIDWXLUEKGMRXANJXLNFO [ 0 ] = SAEMUXMWWNP [ LSNRST ]
<operator>.assignment EHIDWXLUEKGMRXANJXLNFO [ 1 ] = ' '
<operator>.assignment EHIDWXLUEKGMRXANJXLNFO [ 2 ] = ' '
<operator>.assignmentPlus EHIDWXLUEKGMRXANJXLNFO += 3
<operator>.assignmentMinus EHIDWXLUEKGMRXANJXLNFO -= 2
<operator>.addition DRVAC + 1
<operator>.addition DRVAC + 1
<operator>.expressionList "%d:input is %s\n"   DRVAC   GFOSIYRIFJEFN
<operator>.expressionList "numberOfC is %d\n"   BJIKIIBNI
malloc malloc ( 2 * BJIKIIBNI )
malloc malloc ( BJIKIIBNI )
<operator>.expressionList "arrayC\011= %s\n"   CTAGCN
<operator>.expressionList "numberOfD is %d\n"   YYUBBENED
malloc malloc ( YYUBBENED * 2 )
<operator>.greaterThan NDCVNKFQXNRA > ACXYPJ
<operator>.postIncrement ACXYPJ ++
<operator>.notEquals NDCVNKFQXNRA != ACXYPJ
<operator>.greaterThan KKHCQDAHGKCS > ACXYPJ
<operator>.postIncrement ACXYPJ ++
<operator>.equals KKHCQDAHGKCS == ACXYPJ
<operator>.addition EHIDWXLUEKGMRXANJXLNFO + 1
<operator>.multiplication 2 * BJIKIIBNI
NJNTEO NJNTEO ( NULL , " " )
<operator>.addition IWGVJFFPNV + 2
<operator>.multiplication YYUBBENED * 2
NJNTEO NJNTEO ( NULL , " " )
<operator>.bracketedPrimary ( "%d:%s\n" , LSNRST , SAEMUXMWWNP )
<operator>.assignment ACXYPJ = 0
<operator>.assignment ACXYPJ = 0
<operator>.assignment SAEMUXMWWNP [ OLTHAXLVNYD ] = IWGVJFFPNV [ LSNRST ]
<operator>.postIncrement OLTHAXLVNYD ++
<operator>.expressionList "%d:%s\n"   LSNRST   SAEMUXMWWNP
<operator>.equals IWGVJFFPNV [ LSNRST ] == MAXSHG [ ACXYPJ ]
<operator>.equals IWGVJFFPNV [ LSNRST ] == CTAGCN [ ACXYPJ ]
<operator>.assignment IHBR = 0
<operator>.assignment IHBR = 0
<operator>.modulo ACXYPJ % 2
<operator>.equals 1 == IHBR
<operator>.modulo ACXYPJ % 2
<operator>.equals 1 == IHBR
LITERAL 1 <empty>
LITERAL 0 <empty>
LITERAL 1 <empty>
LITERAL 0 <empty>
<operator>.lessEqualsThan 0 <= JONJYG
<operator>.postDecrement JONJYG --
<operator>.lessEqualsThan 0 <= JONJYG
<operator>.postDecrement JONJYG --
<operator>.equals CTAGCN [ ACXYPJ - 1 ] == SAEMUXMWWNP [ OLTHAXLVNYD - 1 ]
<operator>.equals CTAGCN [ ACXYPJ + 1 ] == SAEMUXMWWNP [ OLTHAXLVNYD - 1 ]
<operator>.assignment JONJYG = OLTHAXLVNYD - 1
<operator>.assignment JONJYG = OLTHAXLVNYD - 1
<operator>.assignment SAEMUXMWWNP [ OLTHAXLVNYD - 1 ] = YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ]
<operator>.assignment IHBR = 1
<operator>.assignment SAEMUXMWWNP [ OLTHAXLVNYD - 1 ] = YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ]
<operator>.assignment IHBR = 1
<operator>.equals MAXSHG [ ACXYPJ - 1 ] == SAEMUXMWWNP [ JONJYG ]
<operator>.equals MAXSHG [ ACXYPJ + 1 ] == SAEMUXMWWNP [ JONJYG ]
<operator>.subtraction OLTHAXLVNYD - 1
<operator>.assignment OLTHAXLVNYD = JONJYG
<operator>.assignment IHBR = 1
<operator>.subtraction OLTHAXLVNYD - 1
<operator>.assignment OLTHAXLVNYD = JONJYG
<operator>.assignment IHBR = 1
<operator>.subtraction ACXYPJ - 1
<operator>.subtraction OLTHAXLVNYD - 1
<operator>.equals IWGVJFFPNV [ LSNRST + 1 ] == CTAGCN [ ACXYPJ - 1 ]
<operator>.addition ACXYPJ + 1
<operator>.subtraction OLTHAXLVNYD - 1
<operator>.equals IWGVJFFPNV [ LSNRST + 1 ] == CTAGCN [ ACXYPJ + 1 ]
<operator>.subtraction OLTHAXLVNYD - 1
<operator>.cast ( int ) OYUYV ( ACXYPJ / 2 )
<operator>.assignment SAEMUXMWWNP [ OLTHAXLVNYD ] = YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ]
<operator>.postIncrement OLTHAXLVNYD ++
<operator>.postIncrement LSNRST ++
<operator>.assignment IHBR = 1
<operator>.subtraction OLTHAXLVNYD - 1
<operator>.cast ( int ) OYUYV ( ACXYPJ / 2 )
<operator>.assignment SAEMUXMWWNP [ OLTHAXLVNYD ] = YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ]
<operator>.postIncrement OLTHAXLVNYD ++
<operator>.postIncrement LSNRST ++
<operator>.assignment IHBR = 1
<operator>.subtraction ACXYPJ - 1
<operator>.addition ACXYPJ + 1
OYUYV OYUYV ( ACXYPJ / 2 )
OYUYV OYUYV ( ACXYPJ / 2 )
<operator>.division ACXYPJ / 2
<operator>.addition LSNRST + 1
<operator>.subtraction ACXYPJ - 1
<operator>.division ACXYPJ / 2
<operator>.addition LSNRST + 1
<operator>.addition ACXYPJ + 1
<operator>.cast ( int ) OYUYV ( ACXYPJ / 2 )
<operator>.cast ( int ) OYUYV ( ACXYPJ / 2 )
OYUYV OYUYV ( ACXYPJ / 2 )
OYUYV OYUYV ( ACXYPJ / 2 )
<operator>.division ACXYPJ / 2
<operator>.division ACXYPJ / 2
UNKNOWN G G
UNKNOWN Y Y
UNKNOWN G G
UNKNOWN Y Y
UNKNOWN G G
UNKNOWN Y Y
UNKNOWN G G
UNKNOWN Y Y
<operator>.addressOf & BJIKIIBNI
<operator>.addressOf & YYUBBENED
<operator>.addressOf & IUDOIHSVRCX
<operator>.indirectIndexAccess KVVCHDNNKCILGUI [ 0 ]
<operator>.indirection * ( EHIDWXLUEKGMRXANJXLNFO )
<operator>.indirection * ( EHIDWXLUEKGMRXANJXLNFO + 1 )
UNKNOWN char * char *
UNKNOWN char * char *
UNKNOWN char * char *
UNKNOWN G G
UNKNOWN Y Y
UNKNOWN B B
<operator>.indirectIndexAccess EHIDWXLUEKGMRXANJXLNFO [ 0 ]
<operator>.indirectIndexAccess SAEMUXMWWNP [ LSNRST ]
<operator>.indirectIndexAccess EHIDWXLUEKGMRXANJXLNFO [ 1 ]
<operator>.indirectIndexAccess EHIDWXLUEKGMRXANJXLNFO [ 2 ]
<operator>.indirectIndexAccess SAEMUXMWWNP [ OLTHAXLVNYD ]
<operator>.indirectIndexAccess IWGVJFFPNV [ LSNRST ]
<operator>.indirectIndexAccess IWGVJFFPNV [ LSNRST ]
<operator>.indirectIndexAccess MAXSHG [ ACXYPJ ]
<operator>.indirectIndexAccess IWGVJFFPNV [ LSNRST ]
<operator>.indirectIndexAccess CTAGCN [ ACXYPJ ]
<operator>.indirectIndexAccess CTAGCN [ ACXYPJ - 1 ]
<operator>.indirectIndexAccess SAEMUXMWWNP [ OLTHAXLVNYD - 1 ]
<operator>.indirectIndexAccess CTAGCN [ ACXYPJ + 1 ]
<operator>.indirectIndexAccess SAEMUXMWWNP [ OLTHAXLVNYD - 1 ]
<operator>.indirectIndexAccess SAEMUXMWWNP [ OLTHAXLVNYD - 1 ]
<operator>.indirectIndexAccess YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ]
<operator>.indirectIndexAccess SAEMUXMWWNP [ OLTHAXLVNYD - 1 ]
<operator>.indirectIndexAccess YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ]
<operator>.indirectIndexAccess MAXSHG [ ACXYPJ - 1 ]
<operator>.indirectIndexAccess SAEMUXMWWNP [ JONJYG ]
<operator>.indirectIndexAccess MAXSHG [ ACXYPJ + 1 ]
<operator>.indirectIndexAccess SAEMUXMWWNP [ JONJYG ]
UNKNOWN int int
<operator>.indirectIndexAccess IWGVJFFPNV [ LSNRST + 1 ]
<operator>.indirectIndexAccess CTAGCN [ ACXYPJ - 1 ]
UNKNOWN int int
<operator>.indirectIndexAccess IWGVJFFPNV [ LSNRST + 1 ]
<operator>.indirectIndexAccess CTAGCN [ ACXYPJ + 1 ]
<operator>.indirectIndexAccess SAEMUXMWWNP [ OLTHAXLVNYD ]
<operator>.indirectIndexAccess YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ]
<operator>.indirectIndexAccess SAEMUXMWWNP [ OLTHAXLVNYD ]
<operator>.indirectIndexAccess YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ]
UNKNOWN int int
UNKNOWN int int
>>>PDG&264 0->2 0->3 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->28 0->29 0->30 0->31 0->33 0->34 0->35 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->50 0->51 0->53 0->55 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->82 0->86 0->87 0->89 0->90 0->91 0->92 0->94 0->97 0->98 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->122 0->123 0->124 0->126 0->127 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->139 0->140 0->142 0->143 0->146 0->147 0->148 0->149 0->150 0->151 0->152 0->153 0->154 0->155 0->156 0->157 0->158 0->159 0->165 0->167 0->170 0->171 0->172 0->173 0->174 0->175 0->176 0->177 0->179 0->180 0->182 0->185 0->186 0->187 0->188 0->191 0->192 0->193 0->194 0->195 0->198 0->199 0->200 0->201 0->202 0->203 0->208 0->209 2->1 3->1 3->22 3->23 4->1 4->1 4->9 5->1 5->1 5->1 5->64 6->1 6->1 6->9 7->1 7->1 7->15 7->58 8->1 8->1 8->16 8->60 8->63 8->110 9->1 9->1 9->10 9->29 10->1 10->1 10->14 10->19 10->29 10->71 11->1 11->1 11->1 11->30 11->30 12->1 12->1 14->1 15->1 16->1 17->1 18->1 19->1 19->1 19->1 19->19 19->20 19->29 19->30 19->31 19->32 19->33 19->34 19->35 19->36 19->37 19->38 19->39 19->40 19->41 19->42 19->43 19->44 19->45 19->46 19->47 19->48 19->49 19->50 19->51 19->52 19->53 19->54 19->55 19->56 19->57 19->58 19->59 19->60 19->61 19->62 19->63 19->64 19->65 19->66 19->67 19->72 19->74 19->76 19->78 19->80 19->81 19->82 19->83 19->84 19->85 19->86 19->87 19->93 19->94 19->95 19->96 19->97 19->98 19->102 19->103 19->104 19->105 19->106 19->110 19->111 19->117 19->118 19->119 19->119 19->120 19->121 19->122 19->123 19->124 19->125 19->132 19->133 19->136 19->210 19->211 19->212 19->213 19->214 19->215 19->216 19->217 19->218 19->219 19->220 19->221 19->222 19->223 19->224 19->225 19->226 20->1 20->19 21->18 22->1 22->4 22->4 23->1 23->5 23->5 24->1 25->1 26->1 27->1 27->12 28->1 28->19 29->1 29->1 29->119 30->34 30->34 31->1 31->1 32->1 32->1 32->33 33->1 33->1 33->39 33->72 33->86 33->120 33->122 33->133 34->42 34->42 35->1 35->1 36->1 36->1 36->38 37->1 37->1 37->39 38->1 38->1 38->40 38->123 39->1 39->41 39->44 39->72 40->1 40->1 40->89 41->1 41->1 41->90 42->47 42->47 43->1 43->1 44->1 44->39 44->41 44->67 44->164 44->166 44->184 44->190 45->46 46->1 46->1 46->74 46->97 46->124 46->136 47->1 47->1 47->1 47->30 47->30 47->107 47->107 48->1 48->1 49->1 49->1 49->50 50->1 50->1 50->51 50->104 51->1 51->1 51->100 52->53 53->1 53->1 53->76 54->1 54->1 54->1 54->33 54->46 54->53 54->89 54->90 54->100 54->135 54->141 54->144 54->145 54->178 54->181 55->1 55->78 55->142 55->170 55->173 55->177 55->180 56->1 56->1 56->1 56->126 57->1 57->1 57->1 57->129 58->1 58->15 58->112 58->143 59->1 59->1 59->16 59->60 59->63 59->64 59->110 60->1 60->1 60->115 60->116 60->132 61->1 61->1 61->115 61->116 61->132 62->1 62->1 63->1 63->64 64->1 64->1 64->1 64->16 64->60 64->63 64->110 65->1 66->1 67->1 68->6 68->24 69->7 69->25 70->8 70->26 71->19 71->27 71->27 72->1 72->1 72->33 72->72 72->73 72->73 72->88 72->89 72->90 72->91 72->92 72->120 72->134 72->135 73->1 73->72 74->1 74->1 74->46 74->74 74->75 74->75 74->99 74->100 74->101 74->124 74->137 75->1 75->74 76->1 76->1 76->53 76->76 76->77 76->107 76->108 76->126 76->128 76->138 76->139 76->143 76->143 76->227 76->228 76->229 77->1 77->76 78->1 78->1 78->78 78->79 78->79 78->80 78->112 78->113 78->114 78->115 78->230 78->231 78->232 78->233 79->1 79->78 80->1 80->1 80->116 81->1 81->31 82->14 82->29 82->32 82->32 83->1 83->35 84->1 85->1 86->38 86->38 86->39 87->72 88->89 89->1 89->90 89->91 89->135 90->1 90->1 90->92 91->1 91->1 91->89 92->1 92->1 92->90 93->1 93->43 94->45 94->45 94->102 94->137 95->1 95->48 96->1 97->50 97->50 97->74 98->74 99->100 100->1 100->101 101->1 101->1 101->100 102->52 102->52 102->103 103->1 103->54 103->54 103->94 103->134 104->56 104->66 104->144 104->168 104->169 105->57 105->65 105->145 105->160 105->161 105->178 105->181 106->76 107->1 107->1 107->1 107->30 107->30 108->1 108->1 111->1 111->78 112->1 112->1 112->1 112->115 112->116 112->132 113->1 113->1 113->115 113->116 113->132 114->1 114->1 114->115 114->116 114->132 115->1 115->116 115->132 116->1 116->132 119->20 119->63 119->64 119->81 119->81 119->81 119->82 119->117 119->118 120->83 120->83 120->133 121->36 121->84 122->37 122->85 122->86 123->93 123->93 123->105 124->95 124->95 124->136 125->1 125->49 125->96 126->1 126->127 126->128 126->128 126->144 126->148 126->236 126->237 127->1 127->126 128->1 128->1 128->1 128->126 128->129 128->131 128->140 129->1 129->130 129->131 129->131 129->145 129->150 129->238 129->239 130->1 130->129 131->1 131->1 131->1 131->129 131->141 131->142 131->234 131->235 132->1 133->121 133->121 133->122 134->88 134->88 134->94 136->97 136->125 136->125 137->99 137->99 137->102 138->1 138->108 139->1 139->126 140->1 140->129 141->1 141->1 141->1 141->15 141->58 141->143 142->1 142->78 142->170 142->173 142->177 142->180 143->15 143->58 143->77 143->112 143->138 143->138 143->138 143->160 143->161 143->168 143->169 143->186 143->192 143->199 143->202 144->1 144->1 144->1 144->33 144->46 144->50 144->51 144->53 144->66 144->89 144->90 144->100 144->104 144->126 144->127 144->135 144->141 144->145 144->146 144->148 144->149 145->1 145->1 145->1 145->33 145->38 145->40 145->46 145->53 145->65 145->89 145->90 145->100 145->105 145->123 145->129 145->130 145->135 145->141 145->144 145->147 145->150 145->151 146->1 146->149 147->1 147->151 148->1 148->127 148->128 148->156 148->158 148->162 148->163 148->170 148->173 148->194 148->195 149->1 149->1 149->126 149->127 150->1 150->130 150->131 150->160 150->161 150->176 150->176 150->177 150->179 150->179 150->180 150->201 150->203 150->209 150->240 150->241 150->242 150->243 151->1 151->1 151->129 151->130 156->1 156->1 156->156 156->157 156->157 156->168 156->171 156->194 156->248 156->249 157->1 157->156 158->1 158->1 158->158 158->159 158->159 158->169 158->174 158->195 158->250 158->251 159->1 159->158 160->1 160->1 160->1 160->15 160->38 160->40 160->58 160->65 160->105 160->123 160->143 160->161 160->164 160->165 160->178 160->178 160->182 160->183 160->196 160->198 160->199 160->200 160->244 160->245 160->252 160->253 160->254 161->1 161->1 161->1 161->15 161->38 161->40 161->58 161->65 161->105 161->123 161->143 161->160 161->166 161->167 161->181 161->181 161->188 161->189 161->197 161->201 161->202 161->203 161->246 161->247 161->255 161->256 161->257 162->1 162->1 162->156 163->1 163->1 163->158 164->1 164->1 164->1 164->15 164->58 164->143 164->160 164->161 165->1 165->151 166->1 166->1 166->1 166->15 166->58 166->143 166->160 166->161 167->1 167->151 168->1 168->1 168->1 168->15 168->50 168->51 168->58 168->66 168->104 168->143 168->169 168->171 168->172 169->1 169->1 169->1 169->15 169->50 169->51 169->58 169->66 169->104 169->143 169->168 169->174 169->175 170->78 170->142 170->162 170->162 170->173 170->177 170->180 171->1 171->78 171->142 171->170 171->173 171->177 171->180 172->1 172->149 173->78 173->142 173->163 173->163 173->170 173->177 173->180 174->1 174->78 174->142 174->170 174->173 174->177 174->180 175->1 175->149 176->198 176->200 177->78 177->142 177->170 177->173 177->180 177->182 177->185 178->1 178->1 178->1 178->33 178->38 178->40 178->46 178->53 178->65 178->89 178->90 178->100 178->105 178->123 178->135 178->160 178->181 178->184 178->185 178->186 178->187 178->204 178->206 178->208 178->258 178->259 178->262 180->78 180->142 180->170 180->173 180->177 180->188 180->191 181->1 181->1 181->1 181->33 181->38 181->40 181->46 181->53 181->65 181->89 181->90 181->100 181->105 181->123 181->135 181->161 181->178 181->190 181->191 181->192 181->193 181->205 181->207 181->209 181->260 181->261 181->263 182->78 182->142 182->170 182->173 182->177 182->180 183->1 184->1 184->1 184->1 184->15 184->58 184->143 185->1 185->78 185->142 185->170 185->173 185->177 185->180 186->77 186->192 186->199 186->202 187->1 187->151 188->78 188->142 188->170 188->173 188->177 188->180 189->1 190->1 190->1 190->1 190->15 190->58 190->143 191->1 191->78 191->142 191->170 191->173 191->177 191->180 192->77 192->186 192->199 192->202 193->1 193->151 194->127 194->128 196->1 196->183 197->1 197->189 198->130 198->131 198->196 198->196 200->130 200->131 200->208 201->130 201->131 201->197 201->197 204->1 205->1 206->1 206->204 207->1 207->205 208->130 208->131 208->206 208->206 209->130 209->131 209->207 209->207
>>>Token int main ( int argc , char * * argv ) { int DRVAC , LSNRST , ACXYPJ , JONJYG ; char * GFOSIYRIFJEFN ; char * SAEMUXMWWNP ; char * IWGVJFFPNV ; char * KVVCHDNNKCILGUI ; char * EHIDWXLUEKGMRXANJXLNFO ; char * CTAGCN ; char * MAXSHG ; char * YFGKCN ; char * WKAOICDRAOIIG ; char * KCIQGXFGVAQFY ; char * XLKAYJMBYUDEP ; int GSXOBKSLB ; int BJIKIIBNI ; int YYUBBENED ; int KKHCQDAHGKCS ; int NDCVNKFQXNRA ; int IUDOIHSVRCX ; int IHBR ; int OLTHAXLVNYD ; FYQW * YBSCQDMLYENAPXBH ; FYQW * MMCVOCHNPGQUIKUHN ; YBSCQDMLYENAPXBH = NMGSY ( argv [ 1 ] , " " ) ; MMCVOCHNPGQUIKUHN = NMGSY ( argv [ 2 ] , " " ) ; GFOSIYRIFJEFN = ( char * ) malloc ( 102400 ) ; SAEMUXMWWNP = ( char * ) malloc ( 1000 ) ; KVVCHDNNKCILGUI = ( char * ) malloc ( 3002 ) ; TUFIU ( GFOSIYRIFJEFN , 102400 , YBSCQDMLYENAPXBH ) ; UIXFUM ( GFOSIYRIFJEFN , " " , & GSXOBKSLB ) ; HQC DEBUG  printf < LARBJKY ' ' > ( " \n " , GSXOBKSLB ) ; RWVB for ( DRVAC  = 0 ; GSXOBKSLB > DRVAC ; DRVAC ++ ) { TUFIU ( GFOSIYRIFJEFN , 102400 , YBSCQDMLYENAPXBH ) ; HQC DEBUG  printf < LARBJKY ' ' > ( " \n " , DRVAC , GFOSIYRIFJEFN ) ; RWVB IWGVJFFPNV = NJNTEO ( GFOSIYRIFJEFN , " " ) ; UIXFUM ( IWGVJFFPNV , " " , & BJIKIIBNI ) ; HQC DEBUG  printf < LARBJKY ' ' > ( " \n " , BJIKIIBNI ) ; RWVB CTAGCN = ( char * ) malloc ( 2 * BJIKIIBNI ) ; YFGKCN = ( char * ) malloc ( BJIKIIBNI ) ; memset ( CTAGCN , 0x00 , 2 * BJIKIIBNI ) ; memset ( YFGKCN , 0x00 , BJIKIIBNI ) ; WKAOICDRAOIIG = CTAGCN ; XLKAYJMBYUDEP = YFGKCN ; for ( LSNRST = 0 ; BJIKIIBNI > LSNRST ; LSNRST ++ ) { IWGVJFFPNV = NJNTEO ( NULL , " " ) ; memcpy ( WKAOICDRAOIIG , IWGVJFFPNV , 2 ) ; memcpy ( XLKAYJMBYUDEP , IWGVJFFPNV + 2 , 1 ) ; WKAOICDRAOIIG += 2 ; XLKAYJMBYUDEP ++ ; } HQC DEBUG  printf < LARBJKY ' ' > ( " \n " , CTAGCN ) ; printf ( " \n " , YFGKCN ) ; RWVB IWGVJFFPNV = NJNTEO ( NULL , " " ) ; UIXFUM ( IWGVJFFPNV , " " , & YYUBBENED ) ; HQC DEBUG  printf < LARBJKY ' ' > ( " \n " , YYUBBENED ) ; RWVB MAXSHG = ( char * ) malloc ( YYUBBENED * 2 ) ; memset ( MAXSHG , 0x00 , 2 * YYUBBENED ) ; KCIQGXFGVAQFY = MAXSHG ; for ( LSNRST = 0 ; YYUBBENED > LSNRST ; LSNRST ++ ) { IWGVJFFPNV = NJNTEO ( NULL , " " ) ; memcpy ( KCIQGXFGVAQFY , IWGVJFFPNV , 2 ) ; KCIQGXFGVAQFY += 2 ; } IWGVJFFPNV = NJNTEO ( NULL , " " ) ; UIXFUM ( IWGVJFFPNV , " " , & IUDOIHSVRCX ) ; IWGVJFFPNV = NJNTEO ( NULL , " " ) ; OLTHAXLVNYD = 0 ; NDCVNKFQXNRA = strlen ( MAXSHG ) ; KKHCQDAHGKCS = strlen ( CTAGCN ) ; memset ( SAEMUXMWWNP , 0x00 , 1000 ) ; for ( LSNRST = 0 ; IUDOIHSVRCX > LSNRST ; LSNRST ++ ) { HQC DEBUG  printf < LARBJKY ' ' > ( " \n " , LSNRST , SAEMUXMWWNP ) ; RWVB for ( ACXYPJ  = 0 ; NDCVNKFQXNRA > ACXYPJ ; ACXYPJ ++ ) { if ( IWGVJFFPNV [ LSNRST ] == MAXSHG [ ACXYPJ ] ) { IHBR = 0 ; switch ( ACXYPJ % 2 ) { case 1 : for ( JONJYG = OLTHAXLVNYD - 1 ; 0 <= JONJYG ; JONJYG -- ) { if ( MAXSHG [ ACXYPJ - 1 ] == SAEMUXMWWNP [ JONJYG ] ) { OLTHAXLVNYD = JONJYG ; IHBR = 1 ; } } break ; case 0 : for ( JONJYG = OLTHAXLVNYD - 1 ; 0 <= JONJYG ; JONJYG -- ) { if ( MAXSHG [ ACXYPJ + 1 ] == SAEMUXMWWNP [ JONJYG ] ) { OLTHAXLVNYD = JONJYG ; IHBR = 1 ; } } break ; } if ( 1 == IHBR ) break ; } } if ( NDCVNKFQXNRA != ACXYPJ ) continue ; for ( ACXYPJ = 0 ; KKHCQDAHGKCS > ACXYPJ ; ACXYPJ ++ ) { if ( IWGVJFFPNV [ LSNRST ] == CTAGCN [ ACXYPJ ] ) { IHBR = 0 ; switch ( ACXYPJ % 2 ) { case 1 : if ( CTAGCN [ ACXYPJ - 1 ] == SAEMUXMWWNP [ OLTHAXLVNYD - 1 ] ) { SAEMUXMWWNP [ OLTHAXLVNYD - 1 ] = YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ] ; IHBR = 1 ; } else if ( IWGVJFFPNV [ LSNRST + 1 ] == CTAGCN [ ACXYPJ - 1 ] ) { SAEMUXMWWNP [ OLTHAXLVNYD ] = YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ] ; OLTHAXLVNYD ++ ; LSNRST ++ ; IHBR = 1 ; } break ; case 0 : if ( CTAGCN [ ACXYPJ + 1 ] == SAEMUXMWWNP [ OLTHAXLVNYD - 1 ] ) { SAEMUXMWWNP [ OLTHAXLVNYD - 1 ] = YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ] ; IHBR = 1 ; } else if ( IWGVJFFPNV [ LSNRST + 1 ] == CTAGCN [ ACXYPJ + 1 ] ) { SAEMUXMWWNP [ OLTHAXLVNYD ] = YFGKCN [ ( int ) OYUYV ( ACXYPJ / 2 ) ] ; OLTHAXLVNYD ++ ; LSNRST ++ ; IHBR = 1 ; } break ; } if ( 1 == IHBR ) break ; } } if ( KKHCQDAHGKCS == ACXYPJ ) { SAEMUXMWWNP [ OLTHAXLVNYD ] = IWGVJFFPNV [ LSNRST ] ; OLTHAXLVNYD ++ ; } } KVVCHDNNKCILGUI [ 0 ] = ' ' ; EHIDWXLUEKGMRXANJXLNFO = KVVCHDNNKCILGUI + 1 ; for ( LSNRST = 0 ; OLTHAXLVNYD > LSNRST ; LSNRST ++ ) { EHIDWXLUEKGMRXANJXLNFO [ 0 ] = SAEMUXMWWNP [ LSNRST ] ; EHIDWXLUEKGMRXANJXLNFO [ 1 ] = ' ' ; EHIDWXLUEKGMRXANJXLNFO [ 2 ] = ' ' ; EHIDWXLUEKGMRXANJXLNFO += 3 ; } if ( 0 != OLTHAXLVNYD ) { EHIDWXLUEKGMRXANJXLNFO -= 2 ; } * ( EHIDWXLUEKGMRXANJXLNFO ) = ' ' ; * ( EHIDWXLUEKGMRXANJXLNFO + 1 ) = 0x00 ; printf ( " \n " , DRVAC + 1 , KVVCHDNNKCILGUI ) ; fprintf ( MMCVOCHNPGQUIKUHN , " \n " , DRVAC + 1 , KVVCHDNNKCILGUI ) ; free ( CTAGCN ) ; free ( MAXSHG ) ; free ( YFGKCN ) ; } free ( GFOSIYRIFJEFN ) ; free ( SAEMUXMWWNP ) ; free ( KVVCHDNNKCILGUI ) ; RHTWEHGUL ( ) ; return 0 ; }
>>>Func
METHOD YMRFPOG
METHOD_RETURN int
PARAM long long n
PARAM int DPJY
<operator>.assignment OGXMR = 0
RETURN return OGXMR ; return OGXMR ;
<operator>.notEquals n != 1
IDENTIFIER OGXMR return OGXMR ;
<operator>.assignment nc = MNXRHY ( n , DPJY , BQUPGFW )
<operator>.assignment n = 0
<operator>.postIncrement OGXMR ++
<operator>.lessThan i < nc
<operator>.postIncrement i ++
<operator>.assignmentPlus n += BQUPGFW [ i ] * BQUPGFW [ i ]
<operator>.greaterEqualsThan OGXMR >= 0x100
MNXRHY MNXRHY ( n , DPJY , BQUPGFW )
<operator>.assignment i = 0
RETURN return 0 ; return 0 ;
<operator>.multiplication BQUPGFW [ i ] * BQUPGFW [ i ]
LITERAL 0 return 0 ;
<operator>.indirectIndexAccess BQUPGFW [ i ]
<operator>.indirectIndexAccess BQUPGFW [ i ]
>>>PDG&22 0->2 0->3 0->4 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 2->15 3->15 4->1 4->10 5->1 6->1 6->5 6->8 6->9 6->10 6->11 6->14 6->15 6->15 6->16 7->5 8->1 8->1 8->11 9->1 9->1 9->6 9->13 10->1 10->14 11->1 11->1 11->1 11->11 11->12 11->12 11->13 11->18 11->20 11->21 12->1 12->11 13->1 13->1 13->1 13->6 14->1 14->1 14->6 14->7 14->10 14->17 15->1 15->1 15->8 15->8 15->8 15->18 16->1 16->11 17->1 18->1 18->13 18->15 19->17
>>>Token int YMRFPOG ( long long n , int DPJY ) { int BQUPGFW [ 64 ] ; int nc ; int i , OGXMR = 0 ; do { nc = MNXRHY ( n , DPJY , BQUPGFW ) ; n = 0 ; for ( i = 0 ; i < nc ; i ++ ) n += BQUPGFW [ i ] * BQUPGFW [ i ] ; OGXMR ++ ; if ( OGXMR >= 0x100 ) return 0 ; } while ( n != 1 ) ; return OGXMR ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment l = 1
OLUJC OLUJC ( "%d" , & t )
<operator>.assignment * fp = AODYM ( "output1.out" , "w" )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan l <= t
<operator>.postIncrement l ++
LITERAL 0 return 0 ;
AODYM AODYM ( "output1.out" , "w" )
<operator>.assignment q = 1
<operator>.assignment cs [ 4 ] = { '\0' }
<operator>.assignment ds [ 4 ] = { '\0' }
OLUJC OLUJC ( "%d" , & c )
OLUJC OLUJC ( "%d" , & d )
<operator>.assignment ONIVG [ 15 ] = { '\0' }
OLUJC OLUJC ( "%d%s" , & n , ONIVG )
<operator>.assignment TBN [ 15 ] = { '\0' }
<operator>.assignment TBN [ 0 ] = ONIVG [ 0 ]
<operator>.assignment NMXC [ 45 ] = { '\0' }
<operator>.assignment NMXC [ 0 ] = '['
<operator>.assignment i = 0
<operator>.assignment w = 1
<operator>.assignment NMXC [ w ++ ] = TBN [ i ]
fprintf fprintf ( fp , "Case #%d: %s]\n" , l , NMXC )
<operator>.lessThan j < c
<operator>.postIncrement j ++
OLUJC OLUJC ( "%s" , cs )
<operator>.lessThan j < d
<operator>.postIncrement j ++
OLUJC OLUJC ( "%s" , ds )
<operator>.logicalAnd j < n && q < n
<operator>.expressionList j ++   q ++
<operator>.lessThan i < strlen ( TBN ) - 1
<operator>.arrayInitializer { '\0' }
<operator>.arrayInitializer { '\0' }
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.arrayInitializer { '\0' }
<operator>.arrayInitializer { '\0' }
<operator>.assignment j = 1
<operator>.assignment f = 1
<operator>.assignment TBN [ q ] = ONIVG [ j ]
<operator>.arrayInitializer { '\0' }
<operator>.assignment NMXC [ w ++ ] = TBN [ i ]
<operator>.assignment NMXC [ w ++ ] = ' '
<operator>.assignment NMXC [ w ++ ] = ' '
<operator>.postIncrement i ++
<operator>.lessThan j < n
<operator>.lessThan q < n
<operator>.postIncrement j ++
<operator>.postIncrement q ++
<operator>.logicalAnd f && q > 0
<operator>.subtraction strlen ( TBN ) - 1
<operator>.postIncrement w ++
strlen strlen ( TBN )
<operator>.greaterThan q > 0
<operator>.logicalOr ( q > 0 && TBN [ q ] == cs [ 0 ] && TBN [ q - 1 ] == cs [ 1 ] ) || ( q > 0 && TBN [ q ] == cs [ 1 ] && TBN [ q - 1 ] == cs [ 0 ] )
<operator>.postIncrement w ++
<operator>.postIncrement w ++
<operator>.postIncrement w ++
<operator>.assignment TBN [ q - 1 ] = cs [ 2 ]
<operator>.assignment TBN [ q ] = '\0'
<operator>.assignment q = q - 1
<operator>.logicalAnd q > 0 && TBN [ q ] == cs [ 0 ] && TBN [ q - 1 ] == cs [ 1 ]
<operator>.logicalAnd q > 0 && TBN [ q ] == cs [ 1 ] && TBN [ q - 1 ] == cs [ 0 ]
<operator>.logicalAnd q > 0 && TBN [ q ] == cs [ 0 ]
<operator>.equals TBN [ q - 1 ] == cs [ 1 ]
<operator>.logicalAnd q > 0 && TBN [ q ] == cs [ 1 ]
<operator>.equals TBN [ q - 1 ] == cs [ 0 ]
<operator>.subtraction q - 1
<operator>.logicalAnd q > 0 && TBN [ q ] == ds [ 0 ] && MPGTKR ( TBN , ds [ 1 ] )
<operator>.greaterThan q > 0
<operator>.equals TBN [ q ] == cs [ 0 ]
<operator>.greaterThan q > 0
<operator>.equals TBN [ q ] == cs [ 1 ]
<operator>.subtraction q - 1
memset memset ( TBN   '\0'   sizeof ( TBN ) )
<operator>.assignment q = - 1
<operator>.subtraction q - 1
<operator>.subtraction q - 1
<operator>.logicalAnd q > 0 && TBN [ q ] == ds [ 0 ]
MPGTKR MPGTKR ( TBN , ds [ 1 ] )
<operator>.greaterThan q > 0
<operator>.equals TBN [ q ] == ds [ 0 ]
<operator>.minus - 1
<operator>.logicalAnd q > 0 && TBN [ q ] == ds [ 1 ] && MPGTKR ( TBN , ds [ 0 ] )
memset memset ( TBN   '\0'   sizeof ( TBN ) )
<operator>.assignment q = - 1
<operator>.logicalAnd q > 0 && TBN [ q ] == ds [ 1 ]
MPGTKR MPGTKR ( TBN , ds [ 0 ] )
<operator>.assignment f = 0
<operator>.greaterThan q > 0
<operator>.equals TBN [ q ] == ds [ 1 ]
<operator>.minus - 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess TBN [ 0 ]
<operator>.indirectIndexAccess ONIVG [ 0 ]
<operator>.indirectIndexAccess NMXC [ 0 ]
<operator>.indirectIndexAccess NMXC [ w ++ ]
<operator>.indirectIndexAccess TBN [ i ]
<operator>.indirectIndexAccess TBN [ q ]
<operator>.indirectIndexAccess ONIVG [ j ]
<operator>.indirectIndexAccess NMXC [ w ++ ]
<operator>.indirectIndexAccess TBN [ i ]
<operator>.indirectIndexAccess NMXC [ w ++ ]
<operator>.indirectIndexAccess NMXC [ w ++ ]
<operator>.indirectIndexAccess TBN [ q - 1 ]
<operator>.indirectIndexAccess cs [ 2 ]
<operator>.indirectIndexAccess TBN [ q ]
<operator>.indirectIndexAccess TBN [ q - 1 ]
<operator>.indirectIndexAccess cs [ 1 ]
<operator>.indirectIndexAccess TBN [ q - 1 ]
<operator>.indirectIndexAccess cs [ 0 ]
<operator>.indirectIndexAccess TBN [ q ]
<operator>.indirectIndexAccess cs [ 0 ]
<operator>.indirectIndexAccess TBN [ q ]
<operator>.indirectIndexAccess cs [ 1 ]
<operator>.indirectIndexAccess ds [ 1 ]
<operator>.sizeOf sizeof ( TBN )
<operator>.indirectIndexAccess TBN [ q ]
<operator>.indirectIndexAccess ds [ 0 ]
<operator>.indirectIndexAccess ds [ 0 ]
<operator>.sizeOf sizeof ( TBN )
<operator>.indirectIndexAccess TBN [ q ]
<operator>.indirectIndexAccess ds [ 1 ]
>>>PDG&128 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->13 0->14 0->16 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->43 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->58 0->59 0->60 0->62 0->70 0->72 0->74 0->76 0->77 0->79 0->80 0->82 0->83 0->85 0->87 0->90 0->91 0->92 0->94 2->1 2->6 3->1 3->1 3->6 4->1 4->1 4->1 4->24 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->20 6->21 6->22 6->23 6->24 6->24 6->25 6->28 6->31 6->33 6->34 6->35 6->36 6->37 6->38 6->39 6->40 6->43 6->48 6->53 6->54 6->55 6->95 6->96 6->97 6->98 6->99 6->100 6->101 6->102 7->1 7->6 8->5 9->4 9->4 10->1 10->1 10->49 10->51 10->56 10->72 11->1 11->1 11->27 11->61 11->67 11->69 11->73 11->75 12->1 12->1 12->30 12->82 12->84 12->90 12->93 13->1 13->1 13->25 14->1 14->1 14->28 15->1 15->16 16->1 16->1 16->1 16->18 16->42 16->48 16->49 17->1 17->55 17->67 17->69 17->73 17->75 17->82 17->84 17->90 17->93 18->1 18->1 18->1 18->55 18->77 18->82 18->87 18->90 19->1 19->1 19->24 20->1 20->1 20->24 21->1 21->33 22->1 22->54 22->58 23->1 23->1 23->1 23->24 24->1 24->1 24->1 24->7 25->1 25->1 25->13 25->25 25->26 25->26 25->27 26->1 26->25 27->1 27->1 27->61 27->67 27->69 27->73 27->75 28->1 28->1 28->14 28->28 28->29 28->29 28->30 29->1 29->28 30->1 30->1 30->82 30->84 30->90 30->93 31->1 31->1 31->1 31->31 31->32 31->41 31->42 31->48 31->50 31->51 31->52 31->56 31->103 31->104 32->1 32->1 32->1 33->1 33->1 33->1 33->33 33->44 33->45 33->46 33->47 33->47 33->53 33->55 33->58 33->59 33->60 33->105 33->106 33->107 33->108 34->11 35->12 36->25 37->1 37->28 38->15 39->17 40->1 40->48 41->1 41->52 42->1 42->1 42->1 42->55 42->73 42->75 42->77 42->82 42->84 42->87 42->90 42->93 43->19 45->1 46->1 47->1 47->33 48->1 48->1 48->16 48->31 48->31 48->49 48->49 48->50 49->1 49->1 49->16 49->31 49->31 49->48 49->51 49->56 49->72 50->32 50->48 51->1 51->32 51->49 51->56 51->72 52->1 52->1 52->1 52->52 52->56 52->57 52->64 52->66 52->72 53->1 53->33 53->33 54->1 55->1 55->23 55->44 55->53 55->77 55->82 55->87 55->90 56->51 56->52 56->52 56->72 57->1 57->1 57->1 57->61 57->62 57->63 57->70 57->71 57->76 57->81 57->83 57->109 57->110 57->111 58->59 59->60 60->54 60->58 61->1 61->1 61->1 61->55 61->67 61->69 61->77 61->82 61->87 61->90 62->1 62->1 62->55 62->73 62->75 62->77 62->82 62->84 62->87 62->90 62->93 63->1 63->1 63->51 63->56 63->72 64->1 64->1 64->57 64->57 64->65 64->68 64->74 65->1 65->1 65->57 65->57 66->1 66->52 66->64 66->64 66->67 66->79 66->112 66->113 67->1 67->1 67->27 67->55 67->64 67->64 67->69 67->75 67->77 67->82 67->87 67->90 68->1 68->52 68->65 68->65 68->69 68->80 68->114 68->115 69->1 69->1 69->27 69->55 69->65 69->65 69->67 69->73 69->77 69->82 69->87 69->90 70->63 70->63 71->1 71->1 71->1 71->77 71->78 71->85 71->86 71->89 71->92 71->121 72->66 72->66 72->73 72->74 72->76 72->79 72->83 72->116 72->117 73->1 73->1 73->27 73->55 73->66 73->66 73->69 73->75 73->77 73->82 73->84 73->87 73->90 73->93 74->68 74->68 74->75 74->76 74->80 74->83 74->118 74->119 75->1 75->1 75->27 75->55 75->67 75->68 75->68 75->73 75->77 75->82 75->84 75->87 75->90 75->93 76->70 77->1 77->55 77->67 77->69 77->73 77->75 77->82 77->84 77->90 77->93 78->1 78->1 78->51 78->56 78->72 79->74 79->76 79->83 80->76 80->83 81->1 81->52 81->71 81->71 81->82 81->120 82->1 82->30 82->55 82->67 82->69 82->71 82->71 82->73 82->75 82->84 82->90 82->93 82->93 83->81 83->81 83->84 83->92 83->122 83->123 84->1 84->1 84->30 84->55 84->73 84->75 84->77 84->81 84->81 84->82 84->87 84->90 84->90 84->93 85->78 86->1 86->1 86->1 86->87 86->88 86->91 86->94 86->125 87->1 87->55 87->67 87->69 87->73 87->75 87->82 87->84 87->90 87->93 88->1 88->1 88->51 88->56 88->72 89->1 89->52 89->86 89->86 89->90 89->124 90->1 90->30 90->55 90->67 90->69 90->73 90->75 90->82 90->84 90->84 90->86 90->86 90->93 91->1 91->52 92->51 92->56 92->72 92->89 92->89 92->93 92->126 92->127 93->1 93->1 93->30 93->55 93->73 93->75 93->77 93->82 93->82 93->84 93->87 93->89 93->89 93->90 94->88
>>>Token int main ( ) { int t , l = 1 ; OLUJC ( " " , & t ) ; DOPD * fp = AODYM ( " " , " " ) ; for ( ; l <= t ; l ++ ) { int j , c , d , n ; q = 1 ; char cs [ 4 ] = { ' \0 ' } , ds [ 4 ] = { ' \0 ' } ; OLUJC ( " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) OLUJC ( " " , cs ) ; OLUJC ( " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) OLUJC ( " " , ds ) ; char ONIVG [ 15 ] = { ' \0 ' } ; OLUJC ( " " , & n , ONIVG ) ; char TBN [ 15 ] = { ' \0 ' } ; TBN [ 0 ] = ONIVG [ 0 ] ; for ( j = 1 ; j < n && q < n ; j ++ , q ++ ) { int f = 1 ; TBN [ q ] = ONIVG [ j ] ; while ( f && q > 0 ) { if ( ( q > 0 && TBN [ q ] == cs [ 0 ] && TBN [ q - 1 ] == cs [ 1 ] ) || ( q > 0 && TBN [ q ] == cs [ 1 ] && TBN [ q - 1 ] == cs [ 0 ] ) ) { TBN [ q - 1 ] = cs [ 2 ] ; TBN [ q ] = ' \0 ' ; q = q - 1 ; } else if ( q > 0 && TBN [ q ] == ds [ 0 ] && MPGTKR ( TBN , ds [ 1 ] ) ) { memset ( TBN , ' \0 ' , sizeof ( TBN ) ) ; q = - 1 ; } else if ( q > 0 && TBN [ q ] == ds [ 1 ] && MPGTKR ( TBN , ds [ 0 ] ) ) { memset ( TBN , ' \0 ' , sizeof ( TBN ) ) ; q = - 1 ; } else f = 0 ; } } char NMXC [ 45 ] = { ' \0 ' } ; NMXC [ 0 ] = ' ' ; int i = 0 , w = 1 ; while ( i < strlen ( TBN ) - 1 ) { NMXC [ w ++ ] = TBN [ i ] ; NMXC [ w ++ ] = ' ' ; NMXC [ w ++ ] = ' ' ; i ++ ; } NMXC [ w ++ ] = TBN [ i ] ; fprintf ( fp , " \n " , l , NMXC ) ; } return 0 ; }
>>>Func
METHOD FNXF
METHOD_RETURN double
PARAM int FYSY
PARAM int N
<operator>.assignment ULLJY = 0
<operator>.assignment TEYEY = 0
RETURN return ULLJY / TEYEY ; return ULLJY / TEYEY ;
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.division ULLJY / TEYEY
<operator>.assignment i = 0
<operator>.assignmentPlus ULLJY += PHL ( i , N , FYSY )
<operator>.assignmentPlus TEYEY += 1.0
<operator>.logicalOr i == FYSY || DWPIT [ FYSY ] [ i ] == '.'
PHL PHL ( i , N , FYSY )
<operator>.equals i == FYSY
<operator>.equals DWPIT [ FYSY ] [ i ] == '.'
<operator>.indirectIndexAccess DWPIT [ FYSY ] [ i ]
<operator>.indirectIndexAccess DWPIT [ FYSY ]
>>>PDG&19 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 2->1 2->15 3->7 4->1 4->9 4->11 5->1 5->9 5->12 6->1 7->1 7->1 7->1 7->7 7->8 7->13 7->14 7->15 7->15 8->1 8->7 9->1 9->1 9->1 9->6 10->1 10->7 11->1 11->1 11->9 12->1 12->9 13->1 13->1 13->1 13->11 13->12 13->14 14->1 14->7 14->8 14->11 14->11 14->11 14->15 15->1 15->8 15->13 15->13 15->14 15->14 15->16 15->17 15->18 16->1 16->13 16->13
>>>Token double FNXF ( int FYSY , int N ) { int i ; double ULLJY , TEYEY ; ULLJY = 0 ; TEYEY = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i == FYSY || DWPIT [ FYSY ] [ i ] == ' ' ) { continue ; } ULLJY += PHL ( i , N , FYSY ) ; TEYEY += 1.0 ; } return ULLJY / TEYEY ; }
>>>Func
METHOD XEWN
METHOD_RETURN void
PARAM int * KSOHK
PARAM int * KCDLJC
<operator>.assignment JMYC = * KSOHK
<operator>.assignment * KSOHK = * KCDLJC
<operator>.assignment * KCDLJC = JMYC
>>>PDG&7 0->2 0->3 0->6 2->1 3->1 4->1 4->6 5->1 5->1 6->1 6->1 6->1
>>>Token void XEWN ( int * KSOHK , int * KCDLJC ) { int JMYC = * KSOHK ; * KSOHK = * KCDLJC ; * KCDLJC = JMYC ; }
>>>Func
METHOD XRTIDHXKTQHYGGUB
METHOD_RETURN int
PARAM V a
PARAM V b
RETURN return YXLEFGIAVPL ( a , b ) ; return YXLEFGIAVPL ( a , b ) ;
YXLEFGIAVPL YXLEFGIAVPL ( a , b )
>>>PDG&6 0->2 0->3 0->5 2->5 3->5 4->1 5->1 5->1 5->1 5->4
>>>Token static int XRTIDHXKTQHYGGUB ( V a , V b ) { return YXLEFGIAVPL ( a , b ) ; }
>>>Func
METHOD SSEFIXJKVROTSQBFSQAQN
METHOD_RETURN void
PARAM SRJQUIDJD * HEXNJJOTTK
PARAM NLHICIOWAQPPMJ * BDEKG
<operator>.assignment HNBL = & ( BDEKG -> HNBL )
free free ( BDEKG )
<operator>.notEquals HEXNJJOTTK -> VPIXJXQVHRBOE != NULL
<operator>.notEquals HEXNJJOTTK -> BYLHILDKHJBPYDD != NULL
VPIXJXQVHRBOE HEXNJJOTTK -> VPIXJXQVHRBOE ( HNBL -> KEU )
BYLHILDKHJBPYDD HEXNJJOTTK -> BYLHILDKHJBPYDD ( HNBL -> UUMVE )
<operator>.indirectFieldAccess HEXNJJOTTK -> VPIXJXQVHRBOE
<operator>.indirectFieldAccess HNBL -> KEU
<operator>.indirectFieldAccess HEXNJJOTTK -> BYLHILDKHJBPYDD
<operator>.indirectFieldAccess HNBL -> UUMVE
FIELD_IDENTIFIER VPIXJXQVHRBOE VPIXJXQVHRBOE
FIELD_IDENTIFIER KEU KEU
FIELD_IDENTIFIER BYLHILDKHJBPYDD BYLHILDKHJBPYDD
FIELD_IDENTIFIER UUMVE UUMVE
>>>PDG&18 0->2 0->3 0->5 0->6 0->7 2->1 3->5 4->1 4->1 4->1 5->1 6->1 6->1 6->7 6->8 6->8 6->10 6->11 6->14 6->15 7->1 7->1 7->1 7->9 7->9 7->12 7->13 7->16 7->17 8->1 8->1 8->1 9->1 9->1 9->1
>>>Token static void SSEFIXJKVROTSQBFSQAQN ( SRJQUIDJD * HEXNJJOTTK , NLHICIOWAQPPMJ * BDEKG ) { NPQUOEGASCVGQ * HNBL ; HNBL = & ( BDEKG -> HNBL ) ; if ( HEXNJJOTTK -> VPIXJXQVHRBOE != NULL ) { HEXNJJOTTK -> VPIXJXQVHRBOE ( HNBL -> KEU ) ; } if ( HEXNJJOTTK -> BYLHILDKHJBPYDD != NULL ) { HEXNJJOTTK -> BYLHILDKHJBPYDD ( HNBL -> UUMVE ) ; } free ( BDEKG ) ; }
>>>Func
METHOD DTSK
METHOD_RETURN void
PARAM int K
RETURN return ; return ;
<operator>.lessThan i < K
<operator>.postIncrement i ++
<operator>.assignment RVLUR [ i ] = 0
<operator>.lessEqualsThan i <= K
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.expressionList i = 1   j = - 1
<operator>.assignment RVLUR [ j ] = i
<operator>.lessThan BAUWCAT < i
<operator>.postIncrement BAUWCAT ++
<operator>.assignment i = 1
<operator>.assignment j = - 1
<operator>.assignment BAUWCAT = 0
<operator>.minus - 1
<operator>.assignment j = ( j + 1 ) % K
<operator>.modulo ( j + 1 ) % K
<operator>.addition j + 1
<operator>.indirectIndexAccess RVLUR [ i ]
<operator>.indirectIndexAccess RVLUR [ j ]
<operator>.indirectIndexAccess RVLUR [ j ]
>>>PDG&24 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->19 0->20 2->4 3->1 4->1 4->4 4->5 4->5 4->6 4->7 4->21 5->1 5->4 6->1 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->12 7->16 7->19 7->22 8->1 8->7 9->1 9->4 10->1 10->1 10->1 11->1 11->1 12->1 12->1 12->8 12->11 12->12 12->13 12->13 12->18 12->19 12->20 12->23 13->1 13->12 14->7 14->10 15->1 15->1 15->10 15->19 15->20 16->1 16->12 17->10 17->15 18->1 18->1 18->1 18->19 18->20 19->1 19->7 19->18 19->18 23->18 23->19 23->20 23->23
>>>Token void DTSK ( int K ) { int i , j , BAUWCAT ; for ( i = 0 ; i < K ; i ++ ) RVLUR [ i ] = 0 ; for ( i = 1 , j = - 1 ; i <= K ; i ++ ) { for ( BAUWCAT = 0 ; BAUWCAT < i ; BAUWCAT ++ ) { do j = ( j + 1 ) % K ; while ( RVLUR [ j ] ) ; } RVLUR [ j ] = i ; } return ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment WYQG = 0
LGKDX LGKDX ( "%d\n" , & T )
RETURN return 0 ; return 0 ;
<operator>.postDecrement T --
LITERAL 0 return 0 ;
LGKDX LGKDX ( "%d " , & c )
LGKDX LGKDX ( "%d " , & d )
LGKDX LGKDX ( "%d " , & n )
<operator>.assignment WGQCWSXW = 0
<operator>.lessThan printf <PGRYOOT
<operator>.greaterThan ';'> ( "\n\n" )
printf printf ( "]\n" )
<operator>.lessEqualsThan i <= ( int ) 'Z'
<operator>.postIncrement i ++
<operator>.lessThan i < c
<operator>.postIncrement i ++
<operator>.lessThan i < d
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < WGQCWSXW - 1
<operator>.postIncrement i ++
printf printf ( "%c, " , JHAE [ i ] )
<operator>.greaterThan WGQCWSXW > 0
<operator>.assignment i = ( int ) 'A'
<operator>.assignment GNA [ i ] = 0
<operator>.assignment OAEYJGWRYS [ i ] = 0
<operator>.assignment i = 0
LGKDX LGKDX ( "%s " , QJU )
<operator>.expressionList YUR = ( int ) QJU [ 0 ]   KED = ( int ) QJU [ 1 ]
<operator>.lessThan printf <PGRYOOT
<operator>.greaterThan ';'> ( "\nCombine: %c %c -> %c"   ( char ) YUR   ( char ) KED , QJU [ 2 ] )
<operator>.assignment NGAJWEJ [ YUR ] [ KED ] = NGAJWEJ [ KED ] [ YUR ] = QJU [ 2 ]
<operator>.assignment i = 0
LGKDX LGKDX ( "%s " , QJU )
<operator>.expressionList YUR = ( int ) QJU [ 0 ]   KED = ( int ) QJU [ 1 ]
<operator>.lessThan printf <PGRYOOT
<operator>.greaterThan ';'> ( "\nOpposed: %c %c"   ( char ) YUR   ( char ) KED )
<operator>.assignment KTUOFTK [ YUR ] [ GNA [ YUR ] ++ ] = KED
<operator>.assignment KTUOFTK [ KED ] [ GNA [ KED ] ++ ] = YUR
<operator>.assignment i = 0
LGKDX LGKDX ( "%c" , & SBMU )
<operator>.lessThan printf <PGRYOOT
<operator>.greaterThan ';'> ( "\nElement: %c " , SBMU )
IDENTIFIER OIHW <empty>
<operator>.lessThan printf <PGRYOOT
<operator>.greaterThan ';'> ( "-- not combine " )
IDENTIFIER OIHW <empty>
<operator>.lessThan printf <PGRYOOT
<operator>.greaterThan ';'> ( "-- not opposed " )
<operator>.assignment JHAE [ WGQCWSXW ++ ] = SBMU
<operator>.postIncrement OAEYJGWRYS [ ( int ) SBMU ] ++
<operator>.assignment i = 0
printf printf ( "%c" , JHAE [ WGQCWSXW - 1 ] )
<operator>.cast ( int ) 'Z'
<operator>.lessEqualsThan k <= ( int ) 'Z'
<operator>.postIncrement k ++
<operator>.assignment NGAJWEJ [ i ] [ k ] = '!'
<operator>.equals TDBMEQBXHLGE ( SBMU ) == true
<operator>.equals XCBNHWAGEQJB ( SBMU ) == true
<operator>.subtraction WGQCWSXW - 1
<operator>.cast ( int ) 'A'
<operator>.assignment k = ( int ) 'A'
<operator>.assignment YUR = ( int ) QJU [ 0 ]
<operator>.assignment KED = ( int ) QJU [ 1 ]
<operator>.bracketedPrimary ( "\nCombine: %c %c -> %c"   ( char ) YUR   ( char ) KED , QJU [ 2 ] )
<operator>.assignment NGAJWEJ [ KED ] [ YUR ] = QJU [ 2 ]
<operator>.assignment YUR = ( int ) QJU [ 0 ]
<operator>.assignment KED = ( int ) QJU [ 1 ]
<operator>.bracketedPrimary ( "\nOpposed: %c %c"   ( char ) YUR   ( char ) KED )
<operator>.bracketedPrimary ( "\nElement: %c " , SBMU )
<operator>.cast ( int ) 'Z'
<operator>.cast ( int ) QJU [ 0 ]
<operator>.cast ( int ) QJU [ 1 ]
<operator>.expressionList "\nCombine: %c %c -> %c"   ( char ) YUR   ( char ) KED   QJU [ 2 ]
<operator>.cast ( int ) QJU [ 0 ]
<operator>.cast ( int ) QJU [ 1 ]
<operator>.expressionList "\nOpposed: %c %c"   ( char ) YUR   ( char ) KED
<operator>.postIncrement GNA [ KED ] ++
<operator>.expressionList "\nElement: %c "   SBMU
TDBMEQBXHLGE TDBMEQBXHLGE ( SBMU )
XCBNHWAGEQJB XCBNHWAGEQJB ( SBMU )
<operator>.cast ( int ) SBMU
<operator>.subtraction WGQCWSXW - 1
<operator>.cast ( int ) 'A'
<operator>.cast ( char ) YUR
<operator>.cast ( char ) KED
<operator>.cast ( char ) YUR
<operator>.cast ( char ) KED
UNKNOWN Q Q
UNKNOWN T T
UNKNOWN f f
UNKNOWN <PGRYOOT ';'> ( "Case #%d: [" , ++ WYQG ) ; <PGRYOOT ';'> ( "Case #%d: [" , ++ WYQG ) ;
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
UNKNOWN Q Q
UNKNOWN T T
UNKNOWN Q Q
UNKNOWN T T
UNKNOWN Q Q
UNKNOWN T T
UNKNOWN W W
UNKNOWN Q Q
UNKNOWN T T
UNKNOWN W W
UNKNOWN Q Q
UNKNOWN T T
<operator>.indirectIndexAccess JHAE [ i ]
UNKNOWN int int
<operator>.indirectIndexAccess GNA [ i ]
<operator>.indirectIndexAccess OAEYJGWRYS [ i ]
<operator>.indirectIndexAccess KTUOFTK [ KED ] [ GNA [ KED ] ++ ]
<operator>.addressOf & SBMU
<operator>.indirectIndexAccess OAEYJGWRYS [ ( int ) SBMU ]
<operator>.indirectIndexAccess JHAE [ WGQCWSXW - 1 ]
UNKNOWN int int
<operator>.indirectIndexAccess NGAJWEJ [ i ] [ k ]
<operator>.indirectIndexAccess NGAJWEJ [ KED ] [ YUR ]
<operator>.indirectIndexAccess QJU [ 2 ]
<operator>.indirectIndexAccess KTUOFTK [ KED ]
UNKNOWN int int
<operator>.indirectIndexAccess NGAJWEJ [ i ]
UNKNOWN int int
<operator>.indirectIndexAccess QJU [ 0 ]
UNKNOWN int int
<operator>.indirectIndexAccess QJU [ 1 ]
<operator>.indirectIndexAccess QJU [ 2 ]
<operator>.indirectIndexAccess NGAJWEJ [ KED ]
UNKNOWN int int
<operator>.indirectIndexAccess QJU [ 0 ]
UNKNOWN int int
<operator>.indirectIndexAccess QJU [ 1 ]
<operator>.indirectIndexAccess GNA [ KED ]
UNKNOWN int int
UNKNOWN int int
UNKNOWN char char
UNKNOWN char char
UNKNOWN char char
UNKNOWN char char
>>>PDG&142 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->73 0->76 0->79 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 2->1 2->1 3->1 3->1 3->5 4->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->16 5->18 5->20 5->22 5->25 5->26 5->29 5->35 5->42 5->54 5->56 5->62 5->63 5->91 5->92 5->93 5->94 5->95 5->96 5->97 5->111 5->118 6->4 7->1 7->1 7->16 8->1 8->1 8->18 9->1 9->1 9->20 10->1 10->62 11->1 11->1 11->1 11->32 11->32 11->38 11->38 11->44 11->44 12->1 13->1 14->1 14->1 14->14 14->15 14->15 14->27 14->28 14->56 14->57 14->64 14->73 14->86 14->111 14->112 14->113 14->123 14->137 15->1 15->14 16->1 16->1 16->7 16->16 16->17 16->17 16->30 16->31 16->32 16->33 16->34 16->65 16->66 16->67 16->68 16->74 16->75 16->76 16->87 16->88 16->98 16->99 16->120 16->121 16->125 16->126 16->127 16->128 16->129 16->130 16->138 16->139 17->1 17->16 18->1 18->1 18->8 18->18 18->19 18->19 18->36 18->37 18->38 18->39 18->40 18->41 18->69 18->70 18->71 18->77 18->78 18->79 18->80 18->89 18->90 18->100 18->101 18->114 18->122 18->131 18->132 18->133 18->134 18->135 18->140 18->141 19->1 19->18 20->1 20->1 20->9 20->20 20->21 20->21 20->43 20->44 20->45 20->60 20->72 20->81 20->82 20->102 20->103 20->104 20->115 21->1 21->20 22->1 22->1 22->1 22->22 22->23 22->23 22->24 22->62 22->110 23->1 23->22 24->1 24->1 25->1 25->1 25->55 25->85 25->85 25->117 26->1 26->1 26->14 27->1 27->1 28->1 28->1 29->16 30->1 30->1 30->31 30->34 30->36 30->37 30->65 30->66 30->68 30->69 30->70 30->74 30->75 30->76 30->77 30->78 31->1 31->1 31->1 32->11 32->11 32->38 32->38 32->44 32->44 33->1 33->1 34->1 34->1 34->1 35->18 36->1 36->1 36->30 36->37 36->69 36->70 36->77 36->78 37->1 37->1 37->1 38->11 38->11 38->44 38->44 39->1 39->1 40->1 40->1 40->1 41->1 41->1 41->1 42->20 43->1 43->1 43->52 43->81 43->82 43->83 43->84 44->11 44->11 44->47 44->47 45->1 45->1 47->11 47->11 47->44 47->44 47->50 47->50 48->1 50->11 50->11 50->44 50->44 51->1 52->1 52->1 52->24 52->55 53->1 53->1 54->1 54->22 55->1 55->1 57->1 57->1 57->57 57->58 57->58 57->59 57->73 57->119 57->123 57->124 58->1 58->57 59->1 59->1 60->1 60->1 60->1 60->47 60->48 60->61 60->61 60->83 60->105 60->106 60->107 61->1 61->1 61->1 61->50 61->51 61->52 61->53 61->60 61->84 61->108 61->109 61->116 61->136 62->22 62->22 62->25 64->1 64->1 64->57 65->1 65->31 65->76 65->87 66->1 66->31 66->76 66->88 67->1 67->33 68->1 68->1 68->34 69->1 69->37 69->41 69->79 69->89 70->1 70->37 70->40 70->79 70->90 71->1 71->39 72->1 72->45 74->1 75->1 76->1 76->1 76->30 76->34 76->36 76->67 76->67 76->67 76->67 76->68 77->1 78->1 79->1 79->1 79->71 79->71 79->71 80->1 81->72 81->72 81->82 82->1 82->43 82->60 82->81 82->83 83->1 83->43 83->52 83->61 83->81 83->84 84->1 85->1 87->1 88->1
>>>Token int main ( ) { int T , WYQG = 0 ; LGKDX ( " \n " , & T ) ; while ( T -- ) { int c , d , n ; int i , k ; char QJU [ 10 ] ; for ( i = ( int ) ' ' ; i <= ( int ) ' ' ; i ++ ) { GNA [ i ] = 0 ; OAEYJGWRYS [ i ] = 0 ; for ( k = ( int ) ' ' ; k <= ( int ) ' ' ; k ++ ) NGAJWEJ [ i ] [ k ] = ' ' ; } LGKDX ( " " , & c ) ; for ( i = 0 ; i < c ; i ++ ) { int YUR , KED ; LGKDX ( " " , QJU ) ; YUR = ( int ) QJU [ 0 ] , KED = ( int ) QJU [ 1 ] ; NCT AWANAQ  printf < PGRYOOT ' ' > ( " \n " , ( char ) YUR , ( char ) KED , QJU [ 2 ] ) ; OIHW NGAJWEJ [ YUR ] [ KED ] = NGAJWEJ [ KED ] [ YUR ] = QJU [ 2 ] ; } LGKDX ( " " , & d ) ; for ( i = 0 ; i < d ; i ++ ) { int YUR , KED ; LGKDX ( " " , QJU ) ; YUR = ( int ) QJU [ 0 ] , KED = ( int ) QJU [ 1 ] ; NCT AWANAQ  printf < PGRYOOT ' ' > ( " \n " , ( char ) YUR , ( char ) KED ) ; OIHW KTUOFTK [ YUR ] [ GNA [ YUR ] ++ ] = KED ; KTUOFTK [ KED ] [ GNA [ KED ] ++ ] = YUR ; } LGKDX ( " " , & n ) ; WGQCWSXW = 0 ; for ( i = 0 ; i < n ; i ++ ) { char SBMU ; LGKDX ( " " , & SBMU ) ; NCT AWANAQ  printf < PGRYOOT ' ' > ( " \n " , SBMU ) ; OIHW if ( TDBMEQBXHLGE ( SBMU ) == true ) continue ; NCT AWANAQ  printf < PGRYOOT ' ' > ( " " ) ; OIHW if ( XCBNHWAGEQJB ( SBMU ) == true ) continue ; NCT AWANAQ  printf < PGRYOOT ' ' > ( " " ) ; OIHW JHAE [ WGQCWSXW ++ ] = SBMU ; OAEYJGWRYS [ ( int ) SBMU ] ++ ; } NCT AWANAQ  printf < PGRYOOT ' ' > ( " \n \n " ) ; OIHW printf < PGRYOOT ' ; ' ( " " , ++ WYQG ) ; for ( i = 0 ; i < WGQCWSXW - 1 ; i ++ ) printf ( " " , JHAE [ i ] ) ; if ( WGQCWSXW > 0 ) printf ( " " , JHAE [ WGQCWSXW - 1 ] ) ; printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD PVKVKF
METHOD_RETURN int
PARAM char GLR [ ]
PARAM char c
RETURN return EISNF ( Y , sz , c ) ; return EISNF ( Y , sz , c ) ;
<operator>.assignment p = EISNF ( QKU , D * 2 , c ) < 0
<operator>.equals c == QKU [ 2 * p ]
EISNF EISNF ( Y , sz , c )
RETURN return - 1 ; return - 1 ;
<operator>.assignment c = QKU [ 2 * p + 1 ]
<operator>.lessThan EISNF ( QKU , D * 2 , c ) < 0
<operator>.minus - 1
<operator>.assignment c = QKU [ 2 * p ]
EISNF EISNF ( QKU , D * 2 , c )
<operator>.multiplication 2 * p
<operator>.multiplication D * 2
<operator>.addition 2 * p + 1
<operator>.multiplication 2 * p
<operator>.multiplication 2 * p
<operator>.indirectIndexAccess QKU [ 2 * p ]
<operator>.indirectIndexAccess QKU [ 2 * p + 1 ]
<operator>.indirectIndexAccess QKU [ 2 * p ]
>>>PDG&22 0->2 0->3 0->6 0->7 0->10 0->11 0->13 0->14 0->15 0->16 0->17 0->18 2->1 3->13 4->1 5->1 5->1 5->1 5->4 5->6 5->7 5->8 5->11 5->14 5->14 5->19 6->9 6->12 6->12 6->16 6->17 6->18 6->20 6->21 7->1 7->4 8->1 9->7 10->1 10->5 10->5 11->1 11->8 12->7 13->1 13->1 13->1 13->6 13->6 13->9 13->10 13->10 13->10 13->12 14->17 14->18 15->1 15->13 15->13 17->16 17->16
>>>Token int PVKVKF ( char GLR [ ] , char c ) { int p ; if ( p = EISNF ( QKU , D * 2 , c ) < 0 ) return - 1 ; if ( c == QKU [ 2 * p ] ) c = QKU [ 2 * p + 1 ] ; else c = QKU [ 2 * p ] ; return EISNF ( Y , sz , c ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment x = 0
SLWAGVO SLWAGVO ( "A-small-attempt0.in" , "r" , stdin )
SLWAGVO SLWAGVO ( "A-small-attempt0.out" , "w" , POQJDX )
FEKKN FEKKN ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.postDecrement t --
LITERAL 0 return 0 ;
<operator>.postIncrement x ++
FEKKN FEKKN ( "%I64d%d%d" , & n , & pd , & pg )
<operator>.logicalOr pd != 100 && pg == 100 || pd != 0 && pg == 0
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
<operator>.equals i == n + 1
printf printf ( "Case #%d: Broken\n" , x )
<operator>.assignment i = 1
printf printf ( "Case #%d: Broken\n" , x )
<operator>.logicalAnd pd != 100 && pg == 100
<operator>.logicalAnd pd != 0 && pg == 0
<operator>.equals i * pd % 100 == 0
<operator>.addition n + 1
printf printf ( "Case #%d: Possible\n" , x )
<operator>.notEquals pd != 100
<operator>.equals pg == 100
<operator>.notEquals pd != 0
<operator>.equals pg == 0
<operator>.modulo i * pd % 100
<operator>.multiplication i * pd
<operator>.addressOf & n
<operator>.addressOf & pd
<operator>.addressOf & pg
>>>PDG&32 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 2->1 2->1 2->9 3->1 3->1 4->1 4->1 5->1 5->1 5->7 6->1 7->1 7->1 7->7 7->9 7->10 7->11 7->18 7->23 7->29 7->30 7->31 8->6 9->1 9->15 9->17 9->22 10->1 10->1 10->1 10->1 10->12 10->14 10->21 10->23 10->24 10->25 10->26 10->28 11->1 11->1 11->1 11->12 11->14 11->15 11->16 11->21 12->1 12->10 12->14 12->14 12->20 12->21 12->27 12->28 12->28 13->1 13->12 14->1 14->1 14->1 14->17 14->22 15->1 15->1 15->9 16->1 16->12 17->1 17->1 17->9 18->1 18->1 18->11 18->11 18->19 18->25 19->1 19->1 19->11 19->11 20->1 20->1 20->12 20->13 21->1 22->1 22->1 22->9 23->1 23->10 23->18 23->18 23->24 23->25 23->28 24->1 24->10 24->18 24->18 24->26 25->1 25->10 25->19 25->19 25->23 25->26 25->28 26->1 26->10 26->19 26->19 26->24 27->1 27->20 27->20 28->1 28->10 28->13 28->14 28->23 28->27 28->27
>>>Token int main ( ) { int pd , pg , t , x = 0 ; SKKLUQG n , i , j , k ; SLWAGVO ( " " , " " , stdin ) ; SLWAGVO ( " " , " " , POQJDX ) ; FEKKN ( " " , & t ) ; while ( t -- ) { x ++ ; FEKKN ( " " , & n , & pd , & pg ) ; if ( pd != 100 && pg == 100 || pd != 0 && pg == 0 ) { printf ( " \n " , x ) ; continue ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i * pd % 100 == 0 ) break ; } if ( i == n + 1 ) { printf ( " \n " , x ) ; continue ; } else { printf ( " \n " , x ) ; continue ; } } return 0 ; }
>>>Func
METHOD ac
METHOD_RETURN int
PARAM int * UEV
PARAM int VVC
PARAM int ECK
<operator>.lessThan fi ( VVC ) <VXOHATU
RETURN return ( - 1 ) ; return ( - 1 ) ;
<operator>.minus - 1
fi fi ( VVC )
>>>PDG&9 0->2 0->3 0->4 0->5 0->7 0->8 2->1 3->8 4->1 5->1 5->1 5->1 6->1 7->1 7->6 8->1 8->5
>>>Token int ac ( int * UEV , int VVC , int ECK ) { fi ( VVC ) < VXOHATU ' ' > if ( ECK == UEV [ i ] ) return ( ECK ) ; return ( - 1 ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
assert assert ( argc == 3 )
<operator>.assignment WXPSKVUWD = OCOXQ ( argv [ 1 ] , "r" )
<operator>.assignment TWAEIFSAPF = OCOXQ ( argv [ 2 ] , "w" )
OBNSF OBNSF ( ERIFQHAI , 5000 , WXPSKVUWD )
<operator>.assignment JNQGYQHRLTNI = atoi ( ERIFQHAI )
<operator>.assignment UIPUSTH = 1
NYHUNH NYHUNH ( WXPSKVUWD )
NYHUNH NYHUNH ( TWAEIFSAPF )
<operator>.notEquals OBNSF ( ERIFQHAI , 5000 , WXPSKVUWD ) != NULL
<operator>.equals argc == 3
OCOXQ OCOXQ ( argv [ 1 ] , "r" )
OCOXQ OCOXQ ( argv [ 2 ] , "w" )
atoi atoi ( ERIFQHAI )
<operator>.assignment DDK = MYYWEP ( ERIFQHAI , " " )
<operator>.assignment L = atoi ( DDK )
<operator>.assignment DDK = MYYWEP ( NULL , " " )
<operator>.assignment t = atoi ( DDK )
<operator>.assignment DDK = MYYWEP ( NULL , " " )
<operator>.assignment N = atoi ( DDK )
<operator>.assignment DDK = MYYWEP ( NULL , " " )
<operator>.assignment C = atoi ( DDK )
<operator>.assignment DDK = MYYWEP ( NULL , " " )
<operator>.assignment i = 0
<operator>.assignment RQCQSGBXBDNJ = 0
<operator>.assignment NAWWOQXPG = 0
fprintf fprintf ( TWAEIFSAPF   "Case #%d: %d\n"   UIPUSTH   ( int ) NAWWOQXPG )
LTXKKO LTXKKO ( TWAEIFSAPF )
<operator>.postIncrement UIPUSTH ++
OBNSF OBNSF ( ERIFQHAI , 5000 , WXPSKVUWD )
<operator>.notEquals DDK != NULL
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.assignment TDBH [ i ] = JHHOADWBBY [ i % C ]
<operator>.lessThan i < N
<operator>.postIncrement i ++
MYYWEP MYYWEP ( ERIFQHAI , " " )
atoi atoi ( DDK )
MYYWEP MYYWEP ( NULL , " " )
atoi atoi ( DDK )
MYYWEP MYYWEP ( NULL , " " )
atoi atoi ( DDK )
MYYWEP MYYWEP ( NULL , " " )
atoi atoi ( DDK )
MYYWEP MYYWEP ( NULL , " " )
<operator>.assignment JHHOADWBBY [ i ++ ] = atoi ( DDK )
<operator>.assignment DDK = MYYWEP ( NULL , " " )
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment time = TDBH [ i ] / 0.5
<operator>.cast ( int ) NAWWOQXPG
<operator>.lessEqualsThan time <= t
atoi atoi ( DDK )
MYYWEP MYYWEP ( NULL , " " )
<operator>.modulo i % C
<operator>.division TDBH [ i ] / 0.5
<operator>.assignmentPlus NAWWOQXPG += time
<operator>.postIncrement i ++
<operator>.lessThan RQCQSGBXBDNJ < L
<operator>.assignmentPlus NAWWOQXPG += ( float ) ( TDBH [ i ] + 0.5 * t )
<operator>.postIncrement RQCQSGBXBDNJ ++
<operator>.assignment XWYSP = FFXKIKXKHUAAUPJ ( i , TDBH )
<operator>.cast ( float ) ( TDBH [ i ] + 0.5 * t )
<operator>.greaterThan TDBH [ XWYSP ] > TDBH [ i ]
<operator>.addition TDBH [ i ] + 0.5 * t
FFXKIKXKHUAAUPJ FFXKIKXKHUAAUPJ ( i , TDBH )
<operator>.assignmentPlus NAWWOQXPG += time
<operator>.multiplication 0.5 * t
<operator>.assignment NAWWOQXPG = ( NAWWOQXPG - ( TDBH [ XWYSP ] + 0.5 * t ) + ( TDBH [ XWYSP ] / 0.5 ) + ( TDBH [ i ] + 0.5 * t ) )
<operator>.addition NAWWOQXPG - ( TDBH [ XWYSP ] + 0.5 * t ) + ( TDBH [ XWYSP ] / 0.5 ) + ( TDBH [ i ] + 0.5 * t )
<operator>.addition NAWWOQXPG - ( TDBH [ XWYSP ] + 0.5 * t ) + ( TDBH [ XWYSP ] / 0.5 )
<operator>.addition TDBH [ i ] + 0.5 * t
<operator>.subtraction NAWWOQXPG - ( TDBH [ XWYSP ] + 0.5 * t )
<operator>.division TDBH [ XWYSP ] / 0.5
<operator>.multiplication 0.5 * t
<operator>.addition TDBH [ XWYSP ] + 0.5 * t
<operator>.multiplication 0.5 * t
<operator>.indirectIndexAccess TDBH [ i ]
<operator>.indirectIndexAccess JHHOADWBBY [ i % C ]
UNKNOWN int int
<operator>.indirectIndexAccess JHHOADWBBY [ i ++ ]
<operator>.indirectIndexAccess TDBH [ i ]
UNKNOWN float float
<operator>.indirectIndexAccess TDBH [ i ]
<operator>.indirectIndexAccess TDBH [ XWYSP ]
<operator>.indirectIndexAccess TDBH [ i ]
<operator>.indirectIndexAccess TDBH [ i ]
<operator>.indirectIndexAccess TDBH [ XWYSP ]
<operator>.indirectIndexAccess TDBH [ XWYSP ]
>>>PDG&92 0->2 0->3 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->50 0->51 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->68 0->69 0->70 0->75 0->76 0->77 0->79 2->13 3->1 3->14 3->15 4->1 4->1 5->1 5->1 5->7 6->1 6->1 6->11 6->29 7->16 7->32 8->1 8->1 8->1 9->1 9->1 9->29 10->1 10->1 11->1 11->1 12->1 12->1 12->1 12->12 12->17 12->18 12->19 12->20 12->21 12->22 12->23 12->24 12->25 12->26 12->27 12->28 12->29 12->30 12->31 12->32 12->33 12->34 12->37 12->39 12->40 12->41 12->41 12->42 12->43 12->44 12->45 12->46 12->47 12->50 12->51 12->53 12->82 13->1 13->4 13->4 14->1 14->5 14->5 15->1 15->6 15->6 16->8 16->32 17->1 17->1 17->40 18->1 18->1 18->61 19->42 20->1 20->1 20->54 21->44 22->1 22->34 23->46 24->1 24->1 24->1 24->57 25->1 25->1 25->33 26->60 27->1 27->1 27->61 28->1 28->29 28->53 28->59 28->62 28->69 28->75 29->1 29->1 29->30 29->31 30->1 30->11 30->29 31->1 31->1 31->29 32->1 32->10 32->12 32->12 32->12 32->39 33->1 33->1 33->12 33->33 33->48 33->49 33->55 33->55 33->56 33->56 33->60 33->83 34->34 34->35 34->36 34->37 34->57 34->57 34->80 34->81 35->1 35->34 36->1 36->1 36->1 36->58 37->1 37->1 37->1 37->37 37->38 37->38 37->52 37->54 37->58 37->68 37->84 38->1 38->37 39->17 39->17 39->32 40->18 41->19 41->19 41->43 42->20 43->21 43->21 43->45 44->22 45->23 45->23 45->47 46->24 47->25 47->25 47->33 48->1 48->1 48->1 49->1 49->1 49->33 50->34 51->1 51->37 52->1 52->1 52->54 53->1 54->1 54->1 54->1 54->59 54->59 54->61 54->69 54->70 54->79 55->48 56->33 56->49 56->49 57->1 57->35 58->1 58->52 58->52 58->62 58->65 58->66 58->67 58->68 59->1 59->1 59->29 59->53 59->62 59->69 59->75 61->1 61->1 61->1 61->62 61->63 61->63 61->64 61->65 61->66 61->67 61->68 61->70 61->85 61->86 61->87 61->88 62->1 62->1 62->29 62->53 62->59 62->69 62->75 63->1 63->1 63->61 64->1 64->1 64->1 65->1 66->1 66->1 66->1 66->58 66->68 66->69 66->71 66->71 66->72 66->72 66->73 66->74 66->74 66->75 66->75 66->76 66->76 66->77 66->78 66->78 66->79 66->89 66->90 66->91 67->1 67->1 68->1 68->38 68->58 68->62 68->64 68->64 68->65 68->66 68->67 68->71 68->72 68->74 68->75 68->76 68->78 69->1 69->1 69->29 69->53 69->59 69->62 69->75 70->1 70->54 70->62 70->62 70->65 70->65 70->67 70->67 71->1 71->1 71->29 71->53 71->59 71->62 71->69 71->75 72->1 72->1 73->1 73->1 74->1 74->1 75->1 75->71 75->71 75->72 75->72 75->73 75->73 76->1 76->66 76->68 76->71 76->71 76->72 76->72 76->73 76->73 77->1 77->54 77->71 77->71 77->72 77->72 77->74 77->74 79->75 79->75 79->77 79->78 79->78
>>>Token int main ( int argc , char * * argv ) { assert ( argc == 3 ) ; RJUL * WXPSKVUWD , * TWAEIFSAPF ; int UIPUSTH , JNQGYQHRLTNI ; int t , N , C , RQCQSGBXBDNJ ; int i , j , XWYSP , TDBH [ VKJMTBBNQ ] , JHHOADWBBY [ VKJMTBBNQ ] ; char ERIFQHAI [ 5000 ] , * DDK ; float time , NAWWOQXPG ; WXPSKVUWD = OCOXQ ( argv [ 1 ] , " " ) ; TWAEIFSAPF = OCOXQ ( argv [ 2 ] , " " ) ; OBNSF ( ERIFQHAI , 5000 , WXPSKVUWD ) ; JNQGYQHRLTNI = atoi ( ERIFQHAI ) ; UIPUSTH = 1 ; while ( OBNSF ( ERIFQHAI , 5000 , WXPSKVUWD ) != NULL ) { DDK = MYYWEP ( ERIFQHAI , " " ) ; L = atoi ( DDK ) ; DDK = MYYWEP ( NULL , " " ) ; t = atoi ( DDK ) ; DDK = MYYWEP ( NULL , " " ) ; N = atoi ( DDK ) ; DDK = MYYWEP ( NULL , " " ) ; C = atoi ( DDK ) ; DDK = MYYWEP ( NULL , " " ) ; i = 0 ; while ( DDK != NULL ) { JHHOADWBBY [ i ++ ] = atoi ( DDK ) ; DDK = MYYWEP ( NULL , " " ) ; } for ( i = 0 ; i < N ; i ++ ) TDBH [ i ] = JHHOADWBBY [ i % C ] ; RQCQSGBXBDNJ = 0 ; NAWWOQXPG = 0 ; for ( i = 0 ; i < N ; i ++ ) { time = TDBH [ i ] / 0.5 ; if ( time <= t ) NAWWOQXPG += time ; else if ( RQCQSGBXBDNJ < L ) { NAWWOQXPG += ( float ) ( TDBH [ i ] + 0.5 * t ) ; RQCQSGBXBDNJ ++ ; } else { XWYSP = FFXKIKXKHUAAUPJ ( i , TDBH ) ; if ( TDBH [ XWYSP ] > TDBH [ i ] ) NAWWOQXPG += time ; else NAWWOQXPG = ( NAWWOQXPG - ( TDBH [ XWYSP ] + 0.5 * t ) + ( TDBH [ XWYSP ] / 0.5 ) + ( TDBH [ i ] + 0.5 * t ) ) ; } } fprintf ( TWAEIFSAPF , " \n " , UIPUSTH , ( int ) NAWWOQXPG ) ; LTXKKO ( TWAEIFSAPF ) ; UIPUSTH ++ ; } NYHUNH ( WXPSKVUWD ) ; NYHUNH ( TWAEIFSAPF ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
HBGNE HBGNE ( "%d" , & YVCOPWUFXQ )
<operator>.lessThan i < YVCOPWUFXQ
<operator>.postIncrement i ++
<operator>.assignment i = 0
HBGNE HBGNE ( "%d" , & MAKFUITBD )
ADWAP ADWAP ( OMXWWGV   MAKFUITBD   sizeof ( int )   ( int ( * ) ( const void * , const void * ) ) CVXVYDMLBM )
ADWAP ADWAP ( VCXLTWI   MAKFUITBD   sizeof ( int )   ( int ( * ) ( const void * , const void * ) ) KHIJLIWIHFK )
printf printf ( "Case #%d: %d\n" , i + 1 , AUYJYH )
<operator>.lessThan j < MAKFUITBD
<operator>.postIncrement j ++
<operator>.lessThan j < MAKFUITBD
<operator>.postIncrement j ++
<operator>.lessThan j < MAKFUITBD
<operator>.postIncrement j ++
<operator>.assignment j = 0
HBGNE HBGNE ( "%d" , & OMXWWGV [ j ] )
<operator>.assignment j = 0
HBGNE HBGNE ( "%d" , & VCXLTWI [ j ] )
<operator>.cast ( int ( * ) ( const void * , const void * ) ) CVXVYDMLBM
<operator>.cast ( int ( * ) ( const void * , const void * ) ) KHIJLIWIHFK
<operator>.expressionList j = 0   AUYJYH = 0
<operator>.assignmentPlus AUYJYH += OMXWWGV [ j ] * VCXLTWI [ j ]
<operator>.addition i + 1
<operator>.assignment j = 0
<operator>.assignment AUYJYH = 0
<operator>.multiplication OMXWWGV [ j ] * VCXLTWI [ j ]
<operator>.addressOf & MAKFUITBD
<operator>.sizeOf sizeof ( int )
<operator>.sizeOf sizeof ( int )
UNKNOWN int ( * ) ( const void * , const void * ) int ( * ) ( const void * , const void * )
UNKNOWN int ( * ) ( const void * , const void * ) int ( * ) ( const void * , const void * )
<operator>.addressOf & OMXWWGV [ j ]
<operator>.addressOf & VCXLTWI [ j ]
<operator>.indirectIndexAccess OMXWWGV [ j ]
<operator>.indirectIndexAccess VCXLTWI [ j ]
<operator>.indirectIndexAccess OMXWWGV [ j ]
<operator>.indirectIndexAccess VCXLTWI [ j ]
>>>PDG&41 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 2->1 3->1 4->1 4->1 4->5 5->1 5->1 5->1 5->5 5->6 5->6 5->8 5->9 5->10 5->11 5->11 5->12 5->14 5->16 5->18 5->20 5->22 5->23 5->24 5->26 5->26 5->27 5->28 5->30 5->31 5->32 5->33 5->34 6->1 6->5 7->1 7->5 8->9 8->10 8->12 8->14 8->16 9->10 9->19 9->29 10->16 10->21 10->29 12->12 12->13 12->13 12->14 12->19 12->35 12->37 13->12 14->9 14->14 14->15 14->15 14->21 14->36 14->38 15->14 16->8 16->12 16->16 16->17 16->17 16->25 16->29 16->39 16->40 17->16 18->12 19->9 19->29 20->14 21->10 21->29 22->1 23->1 25->11 27->16 27->24 28->11 28->24 28->25 29->9 29->10 29->19 29->21 29->25 29->25
>>>Token int main ( int argc , char * * argv ) { int YVCOPWUFXQ ; int i ; HBGNE ( " " , & YVCOPWUFXQ ) ; for ( i = 0 ; i < YVCOPWUFXQ ; i ++ ) { int MAKFUITBD , j ; int OMXWWGV [ 800 ] ; int VCXLTWI [ 800 ] ; int AUYJYH ; HBGNE ( " " , & MAKFUITBD ) ; for ( j = 0 ; j < MAKFUITBD ; j ++ ) { HBGNE ( " " , & OMXWWGV [ j ] ) ; } for ( j = 0 ; j < MAKFUITBD ; j ++ ) { HBGNE ( " " , & VCXLTWI [ j ] ) ; } ADWAP ( OMXWWGV , MAKFUITBD , sizeof ( int ) , ( int ( * ) ( const void * , const void * ) ) CVXVYDMLBM ) ; ADWAP ( VCXLTWI , MAKFUITBD , sizeof ( int ) , ( int ( * ) ( const void * , const void * ) ) KHIJLIWIHFK ) ; for ( j = 0 , AUYJYH = 0 ; j < MAKFUITBD ; j ++ ) { AUYJYH += OMXWWGV [ j ] * VCXLTWI [ j ] ; } printf ( " \n " , i + 1 , AUYJYH ) ; } }
>>>Func
METHOD WJSJLSSLJIP
METHOD_RETURN bool
PARAM int fd
PARAM char const * DCPY
PARAM bool XPHSJEEOMVA
PARAM off_t BWYW
<operator>.assignment LYJFKWAD = lseek ( fd , BWYW , IKLYPPQO )
RETURN return true ; return true ;
<operator>.lessThan LYJFKWAD < 0
<operator>.logicalAnd XPHSJEEOMVA && DEUBFBJPOK ( fd , LYJFKWAD - BWYW , BWYW ) < 0
IDENTIFIER true return true ;
lseek lseek ( fd , BWYW , IKLYPPQO )
QHYJQ QHYJQ ( 0   FPHRL   _ ( "cannot lseek %s" )   HULJTWK ( DCPY ) )
RETURN return false ; return false ;
QHYJQ QHYJQ ( 0   FPHRL   _ ( "error deallocating %s" )   HULJTWK ( DCPY ) )
RETURN return false ; return false ;
IDENTIFIER false return false ;
<operator>.lessThan DEUBFBJPOK ( fd , LYJFKWAD - BWYW , BWYW ) < 0
IDENTIFIER false return false ;
_ _ ( "cannot lseek %s" )
HULJTWK HULJTWK ( DCPY )
DEUBFBJPOK DEUBFBJPOK ( fd , LYJFKWAD - BWYW , BWYW )
_ _ ( "error deallocating %s" )
HULJTWK HULJTWK ( DCPY )
<operator>.subtraction LYJFKWAD - BWYW
>>>PDG&25 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 2->11 3->20 3->23 4->1 4->9 5->11 6->1 6->1 6->8 7->1 8->1 8->1 8->9 8->12 8->13 8->17 8->19 8->20 8->21 8->24 8->24 9->7 9->14 9->15 9->22 9->23 10->7 11->1 11->1 11->1 11->6 11->6 11->6 11->21 11->24 12->1 12->1 12->1 12->1 13->1 15->1 16->13 17->9 17->9 18->15 19->12 20->1 20->12 21->17 21->17 21->17 22->14 23->14 24->21 24->21
>>>Token static bool WJSJLSSLJIP ( int fd , char const * DCPY , bool XPHSJEEOMVA , off_t BWYW ) { off_t LYJFKWAD = lseek ( fd , BWYW , IKLYPPQO ) ; if ( LYJFKWAD < 0 ) { QHYJQ ( 0 , FPHRL , _ ( " " ) , HULJTWK ( DCPY ) ) ; return false ; } if ( XPHSJEEOMVA && DEUBFBJPOK ( fd , LYJFKWAD - BWYW , BWYW ) < 0 ) { QHYJQ ( 0 , FPHRL , _ ( " " ) , HULJTWK ( DCPY ) ) ; return false ; } return true ; }
>>>Func
METHOD DNSWTSKGDN
METHOD_RETURN int
PARAM struct EKGASEEF * PEKK
<operator>.assignment CWILMDDQLH = DNSWTSKGDN ( PEKK -> FGEB )
<operator>.assignment YPIDFOPNOJT = DNSWTSKGDN ( PEKK -> UQJAB )
RETURN return CWILMDDQLH + YPIDFOPNOJT + 1 ; return CWILMDDQLH + YPIDFOPNOJT + 1 ;
<operator>.logicalNot ! PEKK
<operator>.addition CWILMDDQLH + YPIDFOPNOJT + 1
RETURN return 0 ; return 0 ;
DNSWTSKGDN DNSWTSKGDN ( PEKK -> FGEB )
DNSWTSKGDN DNSWTSKGDN ( PEKK -> UQJAB )
LITERAL 0 return 0 ;
<operator>.addition CWILMDDQLH + YPIDFOPNOJT
<operator>.indirectFieldAccess PEKK -> FGEB
<operator>.indirectFieldAccess PEKK -> UQJAB
FIELD_IDENTIFIER FGEB FGEB
FIELD_IDENTIFIER UQJAB UQJAB
>>>PDG&17 0->2 0->6 0->7 0->8 0->11 0->12 2->6 3->7 3->12 4->7 4->12 5->1 6->1 6->1 6->3 6->4 6->5 6->7 6->8 6->9 6->10 6->12 6->13 6->14 6->15 6->16 7->5 8->1 9->3 10->4 11->8
>>>Token int DNSWTSKGDN ( struct EKGASEEF * PEKK ) { if ( ! PEKK ) return 0 ; int CWILMDDQLH = DNSWTSKGDN ( PEKK -> FGEB ) ; int YPIDFOPNOJT = DNSWTSKGDN ( PEKK -> UQJAB ) ; return CWILMDDQLH + YPIDFOPNOJT + 1 ; }
>>>Func
METHOD MUSYNQIM
METHOD_RETURN bool
PARAM JDWOT g
PARAM TLRKGV v
PARAM TLRKGV w
assert assert ( g != NULL && IMVJLC ( g , v ) && IMVJLC ( g , w ) )
RETURN return ( g -> WDEYX [ v ] [ w ] != 0 ) ; return ( g -> WDEYX [ v ] [ w ] != 0 ) ;
<operator>.notEquals g -> WDEYX [ v ] [ w ] != 0
<operator>.logicalAnd g != NULL && IMVJLC ( g , v ) && IMVJLC ( g , w )
<operator>.logicalAnd g != NULL && IMVJLC ( g , v )
IMVJLC IMVJLC ( g , w )
<operator>.notEquals g != NULL
IMVJLC IMVJLC ( g , v )
>>>PDG&13 0->2 0->3 0->4 0->7 0->10 0->11 0->12 2->11 3->1 3->12 4->1 4->10 5->1 5->1 6->1 7->1 7->1 7->6 8->1 8->1 8->5 8->5 9->1 9->1 9->8 9->8 9->10 10->1 10->1 10->8 10->8 11->1 11->1 11->9 11->9 11->10 11->12 11->12 12->1 12->1 12->9 12->9 12->10
>>>Token bool MUSYNQIM ( JDWOT g , TLRKGV v , TLRKGV w ) { assert ( g != NULL && IMVJLC ( g , v ) && IMVJLC ( g , w ) ) ; return ( g -> WDEYX [ v ] [ w ] != 0 ) ; }
>>>Func
METHOD ACWNAMQNHPBJQQBF
METHOD_RETURN int
PARAM WGGWYYNF * OEIH
PARAM WGGWYYNF * WWHYY
RETURN return 0 ; return 0 ;
<operator>.lessThan OEIH [ 0 ] . s < WWHYY [ 0 ] . s
<operator>.greaterThan OEIH [ 0 ] . s > WWHYY [ 0 ] . s
<operator>.greaterThan OEIH [ 0 ] . l > WWHYY [ 0 ] . l
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
RETURN return 0 ; return 0 ;
RETURN return 1 ; return 1 ;
LITERAL 1 return 1 ;
LITERAL 0 return 0 ;
LITERAL 1 return 1 ;
<operator>.fieldAccess OEIH [ 0 ] . s
<operator>.fieldAccess WWHYY [ 0 ] . s
<operator>.fieldAccess OEIH [ 0 ] . l
<operator>.fieldAccess WWHYY [ 0 ] . l
<operator>.indirectIndexAccess OEIH [ 0 ]
FIELD_IDENTIFIER s s
<operator>.indirectIndexAccess WWHYY [ 0 ]
FIELD_IDENTIFIER s s
<operator>.indirectIndexAccess OEIH [ 0 ]
FIELD_IDENTIFIER l l
<operator>.indirectIndexAccess WWHYY [ 0 ]
FIELD_IDENTIFIER l l
>>>PDG&27 0->2 0->3 0->4 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 4->1 5->1 5->1 5->1 5->6 5->6 5->6 5->9 5->15 5->16 5->19 5->20 5->21 5->22 6->7 6->10 6->17 6->18 6->23 6->24 6->25 6->26 7->4 7->11 8->4 9->1 10->1 11->1 12->9 13->10 14->11
>>>Token int ACWNAMQNHPBJQQBF ( WGGWYYNF * OEIH , WGGWYYNF * WWHYY ) { if ( OEIH [ 0 ] . s < WWHYY [ 0 ] . s ) { return 1 ; } if ( OEIH [ 0 ] . s > WWHYY [ 0 ] . s ) { return 0 ; } if ( OEIH [ 0 ] . l > WWHYY [ 0 ] . l ) { return 1 ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
XDULX XDULX ( "%d" , & DVCUMU )
RETURN return 0 ; return 0 ;
<operator>.notEquals TFKWE != DVCUMU
<operator>.postIncrement TFKWE ++
LITERAL 0 return 0 ;
<operator>.assignment TFKWE = 0
XDULX XDULX ( "%d %d %d %lf %d" , & X , & S , & R , & T , & N )
XOBAA XOBAA ( QHMI   N   sizeof ( struct EVD ) , BKACNUNL )
<operator>.assignment QVXOCQ = 0
<operator>.assignment MKK = 0
XOBAA XOBAA ( XQYMB   MKK   sizeof ( struct EVD ) , BKACNUNL )
<operator>.assignment time = 0.0
<operator>.assignmentMinus R -= S
printf printf ( "Case #%d: %.10lf\n" , TFKWE + 1 , time )
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.notEquals QVXOCQ != X
<operator>.logicalAnd i < MKK && T > 1e-10
<operator>.postIncrement i ++
<operator>.lessThan i < MKK
<operator>.postIncrement i ++
<operator>.assignment i = 0
XDULX XDULX ( "%d %d %d" , & QHMI [ i ] . v , & QHMI [ i ] . MKK , & QHMI [ i ] . HON )
<operator>.assignment i = 0
<operator>.assignment XQYMB [ MKK ] . v = QHMI [ i ] . HON + S
<operator>.assignment XQYMB [ MKK ] . MKK = QHMI [ i ] . MKK - QHMI [ i ] . v
<operator>.preIncrement ++ MKK
<operator>.assignment QVXOCQ = QHMI [ i ] . MKK
<operator>.assignment XQYMB [ MKK ] . v = S
<operator>.assignment XQYMB [ MKK ] . MKK = X - QVXOCQ
<operator>.preIncrement ++ MKK
<operator>.sizeOf sizeof ( struct EVD )
<operator>.assignment i = 0
<operator>.assignment w = XQYMB [ i ] . MKK / ( double ) ( XQYMB [ i ] . v + R )
<operator>.assignmentPlus time += XQYMB [ i ] . MKK / ( double ) XQYMB [ i ] . v
<operator>.addition TFKWE + 1
<operator>.notEquals QHMI [ i ] . v != QVXOCQ
<operator>.lessThan i < MKK
<operator>.greaterThan T > 1e-10
<operator>.logicalOr w < T || LURA ( w - T ) < 1e-10
<operator>.assignment XQYMB [ MKK ] . v = S
<operator>.assignment XQYMB [ MKK ] . MKK = QHMI [ i ] . v - QVXOCQ
<operator>.preIncrement ++ MKK
<operator>.addition QHMI [ i ] . HON + S
<operator>.subtraction QHMI [ i ] . MKK - QHMI [ i ] . v
<operator>.subtraction X - QVXOCQ
<operator>.division XQYMB [ i ] . MKK / ( double ) ( XQYMB [ i ] . v + R )
<operator>.assignmentMinus T -= w
<operator>.assignmentPlus time += w
<operator>.division XQYMB [ i ] . MKK / ( double ) XQYMB [ i ] . v
<operator>.cast ( double ) ( XQYMB [ i ] . v + R )
<operator>.lessThan w < T
<operator>.lessThan LURA ( w - T ) < 1e-10
<operator>.assignmentPlus time += T
<operator>.assignmentPlus time += ( XQYMB [ i ] . MKK - T * ( XQYMB [ i ] . v + R ) ) / ( double ) ( XQYMB [ i ] . v )
<operator>.assignment T = 0.0
<operator>.subtraction QHMI [ i ] . v - QVXOCQ
<operator>.addition XQYMB [ i ] . v + R
LURA LURA ( w - T )
<operator>.subtraction w - T
<operator>.division ( XQYMB [ i ] . MKK - T * ( XQYMB [ i ] . v + R ) ) / ( double ) ( XQYMB [ i ] . v )
<operator>.subtraction XQYMB [ i ] . MKK - T * ( XQYMB [ i ] . v + R )
<operator>.multiplication T * ( XQYMB [ i ] . v + R )
<operator>.addition XQYMB [ i ] . v + R
<operator>.addressOf & X
<operator>.addressOf & S
<operator>.addressOf & R
<operator>.addressOf & T
<operator>.addressOf & N
<operator>.sizeOf sizeof ( struct EVD )
<operator>.addressOf & QHMI [ i ] . v
<operator>.addressOf & QHMI [ i ] . MKK
<operator>.addressOf & QHMI [ i ] . HON
<operator>.fieldAccess XQYMB [ MKK ] . v
<operator>.fieldAccess XQYMB [ MKK ] . MKK
<operator>.fieldAccess QHMI [ i ] . MKK
<operator>.fieldAccess XQYMB [ MKK ] . v
<operator>.fieldAccess XQYMB [ MKK ] . MKK
<operator>.fieldAccess QHMI [ i ] . v
<operator>.fieldAccess QHMI [ i ] . MKK
<operator>.fieldAccess QHMI [ i ] . HON
<operator>.fieldAccess QHMI [ i ] . v
<operator>.indirectIndexAccess XQYMB [ MKK ]
FIELD_IDENTIFIER v v
<operator>.fieldAccess QHMI [ i ] . HON
<operator>.indirectIndexAccess XQYMB [ MKK ]
FIELD_IDENTIFIER MKK MKK
<operator>.fieldAccess QHMI [ i ] . MKK
<operator>.fieldAccess QHMI [ i ] . v
<operator>.indirectIndexAccess QHMI [ i ]
FIELD_IDENTIFIER MKK MKK
<operator>.indirectIndexAccess XQYMB [ MKK ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess XQYMB [ MKK ]
FIELD_IDENTIFIER MKK MKK
<operator>.fieldAccess XQYMB [ i ] . MKK
<operator>.fieldAccess XQYMB [ i ] . MKK
<operator>.cast ( double ) XQYMB [ i ] . v
<operator>.indirectIndexAccess QHMI [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess QHMI [ i ]
FIELD_IDENTIFIER MKK MKK
<operator>.indirectIndexAccess QHMI [ i ]
FIELD_IDENTIFIER HON HON
<operator>.indirectIndexAccess QHMI [ i ]
FIELD_IDENTIFIER v v
<operator>.fieldAccess XQYMB [ MKK ] . v
<operator>.fieldAccess XQYMB [ MKK ] . MKK
<operator>.indirectIndexAccess QHMI [ i ]
FIELD_IDENTIFIER HON HON
<operator>.indirectIndexAccess QHMI [ i ]
FIELD_IDENTIFIER MKK MKK
<operator>.indirectIndexAccess QHMI [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess XQYMB [ i ]
FIELD_IDENTIFIER MKK MKK
UNKNOWN double double
<operator>.indirectIndexAccess XQYMB [ i ]
FIELD_IDENTIFIER MKK MKK
UNKNOWN double double
<operator>.fieldAccess XQYMB [ i ] . v
<operator>.indirectIndexAccess XQYMB [ MKK ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess XQYMB [ MKK ]
FIELD_IDENTIFIER MKK MKK
<operator>.fieldAccess QHMI [ i ] . v
<operator>.fieldAccess XQYMB [ i ] . v
<operator>.indirectIndexAccess XQYMB [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess QHMI [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess XQYMB [ i ]
FIELD_IDENTIFIER v v
<operator>.cast ( double ) ( XQYMB [ i ] . v )
<operator>.fieldAccess XQYMB [ i ] . MKK
UNKNOWN double double
<operator>.fieldAccess XQYMB [ i ] . v
<operator>.indirectIndexAccess XQYMB [ i ]
FIELD_IDENTIFIER MKK MKK
<operator>.indirectIndexAccess XQYMB [ i ]
FIELD_IDENTIFIER v v
<operator>.fieldAccess XQYMB [ i ] . v
<operator>.indirectIndexAccess XQYMB [ i ]
FIELD_IDENTIFIER v v
>>>PDG&148 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->32 0->34 0->36 0->38 0->39 0->40 0->41 0->42 0->44 0->46 0->47 0->49 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->63 0->66 0->67 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->15 4->16 4->18 4->20 4->21 4->23 4->25 4->27 4->35 4->36 4->39 4->39 4->41 4->68 4->69 4->70 4->71 4->72 4->73 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->1 8->1 8->1 8->9 8->14 8->14 8->16 8->18 8->20 8->28 8->32 8->42 8->44 8->47 8->49 8->50 8->51 8->54 8->55 8->57 8->61 8->63 8->66 8->66 8->67 9->1 9->1 9->12 9->18 10->1 10->20 10->40 11->1 11->12 11->30 11->34 11->46 12->1 12->1 12->1 12->9 12->41 13->1 13->15 13->38 13->52 13->57 14->1 14->1 14->1 14->8 14->50 14->54 14->61 15->1 15->1 15->1 16->9 16->16 16->17 16->17 16->26 16->74 16->75 16->76 16->82 16->83 16->84 16->102 16->103 16->104 16->105 16->106 16->107 17->1 17->16 18->1 18->1 18->8 18->16 18->18 18->19 18->19 18->28 18->29 18->30 18->31 18->40 18->47 18->48 18->77 18->78 18->79 18->85 18->86 18->87 18->88 18->89 18->90 18->91 18->92 18->93 18->94 18->108 18->109 18->112 18->113 18->114 18->115 18->116 18->117 19->1 19->18 20->1 20->1 20->1 20->8 20->32 20->33 20->34 20->49 20->49 20->49 20->80 20->81 20->95 20->96 20->97 20->98 21->1 21->1 21->21 21->22 21->37 21->41 21->43 21->50 21->54 21->55 21->61 21->99 21->118 21->119 21->120 21->130 21->135 21->136 22->1 22->41 23->1 23->1 23->1 23->23 23->24 23->24 23->38 23->53 23->100 23->101 23->121 23->122 23->123 23->124 23->131 23->132 24->1 24->23 25->16 26->1 26->1 26->1 26->1 26->28 26->31 26->40 26->47 26->48 26->48 26->60 27->18 28->1 28->1 29->1 29->1 30->1 30->12 30->34 30->46 31->1 31->20 31->40 32->1 33->1 33->1 34->1 34->12 35->1 36->1 36->41 37->1 37->1 37->55 38->1 38->1 38->15 40->1 40->44 40->45 40->46 40->48 40->60 40->60 40->60 40->110 40->111 40->125 40->126 40->127 40->128 40->129 40->133 40->134 41->21 41->21 41->22 41->23 41->23 41->42 42->1 42->8 42->21 42->21 42->55 43->1 43->1 43->1 43->51 43->52 43->57 43->58 43->59 43->64 43->65 43->66 43->67 43->137 43->138 43->139 43->140 43->141 43->142 43->143 43->144 43->145 43->146 43->147 44->1 45->1 45->1 46->30 48->29 48->29 48->31 49->1 49->1 49->8 49->20 49->33 49->33 50->1 50->37 50->37 50->65 51->1 51->1 51->8 51->42 51->55 52->1 52->1 52->15 52->38 52->57 53->1 53->38 53->38 54->1 55->1 55->43 55->43 55->51 55->51 55->52 55->56 55->57 55->62 55->63 55->63 55->63 55->66 56->1 56->43 56->43 57->1 57->58 58->1 58->1 58->15 58->38 58->52 58->57 59->1 59->1 59->8 59->42 59->55 60->45 60->45 60->48 61->1 62->1 62->56 63->1 63->51 63->51 63->52 63->57 63->62 63->62 63->66 64->1 64->1 64->58 64->58 65->1 65->64 65->64 66->1 66->65 66->65 67->1
>>>Token int main ( ) { int DVCUMU ; XDULX ( " " , & DVCUMU ) ; int TFKWE ; for ( TFKWE = 0 ; TFKWE != DVCUMU ; TFKWE ++ ) { XDULX ( " " , & X , & S , & R , & T , & N ) ; int i ; for ( i = 0 ; i < N ; i ++ ) { XDULX ( " " , & QHMI [ i ] . v , & QHMI [ i ] . MKK , & QHMI [ i ] . HON ) ; } XOBAA ( QHMI , N , sizeof ( struct EVD ) , BKACNUNL ) ; int QVXOCQ = 0 ; int MKK = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( QHMI [ i ] . v != QVXOCQ ) { XQYMB [ MKK ] . v = S ; XQYMB [ MKK ] . MKK = QHMI [ i ] . v - QVXOCQ ; ++ MKK ; } XQYMB [ MKK ] . v = QHMI [ i ] . HON + S ; XQYMB [ MKK ] . MKK = QHMI [ i ] . MKK - QHMI [ i ] . v ; ++ MKK ; QVXOCQ = QHMI [ i ] . MKK ; } if ( QVXOCQ != X ) { XQYMB [ MKK ] . v = S ; XQYMB [ MKK ] . MKK = X - QVXOCQ ; ++ MKK ; } XOBAA ( XQYMB , MKK , sizeof ( struct EVD ) , BKACNUNL ) ; double time = 0.0 ; R -= S ; for ( i = 0 ; i < MKK && T > 1e-10 ; i ++ ) { double w = XQYMB [ i ] . MKK / ( double ) ( XQYMB [ i ] . v + R ) ; if ( w < T || LURA ( w - T ) < 1e-10 ) { T -= w ; time += w ; } else { time += T ; time += ( XQYMB [ i ] . MKK - T * ( XQYMB [ i ] . v + R ) ) / ( double ) ( XQYMB [ i ] . v ) ; T = 0.0 ; } } for ( ; i < MKK ; i ++ ) { time += XQYMB [ i ] . MKK / ( double ) XQYMB [ i ] . v ; } printf ( " \n " , TFKWE + 1 , time ) ; } return 0 ; }
>>>Func
METHOD GLJJ
METHOD_RETURN void
PARAM int XVA
TONWSVI TONWSVI ( )
YTSKNV YTSKNV ( RLF , "%d" , & C )
YTSKNV YTSKNV ( RLF , "%d" , & D )
YTSKNV YTSKNV ( RLF , "%d %s" , & N , HQCL )
fprintf fprintf ( RCYG , "Case #%d: [" , XVA )
<operator>.lessThan i < C
<operator>.preIncrement ++ i
<operator>.lessThan i < D
<operator>.preIncrement ++ i
<operator>.lessThan i < N
<operator>.preIncrement ++ i
<operator>.lessThan i < YHU
<operator>.preIncrement ++ i
<operator>.notEquals YHU != - 1
<operator>.assignment i = 0
YTSKNV YTSKNV ( RLF , "%s" , HQCL )
<operator>.assignment EAB [ HQCL [ 0 ] - 'A' ] [ HQCL [ 1 ] - 'A' ] = HQCL [ 2 ] - 'A'
<operator>.assignment EAB [ HQCL [ 1 ] - 'A' ] [ HQCL [ 0 ] - 'A' ] = HQCL [ 2 ] - 'A'
<operator>.assignment i = 0
YTSKNV YTSKNV ( RLF , "%s" , HQCL )
<operator>.assignment AINJU [ HQCL [ 0 ] - 'A' ] [ HQCL [ 1 ] - 'A' ] = 1
<operator>.assignment AINJU [ HQCL [ 1 ] - 'A' ] [ HQCL [ 0 ] - 'A' ] = 1
<operator>.assignment i = 0
<operator>.assignment LHWVB [ ++ YHU ] = HQCL [ i ]
<operator>.postIncrement PUTIQCH [ LHWVB [ YHU ] - 'A' ] ++
<operator>.assignment i = 0
fprintf fprintf ( RCYG , "%c, " , LHWVB [ i ] )
fprintf fprintf ( RCYG , "%c]\n" , LHWVB [ YHU ] )
<operator>.greaterThan YHU > 0
<operator>.minus - 1
fprintf fprintf ( RCYG , "]\n" )
<operator>.subtraction HQCL [ 2 ] - 'A'
<operator>.subtraction HQCL [ 2 ] - 'A'
NWSDSM NWSDSM ( )
RBQTCQC RBQTCQC ( )
<operator>.subtraction HQCL [ 1 ] - 'A'
<operator>.subtraction HQCL [ 0 ] - 'A'
<operator>.subtraction HQCL [ 1 ] - 'A'
<operator>.subtraction HQCL [ 0 ] - 'A'
<operator>.preIncrement ++ YHU
<operator>.subtraction LHWVB [ YHU ] - 'A'
<operator>.subtraction HQCL [ 0 ] - 'A'
<operator>.subtraction HQCL [ 1 ] - 'A'
<operator>.subtraction HQCL [ 0 ] - 'A'
<operator>.subtraction HQCL [ 1 ] - 'A'
<operator>.indirectIndexAccess EAB [ HQCL [ 0 ] - 'A' ] [ HQCL [ 1 ] - 'A' ]
<operator>.indirectIndexAccess EAB [ HQCL [ 1 ] - 'A' ] [ HQCL [ 0 ] - 'A' ]
<operator>.indirectIndexAccess AINJU [ HQCL [ 0 ] - 'A' ] [ HQCL [ 1 ] - 'A' ]
<operator>.indirectIndexAccess AINJU [ HQCL [ 1 ] - 'A' ] [ HQCL [ 0 ] - 'A' ]
<operator>.indirectIndexAccess LHWVB [ ++ YHU ]
<operator>.indirectIndexAccess HQCL [ i ]
<operator>.indirectIndexAccess PUTIQCH [ LHWVB [ YHU ] - 'A' ]
<operator>.indirectIndexAccess LHWVB [ i ]
<operator>.indirectIndexAccess LHWVB [ YHU ]
<operator>.indirectIndexAccess EAB [ HQCL [ 0 ] - 'A' ]
<operator>.indirectIndexAccess HQCL [ 2 ]
<operator>.indirectIndexAccess EAB [ HQCL [ 1 ] - 'A' ]
<operator>.indirectIndexAccess HQCL [ 2 ]
<operator>.indirectIndexAccess AINJU [ HQCL [ 0 ] - 'A' ]
<operator>.indirectIndexAccess AINJU [ HQCL [ 1 ] - 'A' ]
<operator>.indirectIndexAccess HQCL [ 1 ]
<operator>.indirectIndexAccess HQCL [ 0 ]
<operator>.indirectIndexAccess HQCL [ 1 ]
<operator>.indirectIndexAccess HQCL [ 0 ]
<operator>.indirectIndexAccess LHWVB [ YHU ]
<operator>.indirectIndexAccess HQCL [ 0 ]
<operator>.indirectIndexAccess HQCL [ 1 ]
<operator>.indirectIndexAccess HQCL [ 0 ]
<operator>.indirectIndexAccess HQCL [ 1 ]
>>>PDG&72 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->21 0->22 0->23 0->24 0->25 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 2->7 3->1 4->1 4->1 4->5 4->8 4->18 5->1 5->1 5->6 5->10 5->22 6->1 6->1 6->1 6->1 6->12 6->26 7->1 7->1 7->29 7->30 7->33 8->1 8->1 8->8 8->9 8->9 8->18 8->19 8->20 8->34 8->35 8->38 8->39 8->44 8->45 8->48 8->49 8->57 8->58 8->59 8->60 8->63 8->64 8->68 8->69 9->1 9->8 10->1 10->1 10->10 10->11 10->11 10->22 10->23 10->24 10->40 10->41 10->46 10->47 10->50 10->51 10->61 10->62 10->65 10->66 10->70 10->71 11->1 11->10 12->1 12->1 12->12 12->13 12->13 12->26 12->27 12->31 12->42 12->43 12->52 12->53 12->54 12->67 13->1 13->12 14->1 14->1 14->14 14->15 14->15 14->16 14->29 14->55 15->1 15->14 16->1 16->1 16->1 16->30 16->33 16->56 17->8 18->1 18->5 18->6 18->22 18->34 18->35 18->38 18->39 18->44 18->45 19->1 19->1 20->1 20->1 20->1 21->10 22->1 22->6 22->6 22->40 22->41 22->46 22->47 23->1 23->1 24->1 24->1 25->12 26->1 26->1 26->1 27->1 27->1 28->1 28->14 29->1 29->1 29->30 29->33 30->1 30->1 30->1 31->1 31->14 31->36 31->37 31->42 32->16 34->19 34->19 34->35 35->1 35->6 35->18 35->20 35->20 35->22 35->34 36->1 37->1 38->45 39->1 39->6 39->18 39->22 39->44 39->46 40->47 41->1 41->6 41->22 41->46 42->31 43->30 44->39 45->1 45->6 45->18 45->22 45->38 45->40 46->41 47->1 47->6 47->22 47->40
>>>Token void GLJJ ( int XVA ) { int i , j ; char HQCL [ 200 ] ; TONWSVI ( ) ; YTSKNV ( RLF , " " , & C ) ; for ( i = 0 ; i < C ; ++ i ) { YTSKNV ( RLF , " " , HQCL ) ; EAB [ HQCL [ 0 ] - ' ' ] [ HQCL [ 1 ] - ' ' ] = HQCL [ 2 ] - ' ' ; EAB [ HQCL [ 1 ] - ' ' ] [ HQCL [ 0 ] - ' ' ] = HQCL [ 2 ] - ' ' ; } YTSKNV ( RLF , " " , & D ) ; for ( i = 0 ; i < D ; ++ i ) { YTSKNV ( RLF , " " , HQCL ) ; AINJU [ HQCL [ 0 ] - ' ' ] [ HQCL [ 1 ] - ' ' ] = 1 ; AINJU [ HQCL [ 1 ] - ' ' ] [ HQCL [ 0 ] - ' ' ] = 1 ; } YTSKNV ( RLF , " " , & N , HQCL ) ; for ( i = 0 ; i < N ; ++ i ) { LHWVB [ ++ YHU ] = HQCL [ i ] ; PUTIQCH [ LHWVB [ YHU ] - ' ' ] ++ ; if ( YHU > 0 ) { NWSDSM ( ) ; RBQTCQC ( ) ; } } fprintf ( RCYG , " " , XVA ) ; for ( i = 0 ; i < YHU ; ++ i ) { fprintf ( RCYG , " " , LHWVB [ i ] ) ; } if ( YHU != - 1 ) fprintf ( RCYG , " \n " , LHWVB [ YHU ] ) ; else fprintf ( RCYG , " \n " ) ; }
>>>Func
METHOD JLJXIHLOOBKESQGMVD
METHOD_RETURN ELAAXUPIJ
PARAM ELAAXUPIJ * * MISH
PARAM MEINFDFPNPBWPJG CAWFMDXDKLBP
<operator>.assignment AJKHV = * MISH
<operator>.assignment RMLHPIWBQ = NULL
<operator>.assignment BDQHPTHSG = NULL
<operator>.assignment PPLWV = ( * MISH ) -> XSIS
<operator>.assignment UVVUFHFBYWNXS = JLJXIHLOOBKESQGMVD ( & RMLHPIWBQ , CAWFMDXDKLBP )
<operator>.assignment HKEOCONDIRIYB = JLJXIHLOOBKESQGMVD ( & BDQHPTHSG , CAWFMDXDKLBP )
<operator>.assignment * MISH = RMLHPIWBQ
<operator>.assignment AJKHV -> XSIS = BDQHPTHSG
<operator>.logicalOr MISH == NULL || CAWFMDXDKLBP == NULL
<operator>.logicalOr * MISH == NULL || ( * MISH ) -> XSIS == NULL
<operator>.notEquals PPLWV != NULL
<operator>.equals RMLHPIWBQ == NULL
<operator>.notEquals BDQHPTHSG != NULL
<operator>.equals BDQHPTHSG == NULL
RETURN return NULL ; return NULL ;
RETURN return * MISH ; return * MISH ;
<operator>.assignment * XSIS = PPLWV -> XSIS
<operator>.assignment PPLWV = XSIS
JLJXIHLOOBKESQGMVD JLJXIHLOOBKESQGMVD ( & RMLHPIWBQ , CAWFMDXDKLBP )
JLJXIHLOOBKESQGMVD JLJXIHLOOBKESQGMVD ( & BDQHPTHSG , CAWFMDXDKLBP )
<operator>.assignment AJKHV -> BTJG = NULL
<operator>.assignment * MISH = AJKHV
<operator>.assignment BDQHPTHSG -> BTJG = AJKHV
RETURN return AJKHV ; return AJKHV ;
<operator>.equals MISH == NULL
<operator>.equals CAWFMDXDKLBP == NULL
IDENTIFIER NULL return NULL ;
<operator>.equals * MISH == NULL
<operator>.equals ( * MISH ) -> XSIS == NULL
<operator>.lessThan CAWFMDXDKLBP ( PPLWV -> CEOA , AJKHV -> CEOA ) < 0
<operator>.assignment AJKHV -> BTJG = UVVUFHFBYWNXS
<operator>.assignment UVVUFHFBYWNXS -> XSIS = AJKHV
IDENTIFIER AJKHV return AJKHV ;
RETURN return HKEOCONDIRIYB ; return HKEOCONDIRIYB ;
<operator>.assignment PPLWV -> BTJG = NULL
<operator>.assignment PPLWV -> XSIS = RMLHPIWBQ
<operator>.assignment RMLHPIWBQ = PPLWV
IDENTIFIER HKEOCONDIRIYB return HKEOCONDIRIYB ;
CAWFMDXDKLBP CAWFMDXDKLBP ( PPLWV -> CEOA , AJKHV -> CEOA )
<operator>.notEquals RMLHPIWBQ != NULL
<operator>.assignment PPLWV -> BTJG = NULL
<operator>.assignment PPLWV -> XSIS = BDQHPTHSG
<operator>.assignment BDQHPTHSG = PPLWV
<operator>.assignment RMLHPIWBQ -> BTJG = PPLWV
<operator>.notEquals BDQHPTHSG != NULL
<operator>.assignment BDQHPTHSG -> BTJG = PPLWV
<operator>.indirection * MISH
<operator>.indirectFieldAccess ( * MISH ) -> XSIS
<operator>.indirection * MISH
<operator>.indirectFieldAccess AJKHV -> XSIS
<operator>.indirection * MISH
FIELD_IDENTIFIER XSIS XSIS
<operator>.addressOf & RMLHPIWBQ
<operator>.addressOf & BDQHPTHSG
FIELD_IDENTIFIER XSIS XSIS
<operator>.indirection * MISH
<operator>.indirectFieldAccess ( * MISH ) -> XSIS
<operator>.indirection * MISH
<operator>.indirectFieldAccess PPLWV -> XSIS
<operator>.indirectFieldAccess AJKHV -> BTJG
<operator>.indirection * MISH
<operator>.indirectFieldAccess BDQHPTHSG -> BTJG
<operator>.indirection * MISH
FIELD_IDENTIFIER XSIS XSIS
FIELD_IDENTIFIER XSIS XSIS
FIELD_IDENTIFIER BTJG BTJG
<operator>.indirectFieldAccess AJKHV -> BTJG
<operator>.indirectFieldAccess UVVUFHFBYWNXS -> XSIS
FIELD_IDENTIFIER BTJG BTJG
<operator>.indirectFieldAccess PPLWV -> CEOA
<operator>.indirectFieldAccess AJKHV -> CEOA
<operator>.indirectFieldAccess PPLWV -> BTJG
<operator>.indirectFieldAccess PPLWV -> XSIS
FIELD_IDENTIFIER BTJG BTJG
FIELD_IDENTIFIER XSIS XSIS
FIELD_IDENTIFIER CEOA CEOA
FIELD_IDENTIFIER CEOA CEOA
FIELD_IDENTIFIER BTJG BTJG
FIELD_IDENTIFIER XSIS XSIS
<operator>.indirectFieldAccess PPLWV -> BTJG
<operator>.indirectFieldAccess PPLWV -> XSIS
<operator>.indirectFieldAccess RMLHPIWBQ -> BTJG
FIELD_IDENTIFIER BTJG BTJG
FIELD_IDENTIFIER XSIS XSIS
FIELD_IDENTIFIER BTJG BTJG
<operator>.indirectFieldAccess BDQHPTHSG -> BTJG
FIELD_IDENTIFIER BTJG BTJG
>>>PDG&91 0->2 0->3 0->5 0->6 0->10 0->11 0->14 0->15 0->16 0->17 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->49 2->28 3->1 3->22 3->29 4->25 4->26 4->35 4->36 5->10 5->15 5->22 5->39 5->43 6->11 6->16 6->23 6->45 6->48 7->14 8->34 9->41 12->1 12->1 12->1 12->13 12->18 12->31 12->59 13->4 13->5 13->6 13->7 13->8 13->9 13->10 13->11 13->14 13->15 13->16 13->17 13->19 13->22 13->23 13->50 13->51 13->52 13->53 13->54 13->55 13->56 13->57 13->58 13->61 14->14 14->15 14->20 14->21 14->33 14->38 14->40 14->42 14->43 14->44 14->46 14->47 14->48 14->49 14->62 14->68 14->73 14->74 14->79 14->80 15->16 15->24 15->24 15->25 15->34 15->35 15->63 15->64 15->69 15->70 15->71 15->77 15->78 16->17 16->17 16->26 16->65 16->72 17->27 17->37 18->1 19->1 20->21 21->14 22->8 22->8 22->10 22->15 22->23 23->9 23->9 23->11 23->16 23->17 27->1 28->1 28->1 28->12 28->12 28->29 28->29 28->30 28->31 29->1 29->1 29->12 29->12 29->22 29->30 29->31 30->18 31->4 31->5 31->6 31->13 31->13 31->14 31->32 31->32 31->60 31->66 31->67 32->5 32->6 32->7 32->13 32->13 32->14 33->38 33->39 33->40 33->43 33->44 33->45 33->46 33->48 33->75 33->76 33->81 33->82 33->83 33->84 33->86 33->87 36->27 37->1 39->20 40->10 40->15 40->22 40->39 40->43 41->37 42->33 42->33 43->14 43->47 43->85 43->88 45->20 46->11 46->16 46->23 46->45 46->48 48->14 48->49 48->89 48->90
>>>Token static ELAAXUPIJ * JLJXIHLOOBKESQGMVD ( ELAAXUPIJ * * MISH , MEINFDFPNPBWPJG CAWFMDXDKLBP ) { ELAAXUPIJ * AJKHV ; ELAAXUPIJ * PPLWV ; ELAAXUPIJ * RMLHPIWBQ , * BDQHPTHSG ; ELAAXUPIJ * UVVUFHFBYWNXS , * HKEOCONDIRIYB ; if ( MISH == NULL || CAWFMDXDKLBP == NULL ) { return NULL ; } if ( * MISH == NULL || ( * MISH ) -> XSIS == NULL ) { return * MISH ; } AJKHV = * MISH ; RMLHPIWBQ = NULL ; BDQHPTHSG = NULL ; PPLWV = ( * MISH ) -> XSIS ; while ( PPLWV != NULL ) { ELAAXUPIJ * XSIS = PPLWV -> XSIS ; if ( CAWFMDXDKLBP ( PPLWV -> CEOA , AJKHV -> CEOA ) < 0 ) { PPLWV -> BTJG = NULL ; PPLWV -> XSIS = RMLHPIWBQ ; if ( RMLHPIWBQ != NULL ) { RMLHPIWBQ -> BTJG = PPLWV ; } RMLHPIWBQ = PPLWV ; } else { PPLWV -> BTJG = NULL ; PPLWV -> XSIS = BDQHPTHSG ; if ( BDQHPTHSG != NULL ) { BDQHPTHSG -> BTJG = PPLWV ; } BDQHPTHSG = PPLWV ; } PPLWV = XSIS ; } UVVUFHFBYWNXS = JLJXIHLOOBKESQGMVD ( & RMLHPIWBQ , CAWFMDXDKLBP ) ; HKEOCONDIRIYB = JLJXIHLOOBKESQGMVD ( & BDQHPTHSG , CAWFMDXDKLBP ) ; * MISH = RMLHPIWBQ ; if ( RMLHPIWBQ == NULL ) { AJKHV -> BTJG = NULL ; * MISH = AJKHV ; } else { AJKHV -> BTJG = UVVUFHFBYWNXS ; UVVUFHFBYWNXS -> XSIS = AJKHV ; } AJKHV -> XSIS = BDQHPTHSG ; if ( BDQHPTHSG != NULL ) { BDQHPTHSG -> BTJG = AJKHV ; } if ( BDQHPTHSG == NULL ) { return AJKHV ; } else { return HKEOCONDIRIYB ; } }
>>>Func
METHOD EXCPO
METHOD_RETURN char
PARAM char KXI [ 29 ] [ 2 ]
PARAM int D
PARAM char BVVEQRW [ 101 ]
PARAM int k
PARAM char PVJ
<operator>.assignment VSN = '0'
RETURN return 0 ; return 0 ;
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.equals VSN == '0'
<operator>.lessThan i < k
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.equals KXI [ i ] [ 0 ] == PVJ
RETURN return 0 ; return 0 ;
<operator>.assignment i = 0
<operator>.equals BVVEQRW [ i ] == VSN
<operator>.assignment VSN = KXI [ i ] [ 1 ]
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
LITERAL 1 return 1 ;
<operator>.equals KXI [ i ] [ 1 ] == PVJ
<operator>.assignment VSN = KXI [ i ] [ 0 ]
<operator>.indirectIndexAccess KXI [ i ] [ 0 ]
<operator>.indirectIndexAccess BVVEQRW [ i ]
<operator>.indirectIndexAccess KXI [ i ]
<operator>.indirectIndexAccess KXI [ i ] [ 1 ]
<operator>.indirectIndexAccess KXI [ i ]
<operator>.indirectIndexAccess KXI [ i ] [ 1 ]
<operator>.indirectIndexAccess KXI [ i ]
<operator>.indirectIndexAccess KXI [ i ] [ 0 ]
<operator>.indirectIndexAccess KXI [ i ]
>>>PDG&35 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->21 0->22 0->23 0->24 2->1 3->9 4->1 4->19 5->1 5->12 6->1 6->16 7->1 7->11 8->1 9->1 9->1 9->1 9->9 9->10 9->10 9->16 9->26 9->28 10->1 10->9 11->1 11->1 11->12 11->17 11->18 11->19 12->8 12->13 12->19 12->27 13->12 14->8 15->1 15->9 16->1 16->1 16->1 16->20 16->24 16->24 16->25 16->29 16->30 16->31 16->32 17->1 18->12 19->12 19->13 19->22 20->1 20->1 20->11 21->17 22->1 23->22 24->1 24->1 24->1 24->16 24->20 24->25 24->33 24->34 25->1 25->1 25->11
>>>Token char EXCPO ( char KXI [ 29 ] [ 2 ] , int D , char BVVEQRW [ 101 ] , int k , char PVJ ) { int i ; char VSN = ' ' ; for ( i = 0 ; i < D ; i ++ ) if ( KXI [ i ] [ 0 ] == PVJ ) VSN = KXI [ i ] [ 1 ] ; else if ( KXI [ i ] [ 1 ] == PVJ ) VSN = KXI [ i ] [ 0 ] ; if ( VSN == ' ' ) return 0 ; for ( i = 0 ; i < k ; i ++ ) if ( BVVEQRW [ i ] == VSN ) return 1 ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment * XVAHQ = NULL
<operator>.assignment * CLTONW = NULL
<operator>.assignment XVAHQ = CYHHA ( argv [ 1 ] , "r" )
DKNQLW DKNQLW ( XVAHQ )
<operator>.assignment CLTONW = CYHHA ( "output.txt" , "w" )
DKNQLW DKNQLW ( CLTONW )
ATWLUB ATWLUB ( XVAHQ , "%d" , & SVIYTSKN )
<operator>.lessThan WDSF ( k , SVIYTSKN ) <QYORMJE
RXOQKL RXOQKL ( CLTONW )
RXOQKL RXOQKL ( XVAHQ )
RETURN return 0 ; return 0 ;
<operator>.notEquals argc != 2
LITERAL 0 return 0 ;
SSO SSO ( "Incorrect number of command line arguments, exiting...\n" )
RETURN return 1 ; return 1 ;
CYHHA CYHHA ( argv [ 1 ] , "r" )
CYHHA CYHHA ( "output.txt" , "w" )
WDSF WDSF ( k , SVIYTSKN )
LITERAL 1 return 1 ;
UNKNOWN E E
UNKNOWN ';'> { WDSF ( i , 26 ) <QYORMJE ';'> { WDSF ( j , 26 ) <QYORMJE ';'> { VRLFEA [ i ] [ j ] = 0 ; BAINJU [ i ] [ j ] = 0 ; } } HES ( "%d" , & LHWVBYHUPU ) ; WDSF ( i , LHWVBYHUPU ) <QYORMJE ';'> { HES ( "%*c%c%c%c" , & MRBQTCQCR [ 0 ] , & MRBQTCQCR [ 1 ] , & MRBQTCQCR [ 2 ] ) ; MRBQTCQCR [ 0 ] -= 65 ; MRBQTCQCR [ 1 ] -= 65 ; assert ( MRBQTCQCR [ 0 ] < 26 && MRBQTCQCR [ 0 ] >= 0 ) ; assert ( MRBQTCQCR [ 1 ] < 26 && MRBQTCQCR [ 1 ] >= 0 ) ; VRLFEA [ ( int ) MRBQTCQCR [ 0 ] ] [ ( int ) MRBQTCQCR [ 1 ] ] = MRBQTCQCR [ 2 ] ; VRLFEA [ ( int ) MRBQTCQCR [ 1 ] ] [ ( int ) MRBQTCQCR [ 0 ] ] = MRBQTCQCR [ 2 ] ; } HES ( "%d" , & TIQCHNWSDS ) ; WDSF ( i , TIQCHNWSDS ) <QYORMJE ';'> { HES ( "%*c%c%c" , & CYGMVEN [ 0 ] , & CYGMVEN [ 1 ] ) ; CYGMVEN [ 0 ] -= 65 ; CYGMVEN [ 1 ] -= 65 ; assert ( CYGMVEN [ 0 ] < 26 && CYGMVEN [ 0 ] >= 0 ) ; assert ( CYGMVEN [ 1 ] < 26 && CYGMVEN [ 1 ] >= 0 ) ; BAINJU [ ( int ) CYGMVEN [ 0 ] ] [ ( int ) CYGMVEN [ 1 ] ] = - 1 ; BAINJU [ ( int ) CYGMVEN [ 1 ] ] [ ( int ) CYGMVEN [ 0 ] ] = - 1 ; } HES ( "%d" , & WLINJDVCHEP ) ; FYVANNBG = <QYORMJE ';'> KECTEF ( <QYORMJE ';'> char , WLINJDVCHEP ) ; DKNQLW ( FYVANNBG ) ; HGAJAELGQHMEHB = <QYORMJE ';'> KECTEF ( <QYORMJE ';'> char , WLINJDVCHEP ) ; DKNQLW ( HGAJAELGQHMEHB ) ; HES ( "%*c" ) ; WDSF ( i , WLINJDVCHEP ) <QYORMJE ';'> { HES ( "%c" , & FYVANNBG [ i ] ) ; } NUK = 0 ; WDSF ( i , WLINJDVCHEP ) <QYORMJE ';'> { if ( NUK ) { if ( VRLFEA [ ( int ) HGAJAELGQHMEHB [ NUK - 1 ] - 65 ] [ ( int ) FYVANNBG [ i ] - 65 ] ) HGAJAELGQHMEHB [ NUK - 1 ] = VRLFEA [ ( int ) HGAJAELGQHMEHB [ NUK - 1 ] - 65 ] [ ( int ) FYVANNBG [ i ] - 65 ] ; else { WDSF ( j , NUK ) <QYORMJE ';'> { if ( BAINJU [ ( int ) HGAJAELGQHMEHB [ j ] - 65 ] [ ( int ) FYVANNBG [ i ] - 65 ] == - 1 ) { NUK = 0 ; } } if ( NUK ) { HGAJAELGQHMEHB [ NUK ] = FYVANNBG [ i ] ; NUK ++ ; } } } else { HGAJAELGQHMEHB [ 0 ] = FYVANNBG [ i ] ; NUK ++ ; } } GUXS ( "Case #%d: [" , k + 1 ) ; WDSF ( i , NUK - 1 ) <QYORMJE ';'> GUXS ( "%c, " , HGAJAELGQHMEHB [ i ] ) ; if ( NUK ) GUXS ( "%c" , HGAJAELGQHMEHB [ i ] ) ; GUXS ( "]\n" ) ; free ( FYVANNBG ) ; free ( HGAJAELGQHMEHB ) ; } ';'> { WDSF ( i , 26 ) <QYORMJE ';'> { WDSF ( j , 26 ) <QYORMJE ';'> { VRLFEA [ i ] [ j ] = 0 ; BAINJU [ i ] [ j ] = 0 ; } } HES ( "%d" , & LHWVBYHUPU ) ; WDSF ( i , LHWVBYHUPU ) <QYORMJE ';'> { HES ( "%*c%c%c%c" , & MRBQTCQCR [ 0 ] , & MRBQTCQCR [ 1 ] , & MRBQTCQCR [ 2 ] ) ; MRBQTCQCR [ 0 ] -= 65 ; MRBQTCQCR [ 1 ] -= 65 ; assert ( MRBQTCQCR [ 0 ] < 26 && MRBQTCQCR [ 0 ] >= 0 ) ; assert ( MRBQTCQCR [ 1 ] < 26 && MRBQTCQCR [ 1 ] >= 0 ) ; VRLFEA [ ( int ) MRBQTCQCR [ 0 ] ] [ ( int ) MRBQTCQCR [ 1 ] ] = MRBQTCQCR [ 2 ] ; VRLFEA [ ( int ) MRBQTCQCR [ 1 ] ] [ ( int ) MRBQTCQCR [ 0 ] ] = MRBQTCQCR [ 2 ] ; } HES ( "%d" , & TIQCHNWSDS ) ; WDSF ( i , TIQCHNWSDS ) <QYORMJE ';'> { HES ( "%*c%c%c" , & CYGMVEN [ 0 ] , & CYGMVEN [ 1 ] ) ; CYGMVEN [ 0 ] -= 65 ; CYGMVEN [ 1 ] -= 65 ; assert ( CYGMVEN [ 0 ] < 26 && CYGMVEN [ 0 ] >= 0 ) ; assert ( CYGMVEN [ 1 ] < 26 && CYGMVEN [ 1 ] >= 0 ) ; BAINJU [ ( int ) CYGMVEN [ 0 ] ] [ ( int ) CYGMVEN [ 1 ] ] = - 1 ; BAINJU [ ( int ) CYGMVEN [ 1 ] ] [ ( int ) CYGMVEN [ 0 ] ] = - 1 ; } HES ( "%d" , & WLINJDVCHEP ) ; FYVANNBG = <QYORMJE ';'> KECTEF ( <QYORMJE ';'> char , WLINJDVCHEP ) ; DKNQLW ( FYVANNBG ) ; HGAJAELGQHMEHB = <QYORMJE ';'> KECTEF ( <QYORMJE ';'> char , WLINJDVCHEP ) ; DKNQLW ( HGAJAELGQHMEHB ) ; HES ( "%*c" ) ; WDSF ( i , WLINJDVCHEP ) <QYORMJE ';'> { HES ( "%c" , & FYVANNBG [ i ] ) ; } NUK = 0 ; WDSF ( i , WLINJDVCHEP ) <QYORMJE ';'> { if ( NUK ) { if ( VRLFEA [ ( int ) HGAJAELGQHMEHB [ NUK - 1 ] - 65 ] [ ( int ) FYVANNBG [ i ] - 65 ] ) HGAJAELGQHMEHB [ NUK - 1 ] = VRLFEA [ ( int ) HGAJAELGQHMEHB [ NUK - 1 ] - 65 ] [ ( int ) FYVANNBG [ i ] - 65 ] ; else { WDSF ( j , NUK ) <QYORMJE ';'> { if ( BAINJU [ ( int ) HGAJAELGQHMEHB [ j ] - 65 ] [ ( int ) FYVANNBG [ i ] - 65 ] == - 1 ) { NUK = 0 ; } } if ( NUK ) { HGAJAELGQHMEHB [ NUK ] = FYVANNBG [ i ] ; NUK ++ ; } } } else { HGAJAELGQHMEHB [ 0 ] = FYVANNBG [ i ] ; NUK ++ ; } } GUXS ( "Case #%d: [" , k + 1 ) ; WDSF ( i , NUK - 1 ) <QYORMJE ';'> GUXS ( "%c, " , HGAJAELGQHMEHB [ i ] ) ; if ( NUK ) GUXS ( "%c" , HGAJAELGQHMEHB [ i ] ) ; GUXS ( "]\n" ) ; free ( FYVANNBG ) ; free ( HGAJAELGQHMEHB ) ; }
<operator>.addressOf & SVIYTSKN
<operator>.indirectIndexAccess argv [ 1 ]
>>>PDG&27 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 2->15 3->1 3->19 4->1 4->1 5->1 5->1 5->1 6->7 7->10 8->9 9->12 10->13 10->21 11->1 14->1 15->1 15->1 15->6 15->7 15->8 15->9 15->10 15->11 15->12 15->13 15->14 15->17 15->18 15->19 15->20 15->21 15->23 15->24 15->25 15->26 16->14 17->1 18->1 19->6 19->6 20->8 20->8 21->11 21->11 22->18
>>>Token int main ( int argc , char * argv [ ] ) { GLJJ * XVAHQ = NULL ; GLJJ * CLTONW = NULL ; int i , j , k ; int SVIYTSKN ; signed char VRLFEA [ 26 ] [ 26 ] ; int BAINJU [ 26 ] [ 26 ] ; int LHWVBYHUPU ; int TIQCHNWSDS ; char MRBQTCQCR [ 3 ] ; char CYGMVEN [ 2 ] ; int WLINJDVCHEP ; char * FYVANNBG ; char * HGAJAELGQHMEHB ; int NUK ; if ( argc != 2 ) { SSO ( " \n " ) ; return 1 ; } XVAHQ = CYHHA ( argv [ 1 ] , " " ) ; DKNQLW ( XVAHQ ) ; CLTONW = CYHHA ( " " , " " ) ; DKNQLW ( CLTONW ) ; ATWLUB ( XVAHQ , " " , & SVIYTSKN ) ; WDSF ( k , SVIYTSKN ) < QYORMJE ' ; ' { WDSF ( i , 26 ) < QYORMJE ' ; ' { WDSF ( j , 26 ) < QYORMJE ' ; ' { VRLFEA [ i ] [ j ] = 0 ; BAINJU [ i ] [ j ] = 0 ; } } HES ( " " , & LHWVBYHUPU ) ; WDSF ( i , LHWVBYHUPU ) < QYORMJE ' ; ' { HES ( " " , & MRBQTCQCR [ 0 ] , & MRBQTCQCR [ 1 ] , & MRBQTCQCR [ 2 ] ) ; MRBQTCQCR [ 0 ] -= 65 ; MRBQTCQCR [ 1 ] -= 65 ; assert ( MRBQTCQCR [ 0 ] < 26 && MRBQTCQCR [ 0 ] >= 0 ) ; assert ( MRBQTCQCR [ 1 ] < 26 && MRBQTCQCR [ 1 ] >= 0 ) ; VRLFEA [ ( int ) MRBQTCQCR [ 0 ] ] [ ( int ) MRBQTCQCR [ 1 ] ] = MRBQTCQCR [ 2 ] ; VRLFEA [ ( int ) MRBQTCQCR [ 1 ] ] [ ( int ) MRBQTCQCR [ 0 ] ] = MRBQTCQCR [ 2 ] ; } HES ( " " , & TIQCHNWSDS ) ; WDSF ( i , TIQCHNWSDS ) < QYORMJE ' ; ' { HES ( " " , & CYGMVEN [ 0 ] , & CYGMVEN [ 1 ] ) ; CYGMVEN [ 0 ] -= 65 ; CYGMVEN [ 1 ] -= 65 ; assert ( CYGMVEN [ 0 ] < 26 && CYGMVEN [ 0 ] >= 0 ) ; assert ( CYGMVEN [ 1 ] < 26 && CYGMVEN [ 1 ] >= 0 ) ; BAINJU [ ( int ) CYGMVEN [ 0 ] ] [ ( int ) CYGMVEN [ 1 ] ] = - 1 ; BAINJU [ ( int ) CYGMVEN [ 1 ] ] [ ( int ) CYGMVEN [ 0 ] ] = - 1 ; } HES ( " " , & WLINJDVCHEP ) ; FYVANNBG = < QYORMJE ' ' > KECTEF ( < QYORMJE ' ' > char , WLINJDVCHEP ) ; DKNQLW ( FYVANNBG ) ; HGAJAELGQHMEHB = < QYORMJE ' ' > KECTEF ( < QYORMJE ' ' > char , WLINJDVCHEP ) ; DKNQLW ( HGAJAELGQHMEHB ) ; HES ( " " ) ; WDSF ( i , WLINJDVCHEP ) < QYORMJE ' ; ' { HES ( " " , & FYVANNBG [ i ] ) ; } NUK = 0 ; WDSF ( i , WLINJDVCHEP ) < QYORMJE ' ; ' { if ( NUK ) { if ( VRLFEA [ ( int ) HGAJAELGQHMEHB [ NUK - 1 ] - 65 ] [ ( int ) FYVANNBG [ i ] - 65 ] ) HGAJAELGQHMEHB [ NUK - 1 ] = VRLFEA [ ( int ) HGAJAELGQHMEHB [ NUK - 1 ] - 65 ] [ ( int ) FYVANNBG [ i ] - 65 ] ; else { WDSF ( j , NUK ) < QYORMJE ' ; ' { if ( BAINJU [ ( int ) HGAJAELGQHMEHB [ j ] - 65 ] [ ( int ) FYVANNBG [ i ] - 65 ] == - 1 ) { NUK = 0 ; } } if ( NUK ) { HGAJAELGQHMEHB [ NUK ] = FYVANNBG [ i ] ; NUK ++ ; } } } else { HGAJAELGQHMEHB [ 0 ] = FYVANNBG [ i ] ; NUK ++ ; } } GUXS ( " " , k + 1 ) ; WDSF ( i , NUK - 1 ) < QYORMJE ' ' > GUXS ( " " , HGAJAELGQHMEHB [ i ] ) ; if ( NUK ) GUXS ( " " , HGAJAELGQHMEHB [ i ] ) ; GUXS ( " \n " ) ; free ( FYVANNBG ) ; free ( HGAJAELGQHMEHB ) ; } RXOQKL ( CLTONW ) ; RXOQKL ( XVAHQ ) ; return 0 ; }
>>>Func
METHOD RHSEVHNHWGWYICPDXXPRIQMTJ
METHOD_RETURN void
PARAM char UGMHTXBBS
PARAM int HYAXHWGGXOINT [ 9 ] [ 9 ]
PARAM int INLBWDPSMKABUVBXATIYT [ 9 ] [ 9 ]
<operator>.assignment GISMORBA = HWKVJLSO [ UGMHTXBBS - 'A' ]
<operator>.lessThan i < 8
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignmentMinus INLBWDPSMKABUVBXATIYT [ GISMORBA ] [ i ] -= HYAXHWGGXOINT [ GISMORBA ] [ i ]
<operator>.subtraction UGMHTXBBS - 'A'
<operator>.indirectIndexAccess INLBWDPSMKABUVBXATIYT [ GISMORBA ] [ i ]
<operator>.indirectIndexAccess HYAXHWGGXOINT [ GISMORBA ] [ i ]
<operator>.indirectIndexAccess INLBWDPSMKABUVBXATIYT [ GISMORBA ]
<operator>.indirectIndexAccess HYAXHWGGXOINT [ GISMORBA ]
>>>PDG&15 0->2 0->3 0->4 0->6 0->7 0->8 0->10 2->10 3->1 4->1 5->1 5->1 5->1 6->1 6->1 6->6 6->7 6->7 6->9 6->11 6->12 6->13 6->14 7->1 7->6 8->1 8->6 10->1
>>>Token static void RHSEVHNHWGWYICPDXXPRIQMTJ ( char UGMHTXBBS , int HYAXHWGGXOINT [ 9 ] [ 9 ] , int INLBWDPSMKABUVBXATIYT [ 9 ] [ 9 ] ) { int i ; int GISMORBA = HWKVJLSO [ UGMHTXBBS - ' ' ] ; for ( i = 0 ; i < 8 ; i ++ ) { INLBWDPSMKABUVBXATIYT [ GISMORBA ] [ i ] -= HYAXHWGGXOINT [ GISMORBA ] [ i ] ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment * fp = NULL
<operator>.assignment VHNHWGWYICPDXX = 0
<operator>.assignment fp = AHWKV ( argv [ 1 ] , "r" )
JLSOBL JLSOBL ( fp , "%d\n" , & VHNHWGWYICPDXX )
<operator>.lessThan argc < 2
<operator>.equals NULL == fp
<operator>.lessEqualsThan i <= VHNHWGWYICPDXX
<operator>.postIncrement i ++
fprintf fprintf ( stderr , "Dude, pass a filename\n" )
RETURN return - 1 ; return - 1 ;
AHWKV AHWKV ( argv [ 1 ] , "r" )
fprintf fprintf ( stderr , "Dude, pass a VALID file\n" )
RETURN return - 1 ; return - 1 ;
<operator>.assignment i = 1
memset memset ( NLBWDPSMKABUVB   0   sizeof ( NLBWDPSMKABUVB ) )
memset memset ( XATIYTGISMORB   0   sizeof ( XATIYTGISMORB ) )
DONELMFLMBTNWAYPMNJPPRPBNY DONELMFLMBTNWAYPMNJPPRPBNY ( fp , NLBWDPSMKABUVB , XATIYTGISMORB )
OINSTSHKWUWEGLFDYCDXT OINSTSHKWUWEGLFDYCDXT ( fp , NLBWDPSMKABUVB , XATIYTGISMORB , MHTXBBSH , & PRIQMTJUG )
printf printf ( "Case #%d: [" , i )
printf printf ( "]\n" )
<operator>.minus - 1
<operator>.minus - 1
<operator>.lessThan j < PRIQMTJUG
<operator>.postIncrement j ++
<operator>.assignment j = 0
printf printf ( "%c" , MHTXBBSH [ j ] )
<operator>.greaterThan j > 0
printf printf ( ", " )
<operator>.addressOf & VHNHWGWYICPDXX
<operator>.indirectIndexAccess argv [ 1 ]
<operator>.sizeOf sizeof ( NLBWDPSMKABUVB )
<operator>.sizeOf sizeof ( XATIYTGISMORB )
<operator>.addressOf & PRIQMTJUG
<operator>.indirectIndexAccess MHTXBBSH [ j ]
>>>PDG&38 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->8 3->1 3->14 4->1 4->1 4->1 5->1 5->1 5->7 5->10 6->9 7->10 7->20 8->1 8->1 8->6 8->9 8->12 8->13 8->14 8->24 8->33 9->7 9->7 9->10 9->15 9->16 9->17 9->25 9->32 10->10 10->11 10->18 10->19 10->20 10->21 10->22 10->22 10->23 10->26 10->28 10->34 10->35 10->36 11->10 12->1 12->1 13->1 14->6 14->6 16->1 17->10 18->20 19->20 20->21 20->21 20->21 21->20 21->26 21->29 22->11 24->1 24->13 25->16 26->21 26->26 26->27 26->29 26->30 26->30 26->37 27->26 28->26 29->21 30->27 30->31
>>>Token int main ( int argc , char * argv [ ] ) { RHSE * fp = NULL ; int VHNHWGWYICPDXX = 0 ; int PRIQMTJUG ; int i , j ; char MHTXBBSH [ YAXHWGGXOINTI + 300 ] ; char NLBWDPSMKABUVB [ 9 ] [ 9 ] ; int XATIYTGISMORB [ 9 ] [ 9 ] ; if ( argc < 2 ) { fprintf ( stderr , " \n " ) ; return - 1 ; } fp = AHWKV ( argv [ 1 ] , " " ) ; if ( NULL == fp ) { fprintf ( stderr , " \n " ) ; return - 1 ; } JLSOBL ( fp , " \n " , & VHNHWGWYICPDXX ) ; for ( i = 1 ; i <= VHNHWGWYICPDXX ; i ++ ) { memset ( NLBWDPSMKABUVB , 0 , sizeof ( NLBWDPSMKABUVB ) ) ; memset ( XATIYTGISMORB , 0 , sizeof ( XATIYTGISMORB ) ) ; DONELMFLMBTNWAYPMNJPPRPBNY ( fp , NLBWDPSMKABUVB , XATIYTGISMORB ) ; OINSTSHKWUWEGLFDYCDXT ( fp , NLBWDPSMKABUVB , XATIYTGISMORB , MHTXBBSH , & PRIQMTJUG ) ; printf ( " " , i ) ; for ( j = 0 ; j < PRIQMTJUG ; j ++ ) { if ( j > 0 ) { printf ( " " ) ; } printf ( " " , MHTXBBSH [ j ] ) ; } printf ( " \n " ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
TJJKE TJJKE ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan iT < T
<operator>.postIncrement iT ++
LITERAL 0 return 0 ;
<operator>.assignment iT = 0
TJJKE TJJKE ( "%d %d" , & N , & M )
memset memset ( b   0   sizeof ( b ) )
<operator>.assignment cc = 0
<operator>.assignment BJRLSCRV = N
<operator>.assignment YJR = 0
<operator>.assignment AAILV = 1
printf printf ( "Case #%d: %d\n" , iT + 1 , YJR )
printf printf ( "\n" )
<operator>.lessThan i < M
<operator>.postIncrement i ++
<operator>.lessThan i < M
<operator>.postIncrement i ++
<operator>.lessThan i < M
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.assignmentMultiplication AAILV *= N
<operator>.lessThan i < AAILV
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.assignment i = 0
TJJKE TJJKE ( "%d"   & ( a [ i ] . a ) )
<operator>.postDecrement ( a [ i ] . a ) --
<operator>.assignment i = 0
TJJKE TJJKE ( "%d"   & ( a [ i ] . b ) )
<operator>.postDecrement ( a [ i ] . b ) --
<operator>.assignment i = 0
<operator>.assignment b [ a [ i ] . a ] [ a [ i ] . b ] = 1
<operator>.assignment b [ a [ i ] . b ] [ a [ i ] . a ] = 1
<operator>.assignment i = 0
<operator>.assignment b [ i ] [ ( i - 1 + N ) % N ] = 1
<operator>.assignment b [ i ] [ ( i + 1 ) % N ] = 1
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment EBLV = ( i - 1 + N ) % N
<operator>.assignment j = ( i + 1 ) % N
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment k = i
memset memset ( b2   0   sizeof ( b2 ) )
<operator>.assignment j = 0
<operator>.assignment k = j + 1
<operator>.assignment GKBD = 1
<operator>.addition iT + 1
<operator>.assignment i = 0
printf printf ( "%d" , YCWU [ i ] + 1 )
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.notEquals j != EBLV
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.postIncrement j ++
<operator>.lessThan k < 8
<operator>.lessThan k < 8
<operator>.lessThan l < cc
<operator>.postIncrement l ++
IDENTIFIER GKBD if (GKBD)
IDENTIFIER i if (i)
<operator>.assignment j = 0
<operator>.assignment p [ i ] [ j ] = - 1
<operator>.modulo ( i - 1 + N ) % N
<operator>.modulo ( i + 1 ) % N
<operator>.assignment k = j
<operator>.assignment p [ j ] [ i ] = k
<operator>.assignment j = k
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment XFO [ j ] = k % N
<operator>.assignmentDivision k /= N
<operator>.assignment b2 [ XFO [ j ] ] = 1
<operator>.addition j + 1
<operator>.postIncrement k ++
<operator>.assignment l = 0
memset memset ( b2   0   sizeof ( b2 ) )
<operator>.assignment k = 0
printf printf ( " " )
<operator>.addition YCWU [ i ] + 1
<operator>.modulo ( i - 1 + N ) % N
<operator>.modulo ( i + 1 ) % N
<operator>.addition i - 1 + N
<operator>.addition i + 1
<operator>.equals b [ i ] [ k ] == 0
<operator>.notEquals p [ i ] [ j ] != - 1
<operator>.lessThan k < c [ l ] . YHP
<operator>.postIncrement k ++
<operator>.lessThan k < j
<operator>.notEquals k != j
<operator>.greaterThan j > YJR
<operator>.addition i - 1 + N
<operator>.addition i + 1
<operator>.minus - 1
<operator>.subtraction i - 1
<operator>.assignment k = ( k + 1 ) % N
<operator>.assignment c [ cc ] . YHP = 0
<operator>.assignment x = i
<operator>.assignment y = j
<operator>.postIncrement cc ++
<operator>.modulo k % N
<operator>.assignment k = 0
<operator>.assignment b2 [ XFO [ c [ l ] . a [ k ] ] ] = 1
<operator>.postIncrement k ++
<operator>.assignment GKBD = 0
<operator>.assignment YJR = j
memcpy memcpy ( YCWU   XFO   sizeof ( XFO ) )
<operator>.subtraction i - 1
<operator>.minus - 1
<operator>.logicalOr ( x != i ) || ( y != j )
<operator>.lessThan c [ cc ] . YHP < BJRLSCRV
<operator>.equals b2 [ k ] == 0
<operator>.equals YJR == BJRLSCRV
<operator>.modulo ( k + 1 ) % N
<operator>.assignment c [ cc ] . a [ c [ cc ] . YHP ] = x
<operator>.postIncrement ( c [ cc ] . YHP ) ++
<operator>.assignment z = p [ x ] [ y ]
<operator>.assignment p [ x ] [ y ] = - 1
<operator>.assignment x = y
<operator>.assignment y = z
<operator>.assignment BJRLSCRV = c [ cc ] . YHP
<operator>.addition k + 1
<operator>.notEquals x != i
<operator>.notEquals y != j
<operator>.minus - 1
<operator>.addressOf & N
<operator>.addressOf & M
<operator>.sizeOf sizeof ( b )
<operator>.addressOf & ( a [ i ] . a )
<operator>.fieldAccess a [ i ] . a
<operator>.addressOf & ( a [ i ] . b )
<operator>.fieldAccess a [ i ] . b
<operator>.indirectIndexAccess b [ a [ i ] . a ] [ a [ i ] . b ]
<operator>.indirectIndexAccess b [ a [ i ] . b ] [ a [ i ] . a ]
<operator>.indirectIndexAccess b [ i ] [ ( i - 1 + N ) % N ]
<operator>.indirectIndexAccess b [ i ] [ ( i + 1 ) % N ]
<operator>.sizeOf sizeof ( b2 )
<operator>.indirectIndexAccess b2 [ j ]
<operator>.fieldAccess a [ i ] . a
<operator>.indirectIndexAccess a [ i ]
FIELD_IDENTIFIER a a
<operator>.fieldAccess a [ i ] . b
<operator>.indirectIndexAccess a [ i ]
FIELD_IDENTIFIER b b
<operator>.indirectIndexAccess b [ a [ i ] . a ]
<operator>.fieldAccess a [ i ] . b
<operator>.indirectIndexAccess b [ a [ i ] . b ]
<operator>.fieldAccess a [ i ] . a
<operator>.indirectIndexAccess b [ i ]
<operator>.indirectIndexAccess b [ i ]
<operator>.indirectIndexAccess YCWU [ i ]
<operator>.indirectIndexAccess a [ i ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess a [ i ]
FIELD_IDENTIFIER b b
<operator>.fieldAccess a [ i ] . a
<operator>.indirectIndexAccess a [ i ]
FIELD_IDENTIFIER b b
<operator>.fieldAccess a [ i ] . b
<operator>.indirectIndexAccess a [ i ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess p [ i ] [ j ]
<operator>.indirectIndexAccess p [ j ] [ i ]
<operator>.indirectIndexAccess XFO [ j ]
<operator>.indirectIndexAccess b2 [ XFO [ j ] ]
<operator>.indirectIndexAccess b2 [ k ]
<operator>.sizeOf sizeof ( b2 )
<operator>.indirectIndexAccess a [ i ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess a [ i ]
FIELD_IDENTIFIER b b
<operator>.indirectIndexAccess p [ i ]
<operator>.indirectIndexAccess b [ i ] [ k ]
<operator>.indirectIndexAccess p [ j ]
<operator>.indirectIndexAccess p [ i ] [ j ]
<operator>.indirectIndexAccess XFO [ j ]
<operator>.fieldAccess c [ l ] . YHP
<operator>.indirectIndexAccess b [ i ]
<operator>.indirectIndexAccess p [ i ]
<operator>.fieldAccess c [ cc ] . YHP
<operator>.indirectIndexAccess c [ l ]
FIELD_IDENTIFIER YHP YHP
<operator>.indirectIndexAccess b2 [ XFO [ c [ l ] . a [ k ] ] ]
<operator>.sizeOf sizeof ( XFO )
<operator>.indirectIndexAccess c [ cc ]
FIELD_IDENTIFIER YHP YHP
<operator>.fieldAccess c [ cc ] . YHP
<operator>.indirectIndexAccess XFO [ c [ l ] . a [ k ] ]
<operator>.indirectIndexAccess b2 [ k ]
<operator>.indirectIndexAccess c [ cc ] . a [ c [ cc ] . YHP ]
<operator>.fieldAccess c [ cc ] . YHP
<operator>.indirectIndexAccess p [ x ] [ y ]
<operator>.indirectIndexAccess p [ x ] [ y ]
<operator>.indirectIndexAccess c [ cc ]
FIELD_IDENTIFIER YHP YHP
<operator>.fieldAccess c [ cc ] . YHP
<operator>.indirectIndexAccess c [ l ] . a [ k ]
<operator>.fieldAccess c [ cc ] . a
<operator>.fieldAccess c [ cc ] . YHP
<operator>.indirectIndexAccess c [ cc ]
FIELD_IDENTIFIER YHP YHP
<operator>.indirectIndexAccess p [ x ]
<operator>.indirectIndexAccess p [ x ]
<operator>.indirectIndexAccess c [ cc ]
FIELD_IDENTIFIER YHP YHP
<operator>.fieldAccess c [ l ] . a
<operator>.indirectIndexAccess c [ cc ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess c [ cc ]
FIELD_IDENTIFIER YHP YHP
<operator>.indirectIndexAccess c [ l ]
FIELD_IDENTIFIER a a
>>>PDG&229 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->127 0->128 0->129 0->130 0->131 0->135 0->136 0->138 0->139 0->140 0->141 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->14 4->15 4->16 4->18 4->20 4->22 4->24 4->26 4->28 4->30 4->33 4->35 4->37 4->40 4->43 4->46 4->49 4->50 4->53 4->54 4->55 4->61 4->61 4->62 4->142 4->143 4->144 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->11 8->16 8->18 8->20 8->22 8->24 8->26 8->28 8->30 8->32 8->35 8->64 8->67 8->69 8->80 8->81 8->88 8->97 8->98 8->99 8->108 8->117 8->130 9->1 9->1 10->1 10->1 10->74 10->116 11->1 11->1 11->127 11->129 12->1 12->14 12->107 13->1 13->32 13->33 14->1 14->1 14->1 15->1 16->16 16->17 16->17 16->18 16->38 16->39 16->145 16->146 16->155 16->156 16->157 16->168 16->169 17->1 17->16 18->18 18->19 18->19 18->20 18->41 18->42 18->147 18->148 18->158 18->159 18->160 18->170 18->171 19->1 19->18 20->1 20->1 20->8 20->16 20->20 20->21 20->21 20->44 20->45 20->149 20->150 20->161 20->162 20->163 20->164 20->172 20->173 20->174 20->175 20->176 20->177 20->184 20->185 20->186 20->187 21->1 21->20 22->22 22->23 22->24 22->47 22->48 22->97 22->97 22->98 22->108 22->108 22->109 22->124 22->124 22->151 22->152 22->165 22->166 23->1 23->22 24->24 24->25 24->25 24->26 24->64 24->64 24->78 25->1 25->24 26->11 26->26 26->27 26->28 26->51 26->52 26->66 26->80 26->80 26->81 26->99 26->99 26->100 26->111 26->111 27->1 27->26 28->28 28->29 28->29 28->30 28->67 28->67 28->85 28->114 28->139 29->1 29->28 30->30 30->31 30->31 30->32 30->32 30->35 30->69 31->1 31->30 32->1 32->33 33->1 33->1 33->34 33->56 33->56 33->57 33->58 33->59 33->69 33->72 33->73 33->86 33->90 33->153 33->154 34->1 34->33 35->1 35->1 35->1 35->8 35->22 35->35 35->36 35->36 35->63 35->95 35->96 35->167 36->1 36->35 37->16 38->1 38->1 38->39 39->1 40->18 41->1 41->1 41->42 42->1 43->20 44->1 44->1 45->1 45->1 46->22 47->1 47->1 48->1 48->1 49->24 50->26 51->1 51->1 51->66 52->1 52->1 52->66 53->28 54->30 55->33 56->1 56->117 57->1 57->1 58->1 58->59 58->71 58->90 58->105 58->107 59->1 59->1 59->72 60->1 60->1 62->1 62->35 63->1 63->1 64->1 64->1 64->24 64->64 64->65 64->65 64->79 64->110 64->178 64->188 65->1 65->64 66->1 66->1 66->1 66->66 66->82 66->82 66->83 66->84 66->101 66->112 66->130 66->138 66->179 66->189 66->190 66->194 67->1 67->1 67->28 67->67 67->68 67->68 67->102 67->115 67->125 67->140 67->191 67->195 68->1 68->67 69->1 69->35 69->69 69->70 69->70 69->87 69->88 69->89 69->117 69->117 69->180 69->181 69->192 70->1 70->69 71->1 71->59 71->90 71->105 71->107 72->73 72->91 72->182 73->1 73->1 73->33 73->34 73->60 73->74 73->92 73->107 74->1 74->1 74->1 74->75 74->93 74->94 74->103 74->105 74->106 74->118 74->183 74->193 74->197 74->198 75->1 75->74 78->1 78->64 79->1 79->1 79->1 79->102 80->1 80->51 80->51 80->81 81->1 81->26 81->52 81->52 81->130 82->1 82->130 82->138 83->1 83->1 84->1 84->1 84->66 85->1 85->67 86->69 87->1 87->1 87->1 87->123 88->1 88->117 89->1 89->1 89->57 89->93 90->1 91->1 91->72 92->1 92->74 93->1 93->1 93->128 94->1 94->105 95->1 96->1 97->1 97->98 98->1 98->22 99->1 101->1 101->1 101->101 101->112 101->130 101->138 101->189 101->194 102->1 102->1 102->1 102->113 102->114 102->115 102->116 102->126 102->127 102->131 102->132 102->133 102->134 102->135 102->136 102->139 102->141 102->196 102->201 102->202 102->203 102->206 102->207 102->208 102->209 102->210 102->211 102->214 102->215 102->216 102->217 102->218 102->219 102->223 102->224 102->225 102->226 103->1 103->1 103->103 103->104 103->104 103->119 103->193 103->197 103->198 103->199 103->204 103->213 103->222 103->227 103->228 104->1 104->103 105->1 105->106 105->106 105->120 105->128 105->205 106->1 106->1 106->1 106->74 106->75 106->105 106->107 106->121 107->1 107->1 107->14 107->33 107->34 107->122 107->122 107->123 107->129 107->200 108->1 110->79 111->27 111->80 111->80 111->81 111->99 111->99 111->100 112->1 112->1 112->83 112->84 112->130 112->138 113->1 113->132 114->1 114->131 115->1 115->135 116->1 116->1 116->74 117->69 117->87 117->87 117->88 117->88 118->103 119->1 119->1 119->57 119->93 120->1 120->105 121->1 121->1 122->1 122->1 122->129 123->1 123->1 123->1 123->63 123->96 124->23 124->97 124->97 124->98 124->108 124->108 124->109 125->102 126->1 126->1 126->1 126->126 126->131 126->132 126->133 126->134 126->135 126->136 126->139 126->141 126->206 126->207 126->208 126->209 126->214 126->215 126->216 126->217 126->218 126->219 126->223 126->224 126->225 126->226 127->1 127->1 127->129 127->137 127->137 127->212 127->220 127->221 128->1 128->1 128->57 128->93 128->105 128->120 129->1 129->1 129->14 129->33 129->34 129->107 130->1 130->26 130->112 130->112 131->1 131->1 132->1 132->127 133->1 133->136 134->1 134->1 134->1 134->133 135->1 135->139 136->1 136->1 136->1 136->135 136->140 137->1 137->1 137->127 137->129 139->1 139->29 139->114 139->126 139->126 139->131 139->140 140->1 140->68 140->126 140->126 140->135 141->134 154->71 154->154 182->72 182->91
>>>Token int main ( ) { int T , iT ; TJJKE ( " " , & T ) ; static struct BTNQ a [ AYCB ] ; static char b [ AYCB ] [ AYCB ] ; static int p [ AYCB ] [ AYCB ] ; static struct QQJTU c [ AYCB ] ; static int YCWU [ 10 ] ; static int XFO [ 10 ] ; static char b2 [ 10 ] ; int cc ; for ( iT = 0 ; iT < T ; iT ++ ) { int N , M ; TJJKE ( " " , & N , & M ) ; int i ; for ( i = 0 ; i < M ; i ++ ) { TJJKE ( " " , & ( a [ i ] . a ) ) ; ( a [ i ] . a ) -- ; } for ( i = 0 ; i < M ; i ++ ) { TJJKE ( " " , & ( a [ i ] . b ) ) ; ( a [ i ] . b ) -- ; } memset ( b , 0 , sizeof ( b ) ) ; for ( i = 0 ; i < M ; i ++ ) { b [ a [ i ] . a ] [ a [ i ] . b ] = 1 ; b [ a [ i ] . b ] [ a [ i ] . a ] = 1 ; } for ( i = 0 ; i < N ; i ++ ) { b [ i ] [ ( i - 1 + N ) % N ] = 1 ; b [ i ] [ ( i + 1 ) % N ] = 1 ; } int j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { p [ i ] [ j ] = - 1 ; } } int k , EBLV ; for ( i = 0 ; i < N ; i ++ ) { EBLV = ( i - 1 + N ) % N ; j = ( i + 1 ) % N ; while ( j != EBLV ) { k = j ; do { k = ( k + 1 ) % N ; } while ( b [ i ] [ k ] == 0 ) ; p [ j ] [ i ] = k ; j = k ; } } cc = 0 ; int BJRLSCRV = N ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( p [ i ] [ j ] != - 1 ) { c [ cc ] . YHP = 0 ; int x , y , z ; x = i ; y = j ; do { c [ cc ] . a [ c [ cc ] . YHP ] = x ; ( c [ cc ] . YHP ) ++ ; z = p [ x ] [ y ] ; p [ x ] [ y ] = - 1 ; x = y ; y = z ; } while ( ( x != i ) || ( y != j ) ) ; if ( c [ cc ] . YHP < BJRLSCRV ) BJRLSCRV = c [ cc ] . YHP ; cc ++ ; } } } int YJR = 0 ; int AAILV = 1 ; for ( i = 0 ; i < N ; i ++ ) AAILV *= N ; for ( i = 0 ; i < AAILV ; i ++ ) { k = i ; memset ( b2 , 0 , sizeof ( b2 ) ) ; for ( j = 0 ; j < N ; j ++ ) { XFO [ j ] = k % N ; k /= N ; b2 [ XFO [ j ] ] = 1 ; } j = 0 ; while ( b2 [ j ] ) j ++ ; k = j + 1 ; while ( k < 8 ) { if ( b2 [ k ] ) break ; k ++ ; } if ( k < 8 ) continue ; int l ; char GKBD = 1 ; for ( l = 0 ; l < cc ; l ++ ) { memset ( b2 , 0 , sizeof ( b2 ) ) ; for ( k = 0 ; k < c [ l ] . YHP ; k ++ ) { b2 [ XFO [ c [ l ] . a [ k ] ] ] = 1 ; } k = 0 ; while ( k < j ) { if ( b2 [ k ] == 0 ) break ; k ++ ; } if ( k != j ) { GKBD = 0 ; break ; } } if ( GKBD ) { if ( j > YJR ) { YJR = j ; memcpy ( YCWU , XFO , sizeof ( XFO ) ) ; if ( YJR == BJRLSCRV ) break ; } } } printf ( " \n " , iT + 1 , YJR ) ; for ( i = 0 ; i < N ; i ++ ) { if ( i ) printf ( " " ) ; printf ( " " , YCWU [ i ] + 1 ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment c = ( char ) ROTBF ( stdin )
<operator>.assignment n = PTHDABN ( & c )
LIJHACX LIJHACX ( & c , '\n' )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.cast ( char ) ROTBF ( stdin )
PTHDABN PTHDABN ( & c )
<operator>.assignment i = 1
<operator>.assignment N = PTHDABN ( & c )
LIJHACX LIJHACX ( & c , ' ' )
<operator>.assignment A = ( long long ) PTHDABN ( & c )
LIJHACX LIJHACX ( & c , ' ' )
<operator>.assignment B = ( long long ) PTHDABN ( & c )
LIJHACX LIJHACX ( & c , ' ' )
<operator>.assignment C = ( long long ) PTHDABN ( & c )
LIJHACX LIJHACX ( & c , ' ' )
<operator>.assignment D = ( long long ) PTHDABN ( & c )
LIJHACX LIJHACX ( & c , ' ' )
<operator>.assignment X0 = ( long long ) PTHDABN ( & c )
LIJHACX LIJHACX ( & c , ' ' )
<operator>.assignment Y0 = ( long long ) PTHDABN ( & c )
LIJHACX LIJHACX ( & c , ' ' )
<operator>.assignment M = ( long long ) PTHDABN ( & c )
LIJHACX LIJHACX ( & c , '\n' )
<operator>.assignment GTKLH = ( struct TQYN * ) malloc ( sizeof ( struct TQYN ) * N )
<operator>.assignment GTKLH [ 0 ] . X = X0
<operator>.assignment GTKLH [ 0 ] . Y = Y0
<operator>.assignment BHIUROLGJO = 0
fprintf fprintf ( SBPOCS , "Case #%i: %i\n" , i , BHIUROLGJO )
CVJVXP CVJVXP ( SBPOCS )
free free ( GTKLH )
ROTBF ROTBF ( stdin )
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N - 2
<operator>.postIncrement j ++
PTHDABN PTHDABN ( & c )
<operator>.cast ( long long ) PTHDABN ( & c )
<operator>.cast ( long long ) PTHDABN ( & c )
<operator>.cast ( long long ) PTHDABN ( & c )
<operator>.cast ( long long ) PTHDABN ( & c )
<operator>.cast ( long long ) PTHDABN ( & c )
<operator>.cast ( long long ) PTHDABN ( & c )
<operator>.cast ( long long ) PTHDABN ( & c )
<operator>.cast ( struct TQYN * ) malloc ( sizeof ( struct TQYN ) * N )
<operator>.assignment j = 1
<operator>.assignment GTKLH [ j ] . X = ( A * GTKLH [ j - 1 ] . X + B ) % M
<operator>.assignment GTKLH [ j ] . Y = ( C * GTKLH [ j - 1 ] . Y + D ) % M
<operator>.assignment j = 0
PTHDABN PTHDABN ( & c )
PTHDABN PTHDABN ( & c )
PTHDABN PTHDABN ( & c )
PTHDABN PTHDABN ( & c )
PTHDABN PTHDABN ( & c )
PTHDABN PTHDABN ( & c )
PTHDABN PTHDABN ( & c )
malloc malloc ( sizeof ( struct TQYN ) * N )
<operator>.subtraction N - 2
<operator>.lessThan k < N - 1
<operator>.postIncrement k ++
<operator>.multiplication sizeof ( struct TQYN ) * N
<operator>.modulo ( A * GTKLH [ j - 1 ] . X + B ) % M
<operator>.modulo ( C * GTKLH [ j - 1 ] . Y + D ) % M
<operator>.assignment k = j + 1
<operator>.sizeOf sizeof ( struct TQYN )
<operator>.addition A * GTKLH [ j - 1 ] . X + B
<operator>.addition C * GTKLH [ j - 1 ] . Y + D
<operator>.subtraction N - 1
<operator>.lessThan l < N
<operator>.postIncrement l ++
<operator>.multiplication A * GTKLH [ j - 1 ] . X
<operator>.multiplication C * GTKLH [ j - 1 ] . Y
<operator>.addition j + 1
<operator>.assignment l = k + 1
<operator>.assignment X = ( double ) ( GTKLH [ j ] . X + GTKLH [ k ] . X + GTKLH [ l ] . X ) / 3.0
<operator>.assignment Y = ( double ) ( GTKLH [ j ] . Y + GTKLH [ k ] . Y + GTKLH [ l ] . Y ) / 3.0
<operator>.logicalAnd X == BEHGK ( X ) && Y == BEHGK ( Y )
<operator>.addition k + 1
<operator>.division ( double ) ( GTKLH [ j ] . X + GTKLH [ k ] . X + GTKLH [ l ] . X ) / 3.0
<operator>.division ( double ) ( GTKLH [ j ] . Y + GTKLH [ k ] . Y + GTKLH [ l ] . Y ) / 3.0
<operator>.postIncrement BHIUROLGJO ++
<operator>.subtraction j - 1
<operator>.subtraction j - 1
<operator>.cast ( double ) ( GTKLH [ j ] . X + GTKLH [ k ] . X + GTKLH [ l ] . X )
<operator>.cast ( double ) ( GTKLH [ j ] . Y + GTKLH [ k ] . Y + GTKLH [ l ] . Y )
<operator>.equals X == BEHGK ( X )
<operator>.equals Y == BEHGK ( Y )
<operator>.addition GTKLH [ j ] . X + GTKLH [ k ] . X + GTKLH [ l ] . X
<operator>.addition GTKLH [ j ] . Y + GTKLH [ k ] . Y + GTKLH [ l ] . Y
BEHGK BEHGK ( X )
BEHGK BEHGK ( Y )
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.fieldAccess GTKLH [ 0 ] . X
<operator>.fieldAccess GTKLH [ 0 ] . Y
<operator>.addressOf & c
UNKNOWN long long long long
UNKNOWN long long long long
UNKNOWN long long long long
UNKNOWN long long long long
UNKNOWN long long long long
UNKNOWN long long long long
UNKNOWN long long long long
UNKNOWN struct TQYN * struct TQYN *
<operator>.indirectIndexAccess GTKLH [ 0 ]
FIELD_IDENTIFIER X X
<operator>.indirectIndexAccess GTKLH [ 0 ]
FIELD_IDENTIFIER Y Y
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.addressOf & c
<operator>.fieldAccess GTKLH [ j ] . X
<operator>.fieldAccess GTKLH [ j ] . Y
<operator>.indirectIndexAccess GTKLH [ j ]
FIELD_IDENTIFIER X X
<operator>.indirectIndexAccess GTKLH [ j ]
FIELD_IDENTIFIER Y Y
<operator>.fieldAccess GTKLH [ j - 1 ] . X
<operator>.fieldAccess GTKLH [ j - 1 ] . Y
<operator>.indirectIndexAccess GTKLH [ j - 1 ]
FIELD_IDENTIFIER X X
<operator>.indirectIndexAccess GTKLH [ j - 1 ]
FIELD_IDENTIFIER Y Y
UNKNOWN double double
UNKNOWN double double
<operator>.addition GTKLH [ j ] . X + GTKLH [ k ] . X
<operator>.fieldAccess GTKLH [ l ] . X
<operator>.addition GTKLH [ j ] . Y + GTKLH [ k ] . Y
<operator>.fieldAccess GTKLH [ l ] . Y
<operator>.fieldAccess GTKLH [ j ] . X
<operator>.fieldAccess GTKLH [ k ] . X
<operator>.indirectIndexAccess GTKLH [ l ]
FIELD_IDENTIFIER X X
<operator>.fieldAccess GTKLH [ j ] . Y
<operator>.fieldAccess GTKLH [ k ] . Y
<operator>.indirectIndexAccess GTKLH [ l ]
FIELD_IDENTIFIER Y Y
<operator>.indirectIndexAccess GTKLH [ j ]
FIELD_IDENTIFIER X X
<operator>.indirectIndexAccess GTKLH [ k ]
FIELD_IDENTIFIER X X
<operator>.indirectIndexAccess GTKLH [ j ]
FIELD_IDENTIFIER Y Y
<operator>.indirectIndexAccess GTKLH [ k ]
FIELD_IDENTIFIER Y Y
>>>PDG&159 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->13 0->15 0->17 0->19 0->21 0->23 0->25 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->49 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->81 0->82 0->83 0->84 0->85 0->86 0->89 0->90 0->93 0->94 2->1 2->1 2->1 2->4 2->10 2->13 2->15 2->17 2->19 2->21 2->23 2->25 2->27 2->40 2->53 2->54 2->55 2->56 2->57 2->58 2->59 3->1 3->1 3->6 4->1 4->1 4->13 4->40 5->1 6->1 6->1 6->1 6->6 6->7 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->20 6->21 6->22 6->23 6->24 6->25 6->26 6->27 6->28 6->29 6->30 6->31 6->32 6->32 6->33 6->34 6->36 6->38 6->40 6->41 6->42 6->43 6->44 6->45 6->46 6->47 6->48 6->49 6->52 6->53 6->54 6->55 6->56 6->57 6->58 6->59 6->60 6->61 6->64 6->68 6->95 6->96 6->97 6->98 6->99 6->100 6->101 6->102 6->103 6->104 6->105 6->106 6->107 6->108 6->109 6->110 6->111 6->112 6->113 6->114 6->115 6->116 6->117 6->118 6->119 6->120 6->121 6->122 6->123 6->124 7->1 7->6 8->5 9->1 10->3 10->4 10->13 10->15 10->17 10->19 10->21 10->23 10->25 10->27 10->40 10->53 10->54 10->55 10->56 10->57 10->58 10->59 11->1 11->6 12->1 12->64 13->40 13->53 14->1 14->1 14->74 15->13 15->40 15->53 15->54 16->1 16->1 16->65 16->69 17->13 17->15 17->40 17->53 17->54 17->55 18->1 18->1 18->75 19->13 19->15 19->17 19->40 19->53 19->54 19->55 19->56 20->1 20->1 20->66 20->70 21->13 21->15 21->17 21->19 21->40 21->53 21->54 21->55 21->56 21->57 22->1 22->29 23->13 23->15 23->17 23->19 23->21 23->40 23->53 23->54 23->55 23->56 23->57 23->58 24->1 24->30 25->1 25->13 25->15 25->17 25->19 25->21 25->23 25->40 25->53 25->54 25->55 25->56 25->57 25->58 25->59 26->1 26->1 26->1 26->65 27->1 27->1 27->13 27->40 28->1 28->1 28->34 29->1 29->1 30->1 30->1 31->1 31->32 31->84 32->1 32->1 32->7 32->33 33->1 33->1 33->32 34->1 35->1 35->2 35->9 36->1 36->36 36->37 36->50 36->51 36->61 36->65 36->66 36->69 36->70 36->74 36->75 36->85 36->85 36->86 36->125 36->126 36->127 36->128 36->129 36->130 36->131 36->132 36->133 36->134 36->135 36->136 37->1 37->36 38->1 38->1 38->1 38->38 38->39 38->39 38->61 38->62 38->67 38->67 38->71 38->76 38->76 39->1 39->38 40->12 40->13 47->1 48->1 49->1 49->36 50->1 50->1 51->1 51->1 52->1 52->38 53->13 53->14 53->15 53->40 53->41 54->13 54->15 54->16 54->17 54->40 54->42 54->53 55->13 55->15 55->17 55->18 55->19 55->40 55->43 55->53 55->54 56->13 56->15 56->17 56->19 56->20 56->21 56->40 56->44 56->53 56->54 56->55 57->13 57->15 57->17 57->19 57->21 57->22 57->23 57->40 57->45 57->53 57->54 57->55 57->56 58->13 58->15 58->17 58->19 58->21 58->23 58->24 58->25 58->40 58->46 58->53 58->54 58->55 58->56 58->57 59->13 59->15 59->17 59->19 59->21 59->23 59->25 59->26 59->27 59->40 59->47 59->53 59->54 59->55 59->56 59->57 59->58 60->1 60->28 60->48 61->1 61->38 61->38 61->71 62->1 62->1 62->1 62->62 62->63 62->63 62->71 62->72 62->77 62->77 62->81 62->81 63->1 63->62 64->36 64->60 65->1 65->50 65->50 65->66 66->1 66->1 66->51 66->51 66->65 67->1 67->1 67->62 68->1 69->1 69->1 70->1 70->1 71->61 71->62 71->62 71->72 72->1 72->1 72->71 72->72 72->73 72->73 72->78 72->79 72->80 72->82 72->83 72->87 72->88 72->89 72->91 72->92 72->93 72->137 72->138 72->139 72->140 72->141 72->142 72->143 72->144 72->145 72->146 72->147 72->148 72->149 72->150 72->151 72->152 72->153 72->154 72->155 72->156 72->157 72->158 73->1 73->72 74->1 74->65 74->65 74->69 74->69 75->1 75->66 75->66 75->70 75->70 77->1 77->1 77->72 78->1 78->1 78->93 79->1 79->1 79->1 79->94 80->1 80->1 80->1 80->84 82->1 82->78 82->78 83->1 83->79 83->79 84->1 84->32 85->86 86->37 87->1 88->1 89->1 89->1 89->80 89->80 89->90 89->94 90->1 90->1 90->80 90->80 91->1 92->1 93->89 94->90
>>>Token int main ( ) { char c ; int n , N , BHIUROLGJO , i , j , k , l , m ; long long A , B , C , D , X0 , Y0 , M ; struct TQYN * GTKLH ; struct UTPSPBYH * FELRFSBDN ; double X , Y ; c = ( char ) ROTBF ( stdin ) ; n = PTHDABN ( & c ) ; LIJHACX ( & c , ' \n ' ) ; for ( i = 1 ; i <= n ; i ++ ) { N = PTHDABN ( & c ) ; LIJHACX ( & c , ' ' ) ; A = ( long long ) PTHDABN ( & c ) ; LIJHACX ( & c , ' ' ) ; B = ( long long ) PTHDABN ( & c ) ; LIJHACX ( & c , ' ' ) ; C = ( long long ) PTHDABN ( & c ) ; LIJHACX ( & c , ' ' ) ; D = ( long long ) PTHDABN ( & c ) ; LIJHACX ( & c , ' ' ) ; X0 = ( long long ) PTHDABN ( & c ) ; LIJHACX ( & c , ' ' ) ; Y0 = ( long long ) PTHDABN ( & c ) ; LIJHACX ( & c , ' ' ) ; M = ( long long ) PTHDABN ( & c ) ; LIJHACX ( & c , ' \n ' ) ; GTKLH = ( struct TQYN * ) malloc ( sizeof ( struct TQYN ) * N ) ; GTKLH [ 0 ] . X = X0 ; GTKLH [ 0 ] . Y = Y0 ; for ( j = 1 ; j < N ; j ++ ) { GTKLH [ j ] . X = ( A * GTKLH [ j - 1 ] . X + B ) % M ; GTKLH [ j ] . Y = ( C * GTKLH [ j - 1 ] . Y + D ) % M ; } BHIUROLGJO = 0 ; for ( j = 0 ; j < N - 2 ; j ++ ) { for ( k = j + 1 ; k < N - 1 ; k ++ ) { for ( l = k + 1 ; l < N ; l ++ ) { X = ( double ) ( GTKLH [ j ] . X + GTKLH [ k ] . X + GTKLH [ l ] . X ) / 3.0 ; Y = ( double ) ( GTKLH [ j ] . Y + GTKLH [ k ] . Y + GTKLH [ l ] . Y ) / 3.0 ; if ( X == BEHGK ( X ) && Y == BEHGK ( Y ) ) { BHIUROLGJO ++ ; } } } } fprintf ( SBPOCS , " \n " , i , BHIUROLGJO ) ; CVJVXP ( SBPOCS ) ; free ( GTKLH ) ; } return 0 ; }
>>>Func
METHOD YDLQHS
METHOD_RETURN UAIQ
PARAM UAIQ * KKYB
PARAM int FQIK
RETURN return KKYB ; return KKYB ;
<operator>.equals KKYB == NULL
IDENTIFIER KKYB return KKYB ;
<operator>.assignment KKYB = SIJKYFM ( FQIK )
SIJKYFM SIJKYFM ( FQIK )
<operator>.greaterThan FQIK > KKYB -> FQIK
<operator>.assignment KKYB -> RXVXI = YDLQHS ( KKYB -> RXVXI , FQIK )
YDLQHS YDLQHS ( KKYB -> RXVXI , FQIK )
<operator>.lessThan FQIK < KKYB -> FQIK
<operator>.assignment KKYB -> BSJK = YDLQHS ( KKYB -> BSJK , FQIK )
YDLQHS YDLQHS ( KKYB -> BSJK , FQIK )
<operator>.indirectFieldAccess KKYB -> FQIK
FIELD_IDENTIFIER FQIK FQIK
<operator>.indirectFieldAccess KKYB -> RXVXI
FIELD_IDENTIFIER RXVXI RXVXI
<operator>.indirectFieldAccess KKYB -> RXVXI
FIELD_IDENTIFIER RXVXI RXVXI
<operator>.indirectFieldAccess KKYB -> FQIK
FIELD_IDENTIFIER FQIK FQIK
<operator>.indirectFieldAccess KKYB -> BSJK
FIELD_IDENTIFIER BSJK BSJK
<operator>.indirectFieldAccess KKYB -> BSJK
FIELD_IDENTIFIER BSJK BSJK
>>>PDG&27 0->2 0->3 0->5 0->6 0->8 0->9 0->11 0->12 0->14 2->5 3->8 3->9 4->1 5->1 5->1 5->1 5->6 5->7 5->8 5->9 5->15 5->16 6->4 7->1 7->1 7->1 7->6 8->1 8->7 9->1 9->1 9->10 9->11 9->11 9->12 9->12 9->12 9->17 9->18 9->19 9->20 9->21 9->22 10->1 10->1 10->1 11->1 11->10 11->10 12->1 12->1 12->1 12->13 12->14 12->14 12->23 12->24 12->25 12->26 13->1 13->1 13->1 14->1 14->13 14->13
>>>Token UAIQ * YDLQHS ( UAIQ * KKYB , int FQIK ) { if ( KKYB == NULL ) { KKYB = SIJKYFM ( FQIK ) ; } else if ( FQIK > KKYB -> FQIK ) { KKYB -> RXVXI = YDLQHS ( KKYB -> RXVXI , FQIK ) ; } else if ( FQIK < KKYB -> FQIK ) { KKYB -> BSJK = YDLQHS ( KKYB -> BSJK , FQIK ) ; } return KKYB ; }
>>>Func
METHOD NFBS
METHOD_RETURN void
PARAM char * LBKJCK...
FUHNLHPO FUHNLHPO ( DSYHJK , LBKJCK )
WWPPJSC WWPPJSC ( LBKJCK , DSYHJK )
printf printf ( "\n" )
UUMLML UUMLML ( LANYFG )
AMQKTN AMQKTN ( DSYHJK )
RETURN return ; return ;
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->3 3->1 3->4 3->4 4->1 4->1 4->7 5->1 6->1 6->1 7->1 7->1 8->1
>>>Token void NFBS ( char * LBKJCK , ... ) { OQYANAN DSYHJK ; FUHNLHPO ( DSYHJK , LBKJCK ) ; WWPPJSC ( LBKJCK , DSYHJK ) ; printf ( " \n " ) ; UUMLML ( LANYFG ) ; AMQKTN ( DSYHJK ) ; return ; }
>>>Func
METHOD WQMOYFKYLJBMATQVL
METHOD_RETURN void*
PARAM FVWWETNBWI * JWDT
PARAM char s [ ]
<operator>.assignment UVGJU = NUVYEWNG ( s )
printf printf ( "None entry at given label\n" )
RETURN return NULL ; return NULL ;
IDENTIFIER NULL return NULL ;
NUVYEWNG NUVYEWNG ( s )
RETURN return JWDT -> SFDFMBEK [ UVGJU ] ; return JWDT -> SFDFMBEK [ UVGJU ] ;
<operator>.indirectIndexAccess JWDT -> SFDFMBEK [ UVGJU ]
<operator>.indirectIndexAccess JWDT -> SFDFMBEK [ UVGJU ]
<operator>.indirectFieldAccess JWDT -> SFDFMBEK
FIELD_IDENTIFIER SFDFMBEK SFDFMBEK
>>>PDG&14 0->2 0->3 0->5 0->6 0->7 0->8 0->9 2->1 3->8 4->1 4->1 4->1 6->1 7->6 8->1 8->4 9->1 10->5 10->6 10->9 10->11 10->12 10->13
>>>Token void * WQMOYFKYLJBMATQVL ( FVWWETNBWI * JWDT , char s [ ] ) { int UVGJU = NUVYEWNG ( s ) ; if ( JWDT -> SFDFMBEK [ UVGJU ] ) { return JWDT -> SFDFMBEK [ UVGJU ] ; } printf ( " \n " ) ; return NULL ; }
>>>Func
METHOD IETQHUTNKDARPAUCQDAAA
METHOD_RETURN void
PARAM VUXVIXMAXLIFH * S
<operator>.assignment S -> f [ 0 ] = ( RYTIDOMU ) - 1
PHERAJTBJSVJOGJBHKOR PHERAJTBJSVJOGJBHKOR ( S )
<operator>.subtraction ( RYTIDOMU ) - 1
<operator>.indirectFieldAccess S -> YOESEOXGJ
>>>PDG&7 0->2 0->4 0->5 2->1 2->4 3->1 3->1 3->1 4->1 4->1 5->1 5->3 5->3 6->4
>>>Token static void IETQHUTNKDARPAUCQDAAA ( VUXVIXMAXLIFH * S ) { if ( S -> YOESEOXGJ ) PHERAJTBJSVJOGJBHKOR ( S ) ; S -> f [ 0 ] = ( RYTIDOMU ) - 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
XEWNK XEWNK ( "%d" , & c )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= c
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 1
XEWNK XEWNK ( "%d%d%d" , & n , & m , & a )
printf printf ( "Case #%d: " , t )
<operator>.assignment nf = 1
<operator>.greaterThan a > n * m
<operator>.logicalAnd xa <= n && nf
<operator>.postIncrement xa ++
IDENTIFIER nf if (nf)
printf printf ( "IMPOSSIBLE\n" )
<operator>.assignment xa = 0
printf printf ( "IMPOSSIBLE\n" )
<operator>.multiplication n * m
<operator>.lessEqualsThan xa <= n
<operator>.logicalAnd xb <= n && nf
<operator>.postIncrement xb ++
<operator>.assignment xb = 0
<operator>.lessEqualsThan xb <= n
<operator>.logicalAnd xc <= n && nf
<operator>.postIncrement xc ++
<operator>.assignment xc = 0
<operator>.lessEqualsThan xc <= n
<operator>.logicalAnd ya <= m && nf
<operator>.postIncrement ya ++
<operator>.assignment ya = 0
<operator>.lessEqualsThan ya <= m
<operator>.logicalAnd yb <= m && nf
<operator>.postIncrement yb ++
<operator>.assignment yb = 0
<operator>.lessEqualsThan yb <= m
<operator>.logicalAnd yc <= m && nf
<operator>.postIncrement yc ++
<operator>.assignment yc = 0
<operator>.assignment ar = SOH ( ( xb * ya - xa * yb ) + ( xc * yb - xb * yc ) + ( xa * yc - xc * ya ) )
<operator>.lessEqualsThan yc <= m
<operator>.equals ar == a
SOH SOH ( ( xb * ya - xa * yb ) + ( xc * yb - xb * yc ) + ( xa * yc - xc * ya ) )
printf printf ( "%d %d %d %d %d %d\n" , xa , ya , xb , yb , xc , yc )
<operator>.assignment nf = 0
<operator>.addition ( xb * ya - xa * yb ) + ( xc * yb - xb * yc ) + ( xa * yc - xc * ya )
<operator>.addition ( xb * ya - xa * yb ) + ( xc * yb - xb * yc )
<operator>.subtraction xa * yc - xc * ya
<operator>.subtraction xb * ya - xa * yb
<operator>.subtraction xc * yb - xb * yc
<operator>.multiplication xa * yc
<operator>.multiplication xc * ya
<operator>.multiplication xb * ya
<operator>.multiplication xa * yb
<operator>.multiplication xc * yb
<operator>.multiplication xb * yc
<operator>.addressOf & n
<operator>.addressOf & m
<operator>.addressOf & a
>>>PDG&59 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->43 0->44 0->50 0->51 0->52 0->53 0->54 0->55 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->9 4->11 4->18 4->56 4->57 4->58 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->1 8->11 8->18 8->18 8->19 8->23 8->27 8->31 8->35 8->40 8->41 9->1 9->5 10->1 10->12 11->1 11->1 11->1 11->8 11->10 11->12 11->15 11->16 11->17 11->19 11->41 12->1 12->1 12->1 12->12 12->13 12->19 12->20 12->20 12->22 12->23 13->1 13->19 15->1 16->1 16->19 17->1 18->1 18->1 18->8 18->8 18->11 18->11 18->19 18->31 19->1 19->1 19->8 19->12 19->12 19->13 19->18 19->23 19->53 20->1 20->1 20->12 20->20 20->21 20->23 20->24 20->24 20->26 20->27 21->1 21->23 22->1 22->23 23->1 23->19 23->20 23->20 23->21 23->27 23->52 24->1 24->1 24->20 24->24 24->25 24->27 24->28 24->28 24->30 24->31 25->1 25->27 26->1 26->27 27->1 27->23 27->24 27->24 27->25 27->54 28->1 28->1 28->24 28->28 28->29 28->31 28->32 28->32 28->34 28->35 29->1 29->31 30->1 30->31 31->1 31->1 31->8 31->18 31->28 31->28 31->29 31->35 31->52 32->1 32->1 32->28 32->32 32->33 32->35 32->36 32->36 32->38 32->40 33->1 33->35 34->1 34->35 35->1 35->31 35->32 35->32 35->33 35->40 35->53 36->1 36->1 36->32 36->36 36->37 36->39 36->40 36->41 36->42 36->45 36->46 36->47 36->48 36->49 36->50 36->51 36->52 36->53 36->54 36->55 37->1 37->40 38->1 38->40 39->1 39->1 39->41 40->1 40->35 40->36 40->36 40->55 41->1 41->1 41->1 41->8 41->11 41->43 41->44 42->1 42->39 43->1 43->13 43->21 43->25 43->29 43->33 43->37 43->52 43->52 43->53 43->53 43->54 44->1 44->36 45->1 45->1 46->1 46->1 47->1 47->1 47->42 47->42 47->45 47->45 48->1 48->1 48->42 48->42 48->45 48->45 48->46 48->46 49->1 49->1 49->42 49->42 49->45 49->45 49->46 49->46 50->13 50->37 50->43 50->43 50->47 50->47 50->53 51->25 51->29 51->43 51->43 51->47 51->47 51->52 51->54 52->48 52->48 52->51 52->55 53->48 53->48 53->50 53->54 54->33 54->43 54->49 54->49 54->51 54->53 55->21 55->43 55->49 55->49 55->50 55->52
>>>Token int main ( ) { int c , n , m , a ; int t ; int xa , ya , xb , yb , xc , yc ; int ar ; int nf ; XEWNK ( " " , & c ) ; for ( t = 1 ; t <= c ; t ++ ) { XEWNK ( " " , & n , & m , & a ) ; printf ( " " , t ) ; if ( a > n * m ) { printf ( " \n " ) ; continue ; } nf = 1 ; for ( xa = 0 ; xa <= n && nf ; xa ++ ) { for ( xb = 0 ; xb <= n && nf ; xb ++ ) { for ( xc = 0 ; xc <= n && nf ; xc ++ ) { for ( ya = 0 ; ya <= m && nf ; ya ++ ) { for ( yb = 0 ; yb <= m && nf ; yb ++ ) { for ( yc = 0 ; yc <= m && nf ; yc ++ ) { ar = SOH ( ( xb * ya - xa * yb ) + ( xc * yb - xb * yc ) + ( xa * yc - xc * ya ) ) ; if ( ar == a ) { printf ( " \n " , xa , ya , xb , yb , xc , yc ) ; nf = 0 ; } } } } } } } if ( nf ) printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD KRDEOWAR
METHOD_RETURN WCOQCXL
PARAM char PAC
<operator>.logicalOr PAC == '+' || PAC == '-'
RETURN return 0 ; return 0 ;
<operator>.equals PAC == '+'
<operator>.equals PAC == '-'
LITERAL 0 return 0 ;
<operator>.logicalOr PAC == '/' || PAC == '*' || PAC == '%'
RETURN return 1 ; return 1 ;
<operator>.logicalOr PAC == '/' || PAC == '*'
<operator>.equals PAC == '%'
LITERAL 1 return 1 ;
RETURN return - 1 ; return - 1 ;
<operator>.equals PAC == '/'
<operator>.equals PAC == '*'
<operator>.minus - 1
>>>PDG&17 0->2 0->4 0->5 0->6 0->7 0->9 0->11 0->12 0->14 0->15 0->16 2->5 3->1 3->1 3->1 3->4 3->8 3->10 3->14 4->1 5->1 5->3 5->3 5->6 5->6 5->14 6->1 6->3 6->3 6->14 7->4 8->9 8->13 8->16 9->1 10->8 10->8 10->11 11->8 11->8 12->9 13->1 14->10 14->10 14->11 14->15 14->15 15->10 15->10 15->11 16->13
>>>Token WCOQCXL KRDEOWAR ( char PAC ) { if ( PAC == ' ' || PAC == ' ' ) { return 0 ; } else if ( PAC == ' ' || PAC == ' ' || PAC == ' ' ) { return 1 ; } else { return - 1 ; } }
>>>Func
METHOD SKK
METHOD_RETURN int
PARAM int a
PARAM int b
<operator>.logicalNot ! b
RETURN return a ; return a ;
IDENTIFIER a return a ;
RETURN return SKK ( b , a % b ) ; return SKK ( b , a % b ) ;
SKK SKK ( b , a % b )
<operator>.modulo a % b
>>>PDG&10 0->2 0->3 0->4 0->6 0->8 0->9 2->1 2->6 2->9 3->4 4->1 4->1 4->5 4->7 4->8 4->9 4->9 5->1 6->5 7->1 8->7 9->8 9->8
>>>Token int SKK ( int a , int b ) { if ( ! b ) return a ; else return SKK ( b , a % b ) ; }
>>>Func
METHOD TJJK
METHOD_RETURN void
printf printf ( "%d\n" , EBTNQ )
printf printf ( "1 2" )
printf printf ( "\n" )
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
<operator>.assignment i = 3
assert assert ( AYCBQ [ i ] <= EBTNQ )
printf printf ( " %d" , AYCBQ [ i ] )
<operator>.lessEqualsThan AYCBQ [ i ] <= EBTNQ
<operator>.indirectIndexAccess AYCBQ [ i ]
<operator>.indirectIndexAccess AYCBQ [ i ]
>>>PDG&13 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 2->1 2->1 2->10 3->1 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->8 5->9 5->10 5->11 5->12 6->1 6->5 7->1 7->5 8->1 8->1 9->1 9->1 9->10 10->1 10->8 10->8 10->9
>>>Token void TJJK ( ) { int i ; printf ( " \n " , EBTNQ ) ; printf ( " " ) ; for ( i = 3 ; i <= n ; i ++ ) { assert ( AYCBQ [ i ] <= EBTNQ ) ; printf ( " " , AYCBQ [ i ] ) ; } printf ( " \n " ) ; }
>>>Func
METHOD UBHHXWGQM
METHOD_RETURN char*
PARAM struct NJQJG * l
PARAM char * ( * OYARLRPWI ) ( void * )
PARAM int DWXYRBVPVYYGXV
<operator>.assignment * BGE = malloc ( ( 3 + AOHYPIQQEI ( l ) * ( 2 + DWXYRBVPVYYGXV ) ) * sizeof ( char ) )
PGHVEFK PGHVEFK ( BGE   "[%s%s]"   OYARLRPWI ( WRPBVFKPU ( l ) )   YCXHGXVPWNXPF ( FXWLFSRMFO ( l ) , OYARLRPWI , DWXYRBVPVYYGXV ) )
RETURN return BGE ; return BGE ;
MQKCCDNJTOLM MQKCCDNJTOLM ( l )
IDENTIFIER BGE return BGE ;
RETURN return "[]" ; return "[]" ;
malloc malloc ( ( 3 + AOHYPIQQEI ( l ) * ( 2 + DWXYRBVPVYYGXV ) ) * sizeof ( char ) )
OYARLRPWI OYARLRPWI ( WRPBVFKPU ( l ) )
YCXHGXVPWNXPF YCXHGXVPWNXPF ( FXWLFSRMFO ( l ) , OYARLRPWI , DWXYRBVPVYYGXV )
LITERAL "[]" return "[]" ;
<operator>.multiplication ( 3 + AOHYPIQQEI ( l ) * ( 2 + DWXYRBVPVYYGXV ) ) * sizeof ( char )
WRPBVFKPU WRPBVFKPU ( l )
FXWLFSRMFO FXWLFSRMFO ( l )
<operator>.addition 3 + AOHYPIQQEI ( l ) * ( 2 + DWXYRBVPVYYGXV )
<operator>.sizeOf sizeof ( char )
<operator>.multiplication AOHYPIQQEI ( l ) * ( 2 + DWXYRBVPVYYGXV )
AOHYPIQQEI AOHYPIQQEI ( l )
<operator>.addition 2 + DWXYRBVPVYYGXV
>>>PDG&23 0->2 0->3 0->4 0->6 0->8 0->9 0->10 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->21 0->22 2->8 3->1 4->1 4->13 4->20 4->22 5->6 6->9 7->1 8->1 8->1 8->5 8->6 8->7 8->10 8->11 8->12 8->13 8->15 8->16 8->17 8->18 8->19 8->20 8->21 8->21 8->22 9->7 10->1 11->5 12->6 13->1 13->6 13->6 13->6 14->10 15->11 16->12 16->17 17->13 19->1 20->15 20->15 20->18 20->18 21->16 21->20
>>>Token char * UBHHXWGQM ( struct NJQJG * l , char * ( * OYARLRPWI ) ( void * ) , int DWXYRBVPVYYGXV ) { if ( MQKCCDNJTOLM ( l ) ) return " " ; char * BGE = malloc ( ( 3 + AOHYPIQQEI ( l ) * ( 2 + DWXYRBVPVYYGXV ) ) * sizeof ( char ) ) ; PGHVEFK ( BGE , " " , OYARLRPWI ( WRPBVFKPU ( l ) ) , YCXHGXVPWNXPF ( FXWLFSRMFO ( l ) , OYARLRPWI , DWXYRBVPVYYGXV ) ) ; return BGE ; }
>>>Func
METHOD DSAXR
METHOD_RETURN void
<operator>.assignment N = 500
<operator>.assignment UPETBYBH = 2
<operator>.assignment KSLKASY = 20
<operator>.assignment * * X = ( double * * ) malloc ( N * sizeof ( double * ) )
<operator>.assignment * * W = ( double * * ) malloc ( KSLKASY * sizeof ( double * ) )
XYYALUVLTNKWAHA XYYALUVLTNKWAHA ( X , N )
FBQOOIWFKUPY FBQOOIWFKUPY ( "test2.csv" , X , N , UPETBYBH )
FBQOOIWFKUPY FBQOOIWFKUPY ( "w21.csv" , W , KSLKASY , UPETBYBH )
DEHMCHOCULAJGPTFQE DEHMCHOCULAJGPTFQE ( X , W , N , UPETBYBH , KSLKASY , 0.01 )
FBQOOIWFKUPY FBQOOIWFKUPY ( "w22.csv" , W , KSLKASY , UPETBYBH )
free free ( X )
free free ( W )
<operator>.lessThan i < LQP ( KSLKASY , N )
<operator>.postIncrement i ++
<operator>.lessThan i < LQP ( KSLKASY , N )
<operator>.postIncrement i ++
<operator>.cast ( double * * ) malloc ( N * sizeof ( double * ) )
<operator>.cast ( double * * ) malloc ( KSLKASY * sizeof ( double * ) )
<operator>.assignment i = 0
<operator>.assignment i = 0
malloc malloc ( N * sizeof ( double * ) )
malloc malloc ( KSLKASY * sizeof ( double * ) )
LQP LQP ( KSLKASY , N )
<operator>.lessThan i < N
<operator>.lessThan i < KSLKASY
LQP LQP ( KSLKASY , N )
<operator>.lessThan i < N
<operator>.lessThan i < KSLKASY
<operator>.multiplication N * sizeof ( double * )
<operator>.multiplication KSLKASY * sizeof ( double * )
<operator>.assignment X [ i ] = ( double * ) malloc ( UPETBYBH * sizeof ( double ) )
<operator>.assignment W [ i ] = ( double * ) malloc ( UPETBYBH * sizeof ( double ) )
IDENTIFIER WBCR <empty>
<operator>.lessThan j < UPETBYBH
<operator>.postIncrement j ++
free free ( X [ i ] )
free free ( W [ i ] )
<operator>.sizeOf sizeof ( double * )
<operator>.cast ( double * ) malloc ( UPETBYBH * sizeof ( double ) )
<operator>.cast ( double * ) malloc ( UPETBYBH * sizeof ( double ) )
malloc malloc ( UPETBYBH * sizeof ( double ) )
malloc malloc ( UPETBYBH * sizeof ( double ) )
<operator>.multiplication UPETBYBH * sizeof ( double )
<operator>.multiplication UPETBYBH * sizeof ( double )
<operator>.sizeOf sizeof ( double )
<operator>.sizeOf sizeof ( double )
UNKNOWN K K
UNKNOWN R R
UNKNOWN for ( j <QJLRIOY ')'> = 0 ; for ( j <QJLRIOY ')'> = 0 ;
UNKNOWN + +
UNKNOWN,) W [ i ] [ j ] = UJMIMIJ ( - 1 , 1 ) ;,) W [ i ] [ j ] = UJMIMIJ ( - 1 , 1 ) ;
<operator>.indirectIndexAccess X [ i ]
<operator>.indirectIndexAccess W [ i ]
<operator>.indirectIndexAccess X [ i ]
<operator>.indirectIndexAccess W [ i ]
UNKNOWN double * double *
UNKNOWN double * double *
>>>PDG&59 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->20 0->21 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->34 0->35 0->36 0->44 0->45 2->1 2->30 3->1 3->8 3->44 3->45 4->1 4->31 5->1 5->1 5->7 6->1 6->1 6->9 7->1 7->8 7->8 8->1 8->9 8->10 8->10 9->1 9->10 9->10 9->10 10->1 10->11 10->11 10->11 10->12 10->27 10->37 11->1 11->1 11->13 11->27 11->38 12->1 13->1 14->14 14->15 14->24 14->25 14->25 14->26 15->1 15->14 16->1 16->1 16->1 16->16 16->17 16->27 16->28 16->28 16->29 17->1 17->16 18->1 19->1 20->14 21->1 21->16 22->1 22->5 22->18 23->1 23->6 23->19 24->7 24->9 24->14 24->14 24->25 24->26 25->1 25->24 25->26 25->32 25->40 25->42 25->44 25->46 25->53 25->57 26->1 26->15 26->24 26->33 26->35 26->36 26->41 26->43 26->45 26->47 26->48 26->49 26->50 26->51 26->52 26->54 26->58 27->1 27->1 27->16 27->16 27->28 27->29 28->1 28->27 28->29 28->37 28->55 29->1 29->17 29->27 29->38 29->56 30->22 30->24 31->23 31->24 32->1 32->1 32->1 32->7 32->8 32->10 32->12 32->37 33->1 33->1 33->1 33->9 33->10 33->11 33->13 33->38 35->1 35->8 35->36 35->44 35->45 36->1 36->1 36->35 37->1 37->12 38->1 38->13 39->1 40->1 41->1 42->1 42->32 42->40 43->1 43->33 43->41 44->8 44->42 44->45 45->35 45->43 46->1 47->1
>>>Token void DSAXR ( ) { int j , N = 500 ; int UPETBYBH = 2 ; int KSLKASY = 20 ; double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; double * * W = ( double * * ) malloc ( KSLKASY * sizeof ( double * ) ) ; for ( int i = 0 ; i < LQP ( KSLKASY , N ) ; i ++ ) { if ( i < N ) X [ i ] = ( double * ) malloc ( UPETBYBH * sizeof ( double ) ) ; if ( i < KSLKASY ) { W [ i ] = ( double * ) malloc ( UPETBYBH * sizeof ( double ) ) ; YMT VAWRWCK  WBCR for ( j < QJLRIOY ' ' > = 0 ; j < UPETBYBH ; j ++ ) W [ i ] [ j ] = UJMIMIJ ( - 1 , 1 ) ; } } XYYALUVLTNKWAHA ( X , N ) ; FBQOOIWFKUPY ( " " , X , N , UPETBYBH ) ; FBQOOIWFKUPY ( " " , W , KSLKASY , UPETBYBH ) ; DEHMCHOCULAJGPTFQE ( X , W , N , UPETBYBH , KSLKASY , 0.01 ) ; FBQOOIWFKUPY ( " " , W , KSLKASY , UPETBYBH ) ; for ( int i = 0 ; i < LQP ( KSLKASY , N ) ; i ++ ) { if ( i < N ) free ( X [ i ] ) ; if ( i < KSLKASY ) free ( W [ i ] ) ; } free ( X ) ; free ( W ) ; }
>>>Func
METHOD ACWNAMQNHP
METHOD_RETURN void
PARAM int * BJQQ
PARAM int BFWGGWYY
<operator>.assignment i = 0
<operator>.assignment NFOEI = 0
<operator>.lessThan i < BFWGGWYY
<operator>.postIncrement i ++
<operator>.lessThan NFOEI < BFWGGWYY
<operator>.postIncrement NFOEI ++
<operator>.assignment i = 0
IDENTIFIER NFOEI <empty>
<operator>.assignment BJQQ [ NFOEI ] = 0
<operator>.assignment BJQQ [ NFOEI ++ ] = BJQQ [ i ]
<operator>.postIncrement NFOEI ++
<operator>.indirectIndexAccess BJQQ [ i ]
<operator>.indirectIndexAccess BJQQ [ NFOEI ]
<operator>.indirectIndexAccess BJQQ [ NFOEI ++ ]
<operator>.indirectIndexAccess BJQQ [ i ]
>>>PDG&19 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 2->1 2->13 3->6 5->1 5->8 5->14 6->1 6->1 6->6 6->7 6->7 6->8 6->15 7->1 7->6 8->1 8->1 8->1 8->8 8->9 8->9 8->12 8->16 9->1 9->8 10->1 10->6 14->8 15->13 15->14 15->17 15->18
>>>Token void ACWNAMQNHP ( int * BJQQ , int BFWGGWYY ) { int i = 0 , NFOEI = 0 ; for ( i = 0 ; i < BFWGGWYY ; i ++ ) { if ( BJQQ [ i ] ) BJQQ [ NFOEI ++ ] = BJQQ [ i ] ; } for ( NFOEI ; NFOEI < BFWGGWYY ; NFOEI ++ ) { BJQQ [ NFOEI ] = 0 ; } }
>>>Func
METHOD FWVCTW
METHOD_RETURN int
PARAM const void * a
PARAM const void * b
RETURN return * ( int * ) a - * ( int * ) b ; return * ( int * ) a - * ( int * ) b ;
<operator>.subtraction * ( int * ) a - * ( int * ) b
<operator>.cast ( int * ) a
<operator>.cast ( int * ) b
>>>PDG&8 0->2 0->3 0->6 0->7 2->6 3->7 4->1 5->1 5->1 5->1 5->4 6->1 7->1
>>>Token int FWVCTW ( const void * a , const void * b ) { return * ( int * ) a - * ( int * ) b ; }
>>>Func
METHOD main
METHOD_RETURN int
EOFXU EOFXU ( "%d" , & no )
RETURN return 0 ; return 0 ;
<operator>.lessThan k < no
<operator>.postIncrement k ++
LITERAL 0 return 0 ;
<operator>.assignment k = 0
memset memset ( a , 0 , 1000000 )
memset memset ( b , 0 , 1000000 )
EOFXU EOFXU ( "%d" , & n )
EOFXU EOFXU ( "%d" , & n )
<operator>.assignment p = 0
EOFXU EOFXU ( "%d%s" , & n , s )
printf printf ( "Case #%d: [" , k + 1 )
printf printf ( "]\n" )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.notEquals p != 0
<operator>.lessThan i < p
<operator>.postIncrement i ++
<operator>.assignment i = 0
EOFXU EOFXU ( "%s" , s )
<operator>.assignment a [ s [ 0 ] ] [ s [ 1 ] ] = a [ s [ 1 ] ] [ s [ 0 ] ] = s [ 2 ]
<operator>.assignment i = 0
EOFXU EOFXU ( "%s" , s )
<operator>.assignment b [ s [ 0 ] ] [ s [ 1 ] ] = s [ 1 ]
<operator>.assignment b [ s [ 1 ] ] [ s [ 0 ] ] = s [ 0 ]
<operator>.assignment i = 0
<operator>.assignment fl = 0
<operator>.assignment t = s [ i ]
<operator>.assignment f = 1
<operator>.assignment TWH [ p ++ ] = s [ i ]
<operator>.addition k + 1
printf printf ( "%c" , TWH [ 0 ] )
<operator>.assignment i = 1
printf printf ( ", %c" , TWH [ i ] )
<operator>.logicalAnd p != 0 && a [ t ] [ TWH [ p - 1 ] ] != 0
<operator>.equals fl == 1
<operator>.lessThan j < p
<operator>.postIncrement j ++
<operator>.equals f == 0
<operator>.assignment a [ s [ 1 ] ] [ s [ 0 ] ] = s [ 2 ]
<operator>.assignment fl = 1
<operator>.assignment TWH [ p - 1 ] = a [ t ] [ TWH [ p - 1 ] ]
<operator>.assignment t = TWH [ -- p ]
<operator>.postIncrement p ++
<operator>.assignment j = 0
<operator>.notEquals p != 0
<operator>.notEquals a [ t ] [ TWH [ p - 1 ] ] != 0
<operator>.notEquals b [ s [ i ] ] [ TWH [ j ] ] != 0
<operator>.postIncrement p ++
<operator>.assignment p = 0
<operator>.assignment f = 0
<operator>.subtraction p - 1
<operator>.preDecrement -- p
<operator>.subtraction p - 1
<operator>.subtraction p - 1
<operator>.addressOf & n
<operator>.addressOf & n
<operator>.addressOf & n
<operator>.indirectIndexAccess a [ s [ 0 ] ] [ s [ 1 ] ]
<operator>.indirectIndexAccess b [ s [ 0 ] ] [ s [ 1 ] ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess b [ s [ 1 ] ] [ s [ 0 ] ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess TWH [ p ++ ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess TWH [ 0 ]
<operator>.indirectIndexAccess TWH [ i ]
<operator>.indirectIndexAccess a [ s [ 0 ] ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess a [ s [ 1 ] ] [ s [ 0 ] ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess b [ s [ 0 ] ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess b [ s [ 1 ] ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess a [ s [ 1 ] ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess a [ t ] [ TWH [ p - 1 ] ]
<operator>.indirectIndexAccess TWH [ p - 1 ]
<operator>.indirectIndexAccess a [ t ] [ TWH [ p - 1 ] ]
<operator>.indirectIndexAccess TWH [ -- p ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess a [ t ]
<operator>.indirectIndexAccess TWH [ p - 1 ]
<operator>.indirectIndexAccess a [ t ]
<operator>.indirectIndexAccess TWH [ p - 1 ]
<operator>.indirectIndexAccess b [ s [ i ] ] [ TWH [ j ] ]
<operator>.indirectIndexAccess b [ s [ i ] ]
<operator>.indirectIndexAccess TWH [ j ]
<operator>.indirectIndexAccess s [ i ]
>>>PDG&101 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->29 0->32 0->33 0->35 0->37 0->38 0->39 0->40 0->42 0->43 0->44 0->45 0->47 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->14 4->15 4->16 4->18 4->20 4->22 4->23 4->25 4->28 4->32 4->37 4->37 4->39 4->62 4->63 4->64 5->1 5->4 6->3 7->1 7->4 8->1 8->1 9->1 9->1 10->11 10->16 10->18 11->1 11->13 11->18 11->20 12->1 12->22 12->52 13->1 13->1 13->1 13->10 13->16 13->20 13->26 13->29 13->34 13->36 14->1 14->1 15->1 16->11 16->16 16->17 16->17 16->18 16->26 16->27 16->46 16->65 16->75 16->76 16->77 16->78 16->83 16->84 16->85 16->92 17->1 17->16 18->13 18->18 18->19 18->19 18->20 18->29 18->30 18->31 18->66 18->67 18->68 18->69 18->79 18->80 18->81 18->82 18->86 18->87 19->1 19->18 20->1 20->1 20->10 20->16 20->20 20->21 20->21 20->33 20->34 20->41 20->42 20->52 20->70 21->1 21->20 22->1 22->23 22->38 22->73 23->1 23->1 23->1 23->23 23->24 23->24 23->40 23->74 24->1 24->23 25->16 26->1 26->13 26->27 26->29 26->46 27->1 27->1 27->1 28->18 29->1 29->13 29->26 29->30 29->31 30->1 30->1 30->1 31->1 31->1 31->1 32->1 32->20 33->1 33->42 34->1 34->1 34->1 35->1 35->45 36->1 36->1 36->1 38->1 38->1 39->1 39->23 40->1 40->1 41->1 41->1 41->41 41->47 41->48 41->49 41->52 41->58 41->59 41->61 41->89 41->90 41->91 41->95 41->96 42->1 42->1 42->35 42->43 42->45 42->50 42->51 43->1 43->1 43->22 43->44 43->52 43->54 43->55 43->97 43->98 43->99 43->100 44->1 44->43 45->1 45->1 45->36 45->55 45->71 45->72 46->1 46->1 46->27 47->1 47->42 48->1 48->1 48->1 49->1 49->1 49->1 50->1 50->22 50->52 51->1 51->43 52->41 52->41 52->43 52->50 52->53 52->58 52->60 52->60 52->88 52->93 52->94 53->1 53->41 53->41 53->48 54->1 54->1 54->43 54->44 54->56 54->57 55->22 55->52 56->1 56->22 56->52 56->55 57->1 57->45 58->61 59->52 60->43 60->50 60->58 61->59
>>>Token int main ( ) { int no , k ; EOFXU ( " " , & no ) ; for ( k = 0 ; k < no ; k ++ ) { int n , i ; char a [ 1000 ] [ 1000 ] , b [ 1000 ] [ 1000 ] ; memset ( a , 0 , 1000000 ) ; memset ( b , 0 , 1000000 ) ; EOFXU ( " " , & n ) ; char s [ 100 ] ; for ( i = 0 ; i < n ; i ++ ) { EOFXU ( " " , s ) ; a [ s [ 0 ] ] [ s [ 1 ] ] = a [ s [ 1 ] ] [ s [ 0 ] ] = s [ 2 ] ; } EOFXU ( " " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { EOFXU ( " " , s ) ; b [ s [ 0 ] ] [ s [ 1 ] ] = s [ 1 ] ; b [ s [ 1 ] ] [ s [ 0 ] ] = s [ 0 ] ; } char TWH [ 10000 ] ; int p = 0 ; EOFXU ( " " , & n , s ) ; for ( i = 0 ; i < n ; i ++ ) { int fl = 0 ; char t = s [ i ] ; while ( p != 0 && a [ t ] [ TWH [ p - 1 ] ] != 0 ) { fl = 1 ; TWH [ p - 1 ] = a [ t ] [ TWH [ p - 1 ] ] ; t = TWH [ -- p ] ; } if ( fl == 1 ) { p ++ ; continue ; } int j , f = 1 ; for ( j = 0 ; j < p ; j ++ ) { if ( b [ s [ i ] ] [ TWH [ j ] ] != 0 ) { p = 0 ; f = 0 ; break ; } } if ( f == 0 ) continue ; TWH [ p ++ ] = s [ i ] ; } printf ( " " , k + 1 ) ; if ( p != 0 ) printf ( " " , TWH [ 0 ] ) ; for ( i = 1 ; i < p ; i ++ ) { printf ( " " , TWH [ i ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment LHUTP = 0
<operator>.assignment SPBYHFELRFS [ n ] [ 2 ] = { { 0 } }
<operator>.assignment no = 0
<operator>.assignment x0 = 0
<operator>.assignment y0 = 0
<operator>.assignment X = 0
<operator>.assignment Y = 0
<operator>.assignment A = 0
<operator>.assignment B = 0
<operator>.assignment C = 0
<operator>.assignment D = 0
<operator>.assignment M = 0
<operator>.assignment i = 0
<operator>.assignment j = 0
<operator>.assignment k = 0
<operator>.assignment l = 0
<operator>.assignment BDNRO [ N ] = { 0 }
<operator>.assignment TBFPTH [ 2 ] = { 0 }
RETURN return 0 ; return 0 ;
<operator>.equals argc == 3
LITERAL 0 return 0 ;
<operator>.arrayInitializer { { 0 } }
<operator>.arrayInitializer { 0 }
<operator>.arrayInitializer { 0 }
<operator>.assignment ROLGJO = DABNL ( argv [ 1 ] , "r" )
<operator>.assignment TQYNGTK = DABNL ( argv [ 2 ] , "w" )
IJHACX IJHACX ( ROLGJO , "%d" , & LHUTP )
BEHGK BEHGK ( ROLGJO )
SBPOCS SBPOCS ( ROLGJO )
SBPOCS SBPOCS ( TQYNGTK )
<operator>.arrayInitializer { 0 }
<operator>.equals ROLGJO == NULL
<operator>.lessThan i < LHUTP
<operator>.postIncrement i ++
<operator>.lessThan i < LHUTP
<operator>.postIncrement i ++
printf printf ( "ERROR" )
DABNL DABNL ( argv [ 1 ] , "r" )
DABNL DABNL ( argv [ 2 ] , "w" )
printf printf ( "file open failed" )
RETURN return - 1 ; return - 1 ;
<operator>.assignment i = 0
IJHACX IJHACX ( ROLGJO , "%d" , & no )
IJHACX IJHACX ( ROLGJO , "%Ld" , & A )
IJHACX IJHACX ( ROLGJO , "%Ld" , & B )
IJHACX IJHACX ( ROLGJO , "%Ld" , & C )
IJHACX IJHACX ( ROLGJO , "%Ld" , & D )
IJHACX IJHACX ( ROLGJO , "%Ld" , & x0 )
IJHACX IJHACX ( ROLGJO , "%Ld" , & y0 )
IJHACX IJHACX ( ROLGJO , "%Ld" , & M )
BEHGK BEHGK ( ROLGJO )
<operator>.assignment SPBYHFELRFS [ 0 ] [ 0 ] = x0
<operator>.assignment SPBYHFELRFS [ 0 ] [ 1 ] = y0
<operator>.assignment X = x0
<operator>.assignment Y = y0
<operator>.assignment i = 0
fprintf fprintf ( TQYNGTK   "Case #%d: %d\n"   ( i + 1 ) , BDNRO [ i ] )
<operator>.minus - 1
<operator>.lessThan j < no
<operator>.postIncrement j ++
<operator>.lessThan j < no - 2
<operator>.postIncrement j ++
<operator>.assignment j = 1
<operator>.assignment SPBYHFELRFS [ j ] [ 0 ] = ( A * X + B ) % M
<operator>.assignment SPBYHFELRFS [ j ] [ 1 ] = ( C * Y + D ) % M
<operator>.assignment X = SPBYHFELRFS [ j ] [ 0 ]
<operator>.assignment Y = SPBYHFELRFS [ j ] [ 1 ]
<operator>.assignment j = 0
<operator>.addition i + 1
<operator>.subtraction no - 2
<operator>.lessThan k < no - 1
<operator>.postIncrement k ++
<operator>.modulo ( A * X + B ) % M
<operator>.modulo ( C * Y + D ) % M
<operator>.assignment k = j + 1
<operator>.addition A * X + B
<operator>.addition C * Y + D
<operator>.subtraction no - 1
<operator>.lessThan l < no
<operator>.postIncrement l ++
<operator>.multiplication A * X
<operator>.multiplication C * Y
<operator>.addition j + 1
<operator>.assignment l = k + 1
<operator>.assignment TBFPTH [ 0 ] = ( SPBYHFELRFS [ j ] [ 0 ] + SPBYHFELRFS [ k ] [ 0 ] + SPBYHFELRFS [ l ] [ 0 ] ) / 3.0
<operator>.assignment TBFPTH [ 1 ] = ( SPBYHFELRFS [ j ] [ 1 ] + SPBYHFELRFS [ k ] [ 1 ] + SPBYHFELRFS [ l ] [ 1 ] ) / 3.0
<operator>.logicalAnd ( TBFPTH [ 0 ] == ( int ) TBFPTH [ 0 ] ) && ( TBFPTH [ 1 ] == ( int ) TBFPTH [ 1 ] )
<operator>.addition k + 1
<operator>.division ( SPBYHFELRFS [ j ] [ 0 ] + SPBYHFELRFS [ k ] [ 0 ] + SPBYHFELRFS [ l ] [ 0 ] ) / 3.0
<operator>.division ( SPBYHFELRFS [ j ] [ 1 ] + SPBYHFELRFS [ k ] [ 1 ] + SPBYHFELRFS [ l ] [ 1 ] ) / 3.0
<operator>.postIncrement BDNRO [ i ] ++
<operator>.addition SPBYHFELRFS [ j ] [ 0 ] + SPBYHFELRFS [ k ] [ 0 ] + SPBYHFELRFS [ l ] [ 0 ]
<operator>.addition SPBYHFELRFS [ j ] [ 1 ] + SPBYHFELRFS [ k ] [ 1 ] + SPBYHFELRFS [ l ] [ 1 ]
<operator>.equals TBFPTH [ 0 ] == ( int ) TBFPTH [ 0 ]
<operator>.equals TBFPTH [ 1 ] == ( int ) TBFPTH [ 1 ]
<operator>.addition SPBYHFELRFS [ j ] [ 0 ] + SPBYHFELRFS [ k ] [ 0 ]
<operator>.addition SPBYHFELRFS [ j ] [ 1 ] + SPBYHFELRFS [ k ] [ 1 ]
<operator>.cast ( int ) TBFPTH [ 0 ]
<operator>.cast ( int ) TBFPTH [ 1 ]
<operator>.addressOf & LHUTP
<operator>.indirectIndexAccess argv [ 1 ]
<operator>.indirectIndexAccess argv [ 2 ]
<operator>.addressOf & no
<operator>.addressOf & A
<operator>.addressOf & B
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & x0
<operator>.addressOf & y0
<operator>.addressOf & M
<operator>.indirectIndexAccess SPBYHFELRFS [ 0 ] [ 0 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ 0 ] [ 1 ]
<operator>.indirectIndexAccess BDNRO [ i ]
<operator>.indirectIndexAccess SPBYHFELRFS [ 0 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ 0 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ] [ 0 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ] [ 1 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ] [ 0 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ] [ 1 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ]
<operator>.indirectIndexAccess TBFPTH [ 0 ]
<operator>.indirectIndexAccess TBFPTH [ 1 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ l ] [ 0 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ l ] [ 1 ]
<operator>.indirectIndexAccess TBFPTH [ 0 ]
<operator>.indirectIndexAccess TBFPTH [ 1 ]
<operator>.indirectIndexAccess BDNRO [ i ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ] [ 0 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ k ] [ 0 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ l ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ] [ 1 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ k ] [ 1 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ l ]
UNKNOWN int int
<operator>.indirectIndexAccess TBFPTH [ 0 ]
UNKNOWN int int
<operator>.indirectIndexAccess TBFPTH [ 1 ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ]
<operator>.indirectIndexAccess SPBYHFELRFS [ k ]
<operator>.indirectIndexAccess SPBYHFELRFS [ j ]
<operator>.indirectIndexAccess SPBYHFELRFS [ k ]
>>>PDG&148 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->22 0->23 0->24 0->26 0->27 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->91 0->92 0->93 2->23 3->1 3->41 3->42 4->1 4->1 4->30 4->36 5->1 5->1 5->1 6->1 6->1 6->46 6->62 7->1 7->1 7->51 7->55 8->1 8->1 8->52 8->56 9->1 9->1 10->1 10->1 11->1 11->1 11->47 11->84 12->1 12->1 12->48 12->76 12->79 13->1 13->1 13->49 13->85 14->1 14->1 14->50 14->77 14->80 15->1 15->1 15->53 15->76 16->1 16->1 17->1 17->1 18->1 18->1 19->1 19->1 20->1 20->1 20->60 20->94 21->1 21->1 21->1 21->97 21->98 21->101 21->102 22->1 23->1 23->1 23->22 23->28 23->29 23->35 23->40 23->41 23->42 23->104 23->105 24->22 25->5 26->20 27->21 28->1 28->1 28->35 29->1 29->1 29->1 29->33 29->60 30->31 30->36 30->38 31->32 31->46 34->25 35->1 35->1 35->1 35->22 35->30 35->30 35->31 35->32 35->33 35->36 35->38 35->43 35->44 35->45 35->59 35->61 35->103 36->36 36->37 36->37 36->38 36->46 36->47 36->48 36->49 36->50 36->51 36->52 36->53 36->54 36->55 36->56 36->57 36->58 36->62 36->64 36->66 36->71 36->73 36->106 36->107 36->108 36->109 36->110 36->111 36->112 36->113 36->114 36->115 36->117 36->118 37->36 38->38 38->39 38->39 38->60 38->60 38->72 38->72 38->116 39->38 41->1 41->28 41->28 42->1 42->29 42->29 43->1 44->1 45->36 46->47 46->62 46->73 46->81 46->82 47->48 47->84 48->49 48->76 48->79 49->50 49->85 50->51 50->77 50->80 51->52 51->55 51->57 52->53 52->56 52->58 53->54 53->76 53->77 54->32 54->46 57->84 58->85 59->38 60->33 61->1 61->44 62->62 62->63 62->63 62->67 62->68 62->69 62->70 62->73 62->76 62->77 62->79 62->80 62->84 62->85 62->119 62->120 62->121 62->122 62->123 62->124 62->125 62->126 63->62 64->64 64->65 64->65 64->73 64->74 64->78 64->78 64->81 64->86 64->86 65->64 66->62 67->69 67->92 67->95 67->99 68->70 68->93 68->96 68->100 69->84 70->85 71->64 73->46 73->62 73->64 73->64 73->81 74->74 74->75 74->75 74->81 74->82 74->87 74->87 74->91 74->91 75->74 76->67 76->67 76->77 77->53 77->68 77->68 77->76 78->74 81->73 81->74 81->74 81->82 82->81 82->82 82->83 82->83 82->88 82->89 82->90 82->92 82->93 82->95 82->96 82->97 82->99 82->100 82->101 82->127 82->128 82->129 82->130 82->131 82->134 82->135 82->136 82->137 82->138 82->139 82->140 82->141 82->144 82->145 82->146 82->147 83->82 84->47 84->76 84->76 84->79 84->79 85->49 85->77 85->77 85->80 85->80 87->82 88->97 88->101 89->98 89->102 90->94 90->133 92->88 92->88 93->89 93->89 94->60 97->90 97->90 97->98 97->102 97->132 97->142 97->143 98->90 98->90
>>>Token int main ( int argc , char * * argv ) { BHIU * ROLGJO ; BHIU * TQYNGTK ; int LHUTP = 0 ; long long SPBYHFELRFS [ n ] [ 2 ] = { { 0 } } ; int no = 0 ; long long x0 = 0 , y0 = 0 ; long long X = 0 , Y = 0 ; long long A = 0 ; long long B = 0 ; long long C = 0 ; long long D = 0 ; long long M = 0 ; int i = 0 ; int j = 0 ; int k = 0 ; int l = 0 ; int BDNRO [ N ] = { 0 } ; long double TBFPTH [ 2 ] = { 0 } ; if ( argc == 3 ) { ROLGJO = DABNL ( argv [ 1 ] , " " ) ; TQYNGTK = DABNL ( argv [ 2 ] , " " ) ; if ( ROLGJO == NULL ) { printf ( " " ) ; return - 1 ; } IJHACX ( ROLGJO , " " , & LHUTP ) ; BEHGK ( ROLGJO ) ; for ( i = 0 ; i < LHUTP ; i ++ ) { IJHACX ( ROLGJO , " " , & no ) ; IJHACX ( ROLGJO , " " , & A ) ; IJHACX ( ROLGJO , " " , & B ) ; IJHACX ( ROLGJO , " " , & C ) ; IJHACX ( ROLGJO , " " , & D ) ; IJHACX ( ROLGJO , " " , & x0 ) ; IJHACX ( ROLGJO , " " , & y0 ) ; IJHACX ( ROLGJO , " " , & M ) ; BEHGK ( ROLGJO ) ; SPBYHFELRFS [ 0 ] [ 0 ] = x0 ; SPBYHFELRFS [ 0 ] [ 1 ] = y0 ; X = x0 ; Y = y0 ; for ( j = 1 ; j < no ; j ++ ) { SPBYHFELRFS [ j ] [ 0 ] = ( A * X + B ) % M ; SPBYHFELRFS [ j ] [ 1 ] = ( C * Y + D ) % M ; X = SPBYHFELRFS [ j ] [ 0 ] ; Y = SPBYHFELRFS [ j ] [ 1 ] ; } for ( j = 0 ; j < no - 2 ; j ++ ) { for ( k = j + 1 ; k < no - 1 ; k ++ ) { for ( l = k + 1 ; l < no ; l ++ ) { TBFPTH [ 0 ] = ( SPBYHFELRFS [ j ] [ 0 ] + SPBYHFELRFS [ k ] [ 0 ] + SPBYHFELRFS [ l ] [ 0 ] ) / 3.0 ; TBFPTH [ 1 ] = ( SPBYHFELRFS [ j ] [ 1 ] + SPBYHFELRFS [ k ] [ 1 ] + SPBYHFELRFS [ l ] [ 1 ] ) / 3.0 ; if ( ( TBFPTH [ 0 ] == ( int ) TBFPTH [ 0 ] ) && ( TBFPTH [ 1 ] == ( int ) TBFPTH [ 1 ] ) ) { BDNRO [ i ] ++ ; } } } } } for ( i = 0 ; i < LHUTP ; i ++ ) { fprintf ( TQYNGTK , " \n " , ( i + 1 ) , BDNRO [ i ] ) ; } SBPOCS ( ROLGJO ) ; SBPOCS ( TQYNGTK ) ; } else { printf ( " " ) ; } return 0 ; }
>>>Func
METHOD YNFY
METHOD_RETURN int
PARAM char * IXC
<operator>.assignment OXV = strlen ( IXC ) - 1
RETURN return 0 ; return 0 ;
<operator>.lessThan i < ( strlen ( IXC ) / 2 )
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.subtraction strlen ( IXC ) - 1
<operator>.assignment i = 0
<operator>.assignment t = IXC [ i ]
<operator>.assignment IXC [ i ] = IXC [ OXV ]
<operator>.assignment IXC [ OXV ] = t
<operator>.postDecrement OXV --
strlen strlen ( IXC )
<operator>.division strlen ( IXC ) / 2
strlen strlen ( IXC )
<operator>.indirectIndexAccess IXC [ i ]
<operator>.indirectIndexAccess IXC [ i ]
<operator>.indirectIndexAccess IXC [ OXV ]
<operator>.indirectIndexAccess IXC [ OXV ]
>>>PDG&21 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->12 0->13 0->14 0->15 0->16 2->14 3->1 3->1 3->1 3->13 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->10 5->11 5->12 5->13 5->15 5->16 5->17 5->18 5->19 5->20 6->1 6->5 7->4 8->3 8->3 9->1 9->5 10->1 10->12 11->1 11->1 11->10 11->16 12->1 12->1 12->1 12->11 12->16 13->1 13->1 14->8 14->16 15->1 15->5 15->5 16->1 16->10 16->11 16->15
>>>Token int YNFY ( char * IXC ) { int OXV = strlen ( IXC ) - 1 ; char t ; for ( int i = 0 ; i < ( strlen ( IXC ) / 2 ) ; i ++ ) { t = IXC [ i ] ; IXC [ i ] = IXC [ OXV ] ; IXC [ OXV ] = t ; OXV -- ; } return 0 ; }
>>>Func
METHOD XASXLS
METHOD_RETURN IUKG
PARAM IUKG * LASU
PARAM double NQCLA
PARAM int MTK
<operator>.equals LASU == NULL
<operator>.greaterThan MTK > 0
<operator>.assignment LASU = QMBRMS ( NQCLA )
RETURN return LASU ; return LASU ;
<operator>.assignment * JFW = LASU
<operator>.assignment * TAH = JFW
<operator>.assignment CAHU = 1
<operator>.assignment BUOMX = 1
<operator>.assignment JJLC = 0
RETURN return LASU ; return LASU ;
IDENTIFIER LASU return LASU ;
<operator>.notEquals TAH != NULL
<operator>.equals MTK == 1
<operator>.greaterThan JJLC + 2 > MTK
IDENTIFIER LASU return LASU ;
QMBRMS QMBRMS ( NQCLA )
<operator>.postIncrement JJLC ++
<operator>.assignment TAH = TAH -> MWCB
<operator>.assignment * SMUFPOSI = QMBRMS ( NQCLA )
<operator>.assignment SMUFPOSI -> MWCB = JFW
<operator>.assignment JFW -> AAHT = SMUFPOSI
<operator>.assignment LASU = SMUFPOSI
RETURN return LASU ; return LASU ;
<operator>.assignment * SMUFPOSI = ( IUKG * ) malloc ( sizeof ( IUKG ) )
<operator>.assignment SMUFPOSI -> NQCLA = NQCLA
IDENTIFIER LASU return LASU ;
<operator>.addition JJLC + 2
<operator>.logicalAnd JFW -> MWCB != NULL && BUOMX < MTK
<operator>.equals CAHU == MTK
<operator>.lessThan CAHU < MTK
QMBRMS QMBRMS ( NQCLA )
<operator>.postIncrement CAHU ++
<operator>.postIncrement BUOMX ++
<operator>.assignment JFW = JFW -> MWCB
<operator>.assignment JFW -> AAHT -> MWCB = SMUFPOSI
<operator>.assignment SMUFPOSI -> MWCB = JFW
<operator>.assignment SMUFPOSI -> AAHT = JFW -> AAHT
<operator>.assignment JFW -> AAHT = SMUFPOSI
<operator>.assignment SMUFPOSI -> MWCB = JFW -> MWCB
<operator>.assignment SMUFPOSI -> AAHT = JFW
<operator>.assignment JFW -> MWCB = SMUFPOSI
<operator>.notEquals JFW -> MWCB != NULL
<operator>.lessThan BUOMX < MTK
<operator>.sizeOf sizeof ( IUKG )
<operator>.indirectFieldAccess TAH -> MWCB
<operator>.indirectFieldAccess SMUFPOSI -> MWCB
<operator>.indirectFieldAccess JFW -> AAHT
<operator>.cast ( IUKG * ) malloc ( sizeof ( IUKG ) )
<operator>.indirectFieldAccess SMUFPOSI -> NQCLA
FIELD_IDENTIFIER MWCB MWCB
FIELD_IDENTIFIER MWCB MWCB
FIELD_IDENTIFIER AAHT AAHT
UNKNOWN IUKG * IUKG *
malloc malloc ( sizeof ( IUKG ) )
FIELD_IDENTIFIER NQCLA NQCLA
<operator>.indirectFieldAccess JFW -> MWCB
<operator>.indirectFieldAccess JFW -> MWCB
<operator>.indirectFieldAccess JFW -> AAHT -> MWCB
<operator>.indirectFieldAccess SMUFPOSI -> MWCB
<operator>.indirectFieldAccess SMUFPOSI -> AAHT
<operator>.indirectFieldAccess JFW -> AAHT
<operator>.indirectFieldAccess JFW -> AAHT
<operator>.indirectFieldAccess SMUFPOSI -> MWCB
<operator>.indirectFieldAccess JFW -> MWCB
<operator>.indirectFieldAccess SMUFPOSI -> AAHT
<operator>.indirectFieldAccess JFW -> MWCB
FIELD_IDENTIFIER MWCB MWCB
FIELD_IDENTIFIER MWCB MWCB
<operator>.indirectFieldAccess JFW -> AAHT
FIELD_IDENTIFIER MWCB MWCB
FIELD_IDENTIFIER MWCB MWCB
FIELD_IDENTIFIER AAHT AAHT
FIELD_IDENTIFIER AAHT AAHT
FIELD_IDENTIFIER AAHT AAHT
FIELD_IDENTIFIER MWCB MWCB
FIELD_IDENTIFIER MWCB MWCB
FIELD_IDENTIFIER AAHT AAHT
FIELD_IDENTIFIER MWCB MWCB
FIELD_IDENTIFIER AAHT AAHT
>>>PDG&84 0->2 0->3 0->4 0->5 0->6 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->24 0->25 0->26 0->29 0->30 0->31 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->42 0->44 0->45 0->46 0->47 2->5 3->20 3->29 3->35 4->1 4->6 5->1 5->1 5->6 5->7 5->8 5->9 5->16 5->19 5->20 6->9 6->10 6->11 6->12 6->13 6->16 6->17 6->17 7->1 7->1 7->1 7->15 8->1 9->10 9->24 9->40 9->44 10->16 11->33 11->36 12->37 12->47 13->18 13->21 13->31 14->1 15->8 16->16 16->21 16->22 16->46 16->49 16->54 17->14 17->18 17->18 17->23 17->24 17->25 17->26 17->27 17->31 17->35 17->50 17->51 17->55 17->56 18->28 18->29 18->32 18->33 18->33 18->34 18->46 18->47 18->48 18->52 18->53 18->57 18->58 18->59 18->60 18->71 19->14 20->1 20->7 21->18 21->31 22->16 23->25 23->26 26->30 27->1 28->39 28->42 28->45 30->27 32->32 32->36 32->37 32->38 32->46 32->60 32->61 32->71 32->72 33->34 33->34 33->39 33->40 33->41 33->42 33->62 33->63 33->64 33->65 33->66 33->73 33->74 33->75 33->76 33->77 33->78 33->83 34->43 34->44 34->45 34->67 34->68 34->69 34->70 34->79 34->80 34->81 34->82 35->23 36->33 37->47 38->40 38->44 46->32 46->32 46->38 46->43 46->47 47->32 47->32 47->33 47->37 48->1
>>>Token IUKG * XASXLS ( IUKG * LASU , double NQCLA , int MTK ) { if ( LASU == NULL ) { LASU = QMBRMS ( NQCLA ) ; return LASU ; } if ( MTK > 0 ) { IUKG * JFW = LASU , * TAH = JFW ; int CAHU = 1 , BUOMX = 1 , JJLC = 0 ; while ( TAH != NULL ) { JJLC ++ ; TAH = TAH -> MWCB ; } if ( MTK == 1 ) { IUKG * SMUFPOSI = QMBRMS ( NQCLA ) ; SMUFPOSI -> MWCB = JFW ; JFW -> AAHT = SMUFPOSI ; LASU = SMUFPOSI ; return LASU ; } if ( JJLC + 2 > MTK ) { while ( JFW -> MWCB != NULL && BUOMX < MTK ) { CAHU ++ ; BUOMX ++ ; JFW = JFW -> MWCB ; } IUKG * SMUFPOSI = ( IUKG * ) malloc ( sizeof ( IUKG ) ) ; SMUFPOSI -> NQCLA = NQCLA ; if ( CAHU == MTK ) { JFW -> AAHT -> MWCB = SMUFPOSI ; SMUFPOSI -> MWCB = JFW ; SMUFPOSI -> AAHT = JFW -> AAHT ; JFW -> AAHT = SMUFPOSI ; } if ( CAHU < MTK ) { SMUFPOSI -> MWCB = JFW -> MWCB ; SMUFPOSI -> AAHT = JFW ; JFW -> MWCB = SMUFPOSI ; } } return LASU ; } }
>>>Func
METHOD main
METHOD_RETURN int
NBKEM NBKEM ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= T
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 1
<operator>.assignment OMMF = 0
NBKEM NBKEM ( "%lld %lld %lld" , & n , & pd , & pg )
printf printf ( "Case #%d: %s\n" , t , OMMF ? "Possible" : "Broken" )
<operator>.logicalOr pg == 100 || pg == 0
<operator>.assignment OMMF = ( pd == pg )
<operator>.conditional OMMF ? "Possible" : "Broken"
<operator>.equals pg == 100
<operator>.equals pg == 0
<operator>.equals pd == pg
<operator>.greaterEqualsThan n >= 100
<operator>.assignment OMMF = 1
<operator>.lessEqualsThan d <= n
<operator>.postIncrement d ++
<operator>.assignment d = 1
<operator>.equals ( d * pd ) % 100 == 0
<operator>.assignment OMMF = 1
<operator>.modulo ( d * pd ) % 100
<operator>.multiplication d * pd
<operator>.addressOf & n
<operator>.addressOf & pd
<operator>.addressOf & pg
>>>PDG&29 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->10 4->11 4->13 4->14 4->26 4->27 4->28 5->1 5->4 6->3 7->1 7->4 8->1 9->1 9->1 9->1 9->1 9->14 9->15 9->16 9->16 9->17 9->19 9->25 10->1 10->1 10->5 11->1 11->1 11->1 11->12 11->16 11->17 12->1 12->1 13->1 14->1 14->9 14->11 14->11 14->15 14->15 14->16 15->1 15->9 15->11 15->11 15->14 15->16 16->1 16->1 16->9 16->9 16->12 16->12 16->14 16->25 17->1 17->1 17->9 17->18 17->19 17->19 17->21 18->1 19->1 19->1 19->1 19->9 19->17 19->19 19->20 19->22 19->24 19->25 19->25 20->1 20->19 21->1 21->19 22->1 22->1 22->23 23->1 24->1 24->22 24->22 25->1 25->9 25->16 25->20 25->24 25->24
>>>Token int main ( ) { int T ; NBKEM ( " " , & T ) ; for ( int t = 1 ; t <= T ; t ++ ) { int OMMF = 0 ; unsigned long long n , pd , pg ; NBKEM ( " " , & n , & pd , & pg ) ; if ( pg == 100 || pg == 0 ) OMMF = ( pd == pg ) ; else if ( n >= 100 ) OMMF = 1 ; else for ( int d = 1 ; d <= n ; d ++ ) if ( ( d * pd ) % 100 == 0 ) OMMF = 1 ; printf ( " \n " , t , OMMF ? " " : " " ) ; } return 0 ; }
>>>Func
METHOD YMRFPOGDPJYB
METHOD_RETURN void
PARAM int QUP [ 10 ] [ 10 ]
PARAM int GFWO
<operator>.assignment BGC = MNXRHY - 'A'
<operator>.assignmentMinus GXMR -= 1
<operator>.equals GFWO == 1
<operator>.equals GFWO == 1
<operator>.equals KRXXM == 'H'
<operator>.equals KRXXM == 'V'
DPBMT DPBMT ( "%d %c" , & GXMR , & MNXRHY )
<operator>.subtraction MNXRHY - 'A'
<operator>.logicalOr SXUTPSJVXIKEJWXXMWQT ( GXMR , MNXRHY ) != 1 || XDOVBDCRGQNYOIUE ( QUP   GFWO   ( GXMR - 1 )   ( MNXRHY - 65 ) , 'H' ) != 1
DPBMT DPBMT ( "%d %c %c" , & GXMR , & MNXRHY , & KRXXM )
<operator>.lessThan j < ( BGC + GFWO )
<operator>.postIncrement j ++
<operator>.lessThan a < ( GXMR + GFWO + 1 )
<operator>.postIncrement a ++
<operator>.lessThan j < ( BGC + GFWO )
<operator>.postIncrement j ++
<operator>.equals GFWO == 3
<operator>.lessThan j < ( GXMR + GFWO )
<operator>.postIncrement j ++
<operator>.equals GFWO == 3
printf printf ( "Position unavailable!\n" )
DPBMT DPBMT ( "%d %c" , & GXMR , & MNXRHY )
<operator>.logicalOr SXUTPSJVXIKEJWXXMWQT ( GXMR , MNXRHY ) == 0 || XDOVBDCRGQNYOIUE ( QUP   GFWO   ( GXMR - 1 )   ( MNXRHY - 65 ) , KRXXM ) == 0
<operator>.assignment j = BGC
<operator>.assignment QUP [ GXMR ] [ j ] = GFWO
<operator>.assignment a = GXMR - 1
<operator>.assignment j = BGC
<operator>.assignment QUP [ GXMR ] [ j ] = GFWO
<operator>.assignment j = GXMR
<operator>.assignment QUP [ j ] [ BGC ] = GFWO
<operator>.notEquals SXUTPSJVXIKEJWXXMWQT ( GXMR , MNXRHY ) != 1
<operator>.notEquals XDOVBDCRGQNYOIUE ( QUP   GFWO   ( GXMR - 1 )   ( MNXRHY - 65 ) , 'H' ) != 1
printf printf ( "Position unavailable!\n" )
DPBMT DPBMT ( "%d %c %c" , & GXMR , & MNXRHY , & KRXXM )
<operator>.addition BGC + GFWO
<operator>.addition GXMR + GFWO + 1
<operator>.lessThan b < ( BGC + GFWO + 1 )
<operator>.postIncrement b ++
<operator>.addition BGC + GFWO
<operator>.lessThan a < ( GXMR + GFWO - 1 )
<operator>.postIncrement a ++
<operator>.addition GXMR + GFWO
<operator>.lessThan a < ( GXMR + GFWO + 1 )
<operator>.postIncrement a ++
SXUTPSJVXIKEJWXXMWQT SXUTPSJVXIKEJWXXMWQT ( GXMR , MNXRHY )
XDOVBDCRGQNYOIUE XDOVBDCRGQNYOIUE ( QUP   GFWO   ( GXMR - 1 )   ( MNXRHY - 65 ) , 'H' )
<operator>.equals SXUTPSJVXIKEJWXXMWQT ( GXMR , MNXRHY ) == 0
<operator>.equals XDOVBDCRGQNYOIUE ( QUP   GFWO   ( GXMR - 1 )   ( MNXRHY - 65 ) , KRXXM ) == 0
<operator>.subtraction GXMR - 1
<operator>.addition GXMR + GFWO
<operator>.assignment b = BGC - 1
<operator>.assignment a = GXMR - 1
<operator>.lessThan a < ( GXMR + GFWO )
<operator>.postIncrement a ++
<operator>.assignment a = GXMR - 1
<operator>.lessThan a < ( GXMR + GFWO + 1 )
<operator>.postIncrement a ++
<operator>.subtraction GXMR - 1
<operator>.subtraction MNXRHY - 65
SXUTPSJVXIKEJWXXMWQT SXUTPSJVXIKEJWXXMWQT ( GXMR , MNXRHY )
XDOVBDCRGQNYOIUE XDOVBDCRGQNYOIUE ( QUP   GFWO   ( GXMR - 1 )   ( MNXRHY - 65 ) , KRXXM )
<operator>.addition BGC + GFWO + 1
<operator>.logicalAnd a >= 0 && a <= 9 && b >= 0 && b <= 9
<operator>.subtraction GXMR + GFWO - 1
<operator>.lessThan b < ( BGC + GFWO + 1 )
<operator>.postIncrement b ++
<operator>.assignment a = GXMR - 1
<operator>.addition GXMR + GFWO + 1
<operator>.lessThan b < ( BGC + GFWO - 1 )
<operator>.postIncrement b ++
<operator>.assignment a = GXMR - 1
<operator>.subtraction GXMR - 1
<operator>.subtraction MNXRHY - 65
<operator>.subtraction BGC - 1
<operator>.addition BGC + GFWO
<operator>.subtraction GXMR - 1
<operator>.addition GXMR + GFWO
<operator>.assignment b = BGC - 1
<operator>.addition GXMR + GFWO
<operator>.lessThan b < ( BGC + GFWO + 1 )
<operator>.postIncrement b ++
<operator>.subtraction GXMR - 1
<operator>.addition GXMR + GFWO
<operator>.assignment b = BGC - 1
<operator>.addition GXMR + GFWO + 1
<operator>.lessThan b < ( BGC + GFWO )
<operator>.postIncrement b ++
<operator>.logicalAnd a >= 0 && a <= 9 && b >= 0
<operator>.lessEqualsThan b <= 9
<operator>.notEquals QUP [ a ] [ b ] != GFWO
<operator>.addition BGC + GFWO + 1
<operator>.logicalAnd a >= 0 && a <= 9 && b >= 0 && b <= 9
<operator>.subtraction GXMR - 1
<operator>.assignment b = BGC - 1
<operator>.subtraction BGC + GFWO - 1
<operator>.logicalAnd a >= 0 && a <= 9 && b >= 0 && b <= 9
<operator>.subtraction GXMR - 1
<operator>.addition GXMR + GFWO
<operator>.assignment b = BGC - 1
<operator>.logicalAnd a >= 0 && a <= 9
<operator>.greaterEqualsThan b >= 0
<operator>.assignment QUP [ a ] [ b ] = - 1
<operator>.subtraction BGC - 1
<operator>.addition BGC + GFWO
<operator>.addition BGC + GFWO + 1
<operator>.logicalAnd a >= 0 && a <= 9 && b >= 0 && b <= 9
<operator>.subtraction BGC - 1
<operator>.addition BGC + GFWO
<operator>.addition BGC + GFWO
<operator>.logicalAnd a >= 0 && a <= 9 && b >= 0 && b <= 9
<operator>.greaterEqualsThan a >= 0
<operator>.lessEqualsThan a <= 9
<operator>.logicalAnd a >= 0 && a <= 9 && b >= 0
<operator>.lessEqualsThan b <= 9
<operator>.notEquals QUP [ a ] [ b ] != GFWO
<operator>.subtraction BGC - 1
<operator>.addition BGC + GFWO
<operator>.logicalAnd a >= 0 && a <= 9 && b >= 0
<operator>.lessEqualsThan b <= 9
<operator>.notEquals QUP [ a ] [ b ] != GFWO
<operator>.subtraction BGC - 1
<operator>.minus - 1
<operator>.logicalAnd a >= 0 && a <= 9
<operator>.greaterEqualsThan b >= 0
<operator>.assignment QUP [ a ] [ b ] = - 1
<operator>.logicalAnd a >= 0 && a <= 9 && b >= 0
<operator>.lessEqualsThan b <= 9
<operator>.notEquals QUP [ a ] [ b ] != GFWO
<operator>.logicalAnd a >= 0 && a <= 9
<operator>.greaterEqualsThan b >= 0
<operator>.assignment QUP [ a ] [ b ] = - 1
<operator>.logicalAnd a >= 0 && a <= 9 && b >= 0
<operator>.lessEqualsThan b <= 9
<operator>.notEquals QUP [ a ] [ b ] != GFWO
<operator>.greaterEqualsThan a >= 0
<operator>.lessEqualsThan a <= 9
<operator>.logicalAnd a >= 0 && a <= 9
<operator>.greaterEqualsThan b >= 0
<operator>.assignment QUP [ a ] [ b ] = - 1
<operator>.greaterEqualsThan a >= 0
<operator>.lessEqualsThan a <= 9
<operator>.logicalAnd a >= 0 && a <= 9
<operator>.greaterEqualsThan b >= 0
<operator>.assignment QUP [ a ] [ b ] = - 1
<operator>.minus - 1
<operator>.greaterEqualsThan a >= 0
<operator>.lessEqualsThan a <= 9
<operator>.minus - 1
<operator>.greaterEqualsThan a >= 0
<operator>.lessEqualsThan a <= 9
<operator>.minus - 1
<operator>.minus - 1
<operator>.addressOf & GXMR
<operator>.addressOf & MNXRHY
<operator>.addressOf & GXMR
<operator>.addressOf & MNXRHY
<operator>.addressOf & KRXXM
<operator>.addressOf & GXMR
<operator>.addressOf & MNXRHY
<operator>.indirectIndexAccess QUP [ GXMR ] [ j ]
<operator>.indirectIndexAccess QUP [ GXMR ] [ j ]
<operator>.indirectIndexAccess QUP [ j ] [ BGC ]
<operator>.addressOf & GXMR
<operator>.addressOf & MNXRHY
<operator>.addressOf & KRXXM
<operator>.indirectIndexAccess QUP [ GXMR ]
<operator>.indirectIndexAccess QUP [ GXMR ]
<operator>.indirectIndexAccess QUP [ j ]
<operator>.indirectIndexAccess QUP [ a ] [ b ]
<operator>.indirectIndexAccess QUP [ a ]
<operator>.indirectIndexAccess QUP [ a ] [ b ]
<operator>.indirectIndexAccess QUP [ a ]
<operator>.indirectIndexAccess QUP [ a ] [ b ]
<operator>.indirectIndexAccess QUP [ a ] [ b ]
<operator>.indirectIndexAccess QUP [ a ]
<operator>.indirectIndexAccess QUP [ a ] [ b ]
<operator>.indirectIndexAccess QUP [ a ] [ b ]
<operator>.indirectIndexAccess QUP [ a ]
<operator>.indirectIndexAccess QUP [ a ] [ b ]
<operator>.indirectIndexAccess QUP [ a ] [ b ]
<operator>.indirectIndexAccess QUP [ a ]
<operator>.indirectIndexAccess QUP [ a ]
<operator>.indirectIndexAccess QUP [ a ] [ b ]
<operator>.indirectIndexAccess QUP [ a ]
<operator>.indirectIndexAccess QUP [ a ]
<operator>.indirectIndexAccess QUP [ a ] [ b ]
<operator>.indirectIndexAccess QUP [ a ]
<operator>.indirectIndexAccess QUP [ a ]
>>>PDG&192 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->28 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->56 0->57 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->67 0->68 0->69 0->71 0->72 0->73 0->75 0->76 0->77 0->78 0->79 0->80 0->82 0->83 0->84 0->85 0->86 0->88 0->89 0->90 0->92 0->93 0->94 0->96 0->98 0->100 0->101 0->104 0->106 0->107 0->108 0->110 0->111 0->112 0->114 0->115 0->117 0->118 0->119 0->120 0->122 0->123 0->124 0->125 0->127 0->130 0->131 0->133 0->136 0->137 0->138 0->139 0->141 0->143 0->144 0->146 0->148 0->149 0->150 0->151 0->152 0->153 0->154 0->155 2->1 2->49 2->64 3->6 4->1 4->1 4->1 4->14 4->18 4->27 4->30 4->38 4->42 4->77 4->106 4->110 4->119 4->124 5->1 5->21 5->32 5->45 5->52 5->79 5->85 5->96 5->100 6->7 6->10 6->12 6->13 6->26 6->34 6->48 6->49 6->50 6->63 6->64 6->156 6->157 6->158 6->159 6->160 7->1 7->14 7->14 7->16 7->16 7->18 7->20 7->21 7->23 7->27 7->29 7->38 7->38 7->39 7->39 7->42 7->45 7->52 7->53 7->53 8->1 8->9 8->18 8->20 8->30 8->42 9->1 9->1 9->21 9->23 9->32 9->45 10->1 10->1 10->1 10->5 10->11 10->16 10->21 10->25 10->25 10->32 10->39 10->45 10->46 10->48 10->48 10->52 10->53 10->56 10->59 10->61 10->62 10->67 10->71 10->79 10->80 10->82 10->85 10->86 10->88 10->96 10->100 10->101 11->1 11->4 11->4 12->1 12->1 12->1 12->12 12->24 12->25 12->34 12->48 12->161 12->162 13->1 13->1 13->1 13->1 13->5 13->8 13->9 13->11 13->16 13->21 13->32 13->37 13->37 13->37 13->39 13->45 13->46 13->52 13->53 13->56 13->59 13->63 13->63 13->64 13->67 13->71 13->75 13->76 13->79 13->80 13->82 13->85 13->86 13->88 13->96 13->100 13->101 14->1 14->1 14->14 14->15 14->15 14->28 14->38 14->163 14->169 15->1 15->14 16->16 16->17 16->17 16->39 16->40 16->53 16->54 16->65 16->77 16->78 16->114 17->1 17->16 18->1 18->1 18->18 18->19 18->19 18->31 18->42 18->164 18->170 19->1 19->18 20->21 20->23 20->43 20->45 20->55 20->56 20->56 20->67 20->67 20->70 20->79 20->80 20->80 20->82 20->82 20->96 21->1 21->1 21->21 21->22 21->22 21->33 21->45 21->165 21->171 22->1 22->21 23->1 23->46 23->46 23->58 23->59 23->59 23->71 23->71 23->74 23->85 23->86 23->86 23->88 23->88 23->100 23->101 23->101 25->1 25->1 25->1 25->5 25->11 25->16 25->21 25->32 25->39 25->45 25->46 25->48 25->48 25->52 25->53 25->56 25->59 25->61 25->62 25->67 25->71 25->79 25->80 25->82 25->85 25->86 25->88 25->96 25->100 25->101 26->1 26->1 26->1 26->26 26->36 26->37 26->50 26->63 26->166 26->167 26->168 27->1 27->14 29->16 30->1 30->18 32->1 32->21 34->1 34->12 34->12 34->35 34->49 34->61 34->62 35->1 35->12 35->12 37->1 37->1 37->1 37->1 37->5 37->8 37->9 37->11 37->16 37->21 37->32 37->39 37->45 37->46 37->52 37->53 37->56 37->59 37->63 37->63 37->64 37->67 37->71 37->75 37->76 37->79 37->80 37->82 37->85 37->86 37->88 37->96 37->100 37->101 38->1 40->40 40->41 40->41 40->65 40->66 40->78 40->91 40->92 40->103 40->104 40->114 41->40 42->1 43->1 43->1 43->43 43->44 43->44 43->67 43->68 43->80 43->81 43->94 43->106 43->107 43->138 44->1 44->43 46->1 46->1 46->1 46->46 46->47 46->47 46->71 46->72 46->86 46->87 46->98 46->110 46->111 46->143 47->1 47->46 48->5 48->11 48->25 48->25 48->34 48->34 48->61 48->62 49->1 49->1 49->7 49->35 49->35 49->35 49->35 49->35 50->1 50->26 50->26 50->51 50->64 50->75 50->76 51->1 51->26 51->26 52->16 52->21 52->29 52->29 52->32 52->39 52->45 52->53 52->79 52->85 52->96 52->100 54->40 55->43 56->1 56->56 56->57 56->57 56->82 56->83 56->97 56->108 56->119 56->120 56->149 57->1 57->56 58->1 58->1 58->46 59->59 59->60 59->60 59->88 59->89 59->101 59->102 59->112 59->124 59->152 60->59 61->5 61->25 61->48 61->49 61->49 62->11 62->25 62->48 62->49 62->49 63->5 63->11 63->37 63->37 63->50 63->50 63->75 63->76 64->1 64->1 64->7 64->8 64->37 64->51 64->51 64->51 64->51 64->51 66->93 66->95 66->99 66->109 66->113 66->172 66->173 67->43 67->43 68->68 68->69 68->69 68->94 68->95 68->107 68->116 68->117 68->126 68->127 68->138 69->68 70->56 71->1 72->72 72->73 72->73 72->98 72->99 72->111 72->121 72->122 72->132 72->133 72->143 73->72 74->59 75->5 75->37 75->63 75->64 75->64 76->11 76->37 76->63 76->64 76->64 77->18 77->30 77->40 77->42 77->54 77->54 77->65 77->78 77->106 77->110 77->119 77->124 79->21 79->32 79->45 79->55 79->55 79->67 79->80 79->85 79->100 81->68 83->83 83->84 83->84 83->108 83->109 83->120 83->129 83->130 83->140 83->141 83->149 84->83 85->46 85->58 85->58 85->71 85->86 86->1 86->1 87->72 89->89 89->90 89->90 89->112 89->113 89->135 89->136 89->145 89->146 89->152 90->89 91->66 91->66 91->92 91->116 91->121 91->129 91->135 92->41 92->66 92->66 93->16 93->18 93->20 93->21 93->23 93->39 93->40 93->42 93->45 93->53 93->65 93->78 93->105 93->118 93->123 93->125 93->131 93->137 93->174 93->175 95->99 95->113 95->118 95->176 95->178 96->21 96->32 96->45 96->56 96->70 96->70 96->82 96->85 96->100 97->83 98->72 98->72 99->123 99->177 99->181 100->59 100->74 100->74 100->88 100->101 102->89 103->91 103->91 103->104 103->126 103->132 103->140 103->145 104->41 104->91 104->91 104->92 105->93 105->118 105->123 105->131 105->137 106->68 106->81 106->81 106->94 106->107 106->110 106->124 109->99 109->113 109->131 109->180 109->185 110->87 110->87 110->98 110->111 113->137 113->183 113->188 114->17 114->103 114->103 114->115 114->115 115->17 115->103 115->103 115->114 116->95 116->95 116->117 116->121 116->135 117->69 117->95 117->95 118->21 118->23 118->45 118->67 118->68 118->80 118->94 118->107 118->123 118->128 118->137 118->148 118->179 118->184 119->83 119->97 119->97 119->108 119->110 119->120 119->124 121->99 121->99 121->122 122->73 122->99 122->99 123->46 123->71 123->86 123->98 123->111 123->134 123->151 123->182 123->187 124->89 124->102 124->102 124->112 125->105 126->116 126->116 126->127 126->132 126->145 127->69 127->116 127->116 127->117 128->118 128->123 128->137 129->109 129->109 129->121 129->130 129->135 130->84 130->109 130->109 131->21 131->23 131->45 131->56 131->82 131->83 131->108 131->120 131->123 131->137 131->142 131->154 131->186 131->190 132->121 132->121 132->133 133->73 133->121 133->121 133->122 134->123 135->113 135->113 135->136 136->90 136->113 136->113 137->59 137->88 137->89 137->101 137->112 137->147 137->155 137->189 137->191 138->44 138->126 138->126 138->139 138->139 139->44 139->126 139->126 139->138 140->129 140->129 140->132 140->141 140->145 141->84 141->129 141->129 141->130 142->123 142->131 142->137 143->47 143->132 143->132 143->144 143->144 144->47 144->132 144->132 144->143 145->135 145->135 145->146 146->90 146->135 146->135 146->136 147->137 148->128 149->57 149->140 149->140 149->150 149->150 150->57 150->140 150->140 150->149 151->134 152->60 152->145 152->145 152->153 152->153 153->60 153->145 153->145 153->152 154->142 155->147
>>>Token void YMRFPOGDPJYB ( int QUP [ 10 ] [ 10 ] , int GFWO ) { int GXMR , j ; char MNXRHY , KRXXM ; if ( GFWO == 1 ) { DPBMT ( " " , & GXMR , & MNXRHY ) ; while ( SXUTPSJVXIKEJWXXMWQT ( GXMR , MNXRHY ) != 1 || XDOVBDCRGQNYOIUE ( QUP , GFWO , ( GXMR - 1 ) , ( MNXRHY - 65 ) , ' ' ) != 1 ) { printf ( " \n " ) ; DPBMT ( " " , & GXMR , & MNXRHY ) ; } } else { DPBMT ( " " , & GXMR , & MNXRHY , & KRXXM ) ; while ( SXUTPSJVXIKEJWXXMWQT ( GXMR , MNXRHY ) == 0 || XDOVBDCRGQNYOIUE ( QUP , GFWO , ( GXMR - 1 ) , ( MNXRHY - 65 ) , KRXXM ) == 0 ) { printf ( " \n " ) ; DPBMT ( " " , & GXMR , & MNXRHY , & KRXXM ) ; } } int BGC = MNXRHY - ' ' ; GXMR -= 1 ; if ( GFWO == 1 ) { for ( j = BGC ; j < ( BGC + GFWO ) ; j ++ ) { QUP [ GXMR ] [ j ] = GFWO ; } for ( int a = GXMR - 1 ; a < ( GXMR + GFWO + 1 ) ; a ++ ) { for ( int b = BGC - 1 ; b < ( BGC + GFWO + 1 ) ; b ++ ) { if ( a >= 0 && a <= 9 && b >= 0 && b <= 9 ) { if ( QUP [ a ] [ b ] != GFWO ) { QUP [ a ] [ b ] = - 1 ; } } } } } if ( KRXXM == ' ' ) { for ( j = BGC ; j < ( BGC + GFWO ) ; j ++ ) { QUP [ GXMR ] [ j ] = GFWO ; } if ( GFWO == 3 ) { for ( int a = GXMR - 1 ; a < ( GXMR + GFWO - 1 ) ; a ++ ) { for ( int b = BGC - 1 ; b < ( BGC + GFWO + 1 ) ; b ++ ) { if ( a >= 0 && a <= 9 && b >= 0 && b <= 9 ) { if ( QUP [ a ] [ b ] != GFWO ) { QUP [ a ] [ b ] = - 1 ; } } } } } else { for ( int a = GXMR - 1 ; a < ( GXMR + GFWO ) ; a ++ ) { for ( int b = BGC - 1 ; b < ( BGC + GFWO + 1 ) ; b ++ ) { if ( a >= 0 && a <= 9 && b >= 0 && b <= 9 ) { if ( QUP [ a ] [ b ] != GFWO ) { QUP [ a ] [ b ] = - 1 ; } } } } } } if ( KRXXM == ' ' ) { for ( j = GXMR ; j < ( GXMR + GFWO ) ; j ++ ) { QUP [ j ] [ BGC ] = GFWO ; } if ( GFWO == 3 ) { for ( int a = GXMR - 1 ; a < ( GXMR + GFWO + 1 ) ; a ++ ) { for ( int b = BGC - 1 ; b < ( BGC + GFWO - 1 ) ; b ++ ) { if ( a >= 0 && a <= 9 && b >= 0 && b <= 9 ) { if ( QUP [ a ] [ b ] != GFWO ) { QUP [ a ] [ b ] = - 1 ; } } } } } else { for ( int a = GXMR - 1 ; a < ( GXMR + GFWO + 1 ) ; a ++ ) { for ( int b = BGC - 1 ; b < ( BGC + GFWO ) ; b ++ ) { if ( a >= 0 && a <= 9 && b >= 0 && b <= 9 ) { if ( QUP [ a ] [ b ] != GFWO ) { QUP [ a ] [ b ] = - 1 ; } } } } } } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment EXCPOKXIB = 0
<operator>.assignment k = 0
<operator>.assignment VVEQ = 0
<operator>.assignment RWPVJ = 0
<operator>.assignment k1 = 0
<operator>.assignment VSN = 0
<operator>.assignment NLS = 0
<operator>.assignment NII = 0
<operator>.assignment XDV = 0
TVWQD TVWQD ( "%d" , & EXCPOKXIB )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= EXCPOKXIB
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= EXCPOKXIB
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
TVWQD TVWQD ( "%d" , & NLS )
TVWQD TVWQD ( "%d" , & NII )
TVWQD TVWQD ( "%d" , & XDV )
<operator>.assignment i = 1
<operator>.assignment HKTK = n [ i ]
<operator>.assignment VSN = strlen ( HKTK )
<operator>.assignment ALUA [ 0 ] = n [ i ] [ 0 ]
<operator>.assignment ALUA [ VVEQ ] = '\0'
printf printf ( "Case #%d: [" , i )
printf printf ( "]\n" )
<operator>.expressionList VVEQ = 0   RWPVJ = 0
<operator>.notEquals NLS != 0
<operator>.notEquals NII != 0
<operator>.notEquals XDV != 0
<operator>.lessThan j < ( strlen ( HKTK ) )
<operator>.postIncrement j ++
<operator>.lessThan VVEQ < strlen ( HKTK )
<operator>.postIncrement VVEQ ++
TVWQD TVWQD ( "%s" , c [ i ] )
TVWQD TVWQD ( "%s" , d [ i ] )
TVWQD TVWQD ( "%s" , n [ i ] )
strlen strlen ( HKTK )
<operator>.assignment j = 1
<operator>.assignment VVEQ = 0
<operator>.assignment VVEQ = 0
<operator>.assignment RWPVJ = 0
strlen strlen ( HKTK )
<operator>.logicalOr ( ( HKTK [ j - 1 ] == c [ i ] [ 0 ] ) && ( HKTK [ j ] == c [ i ] [ 1 ] ) ) || ( ( HKTK [ j - 1 ] == c [ i ] [ 1 ] ) && ( HKTK [ j ] == c [ i ] [ 0 ] ) )
strlen strlen ( HKTK )
<operator>.equals HKTK [ VVEQ ] == ' '
<operator>.assignment k = j
<operator>.assignment HKTK [ j - 1 ] = c [ i ] [ 2 ]
<operator>.assignment k = 0
<operator>.logicalAnd ( HKTK [ j - 1 ] == c [ i ] [ 0 ] ) && ( HKTK [ j ] == c [ i ] [ 1 ] )
<operator>.logicalAnd ( HKTK [ j - 1 ] == c [ i ] [ 1 ] ) && ( HKTK [ j ] == c [ i ] [ 0 ] )
<operator>.lessEqualsThan k <= ( strlen ( HKTK ) - 1 )
<operator>.equals HKTK [ j - 1 ] == c [ i ] [ 0 ]
<operator>.equals HKTK [ j ] == c [ i ] [ 1 ]
<operator>.equals HKTK [ j - 1 ] == c [ i ] [ 1 ]
<operator>.equals HKTK [ j ] == c [ i ] [ 0 ]
<operator>.assignment HKTK [ k ] = HKTK [ k + 1 ]
<operator>.postIncrement k ++
<operator>.equals HKTK [ j ] == d [ i ] [ 1 ]
<operator>.equals VVEQ == strlen ( HKTK ) - 1
<operator>.subtraction j - 1
<operator>.subtraction strlen ( HKTK ) - 1
<operator>.assignment k = j - 1
printf printf ( "%c" , HKTK [ VVEQ ] )
<operator>.subtraction j - 1
<operator>.subtraction j - 1
strlen strlen ( HKTK )
<operator>.greaterEqualsThan k >= 0
<operator>.subtraction strlen ( HKTK ) - 1
printf printf ( "%c, " , HKTK [ VVEQ ] )
<operator>.addition k + 1
<operator>.subtraction j - 1
<operator>.postDecrement k --
<operator>.equals HKTK [ j ] == d [ i ] [ 0 ]
strlen strlen ( HKTK )
<operator>.equals HKTK [ k ] == d [ i ] [ 0 ]
<operator>.assignment k = j - 1
<operator>.assignment HKTK [ RWPVJ ] = '\0'
<operator>.assignment RWPVJ = 0
<operator>.greaterEqualsThan k >= 0
<operator>.lessThan k1 < VSN
<operator>.postIncrement k1 ++
<operator>.subtraction j - 1
<operator>.postDecrement k --
<operator>.assignment k1 = 0
<operator>.equals HKTK [ k ] == d [ i ] [ 1 ]
<operator>.logicalAnd k1 >= k && k1 <= j
<operator>.assignment HKTK [ RWPVJ ] = '\0'
<operator>.assignment RWPVJ = 0
<operator>.assignment HKTK [ RWPVJ ++ ] = ' '
<operator>.lessThan k1 < VSN
<operator>.postIncrement k1 ++
<operator>.greaterEqualsThan k1 >= k
<operator>.lessEqualsThan k1 <= j
<operator>.assignment HKTK [ RWPVJ ++ ] = n [ i ] [ k1 ]
<operator>.assignment k1 = 0
<operator>.logicalAnd k1 >= k && k1 <= j
<operator>.postIncrement RWPVJ ++
<operator>.assignment HKTK [ RWPVJ ++ ] = ' '
<operator>.postIncrement RWPVJ ++
<operator>.greaterEqualsThan k1 >= k
<operator>.lessEqualsThan k1 <= j
<operator>.assignment HKTK [ RWPVJ ++ ] = n [ i ] [ k1 ]
<operator>.postIncrement RWPVJ ++
<operator>.postIncrement RWPVJ ++
<operator>.addressOf & NLS
<operator>.addressOf & NII
<operator>.addressOf & XDV
<operator>.indirectIndexAccess n [ i ]
<operator>.indirectIndexAccess ALUA [ 0 ]
<operator>.indirectIndexAccess n [ i ] [ 0 ]
<operator>.indirectIndexAccess ALUA [ VVEQ ]
<operator>.indirectIndexAccess n [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess d [ i ]
<operator>.indirectIndexAccess n [ i ]
<operator>.indirectIndexAccess HKTK [ VVEQ ]
<operator>.indirectIndexAccess HKTK [ j - 1 ]
<operator>.indirectIndexAccess c [ i ] [ 2 ]
<operator>.indirectIndexAccess HKTK [ j - 1 ]
<operator>.indirectIndexAccess c [ i ] [ 0 ]
<operator>.indirectIndexAccess HKTK [ j ]
<operator>.indirectIndexAccess c [ i ] [ 1 ]
<operator>.indirectIndexAccess HKTK [ j - 1 ]
<operator>.indirectIndexAccess c [ i ] [ 1 ]
<operator>.indirectIndexAccess HKTK [ j ]
<operator>.indirectIndexAccess c [ i ] [ 0 ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess HKTK [ k ]
<operator>.indirectIndexAccess HKTK [ k + 1 ]
<operator>.indirectIndexAccess HKTK [ j ]
<operator>.indirectIndexAccess d [ i ] [ 1 ]
<operator>.indirectIndexAccess d [ i ]
<operator>.indirectIndexAccess HKTK [ VVEQ ]
<operator>.indirectIndexAccess HKTK [ VVEQ ]
<operator>.indirectIndexAccess HKTK [ j ]
<operator>.indirectIndexAccess d [ i ] [ 0 ]
<operator>.indirectIndexAccess HKTK [ k ]
<operator>.indirectIndexAccess d [ i ] [ 0 ]
<operator>.indirectIndexAccess d [ i ]
<operator>.indirectIndexAccess d [ i ]
<operator>.indirectIndexAccess HKTK [ RWPVJ ]
<operator>.indirectIndexAccess HKTK [ k ]
<operator>.indirectIndexAccess d [ i ] [ 1 ]
<operator>.indirectIndexAccess d [ i ]
<operator>.indirectIndexAccess HKTK [ RWPVJ ]
<operator>.indirectIndexAccess HKTK [ RWPVJ ++ ]
<operator>.indirectIndexAccess HKTK [ RWPVJ ++ ]
<operator>.indirectIndexAccess n [ i ] [ k1 ]
<operator>.indirectIndexAccess n [ i ]
<operator>.indirectIndexAccess HKTK [ RWPVJ ++ ]
<operator>.indirectIndexAccess HKTK [ RWPVJ ++ ]
<operator>.indirectIndexAccess n [ i ] [ k1 ]
<operator>.indirectIndexAccess n [ i ]
>>>PDG&161 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->47 0->48 0->49 0->51 0->54 0->60 0->62 0->63 0->64 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->77 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->98 0->100 0->101 0->102 0->103 0->104 0->106 0->107 2->1 2->11 2->13 3->1 3->1 4->1 4->1 5->1 5->1 5->100 5->102 5->106 5->107 6->1 6->1 7->1 7->1 8->1 8->1 8->19 8->30 9->1 9->1 9->20 9->31 10->1 10->1 10->21 10->32 11->1 11->1 11->13 11->15 12->1 13->13 13->14 13->14 13->15 13->19 13->20 13->21 13->30 13->31 13->32 13->108 13->109 13->110 14->1 14->13 15->1 15->1 15->1 15->15 15->16 15->23 15->24 15->25 15->26 15->27 15->27 15->28 15->29 15->33 15->35 15->40 15->41 15->42 15->43 15->44 15->45 15->47 15->111 15->112 15->113 15->114 15->115 16->1 16->15 17->12 18->13 19->1 19->1 19->30 20->1 20->1 20->31 21->1 21->1 21->32 22->1 22->15 23->1 23->1 23->40 24->1 24->1 24->83 24->93 25->1 25->1 25->1 26->1 26->1 27->1 27->16 28->1 29->1 29->1 29->1 30->1 30->1 30->19 30->37 30->116 31->1 31->1 31->20 31->38 31->117 32->1 32->1 32->21 32->39 32->118 33->1 33->1 33->33 33->34 33->45 33->46 33->52 33->55 33->67 33->67 33->122 33->123 33->131 34->1 34->33 35->1 35->1 35->35 35->36 35->47 35->48 35->62 35->62 35->71 35->77 35->119 36->1 36->35 37->1 37->1 38->1 38->1 39->1 39->1 39->23 40->24 40->45 41->1 41->33 42->35 43->1 43->29 44->1 44->29 44->100 44->102 44->106 44->107 45->33 45->47 45->55 45->56 45->57 45->58 45->61 45->69 45->76 45->78 45->88 46->1 46->1 46->1 46->49 46->50 46->51 46->54 46->61 46->63 46->64 46->69 46->120 46->121 46->130 46->137 46->138 46->139 47->1 47->35 47->48 47->77 48->1 48->66 48->72 48->77 49->1 49->54 50->1 50->1 50->1 50->40 50->45 50->47 50->55 50->69 50->77 51->1 51->1 52->1 52->1 52->46 52->46 52->53 52->57 52->68 52->126 52->127 52->133 53->1 53->1 53->46 53->46 54->1 54->1 54->54 54->59 54->60 54->60 54->64 54->69 54->73 54->73 54->135 54->136 55->1 55->1 55->40 55->45 55->47 55->52 55->52 55->56 55->57 55->58 55->77 55->124 55->125 55->132 56->1 56->1 56->40 56->45 56->47 56->52 56->52 56->57 56->58 56->61 56->69 56->77 57->1 57->1 57->40 57->45 57->47 57->53 57->53 57->55 57->56 57->58 57->77 57->128 57->129 57->134 58->1 58->1 58->40 58->45 58->47 58->53 58->53 58->55 58->56 58->61 58->69 58->77 59->1 59->1 59->1 59->40 59->45 59->47 59->69 59->77 59->78 59->88 60->1 60->54 61->1 61->1 61->1 61->40 61->45 61->47 61->56 61->58 61->65 61->69 61->70 61->74 61->76 61->76 61->77 61->88 61->142 61->143 61->146 62->1 62->1 62->36 62->66 62->72 62->140 62->141 63->34 64->54 64->54 65->1 65->1 65->70 66->1 66->1 66->40 66->45 66->47 66->48 66->69 67->34 67->49 67->63 67->68 67->74 67->85 68->34 68->49 68->63 68->74 68->85 69->40 69->45 69->47 69->59 69->64 69->77 70->1 70->1 70->75 70->78 70->95 70->144 70->145 70->147 71->62 71->62 72->1 72->1 72->40 72->45 72->47 72->48 72->69 74->34 74->65 74->65 74->96 75->1 75->70 76->1 76->1 76->1 76->40 76->45 76->47 76->56 76->58 76->61 76->69 76->77 76->78 76->79 76->82 76->85 77->47 77->66 77->71 77->72 78->1 78->1 78->1 78->40 78->45 78->47 78->69 78->70 78->75 78->76 78->77 78->80 78->81 78->83 78->87 78->88 78->148 79->1 79->1 79->82 80->1 80->1 80->40 80->45 80->47 80->69 80->77 81->100 81->102 81->106 81->107 82->1 82->1 82->86 82->88 82->103 82->149 82->150 82->151 83->1 83->1 83->1 83->83 83->84 83->89 83->93 83->95 83->95 84->1 84->83 85->34 85->79 85->79 85->104 86->1 86->82 87->1 87->83 88->1 88->1 88->1 88->40 88->45 88->47 88->61 88->69 88->77 88->78 88->82 88->86 88->90 88->91 88->93 88->98 88->152 89->1 89->1 89->1 89->92 89->97 89->99 89->100 89->102 89->153 89->154 89->155 89->156 90->1 90->1 90->40 90->45 90->47 90->69 90->77 91->100 91->102 91->106 91->107 92->1 92->1 92->40 92->45 92->47 92->69 92->77 93->1 93->1 93->1 93->83 93->93 93->94 93->99 93->103 93->103 94->1 94->93 95->1 95->84 95->89 95->89 95->96 95->96 96->34 96->84 96->89 96->89 97->1 97->1 97->1 97->40 97->45 97->47 97->69 97->77 98->1 98->93 99->1 99->1 99->1 99->89 99->101 99->105 99->106 99->107 99->157 99->158 99->159 99->160 100->102 101->1 101->1 101->40 101->45 101->47 101->69 101->77 102->100 103->1 103->94 103->99 103->99 103->104 103->104 104->34 104->94 104->99 104->99 105->1 105->1 105->1 105->40 105->45 105->47 105->69 105->77 106->107 107->106
>>>Token int main ( ) { int EXCPOKXIB = 0 ; char c [ 101 ] [ 5 ] , d [ 101 ] [ 4 ] , n [ 101 ] [ 12 ] ; int i , j , k = 0 , VVEQ = 0 , RWPVJ = 0 , k1 = 0 , VSN = 0 ; int NLS = 0 , NII = 0 , XDV = 0 ; char * HKTK , ALUA [ 12 ] ; TVWQD ( " " , & EXCPOKXIB ) ; for ( i = 1 ; i <= EXCPOKXIB ; i ++ ) { TVWQD ( " " , & NLS ) ; if ( NLS != 0 ) TVWQD ( " " , c [ i ] ) ; TVWQD ( " " , & NII ) ; if ( NII != 0 ) TVWQD ( " " , d [ i ] ) ; TVWQD ( " " , & XDV ) ; if ( XDV != 0 ) TVWQD ( " " , n [ i ] ) ; } for ( i = 1 ; i <= EXCPOKXIB ; i ++ ) { HKTK = n [ i ] ; VSN = strlen ( HKTK ) ; ALUA [ 0 ] = n [ i ] [ 0 ] ; for ( j = 1 ; j < ( strlen ( HKTK ) ) ; j ++ ) { if ( ( ( HKTK [ j - 1 ] == c [ i ] [ 0 ] ) && ( HKTK [ j ] == c [ i ] [ 1 ] ) ) || ( ( HKTK [ j - 1 ] == c [ i ] [ 1 ] ) && ( HKTK [ j ] == c [ i ] [ 0 ] ) ) ) { k = j ; HKTK [ j - 1 ] = c [ i ] [ 2 ] ; while ( k <= ( strlen ( HKTK ) - 1 ) ) { HKTK [ k ] = HKTK [ k + 1 ] ; k ++ ; } k = 0 ; } else if ( HKTK [ j ] == d [ i ] [ 1 ] ) { k = j - 1 ; while ( k >= 0 ) { if ( HKTK [ k ] == d [ i ] [ 0 ] ) { for ( k1 = 0 ; k1 < VSN ; k1 ++ ) { if ( ( k1 >= k && k1 <= j ) ) { HKTK [ RWPVJ ++ ] = ' ' ; } else { HKTK [ RWPVJ ++ ] = n [ i ] [ k1 ] ; } } HKTK [ RWPVJ ] = ' \0 ' ; RWPVJ = 0 ; break ; } k -- ; } } else if ( HKTK [ j ] == d [ i ] [ 0 ] ) { k = j - 1 ; while ( k >= 0 ) { if ( HKTK [ k ] == d [ i ] [ 1 ] ) { for ( k1 = 0 ; k1 < VSN ; k1 ++ ) { if ( ( k1 >= k && k1 <= j ) ) { HKTK [ RWPVJ ++ ] = ' ' ; } else { HKTK [ RWPVJ ++ ] = n [ i ] [ k1 ] ; } } HKTK [ RWPVJ ] = ' \0 ' ; RWPVJ = 0 ; break ; } k -- ; } } else { } } ALUA [ VVEQ ] = ' \0 ' ; printf ( " " , i ) ; for ( VVEQ = 0 ; VVEQ < strlen ( HKTK ) ; VVEQ ++ ) { if ( HKTK [ VVEQ ] == ' ' ) { } else { if ( VVEQ == strlen ( HKTK ) - 1 ) { printf ( " " , HKTK [ VVEQ ] ) ; } else { printf ( " " , HKTK [ VVEQ ] ) ; } } } printf ( " \n " ) ; VVEQ = 0 , RWPVJ = 0 ; } return 0 ; }
>>>Func
METHOD IUKGXASXLSLASUNQC
METHOD_RETURN char
PARAM long double LAMTK
<operator>.assignment QMBRMSJFWT = AHCAHUBU
<operator>.assignment QMBRMSJFWT = LAMTK
RETURN return 0 ; return 0 ;
<operator>.logicalOr OMXJJ ( QMBRMSJFWT - LAMTK ) <= LCMWCBSM || LAMTK < LCMWCBSM
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
<operator>.lessEqualsThan OMXJJ ( QMBRMSJFWT - LAMTK ) <= LCMWCBSM
<operator>.lessThan LAMTK < LCMWCBSM
LITERAL 1 return 1 ;
OMXJJ OMXJJ ( QMBRMSJFWT - LAMTK )
<operator>.subtraction QMBRMSJFWT - LAMTK
>>>PDG&14 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->13 2->13 3->1 3->1 3->13 5->1 6->1 6->1 6->1 6->4 6->5 6->8 7->5 8->1 9->1 9->1 9->6 9->6 9->10 9->10 10->1 10->1 10->4 10->6 10->6 11->8 12->1 12->9 13->1 13->1 13->4 13->10 13->12 13->12
>>>Token char IUKGXASXLSLASUNQC ( long double LAMTK ) { static long double QMBRMSJFWT = AHCAHUBU ; if ( OMXJJ ( QMBRMSJFWT - LAMTK ) <= LCMWCBSM || LAMTK < LCMWCBSM ) return 1 ; QMBRMSJFWT = LAMTK ; return 0 ; }
>>>Func
METHOD EOFXUTWHNSSVGLXKENLCNFORJEVBWHCE
METHOD_RETURN void
PARAM struct XKCSECDTWVPFHPQNDE * QSJH
assert assert ( QSJH != NULL )
<operator>.assignment QSJH -> LVLH = NULL
<operator>.assignment QSJH -> WKQC = NULL
<operator>.assignment QSJH -> QPMTKSXNOUJ = NULL
<operator>.assignment QSJH -> EATWSHCYA = NULL
<operator>.lessEqualsThan ii <= KIWCWSMRS
<operator>.postIncrement ii ++
<operator>.notEquals QSJH != NULL
<operator>.assignment ii = 1
<operator>.assignment QSJH -> BGNMNQIKJS [ ii - 1 ] = 0
<operator>.subtraction ii - 1
<operator>.indirectIndexAccess QSJH -> BGNMNQIKJS [ ii - 1 ]
<operator>.indirectFieldAccess QSJH -> BGNMNQIKJS
FIELD_IDENTIFIER BGNMNQIKJS BGNMNQIKJS
>>>PDG&17 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->10 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 7->1 8->1 8->1 8->1 8->8 8->9 8->12 8->13 8->13 8->14 8->15 8->16 9->1 9->8 10->1 10->3 10->3 10->4 10->5 10->6 10->7 11->1 11->8 13->9
>>>Token static void EOFXUTWHNSSVGLXKENLCNFORJEVBWHCE ( struct XKCSECDTWVPFHPQNDE * QSJH ) { assert ( QSJH != NULL ) ; QSJH -> LVLH = NULL ; QSJH -> WKQC = NULL ; QSJH -> QPMTKSXNOUJ = NULL ; QSJH -> EATWSHCYA = NULL ; for ( VJHJHUSGG ii = 1 ; ii <= KIWCWSMRS ; ii ++ ) { QSJH -> BGNMNQIKJS [ ii - 1 ] = 0 ; } }
>>>Func
METHOD main
METHOD_RETURN int
VQBAE VQBAE ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan it < T
<operator>.postIncrement it ++
LITERAL 0 return 0 ;
<operator>.assignment it = 0
<operator>.assignment KPDB = 0
VQBAE VQBAE ( "%d" , & C )
VQBAE VQBAE ( "%d" , & D )
VQBAE VQBAE ( "%d" , & N )
VQBAE VQBAE ( "%s" , YNFYI )
<operator>.assignment d1 = - 1
<operator>.assignment d2 = - 1
<operator>.assignment c1 = - 1
<operator>.assignment c2 = - 1
printf printf ( "Case #%d: [" , it + 1 )
printf printf ( "]\n" )
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.equals i + 1 == N
<operator>.lessThan i < KPDB
<operator>.postIncrement i ++
<operator>.assignment i = 0
VQBAE VQBAE ( "%s" , c )
<operator>.assignment i = 0
VQBAE VQBAE ( "%s" , d )
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.assignment i = 0
<operator>.assignment GENYEJ [ KPDB ++ ] = YNFYI [ i ]
<operator>.addition it + 1
<operator>.assignment i = 0
printf printf ( "%c" , GENYEJ [ i ] )
<operator>.greaterThan D > 0
<operator>.greaterThan C > 0
<operator>.notEquals c1 != - 1
<operator>.addition i + 1
<operator>.notEquals i != 0
<operator>.assignment GENYEJ [ KPDB ++ ] = c [ 2 ]
<operator>.postIncrement UICRO ++
<operator>.postIncrement i ++
<operator>.assignment c1 = - 1
printf printf ( ", " )
<operator>.logicalOr YNFYI [ i ] == d [ 0 ] || YNFYI [ i ] == d [ 1 ]
<operator>.logicalAnd YNFYI [ i ] == c [ 0 ] && YNFYI [ i + 1 ] == c [ 1 ] && i < N - 1
<operator>.minus - 1
<operator>.equals d1 == c1
<operator>.assignment GENYEJ [ KPDB ++ ] = YNFYI [ i ]
<operator>.postIncrement UICRO ++
<operator>.postIncrement KPDB ++
<operator>.assignment c1 = i
<operator>.assignment c2 = i + 1
<operator>.assignment d1 = - 1
<operator>.minus - 1
<operator>.equals YNFYI [ i ] == d [ 0 ]
<operator>.equals YNFYI [ i ] == d [ 1 ]
<operator>.equals d1 == - 1
<operator>.logicalAnd YNFYI [ i ] == c [ 0 ] && YNFYI [ i + 1 ] == c [ 1 ]
<operator>.lessThan i < N - 1
<operator>.postIncrement KPDB ++
<operator>.assignment d1 = i
<operator>.assignment dc = YNFYI [ i ]
<operator>.assignment UICRO = 0
<operator>.equals YNFYI [ i ] == c [ 0 ]
<operator>.equals YNFYI [ i + 1 ] == c [ 1 ]
<operator>.subtraction N - 1
<operator>.addition i + 1
<operator>.logicalAnd YNFYI [ i ] == c [ 1 ] && YNFYI [ i + 1 ] == c [ 0 ] && i < N - 1
<operator>.minus - 1
<operator>.postIncrement KPDB ++
<operator>.minus - 1
<operator>.assignment c1 = i
<operator>.assignment c2 = i + 1
<operator>.notEquals YNFYI [ i ] != dc
<operator>.addition i + 1
<operator>.logicalAnd YNFYI [ i ] == c [ 1 ] && YNFYI [ i + 1 ] == c [ 0 ]
<operator>.lessThan i < N - 1
<operator>.assignment d1 = - 1
<operator>.assignmentMinus KPDB -= UICRO
<operator>.equals YNFYI [ i ] == c [ 1 ]
<operator>.equals YNFYI [ i + 1 ] == c [ 0 ]
<operator>.subtraction N - 1
<operator>.addition i + 1
<operator>.minus - 1
<operator>.addition i + 1
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.indirectIndexAccess GENYEJ [ KPDB ++ ]
<operator>.indirectIndexAccess YNFYI [ i ]
<operator>.indirectIndexAccess GENYEJ [ i ]
<operator>.indirectIndexAccess GENYEJ [ KPDB ++ ]
<operator>.indirectIndexAccess c [ 2 ]
<operator>.indirectIndexAccess GENYEJ [ KPDB ++ ]
<operator>.indirectIndexAccess YNFYI [ i ]
<operator>.indirectIndexAccess YNFYI [ i ]
<operator>.indirectIndexAccess d [ 0 ]
<operator>.indirectIndexAccess YNFYI [ i ]
<operator>.indirectIndexAccess d [ 1 ]
<operator>.indirectIndexAccess YNFYI [ i ]
<operator>.indirectIndexAccess c [ 0 ]
<operator>.indirectIndexAccess YNFYI [ i + 1 ]
<operator>.indirectIndexAccess c [ 1 ]
<operator>.indirectIndexAccess YNFYI [ i ]
<operator>.indirectIndexAccess YNFYI [ i ]
<operator>.indirectIndexAccess YNFYI [ i ]
<operator>.indirectIndexAccess c [ 1 ]
<operator>.indirectIndexAccess YNFYI [ i + 1 ]
<operator>.indirectIndexAccess c [ 0 ]
>>>PDG&117 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->47 0->48 0->50 0->53 0->54 0->56 0->57 0->58 0->59 0->61 0->64 0->66 0->67 0->68 0->70 0->73 0->74 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->84 0->86 0->89 0->90 0->91 0->92 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->17 4->18 4->19 4->21 4->23 4->25 4->26 4->28 4->30 4->32 4->33 4->34 4->35 4->36 4->38 4->38 4->39 4->44 4->93 4->94 4->95 5->1 5->4 6->3 7->1 7->4 8->1 8->26 8->57 8->67 8->77 8->86 9->1 9->1 9->19 9->42 10->1 10->1 10->21 10->41 11->1 11->1 11->23 11->25 11->73 11->89 12->1 12->1 12->37 12->55 12->62 12->63 12->69 12->71 12->72 12->81 12->87 12->88 13->1 13->1 13->54 13->64 14->1 14->1 15->1 15->1 15->43 16->1 16->1 16->1 17->1 17->1 18->1 19->1 19->1 19->9 19->19 19->20 19->20 19->29 19->42 20->1 20->19 21->1 21->1 21->10 21->21 21->22 21->22 21->31 21->41 22->1 22->21 23->1 23->23 23->24 23->24 23->25 23->25 23->41 23->44 23->48 23->58 23->59 23->66 23->68 23->73 23->74 23->79 23->80 23->82 23->84 23->89 23->90 23->92 24->1 24->23 25->1 25->1 25->1 25->11 25->23 25->37 25->57 25->96 25->97 26->1 26->1 26->1 26->26 26->27 26->40 26->45 26->45 26->98 27->1 27->26 28->19 29->1 29->1 29->46 29->71 29->72 29->87 29->88 30->21 31->1 31->1 31->62 31->63 32->13 33->14 34->15 35->16 36->23 37->1 37->1 37->1 39->1 39->26 40->1 40->1 41->1 41->1 41->10 41->21 41->42 41->43 41->51 41->53 41->62 41->103 41->104 42->1 42->1 42->9 42->19 42->52 42->65 42->71 42->107 42->108 43->1 43->1 43->1 43->46 43->47 43->48 43->49 43->54 43->54 43->55 43->56 43->61 43->67 43->77 43->99 43->100 43->101 43->102 45->1 45->27 45->50 46->1 46->1 46->1 47->1 47->1 47->56 47->86 48->24 49->1 49->1 49->1 49->43 50->1 51->1 51->1 51->1 51->42 51->43 51->53 51->64 51->78 52->1 52->1 52->1 52->58 52->59 52->74 52->75 52->75 52->83 52->87 52->113 52->114 53->43 54->1 54->1 54->60 54->64 54->76 55->1 55->1 55->1 56->1 56->1 56->47 56->86 57->26 58->1 58->43 59->1 59->1 60->1 60->1 60->54 60->64 61->49 62->1 62->1 62->12 62->31 62->37 62->51 62->51 62->55 62->63 62->63 62->69 62->71 62->81 62->105 62->106 63->1 63->1 63->12 63->31 63->37 63->51 63->51 63->55 63->62 63->69 63->71 63->81 64->1 64->1 64->42 64->43 64->53 64->54 64->68 64->69 64->70 64->81 64->111 64->112 65->1 65->1 65->52 65->52 65->66 65->73 66->1 66->24 66->48 66->52 66->52 66->58 66->59 66->74 66->79 66->80 66->84 66->90 66->92 67->26 67->57 67->77 67->86 68->1 68->1 68->54 68->64 69->1 69->1 69->1 69->81 70->1 70->47 70->56 71->1 71->1 71->12 71->29 71->37 71->55 71->62 71->65 71->65 71->72 71->82 71->87 71->88 71->109 71->110 72->1 72->1 72->12 72->29 72->65 72->65 72->87 72->88 73->23 73->66 73->66 73->89 75->1 75->1 75->1 75->52 75->79 75->80 75->90 76->60 77->26 77->57 77->67 77->86 78->64 79->1 79->43 80->1 80->1 81->1 81->1 81->1 81->12 81->37 81->42 81->43 81->53 81->55 81->62 81->71 81->85 81->86 81->91 83->1 83->1 83->75 83->75 83->84 83->89 84->1 84->24 84->48 84->75 84->75 84->79 84->80 84->90 85->1 85->1 85->1 85->54 85->64 86->1 86->1 86->26 86->57 86->67 86->77 87->1 87->1 87->12 87->29 87->37 87->55 87->62 87->71 87->72 87->83 87->83 87->88 87->92 87->115 87->116 88->1 88->1 88->12 88->29 88->71 88->72 88->83 88->83 89->23 89->84 89->84 91->85
>>>Token int main ( ) { int it , i ; int T , C , D , N ; char c [ 4 ] , d [ 3 ] ; char YNFYI [ 100 ] , XCOXVC [ 100 ] , GENYEJ [ 100 ] ; int d1 , d2 , c1 , c2 ; char dc , cc ; int KPDB , UICRO ; VQBAE ( " " , & T ) ; for ( it = 0 ; it < T ; it ++ ) { KPDB = 0 ; VQBAE ( " " , & C ) ; for ( i = 0 ; i < C ; i ++ ) { VQBAE ( " " , c ) ; } VQBAE ( " " , & D ) ; for ( i = 0 ; i < D ; i ++ ) { VQBAE ( " " , d ) ; } VQBAE ( " " , & N ) ; VQBAE ( " " , YNFYI ) ; d1 = - 1 ; d2 = - 1 ; c1 = - 1 ; c2 = - 1 ; for ( i = 0 ; i < N ; i ++ ) { int k ; if ( D > 0 ) if ( YNFYI [ i ] == d [ 0 ] || YNFYI [ i ] == d [ 1 ] ) { if ( d1 == - 1 ) { d1 = i ; dc = YNFYI [ i ] ; UICRO = 0 ; } else if ( YNFYI [ i ] != dc ) { d1 = - 1 ; KPDB -= UICRO ; continue ; } } if ( C > 0 ) if ( YNFYI [ i ] == c [ 0 ] && YNFYI [ i + 1 ] == c [ 1 ] && i < N - 1 ) { c1 = i ; c2 = i + 1 ; } else if ( YNFYI [ i ] == c [ 1 ] && YNFYI [ i + 1 ] == c [ 0 ] && i < N - 1 ) { c1 = i ; c2 = i + 1 ; } if ( c1 != - 1 ) { if ( d1 == c1 ) d1 = - 1 ; GENYEJ [ KPDB ++ ] = c [ 2 ] ; UICRO ++ ; i ++ ; c1 = - 1 ; } else { GENYEJ [ KPDB ++ ] = YNFYI [ i ] ; UICRO ++ ; } } if ( i + 1 == N ) GENYEJ [ KPDB ++ ] = YNFYI [ i ] ; printf ( " " , it + 1 ) ; for ( i = 0 ; i < KPDB ; i ++ ) { if ( i != 0 ) printf ( " " ) ; printf ( " " , GENYEJ [ i ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD DRKDQCOC
METHOD_RETURN char
PARAM char a
PARAM char b
<operator>.assignment WTDCGAVWY = JUUFYXWJDPLTSKOV ( a )
<operator>.assignment QLIKMBIMY = JUUFYXWJDPLTSKOV ( b )
RETURN return PUYLTXEHIO [ WTDCGAVWY ] [ QLIKMBIMY ] ; return PUYLTXEHIO [ WTDCGAVWY ] [ QLIKMBIMY ] ;
<operator>.logicalOr WTDCGAVWY == - 1 || QLIKMBIMY == - 1
JUUFYXWJDPLTSKOV JUUFYXWJDPLTSKOV ( a )
JUUFYXWJDPLTSKOV JUUFYXWJDPLTSKOV ( b )
RETURN return 0 ; return 0 ;
<operator>.equals WTDCGAVWY == - 1
<operator>.equals QLIKMBIMY == - 1
LITERAL 0 return 0 ;
<operator>.minus - 1
<operator>.minus - 1
<operator>.indirectIndexAccess PUYLTXEHIO [ WTDCGAVWY ] [ QLIKMBIMY ]
<operator>.indirectIndexAccess PUYLTXEHIO [ WTDCGAVWY ]
>>>PDG&18 0->2 0->3 0->6 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->8 3->9 4->1 4->1 4->11 5->1 5->1 5->1 5->12 6->1 7->1 7->1 7->1 7->6 7->10 7->16 7->17 8->1 8->4 9->1 9->5 10->1 11->1 11->1 11->7 11->7 11->12 11->15 12->1 12->1 12->7 12->7 13->10 14->11 15->12
>>>Token char DRKDQCOC ( char a , char b ) { int WTDCGAVWY , QLIKMBIMY ; WTDCGAVWY = JUUFYXWJDPLTSKOV ( a ) ; QLIKMBIMY = JUUFYXWJDPLTSKOV ( b ) ; if ( WTDCGAVWY == - 1 || QLIKMBIMY == - 1 ) return 0 ; return PUYLTXEHIO [ WTDCGAVWY ] [ QLIKMBIMY ] ; }
>>>Func
METHOD IJALPJH
METHOD_RETURN int
PARAM char * FQFAJJ
PARAM int * EBJYMRAGYO
PARAM const char * const JHUIBRP
PARAM const int QDBROQDXXTD
PARAM const char * const XDNFGY
PARAM const int GSSGBUUNEP
PARAM const char * const VFJLYMO
PARAM const int SDFVBFSHGXUL
memset memset ( FQFAJJ   0   sizeof ( SDFVBFSHGXUL ) )
<operator>.assignment * EBJYMRAGYO = 0
RETURN return 0 ; return 0 ;
<operator>.lessThan FVRARACMWRQO < SDFVBFSHGXUL
<operator>.expressionList FVRARACMWRQO ++   ( * EBJYMRAGYO ) ++
LITERAL 0 return 0 ;
<operator>.assignment FVRARACMWRQO = 0
<operator>.assignment FQFAJJ [ * EBJYMRAGYO ] = VFJLYMO [ FVRARACMWRQO ]
<operator>.postIncrement FVRARACMWRQO ++
<operator>.postIncrement ( * EBJYMRAGYO ) ++
<operator>.greaterThan ( * EBJYMRAGYO ) + 1 > 1
<operator>.addition ( * EBJYMRAGYO ) + 1
<operator>.lessThan NYXBA < QDBROQDXXTD
<operator>.postIncrement NYXBA ++
<operator>.lessThan NYXBA < GSSGBUUNEP
<operator>.postIncrement NYXBA ++
<operator>.assignment NYXBA = 0
<operator>.assignment NYXBA = 0
<operator>.logicalOr ( JHUIBRP [ ( NYXBA * 3 ) + 0 ] == FQFAJJ [ * EBJYMRAGYO ] && JHUIBRP [ ( NYXBA * 3 ) + 1 ] == FQFAJJ [ * EBJYMRAGYO - 1 ] ) || ( JHUIBRP [ ( NYXBA * 3 ) + 1 ] == FQFAJJ [ * EBJYMRAGYO ] && JHUIBRP [ ( NYXBA * 3 ) + 0 ] == FQFAJJ [ * EBJYMRAGYO - 1 ] )
<operator>.lessThan LPUQWSSCLAIKW < * EBJYMRAGYO
<operator>.postIncrement LPUQWSSCLAIKW ++
<operator>.assignment FQFAJJ [ ( * EBJYMRAGYO ) - 1 ] = JHUIBRP [ ( NYXBA * 3 ) + 2 ]
<operator>.postDecrement ( * EBJYMRAGYO ) --
<operator>.assignment LPUQWSSCLAIKW = 0
<operator>.logicalAnd JHUIBRP [ ( NYXBA * 3 ) + 0 ] == FQFAJJ [ * EBJYMRAGYO ] && JHUIBRP [ ( NYXBA * 3 ) + 1 ] == FQFAJJ [ * EBJYMRAGYO - 1 ]
<operator>.logicalAnd JHUIBRP [ ( NYXBA * 3 ) + 1 ] == FQFAJJ [ * EBJYMRAGYO ] && JHUIBRP [ ( NYXBA * 3 ) + 0 ] == FQFAJJ [ * EBJYMRAGYO - 1 ]
<operator>.logicalOr ( XDNFGY [ ( NYXBA * 2 ) + 0 ] == ( FQFAJJ ) [ * EBJYMRAGYO ] && XDNFGY [ ( NYXBA * 2 ) + 1 ] == ( FQFAJJ ) [ LPUQWSSCLAIKW ] ) || ( XDNFGY [ ( NYXBA * 2 ) + 1 ] == ( FQFAJJ ) [ * EBJYMRAGYO ] && XDNFGY [ ( NYXBA * 2 ) + 0 ] == ( FQFAJJ ) [ LPUQWSSCLAIKW ] )
<operator>.equals JHUIBRP [ ( NYXBA * 3 ) + 0 ] == FQFAJJ [ * EBJYMRAGYO ]
<operator>.equals JHUIBRP [ ( NYXBA * 3 ) + 1 ] == FQFAJJ [ * EBJYMRAGYO - 1 ]
<operator>.equals JHUIBRP [ ( NYXBA * 3 ) + 1 ] == FQFAJJ [ * EBJYMRAGYO ]
<operator>.equals JHUIBRP [ ( NYXBA * 3 ) + 0 ] == FQFAJJ [ * EBJYMRAGYO - 1 ]
<operator>.assignment * EBJYMRAGYO = - 1
<operator>.subtraction ( * EBJYMRAGYO ) - 1
<operator>.addition ( NYXBA * 3 ) + 2
<operator>.logicalAnd XDNFGY [ ( NYXBA * 2 ) + 0 ] == ( FQFAJJ ) [ * EBJYMRAGYO ] && XDNFGY [ ( NYXBA * 2 ) + 1 ] == ( FQFAJJ ) [ LPUQWSSCLAIKW ]
<operator>.logicalAnd XDNFGY [ ( NYXBA * 2 ) + 1 ] == ( FQFAJJ ) [ * EBJYMRAGYO ] && XDNFGY [ ( NYXBA * 2 ) + 0 ] == ( FQFAJJ ) [ LPUQWSSCLAIKW ]
<operator>.addition ( NYXBA * 3 ) + 0
<operator>.addition ( NYXBA * 3 ) + 1
<operator>.subtraction * EBJYMRAGYO - 1
<operator>.addition ( NYXBA * 3 ) + 1
<operator>.addition ( NYXBA * 3 ) + 0
<operator>.subtraction * EBJYMRAGYO - 1
<operator>.multiplication NYXBA * 3
<operator>.equals XDNFGY [ ( NYXBA * 2 ) + 0 ] == ( FQFAJJ ) [ * EBJYMRAGYO ]
<operator>.equals XDNFGY [ ( NYXBA * 2 ) + 1 ] == ( FQFAJJ ) [ LPUQWSSCLAIKW ]
<operator>.equals XDNFGY [ ( NYXBA * 2 ) + 1 ] == ( FQFAJJ ) [ * EBJYMRAGYO ]
<operator>.equals XDNFGY [ ( NYXBA * 2 ) + 0 ] == ( FQFAJJ ) [ LPUQWSSCLAIKW ]
<operator>.minus - 1
<operator>.multiplication NYXBA * 3
<operator>.multiplication NYXBA * 3
<operator>.multiplication NYXBA * 3
<operator>.multiplication NYXBA * 3
<operator>.addition ( NYXBA * 2 ) + 0
<operator>.addition ( NYXBA * 2 ) + 1
<operator>.addition ( NYXBA * 2 ) + 1
<operator>.addition ( NYXBA * 2 ) + 0
<operator>.multiplication NYXBA * 2
<operator>.multiplication NYXBA * 2
<operator>.multiplication NYXBA * 2
<operator>.multiplication NYXBA * 2
<operator>.indirection * EBJYMRAGYO
<operator>.indirectIndexAccess FQFAJJ [ * EBJYMRAGYO ]
<operator>.indirectIndexAccess VFJLYMO [ FVRARACMWRQO ]
<operator>.indirection * EBJYMRAGYO
<operator>.indirection * EBJYMRAGYO
<operator>.indirection * EBJYMRAGYO
<operator>.indirectIndexAccess FQFAJJ [ ( * EBJYMRAGYO ) - 1 ]
<operator>.indirectIndexAccess JHUIBRP [ ( NYXBA * 3 ) + 2 ]
<operator>.indirection * EBJYMRAGYO
<operator>.indirectIndexAccess JHUIBRP [ ( NYXBA * 3 ) + 0 ]
<operator>.indirectIndexAccess FQFAJJ [ * EBJYMRAGYO ]
<operator>.indirectIndexAccess JHUIBRP [ ( NYXBA * 3 ) + 1 ]
<operator>.indirectIndexAccess FQFAJJ [ * EBJYMRAGYO - 1 ]
<operator>.indirectIndexAccess JHUIBRP [ ( NYXBA * 3 ) + 1 ]
<operator>.indirectIndexAccess FQFAJJ [ * EBJYMRAGYO ]
<operator>.indirectIndexAccess JHUIBRP [ ( NYXBA * 3 ) + 0 ]
<operator>.indirectIndexAccess FQFAJJ [ * EBJYMRAGYO - 1 ]
<operator>.indirection * EBJYMRAGYO
<operator>.indirection * EBJYMRAGYO
<operator>.indirection * EBJYMRAGYO
<operator>.indirection * EBJYMRAGYO
<operator>.indirection * EBJYMRAGYO
<operator>.indirection * EBJYMRAGYO
<operator>.indirectIndexAccess XDNFGY [ ( NYXBA * 2 ) + 0 ]
<operator>.indirectIndexAccess ( FQFAJJ ) [ * EBJYMRAGYO ]
<operator>.indirectIndexAccess XDNFGY [ ( NYXBA * 2 ) + 1 ]
<operator>.indirectIndexAccess ( FQFAJJ ) [ LPUQWSSCLAIKW ]
<operator>.indirectIndexAccess XDNFGY [ ( NYXBA * 2 ) + 1 ]
<operator>.indirectIndexAccess ( FQFAJJ ) [ * EBJYMRAGYO ]
<operator>.indirectIndexAccess XDNFGY [ ( NYXBA * 2 ) + 0 ]
<operator>.indirectIndexAccess ( FQFAJJ ) [ LPUQWSSCLAIKW ]
<operator>.indirection * EBJYMRAGYO
<operator>.indirection * EBJYMRAGYO
>>>PDG&103 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->33 0->42 0->43 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 2->10 3->1 4->1 4->31 4->37 4->38 4->39 4->40 5->1 5->22 6->1 6->53 6->54 6->55 6->56 7->1 7->24 8->1 8->17 10->1 10->1 10->37 10->38 10->39 10->40 10->53 10->54 10->55 10->56 11->1 11->1 11->19 11->20 11->21 11->29 11->42 11->48 11->51 12->1 13->1 13->1 13->1 13->13 13->14 13->17 13->18 13->18 13->19 13->20 13->21 13->70 13->71 13->72 13->73 13->74 14->1 14->1 14->1 15->12 16->1 16->13 17->1 17->1 17->1 17->37 18->13 18->14 19->1 19->14 19->20 19->21 19->29 19->42 19->48 19->51 20->1 20->1 20->22 20->24 20->26 20->27 22->1 22->1 22->22 22->23 22->28 22->34 22->37 22->46 22->58 22->58 22->79 22->80 22->87 23->1 23->22 24->1 24->1 24->1 24->24 24->25 24->25 24->29 24->33 24->66 24->75 25->1 25->24 26->22 27->1 27->24 28->1 28->1 28->1 28->31 28->32 28->42 28->43 28->52 28->76 28->77 28->78 28->89 29->1 29->1 29->19 29->29 29->30 29->30 29->36 29->44 29->53 29->62 29->66 29->75 29->93 29->94 29->101 30->1 30->29 31->1 31->1 31->1 32->1 32->19 32->29 32->42 32->48 32->51 33->1 33->29 34->1 34->1 34->28 34->28 34->35 34->39 34->49 34->60 34->83 34->84 34->88 35->1 35->1 35->28 35->28 36->1 36->1 36->1 36->41 36->57 36->90 37->1 37->1 37->34 37->34 37->38 37->39 37->40 37->47 37->48 37->59 37->81 37->82 37->91 38->1 38->1 38->34 38->34 38->39 38->40 39->1 39->1 39->35 39->35 39->37 39->38 39->40 39->50 39->51 39->61 39->85 39->86 39->92 40->1 40->1 40->35 40->35 40->37 40->38 41->1 41->1 41->29 42->32 43->1 44->1 44->1 44->36 44->36 44->45 44->55 44->64 44->68 44->97 44->98 44->102 45->1 45->1 45->36 45->36 46->1 47->1 48->19 48->29 48->42 48->51 49->1 50->1 51->19 51->29 51->42 51->48 52->23 52->43 52->43 53->1 53->1 53->44 53->44 53->54 53->55 53->56 53->63 53->67 53->95 53->96 54->1 54->1 54->44 54->44 54->55 54->56 55->1 55->1 55->45 55->45 55->53 55->54 55->56 55->65 55->69 55->99 55->100 56->1 56->1 56->45 56->45 56->53 56->54 57->41 58->23 58->46 58->46 58->52 58->59 58->60 59->23 59->47 59->47 59->52 59->60 60->23 60->49 60->49 60->52 60->61 61->23 61->50 61->50 61->52 62->1 63->1 64->1 65->1 66->25 66->62 66->62 66->67 66->68 67->25 67->63 67->63 67->66 67->68 68->25 68->64 68->64 68->66 68->69 69->25 69->65 69->65 69->66
>>>Token static int IJALPJH ( char * FQFAJJ , int * EBJYMRAGYO , const char * const JHUIBRP , const int QDBROQDXXTD , const char * const XDNFGY , const int GSSGBUUNEP , const char * const VFJLYMO , const int SDFVBFSHGXUL ) { int FVRARACMWRQO , NYXBA , LPUQWSSCLAIKW ; memset ( FQFAJJ , 0 , sizeof ( SDFVBFSHGXUL ) ) ; * EBJYMRAGYO = 0 ; for ( FVRARACMWRQO = 0 ; FVRARACMWRQO < SDFVBFSHGXUL ; FVRARACMWRQO ++ , ( * EBJYMRAGYO ) ++ ) { FQFAJJ [ * EBJYMRAGYO ] = VFJLYMO [ FVRARACMWRQO ] ; if ( ( * EBJYMRAGYO ) + 1 > 1 ) { for ( NYXBA = 0 ; NYXBA < QDBROQDXXTD ; NYXBA ++ ) { if ( ( JHUIBRP [ ( NYXBA * 3 ) + 0 ] == FQFAJJ [ * EBJYMRAGYO ] && JHUIBRP [ ( NYXBA * 3 ) + 1 ] == FQFAJJ [ * EBJYMRAGYO - 1 ] ) || ( JHUIBRP [ ( NYXBA * 3 ) + 1 ] == FQFAJJ [ * EBJYMRAGYO ] && JHUIBRP [ ( NYXBA * 3 ) + 0 ] == FQFAJJ [ * EBJYMRAGYO - 1 ] ) ) { FQFAJJ [ ( * EBJYMRAGYO ) - 1 ] = JHUIBRP [ ( NYXBA * 3 ) + 2 ] ; ( * EBJYMRAGYO ) -- ; } } for ( NYXBA = 0 ; NYXBA < GSSGBUUNEP ; NYXBA ++ ) { for ( LPUQWSSCLAIKW = 0 ; LPUQWSSCLAIKW < * EBJYMRAGYO ; LPUQWSSCLAIKW ++ ) { if ( ( XDNFGY [ ( NYXBA * 2 ) + 0 ] == ( FQFAJJ ) [ * EBJYMRAGYO ] && XDNFGY [ ( NYXBA * 2 ) + 1 ] == ( FQFAJJ ) [ LPUQWSSCLAIKW ] ) || ( XDNFGY [ ( NYXBA * 2 ) + 1 ] == ( FQFAJJ ) [ * EBJYMRAGYO ] && XDNFGY [ ( NYXBA * 2 ) + 0 ] == ( FQFAJJ ) [ LPUQWSSCLAIKW ] ) ) { * EBJYMRAGYO = - 1 ; } } } } } return 0 ; }
>>>Func
METHOD NFBSLBKJ
METHOD_RETURN double
PARAM void
ANDSYHJKFUHN ANDSYHJKFUHN ( & tv , NULL )
RETURN return tv . LHPOWW + tv . PPJSCUU * 1e-6 ; return tv . LHPOWW + tv . PPJSCUU * 1e-6 ;
<operator>.addition tv . LHPOWW + tv . PPJSCUU * 1e-6
<operator>.multiplication tv . PPJSCUU * 1e-6
>>>PDG&7 0->2 0->3 0->5 0->6 2->1 3->1 3->1 3->1 4->1 5->1 5->1 5->1 5->4 6->1 6->5 6->5
>>>Token double NFBSLBKJ ( void ) { struct CKOQYAN tv ; ANDSYHJKFUHN ( & tv , NULL ) ; return tv . LHPOWW + tv . PPJSCUU * 1e-6 ; }
>>>Func
METHOD LYWN
METHOD_RETURN void
PARAM JQDXMU * UEQCJ
PARAM JQDXMU * UQIVJJ
<operator>.assignment GVHX = * UEQCJ
<operator>.assignment * UEQCJ = * UQIVJJ
<operator>.assignment * UQIVJJ = GVHX
>>>PDG&7 0->2 0->3 0->6 2->1 3->1 4->1 4->6 5->1 5->1 6->1 6->1 6->1
>>>Token void LYWN ( JQDXMU * UEQCJ , JQDXMU * UQIVJJ ) { JQDXMU GVHX = * UEQCJ ; * UEQCJ = * UQIVJJ ; * UQIVJJ = GVHX ; }
>>>Func
METHOD XEWN
METHOD_RETURN void
<operator>.assignment KSOH = 10
<operator>.assignment * KKC = ( int * ) calloc ( KSOH   sizeof ( int ) )
DLJCJMYCMK DLJCJMYCMK ( KKC , KSOH )
free free ( KKC )
<operator>.lessThan i < KSOH
<operator>.postIncrement i ++
<operator>.lessThan i < KSOH - 1
<operator>.preIncrement ++ i
<operator>.cast ( int * ) calloc ( KSOH   sizeof ( int ) )
<operator>.assignment i = 0
<operator>.assignment KKC [ i ] = rand ( ) % 100
<operator>.assignment i = 0
assert assert ( KKC [ i ] <= KKC [ i + 1 ] )
calloc calloc ( KSOH   sizeof ( int ) )
<operator>.subtraction KSOH - 1
<operator>.sizeOf sizeof ( int )
<operator>.modulo rand ( ) % 100
<operator>.lessEqualsThan KKC [ i ] <= KKC [ i + 1 ]
<operator>.addition i + 1
<operator>.indirectIndexAccess KKC [ i ]
rand rand ( )
<operator>.indirectIndexAccess KKC [ i ]
<operator>.indirectIndexAccess KKC [ i + 1 ]
>>>PDG&25 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->15 0->16 0->18 0->20 2->1 2->3 2->6 2->10 2->15 3->1 3->1 3->4 4->1 4->5 4->16 4->19 5->1 6->1 6->4 6->6 6->7 6->7 6->12 6->18 6->21 6->22 7->1 7->6 8->1 8->1 8->1 8->8 8->9 8->9 8->14 8->16 8->19 8->20 8->20 8->23 8->24 9->1 9->8 10->1 11->6 12->1 12->1 12->1 12->4 12->5 12->19 13->1 13->8 14->1 14->1 16->1 16->8 16->8 17->1 18->1 18->12 18->12 19->1 19->1 19->5 19->5 19->14 19->14
>>>Token void XEWN ( ) { const int KSOH = 10 ; int * KKC = ( int * ) calloc ( KSOH , sizeof ( int ) ) ; for ( int i = 0 ; i < KSOH ; i ++ ) { KKC [ i ] = rand ( ) % 100 ; } DLJCJMYCMK ( KKC , KSOH ) ; for ( int i = 0 ; i < KSOH - 1 ; ++ i ) { assert ( KKC [ i ] <= KKC [ i + 1 ] ) ; } free ( KKC ) ; }
>>>Func
METHOD main
METHOD_RETURN int
DRKDQ DRKDQ ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
COCW COCW ( )
<operator>.assignment TDC = 0
DRKDQ DRKDQ ( "%d" , & c )
DRKDQ DRKDQ ( "%d" , & d )
DRKDQ DRKDQ ( "%d" , & n )
DRKDQ DRKDQ ( " " )
printf printf ( "Case #%d: " , i )
printf printf ( "[" )
printf printf ( "]\n" )
<operator>.postDecrement c --
<operator>.postDecrement d --
<operator>.postDecrement n --
<operator>.lessThan j < TDC
<operator>.postIncrement j ++
DRKDQ DRKDQ ( " %c%c%c" , & q , & w , & e )
<operator>.assignment GAVWYQ [ q ] [ w ] = GAVWYQ [ w ] [ q ] = e
DRKDQ DRKDQ ( " %c%c" , & q , & w )
<operator>.assignment LIKMB [ q ] [ w ] = LIKMB [ w ] [ q ] = 1
DRKDQ DRKDQ ( "%c" , & q )
<operator>.assignment j = 0
printf printf ( "%c" , IMYJU [ j ] )
<operator>.equals TDC == 0
<operator>.lessThan j < TDC - 1
<operator>.assignment GAVWYQ [ w ] [ q ] = e
<operator>.assignment LIKMB [ w ] [ q ] = 1
<operator>.assignment IMYJU [ TDC ++ ] = q
printf printf ( ", " )
<operator>.subtraction TDC - 1
<operator>.postIncrement TDC ++
<operator>.assignment IMYJU [ TDC - 1 ] = GAVWYQ [ IMYJU [ TDC - 1 ] ] [ q ]
<operator>.assignment IMYJU [ TDC ++ ] = q
<operator>.lessThan j < TDC
<operator>.postIncrement j ++
<operator>.subtraction TDC - 1
<operator>.subtraction TDC - 1
<operator>.assignment j = 0
<operator>.postIncrement TDC ++
<operator>.subtraction TDC - 1
<operator>.assignment TDC = 0
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.addressOf & q
<operator>.addressOf & w
<operator>.addressOf & e
<operator>.indirectIndexAccess GAVWYQ [ q ] [ w ]
<operator>.addressOf & q
<operator>.addressOf & w
<operator>.indirectIndexAccess LIKMB [ q ] [ w ]
<operator>.addressOf & q
<operator>.indirectIndexAccess IMYJU [ j ]
<operator>.indirectIndexAccess GAVWYQ [ q ]
<operator>.indirectIndexAccess GAVWYQ [ w ] [ q ]
<operator>.indirectIndexAccess LIKMB [ q ]
<operator>.indirectIndexAccess LIKMB [ w ] [ q ]
<operator>.indirectIndexAccess GAVWYQ [ w ]
<operator>.indirectIndexAccess LIKMB [ w ]
<operator>.indirectIndexAccess IMYJU [ TDC ++ ]
<operator>.indirectIndexAccess GAVWYQ [ IMYJU [ TDC - 1 ] ] [ q ]
<operator>.indirectIndexAccess GAVWYQ [ IMYJU [ TDC - 1 ] ]
<operator>.indirectIndexAccess IMYJU [ TDC - 1 ]
<operator>.indirectIndexAccess IMYJU [ TDC - 1 ]
<operator>.indirectIndexAccess GAVWYQ [ IMYJU [ TDC - 1 ] ] [ q ]
<operator>.indirectIndexAccess GAVWYQ [ IMYJU [ TDC - 1 ] ]
<operator>.indirectIndexAccess IMYJU [ TDC ++ ]
<operator>.indirectIndexAccess IMYJU [ TDC - 1 ]
<operator>.indirectIndexAccess LIKMB [ IMYJU [ j ] ] [ q ]
<operator>.indirectIndexAccess LIKMB [ IMYJU [ j ] ]
<operator>.indirectIndexAccess IMYJU [ j ]
>>>PDG&77 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->14 4->15 4->16 4->17 4->18 4->19 4->20 4->27 4->47 4->48 4->49 5->1 5->4 6->3 7->1 7->4 8->1 9->1 9->20 9->29 10->1 10->1 10->17 11->1 11->1 11->18 12->1 12->1 12->19 13->1 14->1 14->5 15->1 16->1 17->1 17->1 17->10 17->17 17->22 17->23 17->31 17->50 17->51 17->52 17->53 17->59 17->60 17->63 18->1 18->1 18->11 18->18 18->24 18->25 18->32 18->54 18->55 18->56 18->61 18->62 18->64 19->1 19->1 19->12 19->19 19->26 19->29 19->57 20->1 20->1 20->1 20->20 20->21 20->28 20->30 20->30 20->35 20->35 20->58 21->1 21->20 22->1 22->1 22->1 22->1 22->23 22->24 22->24 22->26 22->31 22->33 22->38 23->1 23->1 23->1 24->1 24->1 24->1 24->22 24->22 24->26 24->33 24->38 25->1 25->1 25->1 26->1 26->1 26->22 26->24 26->33 26->38 27->1 27->20 28->1 28->1 29->1 29->33 29->36 29->36 29->41 29->41 29->65 29->66 29->67 29->68 30->1 30->1 30->21 30->34 31->1 31->1 31->23 32->1 32->25 33->1 33->1 33->1 34->1 35->20 35->30 35->30 36->20 36->29 37->1 37->1 37->1 38->1 38->1 38->1 39->38 39->40 39->44 39->44 39->72 39->74 39->75 39->76 40->1 40->39 41->39 41->42 42->45 43->39 44->20 44->29 45->20 45->29 46->1 46->20 46->29 66->37 66->39 66->42 66->43 66->45 66->69 66->70 66->71 66->73 74->39 74->40 74->46
>>>Token int main ( ) { int t , c , d , n ; char q , w , e ; int i , j ; DRKDQ ( " " , & t ) ; for ( i = 1 ; i <= t ; i ++ ) { COCW ( ) ; TDC = 0 ; DRKDQ ( " " , & c ) ; while ( c -- ) { DRKDQ ( " " , & q , & w , & e ) ; GAVWYQ [ q ] [ w ] = GAVWYQ [ w ] [ q ] = e ; } DRKDQ ( " " , & d ) ; while ( d -- ) { DRKDQ ( " " , & q , & w ) ; LIKMB [ q ] [ w ] = LIKMB [ w ] [ q ] = 1 ; } DRKDQ ( " " , & n ) ; DRKDQ ( " " ) ; while ( n -- ) { DRKDQ ( " " , & q ) ; if ( TDC == 0 ) { IMYJU [ TDC ++ ] = q ; } else if ( GAVWYQ [ IMYJU [ TDC - 1 ] ] [ q ] ) { IMYJU [ TDC - 1 ] = GAVWYQ [ IMYJU [ TDC - 1 ] ] [ q ] ; } else { for ( j = 0 ; j < TDC ; j ++ ) { if ( LIKMB [ IMYJU [ j ] ] [ q ] ) { TDC = 0 ; goto UFYXW ; } } IMYJU [ TDC ++ ] = q ; } UFYXW : ; } printf ( " " , i ) ; printf ( " " ) ; for ( j = 0 ; j < TDC ; j ++ ) { printf ( " " , IMYJU [ j ] ) ; if ( j < TDC - 1 ) printf ( " " ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment * GEIVRTH = NULL
<operator>.assignment * SUFCQJFSNOW = NULL
<operator>.assignment MKLVIEPP = false
<operator>.assignment * YMXDFJ = NULL
<operator>.assignment IBXYAAFIHCWRIM = false
<operator>.assignment * DORPBDLKJD = NULL
<operator>.assignment * CLRCOXMXY = NULL
<operator>.assignment RJPJMUVWFBCQVEHTS = false
<operator>.assignment HUDHVPNIMYRDTPUFHGRCE = false
RJGVCECKXVRUBYQ RJGVCECKXVRUBYQ ( & argc , & argv )
TPBGOSLKKIPROKWT TPBGOSLKKIPROKWT ( argv [ 0 ] )
EGCAJGEVE EGCAJGEVE ( ANBCPR , "" )
VFTEVOPHCXWVMJ VFTEVOPHCXWVMJ ( SINCKPL , QUJWUYXYO )
SWVOBSFSAJ SWVOBSFSAJ ( SINCKPL )
QYGGJY QYGGJY ( OYBAPOSMAQJA )
<operator>.assignment PNJYWNOQIFPCOWCJPJRWA = ( ! ! GEIVRTH + ! ! DORPBDLKJD + ! ! CLRCOXMXY + IBXYAAFIHCWRIM )
<operator>.assignment * PIHRIQQTSEP = VODMRALLAACBXKMQQ ( YMXDFJ )
<operator>.assignment * YJMQTTKCNC = PIHRIQQTSEP ? PIHRIQQTSEP : YMXDFJ
<operator>.assignment * WIGOFWUT = OUFDWG ( "TZ" )
<operator>.assignment tz = HBUSDIU ( WIGOFWUT )
PWOTOQQCM PWOTOQQCM ( ok ? EXIT_SUCCESS : EXIT_FAILURE )
<operator>.notEquals ( AXRC = QJOJGLAKGIF ( argc , argv , GRYFXFQAVQBXI , SRUSKESDPKNY , NULL ) ) != - 1
<operator>.greaterThan PNJYWNOQIFPCOWCJPJRWA > 1
<operator>.logicalAnd MKLVIEPP && PNJYWNOQIFPCOWCJPJRWA
<operator>.logicalAnd RJPJMUVWFBCQVEHTS && ( RSQLOUGJJVWSGVHMXLDR & QTBHQLOAMMGHIWSWUYIE )
<operator>.logicalAnd HUDHVPNIMYRDTPUFHGRCE && ( RSQLOUGJJVWSGVHMXLDR & QTBHQLOAMMGHIWSWUYIE )
<operator>.lessThan BWJWJA < argc
<operator>.logicalNot ! YMXDFJ
<operator>.notEquals DORPBDLKJD != NULL
<operator>.assignment * XPLEXQMQPT = NULL
<operator>.addition ! ! GEIVRTH + ! ! DORPBDLKJD + ! ! CLRCOXMXY + IBXYAAFIHCWRIM
AOEPK AOEPK ( 0   0   _ ( "the options to specify dates for printing are mutually exclusive" ) )
EPVUF EPVUF ( EXIT_FAILURE )
AOEPK AOEPK ( 0   0   _ ( "the options to print and set the time may not be used together" ) )
EPVUF EPVUF ( EXIT_FAILURE )
AOEPK AOEPK ( 0   0   _ ( "only using last of multiple -d options" ) )
AOEPK AOEPK ( 0   0   _ ( "only using last of multiple -s options" ) )
VODMRALLAACBXKMQQ VODMRALLAACBXKMQQ ( YMXDFJ )
<operator>.conditional PIHRIQQTSEP ? PIHRIQQTSEP : YMXDFJ
OUFDWG OUFDWG ( "TZ" )
HBUSDIU HBUSDIU ( WIGOFWUT )
<operator>.assignment ok = CSDRXCOTSJAVI ( DORPBDLKJD , YJMQTTKCNC , tz , WIGOFWUT )
<operator>.conditional ok ? EXIT_SUCCESS : EXIT_FAILURE
<operator>.assignment AXRC = QJOJGLAKGIF ( argc , argv , GRYFXFQAVQBXI , SRUSKESDPKNY , NULL )
<operator>.minus - 1
IDENTIFIER AXRC switch(AXRC)
IDENTIFIER XPLEXQMQPT if (XPLEXQMQPT)
<operator>.addition ! ! GEIVRTH + ! ! DORPBDLKJD + ! ! CLRCOXMXY
<operator>.and RSQLOUGJJVWSGVHMXLDR & QTBHQLOAMMGHIWSWUYIE
<operator>.and RSQLOUGJJVWSGVHMXLDR & QTBHQLOAMMGHIWSWUYIE
<operator>.lessThan BWJWJA + 1 < argc
<operator>.equals argv [ BWJWJA ] [ 0 ] == '+'
IDENTIFIER IBXYAAFIHCWRIM if (IBXYAAFIHCWRIM)
<operator>.assignment GEJMWYKIPQ = true
<operator>.assignment ok = true
<operators>.assignmentAnd ok &= QJHTOSEKC ( YJMQTTKCNC , MIEF , tz )
QJOJGLAKGIF QJOJGLAKGIF ( argc , argv , GRYFXFQAVQBXI , SRUSKESDPKNY , NULL )
LITERAL 'd' <empty>
<operator>.assignment GEIVRTH = QULQTE
IDENTIFIER URMPLHIXNECEQRDQJOUIFJBXD <empty>
<operators>.assignmentOr RSQLOUGJJVWSGVHMXLDR |= QTBHQLOAMMGHIWSWUYIE
LITERAL 'f' <empty>
<operator>.assignment DORPBDLKJD = QULQTE
IDENTIFIER WGXDCHQCUVVLQWUJJ <empty>
<operator>.assignment IBXYAAFIHCWRIM = true
IDENTIFIER JMXYSFHRAGMBPTX <empty>
LITERAL 'I' <empty>
LITERAL 'r' <empty>
<operator>.assignment CLRCOXMXY = QULQTE
LITERAL 'R' <empty>
<operator>.assignment XPLEXQMQPT = UQYBWYFCWBNPWBVO
LITERAL 's' <empty>
<operator>.assignment SUFCQJFSNOW = QULQTE
<operator>.assignment MKLVIEPP = true
LITERAL 'u' <empty>
IDENTIFIER EXGBA <empty>
VRFGILFQMHUHNJFQNAXHQRUG VRFGILFQMHUHNJFQNAXHQRUG ( HDPRSPYQHEAR , SHIFOGO )
EPVUF EPVUF ( EXIT_FAILURE )
<operator>.assignment YMXDFJ = XPLEXQMQPT
<operator>.addition ! ! GEIVRTH + ! ! DORPBDLKJD
<operator>.logicalNot ! ! CLRCOXMXY
_ _ ( "the options to specify dates for printing are mutually exclusive" )
_ _ ( "the options to print and set the time may not be used together" )
_ _ ( "only using last of multiple -d options" )
_ _ ( "only using last of multiple -s options" )
AOEPK AOEPK ( 0   0   _ ( "extra operand %s" )   KVBKL ( argv [ BWJWJA + 1 ] ) )
EPVUF EPVUF ( EXIT_FAILURE )
<operator>.assignment YMXDFJ = argv [ BWJWJA ++ ] + 1
<operator>.assignment YMXDFJ = "%s.%N"
CSDRXCOTSJAVI CSDRXCOTSJAVI ( DORPBDLKJD , YJMQTTKCNC , tz , WIGOFWUT )
<operator>.logicalAnd ! PNJYWNOQIFPCOWCJPJRWA && ! MKLVIEPP
<operator>.logicalNot ! GEJMWYKIPQ
IDENTIFIER MKLVIEPP if (MKLVIEPP)
IDENTIFIER GEIVRTH if (GEIVRTH)
<operator>.assignment VTEABWCVSXJLWGV [ ] [ 32 ] = { "%Y-%m-%d"   "%Y-%m-%d %H:%M:%S%:z"   "%Y-%m-%d %H:%M:%S.%N%:z" }
<operator>.assignment i = PHKQWGRSA ( "--rfc-3339" , QULQTE , VSDSWBNWMCTSADKK + 2 , KCNYAKOJW + 2 )
<operator>.assignment XPLEXQMQPT = VTEABWCVSXJLWGV [ i ]
<operator>.assignment GGDABFVVKQULGRA [ ] [ 32 ] = { "%Y-%m-%d"   "%Y-%m-%dT%H:%M:%S%:z"   "%Y-%m-%dT%H:%M:%S %N%:z"   "%Y-%m-%dT%H%:z"   "%Y-%m-%dT%H:%M%:z" }
<operator>.assignment i = ( QULQTE ? PHKQWGRSA ( "--iso-8601" , QULQTE , VSDSWBNWMCTSADKK , KCNYAKOJW ) : IMSIPESAIIBKTQ )
<operator>.assignment XPLEXQMQPT = GGDABFVVKQULGRA [ i ]
IDENTIFIER SUFCQJFSNOW if (SUFCQJFSNOW)
<operator>.notEquals CHDWRU ( DLULVYWP ( "TZ=UTC0" ) ) != 0
IDENTIFIER YMXDFJ if (YMXDFJ)
<operator>.logicalNot ! ! GEIVRTH
<operator>.logicalNot ! ! DORPBDLKJD
<operator>.logicalNot ! CLRCOXMXY
<operator>.addition BWJWJA + 1
IDENTIFIER YMXDFJ if (YMXDFJ)
<operator>.assignment YMXDFJ = PBVWRXMQAXGJRFJST ( )
WVM WVM ( EXIT_FAILURE   0   _ ( "invalid date %s" )   KVBKL ( GEIVRTH ) )
QJHTOSEKC QJHTOSEKC ( YJMQTTKCNC , MIEF , tz )
<operator>.assignment RJPJMUVWFBCQVEHTS = true
<operator>.assignment HUDHVPNIMYRDTPUFHGRCE = true
PRJQUGRAIQ PRJQUGRAIQ ( )
WVM WVM ( EXIT_FAILURE   0   _ ( "multiple output formats specified" ) )
<operator>.logicalNot ! GEIVRTH
<operator>.logicalNot ! DORPBDLKJD
_ _ ( "extra operand %s" )
KVBKL KVBKL ( argv [ BWJWJA + 1 ] )
WVM WVM ( EXIT_FAILURE   0   _ ( "multiple output formats specified" ) )
<operator>.addition argv [ BWJWJA ++ ] + 1
<operator>.logicalOr MKLVIEPP || PNJYWNOQIFPCOWCJPJRWA
<operator>.logicalNot ! * YMXDFJ
<operator>.logicalNot ! PNJYWNOQIFPCOWCJPJRWA
<operator>.logicalNot ! MKLVIEPP
<operator>.lessThan BWJWJA < argc
<operator>.notEquals APDICMC ( & MIEF ) != 0
<operator>.arrayInitializer { "%Y-%m-%d"   "%Y-%m-%d %H:%M:%S%:z"   "%Y-%m-%d %H:%M:%S.%N%:z" }
PHKQWGRSA PHKQWGRSA ( "--rfc-3339" , QULQTE , VSDSWBNWMCTSADKK + 2 , KCNYAKOJW + 2 )
<operator>.arrayInitializer { "%Y-%m-%d"   "%Y-%m-%dT%H:%M:%S%:z"   "%Y-%m-%dT%H:%M:%S %N%:z"   "%Y-%m-%dT%H%:z"   "%Y-%m-%dT%H:%M%:z" }
<operator>.conditional QULQTE ? PHKQWGRSA ( "--iso-8601" , QULQTE , VSDSWBNWMCTSADKK , KCNYAKOJW ) : IMSIPESAIIBKTQ
CHDWRU CHDWRU ( DLULVYWP ( "TZ=UTC0" ) )
AOEPK AOEPK ( 0   0   _ ( "the argument %s lacks a leading '+';\n" "when using an option to specify date(s), any non-option\n" "argument must be a format string beginning with '+'" )   KVBKL ( argv [ BWJWJA ] ) )
EPVUF EPVUF ( EXIT_FAILURE )
<operator>.assignment YMXDFJ = "%a %b %e %H:%M:%S %Z %Y"
<operator>.assignment MKLVIEPP = true
<operator>.assignment GEIVRTH = argv [ BWJWJA ]
<operator>.assignment GEJMWYKIPQ = IWTDPANMC ( & MIEF . HRVHTK   GEIVRTH   ( CPVELFMRQYQRLYHDK | GYPWYELCNEA | UANYRJDGQPX ) )
<operator>.assignment MIEF . JRPBDQK = 0
<operator>.notEquals CLRCOXMXY != NULL
_ _ ( "invalid date %s" )
KVBKL KVBKL ( GEIVRTH )
AOEPK AOEPK ( 0   XCLLI   _ ( "cannot set date" ) )
<operator>.assignment ok = false
<operator>.addition VSDSWBNWMCTSADKK + 2
<operator>.addition KCNYAKOJW + 2
PHKQWGRSA PHKQWGRSA ( "--iso-8601" , QULQTE , VSDSWBNWMCTSADKK , KCNYAKOJW )
DLULVYWP DLULVYWP ( "TZ=UTC0" )
_ _ ( "multiple output formats specified" )
<operator>.addition BWJWJA + 1
_ _ ( "multiple output formats specified" )
<operator>.postIncrement BWJWJA ++
IBRIRQH IBRIRQH ( & MIEF )
<operator>.assignment MIEF = LLJFEIOXASBQDM ( & GJTJJOTV )
APDICMC APDICMC ( & MIEF )
_ _ ( "the argument %s lacks a leading '+';\n" "when using an option to specify date(s), any non-option\n" "argument must be a format string beginning with '+'" )
KVBKL KVBKL ( argv [ BWJWJA ] )
IWTDPANMC IWTDPANMC ( & MIEF . HRVHTK   GEIVRTH   ( CPVELFMRQYQRLYHDK | GYPWYELCNEA | UANYRJDGQPX ) )
<operator>.notEquals KYYM ( CLRCOXMXY , & GJTJJOTV ) != 0
_ _ ( "cannot set date" )
<operator>.or CPVELFMRQYQRLYHDK | GYPWYELCNEA | UANYRJDGQPX
WVM WVM ( EXIT_FAILURE   XCLLI   "%s"   MILCID ( CLRCOXMXY ) )
LLJFEIOXASBQDM LLJFEIOXASBQDM ( & GJTJJOTV )
IDENTIFIER IBXYAAFIHCWRIM if (IBXYAAFIHCWRIM)
<operator>.or CPVELFMRQYQRLYHDK | GYPWYELCNEA
KYYM KYYM ( CLRCOXMXY , & GJTJJOTV )
<operator>.assignment UUU = OLEMOSAYHIK ( )
<operator>.assignment MIEF . HRVHTK = UUU / JQOWFACLKTJ
<operator>.assignment MIEF . JRPBDQK = UUU % JQOWFACLKTJ
MILCID MILCID ( CLRCOXMXY )
<operator>.assignment GEJMWYKIPQ = KMKCPYWNVNYBAPV ( & MIEF , GEIVRTH , NULL , RSQLOUGJJVWSGVHMXLDR , tz , WIGOFWUT )
<operator>.division UUU / JQOWFACLKTJ
<operator>.modulo UUU % JQOWFACLKTJ
IDENTIFIER SUFCQJFSNOW if (SUFCQJFSNOW)
<operator>.assignment GEIVRTH = SUFCQJFSNOW
KMKCPYWNVNYBAPV KMKCPYWNVNYBAPV ( & MIEF , GEIVRTH , NULL , RSQLOUGJJVWSGVHMXLDR , tz , WIGOFWUT )
<operator>.indirectIndexAccess argv [ BWJWJA ] [ 0 ]
<operator>.indirectIndexAccess argv [ BWJWJA ]
<operator>.indirectIndexAccess VTEABWCVSXJLWGV [ i ]
<operator>.indirectIndexAccess GGDABFVVKQULGRA [ i ]
<operator>.indirectIndexAccess argv [ BWJWJA + 1 ]
<operator>.indirectIndexAccess argv [ BWJWJA ++ ]
PBVWRXMQAXGJRFJST PBVWRXMQAXGJRFJST ( )
<operator>.indirection * YMXDFJ
<operator>.indirectIndexAccess argv [ BWJWJA ]
<operator>.fieldAccess MIEF . JRPBDQK
<operator>.addressOf & MIEF
<operator>.indirectIndexAccess argv [ BWJWJA ]
<operator>.addressOf & MIEF . HRVHTK
FIELD_IDENTIFIER JRPBDQK JRPBDQK
<operator>.addressOf & MIEF
<operator>.fieldAccess MIEF . HRVHTK
<operator>.addressOf & GJTJJOTV
FIELD_IDENTIFIER HRVHTK HRVHTK
<operator>.addressOf & GJTJJOTV
OLEMOSAYHIK OLEMOSAYHIK ( )
<operator>.fieldAccess MIEF . HRVHTK
<operator>.fieldAccess MIEF . JRPBDQK
FIELD_IDENTIFIER HRVHTK HRVHTK
FIELD_IDENTIFIER JRPBDQK JRPBDQK
<operator>.addressOf & MIEF
>>>PDG&205 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->21 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->81 0->82 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->95 0->96 0->97 0->102 0->104 0->105 0->106 0->109 0->110 0->111 0->112 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->123 0->124 0->125 0->127 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->136 0->137 0->138 0->139 0->142 0->143 0->144 0->145 0->146 0->147 0->148 0->149 0->150 0->151 0->152 0->153 0->154 0->155 0->156 0->158 0->159 0->161 0->162 0->163 0->164 0->165 0->166 0->167 0->168 0->169 0->170 0->173 0->175 0->176 0->177 0->178 0->179 2->13 2->60 3->13 3->14 3->60 4->1 4->119 5->1 5->1 5->178 6->1 6->27 7->1 7->31 8->1 8->19 8->34 9->1 9->120 10->1 10->109 11->1 11->28 12->1 12->1 12->29 13->1 13->1 13->1 13->30 13->54 13->60 13->60 13->129 14->1 14->1 14->60 15->1 15->1 16->1 16->1 16->17 17->1 17->1 18->1 18->1 19->1 19->1 19->26 20->1 20->1 20->21 20->42 21->1 21->1 21->93 21->114 22->1 22->1 22->44 23->1 23->1 23->93 23->114 23->179 24->1 24->1 25->1 25->1 25->1 25->25 25->33 25->47 25->48 25->60 25->62 25->64 25->66 25->68 25->72 25->74 25->76 25->77 25->81 25->82 25->98 25->99 25->100 25->101 25->102 25->103 25->105 25->115 25->116 25->118 25->131 25->132 25->133 25->134 25->135 25->148 25->149 25->150 25->151 25->152 25->182 25->183 26->1 26->27 26->35 26->36 26->85 27->1 27->1 27->1 27->37 27->38 27->86 27->125 27->125 27->127 27->128 28->1 28->1 28->29 28->39 28->87 29->1 29->1 29->1 29->40 29->88 30->1 30->1 30->1 30->54 30->54 30->54 30->55 30->110 30->110 30->129 30->129 30->153 30->155 30->180 30->181 31->1 31->41 31->92 31->112 31->126 31->186 31->187 32->1 32->1 32->1 32->45 32->57 32->58 32->59 32->93 32->93 32->94 32->95 32->114 32->127 32->130 32->143 32->158 32->190 33->1 33->1 33->82 34->1 34->1 35->1 35->1 36->1 36->24 36->38 36->46 36->90 36->113 36->123 36->137 36->165 37->1 37->1 38->1 38->24 38->46 38->90 38->113 38->123 38->137 38->165 39->1 39->1 40->1 40->1 41->20 41->21 41->42 42->1 42->1 43->22 44->1 44->23 44->93 44->179 45->1 45->1 46->1 46->1 46->1 47->1 47->1 47->25 48->25 51->1 51->1 52->1 52->1 52->28 52->28 52->53 52->53 52->179 53->1 53->1 53->29 53->29 53->179 54->1 54->1 54->1 54->89 54->90 54->121 54->122 54->129 54->153 54->184 55->1 55->1 55->91 55->123 55->124 55->125 55->140 55->154 55->155 55->160 55->185 57->1 57->95 58->1 58->1 58->59 59->1 60->1 60->1 60->1 60->25 60->25 60->25 60->25 60->25 60->30 60->32 60->33 60->47 60->47 60->47 60->47 60->47 60->91 60->122 60->124 60->140 60->160 62->1 62->1 62->119 64->1 64->1 64->52 64->53 64->179 66->1 66->1 66->120 68->1 68->1 68->19 68->34 72->1 72->1 72->109 74->1 74->1 74->1 74->82 76->1 76->1 76->1 76->178 77->1 77->1 77->27 80->1 80->1 80->1 81->1 81->24 81->36 81->38 81->46 81->90 81->113 81->118 81->123 81->137 81->165 82->1 82->1 82->31 83->1 83->1 84->1 84->19 84->34 84->51 85->35 86->37 87->39 88->40 89->1 89->1 89->1 90->1 90->24 90->46 90->113 90->123 90->137 90->165 91->1 91->1 91->31 92->1 92->41 93->1 93->1 93->1 93->1 93->45 93->45 93->45 93->45 94->1 94->1 94->1 94->129 94->143 95->1 95->1 95->113 95->144 95->145 98->1 98->1 98->1 98->100 99->1 99->1 99->1 100->1 100->1 100->1 100->82 101->1 101->1 101->1 101->103 102->1 102->1 102->1 103->1 103->1 103->1 103->82 105->1 105->1 105->117 107->1 107->19 107->34 107->51 107->83 108->1 108->19 108->34 108->51 108->83 109->1 109->84 109->143 110->1 112->1 112->1 112->41 113->1 113->1 113->1 113->24 113->46 114->1 114->1 114->1 114->59 114->59 114->59 115->1 115->1 115->28 116->1 116->29 117->1 118->1 118->1 118->24 118->36 118->38 118->46 118->81 118->90 118->113 118->123 118->137 118->165 119->1 119->107 119->145 119->179 120->32 120->108 121->89 122->1 122->89 123->1 123->1 123->24 123->46 123->113 123->165 124->1 125->1 125->1 125->1 125->127 125->128 125->136 125->137 125->159 125->160 125->191 126->1 126->1 126->21 126->41 126->42 126->138 127->1 127->94 127->128 128->1 128->94 129->1 129->1 129->1 129->139 129->140 129->141 129->142 129->156 129->161 129->164 129->168 129->188 129->189 129->192 129->193 129->194 129->195 129->197 130->1 130->1 130->146 130->147 130->163 131->98 131->98 131->98 132->1 132->1 132->1 132->62 132->66 132->72 132->76 132->99 132->99 132->99 132->99 132->150 133->101 133->101 133->101 133->101 133->101 134->1 134->1 134->1 135->1 135->105 136->1 136->1 136->1 137->1 137->24 137->46 137->113 137->165 138->1 138->41 139->1 139->1 139->1 140->1 140->1 140->161 141->1 141->1 141->95 142->1 142->114 142->158 143->1 143->1 143->1 143->157 143->162 143->166 143->169 143->169 143->170 143->171 143->172 143->174 143->175 143->176 143->178 143->179 143->179 143->196 143->198 143->199 143->200 143->201 143->202 143->203 143->204 144->113 145->1 145->113 146->1 146->1 146->1 147->1 147->1 147->59 148->1 149->1 150->1 150->1 150->102 150->102 150->102 150->102 150->132 150->132 150->134 150->134 150->134 150->134 150->148 150->149 151->135 152->118 153->1 154->123 155->1 155->129 156->1 156->1 156->114 156->158 157->1 157->1 157->114 157->158 158->1 158->114 158->130 159->136 160->1 160->136 160->140 161->1 161->1 161->1 161->141 161->141 161->141 161->145 162->1 162->1 162->165 162->173 163->146 164->1 164->1 164->161 164->161 165->1 165->1 165->1 165->24 165->46 165->113 165->146 166->1 166->157 168->1 168->1 168->164 168->164 169->1 169->162 169->162 169->166 169->173 170->1 170->1 170->175 171->1 171->1 171->114 171->158 172->1 172->1 172->114 172->158 173->1 173->165 174->1 174->1 174->95 175->171 175->171 175->176 175->176 176->1 176->1 176->172 176->172 178->1 178->1 178->179 179->1 179->1 179->1 179->1 179->1 179->114 179->114 179->145 179->158 179->174 179->174 179->174 179->174 179->174 179->174
>>>Token int main ( int argc , char * * argv ) { int AXRC ; char const * GEIVRTH = NULL ; char const * SUFCQJFSNOW = NULL ; struct AFHHUMIE MIEF ; bool MKLVIEPP = false ; char const * YMXDFJ = NULL ; bool IBXYAAFIHCWRIM = false ; char * DORPBDLKJD = NULL ; char * CLRCOXMXY = NULL ; struct KYYM GJTJJOTV ; bool ok ; bool RJPJMUVWFBCQVEHTS = false ; bool HUDHVPNIMYRDTPUFHGRCE = false ; RJGVCECKXVRUBYQ ( & argc , & argv ) ; TPBGOSLKKIPROKWT ( argv [ 0 ] ) ; EGCAJGEVE ( ANBCPR , " " ) ; VFTEVOPHCXWVMJ ( SINCKPL , QUJWUYXYO ) ; SWVOBSFSAJ ( SINCKPL ) ; QYGGJY ( OYBAPOSMAQJA ) ; while ( ( AXRC = QJOJGLAKGIF ( argc , argv , GRYFXFQAVQBXI , SRUSKESDPKNY , NULL ) ) != - 1 ) { char const * XPLEXQMQPT = NULL ; switch ( AXRC ) { case ' ' : if ( GEIVRTH ) RJPJMUVWFBCQVEHTS = true ; GEIVRTH = QULQTE ; break ; case URMPLHIXNECEQRDQJOUIFJBXD : RSQLOUGJJVWSGVHMXLDR |= QTBHQLOAMMGHIWSWUYIE ; break ; case ' ' : DORPBDLKJD = QULQTE ; break ; case WGXDCHQCUVVLQWUJJ : IBXYAAFIHCWRIM = true ; break ; case JMXYSFHRAGMBPTX : { static char const VTEABWCVSXJLWGV [ ] [ 32 ] = { " " , " " , " " } ; enum GPIHQDMXU i = PHKQWGRSA ( " " , QULQTE , VSDSWBNWMCTSADKK + 2 , KCNYAKOJW + 2 ) ; XPLEXQMQPT = VTEABWCVSXJLWGV [ i ] ; break ; } case ' ' : { static char const GGDABFVVKQULGRA [ ] [ 32 ] = { " " , " " , " " , " " , " " } ; enum GPIHQDMXU i = ( QULQTE ? PHKQWGRSA ( " " , QULQTE , VSDSWBNWMCTSADKK , KCNYAKOJW ) : IMSIPESAIIBKTQ ) ; XPLEXQMQPT = GGDABFVVKQULGRA [ i ] ; break ; } case ' ' : CLRCOXMXY = QULQTE ; break ; case ' ' : XPLEXQMQPT = UQYBWYFCWBNPWBVO ; break ; case ' ' : if ( SUFCQJFSNOW ) HUDHVPNIMYRDTPUFHGRCE = true ; SUFCQJFSNOW = QULQTE ; MKLVIEPP = true ; break ; case ' ' : if ( CHDWRU ( DLULVYWP ( " " ) ) != 0 ) PRJQUGRAIQ ( ) ; EXGBA ; break ; ERELXBESFRQSNPPGHJPAF ; VRFGILFQMHUHNJFQNAXHQRUG ( HDPRSPYQHEAR , SHIFOGO ) ; default : EPVUF ( EXIT_FAILURE ) ; } if ( XPLEXQMQPT ) { if ( YMXDFJ ) WVM ( EXIT_FAILURE , 0 , _ ( " " ) ) ; YMXDFJ = XPLEXQMQPT ; } } int PNJYWNOQIFPCOWCJPJRWA = ( ! ! GEIVRTH + ! ! DORPBDLKJD + ! ! CLRCOXMXY + IBXYAAFIHCWRIM ) ; if ( PNJYWNOQIFPCOWCJPJRWA > 1 ) { AOEPK ( 0 , 0 , _ ( " " ) ) ; EPVUF ( EXIT_FAILURE ) ; } if ( MKLVIEPP && PNJYWNOQIFPCOWCJPJRWA ) { AOEPK ( 0 , 0 , _ ( " " ) ) ; EPVUF ( EXIT_FAILURE ) ; } if ( RJPJMUVWFBCQVEHTS && ( RSQLOUGJJVWSGVHMXLDR & QTBHQLOAMMGHIWSWUYIE ) ) AOEPK ( 0 , 0 , _ ( " " ) ) ; if ( HUDHVPNIMYRDTPUFHGRCE && ( RSQLOUGJJVWSGVHMXLDR & QTBHQLOAMMGHIWSWUYIE ) ) AOEPK ( 0 , 0 , _ ( " " ) ) ; if ( BWJWJA < argc ) { if ( BWJWJA + 1 < argc ) { AOEPK ( 0 , 0 , _ ( " " ) , KVBKL ( argv [ BWJWJA + 1 ] ) ) ; EPVUF ( EXIT_FAILURE ) ; } if ( argv [ BWJWJA ] [ 0 ] == ' ' ) { if ( YMXDFJ ) WVM ( EXIT_FAILURE , 0 , _ ( " " ) ) ; YMXDFJ = argv [ BWJWJA ++ ] + 1 ; } else if ( MKLVIEPP || PNJYWNOQIFPCOWCJPJRWA ) { AOEPK ( 0 , 0 , _ ( " \n " " \n " " " ) , KVBKL ( argv [ BWJWJA ] ) ) ; EPVUF ( EXIT_FAILURE ) ; } } if ( ! YMXDFJ ) { if ( IBXYAAFIHCWRIM ) YMXDFJ = " " ; else { YMXDFJ = PBVWRXMQAXGJRFJST ( ) ; if ( ! * YMXDFJ ) YMXDFJ = " " ; } } char * PIHRIQQTSEP = VODMRALLAACBXKMQQ ( YMXDFJ ) ; char const * YJMQTTKCNC = PIHRIQQTSEP ? PIHRIQQTSEP : YMXDFJ ; char const * WIGOFWUT = OUFDWG ( " " ) ; FAESPULOGX tz = HBUSDIU ( WIGOFWUT ) ; if ( DORPBDLKJD != NULL ) ok = CSDRXCOTSJAVI ( DORPBDLKJD , YJMQTTKCNC , tz , WIGOFWUT ) ; else { bool GEJMWYKIPQ = true ; ok = true ; if ( ! PNJYWNOQIFPCOWCJPJRWA && ! MKLVIEPP ) { if ( BWJWJA < argc ) { MKLVIEPP = true ; GEIVRTH = argv [ BWJWJA ] ; GEJMWYKIPQ = IWTDPANMC ( & MIEF . HRVHTK , GEIVRTH , ( CPVELFMRQYQRLYHDK | GYPWYELCNEA | UANYRJDGQPX ) ) ; MIEF . JRPBDQK = 0 ; } else { IBRIRQH ( & MIEF ) ; } } else { if ( CLRCOXMXY != NULL ) { if ( KYYM ( CLRCOXMXY , & GJTJJOTV ) != 0 ) WVM ( EXIT_FAILURE , XCLLI , " " , MILCID ( CLRCOXMXY ) ) ; MIEF = LLJFEIOXASBQDM ( & GJTJJOTV ) ; } else if ( IBXYAAFIHCWRIM ) { long int UUU = OLEMOSAYHIK ( ) ; MIEF . HRVHTK = UUU / JQOWFACLKTJ ; MIEF . JRPBDQK = UUU % JQOWFACLKTJ ; } else { if ( SUFCQJFSNOW ) GEIVRTH = SUFCQJFSNOW ; GEJMWYKIPQ = KMKCPYWNVNYBAPV ( & MIEF , GEIVRTH , NULL , RSQLOUGJJVWSGVHMXLDR , tz , WIGOFWUT ) ; } } if ( ! GEJMWYKIPQ ) WVM ( EXIT_FAILURE , 0 , _ ( " " ) , KVBKL ( GEIVRTH ) ) ; if ( MKLVIEPP ) { if ( APDICMC ( & MIEF ) != 0 ) { AOEPK ( 0 , XCLLI , _ ( " " ) ) ; ok = false ; } } ok &= QJHTOSEKC ( YJMQTTKCNC , MIEF , tz ) ; } PWOTOQQCM ( ok ? EXIT_SUCCESS : EXIT_FAILURE ) ; }
>>>Func
METHOD UEV
METHOD_RETURN void
PARAM int n
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignmentDivision wk [ i ] . UEV /= ( wk [ i ] . nb )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.equals wk [ i ] . VVCECK [ j ] == LO
<operator>.assignment st = ( wk [ j ] . VXOH - 1 ) / ( wk [ j ] . nb - 1 )
<operator>.assignmentPlus wk [ i ] . UEV += st
<operator>.assignment st = ( wk [ j ] . VXOH ) / ( wk [ j ] . nb - 1 )
<operator>.assignmentPlus wk [ i ] . UEV += st
<operator>.division ( wk [ j ] . VXOH - 1 ) / ( wk [ j ] . nb - 1 )
<operator>.subtraction wk [ j ] . VXOH - 1
<operator>.subtraction wk [ j ] . nb - 1
<operator>.division ( wk [ j ] . VXOH ) / ( wk [ j ] . nb - 1 )
<operator>.subtraction wk [ j ] . nb - 1
<operator>.fieldAccess wk [ i ] . UEV
<operator>.fieldAccess wk [ i ] . nb
<operator>.indirectIndexAccess wk [ i ] . VVCECK [ j ]
<operator>.indirectIndexAccess wk [ i ]
FIELD_IDENTIFIER UEV UEV
<operator>.indirectIndexAccess wk [ i ]
FIELD_IDENTIFIER nb nb
<operator>.fieldAccess wk [ i ] . VVCECK
<operator>.indirectIndexAccess wk [ i ]
FIELD_IDENTIFIER VVCECK VVCECK
<operator>.indirectIndexAccess wk [ i ] . VVCECK [ j ]
<operator>.fieldAccess wk [ i ] . VVCECK
<operator>.fieldAccess wk [ i ] . UEV
<operator>.indirectIndexAccess wk [ i ]
FIELD_IDENTIFIER VVCECK VVCECK
<operator>.indirectIndexAccess wk [ i ]
FIELD_IDENTIFIER UEV UEV
<operator>.fieldAccess wk [ i ] . UEV
<operator>.fieldAccess wk [ j ] . VXOH
<operator>.fieldAccess wk [ j ] . nb
<operator>.fieldAccess wk [ j ] . VXOH
<operator>.indirectIndexAccess wk [ i ]
FIELD_IDENTIFIER UEV UEV
<operator>.indirectIndexAccess wk [ j ]
FIELD_IDENTIFIER VXOH VXOH
<operator>.indirectIndexAccess wk [ j ]
FIELD_IDENTIFIER nb nb
<operator>.indirectIndexAccess wk [ j ]
FIELD_IDENTIFIER VXOH VXOH
<operator>.fieldAccess wk [ j ] . nb
<operator>.indirectIndexAccess wk [ j ]
FIELD_IDENTIFIER nb nb
>>>PDG&52 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->12 0->14 0->16 0->17 0->19 2->3 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->7 3->7 3->9 3->20 3->21 3->23 3->24 3->25 3->26 4->1 4->3 5->1 5->3 7->3 7->7 7->8 7->8 7->22 7->27 7->28 7->29 8->7 9->7 10->1 10->11 10->12 10->13 10->14 10->15 10->16 10->17 10->18 10->19 10->32 10->35 10->36 10->37 10->38 10->39 10->40 10->41 10->42 10->43 10->44 10->45 10->46 10->47 10->48 10->49 10->50 10->51 11->12 12->6 12->14 13->14 14->6 14->12 15->11 15->11 16->15 16->15 17->15 17->15 18->13 18->13 19->18 19->18 22->10 22->30 22->31 22->33 22->34
>>>Token void UEV ( int n ) { double st ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( wk [ i ] . VVCECK [ j ] ) { if ( wk [ i ] . VVCECK [ j ] == LO ) { st = ( wk [ j ] . VXOH - 1 ) / ( wk [ j ] . nb - 1 ) ; wk [ i ] . UEV += st ; } else { st = ( wk [ j ] . VXOH ) / ( wk [ j ] . nb - 1 ) ; wk [ i ] . UEV += st ; } } wk [ i ] . UEV /= ( wk [ i ] . nb ) ; } }
>>>Func
METHOD SIXAEPV
METHOD_RETURN int
PARAM int x
PARAM int y
RETURN return x ; return x ;
<operator>.notEquals x != y
IDENTIFIER x return x ;
<operator>.greaterThan x > y
RETURN return SIXAEPV ( x - y , y ) ; return SIXAEPV ( x - y , y ) ;
SIXAEPV SIXAEPV ( x - y , y )
RETURN return SIXAEPV ( x , y - x ) ; return SIXAEPV ( x , y - x ) ;
SIXAEPV SIXAEPV ( x , y - x )
<operator>.subtraction x - y
<operator>.subtraction y - x
>>>PDG&14 0->2 0->3 0->5 0->6 0->7 0->9 0->11 0->12 0->13 2->5 3->5 4->1 5->1 5->4 5->6 5->7 5->7 5->7 6->4 7->1 7->8 7->9 7->10 7->11 7->12 7->12 7->12 7->13 7->13 7->13 8->1 9->1 9->1 9->1 9->8 10->1 11->10 12->1 12->9 12->9 13->11 13->11
>>>Token int SIXAEPV ( int x , int y ) { while ( x != y ) { if ( x > y ) return SIXAEPV ( x - y , y ) ; else return SIXAEPV ( x , y - x ) ; } return x ; }
>>>Func
METHOD main
METHOD_RETURN void
<operator>.assignment * NQIMJ = DWOTT ( "code1.in" , "r" )
<operator>.assignment * LRKGV = DWOTT ( "result1.in" , "w" )
<operator>.assignment p = ( char * ) malloc ( sizeof ( char ) * 100 )
CSMKFL CSMKFL ( NQIMJ , "%d" , & n )
HULAKX HULAKX ( LRKGV )
HULAKX HULAKX ( NQIMJ )
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
DWOTT DWOTT ( "code1.in" , "r" )
DWOTT DWOTT ( "result1.in" , "w" )
<operator>.cast ( char * ) malloc ( sizeof ( char ) * 100 )
<operator>.assignment i = 1
CSMKFL CSMKFL ( NQIMJ , "%d" , & q )
<operator>.assignment ch = VTNSW ( NQIMJ )
<operator>.assignment IMVJLC = ( char * * ) malloc ( sizeof ( char * ) * q )
CSMKFL CSMKFL ( NQIMJ , "%d" , & OJWYVID )
printf printf ( "%d" , OJWYVID )
<operator>.assignment ch = VTNSW ( NQIMJ )
<operator>.assignment UXYOJQ = ( int * ) calloc ( sizeof ( int ) , OJWYVID )
<operator>.assignment WDEY = ( char * * ) malloc ( sizeof ( char * ) * OJWYVID )
<operator>.assignment XLNUE = 0
<operator>.assignment XLNUE = KWWUCRUCJ ( q , OJWYVID , UXYOJQ )
fprintf fprintf ( LRKGV , "Case #%d: %d%c" , i , XLNUE , 10 )
free free ( UXYOJQ )
malloc malloc ( sizeof ( char ) * 100 )
<operator>.lessThan j < q
<operator>.postIncrement j ++
<operator>.lessThan j < q
<operator>.postIncrement j ++
<operator>.lessThan j < OJWYVID
<operator>.postIncrement j ++
<operator>.lessThan j < OJWYVID
<operator>.postIncrement j ++
<operator>.lessThan j < q
<operator>.postIncrement j ++
free free ( IMVJLC [ j ] )
<operator>.multiplication sizeof ( char ) * 100
VTNSW VTNSW ( NQIMJ )
<operator>.cast ( char * * ) malloc ( sizeof ( char * ) * q )
<operator>.assignment j = 0
<operator>.assignment * TUUH = ( char * ) malloc ( sizeof ( char ) * 100 )
<operator>.assignment IMVJLC [ j ] = TUUH
<operator>.assignment j = 0
IPLXB IPLXB ( p , 100 , NQIMJ )
strcpy strcpy ( IMVJLC [ j ] , p )
printf printf ( "%s" , IMVJLC [ j ] )
VTNSW VTNSW ( NQIMJ )
<operator>.cast ( int * ) calloc ( sizeof ( int ) , OJWYVID )
<operator>.cast ( char * * ) malloc ( sizeof ( char * ) * OJWYVID )
<operator>.assignment j = 0
<operator>.assignment * TUUH = ( char * ) malloc ( sizeof ( char ) * 100 )
<operator>.assignment WDEY [ j ] = TUUH
<operator>.assignment j = 0
IPLXB IPLXB ( p , 100 , NQIMJ )
strcpy strcpy ( WDEY [ j ] , p )
printf printf ( "%s" , WDEY [ j ] )
KWWUCRUCJ KWWUCRUCJ ( q , OJWYVID , UXYOJQ )
<operator>.assignment j = 0
<operator>.sizeOf sizeof ( char )
malloc malloc ( sizeof ( char * ) * q )
calloc calloc ( sizeof ( int ) , OJWYVID )
malloc malloc ( sizeof ( char * ) * OJWYVID )
<operator>.lessThan k < q
<operator>.postIncrement k ++
<operator>.multiplication sizeof ( char * ) * q
<operator>.cast ( char * ) malloc ( sizeof ( char ) * 100 )
<operator>.sizeOf sizeof ( int )
<operator>.multiplication sizeof ( char * ) * OJWYVID
<operator>.cast ( char * ) malloc ( sizeof ( char ) * 100 )
<operator>.assignment k = 0
<operator>.equals strcmp ( p , IMVJLC [ k ] ) == 0
malloc malloc ( sizeof ( char ) * 100 )
<operator>.sizeOf sizeof ( char * )
malloc malloc ( sizeof ( char ) * 100 )
<operator>.assignment UXYOJQ [ j ] = k
<operator>.multiplication sizeof ( char ) * 100
<operator>.multiplication sizeof ( char ) * 100
strcmp strcmp ( p , IMVJLC [ k ] )
<operator>.sizeOf sizeof ( char )
<operator>.addressOf & q
<operator>.addressOf & OJWYVID
UNKNOWN char * * char * *
UNKNOWN int * int *
UNKNOWN char * * char * *
<operator>.indirectIndexAccess IMVJLC [ j ]
<operator>.indirectIndexAccess IMVJLC [ j ]
<operator>.indirectIndexAccess IMVJLC [ j ]
<operator>.indirectIndexAccess IMVJLC [ j ]
<operator>.indirectIndexAccess WDEY [ j ]
<operator>.indirectIndexAccess WDEY [ j ]
<operator>.indirectIndexAccess WDEY [ j ]
<operator>.sizeOf sizeof ( char * )
UNKNOWN char * char *
UNKNOWN char * char *
<operator>.sizeOf sizeof ( char )
<operator>.indirectIndexAccess IMVJLC [ k ]
<operator>.indirectIndexAccess UXYOJQ [ j ]
>>>PDG&99 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->17 0->18 0->20 0->22 0->24 0->25 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->62 0->64 0->65 0->66 0->69 0->71 0->72 0->76 0->77 0->78 0->79 2->1 2->1 2->5 3->1 3->1 3->6 3->24 4->1 4->1 4->1 4->45 4->55 5->1 5->1 5->7 5->8 5->14 6->1 6->1 7->1 7->1 8->1 8->1 8->1 8->8 8->9 8->14 8->15 8->16 8->17 8->18 8->19 8->20 8->21 8->22 8->23 8->24 8->24 8->25 8->27 8->29 8->31 8->33 8->35 8->39 8->40 8->41 8->44 8->48 8->49 8->50 8->51 8->54 8->58 8->59 8->61 8->62 8->63 8->66 8->68 8->69 8->74 8->81 8->82 8->83 8->84 8->85 8->93 9->1 9->8 10->2 10->2 11->3 11->3 12->1 13->1 13->8 14->1 14->1 14->27 14->29 14->35 14->39 14->58 14->64 14->66 16->1 16->1 16->1 16->37 16->46 16->47 16->79 17->1 17->1 17->18 17->20 17->31 17->33 17->48 17->49 17->58 17->62 17->69 18->1 18->20 18->49 18->62 18->69 19->1 19->1 19->1 20->1 20->1 20->58 21->1 21->1 21->1 21->56 21->57 22->1 23->1 23->1 23->24 24->1 24->1 24->6 24->9 25->1 26->1 26->4 26->12 27->27 27->28 27->28 27->29 27->42 27->43 27->67 27->73 27->77 27->87 27->94 27->96 28->1 28->27 29->29 29->30 29->30 29->45 29->46 29->47 29->58 29->64 29->88 29->89 30->1 30->29 31->31 31->32 31->32 31->33 31->52 31->53 31->70 31->75 31->78 31->80 31->90 31->95 32->1 32->31 33->1 33->33 33->34 33->34 33->55 33->56 33->57 33->58 33->64 33->71 33->91 33->92 34->1 34->33 35->1 35->1 35->1 35->14 35->35 35->36 35->36 35->37 35->66 35->86 36->1 36->35 37->1 37->46 38->26 39->15 39->17 39->45 40->1 41->27 42->1 42->1 42->43 43->1 43->1 43->1 43->37 43->46 44->29 45->1 45->17 45->46 46->1 46->1 46->45 46->47 46->55 47->1 47->1 47->37 47->46 48->7 48->14 48->19 48->55 49->1 50->1 51->31 52->1 52->1 52->53 53->1 53->1 53->1 53->56 54->33 55->1 55->7 55->14 55->56 56->1 56->1 56->45 56->55 56->57 56->79 57->1 57->1 57->56 58->1 58->17 58->18 58->23 58->23 58->23 58->25 58->35 59->1 59->35 60->1 61->1 61->16 61->40 63->1 63->21 63->50 64->1 64->1 64->58 64->65 64->72 64->76 64->79 64->97 65->1 65->64 66->27 66->61 67->1 68->1 69->31 69->63 70->1 71->1 71->64 72->1 72->1 72->64 72->65 72->76 72->98 73->1 73->42 73->67 74->1 75->1 75->52 75->70 76->1 76->1 76->1 76->25 76->58 77->73 78->75 79->1 79->1 79->45 79->55 79->72 79->72 80->1
>>>Token void main ( ) { MUSY * NQIMJ = DWOTT ( " " , " " ) ; MUSY * LRKGV = DWOTT ( " " , " " ) ; char * * IMVJLC , * p , * * WDEY , ch ; int i , j , k , XLNUE ; int n , q , OJWYVID , * UXYOJQ ; p = ( char * ) malloc ( sizeof ( char ) * 100 ) ; CSMKFL ( NQIMJ , " " , & n ) ; for ( i = 1 ; i <= n ; i ++ ) { CSMKFL ( NQIMJ , " " , & q ) ; ch = VTNSW ( NQIMJ ) ; IMVJLC = ( char * * ) malloc ( sizeof ( char * ) * q ) ; for ( j = 0 ; j < q ; j ++ ) { char * TUUH = ( char * ) malloc ( sizeof ( char ) * 100 ) ; IMVJLC [ j ] = TUUH ; } for ( j = 0 ; j < q ; j ++ ) { IPLXB ( p , 100 , NQIMJ ) ; strcpy ( IMVJLC [ j ] , p ) ; printf ( " " , IMVJLC [ j ] ) ; } CSMKFL ( NQIMJ , " " , & OJWYVID ) ; printf ( " " , OJWYVID ) ; ch = VTNSW ( NQIMJ ) ; UXYOJQ = ( int * ) calloc ( sizeof ( int ) , OJWYVID ) ; WDEY = ( char * * ) malloc ( sizeof ( char * ) * OJWYVID ) ; for ( j = 0 ; j < OJWYVID ; j ++ ) { char * TUUH = ( char * ) malloc ( sizeof ( char ) * 100 ) ; WDEY [ j ] = TUUH ; } for ( j = 0 ; j < OJWYVID ; j ++ ) { IPLXB ( p , 100 , NQIMJ ) ; strcpy ( WDEY [ j ] , p ) ; printf ( " " , WDEY [ j ] ) ; for ( k = 0 ; k < q ; k ++ ) if ( strcmp ( p , IMVJLC [ k ] ) == 0 ) { UXYOJQ [ j ] = k ; break ; } } XLNUE = 0 ; XLNUE = KWWUCRUCJ ( q , OJWYVID , UXYOJQ ) ; fprintf ( LRKGV , " " , i , XLNUE , 10 ) ; for ( j = 0 ; j < q ; j ++ ) free ( IMVJLC [ j ] ) ; free ( UXYOJQ ) ; } HULAKX ( LRKGV ) ; HULAKX ( NQIMJ ) ; }
>>>Func
METHOD main
METHOD_RETURN void
SOISV SOISV ( "%d" , & t )
<operator>.lessThan i < t
<operator>.postIncrement i ++
<operator>.lessThan i < t
<operator>.postIncrement i ++
<operator>.assignment i = 0
SOISV SOISV ( "%d" , & n )
<operator>.assignment KJUNCP [ i ] = n
<operator>.assignment i = 0
printf printf ( "Case #%d:\n" , i + 1 , XNF [ i ] )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < KJUNCP [ i ]
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment co = 0
SOISV SOISV ( "%s" , ch )
<operator>.assignment LOE = 0
<operator>.assignment wp [ j ] [ 0 ] = LOE / ( double ) co
<operator>.assignment wp [ j ] [ 1 ] = co
<operator>.assignment j = 0
<operator>.assignment s = 0
<operator>.assignment GER [ j ] = s / wp [ j ] [ 1 ]
<operator>.assignment j = 0
<operator>.assignment s = 0
<operator>.assignment EOTV [ j ] = s / wp [ j ] [ 1 ]
<operator>.assignment j = 0
<operator>.assignment TJK = 0.25 * wp [ j ] [ 0 ] + 0.50 * GER [ j ] + 0.25 * EOTV [ j ]
<operator>.assignment XNF [ i ] [ j ] = TJK
<operator>.addition i + 1
<operator>.assignment j = 0
printf printf ( "%g\n" , XNF [ i ] [ j ] )
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.assignment k = 0
<operator>.division LOE / ( double ) co
<operator>.assignment k = 0
<operator>.division s / wp [ j ] [ 1 ]
<operator>.assignment k = 0
<operator>.division s / wp [ j ] [ 1 ]
<operator>.addition 0.25 * wp [ j ] [ 0 ] + 0.50 * GER [ j ] + 0.25 * EOTV [ j ]
<operator>.equals ch [ k ] == '.'
<operator>.notEquals PCY [ j ] [ k ] != - 1
<operator>.cast ( double ) co
<operator>.notEquals j != k
<operator>.notEquals j != k
<operator>.addition 0.25 * wp [ j ] [ 0 ] + 0.50 * GER [ j ]
<operator>.multiplication 0.25 * EOTV [ j ]
<operator>.assignment PCY [ j ] [ k ] = - 1
<operator>.assignmentPlus LOE += PCY [ j ] [ k ]
<operator>.postIncrement co ++
<operator>.multiplication 0.25 * wp [ j ] [ 0 ]
<operator>.multiplication 0.50 * GER [ j ]
<operator>.minus - 1
<operator>.notEquals PCY [ k ] [ j ] != - 1
<operator>.notEquals PCY [ j ] [ k ] != - 1
<operator>.minus - 1
<operator>.equals ch [ k ] == '0'
<operator>.assignmentPlus s += ( wp [ k ] [ 0 ] * wp [ k ] [ 1 ] - PCY [ k ] [ j ] ) / ( wp [ k ] [ 1 ] - 1 )
<operator>.assignmentPlus s += GER [ k ]
<operator>.assignment PCY [ j ] [ k ] = 0
<operator>.minus - 1
<operator>.minus - 1
<operator>.division ( wp [ k ] [ 0 ] * wp [ k ] [ 1 ] - PCY [ k ] [ j ] ) / ( wp [ k ] [ 1 ] - 1 )
<operator>.equals ch [ k ] == '1'
<operator>.subtraction wp [ k ] [ 0 ] * wp [ k ] [ 1 ] - PCY [ k ] [ j ]
<operator>.subtraction wp [ k ] [ 1 ] - 1
<operator>.assignment PCY [ j ] [ k ] = 1
<operator>.multiplication wp [ k ] [ 0 ] * wp [ k ] [ 1 ]
<operator>.addressOf & n
<operator>.indirectIndexAccess KJUNCP [ i ]
<operator>.indirectIndexAccess XNF [ i ]
<operator>.indirectIndexAccess KJUNCP [ i ]
<operator>.indirectIndexAccess wp [ j ] [ 0 ]
<operator>.indirectIndexAccess wp [ j ] [ 1 ]
<operator>.indirectIndexAccess GER [ j ]
<operator>.indirectIndexAccess EOTV [ j ]
<operator>.indirectIndexAccess XNF [ i ] [ j ]
<operator>.indirectIndexAccess XNF [ i ] [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess wp [ j ] [ 1 ]
<operator>.indirectIndexAccess wp [ j ] [ 1 ]
<operator>.indirectIndexAccess XNF [ i ]
<operator>.indirectIndexAccess XNF [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess EOTV [ j ]
<operator>.indirectIndexAccess ch [ k ]
<operator>.indirectIndexAccess PCY [ j ] [ k ]
<operator>.indirectIndexAccess wp [ j ] [ 0 ]
<operator>.indirectIndexAccess GER [ j ]
<operator>.indirectIndexAccess PCY [ j ] [ k ]
<operator>.indirectIndexAccess PCY [ j ]
<operator>.indirectIndexAccess PCY [ j ] [ k ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess PCY [ j ]
<operator>.indirectIndexAccess PCY [ j ]
<operator>.indirectIndexAccess PCY [ k ] [ j ]
<operator>.indirectIndexAccess PCY [ j ] [ k ]
<operator>.indirectIndexAccess ch [ k ]
<operator>.indirectIndexAccess PCY [ k ]
<operator>.indirectIndexAccess PCY [ j ]
<operator>.indirectIndexAccess GER [ k ]
<operator>.indirectIndexAccess PCY [ j ] [ k ]
<operator>.indirectIndexAccess PCY [ j ]
<operator>.indirectIndexAccess PCY [ k ] [ j ]
<operator>.indirectIndexAccess wp [ k ] [ 1 ]
<operator>.indirectIndexAccess ch [ k ]
<operator>.indirectIndexAccess wp [ k ] [ 0 ]
<operator>.indirectIndexAccess wp [ k ] [ 1 ]
<operator>.indirectIndexAccess PCY [ k ]
<operator>.indirectIndexAccess wp [ k ]
<operator>.indirectIndexAccess PCY [ j ] [ k ]
<operator>.indirectIndexAccess wp [ k ]
<operator>.indirectIndexAccess wp [ k ]
<operator>.indirectIndexAccess PCY [ j ]
>>>PDG&130 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->28 0->29 0->31 0->32 0->34 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->53 0->55 0->56 0->57 0->59 0->61 0->62 0->63 0->64 0->65 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->76 0->78 0->79 2->1 2->1 2->3 2->5 3->3 3->4 3->4 3->5 3->8 3->9 3->12 3->14 3->16 3->18 3->22 3->28 3->31 3->34 3->81 3->82 4->1 4->3 5->1 5->1 5->1 5->5 5->6 5->6 5->11 5->11 5->20 5->37 5->37 5->38 5->83 5->84 6->1 6->5 7->3 8->1 8->1 8->9 8->12 8->14 8->16 8->18 8->40 8->42 8->44 9->1 9->1 9->20 10->1 10->5 11->1 11->1 11->1 12->12 12->13 12->13 12->14 12->23 12->24 12->25 12->26 12->27 12->40 12->40 12->46 12->47 12->55 12->85 12->86 12->91 12->92 12->97 13->1 13->12 14->14 14->15 14->15 14->16 14->29 14->30 14->42 14->42 14->48 14->49 14->56 14->87 14->93 14->98 15->1 15->14 16->16 16->17 16->17 16->18 16->32 16->33 16->44 16->44 16->50 16->51 16->57 16->88 16->94 16->99 17->1 17->16 18->1 18->1 18->1 18->8 18->9 18->12 18->18 18->19 18->19 18->35 18->36 18->52 18->58 18->59 18->63 18->64 18->89 18->95 18->100 18->103 18->104 18->108 19->1 19->18 20->1 20->1 20->1 20->20 20->21 20->21 20->39 20->84 20->90 20->96 21->1 21->20 22->12 23->1 23->27 23->47 23->55 23->62 24->1 24->1 24->53 24->69 24->76 25->1 25->47 25->61 26->1 26->1 26->1 26->63 27->1 27->1 27->1 27->49 27->51 28->14 29->1 29->49 29->70 30->1 30->1 30->1 30->64 31->16 32->1 32->51 32->71 33->1 33->1 33->1 33->59 34->1 34->18 35->1 35->1 35->36 36->1 36->1 36->1 36->11 36->39 38->1 38->20 39->1 39->1 39->11 40->1 40->1 40->12 40->40 40->41 40->41 40->53 40->54 40->65 40->101 40->102 40->106 41->1 41->40 42->1 42->1 42->14 42->42 42->43 42->56 42->56 43->1 43->42 44->1 44->1 44->16 44->44 44->45 44->57 44->57 45->1 45->44 46->1 46->40 47->1 47->1 47->26 47->26 48->1 48->42 49->1 49->1 49->30 49->30 49->51 50->1 50->44 51->1 51->1 51->33 51->33 51->49 52->1 52->1 53->1 53->1 53->24 53->60 53->68 53->69 53->69 53->105 53->109 53->113 54->1 54->1 54->1 54->61 54->61 54->62 54->67 54->107 54->110 56->1 56->15 56->43 56->66 56->73 56->111 56->114 57->1 57->17 57->45 57->67 57->74 57->112 57->115 58->1 58->1 59->1 59->35 59->35 59->52 59->52 60->1 60->54 61->1 61->1 61->47 62->1 62->27 62->47 62->55 63->1 63->35 63->35 63->52 63->52 63->58 63->58 64->1 64->35 64->35 64->52 64->52 64->58 64->58 65->54 66->1 66->1 66->1 66->70 66->75 66->77 66->77 66->78 66->80 66->119 66->120 66->122 66->123 66->124 66->125 66->127 66->128 67->1 67->1 67->1 67->54 67->71 67->116 68->60 69->1 69->1 69->24 69->53 69->72 69->76 69->76 69->117 69->118 69->121 70->1 70->1 70->49 71->1 71->1 71->51 72->1 72->54 73->66 74->67 75->1 75->1 75->70 75->70 76->1 76->1 76->24 76->53 76->79 76->126 76->129 77->1 77->1 77->66 77->75 77->75 78->1 78->75 78->75 78->80 79->1 79->54 80->1 80->77 80->77 80->78
>>>Token void main ( ) { int t , i , j ; SOISV ( " " , & t ) ; for ( i = 0 ; i < t ; i ++ ) { int n , k ; SOISV ( " " , & n ) ; KJUNCP [ i ] = n ; for ( j = 0 ; j < n ; j ++ ) { int co = 0 ; char ch [ 100 ] ; SOISV ( " " , ch ) ; int LOE = 0 ; for ( k = 0 ; k < n ; k ++ ) { if ( ch [ k ] == ' ' ) PCY [ j ] [ k ] = - 1 ; else if ( ch [ k ] == ' ' ) PCY [ j ] [ k ] = 0 ; else if ( ch [ k ] == ' ' ) PCY [ j ] [ k ] = 1 ; if ( PCY [ j ] [ k ] != - 1 ) { LOE += PCY [ j ] [ k ] ; co ++ ; } } wp [ j ] [ 0 ] = LOE / ( double ) co ; wp [ j ] [ 1 ] = co ; } for ( j = 0 ; j < n ; j ++ ) { double s = 0 ; for ( k = 0 ; k < n ; k ++ ) { if ( j != k ) { if ( PCY [ k ] [ j ] != - 1 ) s += ( wp [ k ] [ 0 ] * wp [ k ] [ 1 ] - PCY [ k ] [ j ] ) / ( wp [ k ] [ 1 ] - 1 ) ; } } GER [ j ] = s / wp [ j ] [ 1 ] ; } for ( j = 0 ; j < n ; j ++ ) { double s = 0 ; for ( k = 0 ; k < n ; k ++ ) { if ( j != k ) { if ( PCY [ j ] [ k ] != - 1 ) s += GER [ k ] ; } } EOTV [ j ] = s / wp [ j ] [ 1 ] ; } for ( j = 0 ; j < n ; j ++ ) { double TJK = 0.25 * wp [ j ] [ 0 ] + 0.50 * GER [ j ] + 0.25 * EOTV [ j ] ; XNF [ i ] [ j ] = TJK ; } } for ( i = 0 ; i < t ; i ++ ) { printf ( " \n " , i + 1 , XNF [ i ] ) ; for ( j = 0 ; j < KJUNCP [ i ] ; j ++ ) { printf ( " \n " , XNF [ i ] [ j ] ) ; } } }
>>>Func
METHOD XEWNKSO
METHOD_RETURN void
PARAM const int * HKK
PARAM int n
printf printf ( "\n" )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
printf printf ( "%d " , HKK [ i ] )
<operator>.indirectIndexAccess HKK [ i ]
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 2->8 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->8 5->9 6->1 6->5 7->1 7->5 8->1 8->1
>>>Token void XEWNKSO ( const int * HKK , int n ) { for ( int i = 0 ; i < n ; i ++ ) { printf ( " " , HKK [ i ] ) ; } printf ( " \n " ) ; }
>>>Func
METHOD THUM
METHOD_RETURN void
PARAM int a
PARAM int b
<operator>.greaterEqualsThan a >= b
<operator>.lessEqualsThan i <= b - 1
<operator>.postIncrement i ++
RETURN return ; return ;
<operator>.assignment i = a
<operator>.lessEqualsThan j <= b
<operator>.postIncrement j ++
<operator>.subtraction b - 1
<operator>.assignment j = i + 1
<operator>.greaterThan QOT [ i ] > QOT [ j ]
LQFP LQFP ( & QOT [ i ] , & QOT [ j ] )
<operator>.addition i + 1
<operator>.indirectIndexAccess QOT [ i ]
<operator>.indirectIndexAccess QOT [ j ]
<operator>.addressOf & QOT [ i ]
<operator>.addressOf & QOT [ j ]
<operator>.indirectIndexAccess QOT [ i ]
<operator>.indirectIndexAccess QOT [ j ]
>>>PDG&22 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->15 2->4 3->4 4->1 4->1 4->1 4->5 4->7 4->8 4->8 4->11 4->11 5->5 5->6 5->6 5->9 5->11 5->12 5->12 5->15 5->15 6->5 7->1 8->5 9->9 9->10 9->10 9->11 9->13 9->16 9->17 10->9 11->5 11->5 11->9 12->9 13->14 13->14 13->14 13->18 13->19 13->20 13->21 14->13 14->13
>>>Token void THUM ( int a , int b ) { int i , j ; if ( a >= b ) return ; for ( i = a ; i <= b - 1 ; i ++ ) for ( j = i + 1 ; j <= b ; j ++ ) if ( QOT [ i ] > QOT [ j ] ) LQFP ( & QOT [ i ] , & QOT [ j ] ) ; }
>>>Func
METHOD FNXFF
METHOD_RETURN double
PARAM int YSYU
PARAM int N
<operator>.assignment LLJYT = 0
<operator>.assignment EYEYD = 0
RETURN return LLJYT / EYEYD ; return LLJYT / EYEYD ;
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.division LLJYT / EYEYD
<operator>.assignment i = 0
<operator>.assignmentPlus LLJYT += HLHS ( i , N )
<operator>.assignmentPlus EYEYD += 1.0
<operator>.logicalOr i == YSYU || WPITP [ YSYU ] [ i ] == '.'
HLHS HLHS ( i , N )
<operator>.equals i == YSYU
<operator>.equals WPITP [ YSYU ] [ i ] == '.'
<operator>.indirectIndexAccess WPITP [ YSYU ] [ i ]
<operator>.indirectIndexAccess WPITP [ YSYU ]
>>>PDG&19 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 2->1 2->15 3->7 4->1 4->9 4->11 5->1 5->9 5->12 6->1 7->1 7->1 7->1 7->7 7->8 7->13 7->14 7->15 7->15 8->1 8->7 9->1 9->1 9->1 9->6 10->1 10->7 11->1 11->1 11->9 12->1 12->9 13->1 13->1 13->1 13->11 13->12 13->14 14->7 14->8 14->11 14->11 15->1 15->8 15->13 15->13 15->14 15->16 15->17 15->18 16->1 16->13 16->13
>>>Token double FNXFF ( int YSYU , int N ) { int i ; double LLJYT , EYEYD ; LLJYT = 0 ; EYEYD = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i == YSYU || WPITP [ YSYU ] [ i ] == ' ' ) { continue ; } LLJYT += HLHS ( i , N ) ; EYEYD += 1.0 ; } return LLJYT / EYEYD ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment * RVPNNWK = LYKLR ( argv [ 1 ] , "r" )
NFXXCC NFXXCC ( RVPNNWK , "%d" , & AHHOGVATS )
RETURN return 0 ; return 0 ;
<operator>.lessThan argc < 2
<operator>.equals RVPNNWK == NULL
<operator>.lessEqualsThan i <= AHHOGVATS
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
fprintf fprintf ( stderr , "no filename given\n" )
exit exit ( 1 )
LYKLR LYKLR ( argv [ 1 ] , "r" )
fprintf fprintf ( stderr , "error while loading file\n" )
RETURN return 1 ; return 1 ;
<operator>.assignment i = 1
<operator>.assignment XMLO = 0
NFXXCC NFXXCC ( RVPNNWK , "%d" , & n )
NFXXCC NFXXCC ( RVPNNWK , "%d" , & pd )
NFXXCC NFXXCC ( RVPNNWK , "%d" , & pg )
printf printf ( "Case #%d: %s\n" , i , XMLO == 1 ? "Possible" : "Broken" )
LITERAL 1 return 1 ;
<operator>.greaterEqualsThan n >= 100
<operator>.equals XMLO == 1
<operator>.postIncrement XMLO ++
<operator>.conditional XMLO == 1 ? "Possible" : "Broken"
<operator>.logicalAnd pd != 0 && pg == 0
<operator>.equals XMLO == 1
<operator>.greaterEqualsThan n >= 50
<operator>.logicalAnd XMLO == 0 && n >= 25
<operator>.logicalAnd XMLO == 0 && n >= 20
<operator>.logicalAnd XMLO == 0 && n >= 10
<operator>.logicalAnd XMLO == 0 && n >= 5
<operator>.logicalAnd XMLO == 0 && n >= 4
<operator>.logicalAnd XMLO == 0 && n >= 2
<operator>.equals XMLO == 0
<operator>.postDecrement XMLO --
<operator>.notEquals pd != 0
<operator>.equals pg == 0
<operator>.equals pd % 2 == 0
<operator>.equals XMLO == 0
<operator>.greaterEqualsThan n >= 25
<operator>.equals pd % 4 == 0
<operator>.equals XMLO == 0
<operator>.greaterEqualsThan n >= 20
<operator>.equals pd % 5 == 0
<operator>.equals XMLO == 0
<operator>.greaterEqualsThan n >= 10
<operator>.equals pd % 10 == 0
<operator>.equals XMLO == 0
<operator>.greaterEqualsThan n >= 5
<operator>.equals pd % 20 == 0
<operator>.equals XMLO == 0
<operator>.greaterEqualsThan n >= 4
<operator>.equals pd % 25 == 0
<operator>.equals XMLO == 0
<operator>.greaterEqualsThan n >= 2
<operator>.equals pd % 50 == 0
<operator>.equals pd % 100 == 0
<operator>.logicalAnd pd != 100 && pg == 100
<operator>.postIncrement XMLO ++
<operator>.postIncrement XMLO ++
<operator>.postIncrement XMLO ++
<operator>.postIncrement XMLO ++
<operator>.postIncrement XMLO ++
<operator>.postIncrement XMLO ++
<operator>.postIncrement XMLO ++
<operator>.postIncrement XMLO ++
<operator>.postDecrement XMLO --
<operator>.modulo pd % 2
<operator>.modulo pd % 4
<operator>.modulo pd % 5
<operator>.modulo pd % 10
<operator>.modulo pd % 20
<operator>.modulo pd % 25
<operator>.modulo pd % 50
<operator>.modulo pd % 100
<operator>.notEquals pd != 100
<operator>.equals pg == 100
<operator>.addressOf & AHHOGVATS
<operator>.addressOf & n
<operator>.addressOf & pd
<operator>.addressOf & pg
>>>PDG&85 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 2->7 3->1 3->14 4->1 4->1 4->8 5->9 5->19 6->1 7->1 7->1 7->12 7->13 8->1 8->1 8->1 8->5 8->5 8->6 8->9 8->15 8->16 8->17 8->81 9->9 9->10 9->18 9->19 9->20 9->21 9->22 9->22 9->24 9->25 9->27 9->29 9->82 9->83 9->84 10->9 11->6 12->1 12->15 14->1 14->4 14->4 15->1 15->1 16->1 17->9 18->26 18->42 18->62 19->20 19->24 19->30 19->43 19->46 19->49 19->52 19->55 19->58 20->21 20->39 20->71 20->72 20->73 20->74 20->75 20->76 20->77 20->78 20->79 21->19 21->40 21->80 22->10 23->16 24->19 24->26 24->30 24->30 24->31 24->32 24->33 24->34 24->35 24->36 24->37 24->42 24->45 24->48 24->51 24->54 24->57 25->28 25->29 25->38 25->39 25->70 26->25 28->38 28->61 28->79 30->19 30->24 30->41 30->43 30->46 30->49 30->52 30->55 30->58 30->71 31->44 31->72 32->47 32->73 33->50 33->74 34->53 34->75 35->56 35->76 36->59 36->77 37->25 37->60 37->69 37->78 38->29 39->20 39->28 39->28 39->40 39->71 39->72 39->73 39->74 39->75 39->76 39->77 39->78 39->79 40->21 40->28 40->28 40->80 41->62 42->31 42->31 42->43 42->45 42->63 43->19 43->24 43->31 43->31 43->46 43->49 43->52 43->55 43->58 44->63 45->32 45->32 45->46 45->48 45->64 46->19 46->24 46->32 46->32 46->49 46->52 46->55 46->58 47->64 48->33 48->33 48->49 48->51 48->65 49->19 49->24 49->33 49->33 49->52 49->55 49->58 50->65 51->34 51->34 51->52 51->54 51->66 52->19 52->24 52->34 52->34 52->55 52->58 53->66 54->35 54->35 54->55 54->57 54->67 55->19 55->24 55->35 55->35 55->58 56->67 57->36 57->36 57->37 57->58 57->68 58->19 58->24 58->36 58->36 59->68 60->69 61->70 62->42 63->45 64->48 65->51 66->54 67->57 68->37 69->25 70->29 71->20 71->39 71->41 71->41 71->72 71->73 71->74 71->75 71->76 71->77 71->78 72->20 72->39 72->44 72->44 72->71 72->73 72->74 72->75 72->76 72->77 72->78 73->20 73->39 73->47 73->47 73->71 73->72 73->74 73->75 73->76 73->77 73->78 74->20 74->39 74->50 74->50 74->71 74->72 74->73 74->75 74->76 74->77 74->78 75->20 75->39 75->53 75->53 75->71 75->72 75->73 75->74 75->76 75->77 75->78 76->20 76->39 76->56 76->56 76->71 76->72 76->73 76->74 76->75 76->77 76->78 77->20 77->39 77->59 77->59 77->71 77->72 77->73 77->74 77->75 77->76 77->78 78->20 78->39 78->60 78->60 78->71 78->72 78->73 78->74 78->75 78->76 78->77 79->20 79->39 79->61 79->61 79->71 79->72 79->73 79->74 79->75 79->76 79->77 79->78 79->80 80->21 80->40 80->61 80->61
>>>Token int main ( int argc , char * argv [ ] ) { int AHHOGVATS ; if ( argc < 2 ) { fprintf ( stderr , " \n " ) ; exit ( 1 ) ; } LBEK * RVPNNWK = LYKLR ( argv [ 1 ] , " " ) ; if ( RVPNNWK == NULL ) { fprintf ( stderr , " \n " ) ; return 1 ; } NFXXCC ( RVPNNWK , " " , & AHHOGVATS ) ; int i ; int j ; for ( i = 1 ; i <= AHHOGVATS ; i ++ ) { int XMLO = 0 ; int n ; int pd ; int pg ; NFXXCC ( RVPNNWK , " " , & n ) ; NFXXCC ( RVPNNWK , " " , & pd ) ; NFXXCC ( RVPNNWK , " " , & pg ) ; if ( n >= 100 ) { XMLO ++ ; } else { if ( n >= 50 ) { if ( pd % 2 == 0 ) { XMLO ++ ; } } if ( XMLO == 0 && n >= 25 ) { if ( pd % 4 == 0 ) { XMLO ++ ; } } if ( XMLO == 0 && n >= 20 ) { if ( pd % 5 == 0 ) { XMLO ++ ; } } if ( XMLO == 0 && n >= 10 ) { if ( pd % 10 == 0 ) { XMLO ++ ; } } if ( XMLO == 0 && n >= 5 ) { if ( pd % 20 == 0 ) { XMLO ++ ; } } if ( XMLO == 0 && n >= 4 ) { if ( pd % 25 == 0 ) { XMLO ++ ; } } if ( XMLO == 0 && n >= 2 ) { if ( pd % 50 == 0 ) { XMLO ++ ; } } if ( XMLO == 0 ) { if ( pd % 100 == 0 ) { XMLO ++ ; } } } if ( XMLO == 1 ) { if ( pd != 0 && pg == 0 ) { XMLO -- ; } else if ( pd != 100 && pg == 100 ) { XMLO -- ; } } printf ( " \n " , i , XMLO == 1 ? " " : " " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
HPOWW HPOWW ( "%d" , & n )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
HPOWW HPOWW ( "%d" , & s )
PPJSCUU PPJSCUU ( )
HPOWW HPOWW ( "%d" , & q )
PPJSCUU PPJSCUU ( )
<operator>.assignment NFBSLB = - 1
<operator>.assignment KJC = - 1
<operator>.assignment KOQ = - 1
printf printf ( "Case #%d: %d\n" , i + 1 , KJC )
<operator>.lessThan k < 100
<operator>.postIncrement k ++
<operator>.lessThan j < s
<operator>.postIncrement j ++
<operator>.lessThan j < q
<operator>.postIncrement j ++
<operator>.lessThan NFBSLB < q
<operator>.assignment k = 0
<operator>.assignment j = 0
MLML MLML ( FUHNL [ j ] )
<operator>.assignment j = 0
MLML MLML ( SYHJK )
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.postIncrement KJC ++
<operator>.postIncrement NFBSLB ++
<operator>.assignment NFBSLB = KOQ
<operator>.addition i + 1
<operator>.lessThan j < 1000
<operator>.postIncrement j ++
<operator>.assignment YANAND [ k ] [ j ] = 0
<operator>.lessThan k < s
<operator>.postIncrement k ++
<operator>.lessThan k < s
<operator>.postIncrement k ++
<operator>.assignment j = 0
<operator>.assignment k = 0
<operator>.assignment k = 0
<operator>.assignment a = NFBSLB
<operator>.logicalNot ! strcmp ( SYHJK , FUHNL [ k ] )
<operator>.notEquals YANAND [ k ] [ a ] != 1
<operator>.postIncrement a ++
<operator>.lessThan KOQ < a - 1
<operator>.assignment YANAND [ k ] [ j ] = 1
<operator>.assignment KOQ = a - 1
strcmp strcmp ( SYHJK , FUHNL [ k ] )
<operator>.subtraction a - 1
<operator>.subtraction a - 1
<operator>.addressOf & s
<operator>.addressOf & q
<operator>.indirectIndexAccess FUHNL [ j ]
<operator>.indirectIndexAccess YANAND [ k ] [ j ]
<operator>.indirectIndexAccess YANAND [ k ]
<operator>.indirectIndexAccess YANAND [ k ] [ a ]
<operator>.indirectIndexAccess FUHNL [ k ]
<operator>.indirectIndexAccess YANAND [ k ] [ j ]
<operator>.indirectIndexAccess YANAND [ k ]
<operator>.indirectIndexAccess YANAND [ k ]
>>>PDG&64 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->49 0->51 0->52 0->53 2->1 3->1 3->1 3->4 4->1 4->1 4->1 4->4 4->5 4->5 4->7 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->14 4->15 4->17 4->19 4->21 4->22 4->23 4->25 4->27 4->28 4->29 4->33 4->33 4->54 4->55 5->1 5->4 6->1 6->4 7->17 7->37 7->39 9->19 9->21 11->21 12->14 12->30 13->32 13->48 15->15 15->16 15->16 15->34 15->41 16->15 17->7 17->17 17->18 17->18 17->24 17->37 17->39 17->56 18->17 19->19 19->20 19->20 19->21 19->26 19->37 19->42 20->19 21->9 21->19 21->21 21->30 21->31 21->31 21->32 21->39 21->43 22->15 23->17 25->19 26->51 27->11 28->12 29->13 30->14 31->44 32->21 34->34 34->35 34->35 34->36 34->57 34->58 35->34 37->7 37->17 37->38 37->39 37->45 37->51 37->60 38->37 39->7 39->17 39->39 39->40 39->40 39->44 39->46 39->48 39->52 39->59 39->62 40->39 41->34 42->37 43->39 44->47 44->52 45->37 45->38 45->49 45->61 45->63 46->46 46->47 46->59 46->62 47->52 48->32 48->50 48->53 50->32 50->48 51->26 51->45 51->45 52->48 52->48 52->53 53->50 53->50
>>>Token int main ( void ) { int n , i , q , j , s , k , a , NFBSLB , KJC , KOQ , YANAND [ 100 ] [ 1000 ] ; char SYHJK [ 101 ] , FUHNL [ 100 ] [ 101 ] ; HPOWW ( " " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { for ( k = 0 ; k < 100 ; k ++ ) { for ( j = 0 ; j < 1000 ; j ++ ) YANAND [ k ] [ j ] = 0 ; } HPOWW ( " " , & s ) ; PPJSCUU ( ) ; for ( j = 0 ; j < s ; j ++ ) { MLML ( FUHNL [ j ] ) ; } HPOWW ( " " , & q ) ; PPJSCUU ( ) ; for ( j = 0 ; j < q ; j ++ ) { MLML ( SYHJK ) ; for ( k = 0 ; k < s ; k ++ ) { if ( ! strcmp ( SYHJK , FUHNL [ k ] ) ) { YANAND [ k ] [ j ] = 1 ; break ; } } } NFBSLB = - 1 ; KJC = - 1 ; KOQ = - 1 ; while ( NFBSLB < q ) { KJC ++ ; NFBSLB ++ ; for ( k = 0 ; k < s ; k ++ ) { a = NFBSLB ; while ( YANAND [ k ] [ a ] != 1 ) a ++ ; if ( KOQ < a - 1 ) { KOQ = a - 1 ; } } NFBSLB = KOQ ; } printf ( " \n " , i + 1 , KJC ) ; } }
>>>Func
METHOD RUBRS
METHOD_RETURN void
PARAM const int n
<operator>.assignment CMX = 0
LHQMO LHQMO ( "%d %lld %d %d " , & L , & t , & N , & C )
<operator>.assignment XBB [ C ] = 0
<operator>.assignment OJU [ C ] = 0
<operator>.assignment OAE [ C ] = C
XEICQ XEICQ ( OAE   C + 1   sizeof ( int ) , AWR )
printf printf ( "Case #%d: %d\n" , n , CMX )
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.logicalAnd N && i <= C
<operator>.postIncrement i ++
<operator>.assignment i = 0
LHQMO LHQMO ( "%d " , & XBB [ i ] )
<operator>.assignment OAE [ i ] = i
<operator>.assignment OJU [ i ] = 0
<operator>.assignment i = 0
<operator>.assignment LCDT = XBB [ i % C ]
<operator>.assignmentPlus CMX += LCDT * 2
<operator>.addition C + 1
<operator>.sizeOf sizeof ( int )
<operator>.assignment i = 0
<operator>.assignment j = OAE [ i ]
<operator>.assignment w = ( OJU [ j ] > L ) ? L : OJU [ j ]
<operator>.assignmentMinus L -= w
<operator>.assignmentMinus OJU [ j ] -= w
<operator>.assignmentMinus CMX -= XBB [ j ] * w
<operator>.greaterThan CMX > t
<operator>.lessEqualsThan i <= C
<operator>.postIncrement OJU [ i % C ] ++
<operator>.multiplication LCDT * 2
<operator>.conditional ( OJU [ j ] > L ) ? L : OJU [ j ]
<operator>.multiplication XBB [ j ] * w
<operator>.modulo i % C
<operator>.greaterThan OJU [ j ] > L
<operator>.greaterThan CMX + LCDT * 2 > t
<operator>.modulo i % C
<operator>.assignment p = ( CMX + LCDT * 2 - t ) / 2
<operator>.assignment XBB [ C ] = p
<operator>.postIncrement OJU [ C ] ++
<operator>.addition CMX + LCDT * 2
<operator>.multiplication LCDT * 2
<operator>.division ( CMX + LCDT * 2 - t ) / 2
<operator>.subtraction CMX + LCDT * 2 - t
<operator>.addition CMX + LCDT * 2
<operator>.multiplication LCDT * 2
<operator>.addressOf & XBB [ i ]
<operator>.indirectIndexAccess OAE [ i ]
<operator>.indirectIndexAccess OJU [ i ]
<operator>.indirectIndexAccess XBB [ i % C ]
<operator>.indirectIndexAccess OAE [ i ]
<operator>.indirectIndexAccess OJU [ j ]
<operator>.indirectIndexAccess XBB [ i ]
<operator>.indirectIndexAccess OJU [ j ]
<operator>.indirectIndexAccess XBB [ j ]
<operator>.indirectIndexAccess OJU [ i % C ]
<operator>.indirectIndexAccess OJU [ j ]
<operator>.indirectIndexAccess XBB [ C ]
<operator>.indirectIndexAccess OJU [ C ]
>>>PDG&63 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->25 0->27 0->28 0->29 0->30 0->31 0->32 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->42 0->44 0->45 0->46 0->47 0->48 0->49 2->9 3->1 3->9 3->30 3->31 4->1 4->1 4->1 4->1 4->1 4->7 4->8 4->10 4->12 4->14 4->23 4->27 4->28 4->31 4->32 4->35 4->37 4->38 4->39 4->40 4->47 5->1 5->1 6->1 6->1 6->43 7->1 7->1 7->8 8->1 8->1 8->1 8->1 8->26 9->1 9->1 9->1 10->1 10->7 10->8 10->10 10->11 10->11 10->17 10->18 10->18 10->19 10->23 10->32 10->37 10->50 10->51 10->52 10->56 11->1 11->10 12->1 12->12 12->13 12->14 12->21 12->22 12->31 12->34 12->37 12->37 12->53 13->1 13->12 14->1 14->1 14->1 14->14 14->15 14->26 14->27 14->28 14->29 14->30 14->32 14->35 14->36 14->38 14->54 14->55 14->58 14->60 15->1 15->1 15->32 16->10 17->1 17->1 18->1 18->1 18->8 18->26 19->1 19->1 20->12 21->1 21->1 21->34 21->45 22->1 22->1 22->9 22->30 22->31 23->1 24->1 25->1 25->1 25->15 25->32 26->1 26->1 26->1 27->1 27->1 27->28 27->29 27->36 28->1 28->1 28->38 29->1 29->1 29->38 30->1 30->1 30->9 31->1 31->1 31->22 31->33 31->39 31->39 31->39 31->40 31->44 31->44 31->45 31->47 31->48 31->59 32->1 32->1 32->14 32->14 32->15 33->1 33->1 34->1 34->22 34->22 35->1 36->1 36->1 36->30 36->30 37->8 37->13 37->23 37->32 37->40 37->40 38->27 38->27 38->28 38->29 38->35 38->35 38->57 39->1 39->1 39->1 39->31 39->41 39->42 39->43 39->46 39->47 39->47 39->48 39->49 39->61 39->62 40->8 40->13 40->23 40->32 40->37 41->1 41->1 41->42 42->1 42->1 42->1 43->1 43->1 45->34 45->39 45->39 45->44 45->44 45->49 46->1 46->41 46->41 47->1 47->1 47->31 47->46 47->46 49->34 49->47 49->47 49->48 49->48
>>>Token static void RUBRS ( const int n ) { int L , N , C ; long long int t , CMX ; int i , p ; CMX = 0 ; LHQMO ( " " , & L , & t , & N , & C ) ; for ( i = 0 ; i < C ; i ++ ) { LHQMO ( " " , & XBB [ i ] ) ; OAE [ i ] = i ; OJU [ i ] = 0 ; } XBB [ C ] = 0 ; OJU [ C ] = 0 ; OAE [ C ] = C ; for ( i = 0 ; i < N ; i ++ ) { int LCDT = XBB [ i % C ] ; if ( CMX > t ) { OJU [ i % C ] ++ ; } else if ( CMX + LCDT * 2 > t ) { p = ( CMX + LCDT * 2 - t ) / 2 ; XBB [ C ] = p ; OJU [ C ] ++ ; } CMX += LCDT * 2 ; } XEICQ ( OAE , C + 1 , sizeof ( int ) , AWR ) ; for ( i = 0 ; N && i <= C ; i ++ ) { int j = OAE [ i ] ; int w = ( OJU [ j ] > L ) ? L : OJU [ j ] ; L -= w ; OJU [ j ] -= w ; CMX -= XBB [ j ] * w ; } printf ( " \n " , n , CMX ) ; }
>>>Func
METHOD YVCOPWU
METHOD_RETURN int
PARAM int p
PARAM int k
PARAM int l
<operator>.assignment BGN = 0
EMAK EMAK ( 0 , l - 1 )
<operator>.assignment FXQH = 1
RETURN return BGN ; return BGN ;
<operator>.lessThan i < l
<operator>.postIncrement i ++
IDENTIFIER BGN return BGN ;
<operator>.subtraction l - 1
<operator>.assignment i = 0
<operator>.assignment FXQH = i / k + 1
<operator>.assignmentPlus BGN += FUIT [ i ] * FXQH
<operator>.addition i / k + 1
<operator>.multiplication FUIT [ i ] * FXQH
<operator>.division i / k
<operator>.indirectIndexAccess FUIT [ i ]
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 2->1 3->1 3->18 4->12 5->1 5->1 5->11 5->15 6->1 6->1 7->1 7->1 8->1 9->1 9->1 9->1 9->9 9->10 9->14 9->15 9->16 9->17 9->18 9->18 9->19 10->1 10->9 11->8 12->6 12->6 12->9 13->1 13->9 14->1 14->1 14->17 15->1 15->1 15->1 15->11 16->1 17->1 17->1 17->15 17->15 18->1 18->10 18->14 18->14 18->16 18->16
>>>Token int YVCOPWU ( int p , int k , int l ) { int i , FXQH , BGN = 0 ; EMAK ( 0 , l - 1 ) ; FXQH = 1 ; for ( i = 0 ; i < l ; i ++ ) { FXQH = i / k + 1 ; BGN += FUIT [ i ] * FXQH ; } return BGN ; }
>>>Func
METHOD SIXAEPVI
METHOD_RETURN unsigned int
PARAM char * KRI
PARAM unsigned int TML
<operator>.assignment CANH = 0
<operator>.assignment i = 0
RETURN return CANH ; return CANH ;
<operator>.lessThan i < TML
<operator>.expressionList KRI ++   i ++
IDENTIFIER CANH return CANH ;
<operator>.assignment i = 0
<operator>.assignment CANH = ( * KRI ) + ( CANH << 6 ) + ( CANH << 16 ) - CANH
<operator>.postIncrement KRI ++
<operator>.postIncrement i ++
<operator>.subtraction ( * KRI ) + ( CANH << 6 ) + ( CANH << 16 ) - CANH
<operator>.addition ( * KRI ) + ( CANH << 6 ) + ( CANH << 16 )
<operator>.addition ( * KRI ) + ( CANH << 6 )
<operator>.shiftLeft CANH << 16
<operator>.shiftLeft CANH << 6
<operator>.indirection * KRI
>>>PDG&20 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->12 0->13 0->14 0->17 0->18 2->1 2->12 3->7 4->1 4->1 4->9 4->18 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->13 7->13 7->14 7->15 7->16 7->17 7->18 7->19 8->1 8->1 8->1 9->6 10->1 10->7 11->1 11->1 11->1 11->9 11->18 12->1 12->8 13->7 13->8 14->1 14->11 14->11 15->1 15->1 16->1 16->1 17->14 17->14 17->15 17->15 18->14 18->14 18->15 18->15 18->16 18->16 18->17
>>>Token unsigned int SIXAEPVI ( char * KRI , unsigned int TML ) { unsigned int CANH = 0 ; unsigned int i = 0 ; for ( i = 0 ; i < TML ; KRI ++ , i ++ ) { CANH = ( * KRI ) + ( CANH << 6 ) + ( CANH << 16 ) - CANH ; } return CANH ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment AXQX = 1
QIEEC QIEEC ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan AXQX <= t
LITERAL 0 return 0 ;
<operator>.assignment cc = 0
<operator>.assignment cd = 0
<operator>.assignment ci = 0
<operator>.assignment co = 0
<operator>.assignment PCBM = 0
QIEEC QIEEC ( "%d" , & cc )
<operator>.assignment UHNC [ i ] [ 0 ] = '\0'
QIEEC QIEEC ( "%d" , & cd )
<operator>.assignment WMTE [ i ] [ 0 ] = '\0'
QIEEC QIEEC ( "%d" , & ci )
printf printf ( "Case #%d: [" , AXQX )
printf printf ( "\n" )
<operator>.assignment AXQX = AXQX + 1
<operator>.lessThan i < 26
<operator>.postIncrement i ++
<operator>.lessThan i < cc
<operator>.postIncrement i ++
<operator>.lessThan i < cd
<operator>.postIncrement i ++
<operator>.greaterThan ci > 0
<operator>.lessThan i < ci
<operator>.postIncrement i ++
<operator>.lessThan i < co
<operator>.postIncrement i ++
<operator>.equals co == 0
<operator>.assignment i = 0
<operator>.assignment XJAAF [ i ] = 0
<operator>.assignment i = 0
QIEEC QIEEC ( "%s" , UHNC [ i ] )
<operator>.assignment i = 0
QIEEC QIEEC ( "%s" , WMTE [ i ] )
QIEEC QIEEC ( "%s" , in )
<operator>.assignment PLL [ 0 ] = in [ 0 ]
<operator>.assignment XJAAF [ in [ 0 ] - 65 ] = XJAAF [ in [ 0 ] - 65 ] + 1
<operator>.assignment co = co + 1
<operator>.assignment PLL [ co ] = '\0'
<operator>.assignment i = 1
<operator>.assignment PCBM = 1
<operator>.assignment PLL [ co ] = in [ i ]
<operator>.assignment co = co + 1
<operator>.assignment PLL [ co ] = '\0'
<operator>.assignment XJAAF [ in [ i ] - 65 ] = XJAAF [ in [ i ] - 65 ] + 1
<operator>.assignment i = 0
printf printf ( "]" )
<operator>.addition AXQX + 1
<operator>.assignment in [ 0 ] = '\0'
<operator>.equals PCBM == 1
<operator>.equals i == ( co - 1 )
<operator>.addition XJAAF [ in [ 0 ] - 65 ] + 1
<operator>.addition co + 1
<operator>.addition co + 1
<operator>.addition XJAAF [ in [ i ] - 65 ] + 1
<operator>.assignment PCBM = 0
printf printf ( "%c]" , PLL [ i ] )
<operator>.subtraction in [ 0 ] - 65
<operator>.subtraction in [ i ] - 65
<operator>.lessThan j < cc
<operator>.postIncrement j ++
<operator>.equals PCBM == 0
<operator>.subtraction co - 1
printf printf ( "%c, " , PLL [ i ] )
<operator>.subtraction in [ 0 ] - 65
<operator>.subtraction in [ i ] - 65
<operator>.assignment j = 0
<operator>.logicalOr ( PLL [ co - 1 ] == UHNC [ j ] [ 0 ] && PLL [ co - 2 ] == UHNC [ j ] [ 1 ] ) || ( PLL [ co - 2 ] == UHNC [ j ] [ 0 ] && PLL [ co - 1 ] == UHNC [ j ] [ 1 ] )
<operator>.lessThan j < cd
<operator>.postIncrement j ++
<operator>.assignment PLL [ co - 2 ] = UHNC [ j ] [ 2 ]
<operator>.assignment PCBM = 1
<operator>.assignment co = co - 1
<operator>.assignment PLL [ co ] = '\0'
<operator>.postDecrement XJAAF [ UHNC [ j ] [ 0 ] - 65 ] --
<operator>.postDecrement XJAAF [ UHNC [ j ] [ 1 ] - 65 ] --
<operator>.postIncrement XJAAF [ UHNC [ j ] [ 2 ] - 65 ] ++
<operator>.assignment j = 0
<operator>.logicalAnd PLL [ co - 1 ] == UHNC [ j ] [ 0 ] && PLL [ co - 2 ] == UHNC [ j ] [ 1 ]
<operator>.logicalAnd PLL [ co - 2 ] == UHNC [ j ] [ 0 ] && PLL [ co - 1 ] == UHNC [ j ] [ 1 ]
<operator>.logicalAnd XJAAF [ WMTE [ j ] [ 0 ] - 65 ] > 0 && XJAAF [ WMTE [ j ] [ 1 ] - 65 ] > 0
<operator>.equals PLL [ co - 1 ] == UHNC [ j ] [ 0 ]
<operator>.equals PLL [ co - 2 ] == UHNC [ j ] [ 1 ]
<operator>.equals PLL [ co - 2 ] == UHNC [ j ] [ 0 ]
<operator>.equals PLL [ co - 1 ] == UHNC [ j ] [ 1 ]
<operator>.subtraction co - 1
<operator>.assignment co = 0
<operator>.assignment PLL [ co ] = '\0'
<operator>.postDecrement XJAAF [ WMTE [ j ] [ 0 ] - 65 ] --
<operator>.postDecrement XJAAF [ WMTE [ j ] [ 1 ] - 65 ] --
<operator>.subtraction co - 2
<operator>.subtraction UHNC [ j ] [ 0 ] - 65
<operator>.subtraction UHNC [ j ] [ 1 ] - 65
<operator>.subtraction UHNC [ j ] [ 2 ] - 65
<operator>.greaterThan XJAAF [ WMTE [ j ] [ 0 ] - 65 ] > 0
<operator>.greaterThan XJAAF [ WMTE [ j ] [ 1 ] - 65 ] > 0
<operator>.lessThan k < 26
<operator>.postIncrement k ++
<operator>.subtraction co - 1
<operator>.subtraction co - 2
<operator>.subtraction co - 2
<operator>.subtraction co - 1
<operator>.assignment k = 0
<operator>.assignment XJAAF [ k ] = 0
<operator>.subtraction WMTE [ j ] [ 0 ] - 65
<operator>.subtraction WMTE [ j ] [ 1 ] - 65
<operator>.subtraction WMTE [ j ] [ 0 ] - 65
<operator>.subtraction WMTE [ j ] [ 1 ] - 65
<operator>.addressOf & cc
<operator>.indirectIndexAccess UHNC [ i ] [ 0 ]
<operator>.addressOf & cd
<operator>.indirectIndexAccess WMTE [ i ] [ 0 ]
<operator>.addressOf & ci
<operator>.indirectIndexAccess UHNC [ i ]
<operator>.indirectIndexAccess WMTE [ i ]
<operator>.indirectIndexAccess XJAAF [ i ]
<operator>.indirectIndexAccess UHNC [ i ]
<operator>.indirectIndexAccess WMTE [ i ]
<operator>.indirectIndexAccess PLL [ 0 ]
<operator>.indirectIndexAccess in [ 0 ]
<operator>.indirectIndexAccess XJAAF [ in [ 0 ] - 65 ]
<operator>.indirectIndexAccess PLL [ co ]
<operator>.indirectIndexAccess PLL [ co ]
<operator>.indirectIndexAccess in [ i ]
<operator>.indirectIndexAccess PLL [ co ]
<operator>.indirectIndexAccess XJAAF [ in [ i ] - 65 ]
<operator>.indirectIndexAccess XJAAF [ in [ 0 ] - 65 ]
<operator>.indirectIndexAccess in [ 0 ]
<operator>.indirectIndexAccess XJAAF [ in [ i ] - 65 ]
<operator>.indirectIndexAccess in [ 0 ]
<operator>.indirectIndexAccess in [ i ]
<operator>.indirectIndexAccess PLL [ i ]
<operator>.indirectIndexAccess in [ 0 ]
<operator>.indirectIndexAccess in [ i ]
<operator>.indirectIndexAccess PLL [ i ]
<operator>.indirectIndexAccess PLL [ co - 2 ]
<operator>.indirectIndexAccess UHNC [ j ] [ 2 ]
<operator>.indirectIndexAccess PLL [ co ]
<operator>.indirectIndexAccess XJAAF [ UHNC [ j ] [ 0 ] - 65 ]
<operator>.indirectIndexAccess XJAAF [ UHNC [ j ] [ 1 ] - 65 ]
<operator>.indirectIndexAccess XJAAF [ UHNC [ j ] [ 2 ] - 65 ]
<operator>.indirectIndexAccess PLL [ co - 1 ]
<operator>.indirectIndexAccess UHNC [ j ] [ 0 ]
<operator>.indirectIndexAccess PLL [ co - 2 ]
<operator>.indirectIndexAccess UHNC [ j ] [ 1 ]
<operator>.indirectIndexAccess PLL [ co - 2 ]
<operator>.indirectIndexAccess UHNC [ j ] [ 0 ]
<operator>.indirectIndexAccess PLL [ co - 1 ]
<operator>.indirectIndexAccess UHNC [ j ] [ 1 ]
<operator>.indirectIndexAccess UHNC [ j ]
<operator>.indirectIndexAccess UHNC [ j ]
<operator>.indirectIndexAccess UHNC [ j ]
<operator>.indirectIndexAccess UHNC [ j ]
<operator>.indirectIndexAccess UHNC [ j ]
<operator>.indirectIndexAccess UHNC [ j ] [ 0 ]
<operator>.indirectIndexAccess UHNC [ j ] [ 1 ]
<operator>.indirectIndexAccess UHNC [ j ] [ 2 ]
<operator>.indirectIndexAccess XJAAF [ WMTE [ j ] [ 0 ] - 65 ]
<operator>.indirectIndexAccess XJAAF [ WMTE [ j ] [ 1 ] - 65 ]
<operator>.indirectIndexAccess PLL [ co ]
<operator>.indirectIndexAccess XJAAF [ WMTE [ j ] [ 0 ] - 65 ]
<operator>.indirectIndexAccess XJAAF [ WMTE [ j ] [ 1 ] - 65 ]
<operator>.indirectIndexAccess UHNC [ j ]
<operator>.indirectIndexAccess UHNC [ j ]
<operator>.indirectIndexAccess UHNC [ j ]
<operator>.indirectIndexAccess WMTE [ j ] [ 0 ]
<operator>.indirectIndexAccess WMTE [ j ] [ 1 ]
<operator>.indirectIndexAccess WMTE [ j ] [ 0 ]
<operator>.indirectIndexAccess WMTE [ j ] [ 1 ]
<operator>.indirectIndexAccess XJAAF [ k ]
<operator>.indirectIndexAccess WMTE [ j ]
<operator>.indirectIndexAccess WMTE [ j ]
<operator>.indirectIndexAccess WMTE [ j ]
<operator>.indirectIndexAccess WMTE [ j ]
>>>PDG&178 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->72 0->73 0->75 0->77 0->81 0->89 0->90 0->91 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 2->1 2->5 3->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->17 5->17 5->18 5->19 5->20 5->22 5->24 5->26 5->27 5->29 5->31 5->32 5->34 5->36 5->43 5->49 5->51 5->112 5->113 5->114 5->115 5->116 5->117 5->118 6->4 7->1 7->12 7->22 8->1 8->14 8->24 9->1 9->16 9->26 10->1 10->29 10->41 10->46 10->56 10->57 11->1 11->1 12->1 12->1 12->22 12->63 13->1 13->1 13->35 14->1 14->1 14->24 14->72 15->1 15->1 15->37 16->1 16->1 16->26 16->27 17->1 17->19 17->51 18->1 19->1 19->1 19->5 20->1 20->20 20->21 20->21 20->33 20->119 21->1 21->20 22->1 22->1 22->22 22->23 22->23 22->35 22->63 22->120 23->1 23->22 24->1 24->1 24->24 24->25 24->25 24->37 24->72 24->121 25->1 25->24 26->1 26->27 26->38 26->39 26->40 26->41 26->42 26->52 26->55 26->56 26->61 26->68 26->122 26->123 26->124 26->125 26->130 26->131 26->133 26->136 27->1 27->1 27->27 27->28 27->28 27->44 27->45 27->46 27->47 27->48 27->53 27->57 27->58 27->62 27->69 27->126 27->127 27->128 27->129 27->132 27->134 27->137 28->1 28->27 29->1 29->1 29->29 29->30 29->31 29->54 29->54 29->66 29->66 30->1 30->29 31->1 31->1 31->50 32->20 33->1 33->1 34->22 35->1 35->1 36->24 37->1 37->1 38->1 38->1 38->39 38->45 38->61 38->62 38->68 38->69 39->1 39->1 40->1 40->1 40->1 40->55 41->1 41->1 41->29 41->46 41->57 42->1 42->1 43->1 43->27 44->1 44->53 45->1 46->1 46->1 46->29 46->57 46->102 47->1 47->1 48->1 48->1 48->1 48->58 49->1 49->29 50->1 52->1 52->1 52->38 52->39 52->61 53->1 53->1 53->53 53->59 53->63 53->65 53->70 54->1 54->1 54->30 54->60 54->67 54->135 54->138 59->1 59->65 60->1 60->1 60->67 61->68 62->69 63->1 63->1 63->1 63->64 63->71 63->82 63->85 63->102 63->145 63->146 63->154 64->1 64->63 65->1 65->53 65->72 65->81 66->29 66->54 66->54 67->1 67->1 67->60 68->1 68->38 68->39 68->61 69->1 69->38 69->45 69->62 70->1 70->63 71->1 71->1 71->1 71->63 71->64 71->74 71->75 71->76 71->77 71->78 71->79 71->80 71->89 71->94 71->95 71->96 71->97 71->139 71->140 71->141 71->142 71->143 71->144 71->153 71->158 71->159 71->160 71->166 71->167 71->168 72->1 72->1 72->1 72->73 72->84 72->98 72->108 72->161 72->169 72->174 73->1 73->72 74->1 74->1 74->86 74->87 75->1 75->65 76->1 76->1 76->29 76->46 76->57 76->102 77->1 77->1 78->1 78->1 79->1 79->1 80->1 80->1 81->1 81->72 82->1 82->1 82->71 82->71 82->83 82->87 82->104 82->149 82->150 82->156 83->1 83->1 83->71 83->71 84->1 84->1 84->1 84->72 84->73 84->90 84->91 84->92 84->93 84->100 84->106 84->110 84->111 84->163 84->164 84->165 84->171 84->172 84->176 84->177 85->1 85->1 85->82 85->82 85->86 85->87 85->88 85->95 85->103 85->147 85->148 85->155 86->1 86->1 86->82 86->82 86->87 86->88 86->96 87->1 87->1 87->83 87->83 87->85 87->86 87->88 87->95 87->105 87->151 87->152 87->157 88->1 88->1 88->83 88->83 88->85 88->86 88->96 89->76 89->76 90->1 90->29 90->46 90->57 90->102 91->1 91->1 92->1 92->1 92->98 93->1 93->1 93->99 94->89 95->1 95->85 96->1 96->86 96->88 97->1 97->74 98->1 98->84 98->84 98->92 98->99 98->109 98->162 98->170 98->175 99->1 99->84 99->84 99->93 100->1 100->1 100->100 100->101 100->101 100->107 100->173 101->1 101->100 102->29 102->46 102->57 102->94 102->103 102->104 103->29 103->46 103->57 103->94 103->102 103->104 104->29 104->46 104->57 104->94 104->102 104->105 105->29 105->46 105->57 105->94 105->102 106->1 106->100 107->1 107->1 108->1 108->110 109->1 109->111 110->1 110->108 111->1 111->109
>>>Token int main ( ) { int t , AXQX = 1 ; QIEEC ( " " , & t ) ; while ( AXQX <= t ) { char UHNC [ 36 ] [ 3 ] , WMTE [ 36 ] [ 2 ] , in [ 100 ] , PLL [ 100 ] ; int cc = 0 , cd = 0 , ci = 0 , co = 0 , PCBM = 0 , i , j , XJAAF [ 26 ] , k ; for ( i = 0 ; i < 26 ; i ++ ) { XJAAF [ i ] = 0 ; } QIEEC ( " " , & cc ) ; for ( i = 0 ; i < cc ; i ++ ) { QIEEC ( " " , UHNC [ i ] ) ; } UHNC [ i ] [ 0 ] = ' \0 ' ; QIEEC ( " " , & cd ) ; for ( i = 0 ; i < cd ; i ++ ) { QIEEC ( " " , WMTE [ i ] ) ; } WMTE [ i ] [ 0 ] = ' \0 ' ; QIEEC ( " " , & ci ) ; if ( ci > 0 ) { QIEEC ( " " , in ) ; PLL [ 0 ] = in [ 0 ] ; XJAAF [ in [ 0 ] - 65 ] = XJAAF [ in [ 0 ] - 65 ] + 1 ; co = co + 1 ; PLL [ co ] = ' \0 ' ; } else { in [ 0 ] = ' \0 ' ; } for ( i = 1 ; i < ci ; i ++ ) { PCBM = 1 ; PLL [ co ] = in [ i ] ; co = co + 1 ; PLL [ co ] = ' \0 ' ; XJAAF [ in [ i ] - 65 ] = XJAAF [ in [ i ] - 65 ] + 1 ; while ( PCBM == 1 ) { PCBM = 0 ; for ( j = 0 ; j < cc ; j ++ ) { if ( ( PLL [ co - 1 ] == UHNC [ j ] [ 0 ] && PLL [ co - 2 ] == UHNC [ j ] [ 1 ] ) || ( PLL [ co - 2 ] == UHNC [ j ] [ 0 ] && PLL [ co - 1 ] == UHNC [ j ] [ 1 ] ) ) { PLL [ co - 2 ] = UHNC [ j ] [ 2 ] ; PCBM = 1 ; co = co - 1 ; PLL [ co ] = ' \0 ' ; XJAAF [ UHNC [ j ] [ 0 ] - 65 ] -- ; XJAAF [ UHNC [ j ] [ 1 ] - 65 ] -- ; XJAAF [ UHNC [ j ] [ 2 ] - 65 ] ++ ; break ; } } if ( PCBM == 0 ) { for ( j = 0 ; j < cd ; j ++ ) { if ( ( XJAAF [ WMTE [ j ] [ 0 ] - 65 ] > 0 && XJAAF [ WMTE [ j ] [ 1 ] - 65 ] > 0 ) ) { co = 0 ; PLL [ co ] = ' \0 ' ; XJAAF [ WMTE [ j ] [ 0 ] - 65 ] -- ; XJAAF [ WMTE [ j ] [ 1 ] - 65 ] -- ; for ( k = 0 ; k < 26 ; k ++ ) { XJAAF [ k ] = 0 ; } break ; } } } } } printf ( " " , AXQX ) ; for ( i = 0 ; i < co ; i ++ ) { if ( i == ( co - 1 ) ) { printf ( " " , PLL [ i ] ) ; } else { printf ( " " , PLL [ i ] ) ; } } if ( co == 0 ) { printf ( " " ) ; } printf ( " \n " ) ; AXQX = AXQX + 1 ; } return 0 ; }
>>>Func
METHOD RJULWXPSKVUW
METHOD_RETURN int
PARAM char * s
PARAM int DTWAEI
PARAM int * n
<operator>.assignment nz = 0
<operator>.assignment FSA = 0
<operator>.assignment PFU = 0
RETURN return nz ; return nz ;
<operator>.lessThan nz < DTWAEI
<operator>.expressionList nz ++   FSA += PFU
IDENTIFIER nz return nz ;
<operator>.assignment nz = 0
<operator>.assignment n [ nz ] = - 1
IPUSTH IPUSTH ( s + FSA , "%d%n" , n + nz , & PFU )
<operator>.postIncrement nz ++
<operator>.assignmentPlus FSA += PFU
<operator>.equals n [ nz ] == - 1
<operator>.minus - 1
<operator>.addition s + FSA
<operator>.addition n + nz
<operator>.minus - 1
<operator>.indirectIndexAccess n [ nz ]
<operator>.addressOf & PFU
<operator>.indirectIndexAccess n [ nz ]
>>>PDG&25 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 2->1 2->14 2->19 3->9 4->1 4->14 4->17 4->20 6->1 6->1 6->14 6->16 6->19 7->1 7->1 7->10 7->14 7->16 8->1 9->1 9->1 9->1 9->11 9->13 9->14 9->14 9->15 9->17 9->18 9->19 9->20 9->20 9->21 9->22 9->23 9->24 10->1 10->1 10->1 11->8 12->1 12->9 13->1 13->14 13->17 13->20 14->1 14->1 14->1 14->1 14->10 14->16 15->9 15->10 16->1 16->1 16->10 16->14 16->19 17->1 17->1 17->1 17->9 17->10 17->15 17->16 18->13 19->1 19->1 20->1 20->1 21->17
>>>Token int RJULWXPSKVUW ( char * s , int DTWAEI , int * n ) { int nz = 0 , FSA = 0 , PFU = 0 ; for ( nz = 0 ; nz < DTWAEI ; nz ++ , FSA += PFU ) { n [ nz ] = - 1 ; IPUSTH ( s + FSA , " " , n + nz , & PFU ) ; if ( n [ nz ] == - 1 ) break ; } return nz ; }
>>>Func
METHOD em
METHOD_RETURN void*
PARAM unsigned int YNFY
<operator>.assignment IXC = malloc ( YNFY )
RETURN return IXC ; return IXC ;
<operator>.equals IXC == NULL
IDENTIFIER IXC return IXC ;
malloc malloc ( YNFY )
OXVC OXVC ( "in ec_malloc() on memory allocation" )
>>>PDG&9 0->2 0->5 0->6 0->7 0->8 2->7 3->1 3->1 3->5 4->1 5->1 5->1 5->1 5->6 5->8 6->4 7->1 7->3 8->1
>>>Token void * em ( unsigned int YNFY ) { void * IXC ; IXC = malloc ( YNFY ) ; if ( IXC == NULL ) OXVC ( " " ) ; return IXC ; }
>>>Func
METHOD main
METHOD_RETURN int
AKSXP AKSXP ( "%d" , & LUSX )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan tc <= LUSX
<operator>.preIncrement ++ tc
LITERAL 0 return 0 ;
<operator>.assignment tc = 1
AKSXP AKSXP ( "%d" , & c )
AKSXP AKSXP ( "%d" , & d )
AKSXP AKSXP ( "%d" , & n )
AKSXP AKSXP ( "%s" , N )
<operator>.assignment QJB = 1
<operator>.assignment OP [ 0 ] = N [ 0 ]
printf printf ( "Case #%d: [" , tc )
printf printf ( "]\n" )
<operator>.lessThan i < c
<operator>.preIncrement ++ i
AKSXP AKSXP ( "%s" , C [ i ] )
<operator>.lessThan i < d
<operator>.preIncrement ++ i
AKSXP AKSXP ( "%s" , D [ i ] )
<operator>.equals n == 1
<operator>.lessThan i < n
<operator>.preIncrement ++ i
<operator>.lessThan i < QJB - 1
<operator>.preIncrement ++ i
printf printf ( "%c, " , OP [ i ] )
<operator>.notEquals QJB != 0
<operator>.assignment i = 0
<operator>.assignment i = 0
printf printf ( "Case #%d: [%c]\n" , tc , N [ 0 ] )
<operator>.assignment i = 1
<operator>.assignment OP [ QJB ++ ] = N [ i ]
ROJOKXNFTLVTCDW ROJOKXNFTLVTCDW ( )
BLOCK <empty> <empty>
<operator>.assignment i = 0
printf printf ( "%c" , OP [ QJB - 1 ] )
<operator>.subtraction QJB - 1
VQTHCRACTKU VQTHCRACTKU ( )
<operator>.postIncrement QJB ++
<operator>.subtraction QJB - 1
<operator>.equals i == n - 2
<operator>.assignment OP [ QJB ++ ] = N [ n - 1 ]
<operator>.subtraction n - 2
<operator>.notEquals i != n - 1
<operator>.postIncrement QJB ++
<operator>.subtraction n - 1
<operator>.assignment OP [ QJB ++ ] = N [ ++ i ]
<operator>.subtraction n - 1
<operator>.postIncrement QJB ++
<operator>.preIncrement ++ i
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess OP [ 0 ]
<operator>.indirectIndexAccess N [ 0 ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess D [ i ]
<operator>.indirectIndexAccess OP [ i ]
<operator>.indirectIndexAccess N [ 0 ]
<operator>.indirectIndexAccess OP [ QJB ++ ]
<operator>.indirectIndexAccess N [ i ]
<operator>.indirectIndexAccess OP [ QJB - 1 ]
<operator>.indirectIndexAccess OP [ QJB ++ ]
<operator>.indirectIndexAccess N [ n - 1 ]
<operator>.indirectIndexAccess OP [ QJB ++ ]
<operator>.indirectIndexAccess N [ ++ i ]
>>>PDG&68 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->49 0->50 0->51 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->14 4->16 4->19 4->22 4->29 4->30 4->31 4->52 4->53 4->54 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->16 9->1 9->1 9->19 10->1 10->1 10->22 10->23 10->44 10->47 10->49 11->1 11->1 11->13 11->31 11->33 11->43 11->48 12->1 12->38 12->40 13->1 13->1 13->1 14->1 14->5 15->1 16->1 16->1 16->8 16->16 16->17 16->17 16->18 16->57 17->1 17->16 18->1 18->1 19->1 19->1 19->1 19->9 19->19 19->20 19->20 19->21 19->58 20->1 20->19 21->1 21->1 22->1 22->1 22->10 22->12 22->13 22->14 22->15 22->23 22->23 22->25 22->28 22->31 22->32 22->36 22->38 22->55 22->56 22->60 23->1 23->1 23->10 23->22 23->24 23->33 23->34 23->39 23->40 23->42 23->44 23->61 23->62 24->1 24->23 25->1 25->1 25->1 25->25 25->26 25->26 25->27 25->38 25->59 26->1 26->25 27->1 27->1 28->1 28->1 28->37 28->41 28->41 28->63 29->16 30->1 30->19 31->1 31->1 31->5 31->11 31->13 32->1 32->23 33->1 33->1 33->1 34->1 36->1 36->25 37->1 37->1 38->25 38->25 38->28 39->1 39->23 39->24 39->42 39->44 40->38 40->46 40->50 41->1 42->1 42->1 42->23 42->24 42->43 42->45 42->45 42->46 42->47 42->49 42->64 42->65 43->1 43->1 43->1 44->42 44->42 44->47 44->49 45->1 45->1 45->24 45->48 45->50 45->51 45->51 45->66 45->67 46->38 47->1 47->10 47->22 48->1 48->1 48->1 49->23 49->45 49->45 50->38 50->40 51->24
>>>Token int main ( ) { int LUSX , tc , i ; AKSXP ( " " , & LUSX ) ; for ( tc = 1 ; tc <= LUSX ; ++ tc ) { AKSXP ( " " , & c ) ; for ( i = 0 ; i < c ; ++ i ) AKSXP ( " " , C [ i ] ) ; AKSXP ( " " , & d ) ; for ( i = 0 ; i < d ; ++ i ) AKSXP ( " " , D [ i ] ) ; AKSXP ( " " , & n ) ; AKSXP ( " " , N ) ; if ( n == 1 ) { printf ( " \n " , tc , N [ 0 ] ) ; continue ; } QJB = 1 ; OP [ 0 ] = N [ 0 ] ; for ( i = 1 ; i < n ; ++ i ) { OP [ QJB ++ ] = N [ i ] ; ROJOKXNFTLVTCDW ( ) ; { if ( VQTHCRACTKU ( ) ) { if ( i == n - 2 ) { OP [ QJB ++ ] = N [ n - 1 ] ; break ; } else if ( i != n - 1 ) { OP [ QJB ++ ] = N [ ++ i ] ; } } } } printf ( " " , tc ) ; for ( i = 0 ; i < QJB - 1 ; ++ i ) printf ( " " , OP [ i ] ) ; if ( QJB != 0 ) printf ( " " , OP [ QJB - 1 ] ) ; printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD eo
METHOD_RETURN void
PARAM char * IFB
printf printf ( IFB )
YMUOVV YMUOVV ( CHGUOG )
exit exit ( EXIT_FAILURE )
>>>PDG&6 0->2 0->3 0->4 0->5 2->3 3->1 3->1 4->1 4->1 5->1
>>>Token void eo ( char * IFB ) { printf ( IFB ) ; YMUOVV ( CHGUOG ) ; exit ( EXIT_FAILURE ) ; }
>>>Func
METHOD THDQKBNPKVM
METHOD_RETURN int
RETURN return 0 ; return 0 ;
<operator>.lessThan i < d
<operator>.preIncrement ++ i
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.equals LILRD [ WNW - 1 ] == ds [ i ] [ 0 ]
<operator>.greaterEqualsThan j >= 0
<operator>.preDecrement -- j
<operator>.assignment MLCAJI = ds [ i ] [ 1 ]
<operator>.assignment j = WNW - 2
<operator>.equals LILRD [ j ] == MLCAJI
<operator>.subtraction WNW - 1
<operator>.equals LILRD [ WNW - 1 ] == ds [ i ] [ 1 ]
<operator>.subtraction WNW - 2
<operator>.assignment WNW = 0
RETURN return 1 ; return 1 ;
<operator>.assignment MLCAJI = ds [ i ] [ 0 ]
LITERAL 1 return 1 ;
<operator>.subtraction WNW - 1
<operator>.indirectIndexAccess LILRD [ WNW - 1 ]
<operator>.indirectIndexAccess ds [ i ] [ 0 ]
<operator>.indirectIndexAccess ds [ i ]
<operator>.indirectIndexAccess ds [ i ] [ 1 ]
<operator>.indirectIndexAccess ds [ i ]
<operator>.indirectIndexAccess LILRD [ j ]
<operator>.indirectIndexAccess LILRD [ WNW - 1 ]
<operator>.indirectIndexAccess ds [ i ] [ 1 ]
<operator>.indirectIndexAccess ds [ i ]
<operator>.indirectIndexAccess ds [ i ] [ 0 ]
<operator>.indirectIndexAccess ds [ i ]
>>>PDG&32 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->12 0->13 0->15 0->16 0->17 0->19 0->20 2->1 3->1 3->1 3->1 3->2 3->4 3->7 3->8 3->11 3->13 3->15 3->21 3->22 3->23 4->1 4->3 5->2 6->1 6->3 7->1 7->1 7->1 7->10 7->14 7->14 7->18 7->20 7->24 7->25 7->27 7->28 7->29 8->1 8->1 8->3 8->4 8->9 8->12 8->26 9->1 9->8 10->1 10->1 10->12 11->1 11->1 11->8 12->1 12->1 12->1 12->8 12->9 12->16 12->17 13->15 13->20 14->1 14->1 14->1 14->7 14->10 14->18 14->30 14->31 15->11 15->11 15->13 16->1 16->1 17->1 18->1 18->1 18->12 19->17 20->15
>>>Token static int THDQKBNPKVM ( ) { int i , j ; char MLCAJI ; for ( i = 0 ; i < d ; ++ i ) { if ( LILRD [ WNW - 1 ] == ds [ i ] [ 0 ] ) { MLCAJI = ds [ i ] [ 1 ] ; } else if ( LILRD [ WNW - 1 ] == ds [ i ] [ 1 ] ) { MLCAJI = ds [ i ] [ 0 ] ; } for ( j = WNW - 2 ; j >= 0 ; -- j ) { if ( LILRD [ j ] == MLCAJI ) { WNW = 0 ; return 1 ; } } } return 0 ; }
>>>Func
METHOD DSAXRU
METHOD_RETURN int
PARAM const void * a
PARAM const void * b
<operator>.assignment * a1 = ( struct PETB * ) a
<operator>.assignment * b1 = ( struct PETB * ) b
RETURN return a1 -> YBHKSL > b1 -> YBHKSL ; return a1 -> YBHKSL > b1 -> YBHKSL ;
<operator>.greaterThan a1 -> YBHKSL > b1 -> YBHKSL
<operator>.cast ( struct PETB * ) a
<operator>.cast ( struct PETB * ) b
>>>PDG&10 0->2 0->3 0->4 0->5 0->8 0->9 2->4 2->8 3->5 3->9 4->1 4->1 4->1 5->1 5->1 5->1 6->1 7->1 7->1 7->1 7->6 8->1 9->1
>>>Token int DSAXRU ( const void * a , const void * b ) { struct PETB * a1 = ( struct PETB * ) a ; struct PETB * b1 = ( struct PETB * ) b ; return a1 -> YBHKSL > b1 -> YBHKSL ; }
>>>Func
METHOD OHEWYW
METHOD_RETURN void
PARAM char c
<operator>.assignment PGG = 1
IDENTIFIER LUH if (LUH)
IDENTIFIER PGG if (PGG)
<operator>.assignment FWUJ [ LUH ++ ] = c
<operator>.assignment FWUJ [ LUH - 1 ] = HYILQTLV [ c ] [ FWUJ [ LUH - 1 ] ]
<operator>.assignment PGG = 0
<operator>.postIncrement LUH ++
<operator>.subtraction LUH - 1
<operator>.lessThan i < LUH
<operator>.preIncrement ++ i
<operator>.subtraction LUH - 1
<operator>.assignment i = 0
<operator>.subtraction LUH - 1
<operator>.assignment LUH = PGG = 0
<operator>.assignment PGG = 0
<operator>.indirectIndexAccess HYILQTLV [ c ] [ FWUJ [ LUH - 1 ] ]
<operator>.indirectIndexAccess FWUJ [ LUH - 1 ]
<operator>.indirectIndexAccess HYILQTLV [ c ] [ FWUJ [ LUH - 1 ] ]
<operator>.indirectIndexAccess HYILQTLV [ c ]
<operator>.indirectIndexAccess FWUJ [ LUH - 1 ]
<operator>.indirectIndexAccess KUAIRCK [ c ] [ FWUJ [ i ] ]
<operator>.indirectIndexAccess KUAIRCK [ c ]
<operator>.indirectIndexAccess FWUJ [ i ]
>>>PDG&26 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->6 3->1 3->1 6->1 6->1 6->1 7->1 7->1 7->1 8->1 8->1 9->1 10->11 10->13 11->1 11->1 11->9 11->11 11->12 11->12 11->23 11->24 11->25 12->1 12->11 13->15 14->1 14->11 15->9 16->1 16->1 16->11 17->1 17->16 18->7 18->8 18->11 18->13 18->14 18->15 18->19 18->20 18->21 18->22 23->16 23->17
>>>Token void OHEWYW ( char c ) { int i , PGG = 1 ; if ( LUH ) { if ( HYILQTLV [ c ] [ FWUJ [ LUH - 1 ] ] ) { FWUJ [ LUH - 1 ] = HYILQTLV [ c ] [ FWUJ [ LUH - 1 ] ] ; PGG = 0 ; } else { for ( i = 0 ; i < LUH ; ++ i ) if ( KUAIRCK [ c ] [ FWUJ [ i ] ] ) LUH = PGG = 0 ; } } if ( PGG ) FWUJ [ LUH ++ ] = c ; }
>>>Func
METHOD UPBFJSU
METHOD_RETURN int
PARAM int N
PARAM int PD
PARAM int PG
<operator>.assignment XKLCN = 100 - PD
<operator>.assignment SVENC = 100 - PG
<operator>.assignment KLNOM = MFGWRL ( PD )
<operator>.assignment CEWAWY = 100 / KLNOM
<operator>.assignment FGRD = PD / KLNOM
RETURN return 0 ; return 0 ;
<operator>.logicalAnd PD > 0 && PG == 0
<operator>.logicalAnd SVENC == 0 && XKLCN > 0
<operator>.logicalOr ( SVENC == 0 && XKLCN == 0 ) || ( PG == 0 && PD == 0 )
<operator>.lessEqualsThan CEWAWY <= N
LITERAL 0 return 0 ;
RETURN return 0 ; return 0 ;
<operator>.subtraction 100 - PD
<operator>.subtraction 100 - PG
RETURN return 0 ; return 0 ;
RETURN return 1 ; return 1 ;
MFGWRL MFGWRL ( PD )
<operator>.division 100 / KLNOM
<operator>.division PD / KLNOM
RETURN return 1 ; return 1 ;
<operator>.greaterThan PD > 0
<operator>.equals PG == 0
LITERAL 0 return 0 ;
<operator>.equals SVENC == 0
<operator>.greaterThan XKLCN > 0
LITERAL 0 return 0 ;
<operator>.logicalAnd SVENC == 0 && XKLCN == 0
<operator>.logicalAnd PG == 0 && PD == 0
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
<operator>.equals SVENC == 0
<operator>.equals XKLCN == 0
<operator>.equals PG == 0
<operator>.equals PD == 0
>>>PDG&39 0->2 0->3 0->4 0->10 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->33 0->34 0->35 0->36 0->37 0->38 2->1 2->14 3->25 4->1 4->18 4->26 5->29 5->36 6->28 7->22 8->14 10->1 11->1 11->1 11->1 11->5 11->6 11->12 11->16 11->17 11->18 11->28 12->13 12->19 12->31 12->35 13->7 13->8 13->9 13->14 13->20 13->21 13->22 13->23 14->10 14->24 15->10 16->1 17->5 17->5 17->21 17->38 18->6 18->6 18->37 19->1 20->1 21->7 21->23 22->8 22->8 22->23 23->9 23->9 24->1 25->1 25->11 25->11 25->17 25->26 26->1 26->11 26->11 26->18 27->16 28->12 28->12 28->29 28->35 29->12 29->12 29->36 30->19 31->13 31->13 31->32 31->37 32->13 32->13 33->20 34->24 35->31 35->31 35->36 36->31 36->31 37->32 37->32 37->38 38->21 38->32 38->32
>>>Token int UPBFJSU ( int N , int PD , int PG ) { if ( PD > 0 && PG == 0 ) return 0 ; int XKLCN = 100 - PD , SVENC = 100 - PG ; if ( SVENC == 0 && XKLCN > 0 ) return 0 ; if ( ( SVENC == 0 && XKLCN == 0 ) || ( PG == 0 && PD == 0 ) ) return 1 ; int KLNOM = MFGWRL ( PD ) ; int CEWAWY = 100 / KLNOM , FGRD = PD / KLNOM ; if ( CEWAWY <= N ) return 1 ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf ( "Enter the number of vertices\n" )
OKWDL OKWDL ( "%d" , & AEHHRIVS )
<operator>.assignment * JMKEH = JAEYIQCVMFG ( AEHHRIVS )
printf printf ( "Enter the number of edges\n" )
OKWDL OKWDL ( "%d" , & UYVTP )
printf printf ( "Enter source of DFS\n" )
OKWDL OKWDL ( "%d" , & FMCNVD )
printf printf ( "DFS from %d is:\n" , FMCNVD )
FBW FBW ( JMKEH , FMCNVD )
printf printf ( "\n" )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < UYVTP
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
JAEYIQCVMFG JAEYIQCVMFG ( AEHHRIVS )
<operator>.assignment i = 0
printf printf ( "Edge %d \nEnter source: " , i + 1 )
OKWDL OKWDL ( "%d" , & KFG )
printf printf ( "Enter destination: " )
OKWDL OKWDL ( "%d" , & WDR )
SNGXGWJ SNGXGWJ ( JMKEH , KFG , WDR )
<operator>.addition i + 1
<operator>.addressOf & KFG
<operator>.addressOf & WDR
>>>PDG&26 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 2->1 3->1 3->1 3->16 4->1 4->1 4->10 4->22 5->1 6->1 6->1 6->13 7->1 8->1 8->1 8->9 8->10 9->1 9->10 10->1 10->1 10->1 11->1 12->1 13->1 13->1 13->1 13->13 13->14 13->14 13->18 13->18 13->19 13->20 13->21 13->22 13->23 13->23 13->24 13->25 14->1 14->13 15->12 16->1 16->4 17->1 17->13 18->1 18->1 19->1 19->1 19->22 20->1 21->1 21->1 21->22 22->1 22->1 22->1 22->10 22->19 22->21
>>>Token int main ( ) { int AEHHRIVS , UYVTP , FMCNVD , i , KFG , WDR ; printf ( " \n " ) ; OKWDL ( " " , & AEHHRIVS ) ; struct SDRCM * JMKEH = JAEYIQCVMFG ( AEHHRIVS ) ; printf ( " \n " ) ; OKWDL ( " " , & UYVTP ) ; for ( i = 0 ; i < UYVTP ; i ++ ) { printf ( " \n " , i + 1 ) ; OKWDL ( " " , & KFG ) ; printf ( " " ) ; OKWDL ( " " , & WDR ) ; SNGXGWJ ( JMKEH , KFG , WDR ) ; } printf ( " \n " ) ; OKWDL ( " " , & FMCNVD ) ; printf ( " \n " , FMCNVD ) ; FBW ( JMKEH , FMCNVD ) ; printf ( " \n " ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment SOM = HNBUFUU ( TSWUFF , "r" , stdin )
<operator>.assignment IYQB = HNBUFUU ( CJOTNLO , "w" , NWESPV )
DMDGE DMDGE ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
HNBUFUU HNBUFUU ( TSWUFF , "r" , stdin )
HNBUFUU HNBUFUU ( CJOTNLO , "w" , NWESPV )
<operator>.assignment i = 0
<operator>.assignment HAW = 0
DMDGE DMDGE ( "%d " , & c )
DMDGE DMDGE ( "%d " , & d )
DMDGE DMDGE ( "%d " , & n )
DMDGE DMDGE ( "%s" , cc )
printf printf ( "Case #%d: [" , i + 1 )
<operator>.assignment j = 0
printf printf ( "]\n" )
<operator>.lessThan j < c
<operator>.postIncrement j ++
DMDGE DMDGE ( "%c%c%c " , & BVAVR [ j ] , & AOLPL [ j ] , & BBAO [ j ] )
<operator>.lessThan j < d
<operator>.postIncrement j ++
DMDGE DMDGE ( "%c%c " , & AGKS [ j ] , & SYHI [ j ] )
<operator>.equals n == 1
<operator>.lessThan j < n
IDENTIFIER HAW if (HAW)
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.addition i + 1
printf printf ( "%c]\n" , cc [ 0 ] )
<operator>.assignment AEGNF = 0
<operator>.assignment EKG [ HAW ++ ] = cc [ j ]
<operator>.postIncrement j ++
printf printf ( "%c" , EKG [ 0 ] )
<operator>.lessThan l < HAW
<operator>.postIncrement l ++
IDENTIFIER AEGNF if (AEGNF)
<operator>.equals j == n - 1
<operator>.lessThan k < c
<operator>.postIncrement k ++
IDENTIFIER AEGNF if (AEGNF)
<operator>.lessThan k < HAW
<operator>.postIncrement k ++
printf printf ( ", %c" , EKG [ k ] )
<operator>.assignment l = 0
<operator>.assignment EKG [ HAW ++ ] = cc [ j ]
<operator>.assignment k = 0
<operator>.logicalOr ( BVAVR [ k ] == cc [ j ] && AOLPL [ k ] == cc [ j + 1 ] ) || ( AOLPL [ k ] == cc [ j ] && BVAVR [ k ] == cc [ j + 1 ] )
<operator>.assignment k = 1
<operator>.lessThan k < d
<operator>.postIncrement k ++
IDENTIFIER AEGNF if (AEGNF)
<operator>.subtraction n - 1
<operator>.assignment EKG [ HAW ++ ] = BBAO [ k ]
<operator>.assignmentPlus j += 2
<operator>.assignment AEGNF = 1
<operator>.postIncrement HAW ++
<operator>.assignment k = 0
<operator>.logicalOr ( AGKS [ k ] == cc [ j ] && SYHI [ k ] == EKG [ l ] ) || ( SYHI [ k ] == cc [ j ] && AGKS [ k ] == EKG [ l ] )
<operator>.logicalAnd BVAVR [ k ] == cc [ j ] && AOLPL [ k ] == cc [ j + 1 ]
<operator>.logicalAnd AOLPL [ k ] == cc [ j ] && BVAVR [ k ] == cc [ j + 1 ]
<operator>.assignment HAW = 0
<operator>.assignment AEGNF = 1
<operator>.postIncrement j ++
<operator>.postIncrement HAW ++
<operator>.equals BVAVR [ k ] == cc [ j ]
<operator>.equals AOLPL [ k ] == cc [ j + 1 ]
<operator>.equals AOLPL [ k ] == cc [ j ]
<operator>.equals BVAVR [ k ] == cc [ j + 1 ]
<operator>.logicalAnd AGKS [ k ] == cc [ j ] && SYHI [ k ] == EKG [ l ]
<operator>.logicalAnd SYHI [ k ] == cc [ j ] && AGKS [ k ] == EKG [ l ]
<operator>.postIncrement HAW ++
<operator>.equals AGKS [ k ] == cc [ j ]
<operator>.equals SYHI [ k ] == EKG [ l ]
<operator>.equals SYHI [ k ] == cc [ j ]
<operator>.equals AGKS [ k ] == EKG [ l ]
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.addressOf & BVAVR [ j ]
<operator>.addressOf & AOLPL [ j ]
<operator>.addressOf & BBAO [ j ]
<operator>.addressOf & AGKS [ j ]
<operator>.addressOf & SYHI [ j ]
<operator>.indirectIndexAccess BVAVR [ j ]
<operator>.indirectIndexAccess AOLPL [ j ]
<operator>.indirectIndexAccess BBAO [ j ]
<operator>.indirectIndexAccess AGKS [ j ]
<operator>.indirectIndexAccess SYHI [ j ]
<operator>.indirectIndexAccess cc [ 0 ]
<operator>.indirectIndexAccess EKG [ HAW ++ ]
<operator>.indirectIndexAccess cc [ j ]
<operator>.indirectIndexAccess EKG [ 0 ]
<operator>.indirectIndexAccess EKG [ k ]
<operator>.indirectIndexAccess EKG [ HAW ++ ]
<operator>.indirectIndexAccess cc [ j ]
<operator>.indirectIndexAccess EKG [ HAW ++ ]
<operator>.indirectIndexAccess BBAO [ k ]
<operator>.indirectIndexAccess BVAVR [ k ]
<operator>.indirectIndexAccess cc [ j ]
<operator>.indirectIndexAccess AOLPL [ k ]
<operator>.indirectIndexAccess cc [ j + 1 ]
<operator>.indirectIndexAccess AOLPL [ k ]
<operator>.indirectIndexAccess cc [ j ]
<operator>.indirectIndexAccess BVAVR [ k ]
<operator>.indirectIndexAccess cc [ j + 1 ]
<operator>.indirectIndexAccess AGKS [ k ]
<operator>.indirectIndexAccess cc [ j ]
<operator>.indirectIndexAccess SYHI [ k ]
<operator>.indirectIndexAccess EKG [ l ]
<operator>.indirectIndexAccess SYHI [ k ]
<operator>.indirectIndexAccess cc [ j ]
<operator>.indirectIndexAccess AGKS [ k ]
<operator>.indirectIndexAccess EKG [ l ]
>>>PDG&119 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->49 0->51 0->52 0->53 0->54 0->55 0->57 0->58 0->59 0->60 0->64 0->65 0->66 0->67 0->74 0->79 0->80 2->1 2->1 2->1 3->1 3->1 3->1 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->12 6->13 6->14 6->15 6->16 6->17 6->17 6->20 6->23 6->26 6->29 6->30 6->31 6->31 6->81 6->82 6->83 7->1 7->6 8->5 9->1 9->1 9->2 9->2 9->2 10->1 10->1 10->3 10->3 10->3 11->1 11->6 12->1 12->1 12->37 12->44 13->1 13->1 13->20 13->41 14->1 14->1 14->23 14->52 15->1 15->1 15->26 15->27 15->55 16->1 16->1 16->32 16->34 16->48 16->68 16->69 16->70 16->71 16->75 16->77 17->1 17->1 18->1 18->27 19->1 20->1 20->1 20->13 20->20 20->21 20->21 20->22 20->41 20->84 20->85 20->86 20->89 20->90 20->91 21->1 21->20 22->1 22->1 22->1 22->1 23->1 23->1 23->1 23->14 23->23 23->24 23->24 23->25 23->52 23->87 23->88 23->92 23->93 24->1 24->23 25->1 25->1 25->1 26->1 26->1 26->15 26->18 26->19 26->27 26->27 26->32 26->36 26->44 26->51 26->94 26->97 27->1 27->1 27->1 27->15 27->26 27->27 27->33 27->37 27->40 27->40 27->47 27->55 27->55 27->66 29->20 30->1 30->23 32->1 32->1 32->16 33->1 33->1 34->1 34->1 34->1 35->1 35->27 36->1 36->1 37->1 37->1 37->1 37->37 37->38 37->38 37->44 37->52 37->59 37->60 37->67 37->74 38->1 38->37 40->1 40->1 40->1 40->27 40->27 40->34 40->35 40->35 40->41 40->48 40->49 40->57 40->59 40->67 40->79 40->80 40->95 40->96 40->99 40->100 41->1 41->1 41->1 41->13 41->20 41->42 41->50 41->62 41->68 41->103 41->104 42->1 42->41 44->1 44->1 44->1 44->44 44->45 44->45 44->46 44->98 45->1 45->44 46->1 46->1 47->1 47->37 48->1 48->1 48->1 49->1 49->41 50->1 50->1 50->1 50->41 50->42 50->56 50->57 50->58 50->74 50->101 50->102 51->1 51->44 52->1 52->1 52->1 52->14 52->23 52->53 52->61 52->72 52->75 52->111 52->112 53->1 53->52 55->1 55->15 55->26 55->27 55->40 55->40 56->1 56->1 56->1 57->1 57->27 57->35 58->1 58->1 59->1 59->37 59->44 60->1 60->52 61->1 61->1 61->1 61->52 61->53 61->64 61->65 61->66 62->1 62->1 62->50 62->50 62->63 62->70 62->107 62->108 63->1 63->1 63->50 63->50 64->1 64->1 64->37 64->44 64->59 64->67 64->74 65->1 65->1 66->1 66->27 66->40 67->1 67->44 68->1 68->1 68->16 68->34 68->48 68->62 68->62 68->69 68->70 68->71 68->75 68->79 68->105 68->106 69->1 69->1 69->16 69->62 69->62 69->70 69->71 70->1 70->1 70->16 70->34 70->48 70->63 70->63 70->68 70->69 70->71 70->75 70->80 70->109 70->110 71->1 71->1 71->16 71->63 71->63 71->68 71->69 72->1 72->1 72->61 72->61 72->73 72->77 72->115 72->116 73->1 73->1 73->61 73->61 74->1 74->37 74->44 74->59 75->1 75->1 75->16 75->34 75->48 75->68 75->72 75->72 75->76 75->77 75->78 75->113 75->114 76->1 76->1 76->72 76->72 76->77 76->78 77->1 77->1 77->16 77->34 77->48 77->68 77->73 77->73 77->75 77->76 77->78 77->117 77->118 78->1 78->1 78->73 78->73 78->75 78->76
>>>Token int main ( ) { AKPF * SOM , * IYQB ; SOM = HNBUFUU ( TSWUFF , " " , stdin ) ; IYQB = HNBUFUU ( CJOTNLO , " " , NWESPV ) ; int t , c , d , n , i , j , k , HAW , l , AEGNF ; char BVAVR [ SUMA ] , AOLPL [ SUMA ] , BBAO [ SUMA ] ; char AGKS [ ERUB ] , SYHI [ ERUB ] ; char EKG [ GIXB ] ; char cc [ GIXB ] ; DMDGE ( " " , & t ) ; for ( i = 0 ; i < t ; i ++ ) { HAW = 0 ; DMDGE ( " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) DMDGE ( " " , & BVAVR [ j ] , & AOLPL [ j ] , & BBAO [ j ] ) ; DMDGE ( " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) DMDGE ( " " , & AGKS [ j ] , & SYHI [ j ] ) ; DMDGE ( " " , & n ) ; DMDGE ( " " , cc ) ; printf ( " " , i + 1 ) ; if ( n == 1 ) { printf ( " \n " , cc [ 0 ] ) ; continue ; } j = 0 ; while ( j < n ) { AEGNF = 0 ; for ( l = 0 ; l < HAW ; l ++ ) { for ( k = 0 ; k < d ; k ++ ) if ( ( AGKS [ k ] == cc [ j ] && SYHI [ k ] == EKG [ l ] ) || ( SYHI [ k ] == cc [ j ] && AGKS [ k ] == EKG [ l ] ) ) { HAW = 0 ; AEGNF = 1 ; j ++ ; break ; } if ( AEGNF ) break ; } if ( AEGNF ) continue ; if ( j == n - 1 ) { EKG [ HAW ++ ] = cc [ j ] ; break ; } for ( k = 0 ; k < c ; k ++ ) if ( ( BVAVR [ k ] == cc [ j ] && AOLPL [ k ] == cc [ j + 1 ] ) || ( AOLPL [ k ] == cc [ j ] && BVAVR [ k ] == cc [ j + 1 ] ) ) { EKG [ HAW ++ ] = BBAO [ k ] ; j += 2 ; AEGNF = 1 ; break ; } if ( AEGNF ) continue ; EKG [ HAW ++ ] = cc [ j ] ; j ++ ; } if ( HAW ) { printf ( " " , EKG [ 0 ] ) ; for ( k = 1 ; k < HAW ; k ++ ) printf ( " " , EKG [ k ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD JTJAYXR
METHOD_RETURN int
PARAM int lo
PARAM int hi
PARAM char * HXDD
<operator>.assignment c = QUPTF ( " %d \n" , & n )
RETURN return n ; return n ;
<operator>.notEquals c != 1
<operator>.lessThan n < lo
<operator>.greaterThan n > hi
IDENTIFIER n return n ;
QUPTF QUPTF ( " %d \n" , & n )
printf printf ( "scanf returned %d instead of 1 for %s\n" , c , HXDD )
exit exit ( 1 )
printf printf ( "scanf read %d, less than %d, for %s\n" , n , lo , HXDD )
exit exit ( 1 )
printf printf ( "scanf read %d, greater than %d, for %s\n" , n , hi , HXDD )
exit exit ( 1 )
>>>PDG&18 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->8 3->9 4->1 4->12 4->14 4->16 5->1 5->1 5->7 6->1 7->1 7->1 7->12 7->12 7->13 8->1 8->1 8->9 8->14 8->14 8->14 8->15 9->1 9->1 9->1 9->10 9->16 9->16 9->16 9->17 10->6 11->1 11->5 11->5 11->8 11->9 11->10 11->14 11->16 12->1 12->1 12->1 12->14 12->16 14->1 14->1 14->1 14->9 14->16 16->1 16->1 16->1 16->1 16->10
>>>Token int JTJAYXR ( int lo , int hi , char * HXDD ) { int n ; int c = QUPTF ( " \n " , & n ) ; if ( c != 1 ) { printf ( " \n " , c , HXDD ) ; exit ( 1 ) ; } if ( n < lo ) { printf ( " \n " , n , lo , HXDD ) ; exit ( 1 ) ; } if ( n > hi ) { printf ( " \n " , n , hi , HXDD ) ; exit ( 1 ) ; } return n ; }
>>>Func
METHOD PWBVGT
METHOD_RETURN int
PARAM const void * a
PARAM const void * b
RETURN return * ( int * ) b - * ( int * ) a ; return * ( int * ) b - * ( int * ) a ;
<operator>.subtraction * ( int * ) b - * ( int * ) a
<operator>.cast ( int * ) b
<operator>.cast ( int * ) a
>>>PDG&8 0->2 0->3 0->6 0->7 2->7 3->6 4->1 5->1 5->1 5->1 5->4 6->1 7->1
>>>Token int PWBVGT ( const void * a , const void * b ) { return * ( int * ) b - * ( int * ) a ; }
>>>Func
METHOD WCOQCXL
METHOD_RETURN void
PARAM char KRDEO [ ]
PARAM char WARPACB [ ]
<operator>.assignment s . MMU = - 1
<operator>.assignment j = 0
<operator>.assignment WARPACB [ j ] = '\0'
<operator>.notEquals KRDEO [ i ] != '\0'
<operator>.postIncrement i ++
<operator>.equals MBUPCLC ( s ) == 0
<operator>.minus - 1
<operator>.assignment i = 0
<operator>.assignment ch = KRDEO [ i ]
<operator>.assignment WARPACB [ j ] = SLT ( & s )
<operator>.postIncrement j ++
<operator>.equals BAJTCHI ( ch ) == 1
MBUPCLC MBUPCLC ( s )
<operator>.assignment WARPACB [ j ] = ch
<operator>.postIncrement j ++
SLT SLT ( & s )
BAJTCHI BAJTCHI ( ch )
<operator>.equals ch == '('
MCNT MCNT ( & s , ch )
<operator>.equals,ch == ')'
<operator>.notEquals ( XDVS = SLT ( & s ) ) != '('
MCNT MCNT ( & s , ch )
<operator>.assignment WARPACB [ j ] = XDVS
<operator>.postIncrement j ++
<operator>.equals MBUPCLC ( s ) == 0
<operator>.assignment XDVS = SLT ( & s )
<operator>.assignment pr = VORKEMJHLCKLL ( ch , s . FOV [ s . MMU ] )
<operator>.assignment WARPACB [ j ] = SLT ( & s )
<operator>.postIncrement j ++
SLT SLT ( & s )
MBUPCLC MBUPCLC ( s )
<operator>.equals pr == 1
VORKEMJHLCKLL VORKEMJHLCKLL ( ch , s . FOV [ s . MMU ] )
SLT SLT ( & s )
<operator>.indirectIndexAccess KRDEO [ i ]
<operator>.indirectIndexAccess KRDEO [ i ]
<operator>.indirectIndexAccess WARPACB [ j ]
<operator>.addressOf & s
<operator>.indirectIndexAccess WARPACB [ j ]
<operator>.addressOf & s
<operator>.addressOf & s
<operator>.indirectIndexAccess WARPACB [ j ]
<operator>.addressOf & s
<operator>.indirectIndexAccess WARPACB [ j ]
<operator>.indirectIndexAccess s . FOV [ s . MMU ]
<operator>.addressOf & s
<operator>.fieldAccess s . FOV
<operator>.fieldAccess s . MMU
FIELD_IDENTIFIER FOV FOV
FIELD_IDENTIFIER MMU MMU
>>>PDG&54 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->32 0->33 0->34 0->35 0->36 0->37 2->1 2->7 2->12 3->1 4->1 4->1 4->16 4->22 4->33 4->34 5->1 5->1 5->14 5->18 5->27 5->32 6->1 6->1 7->1 7->1 7->7 7->8 7->12 7->12 7->15 7->20 7->38 7->39 8->1 8->1 9->1 9->1 9->9 9->13 9->14 9->16 9->19 9->40 9->41 10->4 11->1 11->1 11->8 12->1 12->20 13->1 13->1 14->1 14->1 15->1 15->1 15->17 15->18 15->21 15->42 16->1 16->9 16->19 17->1 17->1 18->1 18->1 18->14 18->27 18->32 19->1 19->13 19->16 20->15 20->17 20->21 21->1 21->22 21->22 21->23 21->23 21->43 22->1 22->1 22->1 22->16 22->19 22->25 22->33 22->34 22->37 23->1 23->1 23->24 23->25 23->25 23->28 23->29 23->33 23->34 23->36 23->44 23->46 24->1 24->1 24->24 24->26 24->27 24->29 24->33 24->45 24->46 25->1 25->1 25->1 25->16 25->19 25->22 25->33 25->34 25->37 26->1 27->1 27->1 27->14 27->18 27->32 28->30 28->35 28->36 28->48 28->50 28->51 28->52 28->53 29->1 29->1 29->24 29->26 30->1 30->1 30->35 31->1 31->1 32->1 32->1 32->14 32->18 32->27 33->1 33->16 33->19 33->22 33->24 33->25 33->29 33->34 33->37 34->16 34->22 34->25 34->28 34->33 34->37 35->1 35->1 35->28 35->31 35->32 35->34 35->37 35->47 35->49 36->1 36->25 36->30 36->30 37->16 37->22 37->25 37->31 37->33 37->34
>>>Token void WCOQCXL ( char KRDEO [ ] , char WARPACB [ ] ) { struct OKQDM s ; s . MMU = - 1 ; int i , j = 0 , pr ; char ch , XDVS ; for ( i = 0 ; KRDEO [ i ] != ' \0 ' ; i ++ ) { ch = KRDEO [ i ] ; if ( BAJTCHI ( ch ) == 1 ) { WARPACB [ j ] = ch ; j ++ ; } else { if ( ch == ' ' ) { MCNT ( & s , ch ) ; } else { if ( ch == ' ' ) { while ( ( XDVS = SLT ( & s ) ) != ' ' ) { WARPACB [ j ] = XDVS ; j ++ ; } } else { while ( MBUPCLC ( s ) == 0 ) { pr = VORKEMJHLCKLL ( ch , s . FOV [ s . MMU ] ) ; if ( pr == 1 ) { break ; } WARPACB [ j ] = SLT ( & s ) ; j ++ ; } MCNT ( & s , ch ) ; } } } } while ( MBUPCLC ( s ) == 0 ) { WARPACB [ j ] = SLT ( & s ) ; j ++ ; } WARPACB [ j ] = ' \0 ' ; }
>>>Func
METHOD UAIQY
METHOD_RETURN void
PARAM DLQH * SKKY
<operator>.notEquals SKKY != NULL
free free ( SKKY )
<operator>.assignment SKKY = NULL
<operator>.notEquals SKKY -> BFQI != NULL
<operator>.notEquals SKKY -> KSIJK != NULL
UAIQY UAIQY ( SKKY -> BFQI )
UAIQY UAIQY ( SKKY -> KSIJK )
<operator>.indirectFieldAccess SKKY -> BFQI
<operator>.indirectFieldAccess SKKY -> KSIJK
FIELD_IDENTIFIER BFQI BFQI
<operator>.indirectFieldAccess SKKY -> BFQI
FIELD_IDENTIFIER KSIJK KSIJK
<operator>.indirectFieldAccess SKKY -> KSIJK
FIELD_IDENTIFIER BFQI BFQI
FIELD_IDENTIFIER KSIJK KSIJK
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 2->3 3->1 3->4 3->4 3->5 3->6 3->6 3->7 3->10 3->11 3->12 3->14 5->1 5->1 5->1 6->1 6->1 6->7 6->8 6->8 6->13 6->16 7->1 7->1 7->5 7->9 7->9 7->15 7->17 8->1 8->1 9->1 9->1
>>>Token void UAIQY ( DLQH * SKKY ) { if ( SKKY != NULL ) { if ( SKKY -> BFQI != NULL ) { UAIQY ( SKKY -> BFQI ) ; } if ( SKKY -> KSIJK != NULL ) { UAIQY ( SKKY -> KSIJK ) ; } free ( SKKY ) ; SKKY = NULL ; } }
>>>Func
METHOD main
METHOD_RETURN int
ELVTQ ELVTQ ( " %d" , & FWVC )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= FWVC
<operator>.preIncrement ++ t
LITERAL 0 return 0 ;
<operator>.assignment t = 1
ELVTQ ELVTQ ( " %lf %lf %lf %lf %d" , & x , & s , & r , & rT , & n )
VADVN VADVN ( YDHV   n   sizeof ( struct SKCL ) , UJS )
<operator>.assignment time = 0
printf printf ( "Case #%d: %lf\n" , t , time )
<operator>.lessThan i < n
<operator>.preIncrement ++ i
<operator>.greaterEqualsThan x >= rT * r
<operator>.lessThan i < n
<operator>.preIncrement ++ i
<operator>.assignment i = 0
ELVTQ ELVTQ ( " %lf %lf %lf" , & YDHV [ i ] . b , & YDHV [ i ] . e , & YDHV [ i ] . w )
<operator>.assignment YDHV [ i ] . SYG = YDHV [ i ] . e - YDHV [ i ] . b
<operator>.assignmentMinus x -= ( YDHV [ i ] . e - YDHV [ i ] . b )
<operator>.sizeOf sizeof ( struct SKCL )
<operator>.assignmentPlus time += rT
<operator>.assignmentMinus x -= rT * r
<operator>.assignmentPlus time += ( x ) / ( s )
<operator>.assignment rT = 0
<operator>.assignment i = 0
<operator>.multiplication rT * r
<operator>.assignmentPlus time += ( x ) / ( r )
<operator>.assignmentMinus rT -= ( x ) / ( r )
<operator>.greaterThan rT > 0.0
<operator>.subtraction YDHV [ i ] . e - YDHV [ i ] . b
<operator>.subtraction YDHV [ i ] . e - YDHV [ i ] . b
<operator>.multiplication rT * r
<operator>.division ( x ) / ( s )
<operator>.division ( x ) / ( r )
<operator>.division ( x ) / ( r )
<operator>.greaterEqualsThan YDHV [ i ] . SYG >= ( YDHV [ i ] . w + r ) * rT
<operator>.assignmentPlus time += ( double ) ( YDHV [ i ] . SYG ) / ( double ) ( YDHV [ i ] . w + s )
<operator>.assignmentPlus time += rT
<operator>.assignmentMinus YDHV [ i ] . SYG -= ( YDHV [ i ] . w + r ) * rT
<operator>.assignmentPlus time += YDHV [ i ] . SYG / ( YDHV [ i ] . w + s )
<operator>.assignment rT = 0
<operator>.multiplication ( YDHV [ i ] . w + r ) * rT
<operator>.assignmentPlus time += YDHV [ i ] . SYG / ( YDHV [ i ] . w + r )
<operator>.assignmentMinus rT -= YDHV [ i ] . SYG / ( YDHV [ i ] . w + r )
<operator>.division ( double ) ( YDHV [ i ] . SYG ) / ( double ) ( YDHV [ i ] . w + s )
<operator>.addition YDHV [ i ] . w + r
<operator>.multiplication ( YDHV [ i ] . w + r ) * rT
<operator>.division YDHV [ i ] . SYG / ( YDHV [ i ] . w + s )
<operator>.cast ( double ) ( YDHV [ i ] . w + s )
<operator>.addition YDHV [ i ] . w + r
<operator>.addition YDHV [ i ] . w + s
<operator>.division YDHV [ i ] . SYG / ( YDHV [ i ] . w + r )
<operator>.division YDHV [ i ] . SYG / ( YDHV [ i ] . w + r )
<operator>.addition YDHV [ i ] . w + s
<operator>.addition YDHV [ i ] . w + r
<operator>.addition YDHV [ i ] . w + r
<operator>.addressOf & x
<operator>.addressOf & s
<operator>.addressOf & r
<operator>.addressOf & rT
<operator>.addressOf & n
<operator>.addressOf & YDHV [ i ] . b
<operator>.addressOf & YDHV [ i ] . e
<operator>.addressOf & YDHV [ i ] . w
<operator>.fieldAccess YDHV [ i ] . SYG
<operator>.fieldAccess YDHV [ i ] . b
<operator>.fieldAccess YDHV [ i ] . e
<operator>.fieldAccess YDHV [ i ] . w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER SYG SYG
<operator>.fieldAccess YDHV [ i ] . e
<operator>.fieldAccess YDHV [ i ] . b
<operator>.fieldAccess YDHV [ i ] . e
<operator>.fieldAccess YDHV [ i ] . b
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER b b
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER e e
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER e e
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER b b
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER e e
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER b b
<operator>.fieldAccess YDHV [ i ] . SYG
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER SYG SYG
<operator>.fieldAccess YDHV [ i ] . SYG
<operator>.cast ( double ) ( YDHV [ i ] . SYG )
<operator>.fieldAccess YDHV [ i ] . w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER SYG SYG
<operator>.fieldAccess YDHV [ i ] . SYG
UNKNOWN double double
<operator>.fieldAccess YDHV [ i ] . SYG
UNKNOWN double double
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER w w
<operator>.fieldAccess YDHV [ i ] . w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER SYG SYG
<operator>.fieldAccess YDHV [ i ] . w
<operator>.fieldAccess YDHV [ i ] . SYG
<operator>.fieldAccess YDHV [ i ] . SYG
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER SYG SYG
<operator>.fieldAccess YDHV [ i ] . w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER SYG SYG
<operator>.fieldAccess YDHV [ i ] . w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER SYG SYG
<operator>.fieldAccess YDHV [ i ] . w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess YDHV [ i ]
FIELD_IDENTIFIER w w
>>>PDG&129 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->33 0->34 0->35 0->36 0->38 0->39 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->11 4->12 4->14 4->15 4->17 4->21 4->26 4->27 4->58 4->59 4->60 4->61 4->62 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->1 8->1 8->1 8->9 8->12 8->14 8->15 8->20 8->22 8->23 8->27 8->27 8->29 8->30 8->33 8->33 8->34 8->34 8->35 8->35 8->36 8->36 8->39 8->43 8->43 8->45 8->46 8->47 8->48 8->48 8->49 8->50 8->51 8->52 8->53 8->54 8->55 8->56 8->57 9->1 9->1 9->1 9->15 10->1 10->22 10->28 11->1 11->1 11->5 12->9 12->12 12->13 12->13 12->18 12->19 12->20 12->31 12->32 12->63 12->64 12->65 12->66 12->67 12->68 12->69 12->70 12->71 12->72 12->73 12->74 12->75 12->76 12->77 12->78 12->79 12->80 12->81 12->82 12->83 12->84 12->85 12->86 12->87 12->88 12->89 13->1 13->12 14->1 14->1 14->22 14->23 14->23 14->24 14->25 14->28 14->29 14->33 14->34 14->35 14->35 14->36 15->1 15->1 15->1 15->8 15->12 15->15 15->16 15->16 15->30 16->1 16->15 17->12 18->1 18->1 18->1 18->1 18->31 18->31 18->32 18->32 18->43 18->46 18->47 18->48 18->49 18->50 18->51 18->52 18->53 18->54 18->55 18->56 18->57 19->1 20->1 20->1 20->14 21->1 22->1 22->24 23->1 23->1 23->34 24->1 24->1 24->11 24->38 24->39 24->44 25->1 25->1 25->8 25->27 25->30 26->1 26->15 27->14 27->14 27->22 27->29 27->33 27->33 27->35 28->1 28->11 28->38 28->39 28->44 29->1 29->1 29->1 29->8 29->27 29->30 30->1 30->1 30->8 30->27 30->37 30->38 30->43 30->43 30->46 30->47 30->50 30->55 30->90 30->91 30->92 30->94 30->95 30->99 30->100 30->101 30->102 30->103 30->110 30->111 30->112 30->123 30->124 31->19 31->19 31->32 31->32 32->20 32->20 33->1 33->8 33->23 33->23 33->27 33->43 33->47 33->53 33->54 33->56 33->57 34->1 34->1 34->8 34->8 34->14 34->20 34->24 34->24 34->46 34->49 34->50 34->52 34->55 35->28 35->28 35->36 35->36 36->1 36->1 36->8 36->8 36->14 36->20 36->27 36->29 36->29 36->43 36->47 36->53 36->54 36->56 36->57 37->1 37->1 37->39 37->40 37->40 37->41 37->42 37->44 37->45 37->48 37->49 37->51 37->52 37->53 37->53 37->54 37->56 37->57 37->93 37->96 37->97 37->98 37->104 37->105 37->106 37->107 37->108 37->109 37->113 37->114 37->115 37->116 37->117 37->118 37->119 37->120 37->121 37->122 37->125 37->126 37->127 37->128 38->1 38->1 38->11 38->39 38->44 39->1 39->41 40->1 40->1 40->49 41->1 41->1 41->11 41->38 41->39 41->44 42->1 42->1 42->8 42->27 42->30 43->37 43->37 43->39 43->45 43->48 44->1 44->11 44->38 44->39 45->1 45->1 45->1 45->8 45->27 45->30 46->1 46->1 46->38 46->38 48->1 48->40 48->40 49->1 49->41 49->41 50->1 51->1 52->1 53->44 53->44 53->54 54->1 54->45 54->45 55->1 57->1
>>>Token int main ( ) { int i , j , t , FWVC ; double x , s , r ; int n ; double rT ; double time , TWVG ; ELVTQ ( " " , & FWVC ) ; for ( t = 1 ; t <= FWVC ; ++ t ) { ELVTQ ( " " , & x , & s , & r , & rT , & n ) ; for ( i = 0 ; i < n ; ++ i ) { ELVTQ ( " " , & YDHV [ i ] . b , & YDHV [ i ] . e , & YDHV [ i ] . w ) ; YDHV [ i ] . SYG = YDHV [ i ] . e - YDHV [ i ] . b ; x -= ( YDHV [ i ] . e - YDHV [ i ] . b ) ; } VADVN ( YDHV , n , sizeof ( struct SKCL ) , UJS ) ; time = 0 ; if ( x >= rT * r ) { time += rT ; x -= rT * r ; time += ( x ) / ( s ) ; rT = 0 ; } else { time += ( x ) / ( r ) ; rT -= ( x ) / ( r ) ; } for ( i = 0 ; i < n ; ++ i ) { if ( rT > 0.0 ) { if ( YDHV [ i ] . SYG >= ( YDHV [ i ] . w + r ) * rT ) { time += rT ; YDHV [ i ] . SYG -= ( YDHV [ i ] . w + r ) * rT ; time += YDHV [ i ] . SYG / ( YDHV [ i ] . w + s ) ; rT = 0 ; } else { time += YDHV [ i ] . SYG / ( YDHV [ i ] . w + r ) ; rT -= YDHV [ i ] . SYG / ( YDHV [ i ] . w + r ) ; } } else { time += ( double ) ( YDHV [ i ] . SYG ) / ( double ) ( YDHV [ i ] . w + s ) ; } } printf ( " \n " , t , time ) ; } return 0 ; }
>>>Func
METHOD KNXREISDLOAHQM
METHOD_RETURN void
PARAM long * TOYGRHBNYOGQRIHXYU
PARAM int * * LYMRJHV
PARAM int * * UXXDOLYEKIXRLLSAR
PARAM int n
PARAM int m
PARAM int KSCRQDOECBVL
<operator>.assignment VPXOEWUTCNTFXFVCQE = ( int ) TVQE ( ( 0.2f / n ) * UGE ( 3.142f * WAHY ( 2 * n / 3 ) ) )
<operator>.assignment LIPEK = malloc ( VPXOEWUTCNTFXFVCQE * n * sizeof ( int ) )
<operator>.assignment JOD = malloc ( VPXOEWUTCNTFXFVCQE * sizeof ( int ) )
<operator>.assignment j = 0
<operator>.assignment LTIJSNYEPFQXDK = j
<operator>.assignment * TOYGRHBNYOGQRIHXYU = LTIJSNYEPFQXDK
<operator>.assignment * LYMRJHV = JOD
<operator>.assignment * UXXDOLYEKIXRLLSAR = LIPEK
RETURN return ; return ;
<operator>.lessThan j < VPXOEWUTCNTFXFVCQE
<operator>.postIncrement j ++
<operator>.equals m == 0
<operator>.lessEqualsThan m1 <= RBAFM
<operator>.postIncrement m1 ++
<operator>.greaterEqualsThan KSCRQDOECBVL >= 2
<operator>.cast ( int ) TVQE ( ( 0.2f / n ) * UGE ( 3.142f * WAHY ( 2 * n / 3 ) ) )
malloc malloc ( VPXOEWUTCNTFXFVCQE * n * sizeof ( int ) )
<operator>.assignment j = 0
malloc malloc ( VPXOEWUTCNTFXFVCQE * sizeof ( int ) )
<operator>.assignment KWPYB = 1
<operator>.assignment RBAFM = n
<operator>.assignment m1 = KWPYB
<operator>.assignment LIPEK [ j * n + 0 ] = n - m1 + 1
<operator>.assignment JOD [ j ] = m1
TVQE TVQE ( ( 0.2f / n ) * UGE ( 3.142f * WAHY ( 2 * n / 3 ) ) )
<operator>.multiplication VPXOEWUTCNTFXFVCQE * n * sizeof ( int )
<operator>.lessThan l < n
<operator>.postIncrement l ++
<operator>.multiplication VPXOEWUTCNTFXFVCQE * sizeof ( int )
<operator>.assignment KWPYB = RBAFM = m
<operator>.lessEqualsThan l <= m1 - 1
<operator>.postIncrement l ++
LITERAL 1 while (1)
<operator>.lessThan j < LTIJSNYEPFQXDK
<operator>.postIncrement j ++
<operator>.multiplication ( 0.2f / n ) * UGE ( 3.142f * WAHY ( 2 * n / 3 ) )
<operator>.multiplication VPXOEWUTCNTFXFVCQE * n
<operator>.assignment l = 0
<operator>.assignment LIPEK [ j * n + l ] = 0
<operator>.sizeOf sizeof ( int )
<operator>.addition n - m1 + 1
<operator>.assignment l = 1
<operator>.assignment LIPEK [ j * n + l ] = 1
<operator>.assignment JOD [ j ] = m1
<operator>.assignment j = 0
printf printf ( "  partition #%ld/%ld :" , j , LTIJSNYEPFQXDK )
printf printf ( "\n" )
<operator>.division 0.2f / n
UGE UGE ( 3.142f * WAHY ( 2 * n / 3 ) )
<operator>.assignment RBAFM = m
<operator>.addition j * n + 0
<operator>.subtraction n - m1
<operator>.subtraction m1 - 1
<operator>.greaterEqualsThan KSCRQDOECBVL >= 3
<operator>.greaterEqualsThan u >= 0
<operator>.postDecrement u --
<operator>.equals u == - 1
<operator>.lessThan l < JOD [ j ]
<operator>.postIncrement l ++
<operator>.multiplication 3.142f * WAHY ( 2 * n / 3 )
<operator>.multiplication j * n
printf printf ( "partition #%ld :" , j )
printf printf ( "\n" )
<operator>.assignment u = m1 - 2
<operator>.postIncrement j ++
<operator>.assignment l = 0
printf printf ( " %d " , LIPEK [ j * n + l ] )
WAHY WAHY ( 2 * n / 3 )
<operator>.addition j * n + l
<operator>.addition j * n + l
<operator>.lessThan l < m1
<operator>.postIncrement l ++
<operator>.greaterEqualsThan LIPEK [ j * n + u ] >= LIPEK [ j * n + ( m1 - 1 ) ] + 2
<operator>.minus - 1
<operator>.assignment LIPEK [ ( j + 1 ) * n + u ] = LIPEK [ j * n + u ] - 1
<operator>.assignment FVUXTMCRJV = 1
<operator>.postIncrement j ++
<operator>.division 2 * n / 3
<operator>.multiplication j * n
<operator>.multiplication j * n
<operator>.assignment l = 0
printf printf ( " %d " , LIPEK [ j * n + l ] )
<operator>.subtraction m1 - 2
<operator>.lessEqualsThan v <= u - 1
<operator>.postIncrement v ++
<operator>.lessEqualsThan v <= m1 - 1
<operator>.postIncrement v ++
<operator>.lessEqualsThan v <= m1 - 1
<operator>.postIncrement v ++
<operator>.multiplication 2 * n
<operator>.addition LIPEK [ j * n + ( m1 - 1 ) ] + 2
<operator>.assignment v = 0
<operator>.assignment LIPEK [ ( j + 1 ) * n + v ] = LIPEK [ j * n + v ]
<operator>.subtraction LIPEK [ j * n + u ] - 1
<operator>.assignment v = u + 1
<operator>.assignmentPlus FVUXTMCRJV += LIPEK [ j * n + v ]
<operator>.assignment v = u + 1
<operator>.assignmentMinus FVUXTMCRJV -= LIPEK [ ( j + 1 ) * n + v ]
<operator>.addition j * n + l
<operator>.addition j * n + u
<operator>.subtraction u - 1
<operator>.addition ( j + 1 ) * n + u
<operator>.subtraction m1 - 1
<operator>.subtraction m1 - 1
<operator>.lessEqualsThan LIPEK [ ( j + 1 ) * n + ( v - 1 ) ] + ( m1 - v - 1 ) <= FVUXTMCRJV
<operator>.multiplication j * n
<operator>.addition j * n + l
<operator>.multiplication j * n
<operator>.addition j * n + ( m1 - 1 )
<operator>.multiplication ( j + 1 ) * n
<operator>.addition j * n + u
<operator>.addition u + 1
<operator>.addition u + 1
<operator>.assignment LIPEK [ ( j + 1 ) * n + v ] = LIPEK [ ( j + 1 ) * n + ( v - 1 ) ]
<operator>.multiplication j * n
<operator>.multiplication j * n
<operator>.subtraction m1 - 1
<operator>.addition ( j + 1 ) * n + v
<operator>.addition j * n + v
<operator>.addition j + 1
<operator>.multiplication j * n
<operator>.addition j * n + v
<operator>.addition LIPEK [ ( j + 1 ) * n + ( v - 1 ) ] + ( m1 - v - 1 )
<operator>.assignment LIPEK [ ( j + 1 ) * n + v ] = FVUXTMCRJV - ( m1 - v - 1 )
<operator>.addition ( j + 1 ) * n + v
<operator>.multiplication ( j + 1 ) * n
<operator>.multiplication j * n
<operator>.multiplication j * n
<operator>.subtraction m1 - v - 1
<operator>.multiplication ( j + 1 ) * n
<operator>.addition j + 1
<operator>.addition ( j + 1 ) * n + ( v - 1 )
<operator>.subtraction m1 - v
<operator>.addition ( j + 1 ) * n + v
<operator>.addition ( j + 1 ) * n + ( v - 1 )
<operator>.subtraction FVUXTMCRJV - ( m1 - v - 1 )
<operator>.addition j + 1
<operator>.multiplication ( j + 1 ) * n
<operator>.subtraction v - 1
<operator>.multiplication ( j + 1 ) * n
<operator>.multiplication ( j + 1 ) * n
<operator>.subtraction v - 1
<operator>.addition ( j + 1 ) * n + v
<operator>.subtraction m1 - v - 1
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.multiplication ( j + 1 ) * n
<operator>.subtraction m1 - v
<operator>.addition j + 1
<operator>.indirectIndexAccess LIPEK [ j * n + 0 ]
<operator>.indirectIndexAccess JOD [ j ]
<operator>.indirectIndexAccess LIPEK [ j * n + l ]
<operator>.indirectIndexAccess LIPEK [ j * n + l ]
<operator>.indirectIndexAccess JOD [ j ]
<operator>.indirectIndexAccess JOD [ j ]
<operator>.indirectIndexAccess LIPEK [ j * n + l ]
<operator>.indirectIndexAccess LIPEK [ j * n + u ]
<operator>.indirectIndexAccess LIPEK [ ( j + 1 ) * n + u ]
<operator>.indirectIndexAccess LIPEK [ j * n + l ]
<operator>.indirectIndexAccess LIPEK [ j * n + ( m1 - 1 ) ]
<operator>.indirectIndexAccess LIPEK [ j * n + u ]
<operator>.indirectIndexAccess LIPEK [ ( j + 1 ) * n + v ]
<operator>.indirectIndexAccess LIPEK [ j * n + v ]
<operator>.indirectIndexAccess LIPEK [ j * n + v ]
<operator>.indirectIndexAccess LIPEK [ ( j + 1 ) * n + v ]
<operator>.indirectIndexAccess LIPEK [ ( j + 1 ) * n + ( v - 1 ) ]
<operator>.indirectIndexAccess LIPEK [ ( j + 1 ) * n + v ]
<operator>.indirectIndexAccess LIPEK [ ( j + 1 ) * n + ( v - 1 ) ]
<operator>.indirectIndexAccess LIPEK [ ( j + 1 ) * n + v ]
>>>PDG&178 0->2 0->3 0->4 0->5 0->6 0->7 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->25 0->27 0->28 0->29 0->30 0->31 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->72 0->73 0->74 0->76 0->77 0->78 0->79 0->80 0->81 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->114 0->115 0->117 0->118 0->119 0->120 0->122 0->123 0->124 0->125 0->126 0->127 0->128 0->129 0->132 0->133 0->134 0->135 0->136 0->137 0->138 0->140 0->141 0->143 0->144 0->145 0->146 0->147 0->148 0->149 0->150 0->151 0->152 0->153 0->154 0->155 0->156 0->157 2->1 3->1 4->1 5->55 6->19 7->22 7->61 8->1 8->1 8->44 9->1 9->1 9->15 9->74 9->80 9->89 9->98 9->100 9->101 9->103 9->105 9->112 9->121 9->130 10->1 10->1 10->14 10->65 11->1 11->12 11->68 12->1 12->1 12->13 12->41 13->1 13->1 13->1 14->1 14->1 14->1 15->1 15->1 15->1 16->1 17->1 17->17 17->18 17->18 17->34 17->36 17->45 17->86 18->1 18->17 19->1 19->1 19->27 19->28 19->37 19->37 19->57 19->57 20->1 20->1 20->1 20->20 20->21 20->30 20->31 20->38 20->48 20->49 20->51 20->58 20->59 20->59 20->60 20->61 20->62 20->64 20->68 20->71 20->81 20->90 20->158 20->159 20->162 21->1 21->20 22->1 22->1 22->41 22->52 23->1 24->1 24->9 25->17 26->1 26->10 27->1 27->29 28->1 28->1 28->20 29->1 29->1 29->20 30->1 30->1 30->1 30->15 31->1 31->1 31->14 31->65 32->1 32->8 32->23 33->1 33->24 34->1 34->1 34->1 34->28 34->34 34->35 34->35 34->46 34->68 34->76 34->76 34->86 34->86 34->113 34->160 35->1 35->34 36->1 36->26 37->1 37->1 37->29 38->1 38->1 38->1 38->38 38->39 38->39 38->50 38->60 38->77 38->77 38->87 38->161 39->1 39->38 41->1 41->1 41->13 41->41 41->42 41->53 41->53 41->53 41->54 41->65 41->73 41->163 42->1 42->41 43->1 43->1 43->32 43->32 44->1 44->17 44->28 44->33 44->33 44->34 44->68 44->113 45->1 45->34 46->1 46->1 46->15 46->74 46->89 47->1 48->1 49->1 49->38 50->1 50->1 50->15 50->74 50->89 51->1 51->1 51->14 51->65 52->1 52->41 53->1 53->41 53->42 53->113 54->1 55->43 55->43 55->97 56->1 56->43 57->1 57->20 57->37 58->1 59->1 59->30 59->30 59->48 59->48 59->60 59->68 59->87 59->113 59->115 59->117 59->122 59->133 60->21 60->31 60->38 60->38 60->51 60->78 60->90 61->1 61->22 61->69 61->70 61->78 61->88 62->1 62->63 62->64 62->80 62->98 62->107 62->107 62->115 62->116 62->123 62->124 62->165 62->168 63->1 63->62 64->1 64->1 64->1 64->51 64->61 64->62 64->64 64->71 64->72 64->81 64->82 64->83 64->84 64->90 64->91 64->93 64->95 64->99 64->101 64->102 64->104 64->108 64->108 64->109 64->110 64->111 64->117 64->118 64->119 64->120 64->127 64->128 64->162 64->166 64->169 65->1 65->1 65->1 65->14 65->65 65->66 65->66 65->74 65->106 65->106 65->113 65->163 65->164 66->1 66->65 67->1 67->56 67->56 68->12 68->58 68->58 68->59 68->69 68->72 68->87 68->115 68->117 68->127 68->128 68->133 68->134 68->138 69->1 69->72 69->115 69->117 69->122 69->127 69->128 69->133 69->134 69->138 70->1 71->1 71->1 71->62 72->1 72->12 72->68 73->1 73->65 74->1 74->1 74->15 75->1 75->67 76->1 77->1 78->1 78->1 78->51 78->78 78->79 78->79 78->89 78->90 78->114 78->114 78->122 78->167 79->1 79->78 80->1 80->1 80->1 80->15 80->62 80->63 80->101 81->64 82->1 82->1 82->1 82->15 83->1 83->1 83->103 83->112 84->1 84->12 84->68 84->69 84->72 84->115 84->117 84->127 84->128 84->133 84->134 84->138 85->1 85->75 85->75 86->18 86->34 86->76 86->76 87->1 87->12 87->68 87->68 87->69 87->72 87->77 87->77 87->113 87->115 87->115 87->117 87->117 87->122 87->127 87->128 87->133 87->133 87->134 87->138 88->1 88->78 89->1 89->1 89->15 89->74 90->21 90->71 90->71 90->110 90->124 91->1 91->1 91->91 91->92 91->92 91->100 91->108 91->125 91->125 91->126 91->126 91->133 91->134 91->138 91->170 91->171 92->1 92->91 93->93 93->94 93->94 93->103 93->110 93->129 93->129 93->135 93->172 94->1 94->93 95->1 95->1 95->1 95->95 95->96 95->105 95->111 95->112 95->130 95->132 95->136 95->137 95->139 95->140 95->144 95->145 95->146 95->146 95->152 95->173 95->174 96->1 96->95 97->44 97->85 97->85 98->1 99->1 99->91 100->1 100->1 100->1 100->15 101->1 101->15 101->80 101->82 101->82 102->93 103->1 103->1 103->1 103->112 104->1 104->1 104->95 105->1 105->1 105->1 105->112 106->1 108->91 108->91 108->102 108->104 108->109 108->118 108->119 108->120 109->1 110->93 110->93 110->111 111->21 111->51 111->78 111->90 111->95 111->95 111->140 112->1 112->1 112->105 112->121 112->131 112->141 112->142 112->143 112->143 112->147 112->148 112->149 112->150 112->151 112->153 112->154 112->155 112->156 112->157 112->175 112->176 112->177 113->1 113->42 113->106 113->106 114->1 115->107 115->107 115->123 115->123 116->1 116->1 117->1 117->109 117->109 117->128 118->1 120->1 121->1 121->1 121->15 121->105 122->1 122->68 122->72 122->113 122->114 122->114 122->115 122->115 122->117 122->117 122->127 122->128 122->133 122->133 122->134 122->138 123->1 123->68 123->72 123->113 123->115 123->115 123->116 123->116 123->117 123->117 123->127 123->128 123->133 123->133 123->134 123->138 124->21 124->110 124->116 124->116 128->1 128->68 128->84 128->113 128->115 128->117 128->118 128->118 128->122 128->133 128->135 128->135 128->137 128->144 128->145 128->145 128->147 128->148 128->152 128->153 128->154 128->155 128->157 129->1 130->1 130->1 131->1 131->1 131->15 131->105 132->1 133->125 133->125 133->134 134->117 134->117 134->126 134->126 134->127 134->128 134->133 134->133 134->138 135->1 135->68 135->84 135->113 135->115 135->117 135->122 135->129 135->129 135->133 135->137 135->144 135->145 135->145 135->147 135->148 135->152 135->153 135->154 135->155 135->157 136->1 136->112 136->112 136->130 136->130 137->1 137->1 137->68 137->113 137->115 137->117 137->122 137->132 137->132 137->133 137->145 139->1 140->111 140->136 140->136 140->141 140->149 140->150 140->156 140->156 142->1 143->1 143->105 143->131 143->131 145->139 145->139 145->147 145->155 146->139 146->139 146->140 147->141 147->141 147->148 148->137 148->142 148->142 149->96 149->132 149->142 149->142 151->1 151->143 151->143 155->137 155->150 155->150 156->96 156->111 156->132 156->151 156->151
>>>Token void KNXREISDLOAHQM ( long * TOYGRHBNYOGQRIHXYU , int * * LYMRJHV , int * * UXXDOLYEKIXRLLSAR , int n , int m , int KSCRQDOECBVL ) { int l , u , v , m1 ; long LTIJSNYEPFQXDK , j ; int * JOD , * LIPEK ; int KWPYB , RBAFM ; long VPXOEWUTCNTFXFVCQE = ( int ) TVQE ( ( 0.2f / n ) * UGE ( 3.142f * WAHY ( 2 * n / 3 ) ) ) ; int FVUXTMCRJV ; LIPEK = malloc ( VPXOEWUTCNTFXFVCQE * n * sizeof ( int ) ) ; for ( j = 0 ; j < VPXOEWUTCNTFXFVCQE ; j ++ ) { for ( l = 0 ; l < n ; l ++ ) { LIPEK [ j * n + l ] = 0 ; } } JOD = malloc ( VPXOEWUTCNTFXFVCQE * sizeof ( int ) ) ; if ( m == 0 ) { KWPYB = 1 ; RBAFM = n ; } else { KWPYB = RBAFM = m ; } j = 0 ; for ( m1 = KWPYB ; m1 <= RBAFM ; m1 ++ ) { LIPEK [ j * n + 0 ] = n - m1 + 1 ; for ( l = 1 ; l <= m1 - 1 ; l ++ ) { LIPEK [ j * n + l ] = 1 ; } JOD [ j ] = m1 ; while ( 1 ) { if ( KSCRQDOECBVL >= 3 ) { printf ( " " , j ) ; for ( l = 0 ; l < m1 ; l ++ ) { printf ( " " , LIPEK [ j * n + l ] ) ; } printf ( " \n " ) ; } JOD [ j ] = m1 ; for ( u = m1 - 2 ; u >= 0 ; u -- ) { if ( LIPEK [ j * n + u ] >= LIPEK [ j * n + ( m1 - 1 ) ] + 2 ) { break ; } } if ( u == - 1 ) { j ++ ; break ; } else { for ( v = 0 ; v <= u - 1 ; v ++ ) { LIPEK [ ( j + 1 ) * n + v ] = LIPEK [ j * n + v ] ; } LIPEK [ ( j + 1 ) * n + u ] = LIPEK [ j * n + u ] - 1 ; FVUXTMCRJV = 1 ; for ( v = u + 1 ; v <= m1 - 1 ; v ++ ) { FVUXTMCRJV += LIPEK [ j * n + v ] ; } for ( v = u + 1 ; v <= m1 - 1 ; v ++ ) { if ( LIPEK [ ( j + 1 ) * n + ( v - 1 ) ] + ( m1 - v - 1 ) <= FVUXTMCRJV ) { LIPEK [ ( j + 1 ) * n + v ] = LIPEK [ ( j + 1 ) * n + ( v - 1 ) ] ; } else { LIPEK [ ( j + 1 ) * n + v ] = FVUXTMCRJV - ( m1 - v - 1 ) ; } FVUXTMCRJV -= LIPEK [ ( j + 1 ) * n + v ] ; } j ++ ; } } } LTIJSNYEPFQXDK = j ; if ( KSCRQDOECBVL >= 2 ) { for ( j = 0 ; j < LTIJSNYEPFQXDK ; j ++ ) { printf ( " " , j , LTIJSNYEPFQXDK ) ; for ( l = 0 ; l < JOD [ j ] ; l ++ ) { printf ( " " , LIPEK [ j * n + l ] ) ; } printf ( " \n " ) ; } } * TOYGRHBNYOGQRIHXYU = LTIJSNYEPFQXDK ; * LYMRJHV = JOD ; * UXXDOLYEKIXRLLSAR = LIPEK ; return ; }
>>>Func
METHOD LKINWPLYEAVJW
METHOD_RETURN int
PARAM struct IIBFUHSM const * a
PARAM struct IIBFUHSM const * b
PARAM int ( * FGR ) ( char const * , char const * )
<operator>.assignment * AGPUY = BEMOOAL ( a -> GLKM , '.' )
<operator>.assignment * NGXMO = BEMOOAL ( b -> GLKM , '.' )
<operator>.assignment HNVE = FGR ( AGPUY ? AGPUY : "" , NGXMO ? NGXMO : "" )
RETURN return HNVE ? HNVE : FGR ( a -> GLKM , b -> GLKM ) ; return HNVE ? HNVE : FGR ( a -> GLKM , b -> GLKM ) ;
<operator>.conditional HNVE ? HNVE : FGR ( a -> GLKM , b -> GLKM )
BEMOOAL BEMOOAL ( a -> GLKM , '.' )
BEMOOAL BEMOOAL ( b -> GLKM , '.' )
FGR FGR ( AGPUY ? AGPUY : "" , NGXMO ? NGXMO : "" )
<operator>.conditional AGPUY ? AGPUY : ""
<operator>.conditional NGXMO ? NGXMO : ""
FGR FGR ( a -> GLKM , b -> GLKM )
>>>PDG&16 0->2 0->3 0->4 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 4->1 5->1 5->1 5->12 5->13 6->1 6->1 6->12 6->14 7->1 7->1 7->9 8->1 9->1 9->1 9->1 9->8 10->1 10->5 10->5 10->15 11->1 11->6 11->6 11->15 12->1 12->1 12->7 12->7 13->1 14->1 15->1 15->1 15->9 15->9
>>>Token static int LKINWPLYEAVJW ( struct IIBFUHSM const * a , struct IIBFUHSM const * b , int ( * FGR ) ( char const * , char const * ) ) { char const * AGPUY = BEMOOAL ( a -> GLKM , ' ' ) ; char const * NGXMO = BEMOOAL ( b -> GLKM , ' ' ) ; int HNVE = FGR ( AGPUY ? AGPUY : " " , NGXMO ? NGXMO : " " ) ; return HNVE ? HNVE : FGR ( a -> GLKM , b -> GLKM ) ; }
>>>Func
METHOD AKPFSO
METHOD_RETURN int
PARAM int MIYQBHNBU
PARAM char FUUTSWU
<operator>.assignment FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . DMDGEPXPQBRI [ FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . EASWFMTGHTQQA ] = FUUTSWU
<operator>.postIncrement FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . EASWFMTGHTQQA ++
RETURN return 0 ; return 0 ;
<operator>.lessThan i < FFCJOTNLONWESPV [ MIYQBHNBU ] . HAWAE . GNFBVAVRSUMAA
<operator>.postIncrement i ++
<operator>.equals SERUBSYHIE ( MIYQBHNBU , FUUTSWU ) == 0
LITERAL 0 return 0 ;
<operator>.assignment i = 0
RETURN return 0 ; return 0 ;
<operator>.equals OLPLBBAOAGK ( MIYQBHNBU , i , FUUTSWU ) == 0
SERUBSYHIE SERUBSYHIE ( MIYQBHNBU , FUUTSWU )
LITERAL 0 return 0 ;
RETURN return 0 ; return 0 ;
OLPLBBAOAGK OLPLBBAOAGK ( MIYQBHNBU , i , FUUTSWU )
LITERAL 0 return 0 ;
<operator>.indirectIndexAccess FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . DMDGEPXPQBRI [ FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . EASWFMTGHTQQA ]
<operator>.fieldAccess FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . EASWFMTGHTQQA
<operator>.fieldAccess FFCJOTNLONWESPV [ MIYQBHNBU ] . HAWAE . GNFBVAVRSUMAA
<operator>.fieldAccess FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . DMDGEPXPQBRI
<operator>.fieldAccess FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . EASWFMTGHTQQA
<operator>.fieldAccess FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB
FIELD_IDENTIFIER EASWFMTGHTQQA EASWFMTGHTQQA
<operator>.fieldAccess FFCJOTNLONWESPV [ MIYQBHNBU ] . HAWAE
FIELD_IDENTIFIER GNFBVAVRSUMAA GNFBVAVRSUMAA
<operator>.fieldAccess FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB
FIELD_IDENTIFIER DMDGEPXPQBRI DMDGEPXPQBRI
<operator>.fieldAccess FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB
FIELD_IDENTIFIER EASWFMTGHTQQA EASWFMTGHTQQA
<operator>.indirectIndexAccess FFCJOTNLONWESPV [ MIYQBHNBU ]
FIELD_IDENTIFIER KGGIXB KGGIXB
<operator>.indirectIndexAccess FFCJOTNLONWESPV [ MIYQBHNBU ]
FIELD_IDENTIFIER HAWAE HAWAE
<operator>.indirectIndexAccess FFCJOTNLONWESPV [ MIYQBHNBU ]
FIELD_IDENTIFIER KGGIXB KGGIXB
<operator>.indirectIndexAccess FFCJOTNLONWESPV [ MIYQBHNBU ]
FIELD_IDENTIFIER KGGIXB KGGIXB
>>>PDG&40 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 2->14 2->17 3->14 3->17 6->1 7->1 7->9 7->13 7->14 7->17 7->17 8->1 8->7 9->4 9->5 9->6 9->12 9->19 9->20 9->22 9->23 9->24 9->25 9->28 9->29 9->30 9->31 9->32 9->33 9->36 9->37 9->38 9->39 10->6 11->1 11->7 12->1 13->1 13->1 13->7 13->8 13->16 13->21 13->26 13->27 13->34 13->35 14->4 14->9 14->9 15->12 16->1 17->1 17->1 17->1 17->8 17->13 17->13 17->13 17->14 17->14 18->16
>>>Token int AKPFSO ( int MIYQBHNBU , char FUUTSWU ) { int i ; for ( i = 0 ; i < FFCJOTNLONWESPV [ MIYQBHNBU ] . HAWAE . GNFBVAVRSUMAA ; i ++ ) { if ( OLPLBBAOAGK ( MIYQBHNBU , i , FUUTSWU ) == 0 ) { return 0 ; } } if ( SERUBSYHIE ( MIYQBHNBU , FUUTSWU ) == 0 ) { return 0 ; } FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . DMDGEPXPQBRI [ FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . EASWFMTGHTQQA ] = FUUTSWU ; FFCJOTNLONWESPV [ MIYQBHNBU ] . KGGIXB . EASWFMTGHTQQA ++ ; return 0 ; }
>>>Func
METHOD EOFXUTWHNSSVGLXKENLCNFORJEVBWHCEX
METHOD_RETURN void
PARAM struct KCSECDTWVPFHPQNDEQ * SJHL
PARAM char vv
PARAM struct VLHWKQCQPMT * KSXNOUJEA
assert assert ( SJHL != NULL )
assert assert ( KSXNOUJEA != NULL )
<operator>.assignment * IHFYPRLKFWE = PTJMXHAIQAEYEX ( vv )
<operator>.postIncrement SJHL -> AULUNFGWNH [ WCWSMRSB ( vv ) ] ++
<operator>.notEquals SJHL -> TWSHCYAVJ != NULL
IMKQUHEFWLAYYSFE SJHL -> IMKQUHEFWLAYYSFE ( SJHL , vv , KSXNOUJEA )
<operator>.equals SJHL -> OFUA == NULL
<operator>.notEquals SJHL != NULL
<operator>.notEquals KSXNOUJEA != NULL
<operator>.assignment aa = WCWSMRSB ( vv )
<operator>.assignment bb = WCWSMRSB ( SJHL -> TWSHCYAVJ -> GNMNQIKJS )
GUXST SJHL -> GUXST ( SJHL )
RETURN return ; return ;
PTJMXHAIQAEYEX PTJMXHAIQAEYEX ( vv )
assert assert ( SJHL -> AWPU == NULL )
assert assert ( SJHL -> MRGFLPRJYTS == NULL )
<operator>.assignment SJHL -> TWSHCYAVJ = SJHL -> AWPU = SJHL -> OFUA = IHFYPRLKFWE
<operator>.notEquals KSXNOUJEA -> MJSKUDTEXNKGAT [ aa ] [ bb ] != '-'
<operator>.assignment SJHL -> MRGFLPRJYTS = SJHL -> OFUA
<operator>.assignment SJHL -> TWSHCYAVJ = SJHL -> OFUA = SJHL -> OFUA -> PVWO = IHFYPRLKFWE
WCWSMRSB WCWSMRSB ( vv )
WCWSMRSB WCWSMRSB ( vv )
WCWSMRSB WCWSMRSB ( SJHL -> TWSHCYAVJ -> GNMNQIKJS )
<operator>.assignment * IHFYPRLKFWE = PTJMXHAIQAEYEX ( KSXNOUJEA -> MJSKUDTEXNKGAT [ aa ] [ bb ] )
<operator>.postDecrement SJHL -> AULUNFGWNH [ bb ] --
<operator>.assignment SJHL -> OFUA = IHFYPRLKFWE
<operator>.assignment SJHL -> TWSHCYAVJ = NULL
RETURN return ; return ;
<operator>.equals SJHL -> AWPU == NULL
<operator>.equals SJHL -> MRGFLPRJYTS == NULL
<operator>.assignment SJHL -> AWPU = SJHL -> OFUA = IHFYPRLKFWE
<operator>.notEquals SJHL -> MRGFLPRJYTS != NULL
<operator>.assignment SJHL -> OFUA = IHFYPRLKFWE
<operator>.assignment SJHL -> OFUA = SJHL -> OFUA -> PVWO = IHFYPRLKFWE
PTJMXHAIQAEYEX PTJMXHAIQAEYEX ( KSXNOUJEA -> MJSKUDTEXNKGAT [ aa ] [ bb ] )
<operator>.assignment SJHL -> MRGFLPRJYTS -> PVWO = IHFYPRLKFWE
<operator>.assignment SJHL -> OFUA -> PVWO = IHFYPRLKFWE
<operator>.assignment SJHL -> AWPU = IHFYPRLKFWE
<operator>.indirectIndexAccess SJHL -> AULUNFGWNH [ WCWSMRSB ( vv ) ]
<operator>.indirectFieldAccess SJHL -> IMKQUHEFWLAYYSFE
<operator>.indirectFieldAccess SJHL -> OFUA
<operator>.indirectFieldAccess SJHL -> AULUNFGWNH
FIELD_IDENTIFIER IMKQUHEFWLAYYSFE IMKQUHEFWLAYYSFE
<operator>.indirectFieldAccess SJHL -> GUXST
FIELD_IDENTIFIER OFUA OFUA
<operator>.indirectFieldAccess SJHL -> TWSHCYAVJ
FIELD_IDENTIFIER AULUNFGWNH AULUNFGWNH
<operator>.indirectFieldAccess SJHL -> TWSHCYAVJ -> GNMNQIKJS
<operator>.indirectIndexAccess KSXNOUJEA -> MJSKUDTEXNKGAT [ aa ] [ bb ]
FIELD_IDENTIFIER GUXST GUXST
<operator>.indirectFieldAccess SJHL -> AWPU
<operator>.indirectFieldAccess SJHL -> MRGFLPRJYTS
FIELD_IDENTIFIER TWSHCYAVJ TWSHCYAVJ
<operator>.indirectFieldAccess SJHL -> AWPU
<operator>.indirectFieldAccess SJHL -> MRGFLPRJYTS
<operator>.indirectFieldAccess SJHL -> OFUA
<operator>.indirectFieldAccess SJHL -> TWSHCYAVJ
<operator>.indirectFieldAccess SJHL -> TWSHCYAVJ
FIELD_IDENTIFIER GNMNQIKJS GNMNQIKJS
<operator>.indirectIndexAccess KSXNOUJEA -> MJSKUDTEXNKGAT [ aa ]
<operator>.indirectIndexAccess SJHL -> AULUNFGWNH [ bb ]
<operator>.indirectFieldAccess SJHL -> OFUA
<operator>.indirectFieldAccess SJHL -> TWSHCYAVJ
FIELD_IDENTIFIER AWPU AWPU
FIELD_IDENTIFIER MRGFLPRJYTS MRGFLPRJYTS
FIELD_IDENTIFIER AWPU AWPU
<operator>.indirectFieldAccess SJHL -> OFUA
FIELD_IDENTIFIER MRGFLPRJYTS MRGFLPRJYTS
FIELD_IDENTIFIER OFUA OFUA
FIELD_IDENTIFIER TWSHCYAVJ TWSHCYAVJ
<operator>.indirectFieldAccess SJHL -> OFUA
FIELD_IDENTIFIER TWSHCYAVJ TWSHCYAVJ
<operator>.indirectFieldAccess KSXNOUJEA -> MJSKUDTEXNKGAT
<operator>.indirectIndexAccess KSXNOUJEA -> MJSKUDTEXNKGAT [ aa ] [ bb ]
<operator>.indirectFieldAccess SJHL -> AULUNFGWNH
FIELD_IDENTIFIER OFUA OFUA
FIELD_IDENTIFIER TWSHCYAVJ TWSHCYAVJ
<operator>.indirectFieldAccess SJHL -> MRGFLPRJYTS
FIELD_IDENTIFIER OFUA OFUA
FIELD_IDENTIFIER OFUA OFUA
<operator>.indirectFieldAccess SJHL -> OFUA -> PVWO
FIELD_IDENTIFIER MJSKUDTEXNKGAT MJSKUDTEXNKGAT
<operator>.indirectIndexAccess KSXNOUJEA -> MJSKUDTEXNKGAT [ aa ]
FIELD_IDENTIFIER AULUNFGWNH AULUNFGWNH
FIELD_IDENTIFIER MRGFLPRJYTS MRGFLPRJYTS
<operator>.indirectFieldAccess SJHL -> MRGFLPRJYTS -> PVWO
<operator>.indirectFieldAccess SJHL -> OFUA
FIELD_IDENTIFIER PVWO PVWO
<operator>.indirectFieldAccess KSXNOUJEA -> MJSKUDTEXNKGAT
<operator>.indirectFieldAccess SJHL -> MRGFLPRJYTS
FIELD_IDENTIFIER PVWO PVWO
<operator>.indirectFieldAccess SJHL -> AWPU
FIELD_IDENTIFIER OFUA OFUA
FIELD_IDENTIFIER MJSKUDTEXNKGAT MJSKUDTEXNKGAT
FIELD_IDENTIFIER MRGFLPRJYTS MRGFLPRJYTS
FIELD_IDENTIFIER AWPU AWPU
>>>PDG&101 0->2 0->3 0->4 0->9 0->10 0->11 0->12 0->13 0->16 0->17 0->18 0->21 0->22 0->24 0->25 0->26 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->42 2->12 3->10 3->26 4->13 5->1 5->1 6->1 6->1 7->21 7->24 7->35 7->37 7->38 7->41 9->1 9->10 9->11 9->14 9->15 9->22 9->26 9->27 9->31 9->36 9->44 9->47 9->52 9->53 9->62 9->63 9->64 9->76 9->77 9->86 10->7 10->8 10->11 10->16 10->16 10->17 10->18 10->18 10->25 10->43 10->45 10->46 10->48 10->49 10->51 10->54 11->19 11->20 11->21 11->23 11->23 11->24 11->33 11->33 11->34 11->35 11->37 11->38 11->41 11->50 11->55 11->56 11->57 11->58 11->59 11->60 11->61 11->68 11->69 11->70 11->71 11->72 11->73 11->74 11->75 11->83 11->84 11->85 11->91 11->92 11->97 12->1 12->5 12->5 12->10 12->13 13->1 13->6 13->6 13->9 13->10 14->1 14->1 14->1 15->1 15->1 15->1 17->1 18->7 18->25 22->1 22->10 22->28 22->29 22->30 22->31 22->32 22->36 22->39 22->39 22->44 22->47 22->65 22->66 22->67 22->78 22->79 22->80 22->81 22->82 22->87 22->88 22->89 22->93 22->98 26->1 26->10 26->14 27->1 27->15 28->1 28->1 28->30 28->40 28->42 29->1 29->1 30->1 30->1 31->1 31->1 32->1 33->19 33->19 33->34 34->20 34->20 35->21 36->1 36->1 36->1 36->40 36->42 36->90 36->94 36->95 36->96 36->99 36->100 37->21 37->35 38->24 39->1 39->28 40->1 40->1 40->1 41->24 41->38 42->1 42->1 42->1
>>>Token static void EOFXUTWHNSSVGLXKENLCNFORJEVBWHCEX ( struct KCSECDTWVPFHPQNDEQ * SJHL , char vv , struct VLHWKQCQPMT * KSXNOUJEA ) { assert ( SJHL != NULL ) ; assert ( KSXNOUJEA != NULL ) ; if ( SJHL -> TWSHCYAVJ != NULL ) { const HJHUSGGKI aa = WCWSMRSB ( vv ) ; const HJHUSGGKI bb = WCWSMRSB ( SJHL -> TWSHCYAVJ -> GNMNQIKJS ) ; if ( KSXNOUJEA -> MJSKUDTEXNKGAT [ aa ] [ bb ] != ' ' ) { struct GCSBOLURR * IHFYPRLKFWE = PTJMXHAIQAEYEX ( KSXNOUJEA -> MJSKUDTEXNKGAT [ aa ] [ bb ] ) ; SJHL -> AULUNFGWNH [ bb ] -- ; SJHL -> OFUA = IHFYPRLKFWE ; SJHL -> TWSHCYAVJ = NULL ; if ( SJHL -> MRGFLPRJYTS != NULL ) { SJHL -> MRGFLPRJYTS -> PVWO = IHFYPRLKFWE ; } else { SJHL -> AWPU = IHFYPRLKFWE ; } return ; } } if ( SJHL -> IMKQUHEFWLAYYSFE ( SJHL , vv , KSXNOUJEA ) ) { SJHL -> GUXST ( SJHL ) ; return ; } struct GCSBOLURR * IHFYPRLKFWE = PTJMXHAIQAEYEX ( vv ) ; if ( SJHL -> OFUA == NULL ) { assert ( SJHL -> AWPU == NULL ) ; assert ( SJHL -> MRGFLPRJYTS == NULL ) ; SJHL -> TWSHCYAVJ = SJHL -> AWPU = SJHL -> OFUA = IHFYPRLKFWE ; } else { SJHL -> MRGFLPRJYTS = SJHL -> OFUA ; SJHL -> TWSHCYAVJ = SJHL -> OFUA = SJHL -> OFUA -> PVWO = IHFYPRLKFWE ; } SJHL -> AULUNFGWNH [ WCWSMRSB ( vv ) ] ++ ; }
>>>Func
METHOD XRTIDHX
METHOD_RETURN int
PARAM const void * KTQHY
PARAM const void * GGUBYX
RETURN return - * ( int * ) KTQHY + * ( int * ) GGUBYX ; return - * ( int * ) KTQHY + * ( int * ) GGUBYX ;
<operator>.addition - * ( int * ) KTQHY + * ( int * ) GGUBYX
<operator>.minus - * ( int * ) KTQHY
<operator>.cast ( int * ) GGUBYX
<operator>.cast ( int * ) KTQHY
>>>PDG&9 0->2 0->3 0->7 0->8 2->8 3->7 4->1 5->1 5->1 5->1 5->4 6->1 6->5 7->1 8->1
>>>Token int XRTIDHX ( const void * KTQHY , const void * GGUBYX ) { return - * ( int * ) KTQHY + * ( int * ) GGUBYX ; }
>>>Func
METHOD FNX
METHOD_RETURN void
PARAM char FFYS [ 100 ] [ 101 ]
PARAM int n
<operator>.notEquals i != n
<operator>.preIncrement ++ i
<operator>.assignment i = 0
YULLJYTE YULLJYTE ( FFYS , n , i )
printf printf ( "\n" )
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 2->7 3->4 4->1 4->1 4->1 4->4 4->5 4->7 4->7 4->7 4->8 5->1 5->4 6->1 6->4 7->4 7->5
>>>Token void FNX ( char FFYS [ 100 ] [ 101 ] , int n ) { for ( int i = 0 ; i != n ; ++ i ) { YULLJYTE ( FFYS , n , i ) ; printf ( " \n " ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
YNFYI YNFYI ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= T
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 1
printf printf ( "Case #%d: [" , t )
memset memset ( qq   0   sizeof ( qq ) )
YNFYI YNFYI ( "%d" , & C )
<operator>.assignment di = 0
YNFYI YNFYI ( "%d" , & D )
<operator>.assignment cc [ 0 ] = 0
<operator>.assignment ri = 0
<operator>.assignment b = - 1
YNFYI YNFYI ( "%d %s" , & N , s )
printf printf ( "]\n" )
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < ri
<operator>.postIncrement j ++
<operator>.assignment i = 0
<operator>.assignment e = YNFYI ( "%3s" , s )
assert assert ( e == 1 )
<operator>.assignment a = XCOXVCGEN ( s [ 0 ] )
<operator>.assignment b = XCOXVCGEN ( s [ 1 ] )
<operator>.assignment c = XCOXVCGEN ( s [ 2 ] )
assert assert ( a >= 0 )
assert assert ( b >= 0 )
assert assert ( c < 0 )
assert assert ( qq [ a ] [ b ] == 0 )
assert assert ( qq [ b ] [ a ] == 0 )
<operator>.assignment qq [ a ] [ b ] = s [ 2 ]
<operator>.assignment qq [ b ] [ a ] = s [ 2 ]
<operator>.assignment i = 0
<operator>.assignment e = YNFYI ( "%2s" , s )
assert assert ( e == 1 )
<operator>.assignment a = XCOXVCGEN ( s [ 0 ] )
<operator>.assignment b = XCOXVCGEN ( s [ 1 ] )
assert assert ( a >= 0 )
assert assert ( b >= 0 )
assert assert ( a != b )
<operator>.assignment dd [ di ] = ( 1 << a ) | ( 1 << b )
<operator>.postIncrement di ++
<operator>.minus - 1
<operator>.assignment j = 0
<operator>.assignment a = XCOXVCGEN ( s [ j ] )
assert assert ( a >= 0 )
<operator>.assignment rr [ ri ] = s [ j ]
<operator>.postIncrement ri ++
<operator>.assignment b = a
<operator>.assignment cc [ ri ] = cc [ ri - 1 ] | ( 1 << a )
<operator>.assignment j = 0
printf printf ( "%c" , rr [ j ] )
<operator>.logicalAnd b >= 0 && qq [ a ] [ b ] != 0
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.greaterThan j > 0
YNFYI YNFYI ( "%3s" , s )
<operator>.equals e == 1
XCOXVCGEN XCOXVCGEN ( s [ 0 ] )
XCOXVCGEN XCOXVCGEN ( s [ 1 ] )
XCOXVCGEN XCOXVCGEN ( s [ 2 ] )
<operator>.greaterEqualsThan a >= 0
<operator>.greaterEqualsThan b >= 0
<operator>.lessThan c < 0
<operator>.equals qq [ a ] [ b ] == 0
<operator>.equals qq [ b ] [ a ] == 0
YNFYI YNFYI ( "%2s" , s )
<operator>.equals e == 1
XCOXVCGEN XCOXVCGEN ( s [ 0 ] )
XCOXVCGEN XCOXVCGEN ( s [ 1 ] )
<operator>.greaterEqualsThan a >= 0
<operator>.greaterEqualsThan b >= 0
<operator>.notEquals a != b
<operator>.or ( 1 << a ) | ( 1 << b )
XCOXVCGEN XCOXVCGEN ( s [ j ] )
<operator>.greaterEqualsThan a >= 0
<operator>.assignment rr [ ri - 1 ] = qq [ a ] [ b ]
<operator>.assignment b = - 1
<operator>.assignment cc [ ri ] = cc [ ri - 1 ]
<operator>.or cc [ ri - 1 ] | ( 1 << a )
<operator>.assignment i = 0
assert assert ( dd [ i ] != 0 )
YEJKP YEJKP ( ", " , DBUICR )
<operator>.shiftLeft 1 << a
<operator>.shiftLeft 1 << b
<operator>.greaterEqualsThan b >= 0
<operator>.notEquals qq [ a ] [ b ] != 0
<operator>.shiftLeft 1 << a
<operator>.equals ( cc [ ri ] & dd [ i ] ) == dd [ i ]
<operator>.minus - 1
<operator>.subtraction ri - 1
<operator>.notEquals dd [ i ] != 0
<operator>.assignment ri = 0
<operator>.assignment b = - 1
<operator>.subtraction ri - 1
<operator>.subtraction ri - 1
<operator>.and cc [ ri ] & dd [ i ]
<operator>.minus - 1
<operator>.sizeOf sizeof ( qq )
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.indirectIndexAccess cc [ 0 ]
<operator>.addressOf & N
<operator>.indirectIndexAccess qq [ a ] [ b ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess qq [ b ] [ a ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess dd [ di ]
<operator>.indirectIndexAccess rr [ ri ]
<operator>.indirectIndexAccess s [ j ]
<operator>.indirectIndexAccess cc [ ri ]
<operator>.indirectIndexAccess rr [ j ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess qq [ a ] [ b ]
<operator>.indirectIndexAccess qq [ b ] [ a ]
<operator>.indirectIndexAccess qq [ a ]
<operator>.indirectIndexAccess qq [ b ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess s [ j ]
<operator>.indirectIndexAccess cc [ ri - 1 ]
<operator>.indirectIndexAccess qq [ a ]
<operator>.indirectIndexAccess qq [ b ]
<operator>.indirectIndexAccess qq [ a ] [ b ]
<operator>.indirectIndexAccess rr [ ri - 1 ]
<operator>.indirectIndexAccess qq [ a ] [ b ]
<operator>.indirectIndexAccess cc [ ri ]
<operator>.indirectIndexAccess cc [ ri - 1 ]
<operator>.indirectIndexAccess qq [ a ]
<operator>.indirectIndexAccess qq [ a ]
<operator>.indirectIndexAccess dd [ i ]
<operator>.indirectIndexAccess dd [ i ]
<operator>.indirectIndexAccess cc [ ri ]
<operator>.indirectIndexAccess dd [ i ]
>>>PDG&143 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->39 0->48 0->49 0->50 0->54 0->55 0->57 0->58 0->60 0->61 0->62 0->63 0->64 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->77 0->78 0->79 0->82 0->87 0->89 0->90 0->91 0->92 0->93 0->94 0->96 0->97 0->98 0->99 0->101 0->102 0->104 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->18 4->20 4->22 4->24 4->26 4->39 4->49 4->50 4->57 4->105 4->106 4->107 4->108 4->109 5->1 5->4 6->3 7->1 7->4 8->1 8->5 9->1 9->1 10->1 10->1 10->18 11->1 11->1 11->48 12->1 12->1 12->20 12->60 13->1 13->1 14->1 14->24 14->54 14->101 15->1 15->1 15->1 15->92 16->1 16->1 16->1 16->22 16->53 16->63 16->73 16->81 17->1 18->1 18->1 18->10 18->18 18->19 18->19 18->27 18->28 18->29 18->30 18->31 18->32 18->33 18->34 18->35 18->36 18->37 18->38 18->63 18->64 18->65 18->66 18->67 18->68 18->69 18->70 18->71 18->72 18->110 18->111 18->112 18->113 18->119 18->120 18->121 18->122 18->123 18->124 18->125 18->130 18->131 19->1 19->18 20->1 20->1 20->1 20->12 20->20 20->21 20->21 20->40 20->41 20->42 20->43 20->44 20->45 20->46 20->47 20->48 20->60 20->73 20->74 20->75 20->76 20->77 20->78 20->79 20->80 20->90 20->91 20->114 20->126 20->127 21->1 21->20 22->1 22->1 22->16 22->22 22->23 22->23 22->51 22->52 22->59 22->81 22->82 22->92 22->128 23->1 23->22 24->1 24->1 24->1 24->24 24->25 24->58 24->62 24->62 24->118 25->1 25->24 26->18 27->1 27->1 27->64 28->1 28->1 29->1 29->1 29->68 30->1 30->1 30->69 31->1 31->1 31->70 32->1 32->1 33->1 33->1 34->1 34->1 35->1 35->1 36->1 36->1 37->1 37->1 37->71 37->83 37->93 38->1 38->1 38->1 38->72 39->1 39->20 40->1 40->1 40->74 41->1 41->1 42->1 42->1 42->77 43->1 43->1 43->78 44->1 44->1 45->1 45->1 46->1 46->1 47->1 47->1 47->1 48->1 48->1 49->15 50->22 51->1 51->1 51->82 52->1 52->1 53->1 53->1 53->1 54->1 54->97 55->1 55->1 55->92 56->1 56->1 56->1 56->103 57->1 57->24 58->1 58->1 59->1 59->1 59->1 59->53 59->54 59->55 59->56 59->60 59->83 59->84 59->85 59->86 59->87 59->94 59->96 59->97 59->101 59->102 59->115 59->116 59->117 59->129 59->133 59->134 59->135 59->136 59->138 60->1 60->1 60->1 60->12 60->20 60->61 60->88 60->95 60->98 60->103 60->139 60->140 60->141 60->142 61->1 61->60 62->1 62->25 62->89 63->16 63->27 63->27 63->37 63->38 63->65 63->66 63->67 63->73 64->1 64->28 64->28 65->1 65->16 65->29 65->63 65->73 65->75 66->1 66->16 66->30 66->63 66->73 66->76 67->16 67->31 67->37 67->38 67->63 67->73 68->1 68->32 68->32 69->33 69->33 70->1 70->34 70->34 71->35 71->35 72->36 72->36 73->16 73->40 73->40 73->75 73->76 74->1 74->41 74->41 75->1 75->16 75->42 75->63 75->65 75->73 76->1 76->16 76->43 76->63 76->66 76->73 77->44 77->44 77->79 78->45 78->45 78->79 79->46 79->46 79->90 79->91 80->1 80->1 80->47 80->47 81->1 81->16 81->51 81->53 81->63 81->73 82->1 82->52 82->52 82->55 82->94 83->1 83->1 83->1 84->1 84->1 84->1 84->92 85->1 85->1 85->1 86->1 86->1 86->56 86->56 86->85 87->1 87->60 88->1 88->1 89->1 89->1 90->1 90->80 90->80 91->80 91->80 92->59 92->59 92->93 92->132 92->137 93->1 93->59 93->59 93->71 93->83 94->1 94->86 94->86 95->1 95->1 95->1 95->60 95->61 95->98 95->99 95->100 95->104 96->84 97->24 97->54 97->101 98->88 98->88 98->103 99->1 99->24 99->54 99->101 100->1 100->1 100->1 100->92 101->102 102->24 102->54 102->101 103->1 103->95 103->95 104->100
>>>Token int main ( ) { int T , t ; YNFYI ( " " , & T ) ; for ( t = 1 ; t <= T ; t ++ ) { int C , D , N ; int i , j ; char s [ 101 ] ; int a , b , c ; int dd [ 28 ] ; int di ; char qq [ 8 ] [ 8 ] ; char rr [ 100 ] ; int cc [ 101 ] ; int ri ; int e ; printf ( " " , t ) ; memset ( qq , 0 , sizeof ( qq ) ) ; YNFYI ( " " , & C ) ; for ( i = 0 ; i < C ; i ++ ) { e = YNFYI ( " " , s ) ; assert ( e == 1 ) ; a = XCOXVCGEN ( s [ 0 ] ) ; b = XCOXVCGEN ( s [ 1 ] ) ; c = XCOXVCGEN ( s [ 2 ] ) ; assert ( a >= 0 ) ; assert ( b >= 0 ) ; assert ( c < 0 ) ; assert ( qq [ a ] [ b ] == 0 ) ; assert ( qq [ b ] [ a ] == 0 ) ; qq [ a ] [ b ] = s [ 2 ] ; qq [ b ] [ a ] = s [ 2 ] ; } di = 0 ; YNFYI ( " " , & D ) ; for ( i = 0 ; i < D ; i ++ ) { e = YNFYI ( " " , s ) ; assert ( e == 1 ) ; a = XCOXVCGEN ( s [ 0 ] ) ; b = XCOXVCGEN ( s [ 1 ] ) ; assert ( a >= 0 ) ; assert ( b >= 0 ) ; assert ( a != b ) ; dd [ di ] = ( 1 << a ) | ( 1 << b ) ; di ++ ; } cc [ 0 ] = 0 ; ri = 0 ; b = - 1 ; YNFYI ( " " , & N , s ) ; for ( j = 0 ; j < N ; j ++ ) { a = XCOXVCGEN ( s [ j ] ) ; assert ( a >= 0 ) ; if ( b >= 0 && qq [ a ] [ b ] != 0 ) { rr [ ri - 1 ] = qq [ a ] [ b ] ; b = - 1 ; cc [ ri ] = cc [ ri - 1 ] ; continue ; } rr [ ri ] = s [ j ] ; ri ++ ; b = a ; cc [ ri ] = cc [ ri - 1 ] | ( 1 << a ) ; for ( i = 0 ; i < D ; i ++ ) { assert ( dd [ i ] != 0 ) ; if ( ( cc [ ri ] & dd [ i ] ) == dd [ i ] ) { ri = 0 ; b = - 1 ; break ; } } } for ( j = 0 ; j < ri ; j ++ ) { if ( j > 0 ) { YEJKP ( " " , DBUICR ) ; } printf ( " " , rr [ j ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD MUSYNQIMJDWOT
METHOD_RETURN char*
PARAM const int fd
RETURN return ( NUEOJWYVIDU ( TLRKGV , YXL , fd ) ) ; return ( NUEOJWYVIDU ( TLRKGV , YXL , fd ) ) ;
<operator>.equals IMVJLCWDE == 0
NUEOJWYVIDU NUEOJWYVIDU ( TLRKGV , YXL , fd )
RETURN return ( NULL ) ; return ( NULL ) ;
IDENTIFIER NULL return ( NULL ) ;
<operator>.equals ( YXL = malloc ( IMVJLCWDE * sizeof ( char ) + 1 ) ) == NULL
RETURN return ( NULL ) ; return ( NULL ) ;
<operator>.assignment YXL = malloc ( IMVJLCWDE * sizeof ( char ) + 1 )
IDENTIFIER NULL return ( NULL ) ;
malloc malloc ( IMVJLCWDE * sizeof ( char ) + 1 )
<operator>.addition IMVJLCWDE * sizeof ( char ) + 1
<operator>.multiplication IMVJLCWDE * sizeof ( char )
<operator>.sizeOf sizeof ( char )
>>>PDG&16 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 2->1 2->5 3->1 4->1 4->1 4->6 4->8 4->10 4->12 4->13 4->14 4->14 4->15 5->3 6->1 7->6 8->1 8->3 8->5 8->9 9->1 10->5 10->8 11->9 12->8 12->10 14->12 14->13 15->1
>>>Token char * MUSYNQIMJDWOT ( const int fd ) { static char TLRKGV [ IMVJLCWDE ] ; char * YXL ; if ( IMVJLCWDE == 0 ) return ( NULL ) ; else if ( ( YXL = malloc ( IMVJLCWDE * sizeof ( char ) + 1 ) ) == NULL ) return ( NULL ) ; return ( NUEOJWYVIDU ( TLRKGV , YXL , fd ) ) ; }
>>>Func
METHOD YMRFPOG
METHOD_RETURN void
PARAM int i
PARAM int j
PARAM int n
PARAM char * x [ ]
<operator>.greaterThan n -- > 0
DPJY DPJY ( i , j )
<operator>.postIncrement i ++
<operator>.postIncrement j ++
<operator>.postDecrement n --
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->7 3->1 3->7 4->10 5->1 6->1 6->1 6->6 6->7 6->8 6->9 6->10 7->8 7->9 10->1 10->6
>>>Token void YMRFPOG ( int i , int j , int n , char * x [ ] ) { while ( n -- > 0 ) { DPJY ( i , j ) ; i ++ ; j ++ ; } }
>>>Func
METHOD BSH
METHOD_RETURN void
PARAM char TFL [ 100 ]
PARAM char * p1
PARAM char * p2
printf printf ( "hello" )
<operator>.lessEqualsThan j <= p2 - TFL
<operator>.postIncrement j ++
<operator>.assignment j = p1 - TFL
<operator>.assignment TFL [ j ] = '0'
<operator>.subtraction p2 - TFL
<operator>.subtraction p1 - TFL
<operator>.indirectIndexAccess TFL [ j ]
>>>PDG&13 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 2->11 3->11 4->10 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->9 6->10 6->12 7->1 7->6 8->1 8->1 8->6 9->10 10->1 10->1 10->6 10->6 11->1 11->8 11->8 11->10
>>>Token void BSH ( char TFL [ 100 ] , char * p1 , char * p2 ) { printf ( " " ) ; int j ; for ( j = p1 - TFL ; j <= p2 - TFL ; j ++ ) { TFL [ j ] = ' ' ; } }
>>>Func
METHOD NFBSLBKJCK
METHOD_RETURN void
PARAM OQYANAN x0
<operator>.assignment DSYHJKFUHNLH [ 0 ] = POWWPPJSCUU * x0
<operator>.assignment MQKTNRIBBAPXWHNICRGW = ERLQ
<operator>.assignment ENEFTNGIESDTNN = 0
<operator>.assignment UONMNKVDTXVCWAT = 521
RETURN return ; return ;
<operator>.lessThan i < 521
<operator>.postIncrement i ++
<operator>.multiplication POWWPPJSCUU * x0
<operator>.assignment i = 1
<operator>.assignment DSYHJKFUHNLH [ i ] = POWWPPJSCUU * DSYHJKFUHNLH [ i - 1 ] + MLMLLANYFGA
<operator>.addition POWWPPJSCUU * DSYHJKFUHNLH [ i - 1 ] + MLMLLANYFGA
<operator>.multiplication POWWPPJSCUU * DSYHJKFUHNLH [ i - 1 ]
<operator>.subtraction i - 1
<operator>.indirectIndexAccess DSYHJKFUHNLH [ i ]
<operator>.indirectIndexAccess DSYHJKFUHNLH [ i - 1 ]
>>>PDG&18 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->10 3->1 3->1 3->1 4->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 8->1 8->1 8->8 8->9 8->12 8->13 8->14 8->15 8->15 8->16 8->17 9->1 9->8 10->1 10->1 10->3 10->3 10->14 11->1 11->8 12->1 12->1 12->1 13->1 13->1 14->1 14->1 14->12 14->12 14->13 14->13 15->9
>>>Token void NFBSLBKJCK ( OQYANAN x0 ) { OQYANAN i ; DSYHJKFUHNLH [ 0 ] = POWWPPJSCUU * x0 ; for ( i = 1 ; i < 521 ; i ++ ) { DSYHJKFUHNLH [ i ] = POWWPPJSCUU * DSYHJKFUHNLH [ i - 1 ] + MLMLLANYFGA ; } MQKTNRIBBAPXWHNICRGW = ERLQ ; ENEFTNGIESDTNN = 0 ; UONMNKVDTXVCWAT = 521 ; return ; }
>>>Func
METHOD XRTBBUYCJSDFMXGEB
METHOD_RETURN int
PARAM BWMVOD * EKGUV
PARAM int UHUSYOWC
RETURN return NIOIHJRCERSBTDYB ; return NIOIHJRCERSBTDYB ;
<operator>.logicalAnd UHUSYOWC >= 0 && UHUSYOWC < EKGUV -> JVGS
IDENTIFIER NIOIHJRCERSBTDYB return NIOIHJRCERSBTDYB ;
<operator>.greaterEqualsThan UHUSYOWC >= 0
<operator>.lessThan UHUSYOWC < EKGUV -> JVGS
<operator>.notEquals EKGUV -> EKGUV [ UHUSYOWC ] != 0
<operator>.assignment EKGUV -> EKGUV [ UHUSYOWC ] = 0
RETURN return QKBFKHKNKHAJXF ; return QKBFKHKNKHAJXF ;
IDENTIFIER QKBFKHKNKHAJXF return QKBFKHKNKHAJXF ;
<operator>.indirectFieldAccess EKGUV -> JVGS
FIELD_IDENTIFIER JVGS JVGS
<operator>.indirectIndexAccess EKGUV -> EKGUV [ UHUSYOWC ]
<operator>.indirectFieldAccess EKGUV -> EKGUV
<operator>.indirectIndexAccess EKGUV -> EKGUV [ UHUSYOWC ]
FIELD_IDENTIFIER EKGUV EKGUV
<operator>.indirectFieldAccess EKGUV -> EKGUV
FIELD_IDENTIFIER EKGUV EKGUV
>>>PDG&21 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 3->7 4->1 5->1 5->1 5->1 5->4 5->9 5->15 5->16 5->18 6->4 7->1 7->5 7->5 7->8 7->8 7->13 7->14 8->1 8->1 8->5 8->5 9->1 9->1 9->4 9->10 9->11 9->17 9->19 9->20 11->1 12->11
>>>Token int XRTBBUYCJSDFMXGEB ( BWMVOD * EKGUV , int UHUSYOWC ) { if ( UHUSYOWC >= 0 && UHUSYOWC < EKGUV -> JVGS ) { if ( EKGUV -> EKGUV [ UHUSYOWC ] != 0 ) { EKGUV -> EKGUV [ UHUSYOWC ] = 0 ; } else return QKBFKHKNKHAJXF ; } return NIOIHJRCERSBTDYB ; }
>>>Func
METHOD FNXFFYSY
METHOD_RETURN void
PARAM char ULLJ [ 100 ] [ 101 ]
PARAM int n
PARAM int YTEY
<operator>.assignment wp = EYDWPIT ( ULLJ , n , YTEY , - 1 )
<operator>.assignment PHL = HSCYXINX ( ULLJ , n , YTEY , - 1 )
<operator>.assignment NUYIVUTHGS = 0
<operator>.assignment CKTIMWFEH = 0
<operator>.assignment CUON = NUYIVUTHGS / CKTIMWFEH
printf printf ( "%f " , 0.25 * wp + 0.5 * PHL + 0.25 * CUON )
<operator>.notEquals i != n
<operator>.preIncrement ++ i
EYDWPIT EYDWPIT ( ULLJ , n , YTEY , - 1 )
HSCYXINX HSCYXINX ( ULLJ , n , YTEY , - 1 )
<operator>.assignment i = 0
<operator>.division NUYIVUTHGS / CKTIMWFEH
<operator>.addition 0.25 * wp + 0.5 * PHL + 0.25 * CUON
<operator>.minus - 1
<operator>.minus - 1
<operator>.notEquals ULLJ [ YTEY ] [ i ] != '.'
<operator>.addition 0.25 * wp + 0.5 * PHL
<operator>.multiplication 0.25 * CUON
<operator>.assignmentPlus NUYIVUTHGS += HSCYXINX ( ULLJ , n , i , - 1 )
<operator>.preIncrement ++ CKTIMWFEH
<operator>.multiplication 0.25 * wp
<operator>.multiplication 0.5 * PHL
HSCYXINX HSCYXINX ( ULLJ , n , i , - 1 )
<operator>.minus - 1
<operator>.indirectIndexAccess ULLJ [ YTEY ] [ i ]
<operator>.indirectIndexAccess ULLJ [ YTEY ]
>>>PDG&31 0->2 0->3 0->4 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 2->13 3->13 4->13 5->1 5->1 5->25 6->1 6->1 6->26 7->1 7->16 7->23 8->1 8->16 8->24 9->1 9->1 9->22 10->1 10->1 11->1 11->1 11->1 11->11 11->12 11->12 11->20 11->27 11->27 11->29 11->30 12->1 12->11 13->5 13->5 13->5 13->5 13->14 13->14 13->14 14->1 14->1 14->1 14->6 14->6 14->6 14->6 14->11 14->27 15->1 15->11 16->1 16->1 16->9 16->9 17->1 17->1 18->13 19->14 20->1 20->1 20->23 20->24 20->27 20->28 21->1 21->1 22->1 22->10 22->10 22->17 22->17 23->1 23->1 23->16 24->1 24->16 25->1 25->10 25->10 25->17 25->17 25->21 25->21 26->1 26->10 26->10 26->17 26->17 26->21 26->21 27->1 27->1 27->11 27->12 27->23 27->23 27->23 27->23 28->27
>>>Token void FNXFFYSY ( char ULLJ [ 100 ] [ 101 ] , int n , int YTEY ) { double wp = EYDWPIT ( ULLJ , n , YTEY , - 1 ) ; double PHL = HSCYXINX ( ULLJ , n , YTEY , - 1 ) ; double NUYIVUTHGS = 0 ; int CKTIMWFEH = 0 ; for ( int i = 0 ; i != n ; ++ i ) { if ( ULLJ [ YTEY ] [ i ] != ' ' ) { NUYIVUTHGS += HSCYXINX ( ULLJ , n , i , - 1 ) ; ++ CKTIMWFEH ; } } double CUON = NUYIVUTHGS / CKTIMWFEH ; printf ( " " , 0.25 * wp + 0.5 * PHL + 0.25 * CUON ) ; }
>>>Func
METHOD GRBONERLOM
METHOD_RETURN char*
PARAM char * XJGB
<operator>.assignment IKCVEWLB = 0
<operator>.assignment FDCME = IKCVEWLB
<operator>.logicalAnd XJGB [ IKCVEWLB ] != '\n' && XJGB [ IKCVEWLB ] != 0
<operator>.equals XJGB [ IKCVEWLB ] == '\n'
<operator>.postIncrement IKCVEWLB ++
<operator>.assignment XJGB [ IKCVEWLB ] = 0
<operator>.postIncrement IKCVEWLB ++
RETURN return XJGB + FDCME ; return XJGB + FDCME ;
<operator>.notEquals XJGB [ IKCVEWLB ] != '\n'
<operator>.notEquals XJGB [ IKCVEWLB ] != 0
<operator>.addition XJGB + FDCME
RETURN return NULL ; return NULL ;
IDENTIFIER NULL return NULL ;
<operator>.indirectIndexAccess XJGB [ IKCVEWLB ]
<operator>.indirectIndexAccess XJGB [ IKCVEWLB ]
<operator>.indirectIndexAccess XJGB [ IKCVEWLB ]
>>>PDG&19 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 2->6 2->11 2->12 2->13 3->1 3->4 3->7 3->9 4->1 4->13 5->1 5->1 5->1 5->5 5->7 5->11 5->16 6->1 6->8 6->9 6->10 6->13 6->14 6->18 7->9 8->1 8->1 8->13 9->1 9->1 10->1 11->5 11->5 11->6 11->12 11->12 11->17 12->5 12->5 12->6 12->11 13->1 13->1 13->1 13->10 14->1 15->14
>>>Token char * GRBONERLOM ( char * XJGB ) { static int IKCVEWLB = 0 ; static int FDCME ; FDCME = IKCVEWLB ; while ( XJGB [ IKCVEWLB ] != ' \n ' && XJGB [ IKCVEWLB ] != 0 ) { IKCVEWLB ++ ; } if ( XJGB [ IKCVEWLB ] == ' \n ' ) { XJGB [ IKCVEWLB ] = 0 ; IKCVEWLB ++ ; return XJGB + FDCME ; } else return NULL ; }
>>>Func
METHOD ROAEW
METHOD_RETURN int
PARAM char * s
PARAM int m
PARAM char * * v
PARAM char * r
<operator>.assignment n = 0
RETURN return n ; return n ;
IDENTIFIER n return n ;
<operator>.assignment x = s
assert assert ( n < m )
<operator>.assignment v [ n ++ ] = x
<operator>.assignment * x ++ = 0
<operator>.logicalAnd * x && UKJIJV ( r , * x )
<operator>.postIncrement x ++
<operator>.logicalNot ! * x
<operator>.logicalAnd * x && ! UKJIJV ( r , * x )
<operator>.postIncrement x ++
<operator>.logicalNot ! * x
<operator>.lessThan n < m
UKJIJV UKJIJV ( r , * x )
<operator>.postIncrement n ++
<operator>.logicalNot ! UKJIJV ( r , * x )
<operator>.postIncrement x ++
UKJIJV UKJIJV ( r , * x )
<operator>.indirectIndexAccess v [ n ++ ]
<operator>.indirection * x ++
<operator>.indirection * x
<operator>.indirection * x
<operator>.indirection * x
<operator>.indirection * x
<operator>.indirection * x
<operator>.indirection * x
>>>PDG&33 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->11 0->12 0->14 0->17 0->19 0->20 0->21 0->23 0->24 2->9 3->1 3->19 4->1 5->1 5->20 5->24 6->1 6->1 6->8 6->19 7->1 8->7 9->1 9->1 9->1 9->11 9->14 9->17 9->23 10->1 10->1 11->1 11->1 11->1 12->1 12->1 13->1 13->1 13->13 13->14 13->14 13->15 13->20 13->27 14->1 14->1 14->11 14->17 14->23 15->1 15->1 15->10 15->11 15->11 15->16 15->16 15->17 15->18 15->19 15->21 15->23 15->24 15->25 15->29 15->30 16->1 16->1 16->16 16->17 16->17 16->18 16->24 16->29 17->1 17->1 17->23 18->1 18->1 18->12 18->13 18->13 18->15 18->20 18->23 18->23 18->26 18->27 18->28 19->1 19->10 19->10 19->21 20->1 20->13 20->13 20->24 21->1 21->8 21->19 22->1 22->13 22->16 23->1 23->11 23->14 23->17 24->1 24->16 24->20 24->22 24->22 27->20 27->31 29->22 29->24 29->32
>>>Token static int ROAEW ( char * s , int m , char * * v , char * r ) { int n = 0 ; char * x ; for ( x = s ; ; ) { while ( * x && UKJIJV ( r , * x ) ) x ++ ; if ( ! * x ) break ; assert ( n < m ) ; v [ n ++ ] = x ; while ( * x && ! UKJIJV ( r , * x ) ) x ++ ; if ( ! * x ) break ; * x ++ = 0 ; } return n ; }
>>>Func
METHOD DRVA
METHOD_RETURN void
PARAM int * * CLSN
PARAM int * * RST
PARAM int A
PARAM char * ACXYPJJO
<operator>.lessThan fo ( j , 26 ) <NJYGGFO
<operator>.lessThan ';'> fo ( k , 26 ) <NJYGGFO
<operator>.lessThan fo ( j , A ) <NJYGGFO
<operator>.lessThan fo ( j , A ) <NJYGGFO
fo fo ( j , 26 )
<operator>.greaterThan ';'> fo ( k , 26 )
fo fo ( j , A )
fo fo ( j , A )
fo fo ( k , 26 )
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 4->12 5->1 6->1 6->1 6->7 7->1 7->1 7->8 8->9 9->1 9->1 9->1 10->6 10->6 10->12 11->1 11->7 11->7 12->8 12->8 12->13 12->13 13->1 13->1 13->9 13->9 14->1 14->11 14->11
>>>Token void DRVA ( int * * CLSN , int * * RST , int A , char * ACXYPJJO ) { int j , k ; fo ( j , 26 ) < NJYGGFO ' ' > fo ( k , 26 ) < NJYGGFO ' ; ' { CLSN [ j ] [ k ] = - 1 ; RST [ j ] [ k ] = 0 ; } fo ( j , A ) < NJYGGFO ' ; ' { SIYRI ( " " , ACXYPJJO ) ; CLSN [ ACXYPJJO [ 0 ] - 65 ] [ ACXYPJJO [ 1 ] - 65 ] = ACXYPJJO [ 2 ] - 65 ; CLSN [ ACXYPJJO [ 1 ] - 65 ] [ ACXYPJJO [ 0 ] - 65 ] = ACXYPJJO [ 2 ] - 65 ; } FJEFNSA ( A ) fo ( j , A ) < NJYGGFO ' ; ' { SIYRI ( " " , ACXYPJJO ) ; RST [ ACXYPJJO [ 0 ] - 65 ] [ ACXYPJJO [ 1 ] - 65 ] = 1 ; RST [ ACXYPJJO [ 1 ] - 65 ] [ ACXYPJJO [ 0 ] - 65 ] = 1 ; } }
>>>Func
METHOD ISN
METHOD_RETURN void
PARAM struct CJKQL * MLAWH
PARAM int YRVFOJTHAPQ
<operator>.assignment * q = MTAHHERTUFJ ( )
<operator>.assignment MLAWH -> IFGQGYM [ YRVFOJTHAPQ ] = 1
LNXGWXX LNXGWXX ( q , YRVFOJTHAPQ )
printf printf ( "Breadth first traversal from vertex %d is:\n" , YRVFOJTHAPQ )
<operator>.logicalNot ! OAHIQYW ( q )
printf printf ( "%d "   KAFUGWQCE ( q ) )
<operator>.assignment AKLJDRIREXRMU = PKLRUWI ( q )
<operator>.assignment * BQBA = MLAWH -> HFEKRPTX [ AKLJDRIREXRMU ]
OAHIQYW OAHIQYW ( q )
IDENTIFIER BQBA while (BQBA)
KAFUGWQCE KAFUGWQCE ( q )
PKLRUWI PKLRUWI ( q )
<operator>.assignment IEPMCIYYA = BQBA -> LLSGKD
<operator>.assignment BQBA = BQBA -> BEYW
<operator>.equals MLAWH -> IFGQGYM [ IEPMCIYYA ] == 0
<operator>.assignment MLAWH -> IFGQGYM [ IEPMCIYYA ] = 1
LNXGWXX LNXGWXX ( q , IEPMCIYYA )
<operator>.indirectIndexAccess MLAWH -> HFEKRPTX [ AKLJDRIREXRMU ]
<operator>.indirectFieldAccess MLAWH -> HFEKRPTX
FIELD_IDENTIFIER HFEKRPTX HFEKRPTX
<operator>.indirectFieldAccess BQBA -> LLSGKD
<operator>.indirectFieldAccess BQBA -> BEYW
FIELD_IDENTIFIER LLSGKD LLSGKD
<operator>.indirectIndexAccess MLAWH -> IFGQGYM [ IEPMCIYYA ]
FIELD_IDENTIFIER BEYW BEYW
<operator>.indirectFieldAccess MLAWH -> IFGQGYM
<operator>.indirectIndexAccess MLAWH -> IFGQGYM [ IEPMCIYYA ]
FIELD_IDENTIFIER IFGQGYM IFGQGYM
<operator>.indirectFieldAccess MLAWH -> IFGQGYM
FIELD_IDENTIFIER IFGQGYM IFGQGYM
>>>PDG&34 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->12 0->13 0->14 0->15 0->18 0->19 0->20 2->1 3->6 4->1 4->1 4->6 5->1 5->1 6->1 6->7 6->12 7->1 7->1 8->1 8->1 8->8 8->9 8->10 8->11 8->12 8->14 8->15 8->16 8->17 8->18 8->21 8->22 8->23 8->24 8->25 8->26 8->27 8->28 8->29 8->31 12->1 12->8 12->14 14->9 14->15 15->10 15->12 15->20 16->20 18->19 18->20 18->30 18->32 18->33 19->18 20->12
>>>Token void ISN ( struct CJKQL * MLAWH , int YRVFOJTHAPQ ) { struct AJRQP * q = MTAHHERTUFJ ( ) ; MLAWH -> IFGQGYM [ YRVFOJTHAPQ ] = 1 ; LNXGWXX ( q , YRVFOJTHAPQ ) ; printf ( " \n " , YRVFOJTHAPQ ) ; while ( ! OAHIQYW ( q ) ) { printf ( " " , KAFUGWQCE ( q ) ) ; int AKLJDRIREXRMU = PKLRUWI ( q ) ; struct TTVT * BQBA = MLAWH -> HFEKRPTX [ AKLJDRIREXRMU ] ; while ( BQBA ) { int IEPMCIYYA = BQBA -> LLSGKD ; if ( MLAWH -> IFGQGYM [ IEPMCIYYA ] == 0 ) { MLAWH -> IFGQGYM [ IEPMCIYYA ] = 1 ; LNXGWXX ( q , IEPMCIYYA ) ; } BQBA = BQBA -> BEYW ; } } }
>>>Func
METHOD LKINWPLYEAVJWIIBFUHSMFGRA
METHOD_RETURN bool
PARAM char const * GPUY
<operator>.assignment * BEMO = OALGLKMNGXMOHN ( GPUY )
RETURN return VEURRDXJDEBAD ( BEMO ) ; return VEURRDXJDEBAD ( BEMO ) ;
VEURRDXJDEBAD VEURRDXJDEBAD ( BEMO )
OALGLKMNGXMOHN OALGLKMNGXMOHN ( GPUY )
>>>PDG&7 0->2 0->5 0->6 2->6 3->1 3->1 3->5 4->1 5->1 5->1 5->4 6->1 6->3
>>>Token static bool LKINWPLYEAVJWIIBFUHSMFGRA ( char const * GPUY ) { char const * BEMO = OALGLKMNGXMOHN ( GPUY ) ; return VEURRDXJDEBAD ( BEMO ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment NUEJHYQ = 0
UIDMK UIDMK ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.assignment GYOEKERJK = 0
<operator>.assignment NUEJHYQ = 0
<operator>.assignment FSVV [ 100 ] = ""
UIDMK UIDMK ( " %d" , & C )
UIDMK UIDMK ( " %d" , & D )
UIDMK UIDMK ( " %d " , & N )
printf printf ( "Case #%d: [" , i + 1 )
<operator>.lessThan j < 26
<operator>.postIncrement j ++
<operator>.lessThan j < C
<operator>.postIncrement j ++
<operator>.lessThan j < D
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < GYOEKERJK - 1
<operator>.postIncrement j ++
<operator>.greaterThan GYOEKERJK > 0
<operator>.assignment j = 0
<operator>.assignment BALYE [ j ] = 0
<operator>.assignment j = 0
UIDMK UIDMK ( " %c%c%c" , & BAE , & LOG , & FDO )
<operator>.assignment FDAPFTV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ] = FDO
<operator>.assignment FDAPFTV [ ( int ) LOG - 65 ] [ ( int ) BAE - 65 ] = FDO
<operator>.assignment j = 0
UIDMK UIDMK ( " %c%c" , & BAE , & LOG )
<operator>.assignment HICRMV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ] = 1
<operator>.assignment HICRMV [ ( int ) LOG - 65 ] [ ( int ) BAE - 65 ] = 1
<operator>.assignment j = 0
UIDMK UIDMK ( "%c" , & BAE )
<operator>.assignment NUEJHYQ = 0
<operator>.assignment LOG = FSVV [ GYOEKERJK - 1 ]
<operator>.addition i + 1
<operator>.assignment j = 0
printf printf ( "%c, " , FSVV [ j ] )
printf printf ( "%c]\n" , FSVV [ GYOEKERJK - 1 ] )
<operator>.lessThan k < 26
<operator>.postIncrement k ++
<operator>.equals GYOEKERJK == 0
<operator>.logicalAnd NUEJHYQ == 0 && GYOEKERJK > 0
<operator>.subtraction GYOEKERJK - 1
printf printf ( "]\n" )
<operator>.assignment k = 0
<operator>.assignment FDAPFTV [ j ] [ k ] = '\0'
<operator>.assignment HICRMV [ j ] [ k ] = 0
<operator>.assignment FSVV [ GYOEKERJK ++ ] = BAE
<operator>.postIncrement BALYE [ ( int ) BAE - 65 ] ++
<operator>.assignment NUEJHYQ = 1
<operator>.assignment FSVV [ GYOEKERJK ++ ] = BAE
<operator>.postIncrement BALYE [ ( int ) BAE - 65 ] ++
<operator>.subtraction ( int ) LOG - 65
<operator>.subtraction ( int ) BAE - 65
<operator>.subtraction ( int ) LOG - 65
<operator>.subtraction ( int ) BAE - 65
<operator>.subtraction GYOEKERJK - 1
<operator>.equals NUEJHYQ == 0
<operator>.greaterThan GYOEKERJK > 0
<operator>.subtraction GYOEKERJK - 1
<operator>.subtraction ( int ) BAE - 65
<operator>.cast ( int ) LOG
<operator>.subtraction ( int ) LOG - 65
<operator>.cast ( int ) BAE
<operator>.subtraction ( int ) BAE - 65
<operator>.cast ( int ) LOG
<operator>.subtraction ( int ) LOG - 65
<operator>.cast ( int ) BAE
<operator>.notEquals FDAPFTV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ] != '\0'
<operator>.cast ( int ) BAE
<operator>.cast ( int ) LOG
<operator>.cast ( int ) BAE
<operator>.cast ( int ) LOG
<operator>.postIncrement GYOEKERJK ++
<operator>.subtraction ( int ) BAE - 65
<operator>.postDecrement BALYE [ ( int ) FSVV [ GYOEKERJK - 1 ] - 65 ] --
<operator>.assignment FSVV [ GYOEKERJK - 1 ] = FDAPFTV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ]
<operator>.postIncrement BALYE [ ( int ) FSVV [ GYOEKERJK - 1 ] - 65 ] ++
<operator>.assignment NUEJHYQ = 1
<operator>.postIncrement GYOEKERJK ++
<operator>.subtraction ( int ) BAE - 65
<operator>.cast ( int ) BAE
<operator>.cast ( int ) BAE
<operator>.subtraction ( int ) LOG - 65
<operator>.lessThan k < 26
<operator>.postIncrement k ++
<operator>.subtraction ( int ) BAE - 65
<operator>.cast ( int ) LOG
<operator>.subtraction ( int ) FSVV [ GYOEKERJK - 1 ] - 65
<operator>.subtraction GYOEKERJK - 1
<operator>.subtraction ( int ) LOG - 65
<operator>.subtraction ( int ) FSVV [ GYOEKERJK - 1 ] - 65
<operator>.assignment k = 0
<operator>.cast ( int ) BAE
<operator>.cast ( int ) FSVV [ GYOEKERJK - 1 ]
<operator>.subtraction ( int ) BAE - 65
<operator>.cast ( int ) LOG
<operator>.cast ( int ) FSVV [ GYOEKERJK - 1 ]
<operator>.logicalAnd HICRMV [ ( int ) BAE - 65 ] [ k ] == 1 && BALYE [ k ] > 0
<operator>.cast ( int ) BAE
<operator>.assignment * FSVV = ""
<operator>.assignment NUEJHYQ = 1
<operator>.assignment GYOEKERJK = 0
<operator>.subtraction GYOEKERJK - 1
<operator>.subtraction GYOEKERJK - 1
<operator>.equals HICRMV [ ( int ) BAE - 65 ] [ k ] == 1
<operator>.greaterThan BALYE [ k ] > 0
<operator>.lessThan p < 26
<operator>.postIncrement p ++
<operator>.assignment p = 0
<operator>.assignment BALYE [ p ] = 0
<operator>.subtraction ( int ) BAE - 65
<operator>.cast ( int ) BAE
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.indirectIndexAccess BALYE [ j ]
<operator>.addressOf & BAE
<operator>.addressOf & LOG
<operator>.addressOf & FDO
<operator>.indirectIndexAccess FDAPFTV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ]
<operator>.indirectIndexAccess FDAPFTV [ ( int ) LOG - 65 ] [ ( int ) BAE - 65 ]
<operator>.addressOf & BAE
<operator>.addressOf & LOG
<operator>.indirectIndexAccess HICRMV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ]
<operator>.indirectIndexAccess HICRMV [ ( int ) LOG - 65 ] [ ( int ) BAE - 65 ]
<operator>.addressOf & BAE
<operator>.indirectIndexAccess FSVV [ GYOEKERJK - 1 ]
<operator>.indirectIndexAccess FSVV [ j ]
<operator>.indirectIndexAccess FSVV [ GYOEKERJK - 1 ]
<operator>.indirectIndexAccess FDAPFTV [ ( int ) BAE - 65 ]
<operator>.indirectIndexAccess FDAPFTV [ ( int ) LOG - 65 ]
<operator>.indirectIndexAccess HICRMV [ ( int ) BAE - 65 ]
<operator>.indirectIndexAccess HICRMV [ ( int ) LOG - 65 ]
<operator>.indirectIndexAccess FDAPFTV [ j ] [ k ]
<operator>.indirectIndexAccess HICRMV [ j ] [ k ]
<operator>.indirectIndexAccess FSVV [ GYOEKERJK ++ ]
<operator>.indirectIndexAccess BALYE [ ( int ) BAE - 65 ]
<operator>.indirectIndexAccess FSVV [ GYOEKERJK ++ ]
<operator>.indirectIndexAccess BALYE [ ( int ) BAE - 65 ]
<operator>.indirectIndexAccess FDAPFTV [ j ]
<operator>.indirectIndexAccess HICRMV [ j ]
UNKNOWN int int
UNKNOWN int int
UNKNOWN int int
UNKNOWN int int
UNKNOWN int int
UNKNOWN int int
UNKNOWN int int
UNKNOWN int int
<operator>.indirectIndexAccess FDAPFTV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ]
UNKNOWN int int
<operator>.indirectIndexAccess FDAPFTV [ ( int ) BAE - 65 ]
<operator>.indirectIndexAccess BALYE [ ( int ) FSVV [ GYOEKERJK - 1 ] - 65 ]
<operator>.indirectIndexAccess FSVV [ GYOEKERJK - 1 ]
<operator>.indirectIndexAccess FDAPFTV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ]
<operator>.indirectIndexAccess BALYE [ ( int ) FSVV [ GYOEKERJK - 1 ] - 65 ]
UNKNOWN int int
<operator>.indirectIndexAccess FDAPFTV [ ( int ) BAE - 65 ]
UNKNOWN int int
UNKNOWN int int
UNKNOWN int int
<operator>.indirectIndexAccess FSVV [ GYOEKERJK - 1 ]
UNKNOWN int int
UNKNOWN int int
<operator>.indirectIndexAccess FSVV [ GYOEKERJK - 1 ]
UNKNOWN int int
<operator>.indirectIndexAccess HICRMV [ ( int ) BAE - 65 ] [ k ]
<operator>.indirectIndexAccess BALYE [ k ]
<operator>.indirection * FSVV
<operator>.indirectIndexAccess HICRMV [ ( int ) BAE - 65 ]
<operator>.indirectIndexAccess BALYE [ p ]
UNKNOWN int int
>>>PDG&180 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->49 0->50 0->51 0->52 0->53 0->54 0->56 0->57 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->102 0->103 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->114 0->115 0->116 0->117 0->118 0->119 2->1 2->1 3->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->15 5->16 5->18 5->20 5->22 5->24 5->26 5->27 5->29 5->33 5->37 5->41 5->41 5->42 5->49 5->120 5->121 5->122 6->1 6->5 7->4 8->1 8->5 9->1 9->49 9->63 10->1 10->1 11->1 11->1 11->40 11->43 11->44 11->95 11->98 11->101 11->104 12->1 12->1 12->18 13->1 13->1 13->20 14->1 14->1 14->22 15->1 15->1 16->1 16->16 16->17 16->17 16->28 16->45 16->51 16->123 17->1 17->16 18->1 18->1 18->12 18->18 18->19 18->19 18->30 18->31 18->32 18->59 18->60 18->67 18->68 18->69 18->70 18->76 18->77 18->124 18->125 18->126 18->127 18->128 18->137 18->138 18->149 18->150 18->153 18->154 19->1 19->18 20->1 20->1 20->13 20->20 20->21 20->21 20->34 20->35 20->36 20->61 20->62 20->71 20->72 20->73 20->74 20->78 20->79 20->129 20->130 20->131 20->132 20->139 20->140 20->151 20->152 20->155 20->156 21->1 21->20 22->1 22->1 22->14 22->22 22->23 22->23 22->38 22->39 22->40 22->47 22->48 22->63 22->64 22->133 22->134 23->1 23->22 24->1 24->1 24->1 24->24 24->25 24->25 24->43 24->49 24->135 25->1 25->24 26->1 26->1 26->44 26->48 26->50 26->66 26->66 26->136 27->16 28->1 28->1 29->18 30->1 30->1 30->1 30->1 30->31 30->32 30->34 30->34 30->38 30->54 30->59 30->60 30->61 30->62 30->67 30->68 30->69 30->70 30->71 30->72 30->73 30->74 30->76 30->77 30->78 30->79 30->81 30->88 30->90 30->93 30->94 30->97 30->100 30->103 31->1 31->1 31->75 32->1 32->1 32->1 33->20 34->1 34->1 34->1 34->30 34->30 34->38 34->54 34->59 34->61 34->62 34->68 34->69 34->71 34->72 34->73 34->74 34->77 34->78 34->79 34->81 34->88 34->90 34->93 34->94 34->97 34->100 34->103 35->1 35->1 36->1 36->1 37->22 38->1 38->1 38->30 38->34 38->54 38->57 38->60 38->62 38->67 38->70 38->71 38->74 38->76 38->78 38->81 38->87 38->88 38->89 38->93 38->100 38->102 38->106 38->118 38->119 39->1 39->64 40->1 40->1 40->1 40->30 40->34 40->59 40->61 40->68 40->69 40->72 40->73 40->77 40->79 40->90 40->94 40->97 40->103 42->1 42->24 43->1 43->1 44->1 44->1 44->40 44->95 44->101 45->1 45->1 45->45 45->46 45->46 45->52 45->53 45->141 45->142 45->147 45->148 46->1 46->45 47->1 47->49 47->54 47->55 47->56 47->63 47->65 47->75 47->80 47->80 47->81 47->86 47->88 47->90 47->93 47->94 47->100 47->110 47->143 47->144 47->157 47->158 47->159 47->166 47->167 48->1 48->1 48->57 48->58 48->86 48->87 48->89 48->145 48->146 48->164 49->24 49->24 49->26 50->1 51->1 51->45 52->1 52->1 53->1 53->1 54->1 54->1 55->1 55->1 55->58 56->1 56->64 57->1 57->1 58->1 58->1 58->55 60->1 62->1 63->47 64->1 64->48 64->48 64->65 65->48 65->48 65->49 65->63 65->86 66->1 69->1 70->1 73->1 74->1 75->1 75->1 75->82 75->83 75->83 75->84 75->85 75->91 75->95 75->96 75->97 75->98 75->99 75->101 75->102 75->103 75->104 75->106 75->110 75->111 75->160 75->161 75->162 75->163 75->165 75->168 75->169 75->170 75->171 75->172 75->173 77->1 79->1 80->49 80->63 80->65 80->86 81->1 82->1 82->84 83->1 83->1 83->40 83->44 83->95 83->98 83->101 83->104 84->1 84->1 84->82 85->1 85->64 86->49 86->63 87->1 88->1 89->1 90->1 91->1 91->1 91->91 91->92 91->92 91->105 91->112 91->118 91->119 91->174 91->177 91->179 92->1 92->91 93->1 94->1 96->111 97->1 98->1 99->1 99->91 100->1 102->1 103->1 104->1 105->1 105->1 105->1 105->107 105->108 105->109 105->114 105->116 105->176 106->1 107->1 107->1 108->1 108->64 109->1 109->49 109->63 109->65 109->86 110->96 111->49 111->63 111->65 111->86 112->1 112->105 112->105 112->113 112->175 113->1 113->105 113->105 114->1 114->1 114->114 114->115 114->115 114->117 114->178 115->1 115->114 116->1 116->114 117->1 117->1 118->1 119->1
>>>Token int main ( ) { int T , C , D , N ; int i , j , k , p , GYOEKERJK , NUEJHYQ = 0 ; char BAE , LOG , FDO ; char FDAPFTV [ 26 ] [ 26 ] ; int HICRMV [ 26 ] [ 26 ] ; int BALYE [ 26 ] ; UIDMK ( " " , & T ) ; for ( i = 0 ; i < T ; i ++ ) { GYOEKERJK = 0 ; NUEJHYQ = 0 ; for ( j = 0 ; j < 26 ; j ++ ) { BALYE [ j ] = 0 ; for ( k = 0 ; k < 26 ; k ++ ) { FDAPFTV [ j ] [ k ] = ' \0 ' ; HICRMV [ j ] [ k ] = 0 ; } } char FSVV [ 100 ] = " " ; UIDMK ( " " , & C ) ; for ( j = 0 ; j < C ; j ++ ) { UIDMK ( " " , & BAE , & LOG , & FDO ) ; FDAPFTV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ] = FDO ; FDAPFTV [ ( int ) LOG - 65 ] [ ( int ) BAE - 65 ] = FDO ; } UIDMK ( " " , & D ) ; for ( j = 0 ; j < D ; j ++ ) { UIDMK ( " " , & BAE , & LOG ) ; HICRMV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ] = 1 ; HICRMV [ ( int ) LOG - 65 ] [ ( int ) BAE - 65 ] = 1 ; } UIDMK ( " " , & N ) ; for ( j = 0 ; j < N ; j ++ ) { UIDMK ( " " , & BAE ) ; NUEJHYQ = 0 ; LOG = FSVV [ GYOEKERJK - 1 ] ; if ( GYOEKERJK == 0 ) { FSVV [ GYOEKERJK ++ ] = BAE ; BALYE [ ( int ) BAE - 65 ] ++ ; NUEJHYQ = 1 ; } else if ( FDAPFTV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ] != ' \0 ' ) { BALYE [ ( int ) FSVV [ GYOEKERJK - 1 ] - 65 ] -- ; FSVV [ GYOEKERJK - 1 ] = FDAPFTV [ ( int ) BAE - 65 ] [ ( int ) LOG - 65 ] ; BALYE [ ( int ) FSVV [ GYOEKERJK - 1 ] - 65 ] ++ ; NUEJHYQ = 1 ; } else { for ( k = 0 ; k < 26 ; k ++ ) { if ( HICRMV [ ( int ) BAE - 65 ] [ k ] == 1 && BALYE [ k ] > 0 ) { * FSVV = " " ; NUEJHYQ = 1 ; GYOEKERJK = 0 ; for ( p = 0 ; p < 26 ; p ++ ) { BALYE [ p ] = 0 ; } } } } if ( NUEJHYQ == 0 && GYOEKERJK > 0 ) { FSVV [ GYOEKERJK ++ ] = BAE ; BALYE [ ( int ) BAE - 65 ] ++ ; } } printf ( " " , i + 1 ) ; for ( j = 0 ; j < GYOEKERJK - 1 ; j ++ ) { printf ( " " , FSVV [ j ] ) ; } if ( GYOEKERJK > 0 ) { printf ( " \n " , FSVV [ GYOEKERJK - 1 ] ) ; } else { printf ( " \n " ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PAMK PAMK ( )
LENWR LENWR ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < t
<operator>.preIncrement ++ i
LITERAL 0 return 0 ;
<operator>.assignment i = 0
LENWR LENWR ( "%d" , & c )
<operator>.assignment SKTSAC = 0
LENWR LENWR ( "%d" , & d )
LENWR LENWR ( "%d" , & n )
LENWR LENWR ( "%s" , HFC )
printf printf ( "Case #%d: " , i + 1 )
printf printf ( "[" )
printf printf ( "]\n" )
<operator>.lessThan j < c
<operator>.preIncrement ++ j
<operator>.lessThan k < d
<operator>.preIncrement ++ k
<operator>.lessThan j < n
<operator>.preIncrement ++ j
<operator>.lessThan l < SKTSAC
<operator>.preIncrement ++ l
<operator>.assignment j = 0
LENWR LENWR ( "%s" , CEUC [ j ] )
<operator>.assignment k = 0
LENWR LENWR ( "%s" , NHQU [ k ] )
<operator>.assignment j = 0
<operator>.assignment VYE [ SKTSAC ] = HFC [ j ]
<operator>.preIncrement ++ SKTSAC
<operator>.addition i + 1
<operator>.assignment l = 0
printf printf ( "%c" , VYE [ l ] )
LITERAL 1 while (1)
<operator>.notEquals l != 0
<operator>.assignment KRSM = 0
printf printf ( ", " )
<operator>.lessThan SKTSAC < 2
<operator>.lessThan k < c
<operator>.preIncrement ++ k
IDENTIFIER KRSM if (KRSM)
<operator>.lessThan l < SKTSAC - 1
<operator>.preIncrement ++ l
<operator>.logicalNot ! KRSM
<operator>.assignment k = 0
<operator>.assignment l = 0
<operator>.logicalOr ( CEUC [ k ] [ 0 ] == VYE [ SKTSAC - 1 ] && CEUC [ k ] [ 1 ] == VYE [ SKTSAC - 2 ] ) || ( CEUC [ k ] [ 1 ] == VYE [ SKTSAC - 1 ] && CEUC [ k ] [ 0 ] == VYE [ SKTSAC - 2 ] )
<operator>.subtraction SKTSAC - 1
<operator>.lessThan k < d
<operator>.preIncrement ++ k
IDENTIFIER KRSM if (KRSM)
<operator>.assignment KRSM = 1
<operator>.assignment VYE [ SKTSAC - 2 ] = CEUC [ k ] [ 2 ]
<operator>.preDecrement -- SKTSAC
<operator>.assignment k = 0
<operator>.assignment SKTSAC = 0
<operator>.logicalAnd CEUC [ k ] [ 0 ] == VYE [ SKTSAC - 1 ] && CEUC [ k ] [ 1 ] == VYE [ SKTSAC - 2 ]
<operator>.logicalAnd CEUC [ k ] [ 1 ] == VYE [ SKTSAC - 1 ] && CEUC [ k ] [ 0 ] == VYE [ SKTSAC - 2 ]
<operator>.logicalOr ( NHQU [ k ] [ 0 ] == VYE [ SKTSAC - 1 ] && NHQU [ k ] [ 1 ] == VYE [ l ] ) || ( NHQU [ k ] [ 1 ] == VYE [ SKTSAC - 1 ] && NHQU [ k ] [ 0 ] == VYE [ l ] )
<operator>.equals CEUC [ k ] [ 0 ] == VYE [ SKTSAC - 1 ]
<operator>.equals CEUC [ k ] [ 1 ] == VYE [ SKTSAC - 2 ]
<operator>.equals CEUC [ k ] [ 1 ] == VYE [ SKTSAC - 1 ]
<operator>.equals CEUC [ k ] [ 0 ] == VYE [ SKTSAC - 2 ]
<operator>.assignment KRSM = 1
<operator>.subtraction SKTSAC - 2
<operator>.logicalAnd NHQU [ k ] [ 0 ] == VYE [ SKTSAC - 1 ] && NHQU [ k ] [ 1 ] == VYE [ l ]
<operator>.logicalAnd NHQU [ k ] [ 1 ] == VYE [ SKTSAC - 1 ] && NHQU [ k ] [ 0 ] == VYE [ l ]
<operator>.subtraction SKTSAC - 1
<operator>.subtraction SKTSAC - 2
<operator>.subtraction SKTSAC - 1
<operator>.subtraction SKTSAC - 2
<operator>.equals NHQU [ k ] [ 0 ] == VYE [ SKTSAC - 1 ]
<operator>.equals NHQU [ k ] [ 1 ] == VYE [ l ]
<operator>.equals NHQU [ k ] [ 1 ] == VYE [ SKTSAC - 1 ]
<operator>.equals NHQU [ k ] [ 0 ] == VYE [ l ]
<operator>.subtraction SKTSAC - 1
<operator>.subtraction SKTSAC - 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess CEUC [ j ]
<operator>.indirectIndexAccess NHQU [ k ]
<operator>.indirectIndexAccess VYE [ SKTSAC ]
<operator>.indirectIndexAccess HFC [ j ]
<operator>.indirectIndexAccess VYE [ l ]
<operator>.indirectIndexAccess VYE [ SKTSAC - 2 ]
<operator>.indirectIndexAccess CEUC [ k ] [ 2 ]
<operator>.indirectIndexAccess CEUC [ k ] [ 0 ]
<operator>.indirectIndexAccess VYE [ SKTSAC - 1 ]
<operator>.indirectIndexAccess CEUC [ k ] [ 1 ]
<operator>.indirectIndexAccess VYE [ SKTSAC - 2 ]
<operator>.indirectIndexAccess CEUC [ k ] [ 1 ]
<operator>.indirectIndexAccess VYE [ SKTSAC - 1 ]
<operator>.indirectIndexAccess CEUC [ k ] [ 0 ]
<operator>.indirectIndexAccess VYE [ SKTSAC - 2 ]
<operator>.indirectIndexAccess CEUC [ k ]
<operator>.indirectIndexAccess CEUC [ k ]
<operator>.indirectIndexAccess CEUC [ k ]
<operator>.indirectIndexAccess CEUC [ k ]
<operator>.indirectIndexAccess CEUC [ k ]
<operator>.indirectIndexAccess NHQU [ k ] [ 0 ]
<operator>.indirectIndexAccess VYE [ SKTSAC - 1 ]
<operator>.indirectIndexAccess NHQU [ k ] [ 1 ]
<operator>.indirectIndexAccess VYE [ l ]
<operator>.indirectIndexAccess NHQU [ k ] [ 1 ]
<operator>.indirectIndexAccess VYE [ SKTSAC - 1 ]
<operator>.indirectIndexAccess NHQU [ k ] [ 0 ]
<operator>.indirectIndexAccess VYE [ l ]
<operator>.indirectIndexAccess NHQU [ k ]
<operator>.indirectIndexAccess NHQU [ k ]
<operator>.indirectIndexAccess NHQU [ k ]
<operator>.indirectIndexAccess NHQU [ k ]
>>>PDG&114 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->49 0->50 0->51 0->52 0->53 0->55 0->56 0->57 0->65 0->66 0->69 0->70 0->71 0->72 0->77 0->78 2->1 3->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->10 5->11 5->12 5->13 5->14 5->14 5->15 5->16 5->17 5->19 5->21 5->23 5->25 5->27 5->29 5->32 5->32 5->33 5->79 5->80 5->81 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->17 9->40 10->1 10->23 10->31 11->1 11->1 11->19 11->50 12->1 12->1 12->21 13->1 13->1 13->30 14->1 14->1 15->1 16->1 17->1 17->1 17->9 17->17 17->18 17->18 17->26 17->40 17->82 18->1 18->17 19->1 19->1 19->1 19->11 19->19 19->20 19->20 19->28 19->50 19->83 20->1 20->19 21->1 21->1 21->1 21->12 21->21 21->22 21->22 21->30 21->31 21->39 21->84 21->85 22->1 22->21 23->1 23->1 23->1 23->23 23->24 23->34 23->36 23->36 23->86 24->1 24->23 25->17 26->1 26->1 27->1 27->19 28->1 28->1 29->1 29->21 30->1 30->1 30->1 31->1 31->23 31->39 33->1 33->23 34->1 34->1 34->74 34->76 36->1 36->24 36->38 37->1 37->1 37->45 38->1 39->1 39->23 39->31 39->37 39->39 39->40 39->43 39->45 39->46 39->47 39->49 39->49 39->69 40->1 40->1 40->1 40->9 40->17 40->41 40->48 40->58 40->61 40->69 40->89 40->90 40->98 41->1 41->40 43->1 43->1 43->43 43->44 43->44 43->49 43->50 43->56 43->57 44->1 44->43 45->1 45->1 45->39 46->1 46->40 47->43 48->1 48->1 48->1 48->40 48->41 48->53 48->54 48->55 48->66 48->87 48->88 48->97 49->23 49->31 49->39 49->43 49->43 49->77 50->1 50->1 50->1 50->11 50->19 50->51 50->60 50->67 50->73 50->77 50->102 50->103 50->110 51->1 51->50 53->1 53->1 53->45 54->1 54->1 54->1 54->62 54->64 55->1 55->23 55->31 55->39 55->49 56->1 56->50 57->1 57->23 57->31 57->39 58->1 58->1 58->48 58->48 58->59 58->63 58->71 58->93 58->94 58->100 59->1 59->1 59->48 59->48 60->1 60->1 60->1 60->50 60->51 60->65 61->1 61->1 61->58 61->58 61->62 61->63 61->64 61->70 61->73 61->91 61->92 61->99 62->1 62->1 62->58 62->58 62->63 62->64 63->1 63->1 63->59 63->59 63->61 63->62 63->64 63->72 63->73 63->95 63->96 63->101 64->1 64->1 64->59 64->59 64->61 64->62 65->1 65->45 66->55 67->1 67->1 67->60 67->60 67->68 67->75 67->78 67->106 67->107 67->112 68->1 68->1 68->60 68->60 69->23 69->31 69->39 69->49 69->66 69->70 69->71 70->23 70->31 70->39 70->49 70->66 70->69 70->71 71->23 71->31 71->39 71->49 71->66 71->69 71->72 72->23 72->31 72->39 72->49 72->66 72->69 73->1 73->1 73->28 73->61 73->67 73->67 73->74 73->75 73->76 73->104 73->105 73->111 74->1 74->1 74->28 74->34 74->67 74->67 74->75 74->76 75->1 75->1 75->28 75->61 75->68 75->68 75->73 75->74 75->76 75->108 75->109 75->113 76->1 76->1 76->28 76->34 76->68 76->68 76->73 76->74 77->49 77->78 78->49 78->77
>>>Token int main ( ) { PAMK ( ) ; int t , i , j , k , l , c , d , n ; LENWR ( " " , & t ) ; for ( i = 0 ; i < t ; ++ i ) { LENWR ( " " , & c ) ; char CEUC [ 40 ] [ 4 ] ; char NHQU [ 30 ] [ 3 ] ; char HFC [ 101 ] ; char VYE [ 101 ] ; int SKTSAC = 0 ; int KRSM ; for ( j = 0 ; j < c ; ++ j ) { LENWR ( " " , CEUC [ j ] ) ; } LENWR ( " " , & d ) ; for ( k = 0 ; k < d ; ++ k ) { LENWR ( " " , NHQU [ k ] ) ; } LENWR ( " " , & n ) ; LENWR ( " " , HFC ) ; for ( j = 0 ; j < n ; ++ j ) { VYE [ SKTSAC ] = HFC [ j ] ; ++ SKTSAC ; while ( 1 ) { if ( SKTSAC < 2 ) { break ; } KRSM = 0 ; for ( k = 0 ; k < c ; ++ k ) { if ( ( CEUC [ k ] [ 0 ] == VYE [ SKTSAC - 1 ] && CEUC [ k ] [ 1 ] == VYE [ SKTSAC - 2 ] ) || ( CEUC [ k ] [ 1 ] == VYE [ SKTSAC - 1 ] && CEUC [ k ] [ 0 ] == VYE [ SKTSAC - 2 ] ) ) { KRSM = 1 ; VYE [ SKTSAC - 2 ] = CEUC [ k ] [ 2 ] ; -- SKTSAC ; break ; } } if ( KRSM ) { continue ; } for ( l = 0 ; l < SKTSAC - 1 ; ++ l ) { for ( k = 0 ; k < d ; ++ k ) { if ( ( NHQU [ k ] [ 0 ] == VYE [ SKTSAC - 1 ] && NHQU [ k ] [ 1 ] == VYE [ l ] ) || ( NHQU [ k ] [ 1 ] == VYE [ SKTSAC - 1 ] && NHQU [ k ] [ 0 ] == VYE [ l ] ) ) { KRSM = 1 ; break ; } } if ( KRSM ) { SKTSAC = 0 ; break ; } } if ( ! KRSM ) { break ; } } } printf ( " " , i + 1 ) ; printf ( " " ) ; for ( l = 0 ; l < SKTSAC ; ++ l ) { if ( l != 0 ) { printf ( " " ) ; } printf ( " " , VYE [ l ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment * LURYOXLPOYNOUS = NULL
<operator>.assignment * UKRICPSO = NULL
<operator>.assignment * DOERAISCJPOBYQSTHUXI = NULL
CKBTDFPMNKNSATL CKBTDFPMNKNSATL ( & argc , & argv )
CEGGNXUQWNLSUHQF CEGGNXUQWNLSUHQF ( argv [ 0 ] )
LDHFHOWTF LDHFHOWTF ( IKXKGL , "" )
MLTUBSPSRDELXN MLTUBSPSRDELXN ( EDYIMGP , CELHMVHWF )
VLSRGTKXOF VLSRGTKXOF ( EDYIMGP )
DVQBJU DVQBJU ( GJDVPSAVHJID )
<operator>.assignment UWCATRV = LYFUTOOFPHK
<operator>.assignment VHKIJMGIOGEJEPGVR = ( argc <= EKUQCN || ( EKUQCN + 1 < argc && argv [ EKUQCN + 1 ] [ 0 ] == 'p' ) ? 2 : 4 )
RETURN return EXIT_SUCCESS ; return EXIT_SUCCESS ;
<operator>.notEquals ( ISNR = SHIOUBHDXTD ( argc , argv , "m:Z" , MYGIRHUN , NULL ) ) != - 1
IDENTIFIER LURYOXLPOYNOUS if (LURYOXLPOYNOUS)
<operator>.lessThan argc - EKUQCN < VHKIJMGIOGEJEPGVR
<operator>.lessThan VHKIJMGIOGEJEPGVR < argc - EKUQCN
IDENTIFIER UKRICPSO if (UKRICPSO)
<operator>.logicalAnd LURYOXLPOYNOUS && KWFFFK ( argv [ EKUQCN ] , UWCATRV ) != 0
IDENTIFIER EXIT_SUCCESS return EXIT_SUCCESS ;
<operator>.assignment * DHRTXX = MGKNDWJTTJMS ( LURYOXLPOYNOUS )
<operator>.assignment BUMSPVAQWAF = BAWJI ( 0 )
BAWJI BAWJI ( BUMSPVAQWAF )
<operator>.assignment UWCATRV = WGGICKRTEQT ( UWCATRV , false , BUMSPVAQWAF , DHRTXX , NULL )
free free ( DHRTXX )
<operator>.conditional argc <= EKUQCN || ( EKUQCN + 1 < argc && argv [ EKUQCN + 1 ] [ 0 ] == 'p' ) ? 2 : 4
SYTMO SYTMO ( EXIT_FAILURE )
XIHFX XIHFX ( 0   0   _ ( "extra operand %s" )   SDKCN ( argv [ EKUQCN + VHKIJMGIOGEJEPGVR ] ) )
SYTMO SYTMO ( EXIT_FAILURE )
<operator>.assignment HKT = 0
LITERAL 'b' <empty>
<operator>.lessThan MRQ <RFAMIAL
<operator>.greaterThan ';'> ( EXIT_FAILURE   0   _ ( "block special files not supported" ) )
<operator>.assignment UTDMKCAAY = WUVGBPV
IDENTIFIER TTHM <empty>
LITERAL 'c' <empty>
LITERAL 'u' <empty>
<operator>.lessThan MRQ <RFAMIAL
<operator>.greaterThan ';'> ( EXIT_FAILURE   0   _ ( "character special files not supported" ) )
<operator>.assignment UTDMKCAAY = DOSLQGK
IDENTIFIER TTHM <empty>
BLOCK <empty> <empty>
LITERAL 'p' <empty>
XIHFX XIHFX ( 0   0   _ ( "invalid device type %s" )   SDKCN ( argv [ EKUQCN + 1 ] ) )
SYTMO SYTMO ( EXIT_FAILURE )
MRQ MRQ ( EXIT_FAILURE   MFGDP   _ ( "cannot set permissions of %s" )   KRGVYMI ( argv [ EKUQCN ] ) )
<operator>.assignment ISNR = SHIOUBHDXTD ( argc , argv , "m:Z" , MYGIRHUN , NULL )
<operator>.minus - 1
IDENTIFIER ISNR switch(ISNR)
<operator>.logicalNot ! DHRTXX
<operator>.and UWCATRV & ~ SYFHCESVA
<operator>.logicalOr argc <= EKUQCN || ( EKUQCN + 1 < argc && argv [ EKUQCN + 1 ] [ 0 ] == 'p' )
<operator>.subtraction argc - EKUQCN
<operator>.lessEqualsThan argc <= EKUQCN
<operator>.logicalAnd VHKIJMGIOGEJEPGVR == 4 && argc - EKUQCN == 2
<operator>.subtraction argc - EKUQCN
<operator>.logicalAnd VHKIJMGIOGEJEPGVR == 2 && argc - EKUQCN == 4
OUVXFBQPMIKNRQNN OUVXFBQPMIKNRQNN ( )
<operator>.lessThan HKT < 0
<operator>.assignment * UGGQPVM = argv [ EKUQCN + 2 ]
<operator>.assignment * OOWQSYB = argv [ EKUQCN + 3 ]
<operator>.assignment AXDKHQ = OVOGWLM ( SPGMDYS , NVBUMRS )
IDENTIFIER TTHM <empty>
IDENTIFIER DOERAISCJPOBYQSTHUXI if (DOERAISCJPOBYQSTHUXI)
<operator>.notEquals PLMWIF ( argv [ EKUQCN ] , UWCATRV ) != 0
<operator>.notEquals KWFFFK ( argv [ EKUQCN ] , UWCATRV ) != 0
SHIOUBHDXTD SHIOUBHDXTD ( argc , argv , "m:Z" , MYGIRHUN , NULL )
LITERAL 'm' <empty>
<operator>.assignment LURYOXLPOYNOUS = QGSOXO
LITERAL 'Z' <empty>
GFGNFSSLVKMHGWNRPRLOHSJT GFGNFSSLVKMHGWNRPRLOHSJT ( LBQDJNBRSHFA , AAMYMBG )
SYTMO SYTMO ( EXIT_FAILURE )
MGKNDWJTTJMS MGKNDWJTTJMS ( LURYOXLPOYNOUS )
MRQ MRQ ( EXIT_FAILURE   0   _ ( "invalid mode" ) )
BAWJI BAWJI ( 0 )
WGGICKRTEQT WGGICKRTEQT ( UWCATRV , false , BUMSPVAQWAF , DHRTXX , NULL )
MRQ MRQ ( EXIT_FAILURE   0   _ ( "mode must specify only file permission bits" ) )
<operator>.lessEqualsThan argc <= EKUQCN
<operator>.logicalAnd EKUQCN + 1 < argc && argv [ EKUQCN + 1 ] [ 0 ] == 'p'
XIHFX XIHFX ( 0   0   _ ( "missing operand" ) )
fprintf fprintf ( stderr   "%s\n"   _ ( "Special files require major and minor device numbers." ) )
_ _ ( "extra operand %s" )
SDKCN SDKCN ( argv [ EKUQCN + VHKIJMGIOGEJEPGVR ] )
fprintf fprintf ( stderr   "%s\n"   _ ( "Fifos do not have major and minor device numbers." ) )
<operator>.assignment HKT = SMEKILDFECMNHQIDRNQMESBY ( UKRICPSO )
MRQ MRQ ( EXIT_FAILURE   MFGDP   _ ( "failed to set default file creation context to %s" )   SDKCN ( UKRICPSO ) )
<operator>.addition EKUQCN + 1
<operator>.bracketedPrimary ( EXIT_FAILURE   0   _ ( "block special files not supported" ) )
<operator>.bracketedPrimary ( EXIT_FAILURE   0   _ ( "character special files not supported" ) )
<operator>.logicalOr JWVVJMRYUE ( UGGQPVM , NULL , 0 , & SPGMDYS , "" ) != EWWSSBPGUI || SPGMDYS != ( GDRFFTF ) SPGMDYS
<operator>.logicalOr JWVVJMRYUE ( OOWQSYB , NULL , 0 , & NVBUMRS , "" ) != EWWSSBPGUI || NVBUMRS != ( KENDPKY ) NVBUMRS
IDENTIFIER DOERAISCJPOBYQSTHUXI if (DOERAISCJPOBYQSTHUXI)
<operator>.notEquals MSIFG ( argv [ EKUQCN ] , UWCATRV | UTDMKCAAY , AXDKHQ ) != 0
HUQLMXSGFF HUQLMXSGFF ( DOERAISCJPOBYQSTHUXI , argv [ EKUQCN ] , MQCXCYC )
MRQ MRQ ( EXIT_FAILURE   MFGDP   "%s"   KVCBEA ( argv [ EKUQCN ] ) )
_ _ ( "invalid device type %s" )
SDKCN SDKCN ( argv [ EKUQCN + 1 ] )
KWFFFK KWFFFK ( argv [ EKUQCN ] , UWCATRV )
_ _ ( "cannot set permissions of %s" )
KRGVYMI KRGVYMI ( argv [ EKUQCN ] )
OUVXFBQPMIKNRQNN OUVXFBQPMIKNRQNN ( )
<operator>.not ~ SYFHCESVA
<operator>.lessThan EKUQCN + 1 < argc
<operator>.equals argv [ EKUQCN + 1 ] [ 0 ] == 'p'
XIHFX XIHFX ( 0   0   _ ( "missing operand after %s" )   SDKCN ( argv [ argc - 1 ] ) )
<operator>.equals VHKIJMGIOGEJEPGVR == 4
<operator>.equals argc - EKUQCN == 2
<operator>.equals VHKIJMGIOGEJEPGVR == 2
<operator>.equals argc - EKUQCN == 4
<operator>.assignment HKT = XNDLXNIQCODLAJ ( UKRICPSO )
<operator>.expressionList EXIT_FAILURE   0   _ ( "block special files not supported" )
<operator>.expressionList EXIT_FAILURE   0   _ ( "character special files not supported" )
MRQ MRQ ( EXIT_FAILURE   0   _ ( "invalid major device number %s" )   SDKCN ( UGGQPVM ) )
MRQ MRQ ( EXIT_FAILURE   0   _ ( "invalid minor device number %s" )   SDKCN ( OOWQSYB ) )
OVOGWLM OVOGWLM ( SPGMDYS , NVBUMRS )
MRQ MRQ ( EXIT_FAILURE   0   _ ( "invalid device %s %s" ) , UGGQPVM , OOWQSYB )
HUQLMXSGFF HUQLMXSGFF ( DOERAISCJPOBYQSTHUXI , argv [ EKUQCN ] , UTDMKCAAY )
MRQ MRQ ( EXIT_FAILURE   MFGDP   "%s"   KVCBEA ( argv [ EKUQCN ] ) )
PLMWIF PLMWIF ( argv [ EKUQCN ] , UWCATRV )
<operator>.assignment UKRICPSO = QGSOXO
_ _ ( "invalid mode" )
_ _ ( "mode must specify only file permission bits" )
<operator>.addition EKUQCN + 1
_ _ ( "missing operand" )
<operator>.subtraction argc - EKUQCN
_ _ ( "Special files require major and minor device numbers." )
<operator>.addition EKUQCN + VHKIJMGIOGEJEPGVR
<operator>.subtraction argc - EKUQCN
_ _ ( "Fifos do not have major and minor device numbers." )
SMEKILDFECMNHQIDRNQMESBY SMEKILDFECMNHQIDRNQMESBY ( UKRICPSO )
_ _ ( "failed to set default file creation context to %s" )
SDKCN SDKCN ( UKRICPSO )
_ _ ( "block special files not supported" )
_ _ ( "character special files not supported" )
<operator>.addition EKUQCN + 2
<operator>.addition EKUQCN + 3
<operator>.notEquals JWVVJMRYUE ( UGGQPVM , NULL , 0 , & SPGMDYS , "" ) != EWWSSBPGUI
<operator>.notEquals SPGMDYS != ( GDRFFTF ) SPGMDYS
<operator>.notEquals JWVVJMRYUE ( OOWQSYB , NULL , 0 , & NVBUMRS , "" ) != EWWSSBPGUI
<operator>.notEquals NVBUMRS != ( KENDPKY ) NVBUMRS
MSIFG MSIFG ( argv [ EKUQCN ] , UWCATRV | UTDMKCAAY , AXDKHQ )
KVCBEA KVCBEA ( argv [ EKUQCN ] )
<operator>.addition EKUQCN + 1
_ _ ( "missing operand after %s" )
SDKCN SDKCN ( argv [ argc - 1 ] )
XNDLXNIQCODLAJ XNDLXNIQCODLAJ ( UKRICPSO )
JWVVJMRYUE JWVVJMRYUE ( UGGQPVM , NULL , 0 , & SPGMDYS , "" )
<operator>.cast ( GDRFFTF ) SPGMDYS
_ _ ( "invalid major device number %s" )
SDKCN SDKCN ( UGGQPVM )
JWVVJMRYUE JWVVJMRYUE ( OOWQSYB , NULL , 0 , & NVBUMRS , "" )
<operator>.cast ( KENDPKY ) NVBUMRS
_ _ ( "invalid minor device number %s" )
SDKCN SDKCN ( OOWQSYB )
_ _ ( "invalid device %s %s" )
<operator>.or UWCATRV | UTDMKCAAY
KVCBEA KVCBEA ( argv [ EKUQCN ] )
<operator>.greaterThan TBNBLFKIUDOORNFGIB ( ) > 0
<operator>.addition EKUQCN + 1
<operator>.subtraction argc - 1
IDENTIFIER QGSOXO if (QGSOXO)
<operator>.assignment UKRICPSO = QGSOXO
IDENTIFIER QGSOXO if (QGSOXO)
<operator>.assignment DOERAISCJPOBYQSTHUXI = GPCAFOKSFCJU ( PFXFGKNTSIWKYPXE , NULL , 0 )
XIHFX XIHFX ( 0   0   _ ( "warning: ignoring --context; " "it requires an SELinux/SMACK-enabled kernel" ) )
<operator>.logicalNot ! DOERAISCJPOBYQSTHUXI
GPCAFOKSFCJU GPCAFOKSFCJU ( PFXFGKNTSIWKYPXE , NULL , 0 )
XIHFX XIHFX ( 0   MFGDP   _ ( "warning: ignoring --context" ) )
_ _ ( "warning: ignoring --context; " "it requires an SELinux/SMACK-enabled kernel" )
_ _ ( "warning: ignoring --context" )
<operator>.indirectIndexAccess argv [ EKUQCN + 1 ] [ 0 ]
UNKNOWN V V
UNKNOWN L L
UNKNOWN M M
UNKNOWN K K
UNKNOWN L L
UNKNOWN M M
UNKNOWN K K
UNKNOWN M M
<operator>.indirectIndexAccess argv [ EKUQCN + VHKIJMGIOGEJEPGVR ]
<operator>.indirectIndexAccess argv [ EKUQCN + 2 ]
<operator>.indirectIndexAccess argv [ EKUQCN + 3 ]
UNKNOWN AXDKHQ == <RFAMIAL ';'> UCMMK AXDKHQ == <RFAMIAL ';'> UCMMK
<operator>.indirectIndexAccess argv [ EKUQCN + 1 ]
<operator>.indirectIndexAccess argv [ EKUQCN ]
<operator>.indirectIndexAccess argv [ EKUQCN + 1 ] [ 0 ]
<operator>.indirectIndexAccess argv [ EKUQCN ]
<operator>.indirectIndexAccess argv [ EKUQCN ]
<operator>.indirectIndexAccess argv [ EKUQCN + 1 ]
<operator>.indirectIndexAccess argv [ EKUQCN ]
<operator>.indirectIndexAccess argv [ EKUQCN ]
<operator>.indirectIndexAccess argv [ EKUQCN ]
<operator>.indirectIndexAccess argv [ argc - 1 ]
<operator>.addressOf & SPGMDYS
UNKNOWN GDRFFTF GDRFFTF
<operator>.addressOf & NVBUMRS
UNKNOWN KENDPKY KENDPKY
<operator>.indirectIndexAccess argv [ EKUQCN ]
TBNBLFKIUDOORNFGIB TBNBLFKIUDOORNFGIB ( )
>>>PDG&202 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->25 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->53 0->55 0->56 0->58 0->60 0->61 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->82 0->83 0->84 0->86 0->88 0->89 0->94 0->95 0->96 0->97 0->98 0->100 0->101 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->127 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->138 0->139 0->140 0->141 0->142 0->143 0->145 0->146 0->148 0->149 0->150 0->151 0->152 0->153 0->154 0->155 0->156 0->157 0->158 0->160 0->161 0->162 0->163 0->164 0->165 0->167 0->168 0->169 0->170 0->171 0->172 2->7 2->69 3->7 3->8 3->69 4->1 4->21 4->75 5->1 5->1 5->132 5->148 6->1 6->1 6->96 6->119 7->1 7->1 7->1 7->55 7->56 7->58 7->69 7->69 7->80 7->105 7->127 7->130 7->162 8->1 8->1 8->69 9->1 9->1 10->1 10->1 10->11 11->1 11->1 12->1 12->1 13->1 13->1 13->1 13->78 13->100 13->121 13->158 14->1 14->1 14->18 15->1 16->1 16->1 16->1 16->16 16->49 16->50 16->69 16->71 16->74 16->103 18->1 18->19 18->29 18->56 18->57 18->108 18->108 19->1 19->1 19->1 19->30 19->31 19->59 19->84 19->85 19->110 19->110 19->129 19->129 19->182 21->1 21->1 21->1 21->48 21->101 21->102 21->187 22->15 23->1 23->1 23->52 24->1 24->1 24->25 25->1 25->78 26->1 26->1 26->53 27->1 28->1 29->1 29->1 29->31 29->47 29->48 29->88 29->97 29->113 29->114 30->1 30->1 30->1 31->1 31->1 31->47 31->48 31->88 31->97 31->113 31->114 32->1 34->1 34->1 34->1 35->1 35->1 36->1 36->1 36->119 36->158 40->1 40->1 40->1 41->1 41->1 42->1 42->1 42->119 42->158 46->1 46->1 46->1 47->1 47->1 47->48 48->1 48->1 48->1 48->1 48->1 49->1 49->1 49->16 50->16 52->1 52->76 52->78 52->123 53->1 53->1 53->1 53->79 53->100 53->121 53->124 53->158 54->1 54->1 55->18 55->18 55->56 55->56 55->58 55->58 56->1 56->58 56->58 56->82 56->107 56->126 56->127 56->127 56->146 56->147 56->162 56->162 56->195 57->1 57->1 57->1 57->83 57->128 58->1 58->19 58->19 58->89 58->129 58->130 58->130 58->137 58->138 58->145 59->1 59->1 59->1 59->86 59->131 60->1 60->87 60->112 60->132 60->148 61->1 61->1 61->88 61->133 61->134 62->1 62->1 62->149 63->1 63->1 63->153 64->1 64->1 64->143 67->1 67->1 67->97 67->144 67->194 68->1 68->21 68->21 69->1 69->1 69->1 69->16 69->16 69->16 69->16 69->16 69->49 69->49 69->49 69->49 69->49 69->62 69->63 69->78 69->80 69->85 69->96 69->99 69->100 69->102 69->119 69->121 69->143 69->144 69->147 69->149 69->159 69->169 71->1 71->1 71->21 71->75 73->1 73->1 73->1 74->1 74->1 74->29 74->31 74->47 74->48 74->76 74->79 74->88 74->97 74->113 74->114 75->21 75->23 76->1 76->1 76->1 76->29 76->31 76->47 76->48 76->79 76->88 76->97 76->113 76->114 77->24 78->1 78->1 78->1 78->26 78->26 78->26 78->26 78->26 78->27 78->149 79->1 79->1 79->1 79->29 79->31 79->47 79->48 79->88 79->97 79->113 79->114 80->54 80->54 80->55 80->55 80->81 80->105 80->105 80->105 80->125 80->125 80->161 81->1 81->1 81->54 81->54 82->1 82->1 83->1 83->1 83->1 83->86 84->30 85->1 85->30 86->1 86->1 86->1 87->1 87->1 87->61 88->1 88->1 88->1 88->1 88->1 88->47 88->48 88->48 88->97 88->97 88->113 88->114 88->120 89->1 90->1 90->35 91->1 91->41 92->1 92->1 92->1 92->115 92->151 92->152 93->1 93->1 93->1 93->116 93->155 93->156 95->1 95->1 95->120 95->159 95->200 96->1 96->1 96->1 96->121 97->1 97->1 97->1 97->1 97->48 97->48 98->46 99->1 99->46 100->1 100->1 100->68 100->68 100->102 101->48 102->1 102->48 103->1 103->122 103->160 103->201 104->1 104->53 105->55 105->81 105->81 105->106 105->161 105->188 105->191 106->1 106->81 106->81 106->99 107->1 107->1 107->1 108->19 108->57 108->57 108->109 108->127 109->57 109->57 110->1 110->59 110->59 110->111 110->130 111->1 111->59 111->59 112->1 112->1 112->61 113->1 113->1 113->48 113->90 113->90 113->90 113->115 113->116 113->118 113->120 114->1 114->1 114->48 114->91 114->91 114->91 114->115 114->116 114->118 114->120 115->1 115->1 115->1 115->1 115->48 115->116 115->118 115->120 116->1 116->1 116->1 116->1 116->48 116->118 116->120 117->1 117->1 117->64 117->64 118->1 118->1 118->1 118->1 118->1 118->48 118->120 119->1 119->1 119->143 119->158 120->1 120->1 120->1 120->1 120->48 120->48 121->1 121->1 121->67 121->67 121->100 121->100 121->102 121->144 122->1 122->1 122->1 122->132 122->148 123->76 124->79 126->82 127->58 127->58 127->109 127->109 128->83 130->1 130->89 130->111 130->111 130->137 130->138 130->145 131->86 132->1 132->87 132->134 133->88 134->1 134->88 135->113 136->114 138->1 139->1 139->92 139->92 139->140 139->141 139->150 139->197 140->1 140->92 140->92 140->117 141->1 141->1 141->93 141->93 141->142 141->154 141->199 142->1 142->93 142->93 142->117 143->1 143->1 143->1 143->95 143->95 143->95 143->100 143->102 143->159 144->1 144->97 144->100 144->102 145->1 146->107 147->1 147->107 148->1 148->112 148->134 149->1 149->1 149->117 149->118 149->139 149->139 149->139 149->139 149->139 149->140 149->150 149->152 149->153 151->115 152->1 152->115 152->118 153->1 153->1 153->1 153->117 153->118 153->141 153->141 153->141 153->141 153->141 153->142 153->154 153->156 155->116 156->1 156->116 156->118 157->118 158->1 158->1 158->100 158->143 158->143 159->1 159->100 159->102 159->120 160->1 160->1 160->164 160->166 160->167 160->168 160->169 160->171 162->58 162->127 164->1 164->1 164->1 164->132 164->148 166->1 166->1 166->168 167->1 167->1 168->1 168->1 168->96 168->119 168->170 168->172 169->1 169->69 169->166 169->166 169->166 170->1 170->1 170->1 170->48 170->88 170->97 170->120 171->167 172->170 173->34 173->35 173->36 173->40 173->41 173->42 173->46 173->47 173->62 173->63 173->64 173->67 173->90 173->91 173->92 173->93 173->95 173->96 173->98 173->99 173->113 173->114 173->117 173->119 173->121 173->135 173->136 173->137 173->138 173->139 173->141 173->143 173->145 173->149 173->153 173->158 173->174 173->175 173->176 173->177 173->178 173->179 173->180 173->181 173->183 173->184 173->185 173->186 173->189 173->190 173->192 173->193 173->196 173->198 185->118 185->157
>>>Token int main ( int argc , char * * argv ) { DTSKBA UWCATRV ; char const * LURYOXLPOYNOUS = NULL ; int ISNR ; size_t VHKIJMGIOGEJEPGVR ; DTSKBA UTDMKCAAY ; char const * UKRICPSO = NULL ; struct AEBGMSPQCTJISB * DOERAISCJPOBYQSTHUXI = NULL ; CKBTDFPMNKNSATL ( & argc , & argv ) ; CEGGNXUQWNLSUHQF ( argv [ 0 ] ) ; LDHFHOWTF ( IKXKGL , " " ) ; MLTUBSPSRDELXN ( EDYIMGP , CELHMVHWF ) ; VLSRGTKXOF ( EDYIMGP ) ; DVQBJU ( GJDVPSAVHJID ) ; while ( ( ISNR = SHIOUBHDXTD ( argc , argv , " " , MYGIRHUN , NULL ) ) != - 1 ) { switch ( ISNR ) { case ' ' : LURYOXLPOYNOUS = QGSOXO ; break ; case ' ' : if ( OUVXFBQPMIKNRQNN ( ) ) { UKRICPSO = QGSOXO ; } else if ( TBNBLFKIUDOORNFGIB ( ) > 0 ) { if ( QGSOXO ) UKRICPSO = QGSOXO ; else { DOERAISCJPOBYQSTHUXI = GPCAFOKSFCJU ( PFXFGKNTSIWKYPXE , NULL , 0 ) ; if ( ! DOERAISCJPOBYQSTHUXI ) XIHFX ( 0 , MFGDP , _ ( " " ) ) ; } } else if ( QGSOXO ) { XIHFX ( 0 , 0 , _ ( " " " " ) ) ; } break ; YITKELPCRYOHSKPPWRHUV ; GFGNFSSLVKMHGWNRPRLOHSJT ( LBQDJNBRSHFA , AAMYMBG ) ; default : SYTMO ( EXIT_FAILURE ) ; } } UWCATRV = LYFUTOOFPHK ; if ( LURYOXLPOYNOUS ) { DTSKBA BUMSPVAQWAF ; struct XMGEHHXUVLV * DHRTXX = MGKNDWJTTJMS ( LURYOXLPOYNOUS ) ; if ( ! DHRTXX ) MRQ ( EXIT_FAILURE , 0 , _ ( " " ) ) ; BUMSPVAQWAF = BAWJI ( 0 ) ; BAWJI ( BUMSPVAQWAF ) ; UWCATRV = WGGICKRTEQT ( UWCATRV , false , BUMSPVAQWAF , DHRTXX , NULL ) ; free ( DHRTXX ) ; if ( UWCATRV & ~ SYFHCESVA ) MRQ ( EXIT_FAILURE , 0 , _ ( " " ) ) ; } VHKIJMGIOGEJEPGVR = ( argc <= EKUQCN || ( EKUQCN + 1 < argc && argv [ EKUQCN + 1 ] [ 0 ] == ' ' ) ? 2 : 4 ) ; if ( argc - EKUQCN < VHKIJMGIOGEJEPGVR ) { if ( argc <= EKUQCN ) XIHFX ( 0 , 0 , _ ( " " ) ) ; else XIHFX ( 0 , 0 , _ ( " " ) , SDKCN ( argv [ argc - 1 ] ) ) ; if ( VHKIJMGIOGEJEPGVR == 4 && argc - EKUQCN == 2 ) fprintf ( stderr , " \n " , _ ( " " ) ) ; SYTMO ( EXIT_FAILURE ) ; } if ( VHKIJMGIOGEJEPGVR < argc - EKUQCN ) { XIHFX ( 0 , 0 , _ ( " " ) , SDKCN ( argv [ EKUQCN + VHKIJMGIOGEJEPGVR ] ) ) ; if ( VHKIJMGIOGEJEPGVR == 2 && argc - EKUQCN == 4 ) fprintf ( stderr , " \n " , _ ( " " ) ) ; SYTMO ( EXIT_FAILURE ) ; } if ( UKRICPSO ) { int HKT = 0 ; if ( OUVXFBQPMIKNRQNN ( ) ) HKT = SMEKILDFECMNHQIDRNQMESBY ( UKRICPSO ) ; else HKT = XNDLXNIQCODLAJ ( UKRICPSO ) ; if ( HKT < 0 ) MRQ ( EXIT_FAILURE , MFGDP , _ ( " " ) , SDKCN ( UKRICPSO ) ) ; } switch ( argv [ EKUQCN + 1 ] [ 0 ] ) { case ' ' : SHNF WUVGBPV  MRQ < RFAMIAL ' ' > ( EXIT_FAILURE , 0 , _ ( " " ) ) ; VDY UTDMKCAAY = WUVGBPV ; TTHM goto VYSJBCCIPHILGQOVMG ; case ' ' : case ' ' : SHNF DOSLQGK  MRQ < RFAMIAL ' ' > ( EXIT_FAILURE , 0 , _ ( " " ) ) ; VDY UTDMKCAAY = DOSLQGK ; TTHM goto VYSJBCCIPHILGQOVMG ; VYSJBCCIPHILGQOVMG : { char const * UGGQPVM = argv [ EKUQCN + 2 ] ; char const * OOWQSYB = argv [ EKUQCN + 3 ] ; KHLVNCKLQ SPGMDYS , NVBUMRS ; AIHWB AXDKHQ ; if ( JWVVJMRYUE ( UGGQPVM , NULL , 0 , & SPGMDYS , " " ) != EWWSSBPGUI || SPGMDYS != ( GDRFFTF ) SPGMDYS ) MRQ ( EXIT_FAILURE , 0 , _ ( " " ) , SDKCN ( UGGQPVM ) ) ; if ( JWVVJMRYUE ( OOWQSYB , NULL , 0 , & NVBUMRS , " " ) != EWWSSBPGUI || NVBUMRS != ( KENDPKY ) NVBUMRS ) MRQ ( EXIT_FAILURE , 0 , _ ( " " ) , SDKCN ( OOWQSYB ) ) ; AXDKHQ = OVOGWLM ( SPGMDYS , NVBUMRS ) ; CIL UCMMK  if ( AXDKHQ == < RFAMIAL ' ' > UCMMK ) MRQ ( EXIT_FAILURE , 0 , _ ( " " ) , UGGQPVM , OOWQSYB ) ; TTHM if ( DOERAISCJPOBYQSTHUXI )  HUQLMXSGFF ( DOERAISCJPOBYQSTHUXI , argv [ EKUQCN ] , UTDMKCAAY ) ; if ( MSIFG ( argv [ EKUQCN ] , UWCATRV | UTDMKCAAY , AXDKHQ ) != 0 ) MRQ ( EXIT_FAILURE , MFGDP , " " , KVCBEA ( argv [ EKUQCN ] ) ) ; } break ; case ' ' : if ( DOERAISCJPOBYQSTHUXI ) HUQLMXSGFF ( DOERAISCJPOBYQSTHUXI , argv [ EKUQCN ] , MQCXCYC ) ; if ( PLMWIF ( argv [ EKUQCN ] , UWCATRV ) != 0 ) MRQ ( EXIT_FAILURE , MFGDP , " " , KVCBEA ( argv [ EKUQCN ] ) ) ; break ; default : XIHFX ( 0 , 0 , _ ( " " ) , SDKCN ( argv [ EKUQCN + 1 ] ) ) ; SYTMO ( EXIT_FAILURE ) ; } if ( LURYOXLPOYNOUS && KWFFFK ( argv [ EKUQCN ] , UWCATRV ) != 0 ) MRQ ( EXIT_FAILURE , MFGDP , _ ( " " ) , KRGVYMI ( argv [ EKUQCN ] ) ) ; return EXIT_SUCCESS ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment in = UBYXL ( argv [ 1 ] , "r" )
<operator>.assignment YGG = UBYXL ( argv [ 2 ] , "w" )
EFGIAV EFGIAV ( in , " %d" , & XRTIDHX )
NKSVQQ NKSVQQ ( in )
NKSVQQ NKSVQQ ( YGG )
RETURN return 0 ; return 0 ;
<operator>.lessThan argc < 3
<operator>.lessThan i < XRTIDHX
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
fprintf fprintf ( stderr , "Wrong number of arguments!\n" )
exit exit ( 1 )
UBYXL UBYXL ( argv [ 1 ] , "r" )
UBYXL UBYXL ( argv [ 2 ] , "w" )
<operator>.assignment i = 0
EFGIAV EFGIAV ( in , " %d %d %d" , & p , & k , & PLJNUU )
fprintf fprintf ( YGG   "Case #%d: %lld\n"   i + 1   RXUCT ( p , k , PLJNUU , NMQW ) )
<operator>.lessThan j < PLJNUU
<operator>.postIncrement j ++
<operator>.assignment j = 0
EFGIAV EFGIAV ( in , " %d" , & NMQW [ j ] )
<operator>.addition i + 1
RXUCT RXUCT ( p , k , PLJNUU , NMQW )
<operator>.addressOf & p
<operator>.addressOf & k
<operator>.addressOf & PLJNUU
<operator>.addressOf & NMQW [ j ]
<operator>.indirectIndexAccess NMQW [ j ]
>>>PDG&32 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->10 3->1 3->16 3->17 4->1 4->1 4->6 5->1 5->1 5->8 5->20 6->1 6->1 6->7 6->11 6->19 7->1 7->1 8->1 8->1 9->1 10->1 10->1 10->14 10->15 11->1 11->1 11->1 11->11 11->12 11->12 11->19 11->20 11->20 11->21 11->23 11->25 11->25 11->26 11->27 11->28 11->29 12->1 12->11 13->9 14->1 14->1 16->1 16->4 16->4 17->1 17->5 17->5 18->1 18->11 19->1 19->1 19->1 19->1 19->7 19->21 19->24 19->26 19->26 19->26 20->1 20->1 20->1 20->8 21->1 21->1 21->21 21->22 21->22 21->24 21->26 21->30 21->31 22->1 22->21 23->1 23->21 24->1 24->1 24->7 24->19 24->26 26->1 26->1 26->1 26->1 26->19 26->19 26->19 26->20 26->20 26->20 26->20 26->21 26->24
>>>Token int main ( int argc , char * * argv ) { int i , j , XRTIDHX ; KTQH * in , * YGG ; if ( argc < 3 ) { fprintf ( stderr , " \n " ) ; exit ( 1 ) ; } in = UBYXL ( argv [ 1 ] , " " ) ; YGG = UBYXL ( argv [ 2 ] , " " ) ; EFGIAV ( in , " " , & XRTIDHX ) ; for ( i = 0 ; i < XRTIDHX ; i ++ ) { int p , k , PLJNUU ; int NMQW [ 1001 ] ; EFGIAV ( in , " " , & p , & k , & PLJNUU ) ; for ( j = 0 ; j < PLJNUU ; j ++ ) { EFGIAV ( in , " " , & NMQW [ j ] ) ; } fprintf ( YGG , " \n " , i + 1 , RXUCT ( p , k , PLJNUU , NMQW ) ) ; } NKSVQQ ( in ) ; NKSVQQ ( YGG ) ; return 0 ; }
>>>Func
METHOD TKKEMTIYMTE
METHOD_RETURN bool
PARAM struct DTNYQWAX * WRND
RETURN return WRND == NULL || XQTUODBVWNGCBC ( WRND -> MCPG , WRND -> JUCWV ) ; return WRND == NULL || XQTUODBVWNGCBC ( WRND -> MCPG , WRND -> JUCWV ) ;
<operator>.logicalOr WRND == NULL || XQTUODBVWNGCBC ( WRND -> MCPG , WRND -> JUCWV )
<operator>.equals WRND == NULL
XQTUODBVWNGCBC XQTUODBVWNGCBC ( WRND -> MCPG , WRND -> JUCWV )
<operator>.indirectFieldAccess WRND -> MCPG
<operator>.indirectFieldAccess WRND -> JUCWV
FIELD_IDENTIFIER MCPG MCPG
FIELD_IDENTIFIER JUCWV JUCWV
>>>PDG&11 0->2 0->5 2->5 3->1 4->1 4->1 4->1 4->3 5->1 5->1 5->4 5->4 5->6 5->7 5->8 5->9 5->10 6->1 6->1 6->4 6->4
>>>Token bool TKKEMTIYMTE ( struct DTNYQWAX * WRND ) { return WRND == NULL || XQTUODBVWNGCBC ( WRND -> MCPG , WRND -> JUCWV ) ; }
>>>Func
METHOD KVRO
METHOD_RETURN SSEFIXJ
PARAM const char * s
<operator>.assignment TSQB = 0
<operator>.assignment i = 0
RETURN return ( ( ( TSQB ^ 0xff ) + 1 ) & 0xff ) ; return ( ( ( TSQB ^ 0xff ) + 1 ) & 0xff ) ;
<operator>.notEquals s [ i ] != '\0'
<operator>.and ( ( TSQB ^ 0xff ) + 1 ) & 0xff
<operator>.assignment TSQB = ( TSQB + s [ i ] ) & 0xff
<operator>.postIncrement i ++
<operator>.addition ( TSQB ^ 0xff ) + 1
<operator>.and ( TSQB + s [ i ] ) & 0xff
<operator>.xor TSQB ^ 0xff
<operator>.addition TSQB + s [ i ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i ]
>>>PDG&16 0->2 0->3 0->4 0->6 0->7 0->9 0->10 0->11 0->12 0->13 2->1 2->6 2->11 2->13 3->1 3->11 3->12 3->13 4->1 4->1 4->9 5->1 6->1 6->1 6->6 6->8 6->9 6->11 6->11 6->13 6->13 6->14 6->15 7->1 7->1 7->5 8->1 8->1 8->11 8->12 8->13 9->1 9->1 10->1 11->1 11->8 11->8 12->1 12->7 12->7 12->10 12->10
>>>Token SSEFIXJ KVRO ( const char * s ) { SSEFIXJ TSQB = 0 ; size_t i = 0 ; while ( s [ i ] != ' \0 ' ) { TSQB = ( TSQB + s [ i ] ) & 0xff ; i ++ ; } return ( ( ( TSQB ^ 0xff ) + 1 ) & 0xff ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment * LURYOXLPOYNOUS = NULL
<operator>.assignment ISNRVHKIJMG = EXIT_SUCCESS
<operator>.assignment * JEPGVRUT = NULL
<operator>.assignment * OAEBGMSPQCTJISBDOERA = NULL
ISCJPOBYQSTHUXI ISCJPOBYQSTHUXI ( & argc , & argv )
CKBTDFPMNKNSATLC CKBTDFPMNKNSATLC ( argv [ 0 ] )
EGGNXUQWN EGGNXUQWN ( LSUHQF , "" )
LDHFHOWTFIKXKG LDHFHOWTFIKXKG ( LMLTUBS , PSRDELXNE )
DYIMGPCELH DYIMGPCELH ( LMLTUBS )
MVHWFV MVHWFV ( LSRGTKXOFDVQ )
<operator>.assignment UWCATRV = GKNDWJTTJMS
RETURN return ISNRVHKIJMG ; return ISNRVHKIJMG ;
<operator>.notEquals ( IOGE = BJUGJDVPSAV ( argc , argv , "m:Z" , HJIDSHIO , NULL ) ) != - 1
<operator>.equals HFAAAM == argc
IDENTIFIER JEPGVRUT if (JEPGVRUT)
IDENTIFIER LURYOXLPOYNOUS if (LURYOXLPOYNOUS)
<operator>.lessThan HFAAAM < argc
<operator>.preIncrement ++ HFAAAM
IDENTIFIER ISNRVHKIJMG return ISNRVHKIJMG ;
FXFGK FXFGK ( 0   0   _ ( "missing operand" ) )
JNBRS JNBRS ( EXIT_FAILURE )
<operator>.assignment YMB = 0
<operator>.assignment * HCESVA = EKUQCNSDKCNH ( LURYOXLPOYNOUS )
<operator>.assignment MRQBAWJIWGG = KTSME ( 0 )
KTSME KTSME ( MRQBAWJIWGG )
<operator>.assignment UWCATRV = KILDFECMNHQ ( UWCATRV , false , MRQBAWJIWGG , HCESVA , NULL )
free free ( HCESVA )
<operator>.assignment IOGE = BJUGJDVPSAV ( argc , argv , "m:Z" , HJIDSHIO , NULL )
<operator>.minus - 1
IDENTIFIER IOGE switch(IOGE)
DMYGIRHUNQGSOXOO DMYGIRHUNQGSOXOO ( )
<operator>.lessThan YMB < 0
<operator>.logicalNot ! HCESVA
<operator>.and UWCATRV & ~ IDRNQMESB
IDENTIFIER OAEBGMSPQCTJISBDOERA if (OAEBGMSPQCTJISBDOERA)
<operator>.notEquals NFWUVG ( argv [ HFAAAM ] , UWCATRV ) != 0
BJUGJDVPSAV BJUGJDVPSAV ( argc , argv , "m:Z" , HJIDSHIO , NULL )
LITERAL 'm' <empty>
<operator>.assignment LURYOXLPOYNOUS = UBHDXT
LITERAL 'Z' <empty>
PCRYOHSKPPWRHUVGFGNFSSLV PCRYOHSKPPWRHUVGFGNFSSLV ( KMHGWNRPRLOH , SJTLBQD )
JNBRS JNBRS ( EXIT_FAILURE )
_ _ ( "missing operand" )
<operator>.assignment YMB = GSYTMOLYFUTOOFPHKBUMSPVA ( JEPGVRUT )
VDH VDH ( EXIT_FAILURE   NTSIW   _ ( "failed to set default file creation context to %s" )   RTXXM ( JEPGVRUT ) )
EKUQCNSDKCNH EKUQCNSDKCNH ( LURYOXLPOYNOUS )
VDH VDH ( EXIT_FAILURE   0   _ ( "invalid mode" ) )
KTSME KTSME ( 0 )
KILDFECMNHQ KILDFECMNHQ ( UWCATRV , false , MRQBAWJIWGG , HCESVA , NULL )
VDH VDH ( EXIT_FAILURE   0   _ ( "mode must specify only file permission bits" ) )
YXNDLXNIQC YXNDLXNIQC ( OAEBGMSPQCTJISBDOERA , argv [ HFAAAM ] , ODLAJSH )
FXFGK FXFGK ( 0   NTSIW   _ ( "cannot create fifo %s" )   BPVRFAM ( argv [ HFAAAM ] ) )
<operator>.assignment ISNRVHKIJMG = EXIT_FAILURE
DMYGIRHUNQGSOXOO DMYGIRHUNQGSOXOO ( )
<operator>.assignment YMB = QWAFXMGEHHXUVL ( JEPGVRUT )
<operator>.not ~ IDRNQMESB
NFWUVG NFWUVG ( argv [ HFAAAM ] , UWCATRV )
<operator>.assignment JEPGVRUT = UBHDXT
GSYTMOLYFUTOOFPHKBUMSPVA GSYTMOLYFUTOOFPHKBUMSPVA ( JEPGVRUT )
_ _ ( "failed to set default file creation context to %s" )
RTXXM RTXXM ( JEPGVRUT )
_ _ ( "invalid mode" )
_ _ ( "mode must specify only file permission bits" )
_ _ ( "cannot create fifo %s" )
BPVRFAM BPVRFAM ( argv [ HFAAAM ] )
<operator>.logicalAnd LURYOXLPOYNOUS && IALVDY ( argv [ HFAAAM ] , UWCATRV ) != 0
QWAFXMGEHHXUVL QWAFXMGEHHXUVL ( JEPGVRUT )
FXFGK FXFGK ( 0   NTSIW   _ ( "cannot set permissions of %s" )   BPVRFAM ( argv [ HFAAAM ] ) )
<operator>.assignment ISNRVHKIJMG = EXIT_FAILURE
<operator>.greaterThan UVXFBQPMIKNRQNNTBN ( ) > 0
<operator>.notEquals IALVDY ( argv [ HFAAAM ] , UWCATRV ) != 0
IALVDY IALVDY ( argv [ HFAAAM ] , UWCATRV )
_ _ ( "cannot set permissions of %s" )
BPVRFAM BPVRFAM ( argv [ HFAAAM ] )
IDENTIFIER UBHDXT if (UBHDXT)
<operator>.assignment JEPGVRUT = UBHDXT
IDENTIFIER UBHDXT if (UBHDXT)
<operator>.assignment OAEBGMSPQCTJISBDOERA = BLFKIUDOORNF ( GIBGPCAFOKSFCJUP , NULL , 0 )
FXFGK FXFGK ( 0   0   _ ( "warning: ignoring --context; " "it requires an SELinux/SMACK-enabled kernel" ) )
<operator>.logicalNot ! OAEBGMSPQCTJISBDOERA
BLFKIUDOORNF BLFKIUDOORNF ( GIBGPCAFOKSFCJUP , NULL , 0 )
FXFGK FXFGK ( 0   NTSIW   _ ( "warning: ignoring --context" ) )
_ _ ( "warning: ignoring --context; " "it requires an SELinux/SMACK-enabled kernel" )
_ _ ( "warning: ignoring --context" )
<operator>.indirectIndexAccess argv [ HFAAAM ]
<operator>.indirectIndexAccess argv [ HFAAAM ]
<operator>.indirectIndexAccess argv [ HFAAAM ]
UVXFBQPMIKNRQNNTBN UVXFBQPMIKNRQNNTBN ( )
<operator>.indirectIndexAccess argv [ HFAAAM ]
<operator>.indirectIndexAccess argv [ HFAAAM ]
>>>PDG&94 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->28 0->30 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->45 0->46 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->78 0->79 0->80 0->82 0->83 0->84 0->85 0->86 0->87 2->8 2->40 3->8 3->9 3->40 4->1 4->1 4->49 4->69 5->1 5->1 5->1 5->22 6->1 6->1 6->62 6->70 7->1 7->1 7->54 8->1 8->1 8->1 8->17 8->20 8->40 8->40 9->1 9->1 9->40 10->1 10->1 11->1 11->1 11->12 12->1 12->1 13->1 13->1 14->1 14->1 14->1 14->52 14->60 15->1 16->1 16->1 16->1 16->16 16->31 16->32 16->40 16->42 16->45 16->57 17->1 17->20 17->20 17->23 17->24 17->46 20->1 20->1 20->1 20->20 20->21 20->21 20->39 20->54 20->60 20->88 20->89 21->1 21->20 22->15 23->1 23->1 24->1 24->1 24->48 24->50 24->53 24->56 24->72 25->1 26->1 26->1 26->36 27->1 27->1 27->28 28->1 28->52 29->1 29->1 29->37 30->1 31->1 31->1 31->16 32->16 34->1 34->47 34->58 34->62 34->70 35->1 35->1 35->48 35->63 35->64 36->1 36->50 36->52 36->65 37->1 37->1 37->1 37->53 37->60 37->66 39->1 39->1 39->55 39->56 39->67 39->68 39->69 39->74 39->75 39->90 39->92 40->1 40->1 40->1 40->16 40->16 40->16 40->16 40->16 40->17 40->31 40->31 40->31 40->31 40->31 40->52 40->54 40->60 40->68 40->75 40->77 40->84 42->1 42->1 42->1 42->49 42->69 44->1 44->1 44->1 45->1 45->1 45->24 45->48 45->50 45->53 45->56 45->72 46->23 47->1 47->1 47->35 48->1 48->1 48->1 48->1 48->1 48->50 48->53 48->55 48->56 48->71 48->72 49->1 49->26 49->69 50->1 50->1 50->1 50->53 50->56 50->72 51->27 52->1 52->1 52->1 52->29 52->29 52->29 52->29 52->29 52->30 53->1 53->1 53->1 53->56 53->72 54->1 54->1 54->1 54->60 55->1 55->1 55->1 55->1 55->71 56->1 56->1 56->1 56->22 57->1 57->61 57->73 57->91 58->1 58->1 58->35 59->1 59->37 60->1 60->1 60->39 60->39 60->54 60->68 60->75 60->75 60->77 61->1 61->1 61->1 61->62 61->70 62->1 62->47 62->64 63->48 64->1 64->48 65->50 66->53 67->55 68->1 68->54 68->55 68->60 69->1 69->1 69->1 69->71 69->72 69->76 69->77 69->93 70->1 70->58 70->64 71->1 71->1 71->1 71->1 71->55 72->1 72->1 72->1 72->22 73->1 73->1 73->79 73->81 73->82 73->83 73->84 73->86 74->1 74->69 74->69 75->1 75->1 75->54 75->60 75->60 75->74 75->74 75->77 76->71 77->1 77->54 77->60 77->71 79->1 79->1 79->1 79->62 79->70 81->1 81->1 81->83 82->1 82->1 83->1 83->1 83->54 83->85 83->87 84->1 84->40 84->81 84->81 84->81 85->1 85->1 85->1 85->48 85->55 85->71 86->82 87->85
>>>Token int main ( int argc , char * * argv ) { DTSKBA UWCATRV ; char const * LURYOXLPOYNOUS = NULL ; int ISNRVHKIJMG = EXIT_SUCCESS ; int IOGE ; char const * JEPGVRUT = NULL ; struct DMKCAAYUKRICPS * OAEBGMSPQCTJISBDOERA = NULL ; ISCJPOBYQSTHUXI ( & argc , & argv ) ; CKBTDFPMNKNSATLC ( argv [ 0 ] ) ; EGGNXUQWN ( LSUHQF , " " ) ; LDHFHOWTFIKXKG ( LMLTUBS , PSRDELXNE ) ; DYIMGPCELH ( LMLTUBS ) ; MVHWFV ( LSRGTKXOFDVQ ) ; while ( ( IOGE = BJUGJDVPSAV ( argc , argv , " " , HJIDSHIO , NULL ) ) != - 1 ) { switch ( IOGE ) { case ' ' : LURYOXLPOYNOUS = UBHDXT ; break ; case ' ' : if ( DMYGIRHUNQGSOXOO ( ) ) { JEPGVRUT = UBHDXT ; } else if ( UVXFBQPMIKNRQNNTBN ( ) > 0 ) { if ( UBHDXT ) JEPGVRUT = UBHDXT ; else { OAEBGMSPQCTJISBDOERA = BLFKIUDOORNF ( GIBGPCAFOKSFCJUP , NULL , 0 ) ; if ( ! OAEBGMSPQCTJISBDOERA ) FXFGK ( 0 , NTSIW , _ ( " " ) ) ; } } else if ( UBHDXT ) { FXFGK ( 0 , 0 , _ ( " " " " ) ) ; } break ; KYPXEXIHFXMFGDPYITKEL ; PCRYOHSKPPWRHUVGFGNFSSLV ( KMHGWNRPRLOH , SJTLBQD ) ; default : JNBRS ( EXIT_FAILURE ) ; } } if ( HFAAAM == argc ) { FXFGK ( 0 , 0 , _ ( " " ) ) ; JNBRS ( EXIT_FAILURE ) ; } if ( JEPGVRUT ) { int YMB = 0 ; if ( DMYGIRHUNQGSOXOO ( ) ) YMB = GSYTMOLYFUTOOFPHKBUMSPVA ( JEPGVRUT ) ; else YMB = QWAFXMGEHHXUVL ( JEPGVRUT ) ; if ( YMB < 0 ) VDH ( EXIT_FAILURE , NTSIW , _ ( " " ) , RTXXM ( JEPGVRUT ) ) ; } UWCATRV = GKNDWJTTJMS ; if ( LURYOXLPOYNOUS ) { DTSKBA MRQBAWJIWGG ; struct ICKRTEQTSYF * HCESVA = EKUQCNSDKCNH ( LURYOXLPOYNOUS ) ; if ( ! HCESVA ) VDH ( EXIT_FAILURE , 0 , _ ( " " ) ) ; MRQBAWJIWGG = KTSME ( 0 ) ; KTSME ( MRQBAWJIWGG ) ; UWCATRV = KILDFECMNHQ ( UWCATRV , false , MRQBAWJIWGG , HCESVA , NULL ) ; free ( HCESVA ) ; if ( UWCATRV & ~ IDRNQMESB ) VDH ( EXIT_FAILURE , 0 , _ ( " " ) ) ; } for ( ; HFAAAM < argc ; ++ HFAAAM ) { if ( OAEBGMSPQCTJISBDOERA ) YXNDLXNIQC ( OAEBGMSPQCTJISBDOERA , argv [ HFAAAM ] , ODLAJSH ) ; if ( NFWUVG ( argv [ HFAAAM ] , UWCATRV ) != 0 ) { FXFGK ( 0 , NTSIW , _ ( " " ) , BPVRFAM ( argv [ HFAAAM ] ) ) ; ISNRVHKIJMG = EXIT_FAILURE ; } else if ( LURYOXLPOYNOUS && IALVDY ( argv [ HFAAAM ] , UWCATRV ) != 0 ) { FXFGK ( 0 , NTSIW , _ ( " " ) , BPVRFAM ( argv [ HFAAAM ] ) ) ; ISNRVHKIJMG = EXIT_FAILURE ; } } return ISNRVHKIJMG ; }
>>>Func
METHOD DTSKB
METHOD_RETURN void
PARAM int AUWCAT
exit exit ( AUWCAT )
<operator>.notEquals AUWCAT != EXIT_SUCCESS
RVLURYOXLPOYN RVLURYOXLPOYN ( )
printf printf ( _ ( "Usage: %s [OPTION]... NAME...\n" ) , OUSISNRVHKIJ )
MGIOG MGIOG ( _ ( "\\012Create named pipes (FIFOs) with the given NAMEs.\n\\012" ) , EJEPGV )
RUTDMKCAAYUKRICPSOAEBGM RUTDMKCAAYUKRICPSOAEBGM ( )
MGIOG MGIOG ( _ ( "\\012  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n\\012" ) , EJEPGV )
MGIOG MGIOG ( _ ( "\\012  -Z                   set the SELinux security context to default type\n\\012      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n\\012                         or SMACK security context to CTX\n\\012" ) , EJEPGV )
MGIOG MGIOG ( SPQCTJISBDOERAISCJPOBYQ , EJEPGV )
MGIOG MGIOG ( STHUXICKBTDFPMNKNSATLCEGGN , EJEPGV )
XUQWNLSUHQFLDHFHOWT XUQWNLSUHQFLDHFHOWT ( FIKXKGLMLTUB )
_ _ ( "Usage: %s [OPTION]... NAME...\n" )
_ _ ( "\\012Create named pipes (FIFOs) with the given NAMEs.\n\\012" )
_ _ ( "\\012  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n\\012" )
_ _ ( "\\012  -Z                   set the SELinux security context to default type\n\\012      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n\\012                         or SMACK security context to CTX\n\\012" )
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->4 3->1 4->1 4->1 4->3 4->5 4->6 4->7 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 5->1 6->1 6->1 6->1 7->1 7->1 7->9 8->1 9->1 9->1 9->10 10->1 10->1 10->11 11->1 11->1 11->12 12->1 12->1 12->1 13->1 13->1 14->6 15->7 16->9 17->10
>>>Token void DTSKB ( int AUWCAT ) { if ( AUWCAT != EXIT_SUCCESS ) RVLURYOXLPOYN ( ) ; else { printf ( _ ( " \n " ) , OUSISNRVHKIJ ) ; MGIOG ( _ ( " \
>>>Func
METHOD RHSEVH
METHOD_RETURN int
PARAM char e
PARAM char * NHWGWY
<operator>.assignment ICPDXXPRIQM = TJUGMHTX [ BBS ]
RETURN return 0 ; return 0 ;
<operator>.equals nC == 0
<operator>.lessThan i < nC
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
RETURN return 0 ; return 0 ;
<operator>.assignment i = 0
LITERAL 0 return 0 ;
<operator>.logicalOr ( C [ i ] [ 0 ] == e && C [ i ] [ 1 ] == ICPDXXPRIQM ) || ( C [ i ] [ 1 ] == e && C [ i ] [ 0 ] == ICPDXXPRIQM )
<operator>.assignment * NHWGWY = C [ i ] [ 2 ]
RETURN return 1 ; return 1 ;
<operator>.logicalAnd C [ i ] [ 0 ] == e && C [ i ] [ 1 ] == ICPDXXPRIQM
<operator>.logicalAnd C [ i ] [ 1 ] == e && C [ i ] [ 0 ] == ICPDXXPRIQM
LITERAL 1 return 1 ;
<operator>.equals C [ i ] [ 0 ] == e
<operator>.equals C [ i ] [ 1 ] == ICPDXXPRIQM
<operator>.equals C [ i ] [ 1 ] == e
<operator>.equals C [ i ] [ 0 ] == ICPDXXPRIQM
<operator>.indirection * NHWGWY
<operator>.indirectIndexAccess C [ i ] [ 2 ]
<operator>.indirectIndexAccess C [ i ] [ 0 ]
<operator>.indirectIndexAccess C [ i ] [ 1 ]
<operator>.indirectIndexAccess C [ i ] [ 1 ]
<operator>.indirectIndexAccess C [ i ] [ 0 ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
>>>PDG&34 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->15 0->18 0->19 0->20 0->21 0->22 2->1 2->19 3->1 4->1 4->1 4->1 4->20 4->22 5->1 6->1 6->1 6->7 6->7 6->10 6->11 7->5 7->8 7->13 7->16 7->19 7->25 7->30 8->7 9->5 10->1 11->7 12->10 13->7 13->8 13->14 13->15 13->23 13->24 13->29 15->1 16->13 16->13 16->17 16->21 16->27 16->32 17->13 17->13 18->15 19->16 19->16 19->20 19->21 19->22 19->26 19->31 20->16 20->16 20->21 20->22 21->17 21->17 21->19 21->20 21->22 21->28 21->33 22->17 22->17 22->19 22->20
>>>Token int RHSEVH ( char e , char * NHWGWY ) { int i ; char ICPDXXPRIQM = TJUGMHTX [ BBS ] ; if ( nC == 0 ) { return 0 ; } for ( i = 0 ; i < nC ; i ++ ) { if ( ( C [ i ] [ 0 ] == e && C [ i ] [ 1 ] == ICPDXXPRIQM ) || ( C [ i ] [ 1 ] == e && C [ i ] [ 0 ] == ICPDXXPRIQM ) ) { * NHWGWY = C [ i ] [ 2 ] ; return 1 ; } } return 0 ; }
>>>Func
METHOD GLJJXVA
METHOD_RETURN void
<operator>.assignment HQCL = 0
<operator>.lessThan TON < 1
<operator>.lessThan i < 26
<operator>.preIncrement ++ i
<operator>.equals HQCL == 1
RETURN return ; return ;
<operator>.assignment i = 0
<operator>.equals WSVIY [ TSKNV [ TON ] - 'A' ] [ i ] == 1
<operator>.assignment TON = - 1
<operator>.lessThan i < 26
<operator>.preIncrement ++ i
<operator>.assignment RLFEABA [ i ] = 0
<operator>.logicalAnd TSKNV [ TON ] - 'A' == i && RLFEABA [ i ] > 1
<operator>.logicalAnd TSKNV [ TON ] - 'A' != i && RLFEABA [ i ] > 0
<operator>.assignment i = 0
<operator>.minus - 1
<operator>.assignment HQCL = 1
<operator>.assignment HQCL = 1
<operator>.subtraction TSKNV [ TON ] - 'A'
<operator>.equals TSKNV [ TON ] - 'A' == i
<operator>.greaterThan RLFEABA [ i ] > 1
<operator>.notEquals TSKNV [ TON ] - 'A' != i
<operator>.greaterThan RLFEABA [ i ] > 0
<operator>.subtraction TSKNV [ TON ] - 'A'
<operator>.subtraction TSKNV [ TON ] - 'A'
<operator>.indirectIndexAccess WSVIY [ TSKNV [ TON ] - 'A' ] [ i ]
<operator>.indirectIndexAccess WSVIY [ TSKNV [ TON ] - 'A' ]
<operator>.indirectIndexAccess RLFEABA [ i ]
<operator>.indirectIndexAccess TSKNV [ TON ]
<operator>.indirectIndexAccess RLFEABA [ i ]
<operator>.indirectIndexAccess RLFEABA [ i ]
<operator>.indirectIndexAccess TSKNV [ TON ]
<operator>.indirectIndexAccess TSKNV [ TON ]
>>>PDG&35 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->1 2->1 2->6 3->1 3->1 3->4 3->6 3->7 3->8 4->5 4->9 4->20 4->21 4->27 4->28 4->30 5->4 6->10 6->11 6->16 6->17 7->1 8->4 9->4 9->5 9->14 9->21 9->25 9->33 11->11 11->12 11->12 11->13 11->29 12->11 14->15 14->18 14->23 14->26 14->34 15->4 15->5 15->19 16->11 17->10 18->6 19->6 20->25 21->14 21->14 21->22 21->23 21->31 22->14 22->14 22->24 23->5 23->15 23->15 23->24 23->32 24->15 24->15 24->22 25->21 25->21 25->26 26->20 26->23 26->23
>>>Token void GLJJXVA ( ) { int i , HQCL = 0 ; if ( TON < 1 ) return ; for ( i = 0 ; i < 26 ; ++ i ) if ( WSVIY [ TSKNV [ TON ] - ' ' ] [ i ] == 1 ) { if ( TSKNV [ TON ] - ' ' == i && RLFEABA [ i ] > 1 ) { HQCL = 1 ; break ; } if ( TSKNV [ TON ] - ' ' != i && RLFEABA [ i ] > 0 ) { HQCL = 1 ; break ; } } if ( HQCL == 1 ) { for ( i = 0 ; i < 26 ; ++ i ) RLFEABA [ i ] = 0 ; TON = - 1 ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment WYQG = 0
<operator>.assignment i = 0
<operator>.assignment j = 0
<operator>.assignment k = 0
<operator>.assignment LGKDX = 0
<operator>.assignment QJUGNAO = 0
<operator>.assignment C = 0
<operator>.assignment D = 0
<operator>.assignment N = 0
<operator>.assignment AEYJG = 0
<operator>.assignment WRYSN = 0
<operator>.assignment GAJWE = 0
<operator>.assignment PGRYOOT [ 26 ] = { 0   }
<operator>.assignment OIH = WKTUO ( "Sol3.in" , "r" )
<operator>.assignment QCW = WKTUO ( "Sol3.out" , "w" )
SXWSBM SXWSBM ( OIH , "%d" , & WYQG )
DHHFJU DHHFJU ( OIH )
DHHFJU DHHFJU ( QCW )
RETURN return 0 ; return 0 ;
<operator>.equals OIH == NULL
<operator>.equals QCW == NULL
<operator>.lessThan i < WYQG
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.arrayInitializer { 0   }
WKTUO WKTUO ( "Sol3.in" , "r" )
printf printf ( "File Not Found" )
FTKWG FTKWG ( )
RETURN return 0 ; return 0 ;
WKTUO WKTUO ( "Sol3.out" , "w" )
printf printf ( "Can't Create File" )
FTKWG FTKWG ( )
RETURN return 0 ; return 0 ;
<operator>.assignment i = 0
memset memset ( PGRYOOT   0   26 * ( sizeof ( TAWANAQ ) ) )
SXWSBM SXWSBM ( OIH , "%d" , & C )
UTDBM UTDBM ( OIH )
SXWSBM SXWSBM ( OIH , "%d" , & D )
UTDBM UTDBM ( OIH )
SXWSBM SXWSBM ( OIH , "%d" , & N )
UTDBM UTDBM ( OIH )
<operator>.assignment LGKDX = 0
fprintf fprintf ( QCW , "Case #%d: [" , i + 1 )
fprintf fprintf ( QCW , "]\n" )
LITERAL 0 return 0 ;
LITERAL 0 return 0 ;
<operator>.lessThan j < C
<operator>.postIncrement j ++
<operator>.lessThan j < D
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < LGKDX
<operator>.postIncrement j ++
<operator>.multiplication 26 * ( sizeof ( TAWANAQ ) )
<operator>.assignment j = 0
<operator>.assignment AEYJG = UTDBM ( OIH ) - 65
<operator>.assignment WRYSN = UTDBM ( OIH ) - 65
<operator>.assignment GAJWE = UTDBM ( OIH ) - 65
UTDBM UTDBM ( OIH )
<operator>.assignment PGRYOOT [ AEYJG ] . EQBXHLG = 1
<operator>.assignment PGRYOOT [ WRYSN ] . EQBXHLG = 1
<operator>.assignment PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ] . WAGEQJ = 1
<operator>.assignment PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ] . BJHAEKMYFRB = GAJWE
<operator>.assignment PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ] . WAGEQJ = 1
<operator>.assignment PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ] . BJHAEKMYFRB = GAJWE
<operator>.assignment j = 0
<operator>.assignment AEYJG = UTDBM ( OIH ) - 65
<operator>.assignment WRYSN = UTDBM ( OIH ) - 65
UTDBM UTDBM ( OIH )
<operator>.assignment PGRYOOT [ AEYJG ] . EQBXHLG = 1
<operator>.assignment PGRYOOT [ WRYSN ] . EQBXHLG = 1
<operator>.assignment PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ] . RWTUUBJ = 1
<operator>.assignment PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ] . RWTUUBJ = 1
<operator>.assignment j = 0
<operator>.assignment JYURKEDNC [ LGKDX ] = UTDBM ( OIH ) - 65
<operator>.postIncrement LGKDX ++
<operator>.addition i + 1
<operator>.assignment j = 0
<operator>.sizeOf sizeof ( TAWANAQ )
<operator>.notEquals LGKDX != 0
<operator>.equals j == LGKDX - 1
<operator>.subtraction UTDBM ( OIH ) - 65
<operator>.subtraction UTDBM ( OIH ) - 65
<operator>.subtraction UTDBM ( OIH ) - 65
<operator>.subtraction UTDBM ( OIH ) - 65
<operator>.subtraction UTDBM ( OIH ) - 65
<operator>.subtraction UTDBM ( OIH ) - 65
fprintf fprintf ( QCW , "%c" , JYURKEDNC [ j ] + 65 )
UTDBM UTDBM ( OIH )
UTDBM UTDBM ( OIH )
UTDBM UTDBM ( OIH )
UTDBM UTDBM ( OIH )
UTDBM UTDBM ( OIH )
UTDBM UTDBM ( OIH )
<operator>.equals 1 == PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ LGKDX - 1 ] ] . WAGEQJ
<operator>.subtraction LGKDX - 1
fprintf fprintf ( QCW , "%c, " , JYURKEDNC [ j ] + 65 )
<operator>.assignment JYURKEDNC [ LGKDX - 1 ] = PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ LGKDX - 1 ] ] . BJHAEKMYFRB
<operator>.postDecrement LGKDX --
<operator>.addition JYURKEDNC [ j ] + 65
<operator>.addition JYURKEDNC [ j ] + 65
<operator>.equals 1 == PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EQBXHLG
<operator>.subtraction LGKDX - 1
<operator>.subtraction LGKDX - 1
<operator>.lessEqualsThan k <= LGKDX - 1
<operator>.postIncrement k ++
<operator>.subtraction LGKDX - 1
<operator>.assignment k = 0
<operator>.subtraction LGKDX - 1
<operator>.equals 1 == PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ k ] ] . RWTUUBJ
<operator>.assignment LGKDX = - 1
<operator>.minus - 1
<operator>.addressOf & WYQG
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.fieldAccess PGRYOOT [ AEYJG ] . EQBXHLG
<operator>.fieldAccess PGRYOOT [ WRYSN ] . EQBXHLG
<operator>.fieldAccess PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ] . WAGEQJ
<operator>.fieldAccess PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ] . BJHAEKMYFRB
<operator>.fieldAccess PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ] . WAGEQJ
<operator>.fieldAccess PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ] . BJHAEKMYFRB
<operator>.fieldAccess PGRYOOT [ AEYJG ] . EQBXHLG
<operator>.fieldAccess PGRYOOT [ WRYSN ] . EQBXHLG
<operator>.fieldAccess PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ] . RWTUUBJ
<operator>.fieldAccess PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ] . RWTUUBJ
<operator>.indirectIndexAccess JYURKEDNC [ LGKDX ]
<operator>.indirectIndexAccess PGRYOOT [ AEYJG ]
FIELD_IDENTIFIER EQBXHLG EQBXHLG
<operator>.indirectIndexAccess PGRYOOT [ WRYSN ]
FIELD_IDENTIFIER EQBXHLG EQBXHLG
<operator>.indirectIndexAccess PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ]
FIELD_IDENTIFIER WAGEQJ WAGEQJ
<operator>.indirectIndexAccess PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ]
FIELD_IDENTIFIER BJHAEKMYFRB BJHAEKMYFRB
<operator>.indirectIndexAccess PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ]
FIELD_IDENTIFIER WAGEQJ WAGEQJ
<operator>.indirectIndexAccess PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ]
FIELD_IDENTIFIER BJHAEKMYFRB BJHAEKMYFRB
<operator>.indirectIndexAccess PGRYOOT [ AEYJG ]
FIELD_IDENTIFIER EQBXHLG EQBXHLG
<operator>.indirectIndexAccess PGRYOOT [ WRYSN ]
FIELD_IDENTIFIER EQBXHLG EQBXHLG
<operator>.indirectIndexAccess PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ]
FIELD_IDENTIFIER RWTUUBJ RWTUUBJ
<operator>.indirectIndexAccess PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ]
FIELD_IDENTIFIER RWTUUBJ RWTUUBJ
<operator>.fieldAccess PGRYOOT [ AEYJG ] . EXCBNH
<operator>.fieldAccess PGRYOOT [ AEYJG ] . EXCBNH
<operator>.fieldAccess PGRYOOT [ WRYSN ] . EXCBNH
<operator>.fieldAccess PGRYOOT [ WRYSN ] . EXCBNH
<operator>.fieldAccess PGRYOOT [ AEYJG ] . EXCBNH
<operator>.fieldAccess PGRYOOT [ WRYSN ] . EXCBNH
<operator>.indirectIndexAccess PGRYOOT [ AEYJG ]
FIELD_IDENTIFIER EXCBNH EXCBNH
<operator>.indirectIndexAccess PGRYOOT [ AEYJG ]
FIELD_IDENTIFIER EXCBNH EXCBNH
<operator>.indirectIndexAccess PGRYOOT [ WRYSN ]
FIELD_IDENTIFIER EXCBNH EXCBNH
<operator>.indirectIndexAccess PGRYOOT [ WRYSN ]
FIELD_IDENTIFIER EXCBNH EXCBNH
<operator>.indirectIndexAccess PGRYOOT [ AEYJG ]
FIELD_IDENTIFIER EXCBNH EXCBNH
<operator>.indirectIndexAccess PGRYOOT [ WRYSN ]
FIELD_IDENTIFIER EXCBNH EXCBNH
<operator>.fieldAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ LGKDX - 1 ] ] . WAGEQJ
<operator>.indirectIndexAccess JYURKEDNC [ j ]
<operator>.indirectIndexAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ LGKDX - 1 ] ]
FIELD_IDENTIFIER WAGEQJ WAGEQJ
<operator>.indirectIndexAccess JYURKEDNC [ LGKDX - 1 ]
<operator>.fieldAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ LGKDX - 1 ] ] . BJHAEKMYFRB
<operator>.indirectIndexAccess JYURKEDNC [ j ]
<operator>.fieldAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH
<operator>.indirectIndexAccess JYURKEDNC [ LGKDX - 1 ]
<operator>.indirectIndexAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ LGKDX - 1 ] ]
FIELD_IDENTIFIER BJHAEKMYFRB BJHAEKMYFRB
<operator>.indirectIndexAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ]
FIELD_IDENTIFIER EXCBNH EXCBNH
<operator>.fieldAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH
<operator>.indirectIndexAccess JYURKEDNC [ LGKDX - 1 ]
<operator>.fieldAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EQBXHLG
<operator>.indirectIndexAccess JYURKEDNC [ LGKDX ]
<operator>.indirectIndexAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ]
FIELD_IDENTIFIER EXCBNH EXCBNH
<operator>.indirectIndexAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ]
FIELD_IDENTIFIER EQBXHLG EQBXHLG
<operator>.indirectIndexAccess JYURKEDNC [ LGKDX ]
<operator>.indirectIndexAccess JYURKEDNC [ LGKDX ]
<operator>.fieldAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ k ] ] . RWTUUBJ
<operator>.indirectIndexAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ k ] ]
FIELD_IDENTIFIER RWTUUBJ RWTUUBJ
<operator>.fieldAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH
<operator>.indirectIndexAccess JYURKEDNC [ k ]
<operator>.indirectIndexAccess PGRYOOT [ JYURKEDNC [ LGKDX ] ]
FIELD_IDENTIFIER EXCBNH EXCBNH
<operator>.indirectIndexAccess JYURKEDNC [ LGKDX ]
>>>PDG&199 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->71 0->72 0->73 0->74 0->75 0->76 0->78 0->79 0->80 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->114 2->1 2->1 2->17 2->23 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 8->37 8->48 9->1 9->1 9->39 9->50 10->1 10->1 10->41 10->52 11->1 11->1 12->1 12->1 13->1 13->1 14->1 14->1 14->1 14->36 15->1 15->1 15->21 16->22 17->18 17->23 17->37 20->1 21->1 21->1 21->1 21->16 21->17 21->22 21->22 21->28 21->29 21->30 21->31 22->17 22->18 22->19 22->19 22->20 22->23 22->32 22->33 22->34 22->35 22->44 22->115 23->23 23->24 23->24 23->36 23->37 23->38 23->39 23->40 23->41 23->42 23->43 23->44 23->44 23->45 23->48 23->50 23->52 23->54 23->56 23->57 23->68 23->76 23->79 23->79 23->80 23->81 23->116 23->117 23->118 24->23 25->20 26->14 27->15 27->15 28->1 29->1 30->1 31->16 31->16 34->1 35->23 37->38 37->48 38->39 38->91 39->40 39->50 40->41 40->94 41->42 41->52 42->18 42->37 42->96 43->54 43->82 44->45 44->90 44->99 45->19 45->44 46->30 47->34 48->37 48->48 48->49 48->49 48->58 48->59 48->60 48->61 48->62 48->63 48->64 48->65 48->66 48->67 48->84 48->85 48->86 48->91 48->92 48->93 48->119 48->120 48->121 48->122 48->123 48->124 48->130 48->131 48->132 48->133 48->134 48->135 48->136 48->137 48->138 48->139 48->140 48->141 48->150 48->151 48->152 48->153 48->156 48->157 48->158 48->159 48->160 48->161 48->162 48->163 49->48 50->39 50->50 50->51 50->51 50->69 50->70 50->71 50->72 50->73 50->74 50->75 50->87 50->88 50->94 50->95 50->125 50->126 50->127 50->128 50->142 50->143 50->144 50->145 50->146 50->147 50->148 50->149 50->154 50->155 50->164 50->165 50->166 50->167 51->50 52->41 52->52 52->53 52->53 52->77 52->78 52->82 52->89 52->96 52->129 53->52 54->54 54->55 54->83 54->83 54->98 54->98 55->54 56->36 57->48 60->65 60->67 61->39 61->91 68->50 71->41 71->94 76->52 78->54 78->82 80->54 81->1 82->78 82->97 82->106 82->106 82->168 82->170 82->171 82->175 82->176 82->179 82->180 82->184 83->55 83->90 83->99 83->102 83->103 83->169 83->174 84->58 84->58 85->59 85->59 86->60 86->60 87->69 87->69 88->70 88->70 89->77 89->77 90->45 90->99 91->84 91->92 92->85 92->93 93->61 93->86 94->87 94->95 95->71 95->88 96->18 96->37 96->89 97->100 97->101 97->104 97->105 97->109 97->172 97->173 97->177 97->178 97->181 97->182 97->183 97->185 97->186 97->187 97->188 97->189 97->190 98->54 98->83 98->83 99->45 99->90 101->78 104->107 104->110 104->111 105->109 106->78 106->105 106->111 107->108 107->112 107->191 107->192 107->193 107->194 107->195 107->196 107->197 107->198 108->107 109->101 110->107 111->78 111->107 111->107 112->107 112->108 112->111 112->113 112->114 113->78 114->113
>>>Token int main ( ) { int WYQG = 0 , i = 0 , j = 0 , k = 0 ; int LGKDX = 0 ; int QJUGNAO = 0 ; int C = 0 , D = 0 , N = 0 ; int AEYJG = 0 , WRYSN = 0 , GAJWE = 0 ; char JYURKEDNC [ 100 ] ; TAWANAQ PGRYOOT [ 26 ] = { 0 , } ; OIH = WKTUO ( " " , " " ) ; if ( OIH == NULL ) { printf ( " " ) ; FTKWG ( ) ; return 0 ; } QCW = WKTUO ( " " , " " ) ; if ( QCW == NULL ) { printf ( " " ) ; FTKWG ( ) ; return 0 ; } SXWSBM ( OIH , " " , & WYQG ) ; for ( i = 0 ; i < WYQG ; i ++ ) { memset ( PGRYOOT , 0 , 26 * ( sizeof ( TAWANAQ ) ) ) ; SXWSBM ( OIH , " " , & C ) ; UTDBM ( OIH ) ; for ( j = 0 ; j < C ; j ++ ) { AEYJG = UTDBM ( OIH ) - 65 ; WRYSN = UTDBM ( OIH ) - 65 ; GAJWE = UTDBM ( OIH ) - 65 ; UTDBM ( OIH ) ; PGRYOOT [ AEYJG ] . EQBXHLG = 1 ; PGRYOOT [ WRYSN ] . EQBXHLG = 1 ; PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ] . WAGEQJ = 1 ; PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ] . BJHAEKMYFRB = GAJWE ; PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ] . WAGEQJ = 1 ; PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ] . BJHAEKMYFRB = GAJWE ; } SXWSBM ( OIH , " " , & D ) ; UTDBM ( OIH ) ; for ( j = 0 ; j < D ; j ++ ) { AEYJG = UTDBM ( OIH ) - 65 ; WRYSN = UTDBM ( OIH ) - 65 ; UTDBM ( OIH ) ; PGRYOOT [ AEYJG ] . EQBXHLG = 1 ; PGRYOOT [ WRYSN ] . EQBXHLG = 1 ; PGRYOOT [ AEYJG ] . EXCBNH [ WRYSN ] . RWTUUBJ = 1 ; PGRYOOT [ WRYSN ] . EXCBNH [ AEYJG ] . RWTUUBJ = 1 ; } SXWSBM ( OIH , " " , & N ) ; UTDBM ( OIH ) ; LGKDX = 0 ; for ( j = 0 ; j < N ; j ++ ) { JYURKEDNC [ LGKDX ] = UTDBM ( OIH ) - 65 ; if ( LGKDX != 0 ) { if ( 1 == PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ LGKDX - 1 ] ] . WAGEQJ ) { JYURKEDNC [ LGKDX - 1 ] = PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ LGKDX - 1 ] ] . BJHAEKMYFRB ; LGKDX -- ; } else { if ( 1 == PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EQBXHLG ) { for ( k = 0 ; k <= LGKDX - 1 ; k ++ ) { if ( 1 == PGRYOOT [ JYURKEDNC [ LGKDX ] ] . EXCBNH [ JYURKEDNC [ k ] ] . RWTUUBJ ) { LGKDX = - 1 ; break ; } } } } } LGKDX ++ ; } fprintf ( QCW , " " , i + 1 ) ; for ( j = 0 ; j < LGKDX ; j ++ ) { if ( j == LGKDX - 1 ) { fprintf ( QCW , " " , JYURKEDNC [ j ] + 65 ) ; } else { fprintf ( QCW , " " , JYURKEDNC [ j ] + 65 ) ; } } fprintf ( QCW , " \n " ) ; } DHHFJU ( OIH ) ; DHHFJU ( QCW ) ; return 0 ; }
>>>Func
METHOD GLJJX
METHOD_RETURN void
PARAM char a
PARAM char b
PARAM char c
<operator>.assignmentMinus a -= 'A'
<operator>.assignmentMinus b -= 'A'
<operator>.assignment VAH [ a ] [ b ] = c
<operator>.assignment VAH [ b ] [ a ] = c
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->5 3->6 4->7 4->8 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 8->1
>>>Token void GLJJX ( char a , char b , char c ) { a -= ' ' ; b -= ' ' ; VAH [ a ] [ b ] = c ; VAH [ b ] [ a ] = c ; }
>>>Func
METHOD main
METHOD_RETURN int
SDLOA SDLOA ( "%d" , & KNXREI )
RETURN return 0 ; return 0 ;
<operator>.lessThan HQMTO < KNXREI
<operator>.postIncrement HQMTO ++
LITERAL 0 return 0 ;
<operator>.assignment HQMTO = 0
SDLOA SDLOA ( "%d %lld %d %d" , & L , & T , & N , & C )
<operator>.assignment YGR = 0
<operator>.assignment time = ( N / C ) * YGR
<operator>.assignment l = N / C - T / YGR
<operator>.assignment YOG = 0
<operator>.assignment nl = N % C
<operator>.assignment tl = T % YGR
<operator>.assignment HXYUL = - 1
printf printf ( "Case #%d: %lld\n" , HQMTO + 1 , time )
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.logicalNot ! YOG
<operator>.assignment i = 0
SDLOA SDLOA ( "%lld" , & d [ i ] . HBN )
<operators>.assignmentShiftLeft d [ i ] . HBN <<= 1
<operator>.assignmentPlus YGR += d [ i ] . HBN
<operator>.multiplication ( N / C ) * YGR
<operator>.subtraction N / C - T / YGR
<operator>.assignment i = 0
<operator>.assignment d [ i ] . QRI = l
<operator>.modulo N % C
<operator>.modulo T % YGR
<operator>.minus - 1
<operator>.assignment i = 0
<operator>.assignmentPlus YOG += d [ i ] . QRI < 0
YMRJH YMRJH ( d   C   sizeof ( struct VUXX ) , DOLYEKIX )
<operator>.assignment ll = L
<operator>.addition HQMTO + 1
<operator>.division N / C
<operator>.division N / C
<operator>.division T / YGR
IDENTIFIER nl if (nl)
<operator>.greaterThan tl > 0
<operator>.notEquals HXYUL != - 1
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.assignmentPlus time += d [ i ] . HBN
<operator>.preIncrement ++ d [ i ] . QRI
<operator>.preDecrement -- nl
<operator>.preDecrement -- d [ i ] . QRI
<operator>.assignmentMinus tl -= d [ i ] . HBN
<operator>.assignment HXYUL = i
<operator>.lessThan d [ i ] . QRI < 0
<operator>.assignment d [ C ] . HBN = - tl
<operator>.assignment d [ C ] . QRI = 1
<operator>.preIncrement ++ C
<operator>.sizeOf sizeof ( struct VUXX )
<operator>.assignment i = 0
<operator>.assignment RLLSA = ll < d [ i ] . QRI ? ll : d [ i ] . QRI
<operator>.assignmentMinus d [ i ] . QRI -= RLLSA
<operator>.assignmentMinus ll -= RLLSA
<operator>.assignmentMinus time -= ( d [ i ] . HBN * RLLSA ) >> 1
<operator>.minus - 1
<operator>.minus - tl
<operator>.conditional ll < d [ i ] . QRI ? ll : d [ i ] . QRI
<operator>.arithmeticShiftRight ( d [ i ] . HBN * RLLSA ) >> 1
<operator>.lessThan ll < d [ i ] . QRI
<operator>.multiplication d [ i ] . HBN * RLLSA
<operator>.addressOf & L
<operator>.addressOf & T
<operator>.addressOf & N
<operator>.addressOf & C
<operator>.addressOf & d [ i ] . HBN
<operator>.fieldAccess d [ i ] . HBN
<operator>.fieldAccess d [ i ] . HBN
<operator>.fieldAccess d [ i ] . QRI
<operator>.fieldAccess d [ i ] . HBN
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER HBN HBN
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER HBN HBN
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER QRI QRI
<operator>.fieldAccess d [ i ] . QRI
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER HBN HBN
<operator>.fieldAccess d [ i ] . HBN
<operator>.fieldAccess d [ i ] . QRI
<operator>.fieldAccess d [ i ] . QRI
<operator>.fieldAccess d [ i ] . HBN
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER QRI QRI
<operator>.fieldAccess d [ C ] . HBN
<operator>.fieldAccess d [ C ] . QRI
<operator>.fieldAccess d [ i ] . QRI
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER HBN HBN
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER QRI QRI
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER QRI QRI
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER HBN HBN
<operator>.indirectIndexAccess d [ C ]
FIELD_IDENTIFIER HBN HBN
<operator>.indirectIndexAccess d [ C ]
FIELD_IDENTIFIER QRI QRI
<operator>.fieldAccess d [ i ] . QRI
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER QRI QRI
<operator>.fieldAccess d [ i ] . QRI
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER QRI QRI
<operator>.fieldAccess d [ i ] . HBN
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER QRI QRI
<operator>.indirectIndexAccess d [ i ]
FIELD_IDENTIFIER HBN HBN
>>>PDG&120 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->12 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->50 0->52 0->53 0->54 0->56 0->57 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->16 4->17 4->19 4->21 4->23 4->24 4->28 4->29 4->30 4->32 4->33 4->34 4->35 4->39 4->39 4->40 4->41 4->42 4->70 4->71 4->72 4->73 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->1 8->1 8->17 8->19 8->21 8->32 8->32 8->33 8->37 8->38 8->40 8->40 8->41 8->41 8->42 8->46 8->57 9->1 9->27 9->28 10->1 10->1 10->16 10->48 10->63 11->1 11->1 11->1 11->31 12->1 12->23 12->36 13->1 13->1 13->1 13->50 14->1 14->1 14->1 14->44 14->65 15->1 15->1 15->1 15->45 16->1 16->1 16->1 17->17 17->18 17->18 17->25 17->26 17->27 17->40 17->74 17->75 17->76 17->78 17->79 17->80 17->81 17->82 17->86 17->87 18->1 18->17 19->19 19->20 19->20 19->31 19->32 19->77 19->83 19->84 20->1 20->19 21->1 21->1 21->1 21->8 21->17 21->21 21->22 21->22 21->36 21->37 21->44 21->48 21->49 21->50 21->53 21->54 21->57 21->85 21->88 21->89 21->92 21->93 21->97 21->98 21->99 21->100 22->1 22->21 23->1 23->1 23->37 23->38 23->45 23->46 23->58 23->59 23->64 24->17 25->1 25->1 25->26 25->27 25->48 25->52 25->69 26->27 27->1 27->28 28->10 28->10 28->42 29->1 29->1 29->11 29->11 30->19 31->1 31->1 32->1 32->8 32->13 32->13 32->21 32->40 33->1 33->1 33->8 33->14 33->14 33->42 34->15 35->1 35->21 36->1 36->1 36->23 37->1 37->1 37->1 37->46 38->1 38->1 38->1 38->68 40->28 40->28 40->41 40->41 41->19 41->29 41->29 41->32 42->29 42->29 42->33 42->33 44->1 44->1 44->51 44->52 44->52 44->53 44->65 44->90 44->91 44->101 44->102 44->103 44->104 45->1 45->1 45->1 45->55 45->56 45->57 45->65 45->94 45->95 45->105 45->106 45->107 45->108 46->1 46->1 46->1 46->8 46->17 46->46 46->47 46->47 46->60 46->61 46->62 46->63 46->66 46->67 46->68 46->69 46->96 46->110 46->111 46->112 46->115 46->116 46->117 46->118 46->119 47->1 47->46 48->1 48->16 48->63 49->1 49->51 49->54 50->1 50->1 51->1 52->1 52->1 52->44 52->65 53->1 53->1 53->45 54->36 54->36 55->1 55->1 56->1 57->1 57->37 58->1 59->1 59->46 60->1 60->1 60->61 60->62 60->69 61->1 62->1 62->1 62->68 63->1 63->1 63->16 64->45 65->1 65->55 66->1 67->1 67->63 67->63 68->60 68->60 68->61 68->62 68->66 68->66 68->109 68->113 68->114 69->1 69->67 69->67
>>>Token int main ( ) { int KNXREI ; SDLOA ( " " , & KNXREI ) ; int HQMTO ; for ( HQMTO = 0 ; HQMTO < KNXREI ; HQMTO ++ ) { SDLOA ( " " , & L , & T , & N , & C ) ; long long YGR = 0 ; int i ; for ( i = 0 ; i < C ; i ++ ) { SDLOA ( " " , & d [ i ] . HBN ) ; d [ i ] . HBN <<= 1 ; YGR += d [ i ] . HBN ; } long long time = ( N / C ) * YGR ; long long l = N / C - T / YGR ; int YOG = 0 ; for ( i = 0 ; i < C ; i ++ ) { d [ i ] . QRI = l ; } long long nl = N % C ; long long tl = T % YGR ; long long HXYUL = - 1 ; for ( i = 0 ; i < C ; i ++ ) { if ( nl ) { time += d [ i ] . HBN ; ++ d [ i ] . QRI ; -- nl ; } if ( tl > 0 ) { -- d [ i ] . QRI ; tl -= d [ i ] . HBN ; HXYUL = i ; } YOG += d [ i ] . QRI < 0 ; } if ( ! YOG ) { if ( HXYUL != - 1 ) { d [ C ] . HBN = - tl ; d [ C ] . QRI = 1 ; ++ C ; } YMRJH ( d , C , sizeof ( struct VUXX ) , DOLYEKIX ) ; long long ll = L ; for ( i = 0 ; i < C ; i ++ ) { long long RLLSA = ll < d [ i ] . QRI ? ll : d [ i ] . QRI ; d [ i ] . QRI -= RLLSA ; ll -= RLLSA ; time -= ( d [ i ] . HBN * RLLSA ) >> 1 ; } } printf ( " \n " , HQMTO + 1 , time ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
TDCFW TDCFW ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
TDCFW TDCFW ( "%d " , & c )
TDCFW TDCFW ( "%d " , & d )
TDCFW TDCFW ( "%d " , & n )
TDCFW TDCFW ( "%c" , & in [ n - 1 ] )
VHNHYS VHNHYS ( i , c , d , n )
<operator>.lessThan j < c
<operator>.postIncrement j ++
<operator>.lessThan j < d
<operator>.postIncrement j ++
<operator>.lessThan j < n - 1
<operator>.postIncrement j ++
TDCFW TDCFW ( "%c " , & in [ j ] )
<operator>.assignment j = 0
TDCFW TDCFW ( "%c " , & ARYIRDL [ j ] . THLCW )
TDCFW TDCFW ( "%c " , & ARYIRDL [ j ] . GPSNTN )
TDCFW TDCFW ( "%c " , & ARYIRDL [ j ] . EVUKX )
<operator>.assignment j = 0
TDCFW TDCFW ( "%c " , & LNTFQVNN [ j ] . THLCW )
TDCFW TDCFW ( "%c " , & LNTFQVNN [ j ] . GPSNTN )
<operator>.assignment j = 0
<operator>.subtraction n - 1
<operator>.subtraction n - 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.addressOf & in [ n - 1 ]
<operator>.addressOf & in [ j ]
<operator>.indirectIndexAccess in [ n - 1 ]
<operator>.addressOf & ARYIRDL [ j ] . THLCW
<operator>.addressOf & ARYIRDL [ j ] . GPSNTN
<operator>.addressOf & ARYIRDL [ j ] . EVUKX
<operator>.addressOf & LNTFQVNN [ j ] . THLCW
<operator>.addressOf & LNTFQVNN [ j ] . GPSNTN
<operator>.indirectIndexAccess in [ j ]
<operator>.fieldAccess ARYIRDL [ j ] . THLCW
<operator>.fieldAccess ARYIRDL [ j ] . GPSNTN
<operator>.fieldAccess ARYIRDL [ j ] . EVUKX
<operator>.fieldAccess LNTFQVNN [ j ] . THLCW
<operator>.fieldAccess LNTFQVNN [ j ] . GPSNTN
<operator>.indirectIndexAccess ARYIRDL [ j ]
FIELD_IDENTIFIER THLCW THLCW
<operator>.indirectIndexAccess ARYIRDL [ j ]
FIELD_IDENTIFIER GPSNTN GPSNTN
<operator>.indirectIndexAccess ARYIRDL [ j ]
FIELD_IDENTIFIER EVUKX EVUKX
<operator>.indirectIndexAccess LNTFQVNN [ j ]
FIELD_IDENTIFIER THLCW THLCW
<operator>.indirectIndexAccess LNTFQVNN [ j ]
FIELD_IDENTIFIER GPSNTN GPSNTN
>>>PDG&57 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->15 4->17 4->20 4->24 4->27 4->28 4->29 4->30 4->31 4->32 4->33 4->35 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->12 8->13 9->1 9->1 9->12 9->15 10->1 10->1 10->12 10->28 10->29 11->1 11->1 12->1 12->1 12->1 12->1 12->5 12->8 12->9 12->10 12->13 12->15 12->28 13->1 13->12 13->13 13->14 13->14 13->21 13->22 13->23 13->36 13->37 13->38 13->42 13->43 13->44 13->47 13->48 13->49 13->50 13->51 13->52 14->1 14->13 15->1 15->12 15->15 15->16 15->16 15->25 15->26 15->39 15->40 15->45 15->46 15->53 15->54 15->55 15->56 16->1 16->15 17->1 17->1 17->17 17->18 17->18 17->19 17->28 17->34 17->41 18->1 18->17 19->1 19->1 20->13 21->1 21->1 22->1 22->1 23->1 23->1 24->15 25->1 25->1 26->1 26->1 27->1 27->17 28->17 28->17 28->29 29->12
>>>Token int main ( ) { int t , c , d , n ; TDCFW ( " " , & t ) ; int i , j , k ; for ( i = 1 ; i <= t ; i ++ ) { TDCFW ( " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) { TDCFW ( " " , & ARYIRDL [ j ] . THLCW ) ; TDCFW ( " " , & ARYIRDL [ j ] . GPSNTN ) ; TDCFW ( " " , & ARYIRDL [ j ] . EVUKX ) ; } TDCFW ( " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) { TDCFW ( " " , & LNTFQVNN [ j ] . THLCW ) ; TDCFW ( " " , & LNTFQVNN [ j ] . GPSNTN ) ; } TDCFW ( " " , & n ) ; for ( j = 0 ; j < n - 1 ; j ++ ) TDCFW ( " " , & in [ j ] ) ; TDCFW ( " " , & in [ n - 1 ] ) ; VHNHYS ( i , c , d , n ) ; } return 0 ; }
>>>Func
METHOD UPB
METHOD_RETURN int
PARAM int a
PARAM int b
RETURN return a ; return a ;
<operator>.logicalNot ! a
<operator>.notEquals b != 0
IDENTIFIER a return a ;
RETURN return b ; return b ;
IDENTIFIER b return b ;
<operator>.greaterThan a > b
<operator>.assignmentMinus a -= b
<operator>.assignmentMinus b -= a
>>>PDG&13 0->2 0->3 0->5 0->6 0->7 0->9 0->10 0->11 0->12 2->5 3->1 3->6 3->9 4->1 5->1 5->1 5->4 5->6 5->7 5->8 5->10 6->6 6->10 6->10 7->4 8->1 9->8 10->6 10->7 10->11 10->11 10->11 10->12 10->12 10->12 11->7 11->10 12->6
>>>Token int UPB ( int a , int b ) { if ( ! a ) return b ; while ( b != 0 ) { if ( a > b ) a -= b ; else b -= a ; } return a ; }
>>>Func
METHOD UEVVVCE
METHOD_RETURN int
PARAM const void * p1
PARAM const void * p2
<operator>.assignment A = * ( CKVX * ) p1
<operator>.assignment B = * ( CKVX * ) p2
RETURN return A . OHAT <= B . OHAT ? ( A . OHAT < B . OHAT ? - 1 : ( A . t >= B . t ? ( A . t > B . t ? - 1 : ( A . c >= B . c ? ( A . c > B . c ? - 1 : 0 ) : 1 ) ) : 1 ) ) : 1 ; return A . OHAT <= B . OHAT ? ( A . OHAT < B . OHAT ? - 1 : ( A . t >= B . t ? ( A . t > B . t ? - 1 : ( A . c >= B . c ? ( A . c > B . c ? - 1 : 0 ) : 1 ) ) : 1 ) ) : 1 ;
<operator>.conditional A . OHAT <= B . OHAT ? ( A . OHAT < B . OHAT ? - 1 : ( A . t >= B . t ? ( A . t > B . t ? - 1 : ( A . c >= B . c ? ( A . c > B . c ? - 1 : 0 ) : 1 ) ) : 1 ) ) : 1
<operator>.cast ( CKVX * ) p1
<operator>.cast ( CKVX * ) p2
<operator>.lessEqualsThan A . OHAT <= B . OHAT
<operator>.conditional A . OHAT < B . OHAT ? - 1 : ( A . t >= B . t ? ( A . t > B . t ? - 1 : ( A . c >= B . c ? ( A . c > B . c ? - 1 : 0 ) : 1 ) ) : 1 )
<operator>.lessThan A . OHAT < B . OHAT
<operator>.minus - 1
<operator>.conditional A . t >= B . t ? ( A . t > B . t ? - 1 : ( A . c >= B . c ? ( A . c > B . c ? - 1 : 0 ) : 1 ) ) : 1
<operator>.greaterEqualsThan A . t >= B . t
<operator>.conditional A . t > B . t ? - 1 : ( A . c >= B . c ? ( A . c > B . c ? - 1 : 0 ) : 1 )
<operator>.greaterThan A . t > B . t
<operator>.minus - 1
<operator>.conditional A . c >= B . c ? ( A . c > B . c ? - 1 : 0 ) : 1
<operator>.greaterEqualsThan A . c >= B . c
<operator>.conditional A . c > B . c ? - 1 : 0
<operator>.greaterThan A . c > B . c
<operator>.minus - 1
<operator>.fieldAccess A . OHAT
<operator>.fieldAccess B . OHAT
FIELD_IDENTIFIER OHAT OHAT
FIELD_IDENTIFIER OHAT OHAT
<operator>.fieldAccess A . t
<operator>.fieldAccess B . t
FIELD_IDENTIFIER t t
FIELD_IDENTIFIER t t
<operator>.fieldAccess A . t
<operator>.fieldAccess B . t
FIELD_IDENTIFIER t t
FIELD_IDENTIFIER t t
<operator>.fieldAccess A . c
<operator>.fieldAccess B . c
FIELD_IDENTIFIER c c
FIELD_IDENTIFIER c c
<operator>.fieldAccess A . c
<operator>.fieldAccess B . c
FIELD_IDENTIFIER c c
FIELD_IDENTIFIER c c
>>>PDG&44 0->2 0->3 0->7 0->8 0->9 0->11 0->13 0->14 0->16 0->18 0->19 0->21 0->23 2->8 3->9 4->1 4->1 4->1 4->10 4->12 4->15 4->17 4->20 4->22 5->1 5->1 5->1 5->10 5->12 5->15 5->17 5->20 5->22 6->1 7->1 7->1 7->1 7->6 8->1 9->1 10->1 10->1 10->11 10->12 10->12 10->12 10->24 10->25 10->26 10->27 11->1 11->1 11->1 12->1 12->1 12->13 12->14 12->15 12->28 12->29 12->30 12->31 13->7 13->11 14->1 14->1 15->1 15->1 15->16 15->17 15->17 15->17 15->32 15->33 15->34 15->35 16->1 16->1 17->1 17->1 17->18 17->19 17->20 17->36 17->37 17->38 17->39 18->7 18->11 18->14 18->16 19->1 19->1 20->1 20->1 20->21 20->22 20->22 20->22 20->40 20->41 20->42 20->43 21->1 22->1 22->1 22->23 23->7 23->11 23->14 23->16 23->19 23->21
>>>Token int UEVVVCE ( const void * p1 , const void * p2 ) { CKVX A = * ( CKVX * ) p1 , B = * ( CKVX * ) p2 ; return A . OHAT <= B . OHAT ? ( A . OHAT < B . OHAT ? - 1 : ( A . t >= B . t ? ( A . t > B . t ? - 1 : ( A . c >= B . c ? ( A . c > B . c ? - 1 : 0 ) : 1 ) ) : 1 ) ) : 1 ; }
>>>Func
METHOD LYWNJQDXMUUEQ
METHOD_RETURN void
PARAM int * a
PARAM int n
<operator>.greaterEqualsThan i >= 1
<operator>.postDecrement i --
<operator>.assignment i = n / 2
CJUQIVJJGVH CJUQIVJJGVH ( a , i , n )
<operator>.division n / 2
>>>PDG&9 0->2 0->3 0->4 0->5 0->7 0->8 2->1 2->7 3->8 4->1 4->1 4->4 4->5 4->7 4->7 5->1 5->4 6->1 6->1 6->4 7->5 8->1 8->6 8->6 8->7
>>>Token void LYWNJQDXMUUEQ ( int * a , int n ) { int i ; for ( i = n / 2 ; i >= 1 ; i -- ) { CJUQIVJJGVH ( a , i , n ) ; } }
>>>Func
METHOD LKTPF
METHOD_RETURN void
PARAM int n
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment wp [ i ] = DVN [ i ] / TLVX [ i ]
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
printf printf ( "%.10f\n" , 0.25 * wp [ i ] + 0.5 * VYG [ i ] + 0.25 * UKYP [ i ] )
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment VYG [ i ] = 0
<operator>.assignmentDivision VYG [ i ] /= TLVX [ i ]
<operator>.assignment i = 0
<operator>.assignment UKYP [ i ] = 0
<operator>.assignmentDivision UKYP [ i ] /= TLVX [ i ]
<operator>.assignment i = 0
<operator>.division DVN [ i ] / TLVX [ i ]
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignmentPlus VYG [ i ] += SHIJOCYFV ( i , j )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignmentPlus UKYP [ i ] += ( i != j && PGBD [ i ] [ j ] != - 1 ) ? VYG [ j ] : 0
<operator>.addition 0.25 * wp [ i ] + 0.5 * VYG [ i ] + 0.25 * UKYP [ i ]
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.addition 0.25 * wp [ i ] + 0.5 * VYG [ i ]
<operator>.multiplication 0.25 * UKYP [ i ]
SHIJOCYFV SHIJOCYFV ( i , j )
<operator>.conditional ( i != j && PGBD [ i ] [ j ] != - 1 ) ? VYG [ j ] : 0
<operator>.multiplication 0.25 * wp [ i ]
<operator>.multiplication 0.5 * VYG [ i ]
<operator>.logicalAnd i != j && PGBD [ i ] [ j ] != - 1
<operator>.notEquals i != j
<operator>.notEquals PGBD [ i ] [ j ] != - 1
<operator>.minus - 1
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess DVN [ i ]
<operator>.indirectIndexAccess TLVX [ i ]
<operator>.indirectIndexAccess VYG [ i ]
<operator>.indirectIndexAccess VYG [ i ]
<operator>.indirectIndexAccess TLVX [ i ]
<operator>.indirectIndexAccess UKYP [ i ]
<operator>.indirectIndexAccess UKYP [ i ]
<operator>.indirectIndexAccess TLVX [ i ]
<operator>.indirectIndexAccess VYG [ i ]
<operator>.indirectIndexAccess UKYP [ i ]
<operator>.indirectIndexAccess UKYP [ i ]
<operator>.indirectIndexAccess VYG [ j ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess VYG [ i ]
<operator>.indirectIndexAccess PGBD [ i ] [ j ]
<operator>.indirectIndexAccess PGBD [ i ]
>>>PDG&58 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->20 0->22 0->23 0->25 0->26 0->27 0->29 0->30 0->32 0->33 0->34 0->35 0->36 0->38 0->40 2->3 3->3 3->4 3->4 3->5 3->6 3->21 3->41 3->42 3->43 4->1 4->3 5->35 6->6 6->7 6->7 6->8 6->15 6->16 6->22 6->22 6->29 6->33 6->44 6->45 6->46 7->1 7->6 8->8 8->9 8->9 8->10 8->18 8->19 8->25 8->25 8->30 8->38 8->47 8->48 8->49 9->1 9->8 10->1 10->1 10->1 10->10 10->11 10->11 10->12 10->28 10->31 10->32 10->35 10->36 10->52 10->54 10->55 11->1 11->10 13->3 14->6 15->16 15->24 16->36 17->8 18->19 18->27 19->32 20->1 20->10 21->5 21->5 21->16 21->19 22->6 22->22 22->23 22->24 22->33 22->33 22->50 23->22 24->16 25->8 25->25 25->26 25->27 25->34 25->37 25->38 25->38 25->51 26->25 27->19 29->22 30->25 32->12 32->12 32->28 32->28 33->7 33->23 33->24 33->24 35->12 35->12 35->28 35->28 35->31 35->31 36->12 36->12 36->28 36->28 36->31 36->31 37->53 38->9 38->26 38->37 38->37 38->39 38->40 38->56 38->57 39->37 39->37 40->39
>>>Token void LKTPF ( int n ) { double wp [ 100 ] ; double VYG [ 100 ] ; double UKYP [ 100 ] ; for ( int i = 0 ; i < n ; i ++ ) wp [ i ] = DVN [ i ] / TLVX [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { VYG [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) VYG [ i ] += SHIJOCYFV ( i , j ) ; VYG [ i ] /= TLVX [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { UKYP [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) UKYP [ i ] += ( i != j && PGBD [ i ] [ j ] != - 1 ) ? VYG [ j ] : 0 ; UKYP [ i ] /= TLVX [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) printf ( " \n " , 0.25 * wp [ i ] + 0.5 * VYG [ i ] + 0.25 * UKYP [ i ] ) ; }
>>>Func
METHOD VPUYDE
METHOD_RETURN void
PARAM char c
<operator>.greaterThan PLOFREBMUTSQ > 0
<operator>.assignment e = WEVNYDB [ HFXO ( ) ] [ c ]
IDENTIFIER e if (e)
RUMU RUMU ( c )
AAN AAN ( )
RUMU RUMU ( e )
HUOMY HUOMY ( )
RUMU RUMU ( c )
<operator>.indirectIndexAccess WEVNYDB [ HFXO ( ) ] [ c ]
<operator>.indirectIndexAccess WEVNYDB [ HFXO ( ) ]
HFXO HFXO ( )
<operator>.indirectIndexAccess CDIQIAWLNRIILFM [ c ]
>>>PDG&15 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->6 2->10 3->1 3->1 3->4 3->6 3->7 3->8 3->11 3->12 3->13 3->14 4->1 4->1 4->8 7->1 8->1 8->1 14->9 14->10
>>>Token void VPUYDE ( char c ) { if ( PLOFREBMUTSQ > 0 ) { char e = WEVNYDB [ HFXO ( ) ] [ c ] ; if ( e ) { AAN ( ) ; RUMU ( e ) ; } else if ( CDIQIAWLNRIILFM [ c ] ) HUOMY ( ) ; else RUMU ( c ) ; } else RUMU ( c ) ; }
>>>Func
METHOD XRPGCGFPSQKIME
METHOD_RETURN long double
PARAM int i
PARAM int n
PARAM int * * BIFFHK
PARAM long double * ALY
<operator>.assignment AAETNY = 0
<operator>.assignment JHYB = 0.0
RETURN return ( JHYB ) / ( ( long double ) AAETNY ) ; return ( JHYB ) / ( ( long double ) AAETNY ) ;
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.division ( JHYB ) / ( ( long double ) AAETNY )
<operator>.assignment j = 0
<operator>.notEquals BIFFHK [ i ] [ j ] != - 1
<operator>.cast ( long double ) AAETNY
<operator>.postIncrement AAETNY ++
<operator>.assignmentPlus JHYB += ALY [ j ]
<operator>.minus - 1
<operator>.indirectIndexAccess BIFFHK [ i ] [ j ]
<operator>.indirectIndexAccess BIFFHK [ i ]
<operator>.indirectIndexAccess ALY [ j ]
>>>PDG&21 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 2->1 3->9 4->1 5->1 5->16 6->1 6->11 6->14 6->15 7->1 7->11 7->16 8->1 9->1 9->1 9->1 9->9 9->10 9->10 9->13 9->17 9->18 9->19 10->1 10->9 11->1 11->1 11->1 11->8 12->1 12->9 13->1 13->1 13->1 13->15 13->16 13->20 14->1 15->1 15->11 15->14 16->1 16->1 16->11 17->13
>>>Token long double XRPGCGFPSQKIME ( int i , int n , int * * BIFFHK , long double * ALY ) { int j ; int AAETNY = 0 ; long double JHYB = 0.0 ; for ( j = 0 ; j < n ; j ++ ) { if ( BIFFHK [ i ] [ j ] != - 1 ) { AAETNY ++ ; JHYB += ALY [ j ] ; } } return ( JHYB ) / ( ( long double ) AAETNY ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment DSAXR = 0
<operator>.assignment UPETBY = 5
<operator>.assignment BHKSL = 0
printf printf ( "Input a number, this is the bigger bound of the lerp:\n" )
KASYL KASYL ( "%f" , & UPETBY )
printf printf ( "Input a number, this is in how many steps you want to divide the " "lerp:\n" )
KASYL KASYL ( "%f" , & BHKSL )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < BHKSL + 1
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
printf printf ( "%f\n"   QPYM ( DSAXR , UPETBY , i / BHKSL ) )
<operator>.addition BHKSL + 1
QPYM QPYM ( DSAXR , UPETBY , i / BHKSL )
<operator>.division i / BHKSL
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->1 2->1 2->16 3->1 3->1 3->6 3->16 4->1 4->8 4->10 4->15 4->17 5->1 6->1 6->1 6->16 7->1 8->1 8->1 8->10 8->15 8->17 9->1 10->1 10->1 10->1 10->10 10->11 10->14 10->15 10->16 10->17 10->17 11->1 11->10 12->9 13->1 13->10 14->1 14->1 15->1 16->1 16->1 16->1 16->14 16->14 16->14 17->10 17->11 17->15 17->16 17->16
>>>Token int main ( ) { float DSAXR = 0 ; float UPETBY = 5 ; float BHKSL = 0 ; printf ( " \n " ) ; KASYL ( " " , & UPETBY ) ; printf ( " " " \n " ) ; KASYL ( " " , & BHKSL ) ; for ( int i = 0 ; i < BHKSL + 1 ; i ++ ) { printf ( " \n " , QPYM ( DSAXR , UPETBY , i / BHKSL ) ) ; } return 0 ; }
>>>Func
METHOD YMRFPOGDPJYBQU
METHOD_RETURN int
PARAM int PGF [ 10 ] [ 10 ]
PARAM int WOGX
PARAM int MRMNXR
<operator>.assignment c = 0
<operator>.assignment b = 0
<operator>.assignment e = 0
<operator>.assignment d = 0
RETURN return 0 ; return 0 ;
<operator>.equals PGF [ WOGX ] [ MRMNXR ] == 10
LITERAL 0 return 0 ;
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
RETURN return 2 ; return 2 ;
LITERAL 2 return 2 ;
<operator>.equals PGF [ WOGX ] [ MRMNXR ] == 20
<operator>.equals PGF [ WOGX + 1 ] [ MRMNXR ] == 20
<operator>.equals PGF [ WOGX - 1 ] [ MRMNXR ] == 20
<operator>.equals PGF [ WOGX ] [ MRMNXR + 1 ] == 20
<operator>.equals PGF [ WOGX ] [ MRMNXR - 1 ] == 20
<operator>.equals b == 1
<operator>.equals c == 1
<operator>.equals d == 1
<operator>.equals e == 1
<operator>.assignment b = 1
<operator>.assignment c = 1
<operator>.assignment d = 1
<operator>.assignment e = 1
<operator>.equals PGF [ WOGX ] [ MRMNXR ] == 30
<operator>.equals PGF [ WOGX + 1 ] [ MRMNXR ] == 20
<operator>.equals PGF [ WOGX - 1 ] [ MRMNXR ] == 20
<operator>.equals PGF [ WOGX ] [ MRMNXR + 1 ] == 20
<operator>.equals PGF [ WOGX ] [ MRMNXR - 1 ] == 20
<operator>.addition MRMNXR + 1
<operator>.subtraction MRMNXR - 1
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX + 1 ] [ MRMNXR ] = 50
RETURN return 4 ; return 4 ;
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX - 1 ] [ MRMNXR ] = 50
RETURN return 4 ; return 4 ;
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX ] [ MRMNXR + 1 ] = 50
RETURN return 4 ; return 4 ;
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX ] [ MRMNXR - 1 ] = 50
RETURN return 4 ; return 4 ;
<operator>.equals PGF [ WOGX + 1 ] [ MRMNXR ] == 30
<operator>.equals PGF [ WOGX - 1 ] [ MRMNXR ] == 30
<operator>.equals PGF [ WOGX ] [ MRMNXR + 1 ] == 30
<operator>.equals PGF [ WOGX ] [ MRMNXR - 1 ] == 30
<operator>.logicalAnd b == 1 && c == 1
<operator>.addition WOGX + 1
<operator>.subtraction WOGX - 1
LITERAL 4 return 4 ;
RETURN return 0 ; return 0 ;
LITERAL 4 return 4 ;
RETURN return 0 ; return 0 ;
LITERAL 4 return 4 ;
RETURN return 0 ; return 0 ;
LITERAL 4 return 4 ;
RETURN return 0 ; return 0 ;
<operator>.assignment b = 1
<operator>.assignment c = 1
<operator>.assignment d = 1
<operator>.assignment e = 1
LITERAL 0 return 0 ;
LITERAL 0 return 0 ;
<operator>.addition MRMNXR + 1
LITERAL 0 return 0 ;
<operator>.subtraction MRMNXR - 1
LITERAL 0 return 0 ;
<operator>.equals b == 1
<operator>.equals c == 1
<operator>.logicalAnd PGF [ WOGX + 1 ] [ MRMNXR ] == 30 && PGF [ WOGX - 1 ] [ MRMNXR ] == 30
<operator>.addition WOGX + 1
<operator>.subtraction WOGX - 1
<operator>.addition MRMNXR + 1
<operator>.subtraction MRMNXR - 1
<operator>.addition MRMNXR + 1
<operator>.subtraction MRMNXR - 1
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX + 1 ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX - 1 ] [ MRMNXR ] = 50
RETURN return 7 ; return 7 ;
<operator>.logicalAnd d == 1 && e == 1
<operator>.addition WOGX + 1
<operator>.subtraction WOGX - 1
<operator>.addition WOGX + 1
<operator>.subtraction WOGX - 1
<operator>.equals PGF [ WOGX + 1 ] [ MRMNXR ] == 30
<operator>.equals PGF [ WOGX - 1 ] [ MRMNXR ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.equals d == 1
<operator>.equals e == 1
<operator>.logicalAnd PGF [ WOGX ] [ MRMNXR + 1 ] == 30 && PGF [ WOGX ] [ MRMNXR - 1 ] == 30
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX ] [ MRMNXR - 1 ] = 50
<operator>.assignment PGF [ WOGX ] [ MRMNXR + 1 ] = 50
RETURN return 7 ; return 7 ;
<operator>.equals d == 1
<operator>.addition WOGX + 1
<operator>.subtraction WOGX - 1
<operator>.addition WOGX + 1
<operator>.subtraction WOGX - 1
<operator>.equals PGF [ WOGX ] [ MRMNXR + 1 ] == 30
<operator>.equals PGF [ WOGX ] [ MRMNXR - 1 ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.logicalAnd PGF [ WOGX ] [ MRMNXR + 1 ] == 30 && PGF [ WOGX ] [ MRMNXR + 2 ] == 30
<operator>.addition MRMNXR + 1
<operator>.subtraction MRMNXR - 1
<operator>.subtraction MRMNXR - 1
<operator>.addition MRMNXR + 1
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX ] [ MRMNXR + 1 ] = 50
<operator>.assignment PGF [ WOGX ] [ MRMNXR + 2 ] = 50
RETURN return 7 ; return 7 ;
<operator>.equals e == 1
<operator>.equals PGF [ WOGX ] [ MRMNXR + 1 ] == 30
<operator>.equals PGF [ WOGX ] [ MRMNXR + 2 ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.logicalAnd PGF [ WOGX ] [ MRMNXR - 1 ] == 30 && PGF [ WOGX ] [ MRMNXR - 2 ] == 30
<operator>.addition MRMNXR + 1
<operator>.addition MRMNXR + 2
<operator>.addition MRMNXR + 1
<operator>.addition MRMNXR + 2
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX ] [ MRMNXR - 1 ] = 50
<operator>.assignment PGF [ WOGX ] [ MRMNXR - 2 ] = 50
RETURN return 7 ; return 7 ;
<operator>.equals c == 1
<operator>.equals PGF [ WOGX ] [ MRMNXR - 1 ] == 30
<operator>.equals PGF [ WOGX ] [ MRMNXR - 2 ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.logicalAnd PGF [ WOGX - 1 ] [ MRMNXR ] == 30 && PGF [ WOGX - 2 ] [ MRMNXR ] == 30
<operator>.subtraction MRMNXR - 1
<operator>.subtraction MRMNXR - 2
<operator>.subtraction MRMNXR - 1
<operator>.subtraction MRMNXR - 2
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX - 1 ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX - 2 ] [ MRMNXR ] = 50
RETURN return 7 ; return 7 ;
<operator>.equals b == 1
<operator>.equals PGF [ WOGX - 1 ] [ MRMNXR ] == 30
<operator>.equals PGF [ WOGX - 2 ] [ MRMNXR ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.logicalAnd PGF [ WOGX + 1 ] [ MRMNXR ] == 30 && PGF [ WOGX + 2 ] [ MRMNXR ] == 30
<operator>.assignment PGF [ WOGX ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX + 1 ] [ MRMNXR ] = 50
<operator>.assignment PGF [ WOGX + 2 ] [ MRMNXR ] = 50
RETURN return 7 ; return 7 ;
<operator>.subtraction WOGX - 1
<operator>.subtraction WOGX - 2
<operator>.subtraction WOGX - 1
<operator>.subtraction WOGX - 2
<operator>.equals PGF [ WOGX + 1 ] [ MRMNXR ] == 30
<operator>.equals PGF [ WOGX + 2 ] [ MRMNXR ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.addition WOGX + 1
<operator>.addition WOGX + 2
<operator>.addition WOGX + 1
<operator>.addition WOGX + 2
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR + 2 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR + 2 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR - 2 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR - 2 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 2 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 2 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX - 2 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX - 1 ]
<operator>.indirectIndexAccess PGF [ WOGX - 2 ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX + 2 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX + 2 ] [ MRMNXR ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX + 2 ]
<operator>.indirectIndexAccess PGF [ WOGX ]
<operator>.indirectIndexAccess PGF [ WOGX + 1 ]
<operator>.indirectIndexAccess PGF [ WOGX + 2 ]
>>>PDG&281 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->138 0->139 0->140 0->141 0->143 0->144 0->145 0->146 0->147 0->148 0->149 0->150 0->151 0->152 0->153 0->154 0->155 0->156 0->158 0->159 0->160 0->161 0->162 0->163 0->164 0->165 0->166 0->167 0->168 0->169 0->170 0->171 0->172 0->173 0->174 2->1 3->1 3->52 3->53 3->88 3->89 4->1 4->33 4->34 4->79 4->80 5->1 5->1 5->21 5->73 5->136 6->1 6->1 6->20 6->72 7->1 7->1 7->23 7->96 7->121 8->1 8->1 8->22 8->95 9->1 10->1 10->12 10->13 10->15 10->15 10->175 10->176 10->177 10->178 11->9 12->1 12->1 13->1 14->13 15->16 15->17 15->18 15->19 15->20 15->28 15->28 15->33 15->34 15->52 15->53 15->179 15->180 15->181 15->182 15->183 15->184 15->185 15->186 15->187 15->192 16->24 16->29 17->25 17->30 18->26 18->31 19->27 19->32 20->21 20->29 20->75 20->188 20->193 21->22 21->30 21->76 21->189 21->196 22->23 22->31 22->68 22->190 22->199 23->9 23->32 23->70 23->191 23->202 24->20 25->21 26->22 27->23 28->9 28->47 28->48 28->49 28->50 28->51 28->72 28->79 28->80 28->88 28->89 28->205 28->206 28->207 28->208 28->217 28->218 28->219 28->220 29->35 29->36 29->37 29->55 29->86 29->194 29->195 29->209 29->210 30->38 30->39 30->40 30->57 30->87 30->197 30->198 30->211 30->212 31->41 31->42 31->43 31->59 31->77 31->200 31->201 31->213 31->214 32->44 32->45 32->46 32->61 32->78 32->203 32->204 32->215 32->216 34->68 34->70 34->77 37->1 40->1 43->1 46->1 47->62 47->90 47->166 48->63 48->74 48->91 48->152 49->64 49->107 49->122 50->65 50->97 50->108 50->137 51->74 51->85 51->90 51->95 51->103 51->221 51->226 53->75 53->76 53->86 54->37 55->1 56->40 57->1 58->43 59->1 60->46 61->1 62->72 63->73 63->136 64->95 65->96 65->121 66->55 67->57 69->59 70->78 71->61 72->51 72->51 72->73 72->151 73->51 73->51 73->136 74->81 74->82 74->83 74->84 74->93 74->105 74->106 74->223 74->224 74->225 74->228 74->229 74->230 76->87 80->113 80->114 80->115 80->128 80->129 80->130 80->131 80->143 84->1 85->97 85->102 85->107 85->113 85->231 85->236 89->103 89->104 89->105 89->106 89->162 89->171 89->172 89->173 89->174 90->74 90->74 90->91 90->104 90->222 90->227 91->74 91->74 92->84 93->1 94->93 95->85 95->85 95->96 95->102 96->85 96->85 96->121 97->98 97->99 97->100 97->101 97->110 97->115 97->116 97->233 97->234 97->235 97->238 97->239 97->240 101->1 102->112 102->121 102->122 102->128 102->241 102->246 104->105 104->106 107->97 107->97 107->108 107->114 107->232 107->237 108->97 108->97 109->101 110->1 111->110 112->117 112->118 112->119 112->120 112->125 112->130 112->131 112->243 112->244 112->245 112->248 112->249 112->250 114->115 115->116 120->1 121->127 121->136 121->137 121->143 121->251 121->256 122->112 122->112 122->123 122->129 122->242 122->247 123->112 123->112 124->120 125->1 126->125 127->132 127->133 127->134 127->135 127->140 127->145 127->146 127->253 127->254 127->255 127->258 127->259 127->260 135->1 136->142 136->151 136->152 136->162 136->261 136->266 137->127 137->127 137->138 137->144 137->252 137->257 138->127 138->127 139->135 140->1 141->140 142->147 142->148 142->149 142->150 142->155 142->164 142->165 142->263 142->264 142->265 142->268 142->269 142->270 143->144 143->145 144->145 145->146 150->1 151->9 151->157 151->166 151->171 151->271 151->276 152->142 152->142 152->153 152->163 152->262 152->267 153->142 153->142 154->150 155->1 156->155 157->158 157->159 157->160 157->161 157->169 157->173 157->174 157->273 157->274 157->275 157->278 157->279 157->280 161->1 162->163 162->164 163->164 164->165 166->157 166->157 166->167 166->172 166->272 166->277 167->157 167->157 168->161 169->1 170->169
>>>Token int YMRFPOGDPJYBQU ( int PGF [ 10 ] [ 10 ] , int WOGX , int MRMNXR ) { int c = 0 , b = 0 , e = 0 , d = 0 ; if ( PGF [ WOGX ] [ MRMNXR ] == 10 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; return 2 ; } else if ( PGF [ WOGX ] [ MRMNXR ] == 20 ) { if ( PGF [ WOGX + 1 ] [ MRMNXR ] == 20 ) { b = 1 ; } if ( PGF [ WOGX - 1 ] [ MRMNXR ] == 20 ) { c = 1 ; } if ( PGF [ WOGX ] [ MRMNXR + 1 ] == 20 ) { d = 1 ; } if ( PGF [ WOGX ] [ MRMNXR - 1 ] == 20 ) { e = 1 ; } if ( b == 1 ) { if ( PGF [ WOGX + 1 ] [ MRMNXR ] == 20 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; PGF [ WOGX + 1 ] [ MRMNXR ] = 50 ; return 4 ; } else { return 0 ; } } if ( c == 1 ) { if ( PGF [ WOGX - 1 ] [ MRMNXR ] == 20 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; PGF [ WOGX - 1 ] [ MRMNXR ] = 50 ; return 4 ; } else { return 0 ; } } if ( d == 1 ) { if ( PGF [ WOGX ] [ MRMNXR + 1 ] == 20 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; PGF [ WOGX ] [ MRMNXR + 1 ] = 50 ; return 4 ; } else { return 0 ; } } if ( e == 1 ) { if ( PGF [ WOGX ] [ MRMNXR - 1 ] == 20 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; PGF [ WOGX ] [ MRMNXR - 1 ] = 50 ; return 4 ; } else { return 0 ; } } } else if ( PGF [ WOGX ] [ MRMNXR ] == 30 ) { if ( PGF [ WOGX + 1 ] [ MRMNXR ] == 30 ) { b = 1 ; } if ( PGF [ WOGX - 1 ] [ MRMNXR ] == 30 ) { c = 1 ; } if ( PGF [ WOGX ] [ MRMNXR + 1 ] == 30 ) { d = 1 ; } if ( PGF [ WOGX ] [ MRMNXR - 1 ] == 30 ) { e = 1 ; } if ( b == 1 && c == 1 ) { if ( PGF [ WOGX + 1 ] [ MRMNXR ] == 30 && PGF [ WOGX - 1 ] [ MRMNXR ] == 30 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; PGF [ WOGX + 1 ] [ MRMNXR ] = 50 ; PGF [ WOGX - 1 ] [ MRMNXR ] = 50 ; return 7 ; } else { return 0 ; } } else if ( d == 1 && e == 1 ) { if ( PGF [ WOGX ] [ MRMNXR + 1 ] == 30 && PGF [ WOGX ] [ MRMNXR - 1 ] == 30 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; PGF [ WOGX ] [ MRMNXR - 1 ] = 50 ; PGF [ WOGX ] [ MRMNXR + 1 ] = 50 ; return 7 ; } else { return 0 ; } } else if ( d == 1 ) { if ( PGF [ WOGX ] [ MRMNXR + 1 ] == 30 && PGF [ WOGX ] [ MRMNXR + 2 ] == 30 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; PGF [ WOGX ] [ MRMNXR + 1 ] = 50 ; PGF [ WOGX ] [ MRMNXR + 2 ] = 50 ; return 7 ; } else { return 0 ; } } else if ( e == 1 ) { if ( PGF [ WOGX ] [ MRMNXR - 1 ] == 30 && PGF [ WOGX ] [ MRMNXR - 2 ] == 30 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; PGF [ WOGX ] [ MRMNXR - 1 ] = 50 ; PGF [ WOGX ] [ MRMNXR - 2 ] = 50 ; return 7 ; } else { return 0 ; } } else if ( c == 1 ) { if ( PGF [ WOGX - 1 ] [ MRMNXR ] == 30 && PGF [ WOGX - 2 ] [ MRMNXR ] == 30 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; PGF [ WOGX - 1 ] [ MRMNXR ] = 50 ; PGF [ WOGX - 2 ] [ MRMNXR ] = 50 ; return 7 ; } else { return 0 ; } } else if ( b == 1 ) { if ( PGF [ WOGX + 1 ] [ MRMNXR ] == 30 && PGF [ WOGX + 2 ] [ MRMNXR ] == 30 ) { PGF [ WOGX ] [ MRMNXR ] = 50 ; PGF [ WOGX + 1 ] [ MRMNXR ] = 50 ; PGF [ WOGX + 2 ] [ MRMNXR ] = 50 ; return 7 ; } else { return 0 ; } } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
MLKQJ MLKQJ ( "%d" , & ECSR )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan HFQRDJ <= ECSR
<operator>.postIncrement HFQRDJ ++
LITERAL 0 return 0 ;
<operator>.assignment HFQRDJ = 1
<operator>.assignment wp [ AHV ] = { 0 }
<operator>.assignment RTM [ AHV ] = { 0 }
<operator>.assignment CQJU [ AHV ] = { 0 }
MLKQJ MLKQJ ( "%d" , & n )
printf printf ( "Case #%d:\n" , HFQRDJ )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
printf printf ( "%.12lf\n" , 0.25 * wp [ i ] + 0.50 * RTM [ i ] + 0.25 * CQJU [ i ] )
<operator>.arrayInitializer { 0 }
<operator>.arrayInitializer { 0 }
<operator>.arrayInitializer { 0 }
<operator>.assignment i = 0
MLKQJ MLKQJ ( "%s" , GAEX )
<operator>.assignment i = 0
<operator>.assignment TWRAN = 0
<operator>.assignment GBCI = 0
<operator>.assignment UVQWGPCI [ i ] = GBCI
<operator>.assignment PYVGHDLIP [ i ] = TWRAN
<operator>.assignment i = 0
<operator>.assignment JFAC = 0
<operator>.assignment TWRAN = 0
<operator>.assignment RTM [ i ] = JFAC / TWRAN
<operator>.assignment i = 0
<operator>.assignment EVINB = TWRAN = 0
<operator>.assignment CQJU [ i ] = EVINB / TWRAN
<operator>.assignment i = 0
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment FCW [ i ] [ j ] = GAEX [ j ]
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.equals TWRAN == 0
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.addition 0.25 * wp [ i ] + 0.50 * RTM [ i ] + 0.25 * CQJU [ i ]
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment wp [ i ] = 0
<operator>.assignment j = 0
<operator>.division JFAC / TWRAN
<operator>.assignment TWRAN = 0
<operator>.assignment j = 0
<operator>.division EVINB / TWRAN
<operator>.addition 0.25 * wp [ i ] + 0.50 * RTM [ i ]
<operator>.multiplication 0.25 * CQJU [ i ]
<operator>.notEquals FCW [ i ] [ j ] != '.'
<operator>.assignment wp [ i ] = GBCI / TWRAN
<operator>.notEquals FCW [ i ] [ j ] != '.'
<operator>.notEquals FCW [ i ] [ j ] != '.'
<operator>.multiplication 0.25 * wp [ i ]
<operator>.multiplication 0.50 * RTM [ i ]
<operator>.postIncrement TWRAN ++
<operator>.postIncrement TWRAN ++
<operator>.postIncrement TWRAN ++
<operator>.assignmentPlus EVINB += RTM [ j ]
<operator>.equals FCW [ i ] [ j ] == '1'
<operator>.division GBCI / TWRAN
<operator>.equals FCW [ i ] [ j ] == '1'
<operator>.postIncrement GBCI ++
<operator>.assignmentPlus JFAC += ( UVQWGPCI [ j ] ) / ( PYVGHDLIP [ j ] - 1 )
<operator>.assignmentPlus JFAC += ( UVQWGPCI [ j ] - 1 ) / ( PYVGHDLIP [ j ] - 1 )
<operator>.division ( UVQWGPCI [ j ] ) / ( PYVGHDLIP [ j ] - 1 )
<operator>.subtraction PYVGHDLIP [ j ] - 1
<operator>.division ( UVQWGPCI [ j ] - 1 ) / ( PYVGHDLIP [ j ] - 1 )
<operator>.subtraction UVQWGPCI [ j ] - 1
<operator>.subtraction PYVGHDLIP [ j ] - 1
<operator>.addressOf & n
<operator>.indirectIndexAccess UVQWGPCI [ i ]
<operator>.indirectIndexAccess PYVGHDLIP [ i ]
<operator>.indirectIndexAccess RTM [ i ]
<operator>.indirectIndexAccess CQJU [ i ]
<operator>.indirectIndexAccess FCW [ i ] [ j ]
<operator>.indirectIndexAccess GAEX [ j ]
<operator>.indirectIndexAccess CQJU [ i ]
<operator>.indirectIndexAccess FCW [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess RTM [ i ]
<operator>.indirectIndexAccess FCW [ i ] [ j ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess FCW [ i ] [ j ]
<operator>.indirectIndexAccess FCW [ i ] [ j ]
<operator>.indirectIndexAccess FCW [ i ]
<operator>.indirectIndexAccess FCW [ i ]
<operator>.indirectIndexAccess FCW [ i ]
<operator>.indirectIndexAccess RTM [ j ]
<operator>.indirectIndexAccess FCW [ i ] [ j ]
<operator>.indirectIndexAccess FCW [ i ] [ j ]
<operator>.indirectIndexAccess FCW [ i ]
<operator>.indirectIndexAccess FCW [ i ]
<operator>.indirectIndexAccess UVQWGPCI [ j ]
<operator>.indirectIndexAccess PYVGHDLIP [ j ]
<operator>.indirectIndexAccess UVQWGPCI [ j ]
<operator>.indirectIndexAccess PYVGHDLIP [ j ]
>>>PDG&112 0->2 0->3 0->4 0->5 0->6 0->7 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->41 0->42 0->43 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->62 0->63 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->80 0->82 0->83 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->15 4->17 4->19 4->21 4->24 4->25 4->26 4->27 4->29 4->34 4->38 4->41 4->84 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->67 9->1 9->1 9->68 9->72 10->1 10->1 10->1 10->62 11->1 11->1 11->13 11->15 11->17 11->19 11->21 11->42 11->45 11->48 11->50 12->1 12->5 13->13 13->14 13->14 13->15 13->28 13->42 13->42 13->53 14->1 14->13 15->15 15->16 15->16 15->17 15->30 15->31 15->32 15->33 15->45 15->45 15->47 15->54 15->85 15->86 16->1 16->15 17->17 17->18 17->18 17->19 17->35 17->36 17->37 17->48 17->48 17->56 17->57 17->87 18->1 18->17 19->19 19->20 19->20 19->21 19->39 19->40 19->50 19->50 19->58 19->59 19->60 19->88 20->1 20->19 21->1 21->1 21->1 21->11 21->13 21->21 21->22 21->22 21->23 21->52 21->61 21->62 21->67 21->68 21->91 21->94 21->95 22->1 22->21 23->1 23->1 24->8 25->9 26->10 27->13 28->1 28->1 28->44 29->15 30->1 30->47 30->69 31->1 31->32 31->74 31->76 32->1 32->1 32->1 33->1 33->1 33->1 34->17 35->1 35->57 35->77 35->78 36->1 36->57 36->70 37->1 37->1 37->1 37->68 38->19 39->1 39->1 39->60 39->72 40->1 40->1 40->1 40->62 41->1 41->21 42->1 42->1 42->13 42->42 42->43 42->43 42->44 42->89 42->90 42->92 43->1 43->42 44->1 44->1 44->1 44->63 44->65 44->66 45->1 45->1 45->15 45->45 45->46 45->46 45->63 45->96 45->100 46->1 46->45 47->1 47->33 47->55 47->64 47->74 47->74 47->93 47->97 48->1 48->1 48->17 48->48 48->49 48->49 48->65 48->98 48->101 49->1 49->48 50->1 50->1 50->19 50->50 50->51 50->51 50->66 50->99 50->102 51->1 51->50 52->1 52->1 53->1 53->42 54->1 54->45 55->1 55->1 55->67 56->1 56->48 57->1 57->1 57->37 57->37 58->39 58->60 58->71 59->1 59->50 60->1 60->1 60->40 60->40 61->1 61->1 62->1 62->23 62->23 62->52 62->52 63->1 63->1 63->65 63->66 63->69 63->73 63->73 63->104 63->106 64->1 64->1 64->1 64->67 65->1 65->1 65->63 65->66 65->70 65->75 65->75 65->105 65->107 66->1 66->1 66->63 66->65 66->71 66->72 66->103 67->1 67->23 67->23 67->52 67->52 67->61 67->61 68->1 68->23 68->23 68->52 68->52 68->61 68->61 69->1 69->47 70->1 70->57 71->1 71->60 72->1 72->1 72->60 73->1 73->1 73->63 73->65 73->66 73->76 74->32 74->33 74->64 74->64 75->1 75->1 75->63 75->65 75->66 75->77 75->78 75->79 75->80 75->81 75->82 75->83 75->108 75->109 75->110 75->111 76->1 76->32 76->74 77->1 77->1 77->57 77->78 78->1 78->1 78->57 78->77 79->1 79->1 79->77 79->77 79->82 80->1 80->79 80->79 80->83 81->1 81->1 81->78 81->78 82->1 82->79 82->81 82->81 83->1 83->80 83->81 83->81
>>>Token int main ( ) { int ECSR , HFQRDJ , N , n , PYVGHDLIP [ AHV ] , i , j ; char FCW [ AHV ] [ AHV ] , GAEX [ AHV ] ; double GBCI , TWRAN , JFAC , EVINB , UVQWGPCI [ AHV ] ; MLKQJ ( " " , & ECSR ) ; for ( HFQRDJ = 1 ; HFQRDJ <= ECSR ; HFQRDJ ++ ) { double wp [ AHV ] = { 0 } , RTM [ AHV ] = { 0 } , CQJU [ AHV ] = { 0 } ; MLKQJ ( " " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { MLKQJ ( " " , GAEX ) ; for ( j = 0 ; j < n ; j ++ ) FCW [ i ] [ j ] = GAEX [ j ] ; } for ( i = 0 ; i < n ; i ++ ) { TWRAN = 0 ; GBCI = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( FCW [ i ] [ j ] != ' ' ) { TWRAN ++ ; if ( FCW [ i ] [ j ] == ' ' ) GBCI ++ ; } } if ( TWRAN == 0 ) wp [ i ] = 0 ; else wp [ i ] = GBCI / TWRAN ; UVQWGPCI [ i ] = GBCI ; PYVGHDLIP [ i ] = TWRAN ; } for ( i = 0 ; i < n ; i ++ ) { JFAC = 0 ; TWRAN = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( FCW [ i ] [ j ] != ' ' ) { TWRAN ++ ; if ( FCW [ i ] [ j ] == ' ' ) { JFAC += ( UVQWGPCI [ j ] ) / ( PYVGHDLIP [ j ] - 1 ) ; } else JFAC += ( UVQWGPCI [ j ] - 1 ) / ( PYVGHDLIP [ j ] - 1 ) ; } } RTM [ i ] = JFAC / TWRAN ; } for ( i = 0 ; i < n ; i ++ ) { EVINB = TWRAN = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( FCW [ i ] [ j ] != ' ' ) { TWRAN ++ ; EVINB += RTM [ j ] ; } } CQJU [ i ] = EVINB / TWRAN ; } printf ( " \n " , HFQRDJ ) ; for ( i = 0 ; i < n ; i ++ ) printf ( " \n " , 0.25 * wp [ i ] + 0.50 * RTM [ i ] + 0.25 * CQJU [ i ] ) ; } return 0 ; }
>>>Func
METHOD XRTBBUYCJSDFMXGEBBW
METHOD_RETURN int
PARAM MVODEK * GUVUH
RETURN return 0 ; return 0 ;
<operator>.lessThan i < GUVUH -> OWCJ
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
<operator>.assignment USY = GUVUH -> GUVUH [ i ]
<operator>.assignment j = i - 1
<operator>.assignment GUVUH -> GUVUH [ j + 1 ] = USY
<operator>.logicalAnd j >= 0 && GUVUH -> GUVUH [ j ] > USY
<operator>.subtraction i - 1
<operator>.assignment GUVUH -> GUVUH [ j + 1 ] = GUVUH -> GUVUH [ j ]
<operator>.postDecrement j --
<operator>.greaterEqualsThan j >= 0
<operator>.greaterThan GUVUH -> GUVUH [ j ] > USY
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.indirectFieldAccess GUVUH -> OWCJ
FIELD_IDENTIFIER OWCJ OWCJ
<operator>.indirectIndexAccess GUVUH -> GUVUH [ i ]
<operator>.indirectIndexAccess GUVUH -> GUVUH [ j + 1 ]
<operator>.indirectFieldAccess GUVUH -> GUVUH
<operator>.indirectFieldAccess GUVUH -> GUVUH
FIELD_IDENTIFIER GUVUH GUVUH
<operator>.indirectIndexAccess GUVUH -> GUVUH [ j ]
<operator>.indirectIndexAccess GUVUH -> GUVUH [ j + 1 ]
<operator>.indirectIndexAccess GUVUH -> GUVUH [ j ]
FIELD_IDENTIFIER GUVUH GUVUH
<operator>.indirectFieldAccess GUVUH -> GUVUH
<operator>.indirectFieldAccess GUVUH -> GUVUH
<operator>.indirectFieldAccess GUVUH -> GUVUH
FIELD_IDENTIFIER GUVUH GUVUH
FIELD_IDENTIFIER GUVUH GUVUH
FIELD_IDENTIFIER GUVUH GUVUH
>>>PDG&36 0->2 0->3 0->4 0->5 0->6 0->7 0->10 0->12 0->14 0->15 0->16 0->17 0->18 2->1 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->15 4->17 4->19 4->20 4->21 4->22 4->23 4->24 4->25 4->29 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->10 8->16 9->1 9->1 9->15 10->1 10->1 10->1 11->1 11->1 11->1 11->11 11->13 11->14 11->15 11->18 11->27 11->28 11->31 11->32 11->34 11->35 12->5 12->9 12->9 13->1 13->1 14->1 14->15 15->11 15->11 15->14 15->16 15->17 15->18 15->26 15->30 15->33 16->1 16->10 16->11 16->11 16->13 17->1
>>>Token int XRTBBUYCJSDFMXGEBBW ( MVODEK * GUVUH ) { int i , j , USY ; for ( i = 1 ; i < GUVUH -> OWCJ ; i ++ ) { USY = GUVUH -> GUVUH [ i ] ; j = i - 1 ; while ( j >= 0 && GUVUH -> GUVUH [ j ] > USY ) { GUVUH -> GUVUH [ j + 1 ] = GUVUH -> GUVUH [ j ] ; j -- ; } GUVUH -> GUVUH [ j + 1 ] = USY ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
AHHOG AHHOG ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
printf printf ( "Case #%d: " , i )
AHHOG AHHOG ( "%d%d%d" , & n , & d , & g )
printf printf ( "\n" )
<operator>.equals g == 0
<operator>.equals d == 0
printf printf ( "Possible" )
<operator>.equals d == 100
printf printf ( "Broken" )
printf printf ( "Possible" )
<operator>.equals g == 100
printf printf ( "Broken" )
<operator>.greaterEqualsThan n >= 100
printf printf ( "Possible" )
<operator>.assignment fd = 0
<operator>.lessEqualsThan u <= n
<operator>.postIncrement u ++
IDENTIFIER fd if (fd)
<operator>.assignment u = 1
printf printf ( "Possible" )
<operator>.equals u * d % 100 == 0
printf printf ( "Broken" )
<operator>.assignment fd = 1
<operator>.modulo u * d % 100
<operator>.multiplication u * d
<operator>.addressOf & n
<operator>.addressOf & d
<operator>.addressOf & g
>>>PDG&35 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->8 4->9 4->10 4->11 4->32 4->33 4->34 5->1 5->4 6->3 7->1 7->4 8->1 8->5 9->1 9->1 9->1 9->1 9->11 9->12 9->14 9->17 9->19 9->22 9->31 10->1 11->1 11->1 11->9 11->12 11->14 11->17 12->1 12->1 12->9 12->13 12->14 12->15 13->1 14->1 14->1 14->9 14->12 14->16 14->17 14->31 15->1 16->1 17->1 17->1 17->9 17->11 17->18 17->19 18->1 19->1 19->1 19->9 19->20 19->21 19->22 19->22 19->25 19->26 19->28 20->1 21->1 21->1 22->1 22->1 22->1 22->9 22->19 22->27 22->30 22->31 22->31 23->1 23->22 25->1 25->22 26->1 27->1 27->1 27->22 27->23 27->29 28->1 29->1 29->1 30->1 30->27 30->27 31->1 31->1 31->9 31->12 31->14 31->23 31->30 31->30
>>>Token int main ( ) { int t , n , d , g , i ; int fd , u ; AHHOG ( " " , & t ) ; for ( i = 1 ; i <= t ; i ++ ) { printf ( " " , i ) ; AHHOG ( " " , & n , & d , & g ) ; if ( g == 0 ) { if ( d == 0 ) { printf ( " " ) ; } else { printf ( " " ) ; } } else { if ( d == 100 ) { printf ( " " ) ; } else if ( g == 100 ) { printf ( " " ) ; } else { if ( n >= 100 ) { printf ( " " ) ; } else { fd = 0 ; for ( u = 1 ; u <= n ; u ++ ) { if ( u * d % 100 == 0 ) { fd = 1 ; break ; } } if ( fd ) { printf ( " " ) ; } else { printf ( " " ) ; } } } } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment PTWW = 0
<operator>.assignment YAYYK = 0
RCIYD RCIYD ( "%d" , & n )
printf printf ( "%d\n" , YAYYK )
RETURN return 0 ; return 0 ;
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
<operator>.assignment PTWW = n / NVB ( 5 , i )
<operator>.notEquals PTWW != 0
<operator>.division n / NVB ( 5 , i )
<operator>.assignment YAYYK = YAYYK + PTWW
NVB NVB ( 5 , i )
<operator>.addition YAYYK + PTWW
>>>PDG&16 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 2->1 2->1 3->1 3->5 3->13 3->15 4->1 4->1 4->12 5->1 5->1 6->1 7->1 7->1 7->10 7->11 7->12 7->14 7->14 8->6 9->1 9->7 10->1 10->1 10->11 11->1 11->1 11->7 11->13 11->13 11->15 11->15 12->1 12->1 12->10 12->10 13->1 13->1 13->5 13->15 14->1 14->7 14->12 14->12 15->1
>>>Token int main ( ) { int i , n , PTWW = 0 , YAYYK = 0 ; RCIYD ( " " , & n ) ; for ( i = 1 ; ; i ++ ) { PTWW = n / NVB ( 5 , i ) ; if ( PTWW != 0 ) { YAYYK = YAYYK + PTWW ; } else break ; } printf ( " \n " , YAYYK ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
AILVG AILVG ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessThan TJJKE < t
<operator>.postIncrement TJJKE ++
LITERAL 0 return 0 ;
<operator>.assignment TJJKE = 0
<operator>.assignment BTN = - 1
AILVG AILVG ( "%d" , & c )
AILVG AILVG ( "%d" , & d )
AILVG AILVG ( "%d" , & n )
AILVG AILVG ( "%c" , & sp )
<operator>.assignment EBL [ ++ BTN ] = XFO [ 0 ]
printf printf ( "\n" )
<operator>.notEquals c != 0
<operator>.notEquals d != 0
<operator>.lessThan i < n
<operator>.postIncrement i ++
AILVG AILVG ( "%c" , & XFO [ i ] )
<operator>.notEquals c != 0
<operator>.notEquals d != 0
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan BTN < 0
<operator>.minus - 1
AILVG AILVG ( "%c" , & sp )
AILVG AILVG ( "%c" , & sp )
<operator>.assignment i = 0
<operator>.assignment VBJR = TUY [ 0 ]
<operator>.assignment LSCR = TUY [ 1 ]
<operator>.assignment VYHP = CWU [ 0 ]
<operator>.assignment YJRA = CWU [ 1 ]
<operator>.assignment i = 1
<operator>.assignment EBL [ ++ BTN ] = XFO [ i ]
printf printf ( "Case #%d: []" , TJJKE + 1 )
<operator>.lessThan i < 3
<operator>.postIncrement i ++
AILVG AILVG ( "%c" , & TUY [ i ] )
<operator>.lessThan i < 2
<operator>.postIncrement i ++
AILVG AILVG ( "%c" , & CWU [ i ] )
<operator>.preIncrement ++ BTN
<operator>.greaterThan BTN > 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.addition TJJKE + 1
<operator>.equals BTN == 0
<operator>.preIncrement ++ BTN
<operator>.notEquals c != 0
<operator>.notEquals d != 0
printf printf ( "Case #%d: [%c]" , TJJKE + 1 , EBL [ 0 ] )
<operator>.assignment QAYC = - 1
<operator>.assignment BQQJ = - 1
<operator>.logicalOr ( EBL [ BTN ] == VBJR && EBL [ BTN - 1 ] == LSCR ) || ( EBL [ BTN ] == LSCR && EBL [ BTN - 1 ] == VBJR )
<operator>.lessEqualsThan j <= BTN
<operator>.postIncrement j ++
<operator>.logicalAnd QAYC >= 0 && BQQJ >= 0
<operator>.addition TJJKE + 1
<operator>.greaterThan BTN > 0
<operator>.assignment EBL [ -- BTN ] = TUY [ 2 ]
<operator>.minus - 1
<operator>.minus - 1
<operator>.assignment j = 0
printf printf ( "Case #%d: [%c" , TJJKE + 1 , EBL [ 0 ] )
printf printf ( "]" )
<operator>.logicalAnd EBL [ BTN ] == VBJR && EBL [ BTN - 1 ] == LSCR
<operator>.logicalAnd EBL [ BTN ] == LSCR && EBL [ BTN - 1 ] == VBJR
<operator>.logicalAnd EBL [ j ] == VYHP && QAYC == - 1
<operator>.greaterEqualsThan QAYC >= 0
<operator>.greaterEqualsThan BQQJ >= 0
<operator>.lessThan QAYC < BQQJ
<operator>.lessEqualsThan i <= BTN
<operator>.postIncrement i ++
printf printf ( ", %c" , EBL [ i ] )
<operator>.equals EBL [ BTN ] == VBJR
<operator>.equals EBL [ BTN - 1 ] == LSCR
<operator>.equals EBL [ BTN ] == LSCR
<operator>.equals EBL [ BTN - 1 ] == VBJR
<operator>.assignment QAYC = j
<operator>.assignment BTN = - 1
<operator>.addition TJJKE + 1
<operator>.assignment i = 1
<operator>.preDecrement -- BTN
<operator>.equals EBL [ j ] == VYHP
<operator>.equals QAYC == - 1
<operator>.subtraction BTN - 1
<operator>.subtraction BTN - 1
<operator>.minus - 1
<operator>.logicalAnd EBL [ j ] == YJRA && BQQJ == - 1
<operator>.minus - 1
<operator>.lessThan BQQJ < QAYC
<operator>.assignment BQQJ = j
<operator>.assignment BTN = - 1
<operator>.equals EBL [ j ] == YJRA
<operator>.equals BQQJ == - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.addressOf & sp
<operator>.indirectIndexAccess EBL [ ++ BTN ]
<operator>.indirectIndexAccess XFO [ 0 ]
<operator>.addressOf & XFO [ i ]
<operator>.addressOf & sp
<operator>.addressOf & sp
<operator>.indirectIndexAccess XFO [ i ]
<operator>.indirectIndexAccess TUY [ 0 ]
<operator>.indirectIndexAccess TUY [ 1 ]
<operator>.indirectIndexAccess CWU [ 0 ]
<operator>.indirectIndexAccess CWU [ 1 ]
<operator>.indirectIndexAccess EBL [ ++ BTN ]
<operator>.indirectIndexAccess XFO [ i ]
<operator>.addressOf & TUY [ i ]
<operator>.addressOf & CWU [ i ]
<operator>.indirectIndexAccess TUY [ i ]
<operator>.indirectIndexAccess CWU [ i ]
<operator>.indirectIndexAccess EBL [ 0 ]
<operator>.indirectIndexAccess EBL [ -- BTN ]
<operator>.indirectIndexAccess TUY [ 2 ]
<operator>.indirectIndexAccess EBL [ 0 ]
<operator>.indirectIndexAccess EBL [ BTN ]
<operator>.indirectIndexAccess EBL [ BTN - 1 ]
<operator>.indirectIndexAccess EBL [ BTN ]
<operator>.indirectIndexAccess EBL [ BTN - 1 ]
<operator>.indirectIndexAccess EBL [ i ]
<operator>.indirectIndexAccess EBL [ j ]
<operator>.indirectIndexAccess EBL [ j ]
>>>PDG&129 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->55 0->56 0->58 0->59 0->61 0->62 0->63 0->64 0->65 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->90 0->91 0->92 0->94 0->95 0->96 0->97 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->20 4->21 4->22 4->24 4->25 4->28 4->33 4->35 4->42 4->46 4->51 4->58 4->64 4->81 4->98 4->99 4->100 4->101 4->102 4->103 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->42 9->1 9->1 9->15 9->20 9->49 10->1 10->1 10->16 10->21 10->50 11->1 11->1 11->17 11->22 12->1 12->1 12->26 12->27 13->1 13->1 13->1 14->1 15->20 15->26 15->36 15->44 15->105 16->21 16->27 16->39 16->45 16->106 17->17 17->18 17->18 17->19 17->22 17->104 17->107 18->1 18->17 19->1 19->1 19->34 20->1 20->1 20->9 20->15 20->29 20->30 20->49 20->108 20->109 21->1 21->1 21->10 21->16 21->31 21->32 21->50 21->110 21->111 22->1 22->1 22->1 22->11 22->17 22->22 22->23 22->23 22->34 22->43 22->48 22->112 22->113 23->1 23->22 24->1 24->1 24->35 24->46 24->47 24->47 25->8 26->12 26->27 27->12 28->1 28->17 29->1 29->1 29->1 29->75 30->1 30->1 30->1 30->76 30->77 31->1 31->1 31->1 31->84 32->1 32->1 32->1 32->94 33->1 33->22 34->1 34->1 34->1 35->1 35->1 36->1 36->36 36->37 36->37 36->38 36->114 36->116 37->1 37->36 38->1 38->1 39->1 39->39 39->40 39->40 39->41 39->115 39->117 40->1 40->39 41->1 41->1 42->24 42->48 43->1 43->24 43->48 43->49 43->50 43->55 43->83 43->86 43->87 44->36 45->39 47->1 47->1 47->51 47->58 47->59 47->59 47->118 48->43 49->1 49->1 49->9 49->15 49->54 49->66 49->75 49->122 50->1 50->1 50->10 50->16 50->52 50->53 50->55 50->57 50->61 50->62 50->63 50->69 51->1 51->1 51->1 51->64 52->1 52->69 52->85 53->1 53->1 53->1 53->70 53->71 53->95 54->1 54->1 54->1 54->60 54->83 54->119 54->120 55->1 55->1 55->24 55->48 55->55 55->56 55->56 55->68 55->79 55->84 55->92 55->127 56->1 56->55 57->1 57->1 57->1 57->71 59->1 59->1 59->64 59->65 59->72 59->72 59->81 59->82 59->121 60->1 60->1 60->1 61->52 62->53 63->1 63->55 64->1 64->1 64->1 64->51 65->1 66->1 66->1 66->54 66->54 66->67 66->77 66->124 67->1 67->1 67->54 67->54 68->1 68->1 68->1 68->79 68->89 68->94 68->128 69->1 69->57 69->57 69->70 69->71 70->1 70->57 70->57 70->71 71->1 71->1 71->1 71->80 71->90 71->91 71->91 71->91 72->1 72->1 72->1 72->72 72->73 72->73 72->74 72->126 73->1 73->72 74->1 74->1 75->1 75->1 75->66 75->66 75->76 75->77 75->78 75->86 75->123 76->1 76->1 76->66 76->66 76->77 76->78 77->1 77->1 77->67 77->67 77->75 77->76 77->78 77->87 77->125 78->1 78->1 78->67 78->67 78->75 78->76 79->1 79->69 79->85 80->1 80->1 80->24 80->48 82->1 82->72 83->24 83->48 83->55 84->1 84->1 84->68 84->68 84->85 84->88 84->94 85->1 85->68 85->68 85->69 86->24 86->48 86->55 86->83 86->87 87->24 87->48 87->55 87->83 88->85 89->1 89->1 89->1 89->92 90->80 91->1 91->1 91->1 91->93 91->97 92->1 92->1 92->70 92->71 92->95 93->1 93->1 93->24 93->48 94->1 94->1 94->84 94->89 94->89 94->95 94->96 95->1 95->1 95->70 95->71 95->89 95->89 96->95 97->93
>>>Token int main ( ) { int TJJKE , t , i , c , d , n , BTN , QAYC , BQQJ , j ; char TUY [ 3 ] , CWU [ 2 ] , XFO [ 10 ] , sp , EBL [ 10 ] ; char VBJR , LSCR , VYHP , YJRA ; AILVG ( " " , & t ) ; for ( TJJKE = 0 ; TJJKE < t ; TJJKE ++ ) { BTN = - 1 ; AILVG ( " " , & c ) ; if ( c != 0 ) { AILVG ( " " , & sp ) ; for ( i = 0 ; i < 3 ; i ++ ) AILVG ( " " , & TUY [ i ] ) ; } AILVG ( " " , & d ) ; if ( d != 0 ) { AILVG ( " " , & sp ) ; for ( i = 0 ; i < 2 ; i ++ ) AILVG ( " " , & CWU [ i ] ) ; } AILVG ( " " , & n ) ; AILVG ( " " , & sp ) ; for ( i = 0 ; i < n ; i ++ ) AILVG ( " " , & XFO [ i ] ) ; EBL [ ++ BTN ] = XFO [ 0 ] ; if ( c != 0 ) { VBJR = TUY [ 0 ] ; LSCR = TUY [ 1 ] ; } if ( d != 0 ) { VYHP = CWU [ 0 ] ; YJRA = CWU [ 1 ] ; } for ( i = 1 ; i < n ; i ++ ) { EBL [ ++ BTN ] = XFO [ i ] ; if ( BTN > 0 ) { if ( c != 0 ) { if ( ( EBL [ BTN ] == VBJR && EBL [ BTN - 1 ] == LSCR ) || ( EBL [ BTN ] == LSCR && EBL [ BTN - 1 ] == VBJR ) ) { EBL [ -- BTN ] = TUY [ 2 ] ; } } if ( d != 0 ) { QAYC = - 1 ; BQQJ = - 1 ; for ( j = 0 ; j <= BTN ; j ++ ) { if ( EBL [ j ] == VYHP && QAYC == - 1 ) QAYC = j ; else if ( EBL [ j ] == YJRA && BQQJ == - 1 ) BQQJ = j ; } if ( QAYC >= 0 && BQQJ >= 0 ) { if ( QAYC < BQQJ ) BTN = - 1 ; else if ( BQQJ < QAYC ) BTN = - 1 ; } } } } if ( BTN < 0 ) printf ( " " , TJJKE + 1 ) ; else if ( BTN == 0 ) printf ( " " , TJJKE + 1 , EBL [ 0 ] ) ; else if ( BTN > 0 ) { printf ( " " , TJJKE + 1 , EBL [ 0 ] ) ; for ( i = 1 ; i <= BTN ; i ++ ) printf ( " " , EBL [ i ] ) ; printf ( " " ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD SOISVKJU
METHOD_RETURN void
NCPLO NCPLO ( "%d\n" , & n )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
NCPLO NCPLO ( "\n" )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment j = 0
NCPLO NCPLO ( "%c" , & c )
<operator>.equals c == '.'
<operator>.assignment a [ i ] [ j ] = - 1
<operator>.assignment a [ i ] [ j ] = c - '0'
<operator>.minus - 1
<operator>.subtraction c - '0'
<operator>.addressOf & c
<operator>.indirectIndexAccess a [ i ] [ j ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess a [ i ] [ j ]
<operator>.indirectIndexAccess a [ i ]
>>>PDG&21 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->14 0->15 2->1 2->1 2->3 2->7 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->7 3->7 3->9 4->1 4->3 5->1 5->3 6->1 7->1 7->1 7->3 7->7 7->8 7->8 7->10 7->11 7->16 8->1 8->7 9->1 9->7 10->1 10->1 10->11 10->15 11->1 11->1 11->10 11->12 11->13 11->14 11->15 11->15 11->17 11->18 11->19 11->20 12->1 12->1 12->1 13->1 13->1 13->1 14->12 15->1 15->10 15->11 15->13 15->13
>>>Token void SOISVKJU ( ) { char c ; NCPLO ( " \n " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { NCPLO ( " " , & c ) ; if ( c == ' ' ) { a [ i ] [ j ] = - 1 ; } else { a [ i ] [ j ] = c - ' ' ; } } NCPLO ( " \n " ) ; } }
>>>Func
METHOD IVSUYVTPFMC
METHOD_RETURN struct AEHHR
PARAM int NVDKFGWD
<operator>.assignment * ROKWD = malloc ( sizeof ( struct AEHHR ) )
<operator>.assignment ROKWD -> LSDRCMJMKEH = NVDKFGWD
<operator>.assignment ROKWD -> JAEYIQCV = malloc ( NVDKFGWD * sizeof ( struct MFGS * ) )
<operator>.assignment ROKWD -> NGXGWJF = malloc ( NVDKFGWD * sizeof ( int ) )
RETURN return ROKWD ; return ROKWD ;
<operator>.lessThan i < NVDKFGWD
<operator>.postIncrement i ++
IDENTIFIER ROKWD return ROKWD ;
malloc malloc ( NVDKFGWD * sizeof ( struct MFGS * ) )
malloc malloc ( NVDKFGWD * sizeof ( int ) )
<operator>.assignment i = 0
<operator>.assignment ROKWD -> JAEYIQCV [ i ] = NULL
<operator>.assignment ROKWD -> NGXGWJF [ i ] = 0
<operator>.sizeOf sizeof ( struct AEHHR )
<operator>.multiplication NVDKFGWD * sizeof ( struct MFGS * )
<operator>.multiplication NVDKFGWD * sizeof ( int )
<operator>.sizeOf sizeof ( struct MFGS * )
<operator>.sizeOf sizeof ( int )
<operator>.indirectIndexAccess ROKWD -> JAEYIQCV [ i ]
<operator>.indirectIndexAccess ROKWD -> NGXGWJF [ i ]
<operator>.indirectFieldAccess ROKWD -> JAEYIQCV
<operator>.indirectFieldAccess ROKWD -> NGXGWJF
FIELD_IDENTIFIER JAEYIQCV JAEYIQCV
FIELD_IDENTIFIER NGXGWJF NGXGWJF
>>>PDG&27 0->2 0->4 0->8 0->9 0->10 0->13 0->14 0->15 0->17 0->18 2->4 2->17 3->1 3->1 3->1 3->10 4->1 4->1 5->1 5->1 5->1 6->1 6->1 6->1 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->14 8->15 8->21 8->22 8->23 8->24 8->25 8->26 9->1 9->8 10->7 11->1 11->5 12->1 12->6 13->1 13->8 14->1 14->1 14->1 15->1 15->1 16->1 17->11 17->18 18->8 18->12 19->1 20->1
>>>Token struct AEHHR * IVSUYVTPFMC ( int NVDKFGWD ) { struct AEHHR * ROKWD = malloc ( sizeof ( struct AEHHR ) ) ; ROKWD -> LSDRCMJMKEH = NVDKFGWD ; ROKWD -> JAEYIQCV = malloc ( NVDKFGWD * sizeof ( struct MFGS * ) ) ; ROKWD -> NGXGWJF = malloc ( NVDKFGWD * sizeof ( int ) ) ; int i ; for ( i = 0 ; i < NVDKFGWD ; i ++ ) { ROKWD -> JAEYIQCV [ i ] = NULL ; ROKWD -> NGXGWJF [ i ] = 0 ; } return ROKWD ; }
>>>Func
METHOD MTEDTNYQWAXWRNDX
METHOD_RETURN struct TKKEMTIY
PARAM int * QTUO
PARAM int DBVWNGCB
<operator>.equals DBVWNGCB == 0
RETURN return NULL ; return NULL ;
IDENTIFIER NULL return NULL ;
RETURN return CMCPGJUCWV ( QTUO , 0 , DBVWNGCB - 1 ) ; return CMCPGJUCWV ( QTUO , 0 , DBVWNGCB - 1 ) ;
CMCPGJUCWV CMCPGJUCWV ( QTUO , 0 , DBVWNGCB - 1 )
<operator>.subtraction DBVWNGCB - 1
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->8 0->9 2->1 2->8 3->4 4->1 4->1 4->5 4->7 4->8 4->9 4->9 5->1 6->5 7->1 8->7 9->8 9->8
>>>Token struct TKKEMTIY * MTEDTNYQWAXWRNDX ( int * QTUO , int DBVWNGCB ) { if ( DBVWNGCB == 0 ) return NULL ; else return CMCPGJUCWV ( QTUO , 0 , DBVWNGCB - 1 ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment BMC = QNTYR ( "B.txt" , "r" )
<operator>.assignment FPKD = QNTYR ( "output" , "w" )
<operator>.assignment nt = 0
JIIWGO JIIWGO ( BMC , "%d" , & nt )
fprintf fprintf ( FPKD , "\n" )
UUXKXK UUXKXK ( BMC )
UUXKXK UUXKXK ( FPKD )
RETURN return 0 ; return 0 ;
<operator>.equals BMC == NULL
<operator>.equals FPKD == NULL
<operator>.lessThan it < nt
<operator>.postIncrement it ++
LITERAL 0 return 0 ;
QNTYR QNTYR ( "B.txt" , "r" )
printf printf ( "\nERROR - opening input file\n" )
QNTYR QNTYR ( "output" , "w" )
printf printf ( "\nERROR - opening output file\n" )
<operator>.assignment it = 0
printf printf ( "Case #%d: " , it + 1 )
fprintf fprintf ( FPKD , "Case #%d: " , it + 1 )
CLGR CLGR ( )
FISKJ FISKJ ( )
printf printf ( "\n" )
fprintf fprintf ( FPKD , "\n" )
<operator>.addition it + 1
<operator>.addition it + 1
>>>PDG&28 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->1 2->1 2->10 3->1 3->1 3->11 4->1 4->5 4->12 5->1 5->1 5->7 5->12 6->1 6->8 7->1 7->1 8->1 8->1 9->1 10->1 10->5 10->11 10->16 11->1 11->1 11->6 11->18 11->21 12->1 12->1 12->1 12->12 12->13 12->13 12->20 12->20 12->21 12->21 12->22 12->23 12->24 12->25 12->26 12->26 12->27 12->27 13->1 13->12 14->9 15->2 15->2 16->1 17->3 17->3 18->1 19->1 19->12 20->1 21->1 21->1 21->25 22->1 23->1 24->1 25->6 25->21
>>>Token int main ( ) { BMC = QNTYR ( " " , " " ) ; if ( BMC == NULL ) printf ( " \n \n " ) ; FPKD = QNTYR ( " " , " " ) ; if ( FPKD == NULL ) printf ( " \n \n " ) ; int nt , it ; nt = 0 ; JIIWGO ( BMC , " " , & nt ) ; for ( it = 0 ; it < nt ; it ++ ) { printf ( " " , it + 1 ) ; fprintf ( FPKD , " " , it + 1 ) ; CLGR ( ) ; FISKJ ( ) ; printf ( " \n " ) ; fprintf ( FPKD , " \n " ) ; } fprintf ( FPKD , " \n " ) ; UUXKXK ( BMC ) ; UUXKXK ( FPKD ) ; return 0 ; }
>>>Func
METHOD DVCUMUXDULXT
METHOD_RETURN void
PARAM FKWEQHM * IMKK
DVCUMUXDULXT DVCUMUXDULXT ( IMKK -> HONX )
printf printf ( "  %d  "   ( IMKK -> OBA ) )
DVCUMUXDULXT DVCUMUXDULXT ( IMKK -> AEVDB )
<operator>.equals IMKK == NULL
RETURN return ; return ;
<operator>.indirectFieldAccess IMKK -> HONX
<operator>.indirectFieldAccess IMKK -> OBA
<operator>.indirectFieldAccess IMKK -> AEVDB
FIELD_IDENTIFIER HONX HONX
FIELD_IDENTIFIER OBA OBA
FIELD_IDENTIFIER AEVDB AEVDB
>>>PDG&14 0->2 0->4 0->6 0->7 2->6 6->1 6->1 6->1 6->3 6->4 6->5 6->7 6->8 6->9 6->10 6->11 6->12 6->13 7->1
>>>Token void DVCUMUXDULXT ( FKWEQHM * IMKK ) { if ( IMKK == NULL ) return ; DVCUMUXDULXT ( IMKK -> HONX ) ; printf ( " " , ( IMKK -> OBA ) ) ; DVCUMUXDULXT ( IMKK -> AEVDB ) ; }
>>>Func
METHOD BSHTFL
METHOD_RETURN int
PARAM char ILHTGYNWSTAS [ ]
PARAM int BMACAQKSJ
PARAM char WFIIIBR [ ] [ 3 ]
PARAM char D
<operator>.assignment i = 0
<operator>.assignment j = 0
RETURN return 0 ; return 0 ;
<operator>.lessThan i < D
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.lessThan BMACAQKSJ < 2
<operator>.equals ILHTGYNWSTAS [ BMACAQKSJ - 1 ] == WFIIIBR [ i ] [ 0 ]
<operator>.equals ILHTGYNWSTAS [ BMACAQKSJ - 1 ] == WFIIIBR [ i ] [ 1 ]
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.lessThan j < BMACAQKSJ - 1
<operator>.postIncrement j ++
<operator>.lessThan j < BMACAQKSJ - 1
<operator>.postIncrement j ++
<operator>.subtraction BMACAQKSJ - 1
<operator>.assignment j = 0
<operator>.subtraction BMACAQKSJ - 1
<operator>.assignment j = 0
<operator>.subtraction BMACAQKSJ - 1
<operator>.equals ILHTGYNWSTAS [ j ] == WFIIIBR [ i ] [ 1 ]
<operator>.subtraction BMACAQKSJ - 1
<operator>.equals ILHTGYNWSTAS [ j ] == WFIIIBR [ i ] [ 0 ]
memset memset ( ILHTGYNWSTAS , 0 , BMACAQKSJ )
RETURN return 1 ; return 1 ;
memset memset ( ILHTGYNWSTAS , 0 , BMACAQKSJ )
RETURN return 1 ; return 1 ;
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
<operator>.indirectIndexAccess ILHTGYNWSTAS [ BMACAQKSJ - 1 ]
<operator>.indirectIndexAccess WFIIIBR [ i ] [ 0 ]
<operator>.indirectIndexAccess ILHTGYNWSTAS [ BMACAQKSJ - 1 ]
<operator>.indirectIndexAccess WFIIIBR [ i ] [ 1 ]
<operator>.indirectIndexAccess WFIIIBR [ i ]
<operator>.indirectIndexAccess WFIIIBR [ i ]
<operator>.indirectIndexAccess ILHTGYNWSTAS [ j ]
<operator>.indirectIndexAccess WFIIIBR [ i ] [ 1 ]
<operator>.indirectIndexAccess ILHTGYNWSTAS [ j ]
<operator>.indirectIndexAccess WFIIIBR [ i ] [ 0 ]
<operator>.indirectIndexAccess WFIIIBR [ i ]
<operator>.indirectIndexAccess WFIIIBR [ i ]
>>>PDG&48 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->30 0->31 0->32 0->33 0->34 0->35 2->1 2->14 2->15 2->27 2->29 2->30 2->32 3->13 4->1 5->9 7->1 7->1 8->1 9->1 9->1 9->1 9->8 9->10 9->13 10->1 10->9 11->8 12->1 12->9 13->1 13->1 13->14 13->16 13->22 13->22 13->36 13->37 13->40 14->1 14->1 14->15 14->15 14->18 14->23 14->24 14->26 14->29 14->30 14->38 14->39 14->41 15->1 15->1 15->1 15->9 15->10 15->14 15->20 15->25 15->27 15->28 15->32 16->1 17->16 18->1 18->1 18->15 18->19 18->24 18->27 18->38 18->39 18->41 18->42 18->43 18->46 19->1 19->18 20->1 20->1 20->1 20->9 20->10 20->21 20->29 20->44 20->45 20->47 21->1 21->20 22->24 22->26 23->1 23->18 24->13 24->28 25->1 25->20 26->18 26->18 26->24 26->30 27->1 27->1 27->15 27->18 27->19 27->26 27->29 27->30 27->30 27->31 28->13 28->20 28->20 28->32 29->1 29->1 29->1 29->14 29->20 29->21 29->27 29->28 29->32 29->32 29->33 31->1 33->1 34->31 35->33
>>>Token int BSHTFL ( char ILHTGYNWSTAS [ ] , int BMACAQKSJ , char WFIIIBR [ ] [ 3 ] , char D ) { int i = 0 ; int j = 0 ; for ( i = 0 ; i < D ; i ++ ) { if ( BMACAQKSJ < 2 ) return 0 ; if ( ILHTGYNWSTAS [ BMACAQKSJ - 1 ] == WFIIIBR [ i ] [ 0 ] ) { for ( j = 0 ; j < BMACAQKSJ - 1 ; j ++ ) { if ( ILHTGYNWSTAS [ j ] == WFIIIBR [ i ] [ 1 ] ) { memset ( ILHTGYNWSTAS , 0 , BMACAQKSJ ) ; return 1 ; } } } if ( ILHTGYNWSTAS [ BMACAQKSJ - 1 ] == WFIIIBR [ i ] [ 1 ] ) { for ( j = 0 ; j < BMACAQKSJ - 1 ; j ++ ) { if ( ILHTGYNWSTAS [ j ] == WFIIIBR [ i ] [ 0 ] ) { memset ( ILHTGYNWSTAS , 0 , BMACAQKSJ ) ; return 1 ; } } } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment CDOQBEO = 1
ULLJS ULLJS ( "%d" , & MACAY )
RETURN return 0 ; return 0 ;
<operator>.postDecrement MACAY --
LITERAL 0 return 0 ;
ULLJS ULLJS ( "%d" , & n )
<operator>.assignment wp = ( double * ) malloc ( sizeof ( double ) * n )
<operator>.assignment FKF = ( double * ) malloc ( sizeof ( double ) * n )
<operator>.assignment JXMT = ( double * ) malloc ( sizeof ( double ) * n )
<operator>.assignment WCB = ( double * ) malloc ( sizeof ( double ) * n )
<operator>.assignment np = ( int * ) malloc ( sizeof ( int ) * n )
<operator>.assignment ESAC = ( char * * ) malloc ( sizeof ( char * ) * n )
printf printf ( "Case #%d:\n" , CDOQBEO ++ )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.cast ( double * ) malloc ( sizeof ( double ) * n )
<operator>.cast ( double * ) malloc ( sizeof ( double ) * n )
<operator>.cast ( double * ) malloc ( sizeof ( double ) * n )
<operator>.cast ( double * ) malloc ( sizeof ( double ) * n )
<operator>.cast ( int * ) malloc ( sizeof ( int ) * n )
<operator>.cast ( char * * ) malloc ( sizeof ( char * ) * n )
<operator>.assignment i = 0
<operator>.assignment ESAC [ i ] = ( char * ) malloc ( sizeof ( char ) * n )
ULLJS ULLJS ( "%c" , & c )
<operator>.assignment i = 0
<operator>.assignment np [ i ] = HDGHC ( ESAC [ i ] , n )
<operator>.assignment wp [ i ] = IMSAN ( ESAC [ i ] , n ) * 1.0 / np [ i ]
<operator>.assignment i = 0
<operator>.assignment YOI = 0
<operator>.assignment KAT = ( double * ) malloc ( sizeof ( double ) * ( n - 1 ) )
<operator>.assignment FKF [ i ] = YOI / ( np [ i ] )
<operator>.assignment i = 0
<operator>.assignment ANEE = 0
<operator>.assignment JXMT [ i ] = ANEE / np [ i ]
<operator>.postIncrement CDOQBEO ++
<operator>.assignment i = 0
<operator>.assignment WCB [ i ] = 0.25 * wp [ i ] + 0.5 * FKF [ i ] + 0.25 * JXMT [ i ]
printf printf ( "%.12g\n" , WCB [ i ] )
malloc malloc ( sizeof ( double ) * n )
malloc malloc ( sizeof ( double ) * n )
malloc malloc ( sizeof ( double ) * n )
malloc malloc ( sizeof ( double ) * n )
malloc malloc ( sizeof ( int ) * n )
malloc malloc ( sizeof ( char * ) * n )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.multiplication sizeof ( double ) * n
<operator>.multiplication sizeof ( double ) * n
<operator>.multiplication sizeof ( double ) * n
<operator>.multiplication sizeof ( double ) * n
<operator>.multiplication sizeof ( int ) * n
<operator>.multiplication sizeof ( char * ) * n
<operator>.cast ( char * ) malloc ( sizeof ( char ) * n )
<operator>.assignment j = 0
ULLJS ULLJS ( "%c" , & ESAC [ i ] [ j ] )
HDGHC HDGHC ( ESAC [ i ] , n )
<operator>.division IMSAN ( ESAC [ i ] , n ) * 1.0 / np [ i ]
<operator>.cast ( double * ) malloc ( sizeof ( double ) * ( n - 1 ) )
<operator>.assignment j = 0
<operator>.assignment KAT [ j ] = FHGMSF ( ESAC [ j ] , n , i ) * 1.0 / ( np [ j ] - 1 )
<operator>.assignment j = 0
<operator>.division YOI / ( np [ i ] )
<operator>.assignment j = 0
<operator>.division ANEE / np [ i ]
<operator>.addition 0.25 * wp [ i ] + 0.5 * FKF [ i ] + 0.25 * JXMT [ i ]
<operator>.sizeOf sizeof ( double )
<operator>.sizeOf sizeof ( int )
<operator>.sizeOf sizeof ( char * )
malloc malloc ( sizeof ( char ) * n )
<operator>.multiplication IMSAN ( ESAC [ i ] , n ) * 1.0
malloc malloc ( sizeof ( double ) * ( n - 1 ) )
<operator>.notEquals ESAC [ i ] [ j ] != '.'
<operator>.notEquals ESAC [ i ] [ j ] != '.'
<operator>.addition 0.25 * wp [ i ] + 0.5 * FKF [ i ]
<operator>.multiplication 0.25 * JXMT [ i ]
<operator>.multiplication sizeof ( char ) * n
IMSAN IMSAN ( ESAC [ i ] , n )
<operator>.multiplication sizeof ( double ) * ( n - 1 )
<operator>.division FHGMSF ( ESAC [ j ] , n , i ) * 1.0 / ( np [ j ] - 1 )
<operator>.assignmentPlus YOI += KAT [ j ]
<operator>.assignmentPlus ANEE += FKF [ j ]
<operator>.multiplication 0.25 * wp [ i ]
<operator>.multiplication 0.5 * FKF [ i ]
<operator>.sizeOf sizeof ( char )
<operator>.sizeOf sizeof ( double )
<operator>.subtraction n - 1
<operator>.multiplication FHGMSF ( ESAC [ j ] , n , i ) * 1.0
<operator>.subtraction np [ j ] - 1
FHGMSF FHGMSF ( ESAC [ j ] , n , i )
<operator>.addressOf & n
UNKNOWN double * double *
UNKNOWN double * double *
UNKNOWN double * double *
UNKNOWN double * double *
UNKNOWN int * int *
UNKNOWN char * * char * *
<operator>.indirectIndexAccess ESAC [ i ]
<operator>.addressOf & c
<operator>.indirectIndexAccess np [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess FKF [ i ]
<operator>.indirectIndexAccess JXMT [ i ]
<operator>.indirectIndexAccess WCB [ i ]
<operator>.indirectIndexAccess WCB [ i ]
<operator>.sizeOf sizeof ( double )
<operator>.sizeOf sizeof ( double )
<operator>.sizeOf sizeof ( double )
UNKNOWN char * char *
<operator>.indirectIndexAccess ESAC [ i ]
<operator>.indirectIndexAccess np [ i ]
UNKNOWN double * double *
<operator>.indirectIndexAccess np [ i ]
<operator>.indirectIndexAccess np [ i ]
<operator>.addressOf & ESAC [ i ] [ j ]
<operator>.indirectIndexAccess KAT [ j ]
<operator>.indirectIndexAccess JXMT [ i ]
<operator>.indirectIndexAccess ESAC [ i ] [ j ]
<operator>.indirectIndexAccess ESAC [ i ]
<operator>.indirectIndexAccess ESAC [ i ] [ j ]
<operator>.indirectIndexAccess ESAC [ i ] [ j ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess FKF [ i ]
<operator>.indirectIndexAccess ESAC [ i ]
<operator>.indirectIndexAccess np [ j ]
<operator>.indirectIndexAccess ESAC [ i ]
<operator>.indirectIndexAccess KAT [ j ]
<operator>.indirectIndexAccess ESAC [ i ]
<operator>.indirectIndexAccess FKF [ j ]
<operator>.indirectIndexAccess ESAC [ j ]
>>>PDG&145 0->2 0->3 0->4 0->5 0->6 0->7 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->31 0->33 0->34 0->37 0->38 0->41 0->42 0->44 0->45 0->47 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->69 0->70 0->71 0->74 0->76 0->77 0->78 0->79 0->85 0->87 0->88 0->90 0->91 0->92 0->95 0->96 0->97 0->98 0->101 0->102 0->103 0->104 2->1 2->1 2->44 3->1 3->1 3->5 4->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->17 5->19 5->21 5->23 5->25 5->26 5->27 5->28 5->29 5->30 5->31 5->34 5->37 5->41 5->44 5->45 5->48 5->49 5->50 5->51 5->52 5->53 5->62 5->63 5->64 5->65 5->66 5->67 5->81 5->82 5->83 5->105 5->106 5->107 5->108 5->109 5->110 5->111 5->120 5->121 5->122 6->4 7->1 7->1 7->15 7->17 7->19 7->21 7->23 7->54 7->56 7->58 7->60 7->62 7->63 7->64 7->65 7->66 7->67 7->71 7->91 7->92 7->101 7->104 8->1 8->1 8->97 9->1 9->1 9->96 9->98 10->1 10->1 10->90 11->1 11->1 11->1 11->47 12->1 12->1 12->1 12->72 12->77 12->79 12->103 13->1 13->1 13->1 13->71 13->92 13->104 14->1 14->1 15->15 15->16 15->16 15->17 15->32 15->33 15->54 15->68 15->69 15->84 15->91 15->91 15->99 15->112 15->113 15->123 16->1 16->15 17->17 17->18 17->18 17->19 17->35 17->36 17->71 17->71 17->72 17->85 17->92 17->114 17->115 17->124 17->125 17->133 18->1 18->17 19->19 19->20 19->20 19->21 19->38 19->39 19->40 19->56 19->58 19->73 19->74 19->76 19->77 19->86 19->93 19->100 19->101 19->101 19->104 19->116 19->126 19->127 20->1 20->19 21->21 21->22 21->22 21->23 21->42 21->43 21->60 21->60 21->78 21->79 21->117 21->128 22->1 22->21 23->1 23->1 23->1 23->7 23->23 23->24 23->24 23->46 23->47 23->62 23->80 23->89 23->90 23->97 23->98 23->118 23->119 23->131 23->136 23->137 24->1 24->23 28->1 29->1 30->1 31->15 32->1 32->1 32->1 32->71 33->1 33->1 34->17 35->1 35->1 35->72 36->1 36->1 36->1 36->97 37->19 38->1 38->77 38->95 39->1 39->1 39->1 39->95 40->1 40->1 40->1 40->98 41->21 42->1 42->79 42->96 43->1 43->1 43->1 43->90 44->1 44->14 45->1 45->23 46->1 46->1 46->47 47->1 47->1 48->8 48->25 49->9 49->26 50->10 50->27 51->1 51->11 51->28 52->1 52->12 52->29 53->1 53->13 53->30 54->1 54->1 54->15 54->54 54->55 54->55 54->70 54->129 54->132 54->138 55->1 55->54 56->56 56->57 56->57 56->58 56->75 56->94 56->102 56->103 56->104 56->104 56->130 56->139 56->144 57->1 57->56 58->1 58->1 58->19 58->58 58->59 58->59 58->87 58->134 58->140 59->1 59->58 60->1 60->1 60->21 60->60 60->61 60->61 60->88 60->135 60->142 61->1 61->60 62->48 62->63 63->49 63->64 64->50 64->65 65->51 65->66 66->52 66->67 67->15 67->53 68->1 69->1 69->54 70->1 70->1 70->71 70->87 70->88 70->92 71->35 71->35 71->92 71->92 72->1 72->1 72->36 72->36 72->77 72->79 73->1 74->56 75->1 75->1 75->1 75->95 76->1 76->58 77->1 77->1 77->40 77->40 77->79 78->1 78->60 79->1 79->1 79->43 79->43 79->77 80->1 80->1 81->1 82->1 83->1 84->1 84->32 84->68 85->1 85->72 85->72 86->1 86->39 86->73 87->1 87->1 87->70 87->71 87->88 87->92 87->95 87->141 88->1 88->1 88->70 88->71 88->87 88->92 88->96 88->143 89->1 89->1 90->1 90->46 90->46 90->80 90->80 91->54 91->84 92->1 92->17 92->71 92->85 92->85 93->1 93->86 94->1 94->1 94->75 94->75 95->1 95->1 95->77 96->1 96->1 96->79 97->1 97->46 97->46 97->80 97->80 97->89 97->89 98->1 98->46 98->46 98->80 98->80 98->89 98->89 99->1 100->1 101->56 101->93 101->93 102->1 102->94 102->94 103->1 103->94 103->94 104->1 104->20 104->56 104->102 104->102 104->102
>>>Token int main ( ) { int MACAY , CDOQBEO = 1 ; ULLJS ( " " , & MACAY ) ; while ( MACAY -- ) { int n ; ULLJS ( " " , & n ) ; double * wp ; double * FKF ; double * JXMT ; double * WCB ; int * np ; wp = ( double * ) malloc ( sizeof ( double ) * n ) ; FKF = ( double * ) malloc ( sizeof ( double ) * n ) ; JXMT = ( double * ) malloc ( sizeof ( double ) * n ) ; WCB = ( double * ) malloc ( sizeof ( double ) * n ) ; np = ( int * ) malloc ( sizeof ( int ) * n ) ; char * * ESAC ; ESAC = ( char * * ) malloc ( sizeof ( char * ) * n ) ; int i , j ; char c ; for ( i = 0 ; i < n ; i ++ ) { ESAC [ i ] = ( char * ) malloc ( sizeof ( char ) * n ) ; ULLJS ( " " , & c ) ; for ( j = 0 ; j < n ; j ++ ) { ULLJS ( " " , & ESAC [ i ] [ j ] ) ; } } for ( i = 0 ; i < n ; i ++ ) { np [ i ] = HDGHC ( ESAC [ i ] , n ) ; wp [ i ] = IMSAN ( ESAC [ i ] , n ) * 1.0 / np [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { double YOI = 0 ; double * KAT ; KAT = ( double * ) malloc ( sizeof ( double ) * ( n - 1 ) ) ; for ( j = 0 ; j < n ; j ++ ) { KAT [ j ] = FHGMSF ( ESAC [ j ] , n , i ) * 1.0 / ( np [ j ] - 1 ) ; } for ( j = 0 ; j < n ; j ++ ) { if ( ESAC [ i ] [ j ] != ' ' ) { YOI += KAT [ j ] ; } } FKF [ i ] = YOI / ( np [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { double ANEE = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ESAC [ i ] [ j ] != ' ' ) { ANEE += FKF [ j ] ; } } JXMT [ i ] = ANEE / np [ i ] ; } printf ( " \n " , CDOQBEO ++ ) ; for ( i = 0 ; i < n ; i ++ ) { WCB [ i ] = 0.25 * wp [ i ] + 0.5 * FKF [ i ] + 0.25 * JXMT [ i ] ; printf ( " \n " , WCB [ i ] ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
<operator>.assignment DRVAC = 0
<operator>.assignment LSNRS = 0
<operator>.assignment * fp = EFNSA ( "B-small-attempt0.in" , "r" )
<operator>.assignment * EMU = EFNSA ( "output3.txt" , "w" )
XMWWNP XMWWNP ( fp , "%d" , & t )
IWGVJF IWGVJF ( EMU )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
EFNSA EFNSA ( "B-small-attempt0.in" , "r" )
EFNSA EFNSA ( "output3.txt" , "w" )
<operator>.assignment i = 0
XMWWNP XMWWNP ( fp , "%d" , & c )
XMWWNP XMWWNP ( fp , "%d" , & d )
XMWWNP XMWWNP ( fp , "%d" , & n )
<operator>.assignment j = 0
XMWWNP XMWWNP ( fp , "%s" , SIY )
<operator>.assignment TAC = 0
fprintf fprintf ( EMU , "Case #%d: [" , i + 1 )
<operator>.lessThan j < c
<operator>.postIncrement j ++
<operator>.lessThan j < d
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan i < t - 1
<operator>.assignment j = 0
XMWWNP XMWWNP ( fp , "%s" , XYPJJON [ j ] )
<operator>.assignment j = 0
XMWWNP XMWWNP ( fp , "%s" , JYGGFO [ j ] )
<operator>.assignment j = 0
<operator>.addition i + 1
<operator>.assignment j = 0
fprintf fprintf ( EMU , "]\n" )
<operator>.lessThan k < c
<operator>.postIncrement k ++
<operator>.lessThan k < d
<operator>.postIncrement k ++
<operator>.notEquals SIY [ j ] != ' '
<operator>.subtraction t - 1
fprintf fprintf ( EMU , "]" )
<operator>.assignment k = 0
<operator>.assignment k = 0
<operator>.assignment DRVAC = 0
<operator>.assignment LSNRS = 0
<operator>.lessThan j1 < j
<operator>.postIncrement j1 ++
<operator>.lessEqualsThan l <= j
<operator>.postIncrement l ++
<operator>.lessEqualsThan l <= j
<operator>.postIncrement l ++
<operator>.logicalOr DRVAC == 2000 || LSNRS == 2000
<operator>.equals TAC == 0
<operator>.assignment j1 = 0
<operator>.assignment l = 0
<operator>.assignment l = 0
fprintf fprintf ( EMU , "%c" , SIY [ j ] )
<operator>.postIncrement TAC ++
<operator>.logicalAnd SIY [ j1 ] == XYPJJON [ k ] [ 0 ] && SIY [ j1 + 1 ] == XYPJJON [ k ] [ 1 ]
<operator>.equals SIY [ l ] == JYGGFO [ k ] [ 0 ]
<operator>.logicalAnd ( DRVAC > 0 ) && ( SIY [ l ] == JYGGFO [ k ] [ 1 ] )
<operator>.equals SIY [ l ] == JYGGFO [ k ] [ 1 ]
<operator>.logicalAnd LSNRS > 0 && SIY [ l ] == JYGGFO [ k ] [ 0 ]
<operator>.equals DRVAC == 2000
<operator>.equals LSNRS == 2000
<operator>.lessEqualsThan p <= j
<operator>.postIncrement p ++
<operator>.assignment SIY [ p ] = ' '
fprintf fprintf ( EMU , ", %c" , SIY [ j ] )
<operator>.assignment SIY [ j1 ] = ' '
<operator>.assignment SIY [ j1 + 1 ] = ' '
<operator>.assignment SIY [ j1 ] = XYPJJON [ k ] [ 2 ]
<operator>.postIncrement DRVAC ++
<operator>.assignment DRVAC = 2000
<operator>.postIncrement LSNRS ++
<operator>.assignment LSNRS = 2000
<operator>.assignment p = 0
<operator>.equals SIY [ j1 ] == XYPJJON [ k ] [ 0 ]
<operator>.equals SIY [ j1 + 1 ] == XYPJJON [ k ] [ 1 ]
<operator>.greaterThan DRVAC > 0
<operator>.equals SIY [ l ] == JYGGFO [ k ] [ 1 ]
<operator>.greaterThan LSNRS > 0
<operator>.equals SIY [ l ] == JYGGFO [ k ] [ 0 ]
<operator>.logicalAnd SIY [ j1 ] == XYPJJON [ k ] [ 1 ] && SIY [ j1 + 1 ] == XYPJJON [ k ] [ 0 ]
<operator>.addition j1 + 1
<operator>.addition j1 + 1
<operator>.assignment SIY [ j1 ] = ' '
<operator>.assignment SIY [ j1 + 1 ] = ' '
<operator>.assignment SIY [ j1 ] = XYPJJON [ k ] [ 2 ]
<operator>.equals SIY [ j1 ] == XYPJJON [ k ] [ 1 ]
<operator>.equals SIY [ j1 + 1 ] == XYPJJON [ k ] [ 0 ]
<operator>.addition j1 + 1
<operator>.addition j1 + 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess XYPJJON [ j ]
<operator>.indirectIndexAccess JYGGFO [ j ]
<operator>.indirectIndexAccess SIY [ j ]
<operator>.indirectIndexAccess SIY [ j ]
<operator>.indirectIndexAccess SIY [ l ]
<operator>.indirectIndexAccess JYGGFO [ k ] [ 0 ]
<operator>.indirectIndexAccess SIY [ l ]
<operator>.indirectIndexAccess JYGGFO [ k ] [ 1 ]
<operator>.indirectIndexAccess SIY [ p ]
<operator>.indirectIndexAccess SIY [ j ]
<operator>.indirectIndexAccess SIY [ j1 ]
<operator>.indirectIndexAccess XYPJJON [ k ] [ 0 ]
<operator>.indirectIndexAccess SIY [ j1 + 1 ]
<operator>.indirectIndexAccess XYPJJON [ k ] [ 1 ]
<operator>.indirectIndexAccess SIY [ j1 ]
<operator>.indirectIndexAccess SIY [ j1 + 1 ]
<operator>.indirectIndexAccess SIY [ j1 ]
<operator>.indirectIndexAccess XYPJJON [ k ] [ 2 ]
<operator>.indirectIndexAccess JYGGFO [ k ]
<operator>.indirectIndexAccess SIY [ l ]
<operator>.indirectIndexAccess JYGGFO [ k ] [ 1 ]
<operator>.indirectIndexAccess JYGGFO [ k ]
<operator>.indirectIndexAccess SIY [ l ]
<operator>.indirectIndexAccess JYGGFO [ k ] [ 0 ]
<operator>.indirectIndexAccess XYPJJON [ k ]
<operator>.indirectIndexAccess XYPJJON [ k ]
<operator>.indirectIndexAccess XYPJJON [ k ]
<operator>.indirectIndexAccess JYGGFO [ k ]
<operator>.indirectIndexAccess JYGGFO [ k ]
<operator>.indirectIndexAccess SIY [ j1 ]
<operator>.indirectIndexAccess XYPJJON [ k ] [ 1 ]
<operator>.indirectIndexAccess SIY [ j1 + 1 ]
<operator>.indirectIndexAccess XYPJJON [ k ] [ 0 ]
<operator>.indirectIndexAccess SIY [ j1 ]
<operator>.indirectIndexAccess SIY [ j1 + 1 ]
<operator>.indirectIndexAccess SIY [ j1 ]
<operator>.indirectIndexAccess XYPJJON [ k ] [ 2 ]
<operator>.indirectIndexAccess XYPJJON [ k ]
<operator>.indirectIndexAccess XYPJJON [ k ]
<operator>.indirectIndexAccess XYPJJON [ k ]
>>>PDG&142 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->58 0->59 0->60 0->61 0->62 0->63 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->78 0->79 0->80 0->81 0->82 0->85 0->87 0->90 0->91 0->92 0->93 0->97 0->98 2->1 3->1 3->1 3->69 3->78 3->85 4->1 4->1 4->70 4->80 4->87 5->1 5->1 5->7 6->1 6->1 6->8 6->22 7->1 7->1 7->1 7->10 7->16 7->45 8->1 8->1 9->1 10->1 10->1 10->1 10->10 10->11 10->16 10->17 10->18 10->19 10->20 10->21 10->22 10->22 10->23 10->25 10->27 10->29 10->31 10->31 10->32 10->34 10->36 10->37 10->37 10->38 10->45 10->45 10->99 10->100 10->101 11->1 11->10 12->9 13->5 13->5 14->6 14->6 15->1 15->10 16->1 16->1 16->17 16->23 16->33 16->40 17->1 17->1 17->18 17->25 17->35 17->42 18->1 18->1 18->20 18->27 18->29 20->1 20->1 20->1 20->16 20->44 20->62 20->65 20->67 20->74 20->83 20->84 20->86 20->88 20->95 20->96 21->1 21->1 21->58 22->1 22->1 22->39 22->46 22->62 22->74 23->1 23->1 23->16 23->23 23->24 23->24 23->33 23->40 23->102 24->1 24->23 25->1 25->1 25->17 25->25 25->26 25->26 25->35 25->42 25->103 26->1 26->25 27->27 27->28 27->28 27->29 27->40 27->42 27->47 27->48 27->51 27->53 28->1 28->27 29->1 29->1 29->1 29->18 29->27 29->29 29->30 29->30 29->44 29->104 30->1 30->29 31->1 31->1 31->11 31->39 31->46 32->23 33->1 33->1 33->17 34->25 35->1 35->1 35->18 36->27 38->1 38->29 39->1 39->8 39->22 40->1 40->1 40->16 40->23 40->40 40->41 40->41 40->51 40->59 41->1 41->40 42->1 42->1 42->1 42->17 42->25 42->42 42->43 42->43 42->49 42->50 42->53 42->55 42->57 42->60 42->61 42->69 43->1 43->42 44->1 44->1 44->20 44->58 44->62 44->74 45->10 45->31 45->31 46->1 46->8 46->22 47->40 48->1 48->42 49->1 49->1 49->69 49->78 49->85 50->1 50->1 50->70 50->80 50->87 51->1 51->1 51->28 51->51 51->52 51->52 51->53 51->64 51->83 51->90 51->91 51->97 51->98 51->112 51->113 51->126 52->1 52->51 53->53 53->54 53->54 53->55 53->65 53->66 53->85 53->106 53->107 53->120 54->1 54->53 55->1 55->1 55->28 55->53 55->55 55->56 55->56 55->67 55->68 55->71 55->87 55->108 55->109 55->123 56->1 56->55 57->1 57->1 57->1 57->71 57->82 58->1 58->1 58->62 58->63 58->63 58->74 58->105 58->111 59->1 59->51 60->53 61->1 61->55 62->1 62->1 62->20 62->39 62->44 62->46 62->74 63->1 63->1 63->58 64->1 64->1 64->1 64->75 64->76 64->77 64->89 64->91 64->95 64->116 64->117 64->118 64->119 64->128 64->131 64->132 64->139 65->1 65->1 65->1 65->20 65->67 65->68 65->78 65->86 65->88 66->1 66->1 66->1 66->79 67->1 67->1 67->1 67->20 67->65 67->66 67->80 67->86 67->88 68->1 68->1 68->1 68->81 69->57 69->57 69->70 70->57 70->57 71->1 71->1 71->28 71->53 71->71 71->72 71->72 71->73 71->110 72->1 72->71 73->1 73->1 73->20 74->1 74->1 74->20 74->39 74->44 74->46 74->62 75->1 76->1 76->1 76->20 76->84 76->96 77->1 77->1 77->1 77->20 77->83 78->1 78->85 79->1 79->69 79->78 79->85 80->1 80->87 81->1 81->70 81->80 81->87 82->1 82->71 83->1 83->64 83->64 83->84 83->90 83->95 83->96 83->114 83->115 83->127 84->1 84->1 84->20 84->64 84->64 84->95 84->96 85->66 85->66 85->69 85->78 85->86 85->121 85->122 85->129 86->1 86->1 86->20 86->65 86->66 86->66 86->67 86->67 87->68 87->68 87->70 87->80 87->88 87->124 87->125 87->130 88->1 88->1 88->20 88->65 88->65 88->67 88->68 88->68 89->1 89->1 89->1 89->92 89->93 89->94 89->98 89->135 89->136 89->137 89->138 89->141 92->1 93->1 93->1 93->20 93->84 93->96 94->1 94->1 94->1 94->20 94->83 95->1 95->1 95->20 95->83 95->84 95->89 95->89 95->96 95->97 95->133 95->134 95->140 96->1 96->1 96->20 96->83 96->84 96->89 96->89
>>>Token int main ( void ) { int i , j , k , l , n , c , d , t , p , DRVAC = 0 , LSNRS = 0 , j1 , TAC ; char XYPJJON [ 40 ] [ 3 ] , JYGGFO [ 30 ] [ 2 ] , SIY [ 200 ] ; RIFJ * fp = EFNSA ( " " , " " ) ; RIFJ * EMU = EFNSA ( " " , " " ) ; XMWWNP ( fp , " " , & t ) ; for ( i = 0 ; i < t ; i ++ ) { XMWWNP ( fp , " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) { XMWWNP ( fp , " " , XYPJJON [ j ] ) ; } XMWWNP ( fp , " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) { XMWWNP ( fp , " " , JYGGFO [ j ] ) ; } XMWWNP ( fp , " " , & n ) ; j = 0 ; XMWWNP ( fp , " " , SIY ) ; for ( j = 0 ; j < n ; j ++ ) { for ( k = 0 ; k < c ; k ++ ) { for ( j1 = 0 ; j1 < j ; j1 ++ ) { if ( SIY [ j1 ] == XYPJJON [ k ] [ 0 ] && SIY [ j1 + 1 ] == XYPJJON [ k ] [ 1 ] ) { SIY [ j1 ] = ' ' ; SIY [ j1 + 1 ] = ' ' ; SIY [ j1 ] = XYPJJON [ k ] [ 2 ] ; } else if ( SIY [ j1 ] == XYPJJON [ k ] [ 1 ] && SIY [ j1 + 1 ] == XYPJJON [ k ] [ 0 ] ) { SIY [ j1 ] = ' ' ; SIY [ j1 + 1 ] = ' ' ; SIY [ j1 ] = XYPJJON [ k ] [ 2 ] ; } } } for ( k = 0 ; k < d ; k ++ ) { for ( l = 0 ; l <= j ; l ++ ) { if ( SIY [ l ] == JYGGFO [ k ] [ 0 ] ) DRVAC ++ ; if ( ( DRVAC > 0 ) && ( SIY [ l ] == JYGGFO [ k ] [ 1 ] ) ) DRVAC = 2000 ; } for ( l = 0 ; l <= j ; l ++ ) { if ( SIY [ l ] == JYGGFO [ k ] [ 1 ] ) LSNRS ++ ; if ( LSNRS > 0 && SIY [ l ] == JYGGFO [ k ] [ 0 ] ) LSNRS = 2000 ; } if ( DRVAC == 2000 || LSNRS == 2000 ) { for ( p = 0 ; p <= j ; p ++ ) SIY [ p ] = ' ' ; } DRVAC = 0 ; LSNRS = 0 ; } } TAC = 0 ; fprintf ( EMU , " " , i + 1 ) ; for ( j = 0 ; j < n ; j ++ ) { if ( SIY [ j ] != ' ' ) { if ( TAC == 0 ) { fprintf ( EMU , " " , SIY [ j ] ) ; TAC ++ ; } else { fprintf ( EMU , " " , SIY [ j ] ) ; } } } if ( i < t - 1 ) fprintf ( EMU , " \n " ) ; else fprintf ( EMU , " " ) ; } IWGVJF ( EMU ) ; return 0 ; }
>>>Func
METHOD DVCUMUXDULXTFKWE
METHOD_RETURN void
PARAM char const * QHMIMK
PARAM char const * KHONXO
PARAM bool BAAEVDBK
<operator>.assignment * ACNU = NLQVXOCQX ( QHMIMK )
QYMBLURASGDSHJQMLBMNQH QYMBLURASGDSHJQMLBMNQH ( ACNU )
KRRJP KRRJP ( ACNU , MMSGQY )
TACVHAB TACVHAB ( BAAEVDBK ? '\0' : '\n' )
free free ( ACNU )
<operator>.logicalAnd KHONXO && DEABCQDUPWUCXGWSIRYLK ( ACNU ) && ! IXBUJEJWWSCBTEFKJBCGVF ( ACNU )
NLQVXOCQX NLQVXOCQX ( QHMIMK )
FEEANWBBJKYNH FEEANWBBJKYNH ( ACNU , KHONXO )
<operator>.conditional BAAEVDBK ? '\0' : '\n'
<operator>.logicalAnd KHONXO && DEABCQDUPWUCXGWSIRYLK ( ACNU )
<operator>.logicalNot ! IXBUJEJWWSCBTEFKJBCGVF ( ACNU )
DEABCQDUPWUCXGWSIRYLK DEABCQDUPWUCXGWSIRYLK ( ACNU )
IXBUJEJWWSCBTEFKJBCGVF IXBUJEJWWSCBTEFKJBCGVF ( ACNU )
>>>PDG&18 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->16 0->17 2->11 3->14 5->1 5->1 5->6 6->1 6->7 6->12 6->16 6->17 7->1 7->1 7->9 8->1 8->1 9->1 10->1 10->1 10->1 10->12 11->1 11->5 12->1 12->1 12->7 13->1 14->1 14->1 14->10 14->10 14->12 14->15 14->17 15->1 15->10 16->7 16->12 16->14 16->17 17->7 17->12 17->15
>>>Token static void DVCUMUXDULXTFKWE ( char const * QHMIMK , char const * KHONXO , bool BAAEVDBK ) { char * ACNU = NLQVXOCQX ( QHMIMK ) ; QYMBLURASGDSHJQMLBMNQH ( ACNU ) ; if ( KHONXO && DEABCQDUPWUCXGWSIRYLK ( ACNU ) && ! IXBUJEJWWSCBTEFKJBCGVF ( ACNU ) ) FEEANWBBJKYNH ( ACNU , KHONXO ) ; KRRJP ( ACNU , MMSGQY ) ; TACVHAB ( BAAEVDBK ? ' \0 ' : ' \n ' ) ; free ( ACNU ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
<operator>.assignment BALPUQWSSC = 0
UJBXX UJBXX ( "%d" , & PJHFQFAJJEBJYM )
RETURN return 1 ; return 1 ;
<operator>.lessThan i < PJHFQFAJJEBJYM
<operator>.postIncrement i ++
LITERAL 1 return 1 ;
<operator>.assignment i = 0
<operator>.assignment BALPUQWSSC = 0
UJBXX UJBXX ( "%d" , & RAGYOJHUIBR )
UJBXX UJBXX ( "%d" , & PQDBROQDXXT )
UJBXX UJBXX ( "%d" , & DXDNFGYGSS )
UJBXX UJBXX ( " %s" , GXULFVRAR )
printf printf ( "Case #%d: [" , i + 1 )
printf printf ( "]\n" )
<operator>.lessThan j < 26
<operator>.postIncrement j ++
<operator>.greaterThan RAGYOJHUIBR > 0
<operator>.postDecrement RAGYOJHUIBR --
<operator>.greaterThan PQDBROQDXXT > 0
<operator>.postDecrement PQDBROQDXXT --
<operator>.lessThan j < DXDNFGYGSS
<operator>.postIncrement j ++
<operator>.lessThan m < BALPUQWSSC - 1
<operator>.postIncrement m ++
printf printf ( "%c, " , ACMWRQONYX [ m ] )
<operator>.notEquals BALPUQWSSC != 0
<operator>.assignment j = 0
<operator>.assignment BIIXHATWRGPO [ j ] = 0
UJBXX UJBXX ( " %s" , GBUUNEPVFJL )
<operator>.assignment IECBKGWOMQGJJO [ GBUUNEPVFJL [ 0 ] - 'A' ] [ GBUUNEPVFJL [ 1 ] - 'A' ] = GBUUNEPVFJL [ 2 ] - 'A'
<operator>.assignment IECBKGWOMQGJJO [ GBUUNEPVFJL [ 1 ] - 'A' ] [ GBUUNEPVFJL [ 0 ] - 'A' ] = GBUUNEPVFJL [ 2 ] - 'A'
UJBXX UJBXX ( " %s" , YMOSDFVBFSH )
<operator>.assignment GSQGQRPBSWDOVVULM [ YMOSDFVBFSH [ 0 ] - 'A' ] [ YMOSDFVBFSH [ 1 ] - 'A' ] = 1
<operator>.assignment GSQGQRPBSWDOVVULM [ YMOSDFVBFSH [ 1 ] - 'A' ] [ YMOSDFVBFSH [ 0 ] - 'A' ] = 1
<operator>.assignment j = 0
<operator>.assignment LAIKWVPSPRK = GXULFVRAR [ j ] - 'A'
<operator>.addition i + 1
<operator>.assignment m = 0
printf printf ( "%c" , ACMWRQONYX [ BALPUQWSSC - 1 ] )
<operator>.lessThan k < 26
<operator>.postIncrement k ++
<operator>.logicalAnd ( IJAL != 0 ) && ( IJAL != 2 )
<operator>.notEquals IJAL != 2
<operator>.subtraction BALPUQWSSC - 1
<operator>.assignment k = 0
<operator>.assignment IECBKGWOMQGJJO [ j ] [ k ] = - 1
<operator>.assignment GSQGQRPBSWDOVVULM [ j ] [ k ] = 0
<operator>.subtraction GBUUNEPVFJL [ 2 ] - 'A'
<operator>.subtraction GBUUNEPVFJL [ 2 ] - 'A'
<operator>.subtraction GXULFVRAR [ j ] - 'A'
<operator>.assignment IJAL = 0
<operator>.assignment ACMWRQONYX [ BALPUQWSSC ++ ] = LAIKWVPSPRK + 'A'
<operator>.postIncrement BIIXHATWRGPO [ LAIKWVPSPRK ] ++
<operator>.subtraction GBUUNEPVFJL [ 1 ] - 'A'
<operator>.subtraction GBUUNEPVFJL [ 0 ] - 'A'
<operator>.subtraction YMOSDFVBFSH [ 1 ] - 'A'
<operator>.subtraction YMOSDFVBFSH [ 0 ] - 'A'
<operator>.notEquals BALPUQWSSC != 0
<operator>.notEquals IJAL != 0
<operator>.notEquals IJAL != 2
<operator>.subtraction BALPUQWSSC - 1
<operator>.minus - 1
<operator>.subtraction GBUUNEPVFJL [ 0 ] - 'A'
<operator>.subtraction GBUUNEPVFJL [ 1 ] - 'A'
<operator>.subtraction YMOSDFVBFSH [ 0 ] - 'A'
<operator>.subtraction YMOSDFVBFSH [ 1 ] - 'A'
<operator>.assignment PVYONSDBTEETPVQG = ACMWRQONYX [ BALPUQWSSC - 1 ] - 'A'
<operator>.addition LAIKWVPSPRK + 'A'
<operator>.notEquals IECBKGWOMQGJJO [ LAIKWVPSPRK ] [ PVYONSDBTEETPVQG ] != - 1
<operator>.lessThan k < 26
<operator>.postIncrement k ++
<operator>.postIncrement BALPUQWSSC ++
<operator>.subtraction ACMWRQONYX [ BALPUQWSSC - 1 ] - 'A'
<operator>.assignment IJAL = 1
<operator>.assignment LAIKWVPSPRK = IECBKGWOMQGJJO [ LAIKWVPSPRK ] [ PVYONSDBTEETPVQG ]
<operator>.postDecrement BALPUQWSSC --
<operator>.postDecrement BIIXHATWRGPO [ PVYONSDBTEETPVQG ] --
<operator>.assignment k = 0
<operator>.minus - 1
<operator>.logicalAnd GSQGQRPBSWDOVVULM [ LAIKWVPSPRK ] [ k ] && BIIXHATWRGPO [ k ]
<operator>.subtraction BALPUQWSSC - 1
<operator>.assignment IJAL = 2
<operator>.lessThan m < 26
<operator>.postIncrement m ++
<operator>.assignment m = 0
<operator>.assignment BIIXHATWRGPO [ m ] = 0
<operator>.assignment BALPUQWSSC = 0
<operator>.addressOf & RAGYOJHUIBR
<operator>.addressOf & PQDBROQDXXT
<operator>.addressOf & DXDNFGYGSS
<operator>.indirectIndexAccess ACMWRQONYX [ m ]
<operator>.indirectIndexAccess BIIXHATWRGPO [ j ]
<operator>.indirectIndexAccess IECBKGWOMQGJJO [ GBUUNEPVFJL [ 0 ] - 'A' ] [ GBUUNEPVFJL [ 1 ] - 'A' ]
<operator>.indirectIndexAccess IECBKGWOMQGJJO [ GBUUNEPVFJL [ 1 ] - 'A' ] [ GBUUNEPVFJL [ 0 ] - 'A' ]
<operator>.indirectIndexAccess GSQGQRPBSWDOVVULM [ YMOSDFVBFSH [ 0 ] - 'A' ] [ YMOSDFVBFSH [ 1 ] - 'A' ]
<operator>.indirectIndexAccess GSQGQRPBSWDOVVULM [ YMOSDFVBFSH [ 1 ] - 'A' ] [ YMOSDFVBFSH [ 0 ] - 'A' ]
<operator>.indirectIndexAccess ACMWRQONYX [ BALPUQWSSC - 1 ]
<operator>.indirectIndexAccess IECBKGWOMQGJJO [ GBUUNEPVFJL [ 0 ] - 'A' ]
<operator>.indirectIndexAccess GBUUNEPVFJL [ 2 ]
<operator>.indirectIndexAccess IECBKGWOMQGJJO [ GBUUNEPVFJL [ 1 ] - 'A' ]
<operator>.indirectIndexAccess GBUUNEPVFJL [ 2 ]
<operator>.indirectIndexAccess GSQGQRPBSWDOVVULM [ YMOSDFVBFSH [ 0 ] - 'A' ]
<operator>.indirectIndexAccess GSQGQRPBSWDOVVULM [ YMOSDFVBFSH [ 1 ] - 'A' ]
<operator>.indirectIndexAccess GXULFVRAR [ j ]
<operator>.indirectIndexAccess IECBKGWOMQGJJO [ j ] [ k ]
<operator>.indirectIndexAccess GSQGQRPBSWDOVVULM [ j ] [ k ]
<operator>.indirectIndexAccess GBUUNEPVFJL [ 1 ]
<operator>.indirectIndexAccess GBUUNEPVFJL [ 0 ]
<operator>.indirectIndexAccess YMOSDFVBFSH [ 1 ]
<operator>.indirectIndexAccess YMOSDFVBFSH [ 0 ]
<operator>.indirectIndexAccess ACMWRQONYX [ BALPUQWSSC ++ ]
<operator>.indirectIndexAccess BIIXHATWRGPO [ LAIKWVPSPRK ]
<operator>.indirectIndexAccess IECBKGWOMQGJJO [ j ]
<operator>.indirectIndexAccess GSQGQRPBSWDOVVULM [ j ]
<operator>.indirectIndexAccess GBUUNEPVFJL [ 0 ]
<operator>.indirectIndexAccess GBUUNEPVFJL [ 1 ]
<operator>.indirectIndexAccess YMOSDFVBFSH [ 0 ]
<operator>.indirectIndexAccess YMOSDFVBFSH [ 1 ]
<operator>.indirectIndexAccess ACMWRQONYX [ BALPUQWSSC - 1 ]
<operator>.indirectIndexAccess IECBKGWOMQGJJO [ LAIKWVPSPRK ] [ PVYONSDBTEETPVQG ]
<operator>.indirectIndexAccess IECBKGWOMQGJJO [ LAIKWVPSPRK ]
<operator>.indirectIndexAccess IECBKGWOMQGJJO [ LAIKWVPSPRK ] [ PVYONSDBTEETPVQG ]
<operator>.indirectIndexAccess BIIXHATWRGPO [ PVYONSDBTEETPVQG ]
<operator>.indirectIndexAccess IECBKGWOMQGJJO [ LAIKWVPSPRK ]
<operator>.indirectIndexAccess GSQGQRPBSWDOVVULM [ LAIKWVPSPRK ] [ k ]
<operator>.indirectIndexAccess BIIXHATWRGPO [ k ]
<operator>.indirectIndexAccess GSQGQRPBSWDOVVULM [ LAIKWVPSPRK ]
<operator>.indirectIndexAccess BIIXHATWRGPO [ m ]
>>>PDG&131 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->34 0->35 0->36 0->37 0->39 0->40 0->41 0->42 0->43 0->45 0->46 0->47 0->49 0->50 0->51 0->52 0->53 0->54 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->70 0->72 0->73 0->74 0->75 0->76 0->78 0->80 0->81 0->83 0->84 0->85 0->86 0->87 0->88 0->89 2->1 3->1 3->1 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->15 6->16 6->17 6->19 6->21 6->23 6->25 6->28 6->29 6->37 6->39 6->39 6->40 6->46 6->90 6->91 6->92 7->1 7->6 8->5 9->1 9->6 10->1 10->46 10->60 11->1 11->1 11->19 11->20 12->1 12->1 12->21 12->22 13->1 13->1 13->23 14->1 14->1 14->52 15->1 15->1 16->1 17->1 17->17 17->18 17->18 17->30 17->42 17->47 17->94 18->1 18->17 19->1 19->1 19->11 19->19 19->20 19->20 19->31 19->32 19->33 19->50 19->51 19->56 19->57 19->65 19->66 19->95 19->96 19->100 19->101 19->102 19->103 19->109 19->110 19->117 19->118 20->1 20->19 21->1 21->1 21->12 21->21 21->22 21->22 21->34 21->35 21->36 21->58 21->59 21->67 21->68 21->97 21->98 21->104 21->105 21->111 21->112 21->119 21->120 22->1 22->21 23->1 23->1 23->1 23->13 23->23 23->24 23->24 23->38 23->44 23->45 23->52 23->53 23->60 23->61 23->106 24->1 24->23 25->1 25->1 25->1 25->25 25->26 25->26 25->27 25->46 25->93 26->1 26->25 27->1 27->1 28->1 28->1 28->41 28->63 28->63 28->99 29->17 30->1 30->1 31->1 31->1 31->50 31->51 31->56 31->57 31->65 31->66 32->1 32->1 33->1 33->1 33->1 34->1 34->1 34->58 34->59 34->67 34->68 35->1 35->1 36->1 36->1 37->1 37->23 38->1 38->1 38->1 38->54 38->70 40->1 40->25 41->1 41->1 41->75 42->1 42->1 42->42 42->43 42->43 42->48 42->49 42->64 42->107 42->108 42->115 42->116 43->1 43->42 44->1 44->1 44->44 44->53 44->60 44->61 45->1 45->1 45->44 45->54 45->55 45->70 45->74 45->113 45->114 46->25 46->25 46->28 47->1 47->42 48->1 48->1 48->1 49->1 49->1 50->32 50->32 50->51 51->1 51->31 51->33 51->33 51->50 52->1 52->14 52->38 52->38 53->1 53->61 54->1 54->1 54->1 55->1 55->1 56->66 57->1 57->31 57->65 58->68 59->1 59->34 59->67 60->46 60->69 60->71 60->74 60->75 60->81 60->83 60->83 60->121 60->122 60->123 61->44 61->44 61->45 61->62 61->62 62->44 62->44 62->45 63->1 64->48 65->57 66->1 66->31 66->56 67->59 68->1 68->34 68->58 69->1 69->1 69->1 70->1 71->1 71->1 71->1 71->72 71->76 71->77 71->77 71->78 71->79 71->80 71->124 71->125 71->126 72->1 72->1 72->73 72->82 72->127 72->129 73->1 73->72 74->46 74->60 75->1 75->41 75->69 75->69 76->1 76->61 77->1 77->1 77->1 77->54 77->70 78->1 78->46 78->60 78->74 79->1 79->1 80->1 80->72 81->71 82->1 82->1 82->1 82->72 82->73 82->84 82->85 82->87 83->46 83->60 83->74 83->78 84->1 84->61 85->1 85->85 85->86 85->86 85->88 85->89 85->130 86->1 86->85 87->85 88->1 88->1 89->1 89->46 89->60 89->74 127->128
>>>Token int main ( void ) { int i , j , k , m , IJAL ; int PJHFQFAJJEBJYM , RAGYOJHUIBR , PQDBROQDXXT , DXDNFGYGSS ; char GBUUNEPVFJL [ 4 ] , YMOSDFVBFSH [ 3 ] , GXULFVRAR [ 100 ] , ACMWRQONYX [ 100 ] ; int BALPUQWSSC = 0 ; int LAIKWVPSPRK , PVYONSDBTEETPVQG ; UJBXX ( " " , & PJHFQFAJJEBJYM ) ; for ( i = 0 ; i < PJHFQFAJJEBJYM ; i ++ ) { BALPUQWSSC = 0 ; for ( j = 0 ; j < 26 ; j ++ ) { BIIXHATWRGPO [ j ] = 0 ; for ( k = 0 ; k < 26 ; k ++ ) { IECBKGWOMQGJJO [ j ] [ k ] = - 1 ; GSQGQRPBSWDOVVULM [ j ] [ k ] = 0 ; } } UJBXX ( " " , & RAGYOJHUIBR ) ; for ( ; RAGYOJHUIBR > 0 ; RAGYOJHUIBR -- ) { UJBXX ( " " , GBUUNEPVFJL ) ; IECBKGWOMQGJJO [ GBUUNEPVFJL [ 0 ] - ' ' ] [ GBUUNEPVFJL [ 1 ] - ' ' ] = GBUUNEPVFJL [ 2 ] - ' ' ; IECBKGWOMQGJJO [ GBUUNEPVFJL [ 1 ] - ' ' ] [ GBUUNEPVFJL [ 0 ] - ' ' ] = GBUUNEPVFJL [ 2 ] - ' ' ; } UJBXX ( " " , & PQDBROQDXXT ) ; for ( ; PQDBROQDXXT > 0 ; PQDBROQDXXT -- ) { UJBXX ( " " , YMOSDFVBFSH ) ; GSQGQRPBSWDOVVULM [ YMOSDFVBFSH [ 0 ] - ' ' ] [ YMOSDFVBFSH [ 1 ] - ' ' ] = 1 ; GSQGQRPBSWDOVVULM [ YMOSDFVBFSH [ 1 ] - ' ' ] [ YMOSDFVBFSH [ 0 ] - ' ' ] = 1 ; } UJBXX ( " " , & DXDNFGYGSS ) ; UJBXX ( " " , GXULFVRAR ) ; for ( j = 0 ; j < DXDNFGYGSS ; j ++ ) { LAIKWVPSPRK = GXULFVRAR [ j ] - ' ' ; do { IJAL = 0 ; if ( BALPUQWSSC != 0 ) { PVYONSDBTEETPVQG = ACMWRQONYX [ BALPUQWSSC - 1 ] - ' ' ; if ( IECBKGWOMQGJJO [ LAIKWVPSPRK ] [ PVYONSDBTEETPVQG ] != - 1 ) { IJAL = 1 ; LAIKWVPSPRK = IECBKGWOMQGJJO [ LAIKWVPSPRK ] [ PVYONSDBTEETPVQG ] ; BALPUQWSSC -- ; BIIXHATWRGPO [ PVYONSDBTEETPVQG ] -- ; continue ; } for ( k = 0 ; k < 26 ; k ++ ) { if ( GSQGQRPBSWDOVVULM [ LAIKWVPSPRK ] [ k ] && BIIXHATWRGPO [ k ] ) { IJAL = 2 ; for ( m = 0 ; m < 26 ; m ++ ) { BIIXHATWRGPO [ m ] = 0 ; BALPUQWSSC = 0 ; } break ; } } } } while ( ( IJAL != 0 ) && ( IJAL != 2 ) ) ; if ( IJAL != 2 ) { ACMWRQONYX [ BALPUQWSSC ++ ] = LAIKWVPSPRK + ' ' ; BIIXHATWRGPO [ LAIKWVPSPRK ] ++ ; } } printf ( " " , i + 1 ) ; for ( m = 0 ; m < BALPUQWSSC - 1 ; m ++ ) printf ( " " , ACMWRQONYX [ m ] ) ; if ( BALPUQWSSC != 0 ) printf ( " " , ACMWRQONYX [ BALPUQWSSC - 1 ] ) ; printf ( " \n " ) ; } return 1 ; }
>>>Func
METHOD XEWNKSOHKK
METHOD_RETURN void
PARAM int * CDL
PARAM int JCJM
<operator>.lessThan i < JCJM - 1
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment YCMKYBF = false
<operator>.subtraction JCJM - 1
<operator>.lessThan j < JCJM - 1 - i
<operator>.postIncrement j ++
<operator>.logicalNot ! YCMKYBF
<operator>.assignment j = 0
<operator>.subtraction JCJM - 1 - i
<operator>.greaterThan CDL [ j ] > CDL [ j + 1 ]
<operator>.subtraction JCJM - 1
YAVF YAVF ( & CDL [ j ] , & CDL [ j + 1 ] )
<operator>.assignment YCMKYBF = true
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.indirectIndexAccess CDL [ j ]
<operator>.indirectIndexAccess CDL [ j + 1 ]
<operator>.addressOf & CDL [ j ]
<operator>.addressOf & CDL [ j + 1 ]
<operator>.indirectIndexAccess CDL [ j ]
<operator>.indirectIndexAccess CDL [ j + 1 ]
>>>PDG&26 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->17 0->18 0->19 2->1 2->14 2->16 3->8 4->1 4->1 4->1 4->7 4->9 4->11 4->12 4->13 4->13 4->15 5->1 5->4 6->1 6->4 7->1 7->1 7->11 8->1 8->4 8->4 8->15 9->1 9->1 9->1 9->9 9->10 9->10 9->13 9->14 9->15 9->18 9->18 9->19 9->20 9->21 10->1 10->9 11->1 11->1 11->4 11->5 11->8 12->1 12->9 13->5 13->9 13->9 14->16 14->16 14->16 14->17 14->19 14->22 14->23 14->24 14->25 15->8 15->13 15->13 16->14 16->14 17->1 17->11
>>>Token void XEWNKSOHKK ( int * CDL , int JCJM ) { for ( int i = 0 ; i < JCJM - 1 ; i ++ ) { bool YCMKYBF = false ; for ( int j = 0 ; j < JCJM - 1 - i ; j ++ ) { if ( CDL [ j ] > CDL [ j + 1 ] ) { YAVF ( & CDL [ j ] , & CDL [ j + 1 ] ) ; YCMKYBF = true ; } } if ( ! YCMKYBF ) { break ; } } }
>>>Func
METHOD XRP
METHOD_RETURN int
PARAM a
PARAM b
RETURN return ( b > a ? XRP ( b , a ) : ( b == 0 ? a : XRP ( b , a % b ) ) ) ; return ( b > a ? XRP ( b , a ) : ( b == 0 ? a : XRP ( b , a % b ) ) ) ;
<operator>.conditional b > a ? XRP ( b , a ) : ( b == 0 ? a : XRP ( b , a % b ) )
<operator>.greaterThan b > a
XRP XRP ( b , a )
<operator>.conditional b == 0 ? a : XRP ( b , a % b )
<operator>.equals b == 0
XRP XRP ( b , a % b )
<operator>.modulo a % b
>>>PDG&12 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->6 3->6 4->1 5->1 5->1 5->1 5->1 5->4 6->5 6->7 6->7 6->7 6->8 6->8 6->9 6->9 6->11 7->1 7->1 7->5 7->5 8->1 8->1 8->1 9->1 9->10 9->11 9->11 10->1 10->1 10->5 10->5 10->8 10->8 11->5 11->8 11->10 11->10
>>>Token int XRP ( a , b ) { return ( b > a ? XRP ( b , a ) : ( b == 0 ? a : XRP ( b , a % b ) ) ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment * DTSKBAUWCATRVL = NULL
<operator>.assignment * XLPOYNOU = NULL
<operator>.assignment OGEJEPG . VRUTDMKCAAYUKRICPSOAEB = NULL
<operator>.assignment OGEJEPG . GMSP = QCTJISBDO
<operator>.assignment OGEJEPG . ERAISCJPO = 0
<operator>.assignment OGEJEPG . BYQSTHUXICKBTDFPMNKNSATL = NULL
<operator>.assignment OGEJEPG . CEGGNXUQWNLSUHQFLDHF = NULL
HOWTFIKXKGLMLTU HOWTFIKXKGLMLTU ( & argc , & argv )
BSPSRDELXNEDYIMG BSPSRDELXNEDYIMG ( argv [ 0 ] )
PCELHMVHW PCELHMVHW ( FVLSRG , "" )
TKXOFDVQBJUGJD TKXOFDVQBJUGJD ( VPSAVHJ , IDSHIOUBH )
DXTDMYGIRH DXTDMYGIRH ( VPSAVHJ )
UNQGSO UNQGSO ( XOOUVXFBQPMI )
RETURN return QSPGMDYSNVBUMRSAIHWB ( argc - JMSMRQ , argv + JMSMRQ , AXDKHQJWVVJ , & OGEJEPG ) ; return QSPGMDYSNVBUMRSAIHWB ( argc - JMSMRQ , argv + JMSMRQ , AXDKHQJWVVJ , & OGEJEPG ) ;
<operator>.notEquals ( URYO = KNRQNNTBNBL ( argc , argv , "pm:vZ" , FKIUDOOR , NULL ) ) != - 1
<operator>.equals JMSMRQ == argc
IDENTIFIER XLPOYNOU if (XLPOYNOU)
<operator>.logicalOr OGEJEPG . VRUTDMKCAAYUKRICPSOAEB || DTSKBAUWCATRVL
QSPGMDYSNVBUMRSAIHWB QSPGMDYSNVBUMRSAIHWB ( argc - JMSMRQ , argv + JMSMRQ , AXDKHQJWVVJ , & OGEJEPG )
RLOHS RLOHS ( 0   0   _ ( "missing operand" ) )
DWJTT DWJTT ( EXIT_FAILURE )
<operator>.assignment BAW = 0
<operator>.assignment RNQMESBYXND = LXNIQ ( 0 )
<operator>.assignment OGEJEPG . CODLAJSHNFWUVG = RNQMESBYXND & ~ ( BPVRFAM | IALVDYT )
LXNIQ LXNIQ ( OGEJEPG . YBKHLVNCKL )
<operator>.assignment URYO = KNRQNNTBNBL ( argc , argv , "pm:vZ" , FKIUDOOR , NULL )
<operator>.minus - 1
IDENTIFIER URYO switch(URYO)
XFGKNTSIWKYPXEXI XFGKNTSIWKYPXEXI ( )
<operator>.lessThan BAW < 0
IDENTIFIER DTSKBAUWCATRVL if (DTSKBAUWCATRVL)
<operator>.subtraction argc - JMSMRQ
<operator>.addition argv + JMSMRQ
KNRQNNTBNBL KNRQNNTBNBL ( argc , argv , "pm:vZ" , FKIUDOOR , NULL )
LITERAL 'p' <empty>
<operator>.assignment OGEJEPG . VRUTDMKCAAYUKRICPSOAEB = NFGIBGPCAFOKS
LITERAL 'm' <empty>
<operator>.assignment DTSKBAUWCATRVL = FCJUPF
LITERAL 'v' <empty>
<operator>.assignment OGEJEPG . BYQSTHUXICKBTDFPMNKNSATL = _ ( "created directory %s" )
LITERAL 'Z' <empty>
LYFUTOOFPHKBUMSPVAQWAFXM LYFUTOOFPHKBUMSPVAQWAFXM ( GEHHXUVLVDHR , TXXMGKN )
DWJTT DWJTT ( EXIT_FAILURE )
_ _ ( "missing operand" )
<operator>.assignment BAW = JIWGGICKRTEQTSYFHCESVAEK ( XLPOYNOU )
EKI EKI ( EXIT_FAILURE   JTLBQ   _ ( "failed to set default file creation context to %s" )   LDFEC ( XLPOYNOU ) )
LXNIQ LXNIQ ( 0 )
<operator>.and RNQMESBYXND & ~ ( BPVRFAM | IALVDYT )
<operator>.assignment * PHILGQ = OVMGDOSLQGKU ( DTSKBAUWCATRVL )
<operator>.assignment OGEJEPG . GMSP = GGQPVMOOWQS ( QCTJISBDO , true , RNQMESBYXND , PHILGQ , & OGEJEPG . ERAISCJPO )
<operator>.assignment OGEJEPG . YBKHLVNCKL = RNQMESBYXND & ~ OGEJEPG . GMSP
free free ( PHILGQ )
XFGKNTSIWKYPXEXI XFGKNTSIWKYPXEXI ( )
<operator>.assignment BAW = UQCNSDKCNHKTSM ( XLPOYNOU )
<operator>.not ~ ( BPVRFAM | IALVDYT )
<operator>.logicalNot ! PHILGQ
<operator>.assignment OGEJEPG . GMSP = QCTJISBDO
<operator>.assignment OGEJEPG . YBKHLVNCKL = RNQMESBYXND
_ _ ( "created directory %s" )
<operator>.assignment XLPOYNOU = FCJUPF
JIWGGICKRTEQTSYFHCESVAEK JIWGGICKRTEQTSYFHCESVAEK ( XLPOYNOU )
_ _ ( "failed to set default file creation context to %s" )
LDFEC LDFEC ( XLPOYNOU )
<operator>.or BPVRFAM | IALVDYT
OVMGDOSLQGKU OVMGDOSLQGKU ( DTSKBAUWCATRVL )
EKI EKI ( EXIT_FAILURE   0   _ ( "invalid mode %s" )   LDFEC ( DTSKBAUWCATRVL ) )
GGQPVMOOWQS GGQPVMOOWQS ( QCTJISBDO , true , RNQMESBYXND , PHILGQ , & OGEJEPG . ERAISCJPO )
<operator>.and RNQMESBYXND & ~ OGEJEPG . GMSP
UQCNSDKCNHKTSM UQCNSDKCNHKTSM ( XLPOYNOU )
<operator>.not ~ OGEJEPG . GMSP
<operator>.greaterThan HFXMFGDPYITKELPCRY ( ) > 0
_ _ ( "invalid mode %s" )
LDFEC LDFEC ( DTSKBAUWCATRVL )
IDENTIFIER FCJUPF if (FCJUPF)
<operator>.assignment XLPOYNOU = FCJUPF
IDENTIFIER FCJUPF if (FCJUPF)
<operator>.assignment OGEJEPG . CEGGNXUQWNLSUHQFLDHF = OHSKPPWRHUVG ( FGNFSSLVKMHGWNRP , NULL , 0 )
RLOHS RLOHS ( 0   0   _ ( "warning: ignoring --context; " "it requires an SELinux/SMACK-enabled kernel" ) )
<operator>.logicalNot ! OGEJEPG . CEGGNXUQWNLSUHQFLDHF
OHSKPPWRHUVG OHSKPPWRHUVG ( FGNFSSLVKMHGWNRP , NULL , 0 )
RLOHS RLOHS ( 0   JTLBQ   _ ( "warning: ignoring --context" ) )
_ _ ( "warning: ignoring --context; " "it requires an SELinux/SMACK-enabled kernel" )
_ _ ( "warning: ignoring --context" )
<operator>.fieldAccess OGEJEPG . CODLAJSHNFWUVG
<operator>.fieldAccess OGEJEPG . YBKHLVNCKL
FIELD_IDENTIFIER CODLAJSHNFWUVG CODLAJSHNFWUVG
FIELD_IDENTIFIER YBKHLVNCKL YBKHLVNCKL
<operator>.fieldAccess OGEJEPG . VRUTDMKCAAYUKRICPSOAEB
<operator>.fieldAccess OGEJEPG . BYQSTHUXICKBTDFPMNKNSATL
<operator>.fieldAccess OGEJEPG . GMSP
<operator>.fieldAccess OGEJEPG . YBKHLVNCKL
FIELD_IDENTIFIER VRUTDMKCAAYUKRICPSOAEB VRUTDMKCAAYUKRICPSOAEB
FIELD_IDENTIFIER BYQSTHUXICKBTDFPMNKNSATL BYQSTHUXICKBTDFPMNKNSATL
FIELD_IDENTIFIER GMSP GMSP
<operator>.addressOf & OGEJEPG . ERAISCJPO
FIELD_IDENTIFIER YBKHLVNCKL YBKHLVNCKL
<operator>.fieldAccess OGEJEPG . GMSP
<operator>.fieldAccess OGEJEPG . YBKHLVNCKL
<operator>.fieldAccess OGEJEPG . ERAISCJPO
<operator>.fieldAccess OGEJEPG . GMSP
FIELD_IDENTIFIER GMSP GMSP
FIELD_IDENTIFIER YBKHLVNCKL YBKHLVNCKL
FIELD_IDENTIFIER ERAISCJPO ERAISCJPO
FIELD_IDENTIFIER GMSP GMSP
HFXMFGDPYITKELPCRY HFXMFGDPYITKELPCRY ( )
<operator>.fieldAccess OGEJEPG . CEGGNXUQWNLSUHQFLDHF
FIELD_IDENTIFIER CEGGNXUQWNLSUHQFLDHF CEGGNXUQWNLSUHQFLDHF
<operator>.fieldAccess OGEJEPG . CEGGNXUQWNLSUHQFLDHF
FIELD_IDENTIFIER CEGGNXUQWNLSUHQFLDHF CEGGNXUQWNLSUHQFLDHF
>>>PDG&113 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->46 0->47 0->49 0->50 0->51 0->55 0->56 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->74 0->75 0->76 0->77 0->78 0->79 0->81 0->83 0->84 0->85 0->86 2->11 2->37 3->11 3->12 3->37 4->1 4->21 5->1 5->1 5->64 5->72 6->1 6->21 7->1 7->1 7->1 7->22 8->1 8->1 8->22 8->70 9->1 9->1 9->22 10->1 10->1 10->22 11->1 11->1 11->1 11->19 11->22 11->35 11->36 11->37 11->37 12->1 12->1 12->22 12->36 12->37 13->1 13->1 14->1 14->1 14->15 15->1 15->1 16->1 16->1 17->1 18->1 18->1 18->1 18->18 18->29 18->30 18->37 18->39 18->41 18->43 18->46 18->56 18->62 18->91 18->92 18->95 18->96 19->1 19->23 19->24 19->35 19->35 19->47 21->1 21->1 21->1 21->22 21->26 21->27 21->28 21->50 21->51 21->52 21->53 21->54 21->55 21->58 21->59 21->60 21->61 21->67 21->68 21->68 21->70 21->71 21->73 21->87 21->88 21->89 21->90 21->93 21->94 21->97 21->98 21->99 21->100 21->101 21->102 21->103 21->104 21->105 21->106 21->107 22->1 22->1 22->1 22->1 22->1 22->17 23->1 23->1 24->1 24->1 24->49 24->69 25->1 26->1 26->1 26->51 27->1 27->1 27->1 27->22 28->1 28->1 28->22 29->1 29->1 29->18 30->18 32->1 32->48 32->57 32->64 32->72 33->1 33->1 33->49 33->65 33->66 35->1 35->22 35->22 35->36 36->1 36->1 37->1 37->1 37->18 37->18 37->18 37->18 37->18 37->19 37->22 37->29 37->29 37->29 37->29 37->29 37->36 37->83 39->1 39->1 39->21 41->1 41->1 41->21 43->1 43->1 43->1 43->22 45->1 45->1 45->1 46->1 46->1 46->24 46->49 46->69 47->23 48->1 48->1 48->33 49->1 49->1 49->1 49->1 49->1 49->69 50->26 51->1 51->27 51->27 51->61 51->70 52->1 52->1 52->59 53->1 53->1 53->73 54->1 54->1 54->28 55->1 56->1 56->63 56->74 56->108 57->1 57->1 57->33 58->1 58->51 59->1 59->69 59->70 59->75 59->76 60->1 60->1 60->1 60->22 61->1 61->1 61->28 62->43 63->1 63->1 63->1 63->64 63->72 64->1 64->48 64->66 65->49 66->1 66->49 67->1 67->1 67->58 67->58 68->1 68->52 68->76 69->1 69->1 69->1 69->1 70->1 70->1 70->1 70->53 70->53 70->53 70->53 70->53 70->55 70->71 71->1 71->1 71->54 71->54 72->1 72->57 72->66 73->1 73->22 73->71 74->1 74->1 74->78 74->80 74->81 74->82 74->83 74->85 74->109 74->110 74->111 74->112 75->69 76->1 76->69 78->1 78->1 78->1 78->64 78->72 80->1 80->1 80->82 81->1 81->1 82->1 82->1 82->22 82->84 82->86 83->1 83->37 83->80 83->80 83->80 84->1 84->1 84->1 84->49 85->81 86->84
>>>Token int main ( int argc , char * * argv ) { char const * DTSKBAUWCATRVL = NULL ; int URYO ; char const * XLPOYNOU = NULL ; struct SISNRVHKIJMGI OGEJEPG ; OGEJEPG . VRUTDMKCAAYUKRICPSOAEB = NULL ; OGEJEPG . GMSP = QCTJISBDO ; OGEJEPG . ERAISCJPO = 0 ; OGEJEPG . BYQSTHUXICKBTDFPMNKNSATL = NULL ; OGEJEPG . CEGGNXUQWNLSUHQFLDHF = NULL ; HOWTFIKXKGLMLTU ( & argc , & argv ) ; BSPSRDELXNEDYIMG ( argv [ 0 ] ) ; PCELHMVHW ( FVLSRG , " " ) ; TKXOFDVQBJUGJD ( VPSAVHJ , IDSHIOUBH ) ; DXTDMYGIRH ( VPSAVHJ ) ; UNQGSO ( XOOUVXFBQPMI ) ; while ( ( URYO = KNRQNNTBNBL ( argc , argv , " " , FKIUDOOR , NULL ) ) != - 1 ) { switch ( URYO ) { case ' ' : OGEJEPG . VRUTDMKCAAYUKRICPSOAEB = NFGIBGPCAFOKS ; break ; case ' ' : DTSKBAUWCATRVL = FCJUPF ; break ; case ' ' : OGEJEPG . BYQSTHUXICKBTDFPMNKNSATL = _ ( " " ) ; break ; case ' ' : if ( XFGKNTSIWKYPXEXI ( ) ) { XLPOYNOU = FCJUPF ; } else if ( HFXMFGDPYITKELPCRY ( ) > 0 ) { if ( FCJUPF ) XLPOYNOU = FCJUPF ; else { OGEJEPG . CEGGNXUQWNLSUHQFLDHF = OHSKPPWRHUVG ( FGNFSSLVKMHGWNRP , NULL , 0 ) ; if ( ! OGEJEPG . CEGGNXUQWNLSUHQFLDHF ) RLOHS ( 0 , JTLBQ , _ ( " " ) ) ; } } else if ( FCJUPF ) { RLOHS ( 0 , 0 , _ ( " " " " ) ) ; } break ; DJNBRSHFAAAMYMBGSYTMO ; LYFUTOOFPHKBUMSPVAQWAFXM ( GEHHXUVLVDHR , TXXMGKN ) ; default : DWJTT ( EXIT_FAILURE ) ; } } if ( JMSMRQ == argc ) { RLOHS ( 0 , 0 , _ ( " " ) ) ; DWJTT ( EXIT_FAILURE ) ; } if ( XLPOYNOU ) { int BAW = 0 ; if ( XFGKNTSIWKYPXEXI ( ) ) BAW = JIWGGICKRTEQTSYFHCESVAEK ( XLPOYNOU ) ; else BAW = UQCNSDKCNHKTSM ( XLPOYNOU ) ; if ( BAW < 0 ) EKI ( EXIT_FAILURE , JTLBQ , _ ( " " ) , LDFEC ( XLPOYNOU ) ) ; } if ( OGEJEPG . VRUTDMKCAAYUKRICPSOAEB || DTSKBAUWCATRVL ) { MNHQID RNQMESBYXND = LXNIQ ( 0 ) ; OGEJEPG . CODLAJSHNFWUVG = RNQMESBYXND & ~ ( BPVRFAM | IALVDYT ) ; if ( DTSKBAUWCATRVL ) { struct THMVYSJBCCI * PHILGQ = OVMGDOSLQGKU ( DTSKBAUWCATRVL ) ; if ( ! PHILGQ ) EKI ( EXIT_FAILURE , 0 , _ ( " " ) , LDFEC ( DTSKBAUWCATRVL ) ) ; OGEJEPG . GMSP = GGQPVMOOWQS ( QCTJISBDO , true , RNQMESBYXND , PHILGQ , & OGEJEPG . ERAISCJPO ) ; OGEJEPG . YBKHLVNCKL = RNQMESBYXND & ~ OGEJEPG . GMSP ; free ( PHILGQ ) ; } else { OGEJEPG . GMSP = QCTJISBDO ; OGEJEPG . YBKHLVNCKL = RNQMESBYXND ; } LXNIQ ( OGEJEPG . YBKHLVNCKL ) ; } return QSPGMDYSNVBUMRSAIHWB ( argc - JMSMRQ , argv + JMSMRQ , AXDKHQJWVVJ , & OGEJEPG ) ; }
>>>Func
METHOD IESFUQYUDAX
METHOD_RETURN int
PARAM char * YDUR
PARAM void * MGD
<operator>.assignment * a = MGD
RETURN return VTWDOCXFE ( a -> UJGSKJQ , a -> DXYGMQ , YDUR ) ; return VTWDOCXFE ( a -> UJGSKJQ , a -> DXYGMQ , YDUR ) ;
VTWDOCXFE VTWDOCXFE ( a -> UJGSKJQ , a -> DXYGMQ , YDUR )
>>>PDG&7 0->2 0->3 0->4 0->6 2->6 3->4 4->1 4->1 4->1 5->1 6->1 6->1 6->1 6->1 6->5
>>>Token static int IESFUQYUDAX ( char * YDUR , void * MGD ) { struct MPRATFVNGGL * a = MGD ; return VTWDOCXFE ( a -> UJGSKJQ , a -> DXYGMQ , YDUR ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
OLUJC OLUJC ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan k < T
<operator>.postIncrement k ++
LITERAL 0 return 0 ;
<operator>.assignment k = 0
OLUJC OLUJC ( "%d" , & C )
OLUJC OLUJC ( "%d" , & D )
OLUJC OLUJC ( "%d " , & N )
<operator>.assignment CTV = 0
printf printf ( "Case #%d: [" , k + 1 )
<operator>.lessThan i < DYMON
<operator>.postIncrement i ++
<operator>.lessThan i < DYMON
<operator>.postIncrement i ++
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < CTV - 1
<operator>.postIncrement i ++
<operator>.equals CTV == 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment DOPDAO [ i ] = 0
<operator>.assignment i = 0
OLUJC OLUJC ( " %c%c%c" , & c1 , & c2 , & c3 )
<operator>.assignment n1 = LDXASDDHH ( c1 )
<operator>.assignment n2 = LDXASDDHH ( c2 )
<operator>.assignment PGTKRNMXCXU [ n1 ] [ n2 ] = c3
<operator>.assignment PGTKRNMXCXU [ n2 ] [ n1 ] = c3
<operator>.assignment i = 0
OLUJC OLUJC ( " %c%c" , & c1 , & c2 )
<operator>.assignment n1 = LDXASDDHH ( c1 )
<operator>.assignment n2 = LDXASDDHH ( c2 )
<operator>.assignment IVGTBNM [ n1 ] [ n2 ] = 42
<operator>.assignment IVGTBNM [ n2 ] [ n1 ] = 42
<operator>.assignment i = 0
OLUJC OLUJC ( "%c" , & XBUL [ CTV ++ ] )
<operator>.assignment RFR = LDXASDDHH ( XBUL [ CTV - 1 ] )
<operator>.postIncrement DOPDAO [ RFR ] ++
<operator>.addition k + 1
<operator>.assignment i = 0
printf printf ( "%c, " , XBUL [ i ] )
printf printf ( "]\n" )
<operator>.lessThan j < DYMON
<operator>.postIncrement j ++
<operator>.greaterThan CTV > 1
<operator>.subtraction CTV - 1
printf printf ( "%c]\n" , XBUL [ CTV - 1 ] )
<operator>.assignment j = 0
<operator>.assignment IVGTBNM [ i ] [ j ] = 0
<operator>.assignment PGTKRNMXCXU [ i ] [ j ] = 0
LDXASDDHH LDXASDDHH ( c1 )
LDXASDDHH LDXASDDHH ( c2 )
LDXASDDHH LDXASDDHH ( c1 )
LDXASDDHH LDXASDDHH ( c2 )
LDXASDDHH LDXASDDHH ( XBUL [ CTV - 1 ] )
<operator>.assignment c = PGTKRNMXCXU [ RFR ] [ LDXASDDHH ( XBUL [ CTV - 2 ] ) ]
<operator>.postIncrement CTV ++
<operator>.subtraction CTV - 1
<operator>.postDecrement DOPDAO [ RFR ] --
<operator>.postDecrement DOPDAO [ LDXASDDHH ( XBUL [ CTV - 2 ] ) ] --
<operator>.assignmentMinus CTV -= 2
<operator>.assignment XBUL [ CTV ++ ] = c
<operator>.subtraction CTV - 1
LDXASDDHH LDXASDDHH ( XBUL [ CTV - 2 ] )
<operator>.lessThan j < DYMON
<operator>.postIncrement j ++
LDXASDDHH LDXASDDHH ( XBUL [ CTV - 2 ] )
<operator>.postIncrement CTV ++
<operator>.assignment j = 0
<operator>.subtraction CTV - 2
<operator>.logicalAnd IVGTBNM [ RFR ] [ j ] && DOPDAO [ j ]
<operator>.subtraction CTV - 2
<operator>.assignment CTV = 0
<operator>.lessThan l < DYMON
<operator>.postIncrement l ++
<operator>.assignment l = 0
<operator>.assignment DOPDAO [ l ] = 0
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.indirectIndexAccess DOPDAO [ i ]
<operator>.addressOf & c1
<operator>.addressOf & c2
<operator>.addressOf & c3
<operator>.indirectIndexAccess PGTKRNMXCXU [ n1 ] [ n2 ]
<operator>.indirectIndexAccess PGTKRNMXCXU [ n2 ] [ n1 ]
<operator>.addressOf & c1
<operator>.addressOf & c2
<operator>.indirectIndexAccess IVGTBNM [ n1 ] [ n2 ]
<operator>.indirectIndexAccess IVGTBNM [ n2 ] [ n1 ]
<operator>.addressOf & XBUL [ CTV ++ ]
<operator>.indirectIndexAccess DOPDAO [ RFR ]
<operator>.indirectIndexAccess XBUL [ i ]
<operator>.indirectIndexAccess PGTKRNMXCXU [ n1 ]
<operator>.indirectIndexAccess PGTKRNMXCXU [ n2 ]
<operator>.indirectIndexAccess IVGTBNM [ n1 ]
<operator>.indirectIndexAccess IVGTBNM [ n2 ]
<operator>.indirectIndexAccess XBUL [ CTV ++ ]
<operator>.indirectIndexAccess XBUL [ CTV - 1 ]
<operator>.indirectIndexAccess XBUL [ CTV - 1 ]
<operator>.indirectIndexAccess IVGTBNM [ i ] [ j ]
<operator>.indirectIndexAccess PGTKRNMXCXU [ i ] [ j ]
<operator>.indirectIndexAccess IVGTBNM [ i ]
<operator>.indirectIndexAccess PGTKRNMXCXU [ i ]
<operator>.indirectIndexAccess PGTKRNMXCXU [ RFR ] [ LDXASDDHH ( XBUL [ CTV - 2 ] ) ]
<operator>.indirectIndexAccess PGTKRNMXCXU [ RFR ]
<operator>.indirectIndexAccess DOPDAO [ RFR ]
<operator>.indirectIndexAccess DOPDAO [ LDXASDDHH ( XBUL [ CTV - 2 ] ) ]
<operator>.indirectIndexAccess XBUL [ CTV ++ ]
<operator>.indirectIndexAccess XBUL [ CTV - 2 ]
<operator>.indirectIndexAccess XBUL [ CTV - 2 ]
<operator>.indirectIndexAccess IVGTBNM [ RFR ] [ j ]
<operator>.indirectIndexAccess DOPDAO [ j ]
<operator>.indirectIndexAccess IVGTBNM [ RFR ]
<operator>.indirectIndexAccess DOPDAO [ l ]
>>>PDG&124 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->35 0->36 0->37 0->38 0->41 0->42 0->43 0->44 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->65 0->66 0->69 0->70 0->71 0->73 0->74 0->76 0->77 0->78 0->80 0->81 0->82 0->83 0->84 0->85 2->1 3->1 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->11 6->12 6->13 6->14 6->14 6->15 6->17 6->19 6->21 6->23 6->25 6->27 6->28 6->29 6->31 6->37 6->43 6->47 6->47 6->48 6->54 6->86 6->87 6->88 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->19 11->1 11->1 11->21 12->1 12->1 12->23 13->1 13->54 13->65 14->1 14->1 15->15 15->16 15->16 15->17 15->51 15->51 15->56 16->1 16->15 17->1 17->1 17->15 17->17 17->18 17->18 17->30 17->73 17->89 18->1 18->17 19->1 19->1 19->10 19->19 19->20 19->20 19->32 19->33 19->34 19->35 19->36 19->59 19->60 19->90 19->91 19->92 19->93 19->94 19->102 19->103 20->1 20->19 21->1 21->1 21->11 21->21 21->22 21->22 21->38 21->39 21->40 21->41 21->42 21->61 21->62 21->95 21->96 21->97 21->98 21->104 21->105 22->1 22->21 23->1 23->1 23->12 23->23 23->24 23->24 23->44 23->45 23->46 23->53 23->63 23->65 23->66 23->99 23->100 23->106 23->107 24->1 24->23 25->1 25->1 25->1 25->25 25->26 25->26 25->49 25->54 25->101 26->1 26->25 27->1 27->1 27->50 27->55 27->71 27->71 27->108 28->15 29->17 30->1 30->1 31->19 32->1 32->1 32->1 32->1 32->35 32->36 32->38 32->38 32->59 32->60 32->61 32->62 33->1 33->1 33->1 34->1 34->1 34->1 35->1 35->1 36->1 36->1 36->1 37->21 38->1 38->1 38->1 38->32 38->32 38->59 38->60 38->61 38->62 39->1 39->1 39->1 40->1 40->1 40->1 41->1 41->1 42->1 42->1 43->23 44->1 44->1 45->1 45->1 45->1 46->1 46->1 46->67 48->1 48->25 49->1 49->1 50->1 51->1 51->1 51->15 51->51 51->52 51->52 51->57 51->58 51->109 51->110 51->111 51->112 52->1 52->51 53->1 53->54 53->64 53->65 53->72 53->78 53->78 53->113 53->114 53->118 54->25 54->25 54->27 55->1 55->1 55->63 56->1 56->51 57->1 57->1 58->1 58->1 59->1 59->32 59->33 59->38 59->61 60->1 60->32 60->34 60->38 60->62 61->1 61->32 61->38 61->39 61->59 62->1 62->32 62->38 62->40 62->60 63->1 63->45 63->55 64->1 64->1 64->1 64->67 64->68 64->69 64->70 64->70 64->73 64->75 64->76 64->77 64->80 64->115 64->116 64->117 64->119 65->66 66->53 67->1 67->1 67->46 68->1 68->1 69->1 69->76 70->1 70->1 70->1 70->44 71->1 72->1 72->75 73->1 73->1 73->1 73->15 73->74 73->79 73->82 73->120 73->122 74->1 74->73 75->1 75->72 76->54 76->65 77->1 77->73 78->54 78->65 78->80 79->1 79->1 79->1 79->73 79->74 79->81 79->82 79->84 80->69 81->1 81->54 81->65 82->1 82->1 82->1 82->15 82->73 82->82 82->83 82->83 82->85 82->123 83->1 83->82 84->1 84->82 85->1 85->1 120->121
>>>Token int main ( int argc , char * * argv ) { int T , C , D , N ; OLUJC ( " " , & T ) ; int i , j , k , l ; int DOPDAO [ DYMON ] ; for ( k = 0 ; k < T ; k ++ ) { for ( i = 0 ; i < DYMON ; i ++ ) { for ( j = 0 ; j < DYMON ; j ++ ) { IVGTBNM [ i ] [ j ] = 0 ; PGTKRNMXCXU [ i ] [ j ] = 0 ; } } for ( i = 0 ; i < DYMON ; i ++ ) { DOPDAO [ i ] = 0 ; } OLUJC ( " " , & C ) ; char c1 , c2 , c3 ; for ( i = 0 ; i < C ; i ++ ) { OLUJC ( " " , & c1 , & c2 , & c3 ) ; int n1 = LDXASDDHH ( c1 ) ; int n2 = LDXASDDHH ( c2 ) ; PGTKRNMXCXU [ n1 ] [ n2 ] = c3 ; PGTKRNMXCXU [ n2 ] [ n1 ] = c3 ; } OLUJC ( " " , & D ) ; for ( i = 0 ; i < D ; i ++ ) { OLUJC ( " " , & c1 , & c2 ) ; int n1 = LDXASDDHH ( c1 ) ; int n2 = LDXASDDHH ( c2 ) ; IVGTBNM [ n1 ] [ n2 ] = 42 ; IVGTBNM [ n2 ] [ n1 ] = 42 ; } OLUJC ( " " , & N ) ; int CTV = 0 ; char c ; int RFR ; for ( i = 0 ; i < N ; i ++ ) { OLUJC ( " " , & XBUL [ CTV ++ ] ) ; RFR = LDXASDDHH ( XBUL [ CTV - 1 ] ) ; DOPDAO [ RFR ] ++ ; if ( CTV > 1 ) { if ( ( c = PGTKRNMXCXU [ RFR ] [ LDXASDDHH ( XBUL [ CTV - 2 ] ) ] ) ) { DOPDAO [ RFR ] -- ; DOPDAO [ LDXASDDHH ( XBUL [ CTV - 2 ] ) ] -- ; CTV -= 2 ; XBUL [ CTV ++ ] = c ; } else { for ( j = 0 ; j < DYMON ; j ++ ) { if ( IVGTBNM [ RFR ] [ j ] && DOPDAO [ j ] ) { CTV = 0 ; for ( l = 0 ; l < DYMON ; l ++ ) { DOPDAO [ l ] = 0 ; } break ; } } } } } printf ( " " , k + 1 ) ; for ( i = 0 ; i < CTV - 1 ; i ++ ) { printf ( " " , XBUL [ i ] ) ; } if ( CTV == 0 ) printf ( " \n " ) ; else printf ( " \n " , XBUL [ CTV - 1 ] ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
ROAEWUK ROAEWUK ( "A-small-attempt0.in" , "r" , stdin )
ROAEWUK ROAEWUK ( "A-small-attempt0.out" , "w" , JIJVGE )
DQFPA DQFPA ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= T
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 1
printf printf ( "Case #%d:" , t )
DQFPA DQFPA ( "\n%d" , & N )
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan t < T
<operator>.assignment i = 0
DQFPA DQFPA ( "\n" )
<operator>.assignment i = 0
<operator>.assignment WLUE [ i ] = PCXWGMIOLRQ [ i ] = 0
<operator>.assignment WP [ i ] = ( ( double ) WLUE [ i ] ) / ( ( double ) PCXWGMIOLRQ [ i ] )
<operator>.assignment i = 0
<operator>.assignment MCG [ i ] = 0
<operator>.assignmentDivision MCG [ i ] /= ( ( double ) ( PCXWGMIOLRQ [ i ] ) )
<operator>.assignment i = 0
<operator>.assignment WFCH [ i ] = 0
<operator>.assignmentDivision WFCH [ i ] /= ( ( double ) ( PCXWGMIOLRQ [ i ] ) )
<operator>.assignment YRI [ i ] = 0.25000000 * WP [ i ] + 0.50000000 * MCG [ i ] + 0.25000000 * WFCH [ i ]
printf printf ( "\n%0.12lf" , YRI [ i ] )
printf printf ( "\n" )
<operator>.lessThan j < N
<operator>.postIncrement j ++
DQFPA DQFPA ( "%c" , & WJCAERPN [ i ] [ j ] )
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment PCXWGMIOLRQ [ i ] = 0
<operator>.assignment j = 0
<operator>.division ( ( double ) WLUE [ i ] ) / ( ( double ) PCXWGMIOLRQ [ i ] )
<operator>.assignment j = 0
<operator>.assignment KOOP = ( ( double ) ( WLUE [ j ] - ( WJCAERPN [ j ] [ i ] - '0' ) ) ) / ( ( double ) ( PCXWGMIOLRQ [ j ] - 1 ) )
<operator>.assignmentPlus MCG [ i ] += KOOP
<operator>.cast ( double ) ( PCXWGMIOLRQ [ i ] )
<operator>.assignment j = 0
<operator>.assignmentPlus WFCH [ i ] += MCG [ j ]
<operator>.cast ( double ) ( PCXWGMIOLRQ [ i ] )
<operator>.addition 0.25000000 * WP [ i ] + 0.50000000 * MCG [ i ] + 0.25000000 * WFCH [ i ]
<operator>.equals i == j
<operator>.notEquals WJCAERPN [ i ] [ j ] != '.'
<operator>.equals WJCAERPN [ i ] [ j ] == '1'
<operator>.cast ( double ) WLUE [ i ]
<operator>.cast ( double ) PCXWGMIOLRQ [ i ]
<operator>.logicalOr i == j || WJCAERPN [ i ] [ j ] == '.'
<operator>.logicalOr i == j || WJCAERPN [ i ] [ j ] == '.'
<operator>.addition 0.25000000 * WP [ i ] + 0.50000000 * MCG [ i ]
<operator>.multiplication 0.25000000 * WFCH [ i ]
<operator>.postIncrement PCXWGMIOLRQ [ i ] ++
<operator>.postIncrement WLUE [ i ] ++
<operator>.division ( ( double ) ( WLUE [ j ] - ( WJCAERPN [ j ] [ i ] - '0' ) ) ) / ( ( double ) ( PCXWGMIOLRQ [ j ] - 1 ) )
<operator>.multiplication 0.25000000 * WP [ i ]
<operator>.multiplication 0.50000000 * MCG [ i ]
<operator>.equals i == j
<operator>.equals WJCAERPN [ i ] [ j ] == '.'
<operator>.cast ( double ) ( WLUE [ j ] - ( WJCAERPN [ j ] [ i ] - '0' ) )
<operator>.cast ( double ) ( PCXWGMIOLRQ [ j ] - 1 )
<operator>.equals i == j
<operator>.equals WJCAERPN [ i ] [ j ] == '.'
<operator>.subtraction WLUE [ j ] - ( WJCAERPN [ j ] [ i ] - '0' )
<operator>.subtraction PCXWGMIOLRQ [ j ] - 1
<operator>.subtraction WJCAERPN [ j ] [ i ] - '0'
<operator>.addressOf & N
<operator>.indirectIndexAccess WLUE [ i ]
<operator>.indirectIndexAccess WP [ i ]
<operator>.indirectIndexAccess MCG [ i ]
<operator>.indirectIndexAccess MCG [ i ]
<operator>.indirectIndexAccess WFCH [ i ]
<operator>.indirectIndexAccess WFCH [ i ]
<operator>.indirectIndexAccess YRI [ i ]
<operator>.indirectIndexAccess YRI [ i ]
<operator>.addressOf & WJCAERPN [ i ] [ j ]
<operator>.indirectIndexAccess PCXWGMIOLRQ [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess PCXWGMIOLRQ [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess PCXWGMIOLRQ [ i ]
<operator>.indirectIndexAccess WJCAERPN [ i ] [ j ]
UNKNOWN double double
<operator>.indirectIndexAccess WLUE [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess PCXWGMIOLRQ [ i ]
<operator>.indirectIndexAccess MCG [ i ]
<operator>.indirectIndexAccess WFCH [ i ]
<operator>.indirectIndexAccess MCG [ j ]
<operator>.indirectIndexAccess WFCH [ i ]
<operator>.indirectIndexAccess WJCAERPN [ i ]
<operator>.indirectIndexAccess WJCAERPN [ i ] [ j ]
<operator>.indirectIndexAccess WJCAERPN [ i ] [ j ]
<operator>.indirectIndexAccess WP [ i ]
<operator>.indirectIndexAccess MCG [ i ]
<operator>.indirectIndexAccess WJCAERPN [ i ]
<operator>.indirectIndexAccess PCXWGMIOLRQ [ i ]
<operator>.indirectIndexAccess WJCAERPN [ i ]
<operator>.indirectIndexAccess WLUE [ i ]
<operator>.indirectIndexAccess WJCAERPN [ i ] [ j ]
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess WJCAERPN [ i ] [ j ]
<operator>.indirectIndexAccess WJCAERPN [ i ]
<operator>.indirectIndexAccess WLUE [ j ]
<operator>.indirectIndexAccess PCXWGMIOLRQ [ j ]
<operator>.indirectIndexAccess WJCAERPN [ i ]
<operator>.indirectIndexAccess WJCAERPN [ j ] [ i ]
<operator>.indirectIndexAccess WJCAERPN [ j ]
>>>PDG&122 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->26 0->27 0->29 0->30 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->48 0->50 0->52 0->56 0->57 0->58 0->64 0->68 0->69 0->70 0->71 0->74 0->75 0->77 0->78 2->1 2->1 3->1 3->1 4->1 4->1 4->6 4->20 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->10 6->11 6->12 6->14 6->16 6->18 6->20 6->20 6->21 6->23 6->26 6->29 6->79 7->1 7->6 8->5 9->1 9->6 10->1 10->20 11->1 11->1 11->12 11->14 11->16 11->18 11->35 11->38 11->40 11->42 12->12 12->13 12->13 12->14 12->22 12->35 12->35 12->44 13->1 13->12 14->14 14->15 14->15 14->16 14->24 14->25 14->38 14->38 14->45 14->46 14->47 14->56 14->59 14->60 14->80 14->81 14->89 14->95 14->96 14->97 14->98 15->1 15->14 16->16 16->17 16->17 16->18 16->27 16->28 16->40 16->40 16->48 16->51 16->70 16->82 16->83 16->90 16->91 17->1 17->16 18->1 18->1 18->1 18->11 18->12 18->18 18->19 18->19 18->30 18->31 18->32 18->33 18->42 18->42 18->52 18->54 18->55 18->63 18->64 18->68 18->69 18->74 18->84 18->85 18->86 18->87 18->92 18->93 18->102 18->106 18->107 19->1 19->18 20->1 20->6 20->7 20->34 21->12 22->1 23->14 24->1 24->1 24->47 24->59 24->66 25->1 25->1 25->1 25->68 26->16 27->1 27->28 27->50 28->1 28->1 28->1 28->69 29->1 29->18 30->1 30->31 30->53 31->1 31->1 31->64 32->1 32->1 32->33 33->1 33->1 34->1 35->1 35->1 35->12 35->35 35->36 35->36 35->37 35->88 35->94 35->103 36->1 36->35 37->1 37->1 37->57 37->58 37->71 37->75 38->1 38->1 38->14 38->38 38->39 38->56 38->56 39->1 39->38 40->1 40->1 40->16 40->40 40->41 40->61 40->70 40->70 41->1 41->40 42->1 42->1 42->18 42->42 42->43 42->62 42->74 42->74 43->1 43->42 44->1 44->35 45->24 45->28 45->31 45->47 45->51 45->54 45->60 45->65 46->1 46->38 47->1 47->1 47->25 47->25 48->1 48->40 49->1 49->1 49->50 50->1 50->1 50->28 51->1 52->1 52->42 53->1 53->1 53->31 54->1 55->1 55->1 56->1 56->15 56->39 56->57 56->58 56->104 56->105 56->108 56->110 57->1 57->58 57->65 57->109 58->1 58->1 58->37 58->57 58->66 58->71 58->75 58->111 59->1 60->1 61->1 61->1 61->1 61->49 61->50 61->62 61->67 61->72 61->73 61->76 61->77 61->78 61->99 61->113 61->114 61->117 61->118 61->120 61->121 62->1 62->1 62->1 62->53 62->61 62->100 62->101 63->1 63->1 64->1 64->32 64->32 64->55 64->55 65->1 65->28 65->31 65->47 65->51 65->54 65->60 66->1 66->47 66->59 67->1 67->1 67->49 67->49 68->1 68->32 68->32 68->55 68->55 68->63 68->63 69->1 69->32 69->32 69->55 69->55 69->63 69->63 70->17 70->41 70->61 70->61 70->71 70->112 70->116 71->1 71->37 71->57 71->61 71->61 71->75 72->1 73->1 74->19 74->43 74->62 74->62 74->75 74->115 74->119 75->1 75->37 75->57 75->62 75->62 75->71 76->1 76->1 76->67 76->67 76->72 76->72 77->1 77->67 77->67 77->73 77->73 78->1 78->76 78->76
>>>Token int main ( ) { ROAEWUK ( " " , " " , stdin ) ; ROAEWUK ( " " , " " , JIJVGE ) ; int T , i , j , t , OLG , N ; char WJCAERPN [ 101 ] [ 101 ] ; double WP [ 101 ] , MCG [ 101 ] , WFCH [ 101 ] , YRI [ 101 ] ; DQFPA ( " " , & T ) ; for ( t = 1 ; t <= T ; t ++ ) { printf ( " " , t ) ; DQFPA ( " \n " , & N ) ; for ( i = 0 ; i < N ; i ++ ) { DQFPA ( " \n " ) ; for ( j = 0 ; j < N ; j ++ ) DQFPA ( " " , & WJCAERPN [ i ] [ j ] ) ; } int PCXWGMIOLRQ [ NVKDMAGS ] , WLUE [ NVKDMAGS ] ; for ( i = 0 ; i < N ; i ++ ) { WLUE [ i ] = PCXWGMIOLRQ [ i ] = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; if ( WJCAERPN [ i ] [ j ] != ' ' ) PCXWGMIOLRQ [ i ] ++ ; if ( WJCAERPN [ i ] [ j ] == ' ' ) WLUE [ i ] ++ ; } WP [ i ] = ( ( double ) WLUE [ i ] ) / ( ( double ) PCXWGMIOLRQ [ i ] ) ; } double KOOP , FVFHMH [ NVKDMAGS ] ; for ( i = 0 ; i < N ; i ++ ) { MCG [ i ] = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( i == j || WJCAERPN [ i ] [ j ] == ' ' ) continue ; KOOP = ( ( double ) ( WLUE [ j ] - ( WJCAERPN [ j ] [ i ] - ' ' ) ) ) / ( ( double ) ( PCXWGMIOLRQ [ j ] - 1 ) ) ; MCG [ i ] += KOOP ; } MCG [ i ] /= ( ( double ) ( PCXWGMIOLRQ [ i ] ) ) ; } for ( i = 0 ; i < N ; i ++ ) { WFCH [ i ] = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( i == j || WJCAERPN [ i ] [ j ] == ' ' ) continue ; WFCH [ i ] += MCG [ j ] ; } WFCH [ i ] /= ( ( double ) ( PCXWGMIOLRQ [ i ] ) ) ; YRI [ i ] = 0.25000000 * WP [ i ] + 0.50000000 * MCG [ i ] + 0.25000000 * WFCH [ i ] ; printf ( " \n " , YRI [ i ] ) ; } if ( t < T ) printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD SKK
METHOD_RETURN void
PARAM int * a
PARAM int * b
<operator>.logicalAnd ! ( * a % 2 ) && ! ( * b % 2 )
<operator>.logicalAnd ! ( * a % 5 ) && ! ( * b % 5 )
<operator>.assignmentDivision * a /= 2
<operator>.assignmentDivision * b /= 2
<operator>.assignmentDivision * a /= 5
<operator>.assignmentDivision * b /= 5
<operator>.logicalNot ! ( * a % 2 )
<operator>.logicalNot ! ( * b % 2 )
<operator>.logicalNot ! ( * a % 5 )
<operator>.logicalNot ! ( * b % 5 )
<operator>.modulo * a % 2
<operator>.modulo * b % 2
<operator>.modulo * a % 5
<operator>.modulo * b % 5
<operator>.indirection * a
<operator>.indirection * b
<operator>.indirection * a
<operator>.indirection * b
<operator>.indirection * a
<operator>.indirection * b
<operator>.indirection * a
<operator>.indirection * b
>>>PDG&26 0->2 0->3 0->6 0->7 0->8 0->9 0->14 0->15 0->16 0->17 2->1 3->1 4->1 4->1 4->1 4->4 4->6 4->7 4->10 4->14 4->18 4->19 4->22 5->1 5->1 5->1 5->5 5->8 5->9 5->12 5->16 5->20 5->21 5->24 8->16 9->1 9->1 9->17 10->1 10->4 10->11 10->15 10->23 11->1 11->4 12->1 12->5 12->13 12->17 12->25 13->1 13->5 14->6 14->10 14->10 14->16 15->1 15->7 15->9 15->11 15->11 15->17 16->1 16->8 16->12 16->12 17->1 17->9 17->13 17->13
>>>Token void SKK ( int * a , int * b ) { while ( ! ( * a % 2 ) && ! ( * b % 2 ) ) { * a /= 2 ; * b /= 2 ; } while ( ! ( * a % 5 ) && ! ( * b % 5 ) ) { * a /= 5 ; * b /= 5 ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment UGGC = 0
EJPUH EJPUH ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.postDecrement T --
LITERAL 0 return 0 ;
<operator>.assignment UNECB = 0
<operator>.assignment LYT = 1000000000000.0
EJPUH EJPUH ( "%d %d" , & ps , & AER )
<operator>.assignment MOMJ = ( double ) AER
YCAQY YCAQY ( XKL   ps   sizeof ( hd ) , PWCSJQF )
printf printf ( "Case #%d: %.12f\n" , ++ UGGC , LYT )
<operator>.lessThan i < ps
<operator>.postIncrement i ++
<operator>.lessThan k < 2 * ( double ) XKL [ ps - 1 ] . AFRGJ
<operator>.assignmentPlus k += 0.5
<operator>.cast ( double ) AER
<operator>.assignment i = 0
EJPUH EJPUH ( "%d %d" , & XKL [ i ] . AFRGJ , & XKL [ i ] . XPBU )
<operator>.assignmentPlus UNECB += XKL [ i ] . XPBU
<operator>.sizeOf sizeof ( hd )
<operator>.assignment k = ( double ) XKL [ 0 ] . AFRGJ - ( double ) UNECB * MOMJ
<operator>.assignment GGJ = 0
<operator>.assignment l = 0
<operator>.preIncrement ++ UGGC
<operator>.multiplication 2 * ( double ) XKL [ ps - 1 ] . AFRGJ
<operator>.lessThan i < ps
<operator>.postIncrement i ++
<operator>.lessThan GGJ < LYT
<operator>.subtraction ( double ) XKL [ 0 ] . AFRGJ - ( double ) UNECB * MOMJ
<operator>.cast ( double ) XKL [ ps - 1 ] . AFRGJ
<operator>.assignment i = 0
<operator>.lessThan j < XKL [ i ] . XPBU
<operator>.expressionList j ++   l += 1
<operator>.assignment LYT = GGJ
<operator>.cast ( double ) XKL [ 0 ] . AFRGJ
<operator>.multiplication ( double ) UNECB * MOMJ
<operator>.assignment j = 0
<operator>.greaterThan UAMH ( ( double ) XKL [ i ] . AFRGJ - ( k + l * MOMJ ) ) > GGJ
<operator>.cast ( double ) UNECB
<operator>.postIncrement j ++
<operator>.assignmentPlus l += 1
<operator>.assignment GGJ = UAMH ( ( double ) XKL [ i ] . AFRGJ - ( k + l * MOMJ ) )
<operator>.subtraction ps - 1
UAMH UAMH ( ( double ) XKL [ i ] . AFRGJ - ( k + l * MOMJ ) )
<operator>.subtraction ( double ) XKL [ i ] . AFRGJ - ( k + l * MOMJ )
UAMH UAMH ( ( double ) XKL [ i ] . AFRGJ - ( k + l * MOMJ ) )
<operator>.cast ( double ) XKL [ i ] . AFRGJ
<operator>.addition k + l * MOMJ
<operator>.subtraction ( double ) XKL [ i ] . AFRGJ - ( k + l * MOMJ )
<operator>.multiplication l * MOMJ
<operator>.cast ( double ) XKL [ i ] . AFRGJ
<operator>.addition k + l * MOMJ
<operator>.multiplication l * MOMJ
<operator>.addressOf & ps
<operator>.addressOf & AER
UNKNOWN double double
<operator>.addressOf & XKL [ i ] . AFRGJ
<operator>.addressOf & XKL [ i ] . XPBU
<operator>.fieldAccess XKL [ i ] . XPBU
<operator>.fieldAccess XKL [ i ] . AFRGJ
<operator>.fieldAccess XKL [ i ] . XPBU
<operator>.indirectIndexAccess XKL [ i ]
FIELD_IDENTIFIER XPBU XPBU
UNKNOWN double double
<operator>.fieldAccess XKL [ ps - 1 ] . AFRGJ
<operator>.indirectIndexAccess XKL [ i ]
FIELD_IDENTIFIER AFRGJ AFRGJ
<operator>.indirectIndexAccess XKL [ i ]
FIELD_IDENTIFIER XPBU XPBU
UNKNOWN double double
<operator>.fieldAccess XKL [ 0 ] . AFRGJ
<operator>.indirectIndexAccess XKL [ ps - 1 ]
FIELD_IDENTIFIER AFRGJ AFRGJ
<operator>.fieldAccess XKL [ i ] . XPBU
<operator>.indirectIndexAccess XKL [ 0 ]
FIELD_IDENTIFIER AFRGJ AFRGJ
UNKNOWN double double
<operator>.indirectIndexAccess XKL [ i ]
FIELD_IDENTIFIER XPBU XPBU
UNKNOWN double double
<operator>.fieldAccess XKL [ i ] . AFRGJ
<operator>.indirectIndexAccess XKL [ i ]
FIELD_IDENTIFIER AFRGJ AFRGJ
UNKNOWN double double
<operator>.fieldAccess XKL [ i ] . AFRGJ
<operator>.indirectIndexAccess XKL [ i ]
FIELD_IDENTIFIER AFRGJ AFRGJ
>>>PDG&89 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->32 0->33 0->34 0->35 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->46 0->49 0->50 0->51 0->53 0->54 2->1 2->1 2->25 3->1 3->1 3->5 4->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->15 5->17 5->18 5->21 5->22 5->25 5->26 5->30 5->31 5->36 5->37 5->40 5->44 5->55 5->56 5->57 5->65 5->66 5->71 5->72 5->73 5->74 5->76 5->77 5->78 6->4 7->1 7->20 7->37 7->40 8->1 8->12 8->29 9->1 9->1 9->1 9->10 9->11 9->13 9->17 9->27 9->44 10->1 10->1 10->37 11->1 11->1 11->1 11->44 12->1 12->1 12->1 13->1 13->1 13->11 13->13 13->14 13->14 13->19 13->20 13->58 13->59 13->60 13->61 13->62 13->63 13->64 13->67 13->68 13->69 13->70 14->1 14->13 15->1 15->1 15->1 15->15 15->16 15->16 15->23 15->24 15->26 15->27 15->29 15->31 15->32 15->44 15->46 15->49 15->65 15->66 15->73 15->74 16->1 16->15 17->1 18->1 18->13 19->1 19->1 19->1 19->20 19->33 19->46 19->48 19->50 19->52 20->1 20->37 20->40 21->1 22->1 22->1 22->15 23->1 23->29 23->39 24->1 24->1 24->51 25->1 25->12 26->1 26->15 26->15 27->1 27->1 27->27 27->28 27->28 27->33 27->38 27->44 27->75 27->79 27->80 28->1 28->27 29->1 29->1 29->12 29->35 29->35 30->1 30->1 30->22 30->22 31->1 32->1 32->27 33->1 33->1 33->33 33->34 33->39 33->41 33->41 33->42 33->45 33->46 33->48 33->49 33->51 33->75 33->79 33->80 33->81 33->82 33->83 33->84 34->1 34->1 34->1 35->1 35->1 35->12 35->29 36->1 37->1 37->1 37->30 37->30 37->51 38->1 38->33 39->1 39->1 39->29 39->43 39->47 39->50 39->52 39->53 39->54 39->85 39->86 39->87 39->88 40->1 41->33 41->34 42->1 42->34 42->51 43->1 43->1 43->29 43->39 44->1 44->9 44->13 44->27 45->1 45->39 46->1 46->1 46->45 46->45 47->1 47->43 49->1 50->1 50->1 50->47 50->47 51->1 51->42 51->46 51->46 51->49 51->49 51->54 51->54 53->1 54->1 54->42 54->50 54->50 54->51 54->53 54->53
>>>Token int main ( ) { int T , UGGC = 0 ; EJPUH ( " " , & T ) ; while ( T -- ) { int ps , AER , UNECB = 0 ; double MOMJ , GGJ , LYT = 1000000000000.0 ; int i , j ; double k , l ; EJPUH ( " " , & ps , & AER ) ; MOMJ = ( double ) AER ; for ( i = 0 ; i < ps ; i ++ ) { EJPUH ( " " , & XKL [ i ] . AFRGJ , & XKL [ i ] . XPBU ) ; UNECB += XKL [ i ] . XPBU ; } YCAQY ( XKL , ps , sizeof ( hd ) , PWCSJQF ) ; for ( k = ( double ) XKL [ 0 ] . AFRGJ - ( double ) UNECB * MOMJ ; k < 2 * ( double ) XKL [ ps - 1 ] . AFRGJ ; k += 0.5 ) { GGJ = 0 ; l = 0 ; for ( i = 0 ; i < ps ; i ++ ) for ( j = 0 ; j < XKL [ i ] . XPBU ; j ++ , l += 1 ) if ( UAMH ( ( double ) XKL [ i ] . AFRGJ - ( k + l * MOMJ ) ) > GGJ ) GGJ = UAMH ( ( double ) XKL [ i ] . AFRGJ - ( k + l * MOMJ ) ) ; if ( GGJ < LYT ) LYT = GGJ ; } printf ( " \n " , ++ UGGC , LYT ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment * p = QCOCW ( "in.in" , "r" )
<operator>.assignment * q = QCOCW ( "out.txt" , "w" )
HIOTKY HIOTKY ( p , "%d" , & TDCG )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < TDCG
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
QCOCW QCOCW ( "in.in" , "r" )
QCOCW QCOCW ( "out.txt" , "w" )
<operator>.assignment i = 0
HIOTKY HIOTKY ( p , "%d" , & AVWY )
HIOTKY HIOTKY ( p , "%d" , & QLIK )
<operator>.assignment k = 0
<operator>.assignment TSKO [ k ] = '\0'
<operator>.assignment j = 0
fprintf fprintf ( q , "Case #%d: [" , i + 1 )
fprintf fprintf ( q , "]\n" )
<operator>.notEquals AVWY != 0
<operator>.notEquals QLIK != 0
HIOTKY HIOTKY ( p , "%d" , & MBIM )
<operator>.lessThan j < MBIM
<operator>.postIncrement j ++
<operator>.equals TSKO [ j ] == '\0'
<operator>.notEquals TSKO [ j ] != '\0'
<operator>.assignment c = JLIEG ( p )
<operator>.assignment j = 0
<operator>.assignment TSKO [ k ] = JDPL [ j ]
<operator>.assignment VPUY = 0
<operator>.assignment LTXE = 0
<operator>.postIncrement k ++
<operator>.addition i + 1
fprintf fprintf ( q , "]\n" )
fprintf fprintf ( q , ", %c" , TSKO [ j ++ ] )
<operator>.lessThan j < AVWY
<operator>.postIncrement j ++
<operator>.lessThan j < QLIK
<operator>.postIncrement j ++
<operator>.lessThan j < MBIM
<operator>.postIncrement j ++
<operator>.lessThan m < k
<operator>.postIncrement m ++
<operator>.equals VPUY == 0
fprintf fprintf ( q , "%c" , TSKO [ j ++ ] )
<operator>.assignment j = 0
<operator>.assignment c = JLIEG ( p )
<operator>.assignment j = 0
<operator>.assignment c = JLIEG ( p )
JLIEG JLIEG ( p )
<operator>.assignment j = 0
<operator>.assignment JDPL [ j ] = JLIEG ( p )
<operator>.assignment m = k - 1
<operator>.equals c == ' '
<operator>.assignment c = JLIEG ( p )
<operator>.lessThan k < 3
<operator>.postIncrement k ++
<operator>.equals c == ' '
<operator>.assignment c = JLIEG ( p )
<operator>.lessThan k < 2
<operator>.postIncrement k ++
<operator>.lessThan n < AVWY
<operator>.postIncrement n ++
<operator>.equals VPUY == 1
<operator>.lessThan m < k
<operator>.postIncrement m ++
<operator>.postIncrement j ++
JLIEG JLIEG ( p )
<operator>.assignment k = 0
<operator>.assignment YJUU [ j ] [ k ] = c
<operator>.assignment c = JLIEG ( p )
JLIEG JLIEG ( p )
<operator>.assignment k = 0
<operator>.assignment FYXW [ j ] [ k ] = c
<operator>.assignment c = JLIEG ( p )
JLIEG JLIEG ( p )
<operator>.subtraction k - 1
<operator>.assignment n = 0
<operator>.assignment m = 0
<operator>.postIncrement j ++
JLIEG JLIEG ( p )
JLIEG JLIEG ( p )
<operator>.logicalOr ( YJUU [ n ] [ 1 ] == TSKO [ k ] && YJUU [ n ] [ 0 ] == TSKO [ m ] ) || ( YJUU [ n ] [ 0 ] == TSKO [ k ] && YJUU [ n ] [ 1 ] == TSKO [ m ] )
<operator>.lessThan n < QLIK
<operator>.postIncrement n ++
<operator>.equals LTXE == 1
JLIEG JLIEG ( p )
JLIEG JLIEG ( p )
<operator>.assignment TSKO [ m ] = YJUU [ n ] [ 2 ]
<operator>.assignment k = m
<operator>.assignment VPUY = 1
<operator>.assignment n = 0
<operator>.logicalAnd YJUU [ n ] [ 1 ] == TSKO [ k ] && YJUU [ n ] [ 0 ] == TSKO [ m ]
<operator>.logicalAnd YJUU [ n ] [ 0 ] == TSKO [ k ] && YJUU [ n ] [ 1 ] == TSKO [ m ]
<operator>.logicalOr ( FYXW [ n ] [ 0 ] == TSKO [ k ] && FYXW [ n ] [ 1 ] == TSKO [ m ] ) || ( FYXW [ n ] [ 1 ] == TSKO [ k ] && FYXW [ n ] [ 0 ] == TSKO [ m ] )
<operator>.equals YJUU [ n ] [ 1 ] == TSKO [ k ]
<operator>.equals YJUU [ n ] [ 0 ] == TSKO [ m ]
<operator>.equals YJUU [ n ] [ 0 ] == TSKO [ k ]
<operator>.equals YJUU [ n ] [ 1 ] == TSKO [ m ]
<operator>.assignment k = - 1
<operator>.assignment LTXE = 1
<operator>.logicalAnd FYXW [ n ] [ 0 ] == TSKO [ k ] && FYXW [ n ] [ 1 ] == TSKO [ m ]
<operator>.logicalAnd FYXW [ n ] [ 1 ] == TSKO [ k ] && FYXW [ n ] [ 0 ] == TSKO [ m ]
<operator>.equals FYXW [ n ] [ 0 ] == TSKO [ k ]
<operator>.equals FYXW [ n ] [ 1 ] == TSKO [ m ]
<operator>.equals FYXW [ n ] [ 1 ] == TSKO [ k ]
<operator>.equals FYXW [ n ] [ 0 ] == TSKO [ m ]
<operator>.minus - 1
<operator>.addressOf & AVWY
<operator>.addressOf & QLIK
<operator>.indirectIndexAccess TSKO [ k ]
<operator>.addressOf & MBIM
<operator>.indirectIndexAccess TSKO [ j ]
<operator>.indirectIndexAccess TSKO [ j ]
<operator>.indirectIndexAccess TSKO [ k ]
<operator>.indirectIndexAccess JDPL [ j ]
<operator>.indirectIndexAccess TSKO [ j ++ ]
<operator>.indirectIndexAccess TSKO [ j ++ ]
<operator>.indirectIndexAccess JDPL [ j ]
<operator>.indirectIndexAccess YJUU [ j ] [ k ]
<operator>.indirectIndexAccess FYXW [ j ] [ k ]
<operator>.indirectIndexAccess YJUU [ j ]
<operator>.indirectIndexAccess FYXW [ j ]
<operator>.indirectIndexAccess TSKO [ m ]
<operator>.indirectIndexAccess YJUU [ n ] [ 2 ]
<operator>.indirectIndexAccess YJUU [ n ] [ 1 ]
<operator>.indirectIndexAccess TSKO [ k ]
<operator>.indirectIndexAccess YJUU [ n ] [ 0 ]
<operator>.indirectIndexAccess TSKO [ m ]
<operator>.indirectIndexAccess YJUU [ n ] [ 0 ]
<operator>.indirectIndexAccess TSKO [ k ]
<operator>.indirectIndexAccess YJUU [ n ] [ 1 ]
<operator>.indirectIndexAccess TSKO [ m ]
<operator>.indirectIndexAccess YJUU [ n ]
<operator>.indirectIndexAccess YJUU [ n ]
<operator>.indirectIndexAccess YJUU [ n ]
<operator>.indirectIndexAccess YJUU [ n ]
<operator>.indirectIndexAccess YJUU [ n ]
<operator>.indirectIndexAccess FYXW [ n ] [ 0 ]
<operator>.indirectIndexAccess TSKO [ k ]
<operator>.indirectIndexAccess FYXW [ n ] [ 1 ]
<operator>.indirectIndexAccess TSKO [ m ]
<operator>.indirectIndexAccess FYXW [ n ] [ 1 ]
<operator>.indirectIndexAccess TSKO [ k ]
<operator>.indirectIndexAccess FYXW [ n ] [ 0 ]
<operator>.indirectIndexAccess TSKO [ m ]
<operator>.indirectIndexAccess FYXW [ n ]
<operator>.indirectIndexAccess FYXW [ n ]
<operator>.indirectIndexAccess FYXW [ n ]
<operator>.indirectIndexAccess FYXW [ n ]
>>>PDG&150 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->47 0->49 0->50 0->53 0->55 0->56 0->57 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->71 0->72 0->73 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->83 0->84 0->85 0->86 0->87 0->89 0->90 0->91 0->100 0->107 2->1 2->1 2->4 3->1 3->1 3->1 3->17 4->1 4->1 4->1 4->6 4->12 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->12 6->13 6->14 6->15 6->16 6->17 6->17 6->19 6->20 6->21 6->22 6->24 6->27 6->32 6->32 6->108 6->109 6->110 6->111 6->112 7->1 7->6 8->5 9->2 9->2 10->3 10->3 11->1 11->6 12->1 12->1 12->13 12->19 12->35 12->61 12->67 13->1 13->1 13->20 13->21 13->37 13->71 13->83 14->1 14->1 14->76 15->1 15->1 16->1 16->1 16->79 17->1 17->1 17->33 17->44 18->1 18->1 18->17 19->1 19->1 19->12 19->35 19->35 19->45 19->61 20->1 20->1 20->13 20->37 20->37 20->47 20->83 21->1 21->1 21->1 21->12 21->22 21->26 21->39 21->39 21->49 21->49 21->50 22->1 22->1 22->21 22->22 22->23 22->23 22->28 22->29 22->30 22->31 22->39 22->41 22->43 22->52 22->76 22->114 22->115 23->1 23->22 24->1 24->1 24->18 24->25 24->25 24->33 24->44 24->79 24->113 24->117 25->1 25->1 25->24 25->25 25->34 25->66 25->113 25->116 26->1 26->1 26->1 27->22 28->1 28->1 28->95 28->103 29->1 29->43 29->63 30->1 30->1 30->85 31->1 31->1 31->76 33->1 33->1 33->17 34->1 34->1 34->18 34->44 35->1 35->1 35->12 35->19 35->35 35->36 35->36 35->46 35->53 35->55 35->61 35->67 35->68 36->1 36->35 37->1 37->1 37->13 37->20 37->37 37->38 37->38 37->48 37->57 37->59 37->71 37->72 37->83 38->1 38->37 39->22 39->39 39->40 39->40 39->51 39->75 39->118 40->1 40->39 41->1 41->1 41->31 41->42 41->61 41->63 41->64 41->77 41->89 42->1 42->41 43->1 43->1 43->64 43->78 44->1 44->1 44->18 44->34 44->34 45->35 46->1 46->1 46->53 47->37 48->1 48->1 48->57 49->1 49->12 49->26 49->75 50->39 51->1 51->1 51->1 51->28 52->1 52->1 52->41 53->1 53->1 53->53 53->54 53->69 53->80 54->1 54->1 54->53 55->1 55->55 55->56 55->56 55->69 55->70 55->86 55->119 55->121 56->1 56->55 57->1 57->1 57->57 57->58 57->73 57->81 58->1 58->1 58->57 59->1 59->59 59->60 59->60 59->73 59->74 59->87 59->120 59->122 60->1 60->59 61->1 61->1 61->1 61->12 61->19 61->62 61->82 61->92 61->95 61->125 61->126 61->134 62->1 62->61 63->1 63->41 63->42 63->43 64->1 64->1 64->31 64->65 64->83 64->85 64->91 65->1 65->64 66->1 67->13 67->46 67->80 67->86 68->55 69->1 69->1 70->1 70->1 70->1 70->69 71->21 71->48 71->81 71->87 72->59 73->1 73->1 74->1 74->1 74->1 74->73 75->1 75->12 75->51 76->41 76->52 76->52 77->1 77->61 78->1 78->64 79->1 79->66 80->13 80->54 80->67 80->86 81->21 81->58 81->71 81->87 82->1 82->1 82->1 82->61 82->62 82->88 82->89 82->90 82->123 82->124 82->133 83->1 83->1 83->1 83->13 83->20 83->84 83->94 83->101 83->103 83->138 83->139 83->146 84->1 84->83 85->1 85->1 85->64 85->65 86->13 86->67 86->70 87->21 87->71 87->74 88->1 88->1 88->1 88->96 88->98 88->104 88->106 89->1 89->1 89->31 89->41 89->64 90->1 90->63 91->1 91->83 92->1 92->1 92->82 92->82 92->93 92->97 92->129 92->130 92->136 93->1 93->1 93->82 93->82 94->1 94->1 94->1 94->83 94->84 94->99 94->100 94->107 95->1 95->92 95->92 95->96 95->97 95->98 95->103 95->127 95->128 95->135 96->1 96->1 96->92 96->92 96->97 96->98 96->104 96->106 97->1 97->93 97->93 97->95 97->96 97->98 97->103 97->131 97->132 97->137 98->1 98->1 98->93 98->93 98->95 98->96 98->104 98->106 99->1 99->1 99->31 99->64 100->1 100->85 101->1 101->1 101->94 101->94 101->102 101->105 101->142 101->143 101->148 102->1 102->1 102->94 102->94 103->1 103->101 103->101 103->104 103->105 103->106 103->140 103->141 103->147 104->1 104->1 104->96 104->98 104->101 104->101 104->105 104->106 105->1 105->102 105->102 105->103 105->104 105->106 105->144 105->145 105->149 106->1 106->1 106->96 106->98 106->102 106->102 106->103 106->104 107->99
>>>Token int main ( ) { DRKD * p = QCOCW ( " " , " " ) ; DRKD * q = QCOCW ( " " , " " ) ; int i , j , k , m , n ; int TDCG , AVWY , QLIK , MBIM ; char c ; char YJUU [ C ] [ 3 ] ; char FYXW [ D ] [ 3 ] ; char JDPL [ N ] ; char TSKO [ N ] ; int VPUY , LTXE ; HIOTKY ( p , " " , & TDCG ) ; for ( i = 0 ; i < TDCG ; i ++ ) { HIOTKY ( p , " " , & AVWY ) ; if ( AVWY != 0 ) { for ( j = 0 ; j < AVWY ; j ++ ) { c = JLIEG ( p ) ; while ( c == ' ' ) c = JLIEG ( p ) ; for ( k = 0 ; k < 3 ; k ++ ) { YJUU [ j ] [ k ] = c ; c = JLIEG ( p ) ; } } } HIOTKY ( p , " " , & QLIK ) ; if ( QLIK != 0 ) { for ( j = 0 ; j < QLIK ; j ++ ) { c = JLIEG ( p ) ; while ( c == ' ' ) c = JLIEG ( p ) ; for ( k = 0 ; k < 2 ; k ++ ) { FYXW [ j ] [ k ] = c ; c = JLIEG ( p ) ; } } } if ( HIOTKY ( p , " " , & MBIM ) ) { c = JLIEG ( p ) ; for ( j = 0 ; j < MBIM ; j ++ ) { JDPL [ j ] = JLIEG ( p ) ; } } k = 0 ; for ( j = 0 ; j < MBIM ; j ++ ) { TSKO [ k ] = JDPL [ j ] ; VPUY = 0 ; LTXE = 0 ; for ( m = k - 1 ; m < k ; m ++ ) { for ( n = 0 ; n < AVWY ; n ++ ) { if ( ( YJUU [ n ] [ 1 ] == TSKO [ k ] && YJUU [ n ] [ 0 ] == TSKO [ m ] ) || ( YJUU [ n ] [ 0 ] == TSKO [ k ] && YJUU [ n ] [ 1 ] == TSKO [ m ] ) ) { TSKO [ m ] = YJUU [ n ] [ 2 ] ; k = m ; VPUY = 1 ; break ; } } if ( VPUY == 1 ) break ; } if ( VPUY == 0 ) { for ( m = 0 ; m < k ; m ++ ) { for ( n = 0 ; n < QLIK ; n ++ ) { if ( ( FYXW [ n ] [ 0 ] == TSKO [ k ] && FYXW [ n ] [ 1 ] == TSKO [ m ] ) || ( FYXW [ n ] [ 1 ] == TSKO [ k ] && FYXW [ n ] [ 0 ] == TSKO [ m ] ) ) { k = - 1 ; LTXE = 1 ; break ; } } if ( LTXE == 1 ) break ; } } k ++ ; } TSKO [ k ] = ' \0 ' ; j = 0 ; fprintf ( q , " " , i + 1 ) ; if ( TSKO [ j ] == ' \0 ' ) { fprintf ( q , " \n " ) ; continue ; } else fprintf ( q , " " , TSKO [ j ++ ] ) ; while ( TSKO [ j ] != ' \0 ' ) { fprintf ( q , " " , TSKO [ j ++ ] ) ; } fprintf ( q , " \n " ) ; } return 0 ; }
>>>Func
METHOD SLIXOHV
METHOD_RETURN void
PARAM const double * x
PARAM double * y
PARAM double * dy
<operator>.assignment GNCYA = 1.F
<operator>.assignment dy [ 0 ] = y [ 1 ]
<operator>.assignment dy [ 1 ] = - GNCYA * GNCYA * y [ 0 ]
<operator>.multiplication - GNCYA * GNCYA * y [ 0 ]
<operator>.multiplication - GNCYA * GNCYA
<operator>.minus - GNCYA
>>>PDG&11 0->2 0->3 0->4 0->5 0->9 0->10 2->1 3->1 3->6 3->8 4->1 5->1 5->10 6->1 6->1 6->1 7->1 7->1 7->1 8->1 8->1 8->7 8->7 9->1 9->1 9->8 9->8 10->9
>>>Token void SLIXOHV ( const double * x , double * y , double * dy ) { const double GNCYA = 1.F ; dy [ 0 ] = y [ 1 ] ; dy [ 1 ] = - GNCYA * GNCYA * y [ 0 ] ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment XRP = GCGFP ( "a.txt" , "r" )
<operator>.assignment SQKI = GCGFP ( "output" , "w" )
<operator>.assignment nt = 0
MEBIFF MEBIFF ( XRP , "%d" , & nt )
fprintf fprintf ( SQKI , "\n" )
YAAETN YAAETN ( XRP )
YAAETN YAAETN ( SQKI )
RETURN return 0 ; return 0 ;
<operator>.equals XRP == NULL
<operator>.equals SQKI == NULL
<operator>.lessThan it < nt
<operator>.postIncrement it ++
LITERAL 0 return 0 ;
GCGFP GCGFP ( "a.txt" , "r" )
printf printf ( "\nerror input file\n" )
GCGFP GCGFP ( "output" , "w" )
printf printf ( "\nERROR -output file\n" )
<operator>.assignment it = 0
printf printf ( "Case #%d: " , it + 1 )
fprintf fprintf ( SQKI , "Case #%d: " , it + 1 )
HKAL HKAL ( )
printf printf ( "\n" )
fprintf fprintf ( SQKI , "\n" )
<operator>.addition it + 1
<operator>.addition it + 1
>>>PDG&27 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->1 2->1 2->10 3->1 3->1 3->11 4->1 4->5 4->12 5->1 5->1 5->7 5->12 6->1 6->8 7->1 7->1 8->1 8->1 9->1 10->1 10->5 10->11 10->16 11->1 11->1 11->6 11->18 11->21 12->1 12->1 12->1 12->12 12->13 12->13 12->20 12->20 12->21 12->21 12->22 12->23 12->24 12->25 12->25 12->26 12->26 13->1 13->12 14->9 15->2 15->2 16->1 17->3 17->3 18->1 19->1 19->12 20->1 21->1 21->1 21->24 22->1 23->1 24->6 24->21
>>>Token int main ( ) { XRP = GCGFP ( " " , " " ) ; if ( XRP == NULL ) printf ( " \n \n " ) ; SQKI = GCGFP ( " " , " " ) ; if ( SQKI == NULL ) printf ( " \n \n " ) ; int nt , it ; nt = 0 ; MEBIFF ( XRP , " " , & nt ) ; for ( it = 0 ; it < nt ; it ++ ) { printf ( " " , it + 1 ) ; fprintf ( SQKI , " " , it + 1 ) ; HKAL ( ) ; printf ( " \n " ) ; fprintf ( SQKI , " \n " ) ; } fprintf ( SQKI , " \n " ) ; YAAETN ( XRP ) ; YAAETN ( SQKI ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
VPJQG VPJQG ( "%d" , & PVKVKFG )
<operator>.lessThan CIOKBCH < PVKVKFG
<operator>.postIncrement CIOKBCH ++
<operator>.assignment CIOKBCH = 0
VPJQG VPJQG ( "%d" , & LREI )
<operator>.assignment KUITNA = ( char * * ) malloc ( sizeof ( char * ) * LREI )
VPJQG VPJQG ( "%d" , & SNFQ )
<operator>.assignment FYLM = ( char * * ) malloc ( sizeof ( char * ) * SNFQ )
VPJQG VPJQG ( "%d" , & JXVLEWXSPVMR )
<operator>.assignment PVSAWDPU = ( char * ) malloc ( sizeof ( char ) * XYCXT )
VPJQG VPJQG ( "%s" , PVSAWDPU )
<operator>.assignment OOGVWTPB = PVSAWDPU
RYXCQID RYXCQID ( CIOKBCH , KUITNA , LREI , FYLM , SNFQ , OOGVWTPB )
<operator>.lessThan i < LREI
<operator>.postIncrement i ++
<operator>.lessThan i < SNFQ
<operator>.postIncrement i ++
<operator>.cast ( char * * ) malloc ( sizeof ( char * ) * LREI )
<operator>.assignment i = 0
<operator>.assignment PVSAWDPU = ( char * ) malloc ( sizeof ( char ) * 3 )
VPJQG VPJQG ( "%s" , PVSAWDPU )
<operator>.assignment KUITNA [ i ] = PVSAWDPU
<operator>.cast ( char * * ) malloc ( sizeof ( char * ) * SNFQ )
<operator>.assignment i = 0
<operator>.assignment PVSAWDPU = ( char * ) malloc ( sizeof ( char ) * 2 )
VPJQG VPJQG ( "%s" , PVSAWDPU )
<operator>.assignment FYLM [ i ] = PVSAWDPU
<operator>.cast ( char * ) malloc ( sizeof ( char ) * XYCXT )
malloc malloc ( sizeof ( char * ) * LREI )
malloc malloc ( sizeof ( char * ) * SNFQ )
malloc malloc ( sizeof ( char ) * XYCXT )
<operator>.multiplication sizeof ( char * ) * LREI
<operator>.cast ( char * ) malloc ( sizeof ( char ) * 3 )
<operator>.multiplication sizeof ( char * ) * SNFQ
<operator>.cast ( char * ) malloc ( sizeof ( char ) * 2 )
<operator>.multiplication sizeof ( char ) * XYCXT
malloc malloc ( sizeof ( char ) * 3 )
malloc malloc ( sizeof ( char ) * 2 )
<operator>.multiplication sizeof ( char ) * 3
<operator>.multiplication sizeof ( char ) * 2
<operator>.addressOf & LREI
<operator>.addressOf & SNFQ
<operator>.addressOf & JXVLEWXSPVMR
UNKNOWN char * * char * *
UNKNOWN char * * char * *
UNKNOWN char * char *
<operator>.indirectIndexAccess KUITNA [ i ]
<operator>.indirectIndexAccess FYLM [ i ]
<operator>.sizeOf sizeof ( char * )
UNKNOWN char * char *
<operator>.sizeOf sizeof ( char * )
UNKNOWN char * char *
<operator>.sizeOf sizeof ( char )
<operator>.sizeOf sizeof ( char )
<operator>.sizeOf sizeof ( char )
>>>PDG&58 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->11 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->21 0->23 0->24 0->26 0->28 0->29 0->34 0->36 0->38 0->41 0->42 2->1 3->1 3->1 3->4 4->1 4->1 4->1 4->4 4->5 4->7 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->15 4->16 4->18 4->20 4->21 4->25 4->26 4->30 4->31 4->32 4->33 4->34 4->36 4->38 4->43 4->44 4->45 4->46 4->47 4->48 4->51 4->53 4->55 5->1 5->4 6->1 6->4 7->15 7->16 7->34 8->15 9->15 9->18 9->36 10->15 12->13 13->14 14->15 15->5 15->7 15->9 15->34 15->36 16->15 16->16 16->17 16->17 16->22 16->23 16->24 16->35 16->39 16->41 16->49 16->52 16->56 17->16 18->15 18->18 18->19 18->19 18->27 18->28 18->29 18->37 18->40 18->42 18->50 18->54 18->57 19->18 21->16 22->23 23->24 24->15 26->18 27->28 28->29 29->15 31->8 31->20 32->10 32->25 33->12 33->30 34->16 34->31 36->18 36->32 38->1 38->33 39->22 39->35 40->27 40->37 41->39 42->40
>>>Token int main ( void ) { int PVKVKFG , LREI , SNFQ ; char * * KUITNA ; char * * FYLM ; char * PVSAWDPU ; char * OOGVWTPB ; int i , CIOKBCH , JXVLEWXSPVMR ; VPJQG ( " " , & PVKVKFG ) ; for ( CIOKBCH = 0 ; CIOKBCH < PVKVKFG ; CIOKBCH ++ ) { VPJQG ( " " , & LREI ) ; KUITNA = ( char * * ) malloc ( sizeof ( char * ) * LREI ) ; for ( i = 0 ; i < LREI ; i ++ ) { PVSAWDPU = ( char * ) malloc ( sizeof ( char ) * 3 ) ; VPJQG ( " " , PVSAWDPU ) ; KUITNA [ i ] = PVSAWDPU ; } VPJQG ( " " , & SNFQ ) ; FYLM = ( char * * ) malloc ( sizeof ( char * ) * SNFQ ) ; for ( i = 0 ; i < SNFQ ; i ++ ) { PVSAWDPU = ( char * ) malloc ( sizeof ( char ) * 2 ) ; VPJQG ( " " , PVSAWDPU ) ; FYLM [ i ] = PVSAWDPU ; } VPJQG ( " " , & JXVLEWXSPVMR ) ; PVSAWDPU = ( char * ) malloc ( sizeof ( char ) * XYCXT ) ; VPJQG ( " " , PVSAWDPU ) ; OOGVWTPB = PVSAWDPU ; RYXCQID ( CIOKBCH , KUITNA , LREI , FYLM , SNFQ , OOGVWTPB ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
RHSEVHN RHSEVHN ( "B-small-attempt0.in" , "r" , stdin )
RHSEVHN RHSEVHN ( "gcj_2.out" , "w" , HWGWYI )
CPDXX CPDXX ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
CPDXX CPDXX ( "%d" , & c )
CPDXX CPDXX ( "%d" , & d )
CPDXX CPDXX ( "%d" , & n )
CPDXX CPDXX ( "%s" , JUG )
printf printf ( "Case #%d: " , i )
MHTX MHTX ( )
<operator>.lessThan 0 <BBSHYAX
<operator>.greaterThan ';'> printf ( "======================\n" )
printf printf ( "======================\n" )
IDENTIFIER HWGG <empty>
<operator>.lessThan j < c
<operator>.postIncrement j ++
CPDXX CPDXX ( "%s" , PRI [ j ] )
<operator>.lessThan j < d
<operator>.postIncrement j ++
CPDXX CPDXX ( "%s" , QMT [ j ] )
<operator>.lessThan j < c
<operator>.postIncrement j ++
printf printf ( "%s\n" , PRI [ j ] )
<operator>.lessThan j < d
<operator>.postIncrement j ++
printf printf ( "%s\n" , QMT [ j ] )
<operator>.assignment j = 0
<operator>.assignment j = 0
printf printf ( "======================\n" )
<operator>.assignment j = 0
<operator>.assignment j = 0
UNKNOWN X X
UNKNOWN G G
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess PRI [ j ]
<operator>.indirectIndexAccess QMT [ j ]
<operator>.indirectIndexAccess PRI [ j ]
<operator>.indirectIndexAccess QMT [ j ]
>>>PDG&47 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 2->1 3->1 3->1 4->1 4->1 5->1 5->1 5->7 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->13 7->14 7->15 7->15 7->16 7->17 7->18 7->19 7->21 7->24 7->27 7->30 7->33 7->34 7->35 7->36 7->37 7->38 7->39 7->40 7->41 7->42 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->21 11->27 12->1 12->1 12->24 12->30 13->1 13->1 14->1 14->1 15->1 15->8 16->1 17->1 17->1 18->1 19->1 21->21 21->22 21->22 21->23 21->27 21->43 22->1 22->21 23->1 23->1 23->29 24->24 24->25 24->25 24->26 24->30 24->44 25->1 25->24 26->1 26->1 26->32 27->1 27->1 27->11 27->21 27->27 27->28 27->28 27->29 27->45 28->1 28->27 29->1 29->1 29->23 30->1 30->1 30->1 30->12 30->24 30->30 30->31 30->31 30->32 30->46 31->1 31->30 32->1 32->1 32->26 33->21 34->24 35->18 36->27 37->1 37->30
>>>Token int main ( void ) { RHSEVHN ( " " , " " , stdin ) ; RHSEVHN ( " " , " " , HWGWYI ) ; int t , i , j ; CPDXX ( " " , & t ) ; for ( i = 1 ; i <= t ; i ++ ) { CPDXX ( " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) CPDXX ( " " , PRI [ j ] ) ; CPDXX ( " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) CPDXX ( " " , QMT [ j ] ) ; CPDXX ( " " , & n ) ; CPDXX ( " " , JUG ) ; printf ( " " , i ) ; MHTX ( ) ; 0 < BBSHYAX ' ' > printf ( " \n " ) ; for ( j = 0 ; j < c ; j ++ ) printf ( " \n " , PRI [ j ] ) ; for ( j = 0 ; j < d ; j ++ ) printf ( " \n " , QMT [ j ] ) ; printf ( " \n " ) ; HWGG  } return 0 ; }
>>>Func
METHOD ECSRHFQR
METHOD_RETURN void
PARAM int DJPY
VGHDL VGHDL ( "%d\n" , & IPA )
TMCQJUQY TMCQJUQY ( DJPY + 1 )
<operator>.lessThan i < IPA
<operator>.postIncrement i ++
<operator>.lessThan i < IPA
<operator>.postIncrement i ++
<operator>.lessThan e < IPA
<operator>.postIncrement e ++
<operator>.lessThan e < IPA
<operator>.postIncrement e ++
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment CWGAEX = 0
<operator>.assignment GBCITWRA = 0
<operator>.assignment e = 0
<operator>.assignment ACEVI = 0.0
<operator>.assignment NBUVQWG = 0.0
<operator>.assignment e = 0
<operator>.assignment ACEVI = 0.0
<operator>.assignment NBUVQWG = 0.0
<operator>.assignment LKQJR [ e ] = ACEVI / ( double ) ( NBUVQWG )
<operator>.addition DJPY + 1
<operator>.lessThan j < IPA
<operator>.postIncrement j ++
<operator>.lessThan j < IPA
<operator>.postIncrement j ++
<operator>.greaterThan CWGAEX > 0
<operator>.lessThan a < IPA
<operator>.postIncrement a ++
<operator>.greaterThan NBUVQWG > 0
<operator>.lessThan i < IPA
<operator>.postIncrement i ++
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment NJF [ i ] = ( double ) GBCITWRA / ( double ) CWGAEX
<operator>.assignment a = 0
<operator>.assignment PCIM [ e ] = ACEVI / ( NBUVQWG )
<operator>.assignment i = 0
<operator>.division ACEVI / ( double ) ( NBUVQWG )
<operator>.equals j == IPA - 1
<operator>.logicalAnd m [ i ] [ j ] != '.' && j != i
<operator>.assignment NJF [ i ] = 0.0
<operator>.logicalAnd e != a && m [ a ] [ e ] != '.'
<operator>.assignment PCIM [ e ] = 0.0
<operator>.logicalAnd i != e && m [ i ] [ e ] != '.'
<operator>.cast ( double ) ( NBUVQWG )
VGHDL VGHDL ( "%c\n" , & m [ i ] [ j ] )
<operator>.postIncrement CWGAEX ++
<operator>.division ( double ) GBCITWRA / ( double ) CWGAEX
<operator>.assignment CWGAEX = 0
<operator>.assignment GBCITWRA = 0
<operator>.assignmentPlus ACEVI += ( double ) GBCITWRA / ( double ) CWGAEX
<operator>.assignmentPlus NBUVQWG += 1
<operator>.division ACEVI / ( NBUVQWG )
<operator>.assignmentPlus ACEVI += PCIM [ i ]
<operator>.assignmentPlus NBUVQWG += 1.0
<operator>.subtraction IPA - 1
VGHDL VGHDL ( "%c" , & m [ i ] [ j ] )
<operator>.notEquals m [ i ] [ j ] != '.'
<operator>.notEquals j != i
<operator>.equals m [ i ] [ j ] == '1'
<operator>.cast ( double ) GBCITWRA
<operator>.cast ( double ) CWGAEX
<operator>.notEquals e != a
<operator>.notEquals m [ a ] [ e ] != '.'
<operator>.lessThan i < IPA
<operator>.postIncrement i ++
<operator>.notEquals i != e
<operator>.notEquals m [ i ] [ e ] != '.'
<operator>.postIncrement GBCITWRA ++
<operator>.assignment i = 0
<operator>.division ( double ) GBCITWRA / ( double ) CWGAEX
<operator>.logicalAnd m [ a ] [ i ] != '.' && i != e
<operator>.cast ( double ) GBCITWRA
<operator>.cast ( double ) CWGAEX
<operator>.postIncrement CWGAEX ++
<operator>.notEquals m [ a ] [ i ] != '.'
<operator>.notEquals i != e
<operator>.equals m [ a ] [ i ] == '1'
<operator>.postIncrement GBCITWRA ++
<operator>.indirectIndexAccess LKQJR [ e ]
<operator>.indirectIndexAccess NJF [ i ]
<operator>.indirectIndexAccess PCIM [ e ]
UNKNOWN double double
<operator>.indirectIndexAccess NJF [ i ]
<operator>.indirectIndexAccess PCIM [ e ]
<operator>.addressOf & m [ i ] [ j ]
<operator>.indirectIndexAccess m [ i ] [ j ]
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess m [ a ] [ e ]
<operator>.indirectIndexAccess m [ i ] [ e ]
<operator>.indirectIndexAccess PCIM [ i ]
<operator>.indirectIndexAccess m [ i ] [ j ]
<operator>.addressOf & m [ i ] [ j ]
<operator>.indirectIndexAccess m [ i ]
<operator>.indirectIndexAccess m [ i ] [ j ]
<operator>.indirectIndexAccess m [ a ]
<operator>.indirectIndexAccess m [ i ]
<operator>.indirectIndexAccess m [ i ]
<operator>.indirectIndexAccess m [ i ] [ j ]
<operator>.indirectIndexAccess m [ i ]
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess m [ i ]
<operator>.indirectIndexAccess m [ a ] [ i ]
<operator>.indirectIndexAccess m [ a ]
<operator>.indirectIndexAccess m [ a ] [ i ]
<operator>.indirectIndexAccess m [ a ]
>>>PDG&112 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->40 0->41 0->42 0->44 0->46 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->76 0->77 0->78 0->79 0->80 0->81 0->82 2->4 2->24 3->1 3->1 3->5 3->7 3->9 3->11 3->25 3->27 3->30 3->33 3->59 3->68 4->1 4->1 5->5 5->6 5->6 5->7 5->25 5->25 5->35 6->1 6->5 7->1 7->1 7->7 7->8 7->8 7->9 7->15 7->16 7->27 7->27 7->29 7->36 7->62 8->1 8->7 9->9 9->10 9->10 9->11 9->18 9->19 9->30 9->30 9->32 9->38 9->66 10->1 10->9 11->1 11->1 11->1 11->11 11->12 11->12 11->21 11->22 11->23 11->33 11->33 11->40 11->41 11->48 11->70 11->83 11->86 12->1 12->11 13->5 14->1 14->7 15->1 15->29 15->50 16->1 16->1 16->51 16->64 16->72 17->9 18->1 18->1 18->54 18->56 19->1 19->32 19->55 20->1 20->11 21->1 21->41 21->57 22->1 22->41 22->48 22->58 23->1 23->1 23->1 24->1 25->1 25->1 25->5 25->25 25->26 25->42 25->42 25->59 25->59 26->1 26->25 27->1 27->1 27->7 27->27 27->28 27->28 27->43 27->61 27->62 27->90 27->98 28->1 28->27 29->1 29->1 29->37 29->44 29->51 29->51 29->64 29->65 29->65 29->84 29->87 29->91 29->92 30->1 30->1 30->9 30->30 30->31 30->45 30->66 30->66 30->68 31->1 31->30 32->1 32->1 32->39 32->46 32->56 32->56 32->85 32->88 33->1 33->1 33->11 33->33 33->34 33->47 33->70 33->70 34->1 34->33 35->1 35->25 36->1 36->27 37->1 37->1 37->1 38->1 38->30 39->1 39->1 39->1 40->1 40->33 41->1 41->1 41->23 41->23 42->1 42->1 42->26 42->49 42->60 42->89 42->96 42->97 42->102 42->103 42->107 43->1 43->1 43->1 43->50 43->63 43->99 43->104 44->1 44->1 45->1 45->1 45->1 45->52 45->53 45->54 45->55 45->68 45->73 45->74 45->76 45->77 45->105 45->106 46->1 46->1 47->1 47->1 47->1 47->57 47->58 47->95 48->1 49->1 49->1 49->60 49->61 49->63 50->1 50->29 51->1 51->1 51->37 51->37 52->1 52->74 52->77 52->78 53->1 53->74 53->76 53->82 54->1 54->1 54->1 54->56 55->1 55->32 56->1 56->1 56->39 56->39 57->1 57->1 57->41 58->1 58->41 58->48 59->25 59->42 59->42 60->1 60->1 60->49 60->61 60->63 61->1 61->43 61->43 61->62 61->63 62->8 62->28 62->43 62->43 63->1 63->1 63->61 63->72 64->1 65->1 66->10 66->31 66->45 66->45 66->67 66->80 66->93 66->100 67->1 67->45 67->45 68->1 68->1 68->30 68->68 68->69 68->69 68->75 68->79 68->80 68->108 68->109 69->1 69->68 70->12 70->34 70->47 70->47 70->71 70->94 70->101 71->1 71->47 71->47 72->1 72->1 72->51 72->64 73->1 73->68 74->1 74->1 74->54 74->54 75->1 75->1 75->1 75->78 75->81 75->110 75->111 76->1 77->1 78->1 78->74 78->77 79->1 79->75 79->75 79->80 79->81 80->10 80->66 80->69 80->75 80->75 81->1 81->1 81->79 81->82 82->1 82->74 82->76
>>>Token void ECSRHFQR ( int DJPY ) { VGHDL ( " \n " , & IPA ) ; int i , j ; for ( i = 0 ; i < IPA ; i ++ ) { for ( j = 0 ; j < IPA ; j ++ ) { char HVF ; if ( j == IPA - 1 ) VGHDL ( " \n " , & m [ i ] [ j ] ) ; else VGHDL ( " " , & m [ i ] [ j ] ) ; } } for ( i = 0 ; i < IPA ; i ++ ) { int CWGAEX = 0 ; int GBCITWRA = 0 ; for ( j = 0 ; j < IPA ; j ++ ) { if ( m [ i ] [ j ] != ' ' && j != i ) { CWGAEX ++ ; if ( m [ i ] [ j ] == ' ' ) GBCITWRA ++ ; } } if ( CWGAEX > 0 ) NJF [ i ] = ( double ) GBCITWRA / ( double ) CWGAEX ; else NJF [ i ] = 0.0 ; } int e , a ; for ( e = 0 ; e < IPA ; e ++ ) { double ACEVI = 0.0 ; double NBUVQWG = 0.0 ; for ( a = 0 ; a < IPA ; a ++ ) { if ( e != a && m [ a ] [ e ] != ' ' ) { int CWGAEX = 0 ; int GBCITWRA = 0 ; for ( i = 0 ; i < IPA ; i ++ ) { if ( m [ a ] [ i ] != ' ' && i != e ) { CWGAEX ++ ; if ( m [ a ] [ i ] == ' ' ) GBCITWRA ++ ; } } ACEVI += ( double ) GBCITWRA / ( double ) CWGAEX ; NBUVQWG += 1 ; } } if ( NBUVQWG > 0 ) PCIM [ e ] = ACEVI / ( NBUVQWG ) ; else PCIM [ e ] = 0.0 ; } for ( e = 0 ; e < IPA ; e ++ ) { double ACEVI = 0.0 ; double NBUVQWG = 0.0 ; for ( i = 0 ; i < IPA ; i ++ ) { if ( i != e && m [ i ] [ e ] != ' ' ) { ACEVI += PCIM [ i ] ; NBUVQWG += 1.0 ; } } LKQJR [ e ] = ACEVI / ( double ) ( NBUVQWG ) ; } TMCQJUQY ( DJPY + 1 ) ; }
>>>Func
METHOD XRTIDHX
METHOD_RETURN void
PARAM double * * A
PARAM int N
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.assignment i = 0
KTQHYGG KTQHYGG ( '\n' )
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.assignment j = 0
printf printf ( "% 3.3g \t" , A [ i ] [ j ] )
<operator>.indirectIndexAccess A [ i ] [ j ]
<operator>.indirectIndexAccess A [ i ]
>>>PDG&14 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->1 3->4 4->1 4->1 4->1 4->4 4->5 4->5 4->7 4->8 4->8 4->10 5->1 5->4 6->1 6->4 8->4 8->8 8->9 8->9 8->11 8->12 8->13 9->8 10->8
>>>Token void XRTIDHX ( double * * A , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { printf ( " \t " , A [ i ] [ j ] ) ; } KTQHYGG ( ' \n ' ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
<operator>.assignment HTGYN = WSTAS ( "B.out" , "w+" )
YMTTAD YMTTAD ( FLIL , "%d\n" , & n )
XPBXWT XPBXWT ( FLIL )
XPBXWT XPBXWT ( HTGYN )
RETURN return EXIT_SUCCESS ; return EXIT_SUCCESS ;
<operator>.logicalNot ! ( FLIL = WSTAS ( "B.in" , "r" ) )
<operator>.lessThan i < n
<operator>.postIncrement i ++
IDENTIFIER EXIT_SUCCESS return EXIT_SUCCESS ;
printf printf ( "ERROR: no input file.\n" )
RETURN return EXIT_FAILURE ; return EXIT_FAILURE ;
WSTAS WSTAS ( "B.out" , "w+" )
<operator>.assignment i = 0
fprintf fprintf ( HTGYN , "Case #%d: [" , i + 1 )
YMTTAD YMTTAD ( FLIL , "%d " , & KDERLO )
YMTTAD YMTTAD ( FLIL , "%d " , & CARO )
YMTTAD YMTTAD ( FLIL , "%d " , & AVRTH )
<operator>.assignment COHE = 0
fprintf fprintf ( HTGYN , "]\n" )
<operator>.assignment FLIL = WSTAS ( "B.in" , "r" )
IDENTIFIER EXIT_FAILURE return EXIT_FAILURE ;
<operator>.lessThan j < KDERLO
<operator>.postIncrement j ++
<operator>.lessThan j < CARO
<operator>.postIncrement j ++
<operator>.lessThan j < AVRTH
<operator>.postIncrement j ++
<operator>.lessThan j < AVRTH
<operator>.postIncrement j ++
<operator>.lessThan j < COHE
<operator>.postIncrement j ++
WSTAS WSTAS ( "B.in" , "r" )
<operator>.addition i + 1
<operator>.assignment j = 0
YMTTAD YMTTAD ( FLIL , "%c%c%c " , & a , & b , & c )
<operator>.assignment BMACAQ [ j ] [ 0 ] = a
<operator>.assignment BMACAQ [ j ] [ 1 ] = b
<operator>.assignment BMACAQ [ j ] [ 2 ] = c
<operator>.assignment j = 0
YMTTAD YMTTAD ( FLIL , "%c%c%c " , & a , & b , & c )
<operator>.assignment KSJWFIIIB [ j ] [ 0 ] = a
<operator>.assignment KSJWFIIIB [ j ] [ 1 ] = b
<operator>.assignment KSJWFIIIB [ j ] [ 2 ] = c
<operator>.assignment j = 0
YMTTAD YMTTAD ( FLIL , "%c" , & a )
<operator>.assignment RCIDNTNJ [ j ] = a
<operator>.assignment j = 0
<operator>.assignment CMWAHQ [ COHE ] = RCIDNTNJ [ j ]
<operator>.postIncrement COHE ++
<operator>.assignment j = 0
fprintf fprintf ( HTGYN , "%c" , CMWAHQ [ j ] )
<operator>.greaterThan COHE > 1
<operator>.notEquals j != ( COHE - 1 )
fprintf fprintf ( HTGYN , ", " )
<operator>.lessThan k < KDERLO
<operator>.postIncrement k ++
<operator>.lessThan k < CARO
<operator>.postIncrement k ++
<operator>.subtraction COHE - 1
<operator>.assignment k = 0
<operator>.assignment k = 0
<operator>.logicalOr ( CMWAHQ [ COHE - 1 ] == BMACAQ [ k ] [ 0 ] && CMWAHQ [ COHE - 2 ] == BMACAQ [ k ] [ 1 ] ) || ( CMWAHQ [ COHE - 1 ] == BMACAQ [ k ] [ 1 ] && CMWAHQ [ COHE - 2 ] == BMACAQ [ k ] [ 0 ] )
<operator>.lessThan l < ( COHE - 1 )
<operator>.postIncrement l ++
<operator>.postDecrement COHE --
<operator>.assignment CMWAHQ [ COHE - 1 ] = BMACAQ [ k ] [ 2 ]
<operator>.assignment k = - 1
<operator>.assignment l = 0
<operator>.logicalAnd CMWAHQ [ COHE - 1 ] == BMACAQ [ k ] [ 0 ] && CMWAHQ [ COHE - 2 ] == BMACAQ [ k ] [ 1 ]
<operator>.logicalAnd CMWAHQ [ COHE - 1 ] == BMACAQ [ k ] [ 1 ] && CMWAHQ [ COHE - 2 ] == BMACAQ [ k ] [ 0 ]
<operator>.subtraction COHE - 1
<operator>.logicalOr ( CMWAHQ [ COHE - 1 ] == KSJWFIIIB [ k ] [ 0 ] && CMWAHQ [ l ] == KSJWFIIIB [ k ] [ 1 ] ) || ( CMWAHQ [ COHE - 1 ] == KSJWFIIIB [ k ] [ 1 ] && CMWAHQ [ l ] == KSJWFIIIB [ k ] [ 0 ] )
<operator>.equals CMWAHQ [ COHE - 1 ] == BMACAQ [ k ] [ 0 ]
<operator>.equals CMWAHQ [ COHE - 2 ] == BMACAQ [ k ] [ 1 ]
<operator>.equals CMWAHQ [ COHE - 1 ] == BMACAQ [ k ] [ 1 ]
<operator>.equals CMWAHQ [ COHE - 2 ] == BMACAQ [ k ] [ 0 ]
<operator>.minus - 1
<operator>.assignment COHE = 0
<operator>.subtraction COHE - 1
<operator>.logicalAnd CMWAHQ [ COHE - 1 ] == KSJWFIIIB [ k ] [ 0 ] && CMWAHQ [ l ] == KSJWFIIIB [ k ] [ 1 ]
<operator>.logicalAnd CMWAHQ [ COHE - 1 ] == KSJWFIIIB [ k ] [ 1 ] && CMWAHQ [ l ] == KSJWFIIIB [ k ] [ 0 ]
<operator>.subtraction COHE - 1
<operator>.subtraction COHE - 2
<operator>.subtraction COHE - 1
<operator>.subtraction COHE - 2
<operator>.equals CMWAHQ [ COHE - 1 ] == KSJWFIIIB [ k ] [ 0 ]
<operator>.equals CMWAHQ [ l ] == KSJWFIIIB [ k ] [ 1 ]
<operator>.equals CMWAHQ [ COHE - 1 ] == KSJWFIIIB [ k ] [ 1 ]
<operator>.equals CMWAHQ [ l ] == KSJWFIIIB [ k ] [ 0 ]
<operator>.subtraction COHE - 1
<operator>.subtraction COHE - 1
<operator>.addressOf & n
<operator>.addressOf & KDERLO
<operator>.addressOf & CARO
<operator>.addressOf & AVRTH
<operator>.addressOf & a
<operator>.addressOf & b
<operator>.addressOf & c
<operator>.indirectIndexAccess BMACAQ [ j ] [ 0 ]
<operator>.indirectIndexAccess BMACAQ [ j ] [ 1 ]
<operator>.indirectIndexAccess BMACAQ [ j ] [ 2 ]
<operator>.addressOf & a
<operator>.addressOf & b
<operator>.addressOf & c
<operator>.indirectIndexAccess KSJWFIIIB [ j ] [ 0 ]
<operator>.indirectIndexAccess KSJWFIIIB [ j ] [ 1 ]
<operator>.indirectIndexAccess KSJWFIIIB [ j ] [ 2 ]
<operator>.addressOf & a
<operator>.indirectIndexAccess RCIDNTNJ [ j ]
<operator>.indirectIndexAccess CMWAHQ [ COHE ]
<operator>.indirectIndexAccess RCIDNTNJ [ j ]
<operator>.indirectIndexAccess CMWAHQ [ j ]
<operator>.indirectIndexAccess BMACAQ [ j ]
<operator>.indirectIndexAccess BMACAQ [ j ]
<operator>.indirectIndexAccess BMACAQ [ j ]
<operator>.indirectIndexAccess KSJWFIIIB [ j ]
<operator>.indirectIndexAccess KSJWFIIIB [ j ]
<operator>.indirectIndexAccess KSJWFIIIB [ j ]
<operator>.indirectIndexAccess CMWAHQ [ COHE - 1 ]
<operator>.indirectIndexAccess BMACAQ [ k ] [ 2 ]
<operator>.indirectIndexAccess CMWAHQ [ COHE - 1 ]
<operator>.indirectIndexAccess BMACAQ [ k ] [ 0 ]
<operator>.indirectIndexAccess CMWAHQ [ COHE - 2 ]
<operator>.indirectIndexAccess BMACAQ [ k ] [ 1 ]
<operator>.indirectIndexAccess CMWAHQ [ COHE - 1 ]
<operator>.indirectIndexAccess BMACAQ [ k ] [ 1 ]
<operator>.indirectIndexAccess CMWAHQ [ COHE - 2 ]
<operator>.indirectIndexAccess BMACAQ [ k ] [ 0 ]
<operator>.indirectIndexAccess BMACAQ [ k ]
<operator>.indirectIndexAccess BMACAQ [ k ]
<operator>.indirectIndexAccess BMACAQ [ k ]
<operator>.indirectIndexAccess BMACAQ [ k ]
<operator>.indirectIndexAccess BMACAQ [ k ]
<operator>.indirectIndexAccess CMWAHQ [ COHE - 1 ]
<operator>.indirectIndexAccess KSJWFIIIB [ k ] [ 0 ]
<operator>.indirectIndexAccess CMWAHQ [ l ]
<operator>.indirectIndexAccess KSJWFIIIB [ k ] [ 1 ]
<operator>.indirectIndexAccess CMWAHQ [ COHE - 1 ]
<operator>.indirectIndexAccess KSJWFIIIB [ k ] [ 1 ]
<operator>.indirectIndexAccess CMWAHQ [ l ]
<operator>.indirectIndexAccess KSJWFIIIB [ k ] [ 0 ]
<operator>.indirectIndexAccess KSJWFIIIB [ k ]
<operator>.indirectIndexAccess KSJWFIIIB [ k ]
<operator>.indirectIndexAccess KSJWFIIIB [ k ]
<operator>.indirectIndexAccess KSJWFIIIB [ k ]
>>>PDG&148 0->2 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->65 0->66 0->67 0->70 0->73 0->79 0->80 0->81 0->84 0->85 0->86 0->87 0->92 0->93 2->1 3->6 3->16 4->5 4->9 4->17 7->1 8->1 8->1 8->3 8->4 8->5 8->6 8->7 8->9 8->12 8->13 8->14 8->15 8->94 9->9 9->10 9->10 9->16 9->16 9->17 9->18 9->19 9->20 9->21 9->24 9->26 9->28 9->30 9->32 9->35 9->35 9->36 9->41 9->46 9->49 9->52 9->95 9->96 9->97 10->9 11->7 12->1 13->1 14->3 14->3 15->9 16->21 16->53 17->18 17->24 17->37 17->57 18->19 18->26 18->42 18->59 19->5 19->17 19->28 19->30 19->47 20->32 20->51 21->6 21->16 22->1 22->1 22->4 22->8 23->13 24->17 24->24 24->25 24->25 24->37 24->38 24->39 24->40 24->57 24->98 24->99 24->100 24->101 24->102 24->103 24->115 24->116 24->117 25->24 26->18 26->26 26->27 26->27 26->42 26->43 26->44 26->45 26->59 26->104 26->105 26->106 26->107 26->108 26->109 26->118 26->119 26->120 27->26 28->28 28->29 28->29 28->30 28->47 28->48 28->110 28->111 29->28 30->19 30->28 30->30 30->31 30->31 30->50 30->51 30->54 30->112 30->113 31->30 32->32 32->33 32->53 32->55 32->55 32->61 32->61 32->114 33->32 34->8 34->8 34->22 34->22 36->24 37->18 37->38 37->39 37->40 37->42 37->42 37->42 37->43 37->44 37->45 37->47 37->48 41->26 42->19 42->37 42->37 42->37 42->38 42->39 42->40 42->43 42->44 42->45 42->47 42->48 46->28 47->5 47->17 47->37 47->38 47->42 47->43 47->48 48->50 49->30 51->54 52->32 53->21 53->56 54->32 54->51 54->57 54->59 54->62 54->63 54->73 54->84 55->33 55->56 56->21 56->53 57->17 57->24 57->57 57->58 57->58 57->64 57->71 57->75 57->84 57->123 57->124 57->132 58->57 59->18 59->26 59->59 59->60 59->60 59->65 59->70 59->73 60->59 61->32 61->55 61->55 62->57 63->59 64->67 64->68 64->69 64->79 64->81 64->121 64->122 64->131 65->66 65->74 65->82 65->88 65->92 65->136 65->137 65->144 66->65 67->81 68->75 68->88 69->58 70->65 71->64 71->64 71->72 71->77 71->86 71->127 71->128 71->134 72->64 72->64 73->32 73->51 73->65 73->65 73->92 74->65 74->66 74->73 74->80 75->71 75->71 75->76 75->77 75->78 75->85 75->88 75->125 75->126 75->133 76->71 76->71 76->77 76->78 77->72 77->72 77->75 77->76 77->78 77->87 77->88 77->129 77->130 77->135 78->72 78->72 78->75 78->76 79->69 80->32 80->51 80->73 81->32 81->51 81->73 81->84 82->74 82->74 82->83 82->90 82->93 82->140 82->141 82->146 83->74 83->74 84->32 84->51 84->67 84->73 84->85 84->86 85->32 85->51 85->67 85->73 85->84 85->86 86->32 86->51 86->67 86->73 86->84 86->87 87->32 87->51 87->67 87->73 87->84 88->75 88->82 88->82 88->89 88->90 88->91 88->138 88->139 88->145 89->82 89->82 89->90 89->91 90->75 90->83 90->83 90->88 90->89 90->91 90->142 90->143 90->147 91->83 91->83 91->88 91->89 92->73 92->93 93->73
>>>Token int main ( void ) { BSHT * FLIL , * HTGYN ; if ( ! ( FLIL = WSTAS ( " " , " " ) ) ) { printf ( " \n " ) ; return EXIT_FAILURE ; } HTGYN = WSTAS ( " " , " " ) ; int i , j , k , l , n ; char a , b , c ; char BMACAQ [ 36 ] [ 3 ] ; char KSJWFIIIB [ 28 ] [ 3 ] ; char RCIDNTNJ [ 100 ] ; char CMWAHQ [ 100 ] ; int CARO , AVRTH , KDERLO , COHE ; YMTTAD ( FLIL , " \n " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { fprintf ( HTGYN , " " , i + 1 ) ; YMTTAD ( FLIL , " " , & KDERLO ) ; for ( j = 0 ; j < KDERLO ; j ++ ) { YMTTAD ( FLIL , " " , & a , & b , & c ) ; BMACAQ [ j ] [ 0 ] = a ; BMACAQ [ j ] [ 1 ] = b ; BMACAQ [ j ] [ 2 ] = c ; } YMTTAD ( FLIL , " " , & CARO ) ; for ( j = 0 ; j < CARO ; j ++ ) { YMTTAD ( FLIL , " " , & a , & b , & c ) ; KSJWFIIIB [ j ] [ 0 ] = a ; KSJWFIIIB [ j ] [ 1 ] = b ; KSJWFIIIB [ j ] [ 2 ] = c ; } YMTTAD ( FLIL , " " , & AVRTH ) ; for ( j = 0 ; j < AVRTH ; j ++ ) { YMTTAD ( FLIL , " " , & a ) ; RCIDNTNJ [ j ] = a ; } COHE = 0 ; for ( j = 0 ; j < AVRTH ; j ++ ) { CMWAHQ [ COHE ] = RCIDNTNJ [ j ] ; COHE ++ ; if ( COHE > 1 ) { for ( k = 0 ; k < KDERLO ; k ++ ) { if ( ( CMWAHQ [ COHE - 1 ] == BMACAQ [ k ] [ 0 ] && CMWAHQ [ COHE - 2 ] == BMACAQ [ k ] [ 1 ] ) || ( CMWAHQ [ COHE - 1 ] == BMACAQ [ k ] [ 1 ] && CMWAHQ [ COHE - 2 ] == BMACAQ [ k ] [ 0 ] ) ) { COHE -- ; CMWAHQ [ COHE - 1 ] = BMACAQ [ k ] [ 2 ] ; k = - 1 ; } } for ( k = 0 ; k < CARO ; k ++ ) { for ( l = 0 ; l < ( COHE - 1 ) ; l ++ ) { if ( ( CMWAHQ [ COHE - 1 ] == KSJWFIIIB [ k ] [ 0 ] && CMWAHQ [ l ] == KSJWFIIIB [ k ] [ 1 ] ) || ( CMWAHQ [ COHE - 1 ] == KSJWFIIIB [ k ] [ 1 ] && CMWAHQ [ l ] == KSJWFIIIB [ k ] [ 0 ] ) ) { COHE = 0 ; break ; } } } } } for ( j = 0 ; j < COHE ; j ++ ) { fprintf ( HTGYN , " " , CMWAHQ [ j ] ) ; if ( j != ( COHE - 1 ) ) { fprintf ( HTGYN , " " ) ; } } fprintf ( HTGYN , " \n " ) ; } XPBXWT ( FLIL ) ; XPBXWT ( HTGYN ) ; return EXIT_SUCCESS ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment PKVM = CBORQ ( "out.txt" , "w+" )
ATQLE ATQLE ( "%d" , & MLCAJIL )
KXGBBA KXGBBA ( PKVM )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= MLCAJIL
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= MLCAJIL
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
CBORQ CBORQ ( "out.txt" , "w+" )
<operator>.assignment i = 1
<operator>.assignment JLYOEMQS = ILRDWNW = PPUQR = 0
ATQLE ATQLE ( "%d " , & ILRDWNW )
ATQLE ATQLE ( "%d " , & PPUQR )
ATQLE ATQLE ( "%d " , & JXPO [ i ] )
<operator>.assignment i = 1
fprintf fprintf ( PKVM , "Case #%d: " , i )
fprintf fprintf ( PKVM , "[" )
fprintf fprintf ( PKVM , "]\n" )
IDENTIFIER ILRDWNW if (ILRDWNW)
IDENTIFIER PPUQR if (PPUQR)
<operator>.lessEqualsThan j <= JXPO [ i ]
<operator>.postIncrement j ++
<operator>.lessEqualsThan j <= JXPO [ i ]
<operator>.postIncrement j ++
<operator>.lessEqualsThan j <= JXPO [ i ]
<operator>.postIncrement j ++
<operator>.assignment ILRDWNW = PPUQR = 0
ATQLE ATQLE ( "%c%c%c" , & EUPYXNMU [ 1 ] , & EUPYXNMU [ 2 ] , & EUPYXNMU [ 3 ] )
ATQLE ATQLE ( "%c%c" , & FCRVVB [ 1 ] , & FCRVVB [ 2 ] )
<operator>.assignment j = 1
ATQLE ATQLE ( "%c" , & KGJM [ i ] [ j ] )
<operator>.assignment j = 1
<operator>.assignment j = 1
<operator>.assignment PPUQR = 0
<operator>.equals KGJM [ i ] [ j ] == EUPYXNMU [ 1 ]
<operator>.logicalNot ! JLYOEMQS
<operator>.equals j == JXPO [ i ]
fprintf fprintf ( PKVM , "%c" , KGJM [ i ] [ j ] )
<operator>.equals KGJM [ i ] [ j + 1 ] == EUPYXNMU [ 2 ]
<operator>.equals KGJM [ i ] [ j ] == FCRVVB [ 1 ]
fprintf fprintf ( PKVM , "%c, " , KGJM [ i ] [ j ] )
<operator>.assignment KGJM [ i ] [ j + 1 ] = EUPYXNMU [ 3 ]
<operator>.assignment j = 0
<operator>.assignmentMinus JXPO [ i ] -= 1
<operator>.assignment JLYOEMQS = 1
<operator>.equals KGJM [ i ] [ j ] == EUPYXNMU [ 2 ]
<operator>.lessEqualsThan k <= JXPO [ i ]
<operator>.postIncrement k ++
<operator>.lessEqualsThan k <= j + 2
<operator>.postIncrement k ++
<operator>.addition j + 1
<operator>.assignment k = j + 1
<operator>.assignment KGJM [ i ] [ k - 1 ] = KGJM [ i ] [ k ]
<operator>.equals KGJM [ i ] [ j + 1 ] == EUPYXNMU [ 1 ]
<operator>.assignment k = j + 1
<operator>.equals KGJM [ i ] [ j ] == FCRVVB [ 2 ]
<operator>.addition j + 1
<operator>.assignment KGJM [ i ] [ j + 1 ] = EUPYXNMU [ 3 ]
<operator>.assignment j = 0
<operator>.assignmentMinus JXPO [ i ] -= 1
<operator>.assignment JLYOEMQS = 1
<operator>.equals KGJM [ i ] [ j + 1 ] == EUPYXNMU [ 1 ]
<operator>.addition j + 2
<operator>.equals KGJM [ i ] [ k ] == FCRVVB [ 2 ]
<operator>.addition j + 1
<operator>.lessEqualsThan k <= JXPO [ i ]
<operator>.postIncrement k ++
<operator>.addition j + 1
<operator>.assignment JXPO [ i ] = JXPO [ i ] - ( k - j + 1 )
<operator>.assignment j = 0
<operator>.assignment JLYOEMQS = 1
<operator>.lessEqualsThan k <= j + 2
<operator>.postIncrement k ++
<operator>.subtraction k - 1
<operator>.addition j + 1
<operator>.assignment k = j + 1
<operator>.assignment KGJM [ i ] [ k - 1 ] = KGJM [ i ] [ k ]
<operator>.equals KGJM [ i ] [ j + 2 ] == EUPYXNMU [ 2 ]
<operator>.lessEqualsThan l <= JXPO [ i ]
<operator>.expressionList l ++   m ++
<operator>.assignment k = j + 1
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.assignment KGJM [ i ] [ j + 2 ] = EUPYXNMU [ 3 ]
<operator>.assignment j = 0
<operator>.assignmentMinus JXPO [ i ] -= 1
<operator>.assignment JLYOEMQS = 1
<operator>.equals KGJM [ i ] [ j + 1 ] == EUPYXNMU [ 2 ]
<operator>.expressionList l = k + 1   m = j
<operator>.assignment KGJM [ i ] [ m ] = KGJM [ i ] [ l ]
<operator>.subtraction JXPO [ i ] - ( k - j + 1 )
<operator>.addition j + 2
<operator>.equals KGJM [ i ] [ k ] == FCRVVB [ 1 ]
<operator>.addition j + 1
<operator>.lessEqualsThan k <= JXPO [ i ]
<operator>.postIncrement k ++
<operator>.postIncrement l ++
<operator>.postIncrement m ++
<operator>.addition k - j + 1
<operator>.addition j + 1
<operator>.assignment JXPO [ i ] = JXPO [ i ] - ( k - j + 1 )
<operator>.assignment j = 0
<operator>.assignment JLYOEMQS = 1
<operator>.subtraction k - 1
<operator>.addition j + 2
<operator>.assignment k = j + 2
<operator>.assignment KGJM [ i ] [ k - 1 ] = KGJM [ i ] [ k ]
<operator>.equals KGJM [ i ] [ j + 2 ] == EUPYXNMU [ 1 ]
<operator>.assignment l = k + 1
<operator>.assignment m = j
<operator>.subtraction k - j
<operator>.lessEqualsThan l <= JXPO [ i ]
<operator>.expressionList l ++   m ++
<operator>.addition j + 2
<operator>.addition j + 1
<operator>.assignment KGJM [ i ] [ j + 2 ] = EUPYXNMU [ 3 ]
<operator>.assignment j = 0
<operator>.assignmentMinus JXPO [ i ] -= 1
<operator>.assignment JLYOEMQS = 1
<operator>.addition k + 1
<operator>.expressionList l = k + 1   m = j
<operator>.assignment KGJM [ i ] [ m ] = KGJM [ i ] [ l ]
<operator>.subtraction JXPO [ i ] - ( k - j + 1 )
<operator>.addition j + 2
<operator>.lessEqualsThan k <= JXPO [ i ]
<operator>.postIncrement k ++
<operator>.postIncrement l ++
<operator>.postIncrement m ++
<operator>.addition k - j + 1
<operator>.subtraction k - 1
<operator>.addition j + 2
<operator>.assignment k = j + 2
<operator>.assignment KGJM [ i ] [ k - 1 ] = KGJM [ i ] [ k ]
<operator>.assignment l = k + 1
<operator>.assignment m = j
<operator>.subtraction k - j
<operator>.addition j + 2
<operator>.addition k + 1
<operator>.addition j + 2
<operator>.subtraction k - 1
<operator>.addressOf & ILRDWNW
<operator>.addressOf & PPUQR
<operator>.addressOf & JXPO [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.addressOf & EUPYXNMU [ 1 ]
<operator>.addressOf & EUPYXNMU [ 2 ]
<operator>.addressOf & EUPYXNMU [ 3 ]
<operator>.addressOf & FCRVVB [ 1 ]
<operator>.addressOf & FCRVVB [ 2 ]
<operator>.addressOf & KGJM [ i ] [ j ]
<operator>.indirectIndexAccess EUPYXNMU [ 1 ]
<operator>.indirectIndexAccess EUPYXNMU [ 2 ]
<operator>.indirectIndexAccess EUPYXNMU [ 3 ]
<operator>.indirectIndexAccess FCRVVB [ 1 ]
<operator>.indirectIndexAccess FCRVVB [ 2 ]
<operator>.indirectIndexAccess KGJM [ i ] [ j ]
<operator>.indirectIndexAccess KGJM [ i ] [ j ]
<operator>.indirectIndexAccess EUPYXNMU [ 1 ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ j ]
<operator>.indirectIndexAccess KGJM [ i ] [ j + 1 ]
<operator>.indirectIndexAccess EUPYXNMU [ 2 ]
<operator>.indirectIndexAccess KGJM [ i ] [ j ]
<operator>.indirectIndexAccess FCRVVB [ 1 ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ j ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ j + 1 ]
<operator>.indirectIndexAccess EUPYXNMU [ 3 ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ j ]
<operator>.indirectIndexAccess EUPYXNMU [ 2 ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ k - 1 ]
<operator>.indirectIndexAccess KGJM [ i ] [ k ]
<operator>.indirectIndexAccess KGJM [ i ] [ j + 1 ]
<operator>.indirectIndexAccess EUPYXNMU [ 1 ]
<operator>.indirectIndexAccess KGJM [ i ] [ j ]
<operator>.indirectIndexAccess FCRVVB [ 2 ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ j + 1 ]
<operator>.indirectIndexAccess EUPYXNMU [ 3 ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ j + 1 ]
<operator>.indirectIndexAccess EUPYXNMU [ 1 ]
<operator>.indirectIndexAccess KGJM [ i ] [ k ]
<operator>.indirectIndexAccess FCRVVB [ 2 ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ k - 1 ]
<operator>.indirectIndexAccess KGJM [ i ] [ k ]
<operator>.indirectIndexAccess KGJM [ i ] [ j + 2 ]
<operator>.indirectIndexAccess EUPYXNMU [ 2 ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ j + 2 ]
<operator>.indirectIndexAccess EUPYXNMU [ 3 ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ j + 1 ]
<operator>.indirectIndexAccess EUPYXNMU [ 2 ]
<operator>.indirectIndexAccess KGJM [ i ] [ m ]
<operator>.indirectIndexAccess KGJM [ i ] [ l ]
<operator>.indirectIndexAccess KGJM [ i ] [ k ]
<operator>.indirectIndexAccess FCRVVB [ 1 ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ k - 1 ]
<operator>.indirectIndexAccess KGJM [ i ] [ k ]
<operator>.indirectIndexAccess KGJM [ i ] [ j + 2 ]
<operator>.indirectIndexAccess EUPYXNMU [ 1 ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ j + 2 ]
<operator>.indirectIndexAccess EUPYXNMU [ 3 ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ m ]
<operator>.indirectIndexAccess KGJM [ i ] [ l ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess JXPO [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ] [ k - 1 ]
<operator>.indirectIndexAccess KGJM [ i ] [ k ]
<operator>.indirectIndexAccess KGJM [ i ]
<operator>.indirectIndexAccess KGJM [ i ]
>>>PDG&254 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->43 0->45 0->46 0->47 0->49 0->50 0->51 0->52 0->53 0->54 0->57 0->59 0->61 0->62 0->63 0->65 0->67 0->68 0->69 0->70 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->81 0->83 0->84 0->85 0->87 0->88 0->89 0->91 0->93 0->94 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->104 0->105 0->106 0->107 0->108 0->111 0->112 0->113 0->114 0->116 0->117 0->119 0->120 0->121 0->122 0->123 0->125 0->126 0->127 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->136 0->137 0->138 0->139 0->140 0->141 0->142 2->1 2->1 2->4 2->18 3->1 3->1 3->6 3->8 4->1 4->1 5->1 6->6 6->7 6->7 6->8 6->13 6->14 6->15 6->16 6->23 6->25 6->29 6->30 6->31 6->32 6->34 6->36 6->143 6->144 6->145 6->146 6->147 6->148 6->150 6->151 6->152 6->153 6->154 6->156 6->157 6->158 6->159 6->160 7->1 7->6 8->1 8->1 8->1 8->8 8->9 8->18 8->18 8->19 8->20 8->27 8->35 8->149 9->1 9->8 10->5 11->2 11->2 12->6 13->1 13->1 13->1 13->38 14->1 14->1 15->1 15->1 16->1 16->1 16->23 16->25 16->27 16->39 16->46 16->49 16->62 16->68 16->81 16->88 16->93 16->97 16->114 16->120 16->125 16->127 17->1 17->8 18->1 18->9 18->19 19->1 19->20 19->40 19->43 20->1 20->4 20->18 23->23 23->24 23->24 23->25 23->33 23->147 23->155 23->161 23->165 24->1 24->23 25->1 25->1 25->1 25->16 25->23 25->25 25->26 25->26 25->27 25->37 25->38 25->49 25->51 25->53 25->54 25->57 25->59 25->65 25->67 25->68 25->70 25->74 25->77 25->78 25->81 25->83 25->84 25->85 25->91 25->94 25->96 25->97 25->102 25->107 25->108 25->112 25->113 25->114 25->116 25->117 25->123 25->126 25->127 25->133 25->134 25->137 25->138 25->139 25->141 25->148 25->162 25->163 25->166 26->1 26->25 27->1 27->1 27->1 27->27 27->28 27->39 27->39 27->39 27->149 27->164 28->1 28->27 29->1 29->1 29->13 29->14 30->1 30->1 30->1 30->1 30->37 30->41 30->44 30->48 30->56 30->60 30->64 30->80 30->86 30->90 30->110 30->118 31->1 31->1 31->1 31->42 31->58 31->66 31->95 32->23 33->1 33->1 33->37 33->40 33->42 33->43 33->48 33->58 34->1 34->25 35->1 35->27 36->1 36->13 36->15 36->29 37->1 37->1 37->1 37->30 37->33 37->40 37->41 37->42 37->43 37->48 37->48 37->53 37->56 37->64 37->168 37->169 37->174 37->178 37->179 37->184 38->1 38->1 38->42 38->170 38->171 38->180 39->1 39->27 39->28 39->40 39->43 39->167 39->172 39->173 39->181 40->1 40->1 40->20 40->43 40->43 41->1 41->1 41->1 41->30 41->44 41->45 41->46 41->47 41->48 41->49 41->54 41->56 41->59 41->64 41->67 41->175 41->176 41->177 41->182 41->183 42->1 42->1 42->1 42->31 42->33 42->37 42->40 42->43 42->51 42->57 42->58 42->58 42->65 42->70 42->95 42->189 42->190 42->201 43->1 43->1 43->20 43->40 43->40 44->1 44->1 44->1 44->41 44->56 44->64 45->1 45->26 45->51 45->57 45->65 45->70 45->74 45->83 45->91 45->94 45->102 45->112 45->113 45->123 45->137 45->138 46->1 46->25 46->81 46->114 47->1 47->38 48->1 48->1 48->1 48->30 48->33 48->37 48->40 48->41 48->42 48->43 48->56 48->64 48->77 48->80 48->85 48->90 48->187 48->188 48->193 48->197 48->198 48->204 49->1 49->1 49->46 49->49 49->50 49->55 49->76 49->76 49->183 49->185 49->186 49->191 49->192 50->1 50->49 51->1 51->1 51->1 51->52 51->66 51->91 51->111 51->113 51->122 51->199 51->200 51->205 52->1 52->51 54->1 54->1 54->49 55->1 55->1 55->1 56->1 56->1 56->1 56->30 56->37 56->41 56->60 56->61 56->62 56->63 56->64 56->68 56->78 56->84 56->96 56->194 56->195 56->196 56->202 56->203 57->1 57->1 57->51 58->1 58->1 58->1 58->31 58->33 58->37 58->40 58->43 58->66 58->74 58->83 58->94 58->102 60->1 60->1 60->1 60->41 60->56 60->64 61->1 61->26 61->51 61->57 61->65 61->70 61->74 61->83 61->91 61->94 61->102 61->112 61->113 61->123 61->137 61->138 62->1 62->25 62->81 62->114 63->1 63->38 64->1 64->1 64->1 64->30 64->37 64->41 64->56 64->80 64->90 64->90 64->107 64->110 64->117 64->209 64->210 64->215 64->219 64->220 64->227 66->1 66->1 66->1 66->31 66->51 66->52 66->55 66->58 66->65 66->71 66->72 66->73 66->79 66->81 66->91 66->93 66->95 66->101 66->109 66->111 66->112 66->113 66->122 66->135 66->206 66->211 66->212 68->1 68->1 68->62 68->68 68->69 68->79 68->106 68->106 68->203 68->207 68->208 68->213 68->214 69->1 69->68 71->1 71->1 71->25 72->1 72->26 73->1 73->1 73->38 74->1 74->1 74->1 74->75 74->95 74->123 74->136 74->138 74->140 74->223 74->224 74->230 75->1 75->74 76->50 78->1 78->1 78->68 79->1 79->1 79->1 80->1 80->1 80->1 80->30 80->41 80->48 80->86 80->87 80->88 80->89 80->97 80->108 80->110 80->116 80->126 80->216 80->217 80->218 80->225 80->226 81->1 81->1 81->81 81->82 81->92 81->93 81->99 81->99 81->100 81->211 81->221 81->222 81->228 81->229 82->1 82->1 82->1 83->1 83->1 83->74 86->1 86->1 86->1 86->80 86->110 87->1 87->26 87->51 87->57 87->65 87->70 87->74 87->83 87->91 87->94 87->102 87->112 87->113 87->123 87->137 87->138 88->1 88->25 88->81 88->114 89->1 89->38 90->1 90->1 90->1 90->30 90->41 90->41 90->48 90->56 90->64 90->110 90->133 90->234 90->235 90->240 91->1 91->1 91->1 92->1 92->1 92->1 93->1 93->71 93->71 95->1 95->1 95->1 95->31 95->42 95->55 95->66 95->74 95->75 95->79 95->94 95->103 95->104 95->105 95->109 95->114 95->123 95->125 95->131 95->135 95->136 95->137 95->138 95->140 95->231 95->236 95->237 97->1 97->1 97->88 97->97 97->98 97->109 97->132 97->132 97->226 97->232 97->233 97->238 97->239 98->1 98->97 99->81 99->82 100->1 100->82 101->1 103->1 103->1 103->25 104->1 104->26 105->1 105->1 105->38 106->69 108->1 108->1 108->97 109->1 109->1 109->1 110->1 110->1 110->1 110->30 110->37 110->80 110->118 110->119 110->120 110->121 110->127 110->134 110->139 110->141 110->241 110->242 110->243 110->246 110->247 111->1 111->81 111->91 112->1 112->91 112->100 113->1 113->93 113->93 113->101 113->101 114->1 114->1 114->114 114->115 114->124 114->125 114->129 114->129 114->130 114->236 114->244 114->245 114->248 114->249 115->1 115->1 115->1 118->1 118->1 118->1 118->80 118->110 119->1 119->26 119->51 119->57 119->65 119->70 119->74 119->83 119->91 119->94 119->102 119->112 119->113 119->123 119->137 119->138 120->1 120->25 120->81 120->114 121->1 121->38 123->1 123->1 123->1 124->1 124->1 124->1 125->1 125->103 125->103 127->1 127->1 127->120 127->127 127->128 127->135 127->142 127->142 127->247 127->250 127->251 127->252 127->253 128->1 128->127 129->114 129->115 130->1 130->115 131->1 132->98 134->1 134->1 134->127 135->1 135->1 135->1 136->1 136->114 136->123 137->1 137->123 137->130 138->1 138->125 138->125 138->131 138->131 142->128
>>>Token int main ( ) { THDQ * KBN , * PKVM ; int i , j , k , l , m , MLCAJIL ; int ILRDWNW , PPUQR ; int JLYOEMQS ; PKVM = CBORQ ( " " , " " ) ; ATQLE ( " " , & MLCAJIL ) ; for ( i = 1 ; i <= MLCAJIL ; i ++ ) { char EUPYXNMU [ 4 ] ; char FCRVVB [ 3 ] ; JLYOEMQS = ILRDWNW = PPUQR = 0 ; ATQLE ( " " , & ILRDWNW ) ; if ( ILRDWNW ) { ATQLE ( " " , & EUPYXNMU [ 1 ] , & EUPYXNMU [ 2 ] , & EUPYXNMU [ 3 ] ) ; } ATQLE ( " " , & PPUQR ) ; if ( PPUQR ) { ATQLE ( " " , & FCRVVB [ 1 ] , & FCRVVB [ 2 ] ) ; } ATQLE ( " " , & JXPO [ i ] ) ; for ( j = 1 ; j <= JXPO [ i ] ; j ++ ) { ATQLE ( " " , & KGJM [ i ] [ j ] ) ; } for ( j = 1 ; j <= JXPO [ i ] ; j ++ ) { if ( KGJM [ i ] [ j ] == EUPYXNMU [ 1 ] ) { if ( KGJM [ i ] [ j + 1 ] == EUPYXNMU [ 2 ] ) { KGJM [ i ] [ j + 1 ] = EUPYXNMU [ 3 ] ; for ( k = j + 1 ; k <= JXPO [ i ] ; k ++ ) { KGJM [ i ] [ k - 1 ] = KGJM [ i ] [ k ] ; } j = 0 ; JXPO [ i ] -= 1 ; JLYOEMQS = 1 ; } } else if ( KGJM [ i ] [ j ] == EUPYXNMU [ 2 ] ) { if ( KGJM [ i ] [ j + 1 ] == EUPYXNMU [ 1 ] ) { KGJM [ i ] [ j + 1 ] = EUPYXNMU [ 3 ] ; for ( k = j + 1 ; k <= JXPO [ i ] ; k ++ ) { KGJM [ i ] [ k - 1 ] = KGJM [ i ] [ k ] ; } j = 0 ; JXPO [ i ] -= 1 ; JLYOEMQS = 1 ; } } else if ( KGJM [ i ] [ j + 1 ] == EUPYXNMU [ 1 ] ) { if ( KGJM [ i ] [ j + 2 ] == EUPYXNMU [ 2 ] ) { KGJM [ i ] [ j + 2 ] = EUPYXNMU [ 3 ] ; for ( k = j + 2 ; k <= JXPO [ i ] ; k ++ ) { KGJM [ i ] [ k - 1 ] = KGJM [ i ] [ k ] ; } j = 0 ; JXPO [ i ] -= 1 ; JLYOEMQS = 1 ; } } else if ( KGJM [ i ] [ j + 1 ] == EUPYXNMU [ 2 ] ) { if ( KGJM [ i ] [ j + 2 ] == EUPYXNMU [ 1 ] ) { KGJM [ i ] [ j + 2 ] = EUPYXNMU [ 3 ] ; for ( k = j + 2 ; k <= JXPO [ i ] ; k ++ ) { KGJM [ i ] [ k - 1 ] = KGJM [ i ] [ k ] ; } j = 0 ; JXPO [ i ] -= 1 ; JLYOEMQS = 1 ; } } if ( ! JLYOEMQS ) { if ( KGJM [ i ] [ j ] == FCRVVB [ 1 ] ) { for ( k = j + 1 ; k <= j + 2 ; k ++ ) { if ( KGJM [ i ] [ k ] == FCRVVB [ 2 ] ) { for ( l = k + 1 , m = j ; l <= JXPO [ i ] ; l ++ , m ++ ) { KGJM [ i ] [ m ] = KGJM [ i ] [ l ] ; } JXPO [ i ] = JXPO [ i ] - ( k - j + 1 ) ; j = 0 ; JLYOEMQS = 1 ; break ; } } } else if ( KGJM [ i ] [ j ] == FCRVVB [ 2 ] ) { for ( k = j + 1 ; k <= j + 2 ; k ++ ) { if ( KGJM [ i ] [ k ] == FCRVVB [ 1 ] ) { for ( l = k + 1 , m = j ; l <= JXPO [ i ] ; l ++ , m ++ ) { KGJM [ i ] [ m ] = KGJM [ i ] [ l ] ; } JXPO [ i ] = JXPO [ i ] - ( k - j + 1 ) ; j = 0 ; JLYOEMQS = 1 ; break ; } } } } } } for ( i = 1 ; i <= MLCAJIL ; i ++ ) { fprintf ( PKVM , " " , i ) ; fprintf ( PKVM , " " ) ; for ( j = 1 ; j <= JXPO [ i ] ; j ++ ) { if ( j == JXPO [ i ] ) fprintf ( PKVM , " " , KGJM [ i ] [ j ] ) ; else fprintf ( PKVM , " " , KGJM [ i ] [ j ] ) ; } fprintf ( PKVM , " \n " ) ; } KXGBBA ( PKVM ) ; return 0 ; }
>>>Func
METHOD read
METHOD_RETURN void
OHUSM OHUSM ( "%d" , & QSC )
OHUSM OHUSM ( "%d" , & QSC )
OHUSM OHUSM ( "%d %s" , & n , FKRBHXAJ )
<operator>.lessThan i < UTDYAFRPN
<operator>.postIncrement i ++
<operator>.lessThan i < QSC
<operator>.postIncrement i ++
<operator>.lessThan i < QSC
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.lessThan j < UTDYAFRPN
<operator>.postIncrement j ++
<operator>.assignment QOLWQLL [ i ] [ j ] = QLEJQRU [ i ] [ j ] = 0
<operator>.assignment i = 0
OHUSM OHUSM ( "%s" , MIX )
<operator>.assignment QOLWQLL [ ( int ) MIX [ 0 ] ] [ ( int ) MIX [ 1 ] ] = QOLWQLL [ ( int ) MIX [ 1 ] ] [ ( int ) MIX [ 0 ] ] = MIX [ 2 ]
<operator>.assignment i = 0
OHUSM OHUSM ( "%s" , MIX )
<operator>.assignment QLEJQRU [ ( int ) MIX [ 0 ] ] [ ( int ) MIX [ 1 ] ] = QLEJQRU [ ( int ) MIX [ 1 ] ] [ ( int ) MIX [ 0 ] ] = 1
<operator>.assignment j = 0
<operator>.assignment QLEJQRU [ i ] [ j ] = 0
<operator>.assignment QOLWQLL [ ( int ) MIX [ 1 ] ] [ ( int ) MIX [ 0 ] ] = MIX [ 2 ]
<operator>.assignment QLEJQRU [ ( int ) MIX [ 1 ] ] [ ( int ) MIX [ 0 ] ] = 1
<operator>.cast ( int ) MIX [ 1 ]
<operator>.cast ( int ) MIX [ 1 ]
<operator>.cast ( int ) MIX [ 0 ]
<operator>.cast ( int ) MIX [ 0 ]
<operator>.cast ( int ) MIX [ 0 ]
<operator>.cast ( int ) MIX [ 0 ]
<operator>.cast ( int ) MIX [ 1 ]
<operator>.cast ( int ) MIX [ 1 ]
<operator>.indirectIndexAccess QOLWQLL [ i ] [ j ]
<operator>.indirectIndexAccess QOLWQLL [ ( int ) MIX [ 0 ] ] [ ( int ) MIX [ 1 ] ]
<operator>.indirectIndexAccess QLEJQRU [ ( int ) MIX [ 0 ] ] [ ( int ) MIX [ 1 ] ]
<operator>.indirectIndexAccess QOLWQLL [ i ]
<operator>.indirectIndexAccess QLEJQRU [ i ] [ j ]
<operator>.indirectIndexAccess QOLWQLL [ ( int ) MIX [ 0 ] ]
<operator>.indirectIndexAccess QOLWQLL [ ( int ) MIX [ 1 ] ] [ ( int ) MIX [ 0 ] ]
<operator>.indirectIndexAccess MIX [ 2 ]
<operator>.indirectIndexAccess QLEJQRU [ ( int ) MIX [ 0 ] ]
<operator>.indirectIndexAccess QLEJQRU [ ( int ) MIX [ 1 ] ] [ ( int ) MIX [ 0 ] ]
<operator>.indirectIndexAccess QLEJQRU [ i ]
UNKNOWN int int
<operator>.indirectIndexAccess MIX [ 1 ]
<operator>.indirectIndexAccess QOLWQLL [ ( int ) MIX [ 1 ] ]
UNKNOWN int int
<operator>.indirectIndexAccess MIX [ 1 ]
<operator>.indirectIndexAccess QLEJQRU [ ( int ) MIX [ 1 ] ]
UNKNOWN int int
<operator>.indirectIndexAccess MIX [ 0 ]
UNKNOWN int int
<operator>.indirectIndexAccess MIX [ 0 ]
UNKNOWN int int
<operator>.indirectIndexAccess MIX [ 0 ]
UNKNOWN int int
<operator>.indirectIndexAccess MIX [ 0 ]
UNKNOWN int int
<operator>.indirectIndexAccess MIX [ 1 ]
UNKNOWN int int
<operator>.indirectIndexAccess MIX [ 1 ]
>>>PDG&62 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->24 2->3 2->7 2->9 3->1 3->1 3->9 4->1 4->1 4->1 5->1 5->1 5->5 5->6 5->6 5->12 5->12 5->21 6->1 6->5 7->3 7->7 7->8 7->8 7->9 7->16 7->17 7->23 7->25 7->27 7->28 7->31 7->34 7->38 7->39 7->40 7->44 7->45 7->46 7->50 7->51 7->52 7->53 7->58 7->59 8->1 8->7 9->1 9->1 9->1 9->9 9->10 9->10 9->19 9->20 9->24 9->26 9->29 9->30 9->32 9->35 9->41 9->42 9->47 9->48 9->49 9->54 9->55 9->56 9->57 9->60 9->61 10->1 10->9 11->5 12->1 12->1 12->5 12->12 12->13 12->13 12->14 12->22 12->33 12->36 12->37 12->43 13->1 13->12 14->1 14->1 14->1 15->7 16->1 16->1 16->17 16->19 16->23 16->25 16->26 16->27 16->28 16->29 16->30 16->31 16->32 17->1 17->1 17->1 18->1 18->9 19->1 19->1 19->26 19->29 19->30 19->32 20->1 20->1 20->1 21->1 21->12 22->1 22->14 23->1 23->1 23->17 24->1 24->20 28->1 30->1 31->1 32->1
>>>Token void read ( ) { int QSC , i , j ; char MIX [ PXDDIRF ] ; for ( i = 0 ; i < UTDYAFRPN ; i ++ ) for ( j = 0 ; j < UTDYAFRPN ; j ++ ) QOLWQLL [ i ] [ j ] = QLEJQRU [ i ] [ j ] = 0 ; OHUSM ( " " , & QSC ) ; for ( i = 0 ; i < QSC ; i ++ ) { OHUSM ( " " , MIX ) ; QOLWQLL [ ( int ) MIX [ 0 ] ] [ ( int ) MIX [ 1 ] ] = QOLWQLL [ ( int ) MIX [ 1 ] ] [ ( int ) MIX [ 0 ] ] = MIX [ 2 ] ; } OHUSM ( " " , & QSC ) ; for ( i = 0 ; i < QSC ; i ++ ) { OHUSM ( " " , MIX ) ; QLEJQRU [ ( int ) MIX [ 0 ] ] [ ( int ) MIX [ 1 ] ] = QLEJQRU [ ( int ) MIX [ 1 ] ] [ ( int ) MIX [ 0 ] ] = 1 ; } OHUSM ( " " , & n , FKRBHXAJ ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment LGKDX = DNCTA ( argv [ 1 ] , "r" )
<operator>.assignment QJUGNA = DNCTA ( argv [ 2 ] , "w" )
WANAQP WANAQP ( LGKDX , "%d " , & T )
HWAGEQ HWAGEQ ( LGKDX )
HWAGEQ HWAGEQ ( QJUGNA )
RETURN return 0 ; return 0 ;
<operator>.equals LGKDX == NULL
<operator>.equals QJUGNA == NULL
<operator>.lessThan i < T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
DNCTA DNCTA ( argv [ 1 ] , "r" )
perror perror ( argv [ 1 ] )
exit exit ( 1 )
DNCTA DNCTA ( argv [ 2 ] , "w" )
perror perror ( argv [ 2 ] )
exit exit ( 1 )
<operator>.assignment i = 0
WANAQP WANAQP ( LGKDX , "%d " , & C )
WANAQP WANAQP ( LGKDX , "%d " , & D )
WANAQP WANAQP ( LGKDX , "%d " , & N )
WANAQP WANAQP ( LGKDX , "%s " , AJW )
<operator>.assignment OAEY = SXWSBMUTDBM ( EJYU , N , RKE )
fprintf fprintf ( QJUGNA   "Case #%d: [%s]\n"   i + 1   EQBXHLGEXCBN ( RKE , OAEY , rs ) )
<operator>.lessThan j < 8
<operator>.postIncrement j ++
<operator>.lessThan j < C
<operator>.postIncrement j ++
<operator>.lessThan j < 8
<operator>.postIncrement j ++
<operator>.lessThan j < D
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.assignment EJYU [ j ] = TOIHWKTUOFTK ( AJW [ j ] )
<operator>.assignment j = 0
<operator>.lessThan k < 8
<operator>.postIncrement k ++
<operator>.assignment GRYOO [ j ] [ k ] = - 1
<operator>.assignment j = 0
WANAQP WANAQP ( LGKDX , "%s " , JGWR [ j ] )
<operator>.assignment s1 = TOIHWKTUOFTK ( JGWR [ j ] [ 0 ] )
<operator>.assignment s2 = TOIHWKTUOFTK ( JGWR [ j ] [ 1 ] )
<operator>.assignment d = JGWR [ j ] [ 2 ]
<operator>.assignment GRYOO [ s1 ] [ s2 ] = d
<operator>.assignment GRYOO [ s2 ] [ s1 ] = d
<operator>.assignment j = 0
<operator>.lessThan k < 8
<operator>.postIncrement k ++
<operator>.assignment WGQCW [ j ] [ k ] = 0
<operator>.assignment j = 0
WANAQP WANAQP ( LGKDX , "%s " , YSNG [ j ] )
<operator>.assignment s1 = TOIHWKTUOFTK ( YSNG [ j ] [ 0 ] )
<operator>.assignment s2 = TOIHWKTUOFTK ( YSNG [ j ] [ 1 ] )
<operator>.assignment WGQCW [ s1 ] [ s2 ] = 1
<operator>.assignment WGQCW [ s2 ] [ s1 ] = 1
<operator>.assignment j = 0
SXWSBMUTDBM SXWSBMUTDBM ( EJYU , N , RKE )
<operator>.addition i + 1
EQBXHLGEXCBN EQBXHLGEXCBN ( RKE , OAEY , rs )
<operator>.assignment k = 0
<operator>.assignment k = 0
TOIHWKTUOFTK TOIHWKTUOFTK ( AJW [ j ] )
<operator>.minus - 1
TOIHWKTUOFTK TOIHWKTUOFTK ( JGWR [ j ] [ 0 ] )
TOIHWKTUOFTK TOIHWKTUOFTK ( JGWR [ j ] [ 1 ] )
TOIHWKTUOFTK TOIHWKTUOFTK ( YSNG [ j ] [ 0 ] )
TOIHWKTUOFTK TOIHWKTUOFTK ( YSNG [ j ] [ 1 ] )
<operator>.indirectIndexAccess argv [ 1 ]
<operator>.indirectIndexAccess argv [ 2 ]
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.indirectIndexAccess EJYU [ j ]
<operator>.indirectIndexAccess GRYOO [ j ] [ k ]
<operator>.indirectIndexAccess JGWR [ j ]
<operator>.indirectIndexAccess JGWR [ j ] [ 2 ]
<operator>.indirectIndexAccess GRYOO [ s1 ] [ s2 ]
<operator>.indirectIndexAccess GRYOO [ s2 ] [ s1 ]
<operator>.indirectIndexAccess WGQCW [ j ] [ k ]
<operator>.indirectIndexAccess YSNG [ j ]
<operator>.indirectIndexAccess WGQCW [ s1 ] [ s2 ]
<operator>.indirectIndexAccess WGQCW [ s2 ] [ s1 ]
<operator>.indirectIndexAccess AJW [ j ]
<operator>.indirectIndexAccess GRYOO [ j ]
<operator>.indirectIndexAccess JGWR [ j ] [ 0 ]
<operator>.indirectIndexAccess JGWR [ j ] [ 1 ]
<operator>.indirectIndexAccess JGWR [ j ]
<operator>.indirectIndexAccess GRYOO [ s1 ]
<operator>.indirectIndexAccess GRYOO [ s2 ]
<operator>.indirectIndexAccess WGQCW [ j ]
<operator>.indirectIndexAccess YSNG [ j ] [ 0 ]
<operator>.indirectIndexAccess YSNG [ j ] [ 1 ]
<operator>.indirectIndexAccess WGQCW [ s1 ]
<operator>.indirectIndexAccess WGQCW [ s2 ]
<operator>.indirectIndexAccess JGWR [ j ]
<operator>.indirectIndexAccess JGWR [ j ]
<operator>.indirectIndexAccess YSNG [ j ]
<operator>.indirectIndexAccess YSNG [ j ]
>>>PDG&103 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->41 0->43 0->44 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->67 2->1 3->1 3->15 3->16 3->18 3->19 4->1 4->1 4->10 5->1 5->1 5->11 6->1 6->1 6->7 6->12 6->22 7->1 7->1 8->1 8->1 9->1 10->1 10->6 10->11 10->16 10->17 10->72 11->1 11->1 11->8 11->19 11->20 11->27 11->73 12->1 12->1 12->1 12->12 12->13 12->13 12->22 12->23 12->24 12->25 12->26 12->27 12->27 12->28 12->30 12->32 12->34 12->36 12->39 12->43 12->50 12->54 12->60 12->61 12->62 12->62 12->63 12->74 12->75 12->76 13->1 13->12 14->9 15->1 15->4 15->4 15->16 16->1 16->1 18->1 18->5 18->5 18->19 19->1 19->1 21->1 21->12 22->1 22->1 22->23 22->30 22->44 23->1 23->1 23->24 23->34 23->55 24->1 24->1 24->25 24->36 24->61 25->1 25->1 25->7 25->22 25->66 26->1 26->1 26->63 27->1 27->1 27->1 27->8 28->28 28->29 28->29 28->40 28->64 29->1 29->28 30->1 30->1 30->22 30->30 30->31 30->31 30->44 30->45 30->46 30->47 30->48 30->49 30->68 30->69 30->79 30->80 30->81 30->82 30->89 30->90 30->91 30->92 30->93 30->99 30->100 31->1 31->30 32->1 32->32 32->33 32->33 32->51 32->65 33->1 33->32 34->1 34->1 34->23 34->34 34->35 34->35 34->55 34->56 34->57 34->58 34->59 34->70 34->71 34->84 34->85 34->86 34->95 34->96 34->97 34->98 34->101 34->102 35->1 35->34 36->1 36->1 36->36 36->37 36->37 36->38 36->61 36->66 36->77 36->87 37->1 37->36 38->1 38->1 38->1 38->61 39->28 40->1 40->1 40->40 40->41 40->41 40->42 40->67 40->78 40->88 41->1 41->40 42->1 42->1 42->1 43->30 44->1 44->1 44->23 45->1 45->1 45->1 46->1 46->1 46->1 47->1 47->1 47->48 47->49 48->1 48->1 49->1 49->1 49->1 50->32 51->1 51->1 51->51 51->52 51->52 51->53 51->83 51->94 52->1 52->51 53->1 53->1 54->34 55->1 55->1 55->24 56->1 56->1 56->1 57->1 57->1 57->1 58->1 58->1 59->1 59->1 60->1 60->36 61->1 61->1 61->24 61->26 61->26 61->26 61->36 61->63 63->1 63->1 63->1 63->27 63->27 63->27 63->61 64->1 64->40 65->1 65->51 66->1 66->25 66->38 67->42 68->1 68->44 68->45 69->1 69->44 69->46 70->1 70->55 70->56 71->1 71->55 71->57
>>>Token int main ( int argc , char * * argv ) { WYQG * LGKDX , * QJUGNA ; int T , C , D , N ; int i , j , k ; int OAEY ; char rs [ 700 ] ; char s1 , s2 , d ; char JGWR [ 37 ] [ 4 ] ; char YSNG [ 29 ] [ 3 ] ; char AJW [ 101 ] ; char EJYU [ 101 ] ; char RKE [ 101 ] ; LGKDX = DNCTA ( argv [ 1 ] , " " ) ; if ( LGKDX == NULL ) { perror ( argv [ 1 ] ) ; exit ( 1 ) ; } QJUGNA = DNCTA ( argv [ 2 ] , " " ) ; if ( QJUGNA == NULL ) { perror ( argv [ 2 ] ) ; exit ( 1 ) ; } WANAQP ( LGKDX , " " , & T ) ; for ( i = 0 ; i < T ; i ++ ) { for ( j = 0 ; j < 8 ; j ++ ) for ( k = 0 ; k < 8 ; k ++ ) GRYOO [ j ] [ k ] = - 1 ; WANAQP ( LGKDX , " " , & C ) ; for ( j = 0 ; j < C ; j ++ ) { WANAQP ( LGKDX , " " , JGWR [ j ] ) ; s1 = TOIHWKTUOFTK ( JGWR [ j ] [ 0 ] ) ; s2 = TOIHWKTUOFTK ( JGWR [ j ] [ 1 ] ) ; d = JGWR [ j ] [ 2 ] ; GRYOO [ s1 ] [ s2 ] = d ; GRYOO [ s2 ] [ s1 ] = d ; } for ( j = 0 ; j < 8 ; j ++ ) for ( k = 0 ; k < 8 ; k ++ ) WGQCW [ j ] [ k ] = 0 ; WANAQP ( LGKDX , " " , & D ) ; for ( j = 0 ; j < D ; j ++ ) { WANAQP ( LGKDX , " " , YSNG [ j ] ) ; s1 = TOIHWKTUOFTK ( YSNG [ j ] [ 0 ] ) ; s2 = TOIHWKTUOFTK ( YSNG [ j ] [ 1 ] ) ; WGQCW [ s1 ] [ s2 ] = 1 ; WGQCW [ s2 ] [ s1 ] = 1 ; } WANAQP ( LGKDX , " " , & N ) ; WANAQP ( LGKDX , " " , AJW ) ; for ( j = 0 ; j < N ; j ++ ) EJYU [ j ] = TOIHWKTUOFTK ( AJW [ j ] ) ; OAEY = SXWSBMUTDBM ( EJYU , N , RKE ) ; fprintf ( QJUGNA , " \n " , i + 1 , EQBXHLGEXCBN ( RKE , OAEY , rs ) ) ; } HWAGEQ ( LGKDX ) ; HWAGEQ ( QJUGNA ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf ( "Enter number of vertices: " )
APQAJ APQAJ ( "%d" , & V )
printf printf ( "Enter number of edges: " )
APQAJ APQAJ ( "%d" , & E )
RQPMTAHHERT RQPMTAHHERT ( & G , V , E )
printf printf ( "\nEnter source:" )
APQAJ APQAJ ( "%d" , & ISNC )
GYMLNXGWXXO GYMLNXGWXXO ( & G , ISNC )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < E
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
printf printf ( "\nEdge %d \nEnter source: " , i + 1 )
APQAJ APQAJ ( "%d" , & JKQ )
printf printf ( "Enter destination: " )
APQAJ APQAJ ( "%d" , & LML )
printf printf ( "Enter weight: " )
APQAJ APQAJ ( "%d" , & AWHYRV )
UFJIFGQ UFJIFGQ ( & G , JKQ , LML , AWHYRV )
<operator>.addition i + 1
<operator>.addressOf & JKQ
<operator>.addressOf & LML
<operator>.addressOf & AWHYRV
<operator>.addressOf & G
>>>PDG&27 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 2->1 3->1 3->1 3->6 4->1 5->1 5->1 5->6 5->11 6->1 6->1 6->9 6->11 6->21 7->1 8->1 8->1 8->9 9->1 9->1 9->1 10->1 11->1 11->1 11->1 11->11 11->12 11->12 11->15 11->15 11->16 11->17 11->18 11->19 11->20 11->21 11->22 11->22 11->23 11->24 11->25 11->26 12->1 12->11 13->10 14->1 14->11 15->1 15->1 16->1 16->1 16->21 17->1 18->1 18->1 18->21 19->1 20->1 20->1 20->21 21->1 21->1 21->1 21->1 21->9 21->16 21->18 21->20
>>>Token int main ( ) { int V , E , ISNC ; int JKQ , LML , AWHYRV ; struct FOJTH G ; printf ( " " ) ; APQAJ ( " " , & V ) ; printf ( " " ) ; APQAJ ( " " , & E ) ; RQPMTAHHERT ( & G , V , E ) ; for ( int i = 0 ; i < E ; i ++ ) { printf ( " \n \n " , i + 1 ) ; APQAJ ( " " , & JKQ ) ; printf ( " " ) ; APQAJ ( " " , & LML ) ; printf ( " " ) ; APQAJ ( " " , & AWHYRV ) ; UFJIFGQ ( & G , JKQ , LML , AWHYRV ) ; } printf ( " \n " ) ; APQAJ ( " " , & ISNC ) ; GYMLNXGWXXO ( & G , ISNC ) ; return 0 ; }
>>>Func
METHOD THUMQOTLQFP
METHOD_RETURN void
PARAM int QCTB
assert assert ( 3 == VJUSQ ( "%lld %lld %lld\n" , & A , & B , & P0 ) )
<operator>.assignment D = B - A + 1
<operator>.assignment P = ( P0 > D ) ? D : P0
printf printf ( "Case #%d: %d\n" , QCTB , n )
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.assignment YXQN [ i ] = i
<operator>.lessThan p < D
<operator>.postIncrement p ++
<operator>.lessThan i < D
<operator>.postIncrement i ++
VHKSUDXP VHKSUDXP ( i )
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.equals 3 == VJUSQ ( "%lld %lld %lld\n" , & A , & B , & P0 )
<operator>.addition B - A + 1
<operator>.assignment i = 0
<operator>.conditional ( P0 > D ) ? D : P0
<operator>.assignment p = P
<operator>.assignment x = p - ( A % p )
VHKSUDXP VHKSUDXP ( x )
<operator>.assignment z = YXQN [ x ]
<operator>.assignment i = 0
<operator>.assignment i = n = 0
<operator>.equals YXQN [ i ] == i
VJUSQ VJUSQ ( "%lld %lld %lld\n" , & A , & B , & P0 )
<operator>.subtraction B - A
<operator>.greaterThan P0 > D
<operator>.logicalAnd p > 2 && ( p & 1 ) == 0
<operator>.lessEqualsThan f * f <= p
<operator>.assignmentPlus f += 2
<operator>.lessEqualsThan f * f <= p
<operator>.equals x == p
<operator>.lessThan y < D
<operator>.assignmentPlus y += p
<operator>.postIncrement n ++
<operator>.assignment f = 3
<operator>.equals p % f == 0
<operator>.subtraction p - ( A % p )
<operator>.assignment x = 0
<operator>.assignment y = x + p
VHKSUDXP VHKSUDXP ( y )
<operator>.assignment YXQN [ YXQN [ y ] ] = z
<operator>.assignment n = 0
<operator>.greaterThan p > 2
<operator>.equals ( p & 1 ) == 0
<operator>.multiplication f * f
<operator>.multiplication f * f
<operator>.modulo A % p
<operator>.and p & 1
<operator>.modulo p % f
<operator>.addition x + p
<operator>.indirectIndexAccess YXQN [ i ]
<operator>.indirectIndexAccess YXQN [ x ]
<operator>.indirectIndexAccess YXQN [ i ]
<operator>.indirectIndexAccess YXQN [ YXQN [ y ] ]
<operator>.indirectIndexAccess YXQN [ y ]
>>>PDG&60 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 2->6 3->1 3->1 4->1 4->1 4->7 5->1 5->1 5->21 6->1 6->1 6->1 7->7 7->8 7->8 7->9 7->9 7->30 7->55 8->1 8->7 9->1 9->1 9->27 10->1 10->1 10->10 10->11 10->12 10->31 10->36 10->47 10->47 11->1 11->10 12->12 12->13 12->14 12->14 12->15 13->1 13->12 14->1 14->13 15->1 15->1 15->1 15->15 15->16 15->27 15->27 15->57 16->1 16->15 17->1 17->3 17->3 18->1 19->7 20->1 20->1 21->1 21->1 21->10 22->1 22->1 22->35 23->1 23->43 23->54 24->1 24->1 24->1 24->45 25->1 25->12 26->1 26->1 26->15 27->1 27->1 27->16 27->38 28->1 28->1 28->1 28->5 28->17 28->17 28->17 28->17 28->20 28->29 28->29 28->30 28->51 29->1 29->1 29->4 29->4 29->18 29->18 29->51 30->5 30->5 30->10 30->20 30->20 31->1 31->1 31->1 31->32 31->34 31->39 31->49 31->50 32->34 32->40 32->53 32->53 33->1 33->49 34->1 34->1 34->11 34->22 34->23 34->24 34->35 34->36 34->41 34->43 34->51 34->51 34->54 34->56 35->1 35->11 35->23 35->37 35->42 35->43 35->54 36->1 36->1 36->10 36->36 36->37 36->44 36->44 36->45 36->58 36->59 37->1 37->36 38->1 38->6 39->1 39->49 40->1 40->1 40->32 40->33 40->49 41->1 41->22 41->22 41->35 42->1 42->23 43->1 43->1 43->36 44->1 44->37 45->1 45->1 45->1 46->6 46->26 46->38 47->11 47->31 47->31 47->32 47->48 47->52 47->52 48->1 48->31 48->31 49->32 49->50 49->53 50->1 50->34 51->1 51->41 51->41 52->11 52->32 52->48 52->48 53->32 53->33 53->34 53->40 53->40 53->50 54->1
>>>Token void THUMQOTLQFP ( int QCTB ) { long long A , B , P0 ; int D , p , f , P ; int i , n , x , y , z ; assert ( 3 == VJUSQ ( " \n " , & A , & B , & P0 ) ) ; D = B - A + 1 ; for ( i = 0 ; i < D ; i ++ ) YXQN [ i ] = i ; P = ( P0 > D ) ? D : P0 ; for ( p = P ; p < D ; p ++ ) { if ( p > 2 && ( p & 1 ) == 0 ) continue ; for ( f = 3 ; f * f <= p ; f += 2 ) if ( p % f == 0 ) break ; if ( f * f <= p ) continue ; x = p - ( A % p ) ; if ( x == p ) x = 0 ; VHKSUDXP ( x ) ; z = YXQN [ x ] ; for ( y = x + p ; y < D ; y += p ) { VHKSUDXP ( y ) ; YXQN [ YXQN [ y ] ] = z ; } } for ( i = 0 ; i < D ; i ++ ) VHKSUDXP ( i ) ; for ( i = n = 0 ; i < D ; i ++ ) if ( YXQN [ i ] == i ) { n ++ ; } printf ( " \n " , QCTB , n ) ; }
>>>Func
METHOD EVXUKNNMWQAJSLFCNCATRDKITJCPR
METHOD_RETURN PBNNQYTSIMO
PARAM QEWOCTY * RHNO
PARAM PBNNQYTSIMO * APBU
<operator>.assignment CGXPKAMCDYMW = APBU -> WWKDCWLL [ IGSFUPGRHIKXJCJQGD ]
<operator>.assignment IQODHTCVXVWSF = APBU -> WWKDCWLL [ GPHYEEYRHBOUOAEIHYA ]
<operator>.assignment EKIHLUHTMVY = NSHXDIIIRBQUHGEJKLIEULT ( CGXPKAMCDYMW )
<operator>.assignment TPBSQYPJGDSN = NSHXDIIIRBQUHGEJKLIEULT ( IQODHTCVXVWSF )
<operator>.assignment LHHBKC = APBU -> WWKDCWLL [ HESM ]
<operator>.assignment FSCXD = LHHBKC -> WWKDCWLL [ HESM ]
QAVUIDVKQPSPUDADWBVSI QAVUIDVKQPSPUDADWBVSI ( RHNO , LHHBKC , FSCXD )
CYTPKCVGPPYQNVBQRMKJHA CYTPKCVGPPYQNVBQRMKJHA ( LHHBKC -> HMAMJD )
RETURN return LHHBKC ; return LHHBKC ;
<operator>.logicalAnd CGXPKAMCDYMW == NULL && IQODHTCVXVWSF == NULL
<operator>.lessThan EKIHLUHTMVY < TPBSQYPJGDSN
<operator>.notEquals LHHBKC -> WWKDCWLL [ 1 - HESM ] != NULL
IDENTIFIER LHHBKC return LHHBKC ;
RETURN return NULL ; return NULL ;
NSHXDIIIRBQUHGEJKLIEULT NSHXDIIIRBQUHGEJKLIEULT ( CGXPKAMCDYMW )
NSHXDIIIRBQUHGEJKLIEULT NSHXDIIIRBQUHGEJKLIEULT ( IQODHTCVXVWSF )
<operator>.assignment HESM = GPHYEEYRHBOUOAEIHYA
<operator>.assignment LHHBKC = LHHBKC -> WWKDCWLL [ 1 - HESM ]
<operator>.equals CGXPKAMCDYMW == NULL
<operator>.equals IQODHTCVXVWSF == NULL
IDENTIFIER NULL return NULL ;
<operator>.assignment HESM = IGSFUPGRHIKXJCJQGD
<operator>.subtraction 1 - HESM
<operator>.subtraction 1 - HESM
<operator>.indirectIndexAccess APBU -> WWKDCWLL [ HESM ]
<operator>.indirectIndexAccess LHHBKC -> WWKDCWLL [ HESM ]
<operator>.indirectFieldAccess LHHBKC -> HMAMJD
<operator>.indirectFieldAccess APBU -> WWKDCWLL
<operator>.indirectIndexAccess LHHBKC -> WWKDCWLL [ 1 - HESM ]
<operator>.indirectFieldAccess LHHBKC -> WWKDCWLL
FIELD_IDENTIFIER HMAMJD HMAMJD
FIELD_IDENTIFIER WWKDCWLL WWKDCWLL
<operator>.indirectFieldAccess LHHBKC -> WWKDCWLL
<operator>.indirectIndexAccess LHHBKC -> WWKDCWLL [ 1 - HESM ]
FIELD_IDENTIFIER WWKDCWLL WWKDCWLL
FIELD_IDENTIFIER WWKDCWLL WWKDCWLL
<operator>.indirectFieldAccess LHHBKC -> WWKDCWLL
FIELD_IDENTIFIER WWKDCWLL WWKDCWLL
>>>PDG&42 0->2 0->3 0->10 0->14 0->15 0->16 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 2->1 2->10 3->1 4->1 4->1 4->22 5->1 5->1 5->1 5->19 5->23 6->14 7->14 8->10 9->10 10->16 12->1 13->1 13->1 13->1 13->6 13->7 13->8 13->9 13->10 13->11 13->12 13->14 13->15 13->17 13->18 13->19 13->26 13->28 13->29 13->30 13->31 13->32 13->33 13->34 13->35 13->36 13->38 13->39 14->20 14->25 15->15 15->21 15->21 15->26 15->27 15->32 15->36 15->37 15->39 15->40 15->41 16->12 17->1 18->6 19->7 20->26 21->10 22->1 22->1 22->13 22->13 22->15 22->18 22->23 22->23 22->24 23->1 23->1 23->13 23->13 23->15 23->19 23->24 24->17 25->26 26->27 27->26
>>>Token static PBNNQYTSIMO * EVXUKNNMWQAJSLFCNCATRDKITJCPR ( QEWOCTY * RHNO , PBNNQYTSIMO * APBU ) { PBNNQYTSIMO * CGXPKAMCDYMW ; PBNNQYTSIMO * IQODHTCVXVWSF ; PBNNQYTSIMO * LHHBKC ; PBNNQYTSIMO * FSCXD ; int EKIHLUHTMVY , TPBSQYPJGDSN ; int HESM ; CGXPKAMCDYMW = APBU -> WWKDCWLL [ IGSFUPGRHIKXJCJQGD ] ; IQODHTCVXVWSF = APBU -> WWKDCWLL [ GPHYEEYRHBOUOAEIHYA ] ; if ( CGXPKAMCDYMW == NULL && IQODHTCVXVWSF == NULL ) { return NULL ; } EKIHLUHTMVY = NSHXDIIIRBQUHGEJKLIEULT ( CGXPKAMCDYMW ) ; TPBSQYPJGDSN = NSHXDIIIRBQUHGEJKLIEULT ( IQODHTCVXVWSF ) ; if ( EKIHLUHTMVY < TPBSQYPJGDSN ) { HESM = GPHYEEYRHBOUOAEIHYA ; } else { HESM = IGSFUPGRHIKXJCJQGD ; } LHHBKC = APBU -> WWKDCWLL [ HESM ] ; while ( LHHBKC -> WWKDCWLL [ 1 - HESM ] != NULL ) { LHHBKC = LHHBKC -> WWKDCWLL [ 1 - HESM ] ; } FSCXD = LHHBKC -> WWKDCWLL [ HESM ] ; QAVUIDVKQPSPUDADWBVSI ( RHNO , LHHBKC , FSCXD ) ; CYTPKCVGPPYQNVBQRMKJHA ( LHHBKC -> HMAMJD ) ; return LHHBKC ; }
>>>Func
METHOD XEWNKSOHKKC
METHOD_RETURN void
PARAM int * DLJCJMYCMK
<operator>.assignment YBFYAVFWG = false
<operator>.logicalNot ! YBFYAVFWG
<operator>.assignment YBFYAVFWG = true
<operator>.lessThan i < GUM - 1
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.subtraction GUM - 1
<operator>.greaterThan DLJCJMYCMK [ i ] > DLJCJMYCMK [ i + 1 ]
<operator>.assignment GKXYAHJMKPXV = DLJCJMYCMK [ i ]
<operator>.assignment DLJCJMYCMK [ i ] = DLJCJMYCMK [ i + 1 ]
<operator>.assignment DLJCJMYCMK [ i + 1 ] = GKXYAHJMKPXV
<operator>.assignment YBFYAVFWG = false
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.indirectIndexAccess DLJCJMYCMK [ i ]
<operator>.indirectIndexAccess DLJCJMYCMK [ i + 1 ]
<operator>.indirectIndexAccess DLJCJMYCMK [ i ]
<operator>.indirectIndexAccess DLJCJMYCMK [ i ]
<operator>.indirectIndexAccess DLJCJMYCMK [ i + 1 ]
<operator>.indirectIndexAccess DLJCJMYCMK [ i + 1 ]
>>>PDG&24 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->13 0->14 0->15 0->16 0->17 2->1 2->10 2->11 2->12 3->1 3->1 3->4 4->1 4->1 4->4 4->5 4->6 4->8 4->9 5->1 5->4 6->1 6->1 6->1 6->6 6->7 6->7 6->9 6->10 6->15 6->15 6->16 6->17 6->18 6->19 7->6 8->6 9->1 9->6 9->6 10->11 10->11 10->12 10->12 10->13 10->14 10->16 10->17 10->20 10->21 10->22 10->23 11->13 12->10 13->10 14->4
>>>Token void XEWNKSOHKKC ( int * DLJCJMYCMK ) { bool YBFYAVFWG = false ; while ( ! YBFYAVFWG ) { YBFYAVFWG = true ; for ( int i = 0 ; i < GUM - 1 ; i ++ ) { if ( DLJCJMYCMK [ i ] > DLJCJMYCMK [ i + 1 ] ) { int GKXYAHJMKPXV = DLJCJMYCMK [ i ] ; DLJCJMYCMK [ i ] = DLJCJMYCMK [ i + 1 ] ; DLJCJMYCMK [ i + 1 ] = GKXYAHJMKPXV ; YBFYAVFWG = false ; } } } }
>>>Func
METHOD main
METHOD_RETURN int
PAMKL PAMKL ( "%d" , & N )
RETURN return 0 ; return 0 ;
<operator>.postDecrement N --
ENWRC ENWRC ( )
LITERAL 0 return 0 ;
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->1 2->4 3->1 4->1 4->1 4->4 4->5 5->1 6->3
>>>Token int main ( ) { int N ; PAMKL ( " " , & N ) ; while ( N -- ) ENWRC ( ) ; return 0 ; }
>>>Func
METHOD ACPGRJEQRLGMJYIH
METHOD_RETURN int
PARAM int * VWHB
PARAM int MXHPWFGQ
<operator>.assignment KODKTT = 1
<operator>.assignment TLFXE = 1
RETURN return KODKTT ; return KODKTT ;
<operator>.equals MXHPWFGQ == 0
<operator>.lessThan i < MXHPWFGQ
<operator>.postIncrement i ++
IDENTIFIER KODKTT return KODKTT ;
RETURN return 0 ; return 0 ;
<operator>.assignment i = 1
LITERAL 0 return 0 ;
<operator>.greaterThan VWHB [ i ] > VWHB [ i - 1 ]
<operator>.postIncrement TLFXE ++
<operator>.greaterEqualsThan TLFXE >= KODKTT
<operator>.assignment TLFXE = 1
<operator>.subtraction i - 1
<operator>.assignment KODKTT = TLFXE
<operator>.indirectIndexAccess VWHB [ i ]
<operator>.indirectIndexAccess VWHB [ i - 1 ]
>>>PDG&22 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 2->1 2->14 3->7 4->1 4->1 4->10 4->16 5->1 5->1 5->15 6->1 7->1 7->1 7->6 7->8 7->8 7->11 7->12 8->8 8->9 8->14 8->18 8->18 8->20 8->21 9->8 10->6 11->1 12->8 13->11 14->15 14->16 14->17 15->16 16->10 16->15 16->19 16->19 17->15 18->9 19->10 19->16
>>>Token int ACPGRJEQRLGMJYIH ( int * VWHB , int MXHPWFGQ ) { int KODKTT = 1 , i , TLFXE = 1 ; if ( MXHPWFGQ == 0 ) return 0 ; for ( i = 1 ; i < MXHPWFGQ ; i ++ ) { if ( VWHB [ i ] > VWHB [ i - 1 ] ) { TLFXE ++ ; if ( TLFXE >= KODKTT ) KODKTT = TLFXE ; } else { TLFXE = 1 ; } } return KODKTT ; }
>>>Func
METHOD KQVPOQWHEHX
METHOD_RETURN int
PARAM int x
<operator>.assignment n = PJJYM ( x )
<operator>.assignment FEVV = x
<operator>.assignment NIY = 0
IDENTIFIER FEVV while (FEVV)
<operator>.equals NIY == x
PJJYM PJJYM ( x )
<operator>.assignment r = FEVV % 10
<operator>.assignmentPlus NIY += RHUYD ( r , n )
<operator>.assignment FEVV = FEVV / 10
RETURN return 1 ; return 1 ;
LITERAL 1 return 1 ;
RETURN return 0 ; return 0 ;
<operator>.modulo FEVV % 10
RHUYD RHUYD ( r , n )
<operator>.division FEVV / 10
LITERAL 0 return 0 ;
>>>PDG&19 0->2 0->4 0->5 0->6 0->7 0->8 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 2->8 3->1 3->1 3->1 3->16 4->1 4->1 4->15 5->1 5->7 5->10 7->1 7->1 7->1 7->12 7->14 8->3 8->4 8->7 9->1 9->1 9->16 10->1 10->1 10->7 11->1 11->1 11->1 11->15 12->1 13->12 14->1 15->9 15->9 15->17 16->1 16->1 16->10 16->10 17->11 17->11 18->14
>>>Token int KQVPOQWHEHX ( int x ) { int n = PJJYM ( x ) ; int FEVV = x , NIY = 0 ; while ( FEVV ) { int r = FEVV % 10 ; NIY += RHUYD ( r , n ) ; FEVV = FEVV / 10 ; } if ( NIY == x ) return 1 ; else return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
UAIRC UAIRC ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan t < T
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 0
UAIRC UAIRC ( "\n%d" , & C )
UAIRC UAIRC ( " %d" , & D )
UAIRC UAIRC ( " %d " , & N )
printf printf ( "]" )
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.greaterThan N > 0
<operator>.lessThan i < N
<operator>.postIncrement i ++
printf printf ( ", %c" , YILQ [ i ] )
<operator>.lessThan t < T - 1
<operator>.assignment i = 0
UAIRC UAIRC ( " " )
<operator>.assignment i = 0
UAIRC UAIRC ( " " )
<operator>.assignment i = 0
UAIRC UAIRC ( "%c" , & YILQ [ i ] )
<operator>.assignment i = 1
<operator>.assignment KJL = 0
printf printf ( "Case #%d: [%c" , t + 1 , YILQ [ 0 ] )
<operator>.assignment i = 1
printf printf ( "\n" )
<operator>.lessThan j < 3
<operator>.postIncrement j ++
<operator>.lessThan j < 2
<operator>.postIncrement j ++
<operator>.lessThan j < C
<operator>.postIncrement j ++
<operator>.logicalNot ! KJL
<operator>.lessThan i < 0
printf printf ( "Case #%d: [" , t + 1 )
<operator>.subtraction T - 1
<operator>.assignment j = 0
UAIRC UAIRC ( "%c" , & OHEWYWP [ i ] [ j ] )
<operator>.assignment j = 0
UAIRC UAIRC ( "%c" , & GGLUHH [ i ] [ j ] )
<operator>.assignment j = 0
<operator>.logicalOr ( YILQ [ i ] == OHEWYWP [ j ] [ 0 ] && YILQ [ i - 1 ] == OHEWYWP [ j ] [ 1 ] ) || ( YILQ [ i ] == OHEWYWP [ j ] [ 1 ] && YILQ [ i - 1 ] == OHEWYWP [ j ] [ 0 ] )
<operator>.assignment i = 0
<operator>.addition t + 1
<operator>.assignment N = OGLNVTV ( YILQ , i - 1 , OHEWYWP [ j ] [ 2 ] , N )
<operator>.assignmentMinus i -= 2
<operator>.assignment KJL = 1
<operator>.lessThan j < D
<operator>.postIncrement j ++
<operator>.addition t + 1
<operator>.logicalAnd YILQ [ i ] == OHEWYWP [ j ] [ 0 ] && YILQ [ i - 1 ] == OHEWYWP [ j ] [ 1 ]
<operator>.logicalAnd YILQ [ i ] == OHEWYWP [ j ] [ 1 ] && YILQ [ i - 1 ] == OHEWYWP [ j ] [ 0 ]
<operator>.assignment j = 0
<operator>.logicalOr YILQ [ i ] == GGLUHH [ j ] [ 0 ] || YILQ [ i ] == GGLUHH [ j ] [ 1 ]
<operator>.equals YILQ [ i ] == OHEWYWP [ j ] [ 0 ]
<operator>.equals YILQ [ i - 1 ] == OHEWYWP [ j ] [ 1 ]
<operator>.equals YILQ [ i ] == OHEWYWP [ j ] [ 1 ]
<operator>.equals YILQ [ i - 1 ] == OHEWYWP [ j ] [ 0 ]
OGLNVTV OGLNVTV ( YILQ , i - 1 , OHEWYWP [ j ] [ 2 ] , N )
<operator>.subtraction i - 1
<operator>.equals YILQ [ i ] == GGLUHH [ j ] [ 0 ]
<operator>.equals YILQ [ i ] == GGLUHH [ j ] [ 1 ]
<operator>.greaterEqualsThan k >= 0
<operator>.postDecrement k --
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.assignment k = i - 1
<operator>.logicalOr ( YILQ [ k ] == GGLUHH [ j ] [ 0 ] && YILQ [ i ] == GGLUHH [ j ] [ 1 ] ) || ( YILQ [ k ] == GGLUHH [ j ] [ 1 ] && YILQ [ i ] == GGLUHH [ j ] [ 0 ] )
<operator>.equals KJL == 1
<operator>.subtraction i - 1
<operator>.assignment N = JQGTPO ( YILQ , k , i , N )
<operator>.assignment i = k - 1
<operator>.assignment KJL = 1
<operator>.logicalAnd YILQ [ k ] == GGLUHH [ j ] [ 0 ] && YILQ [ i ] == GGLUHH [ j ] [ 1 ]
<operator>.logicalAnd YILQ [ k ] == GGLUHH [ j ] [ 1 ] && YILQ [ i ] == GGLUHH [ j ] [ 0 ]
<operator>.equals YILQ [ k ] == GGLUHH [ j ] [ 0 ]
<operator>.equals YILQ [ i ] == GGLUHH [ j ] [ 1 ]
<operator>.equals YILQ [ k ] == GGLUHH [ j ] [ 1 ]
<operator>.equals YILQ [ i ] == GGLUHH [ j ] [ 0 ]
JQGTPO JQGTPO ( YILQ , k , i , N )
<operator>.subtraction k - 1
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.indirectIndexAccess YILQ [ i ]
<operator>.addressOf & YILQ [ i ]
<operator>.indirectIndexAccess YILQ [ 0 ]
<operator>.indirectIndexAccess YILQ [ i ]
<operator>.addressOf & OHEWYWP [ i ] [ j ]
<operator>.addressOf & GGLUHH [ i ] [ j ]
<operator>.indirectIndexAccess OHEWYWP [ i ] [ j ]
<operator>.indirectIndexAccess GGLUHH [ i ] [ j ]
<operator>.indirectIndexAccess OHEWYWP [ i ]
<operator>.indirectIndexAccess GGLUHH [ i ]
<operator>.indirectIndexAccess YILQ [ i ]
<operator>.indirectIndexAccess OHEWYWP [ j ] [ 0 ]
<operator>.indirectIndexAccess YILQ [ i - 1 ]
<operator>.indirectIndexAccess OHEWYWP [ j ] [ 1 ]
<operator>.indirectIndexAccess YILQ [ i ]
<operator>.indirectIndexAccess OHEWYWP [ j ] [ 1 ]
<operator>.indirectIndexAccess YILQ [ i - 1 ]
<operator>.indirectIndexAccess OHEWYWP [ j ] [ 0 ]
<operator>.indirectIndexAccess OHEWYWP [ j ] [ 2 ]
<operator>.indirectIndexAccess OHEWYWP [ j ]
<operator>.indirectIndexAccess OHEWYWP [ j ]
<operator>.indirectIndexAccess OHEWYWP [ j ]
<operator>.indirectIndexAccess OHEWYWP [ j ]
<operator>.indirectIndexAccess OHEWYWP [ j ]
<operator>.indirectIndexAccess YILQ [ i ]
<operator>.indirectIndexAccess GGLUHH [ j ] [ 0 ]
<operator>.indirectIndexAccess YILQ [ i ]
<operator>.indirectIndexAccess GGLUHH [ j ] [ 1 ]
<operator>.indirectIndexAccess GGLUHH [ j ]
<operator>.indirectIndexAccess GGLUHH [ j ]
<operator>.indirectIndexAccess YILQ [ k ]
<operator>.indirectIndexAccess GGLUHH [ j ] [ 0 ]
<operator>.indirectIndexAccess YILQ [ i ]
<operator>.indirectIndexAccess GGLUHH [ j ] [ 1 ]
<operator>.indirectIndexAccess YILQ [ k ]
<operator>.indirectIndexAccess GGLUHH [ j ] [ 1 ]
<operator>.indirectIndexAccess YILQ [ i ]
<operator>.indirectIndexAccess GGLUHH [ j ] [ 0 ]
<operator>.indirectIndexAccess GGLUHH [ j ]
<operator>.indirectIndexAccess GGLUHH [ j ]
<operator>.indirectIndexAccess GGLUHH [ j ]
<operator>.indirectIndexAccess GGLUHH [ j ]
>>>PDG&136 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->52 0->53 0->55 0->56 0->57 0->58 0->59 0->62 0->68 0->69 0->72 0->73 0->74 0->75 0->78 0->79 0->82 0->89 0->90 2->1 2->1 2->4 2->45 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->14 4->16 4->18 4->20 4->21 4->24 4->24 4->25 4->27 4->29 4->31 4->33 4->34 4->44 4->45 4->45 4->53 4->59 4->91 4->92 4->93 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->12 8->40 9->1 9->1 9->14 9->57 10->1 10->1 10->16 10->18 10->20 10->21 10->68 10->89 11->1 12->1 12->1 12->8 12->12 12->13 12->13 12->26 12->36 12->40 12->46 13->1 13->12 14->1 14->1 14->9 14->14 14->15 14->15 14->28 14->38 14->48 14->57 15->1 15->14 16->16 16->17 16->17 16->18 16->30 16->95 16->97 17->1 17->16 18->18 18->19 18->20 18->32 18->40 18->42 18->43 18->43 18->50 18->68 18->69 18->74 18->75 18->79 18->89 19->1 19->18 20->1 20->21 20->33 20->44 20->53 20->59 20->96 21->1 21->1 21->1 21->10 21->16 21->21 21->22 21->22 21->23 21->94 22->1 22->21 23->1 23->1 23->30 23->64 23->70 24->1 24->1 24->5 24->35 25->12 26->1 27->14 28->1 29->1 29->16 30->1 30->1 30->23 30->64 30->66 30->70 30->71 30->86 30->88 31->18 32->1 32->42 33->1 33->1 33->1 33->68 33->89 34->1 34->21 35->1 36->1 36->1 36->36 36->37 36->37 36->47 36->98 36->100 36->102 37->1 37->36 38->1 38->1 38->38 38->39 38->39 38->49 38->99 38->101 38->103 39->1 39->38 40->1 40->1 40->1 40->8 40->12 40->41 40->51 40->60 40->64 40->104 40->105 40->113 41->1 41->40 42->1 42->1 42->57 42->62 42->78 43->1 43->19 43->52 44->1 44->1 45->4 45->24 45->24 46->1 46->36 47->1 47->1 48->1 48->38 49->1 49->1 50->1 50->40 51->1 51->1 51->1 51->40 51->41 51->54 51->55 51->56 51->68 51->69 51->112 51->117 52->1 52->19 54->1 54->1 54->18 54->89 55->1 55->43 55->79 56->1 56->42 57->1 57->1 57->1 57->9 57->14 57->57 57->58 57->58 57->63 57->70 57->118 57->119 57->122 58->1 58->57 60->1 60->1 60->51 60->51 60->61 60->66 60->108 60->109 60->115 61->1 61->1 61->51 61->51 62->1 62->57 63->1 63->1 63->1 63->72 63->76 63->79 63->83 63->84 64->1 64->1 64->23 64->30 64->60 64->60 64->65 64->66 64->67 64->68 64->70 64->74 64->106 64->107 64->114 65->1 65->1 65->60 65->60 65->66 65->67 65->68 65->89 66->1 66->1 66->23 66->30 66->61 66->61 66->64 66->65 66->67 66->68 66->70 66->75 66->110 66->111 66->116 67->1 67->1 67->61 67->61 67->64 67->65 67->68 67->89 68->1 68->1 68->1 68->23 68->30 68->33 68->54 68->54 68->54 68->54 68->64 68->65 68->66 68->67 68->70 68->71 68->85 68->86 68->87 68->88 68->89 69->55 69->68 69->68 70->1 70->1 70->23 70->30 70->63 70->63 70->64 70->71 70->71 70->85 70->86 70->88 70->89 70->120 70->121 70->123 71->1 71->1 71->23 71->30 71->63 71->63 71->64 71->70 71->86 71->86 71->87 71->88 71->89 72->1 72->1 72->73 72->77 72->83 72->85 72->89 72->124 72->125 72->132 73->1 73->72 74->43 74->69 74->75 74->79 75->43 75->69 75->74 75->79 76->1 76->1 76->72 77->1 77->1 77->1 77->78 77->80 77->81 77->82 77->89 77->90 78->1 78->1 78->72 78->73 79->43 79->76 79->76 79->89 80->1 80->1 80->18 80->89 81->1 81->1 81->43 81->79 82->1 82->1 82->78 83->1 83->1 83->63 83->77 83->77 83->84 83->87 83->128 83->129 83->134 84->1 84->1 84->77 84->77 85->1 85->1 85->68 85->70 85->83 85->83 85->86 85->87 85->88 85->89 85->126 85->127 85->133 86->1 86->1 86->23 86->30 86->64 86->70 86->71 86->83 86->83 86->87 86->88 86->89 87->1 87->1 87->68 87->71 87->84 87->84 87->85 87->86 87->88 87->89 87->130 87->131 87->135 88->1 88->1 88->23 88->30 88->64 88->70 88->70 88->84 88->84 88->85 88->86 88->89 89->1 89->23 89->30 89->33 89->64 89->65 89->66 89->67 89->68 89->70 89->71 89->80 89->80 89->80 89->80 89->85 89->86 89->87 89->88 89->90 90->1 90->81 90->81
>>>Token int main ( ) { int T , C , D , N , i , j , k , t ; char OHEWYWP [ 40 ] [ 3 ] , GGLUHH [ 30 ] [ 2 ] , YILQ [ TLVFWUJK ] ; UAIRC ( " " , & T ) ; for ( t = 0 ; t < T ; t ++ ) { UAIRC ( " \n " , & C ) ; for ( i = 0 ; i < C ; i ++ ) { UAIRC ( " " ) ; for ( j = 0 ; j < 3 ; j ++ ) { UAIRC ( " " , & OHEWYWP [ i ] [ j ] ) ; } } UAIRC ( " " , & D ) ; for ( i = 0 ; i < D ; i ++ ) { UAIRC ( " " ) ; for ( j = 0 ; j < 2 ; j ++ ) { UAIRC ( " " , & GGLUHH [ i ] [ j ] ) ; } } UAIRC ( " " , & N ) ; for ( i = 0 ; i < N ; i ++ ) { UAIRC ( " " , & YILQ [ i ] ) ; } int KJL ; for ( i = 1 ; i < N ; i ++ ) { KJL = 0 ; for ( j = 0 ; j < C ; j ++ ) if ( ( YILQ [ i ] == OHEWYWP [ j ] [ 0 ] && YILQ [ i - 1 ] == OHEWYWP [ j ] [ 1 ] ) || ( YILQ [ i ] == OHEWYWP [ j ] [ 1 ] && YILQ [ i - 1 ] == OHEWYWP [ j ] [ 0 ] ) ) { N = OGLNVTV ( YILQ , i - 1 , OHEWYWP [ j ] [ 2 ] , N ) ; i -= 2 ; KJL = 1 ; break ; } if ( ! KJL ) { for ( j = 0 ; j < D ; j ++ ) if ( YILQ [ i ] == GGLUHH [ j ] [ 0 ] || YILQ [ i ] == GGLUHH [ j ] [ 1 ] ) { for ( k = i - 1 ; k >= 0 ; k -- ) { if ( ( YILQ [ k ] == GGLUHH [ j ] [ 0 ] && YILQ [ i ] == GGLUHH [ j ] [ 1 ] ) || ( YILQ [ k ] == GGLUHH [ j ] [ 1 ] && YILQ [ i ] == GGLUHH [ j ] [ 0 ] ) ) { N = JQGTPO ( YILQ , k , i , N ) ; i = k - 1 ; KJL = 1 ; break ; } if ( KJL == 1 ) break ; } } } if ( i < 0 ) i = 0 ; } if ( N > 0 ) printf ( " " , t + 1 , YILQ [ 0 ] ) ; else printf ( " " , t + 1 ) ; for ( i = 1 ; i < N ; i ++ ) printf ( " " , YILQ [ i ] ) ; printf ( " " ) ; if ( t < T - 1 ) printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD WJSJLSSLJIPDCPYXPHSJE
METHOD_RETURN bool
PARAM char const * EOMVABWY
PARAM bool WLYJFKW
PARAM const struct ADIKLYPPQO * x
<operator>.assignment QHYJQFPHRL = ( ! x -> HULJTWKDEUBFBJPOKH || x -> HCYAJXJCDYJWNSRBELXOPDMS )
<operator>.assignment IPEAEPJNTIN = ! QHYJQFPHRL && ! x -> FIYHLYSIONCPUOPLGU
RETURN return true ; return true ;
<operator>.logicalNot ! XYDPDFUUPK ( x -> QAYVJXFWYAIPOKHJYXUF , EOMVABWY , WLYJFKW )
IDENTIFIER true return true ;
<operator>.logicalOr ! x -> HULJTWKDEUBFBJPOKH || x -> HCYAJXJCDYJWNSRBELXOPDMS
<operator>.logicalAnd ! QHYJQFPHRL && ! x -> FIYHLYSIONCPUOPLGU
RETURN return false ; return false ;
<operator>.logicalNot ! x -> HULJTWKDEUBFBJPOKH
<operator>.logicalNot ! QHYJQFPHRL
<operator>.logicalNot ! x -> FIYHLYSIONCPUOPLGU
XYDPDFUUPK XYDPDFUUPK ( x -> QAYVJXFWYAIPOKHJYXUF , EOMVABWY , WLYJFKW )
<operator>.logicalOr QHYJQFPHRL || ( IPEAEPJNTIN && ! SVGYLMGIJXTBYUWIU ( DFUFN ) )
IDENTIFIER false return false ;
MTYUF MTYUF ( 0   DFUFN   _ ( "failed to set the security context of %s" )   ASDINBOMM ( 0 , EOMVABWY ) )
<operator>.logicalAnd IPEAEPJNTIN && ! SVGYLMGIJXTBYUWIU ( DFUFN )
<operator>.logicalNot ! SVGYLMGIJXTBYUWIU ( DFUFN )
_ _ ( "failed to set the security context of %s" )
ASDINBOMM ASDINBOMM ( 0 , EOMVABWY )
SVGYLMGIJXTBYUWIU SVGYLMGIJXTBYUWIU ( DFUFN )
<operator>.indirectFieldAccess x -> HCYAJXJCDYJWNSRBELXOPDMS
FIELD_IDENTIFIER HCYAJXJCDYJWNSRBELXOPDMS HCYAJXJCDYJWNSRBELXOPDMS
<operator>.indirectFieldAccess x -> FIYHLYSIONCPUOPLGU
FIELD_IDENTIFIER FIYHLYSIONCPUOPLGU FIYHLYSIONCPUOPLGU
>>>PDG&29 0->2 0->3 0->4 0->7 0->9 0->12 0->14 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 2->16 3->16 4->1 5->1 5->1 5->14 6->1 6->1 6->1 6->20 7->1 8->1 8->1 8->7 8->12 8->17 8->20 8->21 8->24 9->7 10->1 10->1 10->5 10->5 11->1 11->1 11->6 11->6 12->1 13->1 13->10 13->25 13->26 14->11 14->15 14->17 14->27 14->28 15->1 15->11 16->1 16->1 16->1 16->8 16->8 16->8 16->23 17->1 17->1 17->1 17->19 17->22 17->23 18->12 19->1 19->1 19->1 19->1 20->1 20->1 20->17 20->17 21->1 21->20 22->19 23->1 23->19 23->19 24->1 24->19 24->21
>>>Token bool WJSJLSSLJIPDCPYXPHSJE ( char const * EOMVABWY , bool WLYJFKW , const struct ADIKLYPPQO * x ) { bool QHYJQFPHRL = ( ! x -> HULJTWKDEUBFBJPOKH || x -> HCYAJXJCDYJWNSRBELXOPDMS ) ; bool IPEAEPJNTIN = ! QHYJQFPHRL && ! x -> FIYHLYSIONCPUOPLGU ; if ( ! XYDPDFUUPK ( x -> QAYVJXFWYAIPOKHJYXUF , EOMVABWY , WLYJFKW ) ) { if ( QHYJQFPHRL || ( IPEAEPJNTIN && ! SVGYLMGIJXTBYUWIU ( DFUFN ) ) ) MTYUF ( 0 , DFUFN , _ ( " " ) , ASDINBOMM ( 0 , EOMVABWY ) ) ; return false ; } return true ; }
>>>Func
METHOD main
METHOD_RETURN int
GQEGN GQEGN ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessThan cs < t
<operator>.postIncrement cs ++
LITERAL 0 return 0 ;
<operator>.assignment cs = 0
<operator>.assignment s [ 100 ] = { }
<operator>.assignment w [ 100 ] = { }
<operator>.assignment wp [ 100 ] = { }
<operator>.assignment KBB [ 100 ] = { }
<operator>.assignment JAAD [ 100 ] = { }
GQEGN GQEGN ( "%d" , & n )
GQEGN GQEGN ( "%c" , & mm )
printf printf ( "Case #%d:\n" , cs + 1 )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment j = 0
GQEGN GQEGN ( "%c" , & mm )
<operator>.assignment i = 0
<operator>.assignment wp [ i ] = w [ i ] / ( double ) s [ i ]
<operator>.assignment i = 0
<operator>.assignment ws [ 100 ] = { }
<operator>.assignment ww [ 100 ] = { }
<operator>.assignment s [ 100 ] = { }
<operator>.assignment ts = 0
<operator>.assignmentDivision KBB [ i ] /= ts
<operator>.assignment i = 0
<operator>.assignment ts = 0
<operator>.assignmentDivision JAAD [ i ] /= ts
<operator>.addition cs + 1
<operator>.assignment i = 0
printf printf ( "%f\n" , 0.25 * wp [ i ] + 0.50 * KBB [ i ] + 0.25 * JAAD [ i ] )
<operator>.lessThan k < n
<operator>.postIncrement k ++
GQEGN GQEGN ( "%c" , & m [ j ] [ k ] )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan ii < n
<operator>.postIncrement ii ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment k = 0
<operator>.assignment j = 0
<operator>.division w [ i ] / ( double ) s [ i ]
<operator>.assignment ii = 0
<operator>.assignment ws [ ii ] = ww [ ii ] / ( double ) s [ ii ]
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.addition 0.25 * wp [ i ] + 0.50 * KBB [ i ] + 0.25 * JAAD [ i ]
<operator>.equals m [ i ] [ j ] == '1'
<operator>.cast ( double ) s [ i ]
<operator>.lessThan jj < n
<operator>.postIncrement jj ++
<operator>.notEquals m [ i ] [ j ] != '.'
<operator>.notEquals m [ i ] [ j ] != '.'
<operator>.addition 0.25 * wp [ i ] + 0.50 * KBB [ i ]
<operator>.multiplication 0.25 * JAAD [ i ]
<operator>.expressionList s [ i ] ++   w [ i ] ++
<operator>.assignment jj = 0
<operator>.division ww [ ii ] / ( double ) s [ ii ]
<operator>.expressionList KBB [ i ] += ws [ j ]   ts ++
<operator>.expressionList JAAD [ i ] += KBB [ j ]   ts ++
<operator>.multiplication 0.25 * wp [ i ]
<operator>.multiplication 0.50 * KBB [ i ]
<operator>.logicalAnd m [ ii ] [ jj ] == '1' && jj != i
<operator>.cast ( double ) s [ ii ]
<operator>.postIncrement s [ i ] ++
<operator>.postIncrement w [ i ] ++
<operator>.equals m [ i ] [ j ] == '0'
<operator>.expressionList s [ ii ] ++   ww [ ii ] ++
<operator>.assignmentPlus KBB [ i ] += ws [ j ]
<operator>.postIncrement ts ++
<operator>.assignmentPlus JAAD [ i ] += KBB [ j ]
<operator>.postIncrement ts ++
<operator>.postIncrement s [ i ] ++
<operator>.equals m [ ii ] [ jj ] == '1'
<operator>.notEquals jj != i
<operator>.postIncrement s [ ii ] ++
<operator>.postIncrement ww [ ii ] ++
<operator>.logicalAnd m [ ii ] [ jj ] == '0' && jj != i
<operator>.postIncrement s [ ii ] ++
<operator>.equals m [ ii ] [ jj ] == '0'
<operator>.notEquals jj != i
<operator>.arrayInitializer { }
<operator>.arrayInitializer { }
<operator>.arrayInitializer { }
<operator>.arrayInitializer { }
<operator>.arrayInitializer { }
<operator>.addressOf & n
<operator>.addressOf & mm
<operator>.addressOf & mm
<operator>.indirectIndexAccess wp [ i ]
<operator>.arrayInitializer { }
<operator>.arrayInitializer { }
<operator>.arrayInitializer { }
<operator>.indirectIndexAccess KBB [ i ]
<operator>.indirectIndexAccess JAAD [ i ]
<operator>.addressOf & m [ j ] [ k ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess m [ j ] [ k ]
UNKNOWN double double
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess ws [ ii ]
<operator>.indirectIndexAccess JAAD [ i ]
<operator>.indirectIndexAccess m [ j ]
<operator>.indirectIndexAccess m [ i ] [ j ]
<operator>.indirectIndexAccess ww [ ii ]
<operator>.indirectIndexAccess m [ i ] [ j ]
<operator>.indirectIndexAccess m [ i ] [ j ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess KBB [ i ]
<operator>.indirectIndexAccess m [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess s [ ii ]
<operator>.indirectIndexAccess m [ i ]
<operator>.indirectIndexAccess m [ i ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess KBB [ i ]
<operator>.indirectIndexAccess ws [ j ]
<operator>.indirectIndexAccess JAAD [ i ]
<operator>.indirectIndexAccess KBB [ j ]
<operator>.indirectIndexAccess m [ i ] [ j ]
<operator>.indirectIndexAccess m [ ii ] [ jj ]
<operator>.indirectIndexAccess m [ i ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess m [ ii ]
<operator>.indirectIndexAccess s [ ii ]
<operator>.indirectIndexAccess ww [ ii ]
<operator>.indirectIndexAccess m [ ii ] [ jj ]
<operator>.indirectIndexAccess s [ ii ]
<operator>.indirectIndexAccess m [ ii ]
>>>PDG&144 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->56 0->58 0->59 0->61 0->63 0->64 0->65 0->66 0->68 0->70 0->74 0->75 0->80 0->83 0->85 0->87 0->88 0->93 0->94 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->15 4->16 4->18 4->20 4->22 4->24 4->26 4->28 4->30 4->36 4->39 4->39 4->40 4->95 4->96 4->97 4->98 4->99 4->100 4->101 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->55 8->62 8->78 8->86 9->1 9->1 9->55 9->79 10->1 10->1 10->74 11->1 11->1 11->35 11->73 11->75 11->82 11->84 12->1 12->1 12->1 12->38 12->68 12->84 13->1 13->1 13->16 13->18 13->20 13->22 13->24 13->42 13->45 13->47 13->49 13->51 13->63 14->1 14->1 14->27 15->1 15->1 16->1 16->1 16->16 16->17 16->17 16->18 16->27 16->42 16->42 16->53 16->102 17->1 17->16 18->18 18->19 18->19 18->20 18->29 18->45 18->45 18->54 18->55 18->62 18->103 18->110 18->112 18->113 19->1 19->18 20->20 20->21 20->21 20->22 20->31 20->32 20->33 20->34 20->35 20->47 20->47 20->49 20->56 20->58 20->88 20->94 20->104 20->105 20->106 20->107 21->1 21->20 22->22 22->23 22->23 22->24 22->37 22->38 22->51 22->51 22->59 22->108 23->1 23->22 24->1 24->1 24->1 24->13 24->16 24->24 24->25 24->25 24->41 24->60 24->67 24->68 24->74 24->75 24->115 24->121 24->122 25->1 25->24 26->1 26->16 27->1 27->1 27->14 28->18 29->1 29->1 29->1 29->74 30->20 31->1 31->1 31->72 31->82 32->1 32->1 32->71 32->90 33->1 33->1 33->1 33->71 33->77 33->89 33->92 34->1 34->35 34->83 35->1 35->1 35->1 35->75 35->82 36->22 37->1 37->38 37->85 38->1 38->1 38->1 38->68 38->84 40->1 40->24 41->1 41->1 42->1 42->1 42->16 42->42 42->43 42->43 42->44 42->109 42->111 42->116 43->1 43->42 44->1 44->1 45->1 45->1 45->18 45->45 45->46 45->46 45->61 45->117 45->123 46->1 46->45 47->1 47->1 47->47 47->48 47->48 47->49 47->57 47->63 47->63 47->70 47->71 47->77 47->114 47->118 47->124 47->125 48->1 48->47 49->1 49->1 49->20 49->49 49->50 49->50 49->65 49->119 49->126 50->1 50->49 51->1 51->1 51->22 51->51 51->52 51->52 51->66 51->120 51->127 52->1 52->51 53->1 53->42 54->1 54->45 55->1 55->1 55->29 55->29 55->79 56->1 56->47 57->1 57->1 57->1 58->1 58->49 59->1 59->51 60->1 60->1 61->1 61->1 61->65 61->66 61->69 61->78 61->79 61->80 61->80 61->128 61->129 61->134 61->136 62->1 63->1 63->1 63->47 63->63 63->64 63->64 63->76 63->87 63->88 63->94 63->135 63->138 64->1 64->63 65->1 65->1 65->61 65->66 65->72 65->82 65->83 65->130 65->131 66->1 66->1 66->61 66->65 66->73 66->84 66->85 66->132 66->133 67->1 67->1 68->1 68->38 68->41 68->41 68->60 68->60 68->84 69->1 69->1 69->1 70->1 70->63 71->1 71->1 71->57 71->57 71->90 72->1 72->1 72->1 73->1 73->1 73->1 74->1 74->41 74->41 74->60 74->60 74->67 74->67 75->1 75->35 75->41 75->41 75->60 75->60 75->67 75->67 75->82 76->1 76->1 76->1 76->81 76->89 76->90 76->91 76->91 76->93 76->139 76->140 76->141 76->143 77->1 78->55 78->62 78->69 78->86 79->55 79->69 80->1 80->1 80->61 80->65 80->66 80->86 80->137 81->1 81->1 81->1 82->1 82->35 82->72 83->35 83->72 84->1 84->38 84->73 85->38 85->73 86->1 86->55 86->62 86->78 87->1 87->76 87->76 87->88 87->93 88->21 88->64 88->76 88->76 88->94 88->94 89->71 89->77 89->81 89->92 90->71 90->81 91->1 91->1 91->1 91->76 91->92 91->142 92->1 92->71 92->77 92->89 93->1 93->87 93->91 93->91 93->94 94->21 94->64 94->88 94->91 94->91
>>>Token int main ( ) { int t ; GQEGN ( " " , & t ) ; for ( int cs = 0 ; cs < t ; cs ++ ) { int n , s [ 100 ] = { } ; char m [ 100 ] [ 100 ] , mm ; double w [ 100 ] = { } , wp [ 100 ] = { } , KBB [ 100 ] = { } , JAAD [ 100 ] = { } ; GQEGN ( " " , & n ) ; GQEGN ( " " , & mm ) ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) GQEGN ( " " , & m [ j ] [ k ] ) ; GQEGN ( " " , & mm ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] == ' ' ) s [ i ] ++ , w [ i ] ++ ; else if ( m [ i ] [ j ] == ' ' ) s [ i ] ++ ; } wp [ i ] = w [ i ] / ( double ) s [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { double ws [ 100 ] = { } , ww [ 100 ] = { } , s [ 100 ] = { } ; for ( int ii = 0 ; ii < n ; ii ++ ) { for ( int jj = 0 ; jj < n ; jj ++ ) { if ( m [ ii ] [ jj ] == ' ' && jj != i ) s [ ii ] ++ , ww [ ii ] ++ ; else if ( m [ ii ] [ jj ] == ' ' && jj != i ) s [ ii ] ++ ; } ws [ ii ] = ww [ ii ] / ( double ) s [ ii ] ; } double ts = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != ' ' ) KBB [ i ] += ws [ j ] , ts ++ ; } KBB [ i ] /= ts ; } for ( int i = 0 ; i < n ; i ++ ) { double ts = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != ' ' ) JAAD [ i ] += KBB [ j ] , ts ++ ; } JAAD [ i ] /= ts ; } printf ( " \n " , cs + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { printf ( " \n " , 0.25 * wp [ i ] + 0.50 * KBB [ i ] + 0.25 * JAAD [ i ] ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
UXKLC UXKLC ( "%d" , & n )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < n
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.assignment UPBFJS = NSVEN ( )
IDENTIFIER UPBFJS if (UPBFJS)
printf printf ( "Case #%d: Possible\n" , i + 1 )
printf printf ( "Case #%d: Broken\n" , i + 1 )
<operator>.addition i + 1
<operator>.addition i + 1
NSVEN NSVEN ( )
>>>PDG&16 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->11 5->11 5->12 5->12 5->13 5->13 5->14 5->14 5->15 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->1 11->1 11->1 12->1 12->1
>>>Token int main ( void ) { int i , n , UPBFJS ; UXKLC ( " " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { UPBFJS = NSVEN ( ) ; if ( UPBFJS ) printf ( " \n " , i + 1 ) ; else printf ( " \n " , i + 1 ) ; } return 0 ; }
>>>Func
METHOD AEHHRIVSUY
METHOD_RETURN void
PARAM struct VTPFM * CNVDK
<operator>.lessThan v < CNVDK -> FGWDROKWDLS
<operator>.postIncrement v ++
<operator>.assignment v = 0
<operator>.assignment * JMKE = CNVDK -> HJAEYIQC [ v ]
printf printf ( "\n Adjacency list of vertex %d\n " , v )
printf printf ( "\n" )
IDENTIFIER JMKE while (JMKE)
printf printf ( "%d -> " , JMKE -> VMFGSN )
<operator>.assignment JMKE = JMKE -> GXGW
<operator>.indirectFieldAccess CNVDK -> FGWDROKWDLS
FIELD_IDENTIFIER FGWDROKWDLS FGWDROKWDLS
<operator>.indirectIndexAccess CNVDK -> HJAEYIQC [ v ]
<operator>.indirectFieldAccess CNVDK -> HJAEYIQC
FIELD_IDENTIFIER HJAEYIQC HJAEYIQC
<operator>.indirectFieldAccess JMKE -> VMFGSN
<operator>.indirectFieldAccess JMKE -> GXGW
FIELD_IDENTIFIER VMFGSN VMFGSN
FIELD_IDENTIFIER GXGW GXGW
>>>PDG&21 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 2->1 3->1 3->1 3->1 3->3 3->4 3->6 3->7 3->7 3->8 3->10 3->11 3->12 3->13 3->14 3->15 3->16 3->17 3->18 3->19 3->20 4->1 4->3 5->1 5->3 7->4
>>>Token void AEHHRIVSUY ( struct VTPFM * CNVDK ) { int v ; for ( v = 0 ; v < CNVDK -> FGWDROKWDLS ; v ++ ) { struct DRCM * JMKE = CNVDK -> HJAEYIQC [ v ] ; printf ( " \n \n " , v ) ; while ( JMKE ) { printf ( " " , JMKE -> VMFGSN ) ; JMKE = JMKE -> GXGW ; } printf ( " \n " ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
POKXI POKXI ( "%d" , & tn )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan k <= tn
<operator>.postIncrement k ++
LITERAL 0 return 0 ;
<operator>.assignment k = 1
POKXI POKXI ( "%d" , & c )
POKXI POKXI ( "%d" , & d )
POKXI POKXI ( "%d%s" , & n , EXC )
<operator>.assignment sn = - 1
printf printf ( "Case #%d: [" , k )
printf printf ( "]\n" )
<operator>.lessThan i < c
<operator>.postIncrement i ++
POKXI POKXI ( "%s" , BVV [ i ] )
<operator>.lessThan i < d
<operator>.postIncrement i ++
POKXI POKXI ( "%s" , EQRW [ i ] )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= sn
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.minus - 1
<operator>.assignment i = 0
<operator>.preIncrement ++ sn
<operator>.assignment PVJ [ sn ] = EXC [ i ]
<operator>.assignment i = 0
printf printf ( "%c" , PVJ [ i ] )
<operator>.logicalAnd j < c && sn >= 1
<operator>.postIncrement j ++
<operator>.logicalAnd j < d && sn >= 1
<operator>.postIncrement j ++
IDENTIFIER r if (r)
IDENTIFIER i if (i)
<operator>.assignment j = 0
<operator>.expressionList j = 0   r = 0
<operator>.assignment sn = - 1
printf printf ( ", " )
<operator>.lessThan j < c
<operator>.greaterEqualsThan sn >= 1
<operator>.logicalAnd PVJ [ sn ] == BVV [ j ] [ 0 ] && PVJ [ sn - 1 ] == BVV [ j ] [ 1 ]
<operator>.lessThan j < d
<operator>.greaterEqualsThan sn >= 1
<operator>.logicalAnd r == 0 && o <= sn
<operator>.postIncrement o ++
IDENTIFIER r if (r)
<operator>.postDecrement sn --
<operator>.postDecrement sn --
<operator>.postIncrement sn ++
<operator>.assignment PVJ [ sn ] = BVV [ j ] [ 2 ]
<operator>.assignment j = 0
<operator>.assignment r = 0
<operator>.assignment o = 0
<operator>.minus - 1
<operator>.equals PVJ [ sn ] == BVV [ j ] [ 0 ]
<operator>.equals PVJ [ sn - 1 ] == BVV [ j ] [ 1 ]
<operator>.equals r == 0
<operator>.lessEqualsThan o <= sn
<operator>.logicalAnd r == 0 && p <= sn
<operator>.postIncrement p ++
<operator>.logicalAnd PVJ [ sn - 1 ] == BVV [ j ] [ 0 ] && PVJ [ sn ] == BVV [ j ] [ 1 ]
<operator>.assignment p = 0
<operator>.subtraction sn - 1
<operator>.postDecrement sn --
<operator>.postDecrement sn --
<operator>.postIncrement sn ++
<operator>.assignment PVJ [ sn ] = BVV [ j ] [ 2 ]
<operator>.equals r == 0
<operator>.lessEqualsThan p <= sn
<operator>.equals o == p
<operator>.logicalAnd EQRW [ j ] [ 0 ] == PVJ [ o ] && EQRW [ j ] [ 1 ] == PVJ [ p ]
<operator>.equals PVJ [ sn - 1 ] == BVV [ j ] [ 0 ]
<operator>.equals PVJ [ sn ] == BVV [ j ] [ 1 ]
<operator>.assignment r = 1
<operator>.equals EQRW [ j ] [ 0 ] == PVJ [ o ]
<operator>.equals EQRW [ j ] [ 1 ] == PVJ [ p ]
<operator>.subtraction sn - 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess BVV [ i ]
<operator>.indirectIndexAccess EQRW [ i ]
<operator>.indirectIndexAccess PVJ [ sn ]
<operator>.indirectIndexAccess EXC [ i ]
<operator>.indirectIndexAccess PVJ [ i ]
<operator>.indirectIndexAccess PVJ [ sn ]
<operator>.indirectIndexAccess BVV [ j ] [ 0 ]
<operator>.indirectIndexAccess PVJ [ sn - 1 ]
<operator>.indirectIndexAccess BVV [ j ] [ 1 ]
<operator>.indirectIndexAccess PVJ [ sn ]
<operator>.indirectIndexAccess BVV [ j ] [ 2 ]
<operator>.indirectIndexAccess BVV [ j ]
<operator>.indirectIndexAccess BVV [ j ]
<operator>.indirectIndexAccess BVV [ j ]
<operator>.indirectIndexAccess PVJ [ sn - 1 ]
<operator>.indirectIndexAccess BVV [ j ] [ 0 ]
<operator>.indirectIndexAccess PVJ [ sn ]
<operator>.indirectIndexAccess BVV [ j ] [ 1 ]
<operator>.indirectIndexAccess PVJ [ sn ]
<operator>.indirectIndexAccess BVV [ j ] [ 2 ]
<operator>.indirectIndexAccess BVV [ j ]
<operator>.indirectIndexAccess BVV [ j ]
<operator>.indirectIndexAccess BVV [ j ]
<operator>.indirectIndexAccess EQRW [ j ] [ 0 ]
<operator>.indirectIndexAccess PVJ [ o ]
<operator>.indirectIndexAccess EQRW [ j ] [ 1 ]
<operator>.indirectIndexAccess PVJ [ p ]
<operator>.indirectIndexAccess EQRW [ j ]
<operator>.indirectIndexAccess EQRW [ j ]
>>>PDG&113 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->31 0->33 0->35 0->36 0->37 0->38 0->39 0->41 0->42 0->43 0->45 0->46 0->48 0->49 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->60 0->61 0->63 0->65 0->66 0->67 0->68 0->69 0->71 0->72 0->73 0->77 0->80 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->14 4->17 4->20 4->22 4->24 4->25 4->26 4->27 4->30 4->81 4->82 4->83 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->14 8->42 9->1 9->1 9->17 9->45 10->1 10->1 10->1 10->20 10->29 11->1 11->1 11->22 11->28 12->1 12->5 13->1 14->1 14->1 14->8 14->14 14->15 14->15 14->16 14->42 14->84 15->1 15->14 16->1 16->1 17->1 17->1 17->9 17->17 17->18 17->18 17->19 17->45 17->85 18->1 18->17 19->1 19->1 20->1 20->1 20->10 20->20 20->21 20->21 20->28 20->29 20->32 20->34 20->38 20->39 20->40 20->42 20->45 20->54 20->55 20->57 20->86 20->87 21->1 21->20 22->1 22->1 22->1 22->22 22->23 22->23 22->31 22->41 22->88 23->1 23->22 24->14 25->17 26->11 27->20 28->1 28->22 28->43 28->46 28->50 28->61 28->66 28->72 28->80 29->1 29->1 29->1 29->58 30->1 30->22 31->1 31->1 32->1 32->1 32->32 32->33 32->34 32->42 32->44 32->58 32->89 32->90 32->95 33->1 33->42 34->1 34->1 34->1 34->32 34->34 34->35 34->45 34->47 34->56 34->60 35->1 35->45 38->42 39->1 39->1 39->1 40->1 40->1 40->22 40->28 41->1 42->1 42->8 42->14 42->32 42->32 42->33 42->43 43->22 43->28 43->32 43->32 43->46 43->50 43->61 43->66 43->72 43->80 44->1 44->1 44->1 44->50 44->51 44->52 44->53 44->64 44->75 44->80 44->93 44->94 44->97 44->98 44->99 44->104 45->1 45->1 45->9 45->17 45->34 45->34 45->35 45->46 46->22 46->28 46->34 46->34 46->61 46->72 47->1 47->1 47->1 47->47 47->48 47->60 47->62 47->65 47->71 48->1 48->1 48->61 48->73 50->51 51->1 51->52 52->1 52->22 52->28 52->43 52->46 52->50 52->61 52->66 52->72 52->80 53->1 53->1 53->1 53->58 54->39 54->45 55->1 55->39 55->60 56->1 56->1 56->48 56->61 56->73 57->40 58->1 58->1 58->44 58->44 58->59 58->66 58->75 58->76 58->91 58->92 58->96 59->1 59->1 59->44 59->44 59->75 59->76 60->1 60->47 60->47 60->61 60->71 61->1 61->22 61->28 61->46 61->47 61->47 61->48 61->72 61->73 62->1 62->1 62->62 62->63 62->71 62->73 63->1 63->1 63->72 63->73 64->1 64->1 64->1 64->67 64->68 64->69 64->70 64->102 64->103 64->106 65->1 65->1 65->72 65->73 66->50 66->80 67->68 68->1 68->69 69->1 69->22 69->28 69->43 69->46 69->50 69->61 69->66 69->72 69->80 70->1 70->1 70->1 70->58 71->60 71->62 71->62 71->72 72->1 72->22 72->28 72->46 72->61 72->62 72->62 72->73 73->1 73->48 73->63 73->74 73->78 73->107 73->108 73->111 74->1 74->1 74->1 74->77 75->1 75->1 75->58 75->59 75->64 75->64 75->76 75->100 75->101 75->105 76->1 76->1 76->58 76->59 76->64 76->64 77->1 77->71 78->1 78->1 78->74 78->74 78->79 78->109 78->110 78->112 79->1 79->1 79->74 79->74 80->22 80->28 80->43 80->46 80->50 80->61 80->66 80->67 80->72
>>>Token int main ( ) { int i , j , k ; int o , p ; int r ; int tn , sn ; int c , d , n ; char EXC [ 200 ] ; POKXI ( " " , & tn ) ; for ( k = 1 ; k <= tn ; k ++ ) { POKXI ( " " , & c ) ; for ( i = 0 ; i < c ; i ++ ) POKXI ( " " , BVV [ i ] ) ; POKXI ( " " , & d ) ; for ( i = 0 ; i < d ; i ++ ) POKXI ( " " , EQRW [ i ] ) ; POKXI ( " " , & n , EXC ) ; sn = - 1 ; for ( i = 0 ; i < n ; i ++ ) { ++ sn ; PVJ [ sn ] = EXC [ i ] ; for ( j = 0 ; j < c && sn >= 1 ; j ++ ) { if ( PVJ [ sn ] == BVV [ j ] [ 0 ] && PVJ [ sn - 1 ] == BVV [ j ] [ 1 ] ) { sn -- ; sn -- ; sn ++ ; PVJ [ sn ] = BVV [ j ] [ 2 ] ; } else if ( PVJ [ sn - 1 ] == BVV [ j ] [ 0 ] && PVJ [ sn ] == BVV [ j ] [ 1 ] ) { sn -- ; sn -- ; sn ++ ; PVJ [ sn ] = BVV [ j ] [ 2 ] ; } } for ( j = 0 , r = 0 ; j < d && sn >= 1 ; j ++ ) { for ( o = 0 ; r == 0 && o <= sn ; o ++ ) { for ( p = 0 ; r == 0 && p <= sn ; p ++ ) { if ( o == p ) continue ; if ( EQRW [ j ] [ 0 ] == PVJ [ o ] && EQRW [ j ] [ 1 ] == PVJ [ p ] ) { r = 1 ; } } } if ( r ) break ; } if ( r ) { sn = - 1 ; } } printf ( " " , k ) ; for ( i = 0 ; i <= sn ; i ++ ) { if ( i ) printf ( " " ) ; printf ( " " , PVJ [ i ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD OLUJCD
METHOD_RETURN int
<operator>.assignment OPDA = 0
<operator>.assignment BNMP = - 1
<operator>.assignment GTKR = - 1
RETURN return 0 ; return 0 ;
<operator>.lessThan i < n
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.minus - 1
<operator>.minus - 1
<operator>.assignment i = 1
<operator>.greaterThan NMXC [ s [ i ] - 'A' ] [ s [ i - 1 ] - 'A' ] > 0
<operator>.lessThan k < i
<operator>.postIncrement k ++
<operator>.assignment ODY [ OPDA ++ ] = NMXC [ s [ i ] - 'A' ] [ s [ i - 1 ] - 'A' ]
<operator>.assignment ODY [ OPDA ] = '\0'
<operator>.assignment n = OPDA
strcpy strcpy ( s , ODY )
RETURN return 1 ; return 1 ;
<operator>.assignment k = 0
<operator>.lessThan j < i - 1
<operator>.postIncrement j ++
<operator>.assignment ODY [ OPDA ++ ] = s [ j ]
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment ODY [ OPDA ++ ] = s [ j ]
LITERAL 1 return 1 ;
<operator>.greaterThan XULD [ s [ i ] - 'A' ] [ s [ k ] - 'A' ] > 0
<operator>.subtraction s [ i - 1 ] - 'A'
<operator>.assignment j = 0
<operator>.assignment j = i + 1
<operator>.assignment ODY [ OPDA ] = '\0'
<operator>.assignment n = OPDA
strcpy strcpy ( s , ODY )
RETURN return 1 ; return 1 ;
<operator>.subtraction s [ i ] - 'A'
<operator>.subtraction i - 1
<operator>.postIncrement OPDA ++
<operator>.subtraction s [ i - 1 ] - 'A'
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment ODY [ OPDA ++ ] = s [ j ]
LITERAL 1 return 1 ;
<operator>.subtraction i - 1
<operator>.postIncrement OPDA ++
<operator>.subtraction s [ i ] - 'A'
<operator>.addition i + 1
<operator>.postIncrement OPDA ++
<operator>.subtraction s [ k ] - 'A'
<operator>.assignment j = i + 1
<operator>.subtraction i - 1
<operator>.subtraction s [ i ] - 'A'
<operator>.addition i + 1
<operator>.postIncrement OPDA ++
<operator>.assignment i = BNMP
<operator>.assignment k = GTKR
<operator>.assignment ODY [ OPDA ] = '\0'
<operator>.assignment n = OPDA
strcpy strcpy ( s , ODY )
RETURN return 1 ; return 1 ;
<operator>.equals BNMP == - 1
<operator>.lessThan j < i
<operator>.postIncrement j ++
<operator>.assignment ODY [ OPDA ++ ] = s [ j ]
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment ODY [ OPDA ++ ] = s [ j ]
<operator>.indirectIndexAccess ODY [ OPDA ]
RETURN return 0 ; return 0 ;
<operator>.assignment j = 0
<operator>.indirectIndexAccess ODY [ OPDA ++ ]
<operator>.indirectIndexAccess s [ j ]
<operator>.assignment j = k + 1
<operator>.indirectIndexAccess ODY [ OPDA ++ ]
<operator>.indirectIndexAccess s [ j ]
<operator>.postIncrement OPDA ++
<operator>.addition k + 1
<operator>.postIncrement OPDA ++
<operator>.indirectIndexAccess NMXC [ s [ i ] - 'A' ] [ s [ i - 1 ] - 'A' ]
<operator>.indirectIndexAccess NMXC [ s [ i ] - 'A' ]
<operator>.indirectIndexAccess ODY [ OPDA ++ ]
<operator>.indirectIndexAccess NMXC [ s [ i ] - 'A' ] [ s [ i - 1 ] - 'A' ]
<operator>.indirectIndexAccess ODY [ OPDA ]
<operator>.indirectIndexAccess s [ i - 1 ]
<operator>.indirectIndexAccess ODY [ OPDA ++ ]
<operator>.indirectIndexAccess s [ j ]
<operator>.indirectIndexAccess NMXC [ s [ i ] - 'A' ]
<operator>.indirectIndexAccess ODY [ OPDA ++ ]
<operator>.indirectIndexAccess s [ j ]
<operator>.indirectIndexAccess XULD [ s [ i ] - 'A' ] [ s [ k ] - 'A' ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i - 1 ]
<operator>.indirectIndexAccess XULD [ s [ i ] - 'A' ]
<operator>.indirectIndexAccess ODY [ OPDA ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ k ]
<operator>.indirectIndexAccess ODY [ OPDA ++ ]
<operator>.indirectIndexAccess s [ j ]
<operator>.indirectIndexAccess s [ i ]
>>>PDG&100 0->2 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 2->1 2->33 2->38 2->45 2->54 3->1 3->1 4->1 4->1 4->1 5->1 6->1 6->5 6->12 6->24 6->29 6->36 6->40 6->44 6->44 6->79 6->80 6->84 6->91 7->1 7->6 8->5 9->3 10->4 11->1 11->6 12->1 12->13 12->15 12->15 12->16 12->17 12->18 12->19 12->20 12->21 12->24 12->30 12->31 12->37 12->38 12->39 12->46 12->47 12->51 12->81 12->82 12->83 12->87 12->92 12->95 13->1 13->1 13->6 13->7 13->7 13->14 13->28 13->49 13->50 13->52 13->53 13->90 13->93 13->96 13->99 14->1 14->13 15->1 15->1 15->1 15->18 16->1 16->1 16->18 17->1 17->1 17->1 18->1 18->1 18->1 19->1 20->1 20->13 21->1 21->21 21->22 21->22 21->23 21->37 21->45 21->85 21->86 22->1 22->21 23->1 23->1 24->1 24->1 24->24 24->25 24->25 24->26 24->48 24->88 24->89 25->1 25->24 26->1 26->1 26->1 26->18 27->19 28->1 28->1 28->13 28->14 28->32 28->33 28->34 28->35 28->40 28->50 28->53 28->94 29->34 29->39 30->1 30->21 31->1 31->1 31->24 32->34 35->1 36->46 36->52 37->21 37->21 37->51 38->17 38->48 39->1 39->18 40->40 40->41 40->41 40->42 40->54 40->97 40->98 41->40 42->34 43->35 44->13 44->37 45->38 46->1 46->18 47->1 48->17 49->1 49->18 49->34 50->40 51->31 51->47 52->34 52->36 54->33 61->55 61->56 61->57 61->58 61->59 61->60 61->62 61->65 61->68 61->69 61->70 61->73 61->77 62->62 62->63 62->64 62->71 62->72 62->76 65->65 65->66 65->67 65->74 65->75 65->78
>>>Token int OLUJCD ( ) { int OPDA = 0 ; char ODY [ 110 ] ; int MON [ 110 ] ; int i ; int j ; int k ; int IVGT ; int BNMP = - 1 ; int GTKR = - 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( NMXC [ s [ i ] - ' ' ] [ s [ i - 1 ] - ' ' ] > 0 ) { for ( j = 0 ; j < i - 1 ; j ++ ) ODY [ OPDA ++ ] = s [ j ] ; ODY [ OPDA ++ ] = NMXC [ s [ i ] - ' ' ] [ s [ i - 1 ] - ' ' ] ; for ( j = i + 1 ; j < n ; j ++ ) ODY [ OPDA ++ ] = s [ j ] ; ODY [ OPDA ] = ' \0 ' ; n = OPDA ; strcpy ( s , ODY ) ; return 1 ; } for ( k = 0 ; k < i ; k ++ ) { if ( XULD [ s [ i ] - ' ' ] [ s [ k ] - ' ' ] > 0 ) { for ( j = i + 1 ; j < n ; j ++ ) ODY [ OPDA ++ ] = s [ j ] ; ODY [ OPDA ] = ' \0 ' ; n = OPDA ; strcpy ( s , ODY ) ; return 1 ; } } } return 0 ; if ( BNMP == - 1 ) return 0 ; i = BNMP ; k = GTKR ; for ( j = 0 ; j < i ; j ++ ) ODY [ OPDA ++ ] = s [ j ] ; for ( j = k + 1 ; j < n ; j ++ ) ODY [ OPDA ++ ] = s [ j ] ; ODY [ OPDA ] = ' \0 ' ; n = OPDA ; strcpy ( s , ODY ) ; return 1 ; }
>>>Func
METHOD YMRFPOGDPJYBQUPG
METHOD_RETURN void
PARAM int FWOGXM
PARAM int RMNX
PARAM int nm
<operator>.equals FWOGXM == 1
<operator>.equals FWOGXM == 2
<operator>.assignment RHYK [ 60 ] = "Player 1 - Position the size boat 1 (1/6)"
<operator>.assignment RXXM [ 60 ] = "Player 1 - Position the size boat 1 (2/6)"
<operator>.assignment DPBM [ 60 ] = "Player 1 - Position the size boat 1 (3/6)"
<operator>.assignment TSXU [ 60 ] = "Player 1 - Position the size boat 1 (4/6)"
<operator>.assignment TPSJ [ 60 ] = "Player 1 - Position the size boat 1 (5/6)"
<operator>.assignment VXIK [ 60 ] = "Player 1 - Position the size boat 1 (6/6)"
<operator>.assignment EJWX [ 60 ] = "Player 1 - Position the size boat 2 (1/4)"
<operator>.assignment XMWQ [ 60 ] = "Player 1 - Position the size boat 2 (2/4)"
<operator>.assignment TXDO [ 60 ] = "Player 1 - Position the size boat 2 (3/4)"
<operator>.assignment VBDCR [ 60 ] = "Player 1 - Position the size boat 2 (4/4)"
<operator>.assignment GQNYO [ 60 ] = "Player 1 - Position the size boat 3 (1/2)"
<operator>.assignment IUEBG [ 60 ] = "Player 1 - Position the size boat 3 (2/2)"
<operator>.assignment RHYK [ 60 ] = "Player 2 - Position the size boat 1 (1/6)"
<operator>.assignment RXXM [ 60 ] = "Player 2 - Position the size boat 1 (2/6)"
<operator>.assignment DPBM [ 60 ] = "Player 2 - Position the size boat 1 (3/6)"
<operator>.assignment TSXU [ 60 ] = "Player 2 - Position the size boat 1 (4/6)"
<operator>.assignment TPSJ [ 60 ] = "Player 2 - Position the size boat 1 (5/6)"
<operator>.assignment VXIK [ 60 ] = "Player 2 - Position the size boat 1 (6/6)"
<operator>.assignment EJWX [ 60 ] = "Player 2 - Position the size boat 2 (1/4)"
<operator>.assignment XMWQ [ 60 ] = "Player 2 - Position the size boat 2 (2/4)"
<operator>.assignment TXDO [ 60 ] = "Player 2 - Position the size boat 2 (3/4)"
<operator>.assignment VBDCR [ 60 ] = "Player 2 - Position the size boat 2 (4/4)"
<operator>.assignment GQNYO [ 60 ] = "Player 2 - Position the size boat 3 (1/2)"
<operator>.assignment IUEBG [ 60 ] = "Player 2 - Position the size boat 3 (2/2)"
<operator>.equals RMNX == 1
<operator>.equals RMNX == 1
<operator>.equals nm == 1
<operator>.equals nm == 1
CCONIAMHYCGR CCONIAMHYCGR ( RHYK )
<operator>.equals RMNX == 2
CCONIAMHYCGR CCONIAMHYCGR ( RHYK )
<operator>.equals RMNX == 2
<operator>.equals nm == 2
<operator>.equals nm == 1
<operator>.equals nm == 2
<operator>.equals nm == 1
CCONIAMHYCGR CCONIAMHYCGR ( RXXM )
CCONIAMHYCGR CCONIAMHYCGR ( EJWX )
<operator>.equals RMNX == 3
CCONIAMHYCGR CCONIAMHYCGR ( RXXM )
CCONIAMHYCGR CCONIAMHYCGR ( EJWX )
<operator>.equals RMNX == 3
<operator>.equals nm == 3
<operator>.equals nm == 2
<operator>.equals nm == 1
<operator>.equals nm == 2
<operator>.equals nm == 3
<operator>.equals nm == 2
<operator>.equals nm == 1
CCONIAMHYCGR CCONIAMHYCGR ( DPBM )
CCONIAMHYCGR CCONIAMHYCGR ( XMWQ )
CCONIAMHYCGR CCONIAMHYCGR ( GQNYO )
CCONIAMHYCGR CCONIAMHYCGR ( IUEBG )
CCONIAMHYCGR CCONIAMHYCGR ( DPBM )
CCONIAMHYCGR CCONIAMHYCGR ( XMWQ )
CCONIAMHYCGR CCONIAMHYCGR ( GQNYO )
<operator>.equals nm == 4
<operator>.equals nm == 3
<operator>.equals nm == 4
<operator>.equals nm == 3
<operator>.equals nm == 2
CCONIAMHYCGR CCONIAMHYCGR ( TSXU )
CCONIAMHYCGR CCONIAMHYCGR ( TXDO )
CCONIAMHYCGR CCONIAMHYCGR ( TSXU )
CCONIAMHYCGR CCONIAMHYCGR ( TXDO )
CCONIAMHYCGR CCONIAMHYCGR ( IUEBG )
<operator>.equals nm == 5
<operator>.equals nm == 4
<operator>.equals nm == 5
<operator>.equals nm == 4
CCONIAMHYCGR CCONIAMHYCGR ( TPSJ )
CCONIAMHYCGR CCONIAMHYCGR ( VBDCR )
CCONIAMHYCGR CCONIAMHYCGR ( TPSJ )
CCONIAMHYCGR CCONIAMHYCGR ( VBDCR )
<operator>.equals nm == 6
<operator>.equals nm == 6
CCONIAMHYCGR CCONIAMHYCGR ( VXIK )
CCONIAMHYCGR CCONIAMHYCGR ( VXIK )
>>>PDG&85 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 2->5 3->31 3->32 4->33 4->34 4->40 4->42 4->51 4->55 5->1 5->6 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->17 5->18 5->31 6->1 6->1 6->19 6->20 6->21 6->22 6->23 6->24 6->25 6->26 6->27 6->28 6->29 6->30 6->32 7->1 7->35 8->1 8->43 9->1 9->56 10->1 10->68 11->1 11->77 12->1 12->83 13->1 13->44 14->1 14->57 15->1 15->69 16->1 16->78 17->1 17->58 18->1 18->59 19->1 19->37 20->1 20->1 20->46 21->1 21->1 21->60 22->1 22->1 22->70 23->1 23->1 23->79 24->1 24->1 24->84 25->1 25->1 25->47 26->1 26->1 26->61 27->1 27->1 27->71 28->1 28->1 28->80 29->1 29->1 29->62 30->1 30->1 30->72 31->32 31->33 31->36 31->36 32->1 32->1 32->34 32->38 32->38 33->34 33->35 33->39 33->39 33->42 33->55 34->1 34->1 34->37 34->41 34->41 36->1 36->32 36->40 36->45 36->45 37->1 37->1 38->42 38->48 38->48 39->1 39->34 39->42 39->43 39->49 39->49 39->55 40->34 40->42 40->44 40->50 40->50 40->55 41->46 41->53 41->53 42->47 42->54 42->54 43->1 44->1 45->1 45->32 45->51 45->52 48->55 49->1 49->34 49->42 49->55 49->56 49->63 49->63 50->1 50->34 50->42 50->55 50->57 50->64 50->64 51->52 51->58 52->1 52->34 52->42 52->55 52->59 53->60 53->65 53->65 54->61 54->66 54->66 55->62 55->67 55->67 56->1 57->1 58->1 59->1 63->1 63->34 63->42 63->55 63->68 63->73 63->73 64->1 64->34 64->42 64->55 64->69 64->74 64->74 65->70 65->75 65->75 66->71 66->76 66->76 67->72 68->1 69->1 73->1 73->34 73->42 73->55 73->77 73->81 73->81 74->1 74->34 74->42 74->55 74->78 75->79 75->82 75->82 76->80 77->1 78->1 81->1 81->34 81->42 81->55 81->83 82->84 83->1
>>>Token void YMRFPOGDPJYBQUPG ( int FWOGXM , int RMNX , int nm ) { if ( FWOGXM == 1 ) { char RHYK [ 60 ] = " " ; char RXXM [ 60 ] = " " ; char DPBM [ 60 ] = " " ; char TSXU [ 60 ] = " " ; char TPSJ [ 60 ] = " " ; char VXIK [ 60 ] = " " ; char EJWX [ 60 ] = " " ; char XMWQ [ 60 ] = " " ; char TXDO [ 60 ] = " " ; char VBDCR [ 60 ] = " " ; char GQNYO [ 60 ] = " " ; char IUEBG [ 60 ] = " " ; if ( RMNX == 1 ) { if ( nm == 1 ) { CCONIAMHYCGR ( RHYK ) ; } else if ( nm == 2 ) { CCONIAMHYCGR ( RXXM ) ; } else if ( nm == 3 ) { CCONIAMHYCGR ( DPBM ) ; } else if ( nm == 4 ) { CCONIAMHYCGR ( TSXU ) ; } else if ( nm == 5 ) { CCONIAMHYCGR ( TPSJ ) ; } else if ( nm == 6 ) { CCONIAMHYCGR ( VXIK ) ; } } else if ( RMNX == 2 ) { if ( nm == 1 ) { CCONIAMHYCGR ( EJWX ) ; } else if ( nm == 2 ) { CCONIAMHYCGR ( XMWQ ) ; } else if ( nm == 3 ) { CCONIAMHYCGR ( TXDO ) ; } else if ( nm == 4 ) { CCONIAMHYCGR ( VBDCR ) ; } } else if ( RMNX == 3 ) { if ( nm == 1 ) { CCONIAMHYCGR ( GQNYO ) ; } if ( nm == 2 ) { CCONIAMHYCGR ( IUEBG ) ; } } } if ( FWOGXM == 2 ) { char RHYK [ 60 ] = " " ; char RXXM [ 60 ] = " " ; char DPBM [ 60 ] = " " ; char TSXU [ 60 ] = " " ; char TPSJ [ 60 ] = " " ; char VXIK [ 60 ] = " " ; char EJWX [ 60 ] = " " ; char XMWQ [ 60 ] = " " ; char TXDO [ 60 ] = " " ; char VBDCR [ 60 ] = " " ; char GQNYO [ 60 ] = " " ; char IUEBG [ 60 ] = " " ; if ( RMNX == 1 ) { if ( nm == 1 ) { CCONIAMHYCGR ( RHYK ) ; } else if ( nm == 2 ) { CCONIAMHYCGR ( RXXM ) ; } else if ( nm == 3 ) { CCONIAMHYCGR ( DPBM ) ; } else if ( nm == 4 ) { CCONIAMHYCGR ( TSXU ) ; } else if ( nm == 5 ) { CCONIAMHYCGR ( TPSJ ) ; } else if ( nm == 6 ) { CCONIAMHYCGR ( VXIK ) ; } } else if ( RMNX == 2 ) { if ( nm == 1 ) { CCONIAMHYCGR ( EJWX ) ; } else if ( nm == 2 ) { CCONIAMHYCGR ( XMWQ ) ; } else if ( nm == 3 ) { CCONIAMHYCGR ( TXDO ) ; } else if ( nm == 4 ) { CCONIAMHYCGR ( VBDCR ) ; } } else if ( RMNX == 3 ) { if ( nm == 1 ) { CCONIAMHYCGR ( GQNYO ) ; } else if ( nm == 2 ) { CCONIAMHYCGR ( IUEBG ) ; } } } }
>>>Func
METHOD main
METHOD_RETURN int
NBKEM NBKEM ( "%d" , & tn )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan ti <= tn
<operator>.preIncrement ++ ti
LITERAL 0 return 0 ;
<operator>.assignment ti = 1
printf printf ( "Case #%d: " , ti )
NBKEM NBKEM ( "%lld%lld%lld" , & n , & pd , & pg )
<operator>.logicalAnd n >= 100 / OMM ( pd , 100 ) && ! ( pd != 100 && pg == 100 ) && ! ( pd && ! pg )
printf printf ( "Possible\n" )
<operator>.logicalAnd n >= 100 / OMM ( pd , 100 ) && ! ( pd != 100 && pg == 100 )
<operator>.logicalNot ! ( pd && ! pg )
printf printf ( "Broken\n" )
<operator>.greaterEqualsThan n >= 100 / OMM ( pd , 100 )
<operator>.logicalNot ! ( pd != 100 && pg == 100 )
<operator>.logicalAnd pd && ! pg
<operator>.division 100 / OMM ( pd , 100 )
<operator>.logicalAnd pd != 100 && pg == 100
<operator>.logicalNot ! pg
OMM OMM ( pd , 100 )
<operator>.notEquals pd != 100
<operator>.equals pg == 100
<operator>.addressOf & n
<operator>.addressOf & pd
<operator>.addressOf & pg
>>>PDG&27 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->14 0->15 0->17 0->18 0->20 0->21 0->22 0->23 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->8 4->9 4->10 4->12 4->15 4->18 4->21 4->24 4->25 4->26 5->1 5->4 6->3 7->1 7->4 8->1 8->5 9->1 9->1 9->1 9->1 9->15 9->17 9->20 9->21 9->22 9->23 10->1 10->1 10->1 10->11 10->14 11->1 12->1 12->1 12->10 12->10 12->13 12->17 12->20 13->1 13->10 14->1 15->1 15->1 15->9 15->12 15->12 15->16 15->19 15->22 16->1 16->12 17->1 17->1 17->9 17->13 17->13 17->21 18->1 18->15 18->15 19->1 19->1 19->16 19->16 20->1 20->9 20->17 20->23 21->1 21->9 21->17 21->18 21->18 21->22 22->1 22->9 22->17 22->19 22->19 22->21 22->23 23->1 23->9 23->19 23->19 23->20
>>>Token int main ( ) { NBKEM ( " " , & tn ) ; for ( ti = 1 ; ti <= tn ; ++ ti ) { printf ( " " , ti ) ; NBKEM ( " " , & n , & pd , & pg ) ; if ( n >= 100 / OMM ( pd , 100 ) && ! ( pd != 100 && pg == 100 ) && ! ( pd && ! pg ) ) printf ( " \n " ) ; else printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD DVCUM
METHOD_RETURN void
PARAM void
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.assignment i = 0
printf printf ( "Case #%d: " , i + 1 )
ULXTF ULXTF ( UXD , SZ , stdin )
<operator>.assignment x = KWEQHMIMK ( UXD )
printf printf ( "%d\n" , x )
<operator>.addition i + 1
KWEQHMIMK KWEQHMIMK ( UXD )
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 2->1 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->6 3->7 3->8 3->9 3->10 3->10 3->11 4->1 4->3 5->1 5->3 7->1 7->11 8->9 11->7 11->8
>>>Token void DVCUM ( void ) { char UXD [ SZ ] ; int i ; for ( i = 0 ; i < N ; i ++ ) { int x ; printf ( " " , i + 1 ) ; ULXTF ( UXD , SZ , stdin ) ; x = KWEQHMIMK ( UXD ) ; printf ( " \n " , x ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan h <= nc
<operator>.postIncrement h ++
LITERAL 0 return 0 ;
<operator>.expressionList PWBVG ( "%d" , & nc )   h = 1
PWBVG PWBVG ( "%d" , & n )
<operator>.assignment r = THLRJPFP
memset memset ( JGC   0   sizeof ( JGC ) )
bt bt ( 0 , 0 )
printf printf ( "Case #%d: %d\n" , h , r )
<operator>.lessThan i < 2
<operator>.postIncrement i ++
PWBVG PWBVG ( "%d" , & nc )
<operator>.assignment h = 1
<operator>.assignment i = 0
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment j = 0
PWBVG PWBVG ( "%d"   & ( v [ i ] [ j ] ) )
<operator>.addressOf & n
<operator>.sizeOf sizeof ( JGC )
<operator>.addressOf & ( v [ i ] [ j ] )
<operator>.indirectIndexAccess v [ i ] [ j ]
<operator>.indirectIndexAccess v [ i ]
>>>PDG&27 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 2->1 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->17 4->22 4->23 5->1 5->4 6->3 7->1 7->1 7->1 8->1 8->1 8->18 9->1 9->1 9->12 10->1 10->1 11->1 12->1 12->1 12->5 13->1 13->1 13->13 13->14 13->14 13->18 13->20 14->1 14->13 15->1 15->4 15->7 15->7 16->4 16->7 17->1 17->13 18->1 18->1 18->1 18->8 18->18 18->19 18->19 18->21 18->24 18->25 18->26 19->1 19->18 20->1 20->18 21->1 21->1
>>>Token int main ( void ) { int nc , h ; int i , j ; for ( PWBVG ( " " , & nc ) , h = 1 ; h <= nc ; h ++ ) { PWBVG ( " " , & n ) ; for ( i = 0 ; i < 2 ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { PWBVG ( " " , & ( v [ i ] [ j ] ) ) ; } } r = THLRJPFP ; memset ( JGC , 0 , sizeof ( JGC ) ) ; bt ( 0 , 0 ) ; printf ( " \n " , h , r ) ; } return 0 ; }
>>>Func
METHOD HPBJQQBFWGG
METHOD_RETURN struct ACWNAMQN
PARAM struct ACWNAMQN * WYYN
<operator>.assignment * FOE = NULL
RETURN return FOE ; return FOE ;
IDENTIFIER WYYN while (WYYN)
IDENTIFIER FOE return FOE ;
<operator>.assignment * IHWWHYYH = WYYN
<operator>.assignment WYYN = WYYN -> OBTI
<operator>.assignment IHWWHYYH -> OBTI = FOE
<operator>.assignment FOE = IHWWHYYH
>>>PDG&11 0->2 0->3 0->5 0->6 0->7 0->9 0->10 2->1 2->7 3->1 3->1 3->1 3->6 3->9 4->1 6->4 7->1 7->10 8->1 8->1 8->1 8->7 9->1 9->1 10->1 10->1 10->1 10->6 10->9
>>>Token struct ACWNAMQN * HPBJQQBFWGG ( struct ACWNAMQN * WYYN ) { struct ACWNAMQN * FOE = NULL ; while ( WYYN ) { struct ACWNAMQN * IHWWHYYH = WYYN ; WYYN = WYYN -> OBTI ; IHWWHYYH -> OBTI = FOE ; FOE = IHWWHYYH ; } return FOE ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
ACPG ACPG ( )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 3->1 4->1 5->4
>>>Token int main ( void ) { ACPG ( ) ; return 0 ; }
>>>Func
METHOD QCHAF
METHOD_RETURN void
<operator>.assignment N = 300
<operator>.assignment TIAEQMWH = 2
<operator>.assignment WSAFXIP = 30
<operator>.assignment * * X = ( double * * ) malloc ( N * sizeof ( double * ) )
<operator>.assignment W . UFSY = WSAFXIP
<operator>.assignment W . VIYF = WSAFXIP
<operator>.assignment W . FTFM = TIAEQMWH
<operator>.assignment W . RQDV = ( double * ) malloc ( WSAFXIP * WSAFXIP * TIAEQMWH * sizeof ( double ) )
KKIIEBHGAALMKJB KKIIEBHGAALMKJB ( X , N )
TMQXSXBGDOVD TMQXSXBGDOVD ( "test1.csv" , X , N , TIAEQMWH )
YKUXVFIGMKOSM YKUXVFIGMKOSM ( "w11.csv" , & W )
QGYCPBXETXW QGYCPBXETXW ( X , & W , N , TIAEQMWH , WSAFXIP , 1e-4 )
YKUXVFIGMKOSM YKUXVFIGMKOSM ( "w12.csv" , & W )
free free ( X )
free free ( W . RQDV )
<operator>.lessThan i < HVT ( WSAFXIP , N )
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
free free ( X [ i ] )
<operator>.cast ( double * * ) malloc ( N * sizeof ( double * ) )
<operator>.cast ( double * ) malloc ( WSAFXIP * WSAFXIP * TIAEQMWH * sizeof ( double ) )
<operator>.assignment i = 0
<operator>.assignment i = 0
malloc malloc ( N * sizeof ( double * ) )
malloc malloc ( WSAFXIP * WSAFXIP * TIAEQMWH * sizeof ( double ) )
HVT HVT ( WSAFXIP , N )
<operator>.lessThan i < N
<operator>.lessThan i < WSAFXIP
<operator>.multiplication N * sizeof ( double * )
<operator>.multiplication WSAFXIP * WSAFXIP * TIAEQMWH * sizeof ( double )
<operator>.assignment X [ i ] = ( double * ) malloc ( TIAEQMWH * sizeof ( double ) )
<operator>.multiplication WSAFXIP * WSAFXIP * TIAEQMWH
<operator>.sizeOf sizeof ( double )
<operator>.lessThan k < WSAFXIP
<operator>.postIncrement k ++
<operator>.multiplication WSAFXIP * WSAFXIP
<operator>.cast ( double * ) malloc ( TIAEQMWH * sizeof ( double ) )
<operator>.assignment k = 0
IDENTIFIER QPVV <empty>
<operator>.lessThan j < TIAEQMWH
<operator>.postIncrement j ++
malloc malloc ( TIAEQMWH * sizeof ( double ) )
<operator>.multiplication TIAEQMWH * sizeof ( double )
<operator>.sizeOf sizeof ( double )
<operator>.indirectIndexAccess X [ i ]
<operator>.indirectIndexAccess X [ i ]
UNKNOWN double * double *
UNKNOWN B B
UNKNOWN V V
UNKNOWN for ( j <IXRQWYW ')'> = 0 ; for ( j <IXRQWYW ')'> = 0 ;
UNKNOWN + +
UNKNOWN,) { double * w = QFJKVOIDNCGHDLE ( & W , i , k , j ) ; w [ 0 ] = LNXJOOY ( - 5 , 5 ) ; },) { double * w = QFJKVOIDNCGHDLE ( & W , i , k , j ) ; w [ 0 ] = LNXJOOY ( - 5 , 5 ) ; }
>>>PDG&55 0->2 0->3 0->4 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->24 0->25 0->28 0->29 0->30 0->31 0->34 0->36 0->37 0->38 0->40 0->41 0->42 0->43 0->45 2->1 2->31 3->1 3->8 3->34 4->1 4->6 4->7 4->38 5->1 5->1 5->10 6->1 6->1 6->12 6->13 6->14 6->16 7->1 7->1 7->12 7->13 7->14 7->16 8->1 8->1 8->12 8->13 8->14 8->16 9->1 9->1 9->12 9->13 9->14 9->16 10->1 10->11 10->11 11->1 11->13 11->13 11->13 12->1 12->13 12->14 12->16 13->1 13->1 13->1 13->14 13->15 13->16 13->19 13->21 14->1 14->1 15->1 16->1 17->1 17->1 17->17 17->18 17->28 17->29 17->29 17->30 18->1 18->17 19->1 19->1 19->1 19->19 19->20 19->20 19->21 19->47 20->1 20->19 21->1 21->15 22->1 23->1 24->17 25->1 25->19 26->1 26->5 26->22 27->1 27->9 27->23 28->10 28->13 28->17 28->17 28->29 28->30 29->28 29->30 29->33 29->39 29->44 29->45 29->46 29->48 29->49 30->1 30->18 30->28 30->36 30->36 30->40 31->26 31->28 32->1 32->27 33->1 33->1 33->1 33->10 33->11 33->13 33->15 33->21 34->1 34->11 34->32 34->32 34->42 34->45 35->1 36->1 36->1 36->28 36->36 36->37 36->37 36->42 36->43 36->50 36->51 36->52 36->53 36->54 37->1 37->36 38->28 38->34 39->1 40->1 40->36 42->1 42->11 42->43 42->45 43->1 43->1 43->42 44->1 44->33 44->39 45->11 45->42 45->44 46->1
>>>Token void QCHAF ( ) { int j , N = 300 ; int TIAEQMWH = 2 ; int WSAFXIP = 30 ; double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; struct EOQWTUCEDJRTLBWS W ; W . UFSY = WSAFXIP ; W . VIYF = WSAFXIP ; W . FTFM = TIAEQMWH ; W . RQDV = ( double * ) malloc ( WSAFXIP * WSAFXIP * TIAEQMWH * sizeof ( double ) ) ; for ( int i = 0 ; i < HVT ( WSAFXIP , N ) ; i ++ ) { if ( i < N ) X [ i ] = ( double * ) malloc ( TIAEQMWH * sizeof ( double ) ) ; if ( i < WSAFXIP ) { for ( int k = 0 ; k < WSAFXIP ; k ++ ) { BTX FWIYTVB  QPVV for ( j < IXRQWYW ' ' > = 0 ; j < TIAEQMWH ; j ++ ) { double * w = QFJKVOIDNCGHDLE ( & W , i , k , j ) ; w [ 0 ] = LNXJOOY ( - 5 , 5 ) ; } } } } KKIIEBHGAALMKJB ( X , N ) ; TMQXSXBGDOVD ( " " , X , N , TIAEQMWH ) ; YKUXVFIGMKOSM ( " " , & W ) ; QGYCPBXETXW ( X , & W , N , TIAEQMWH , WSAFXIP , 1e-4 ) ; YKUXVFIGMKOSM ( " " , & W ) ; for ( int i = 0 ; i < N ; i ++ ) free ( X [ i ] ) ; free ( X ) ; free ( W . RQDV ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment EOF = XUTWH ( "Binp.txt" , "r" )
<operator>.assignment NSSV = XUTWH ( "output" , "w" )
<operator>.assignment nt = 0
GLXKEN GLXKEN ( EOF , "%d" , & nt )
fprintf fprintf ( NSSV , "\n" )
ORJEVB ORJEVB ( EOF )
ORJEVB ORJEVB ( NSSV )
RETURN return 0 ; return 0 ;
<operator>.equals EOF == NULL
<operator>.equals NSSV == NULL
<operator>.lessThan it < nt
<operator>.postIncrement it ++
LITERAL 0 return 0 ;
XUTWH XUTWH ( "Binp.txt" , "r" )
printf printf ( "\nerror input file\n" )
XUTWH XUTWH ( "output" , "w" )
printf printf ( "\nERROR -output file\n" )
<operator>.assignment it = 0
printf printf ( "Case #%d: " , it + 1 )
fprintf fprintf ( NSSV , "Case #%d: " , it + 1 )
LCNF LCNF ( )
printf printf ( "\n" )
fprintf fprintf ( NSSV , "\n" )
<operator>.addition it + 1
<operator>.addition it + 1
>>>PDG&27 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->1 2->1 2->10 3->1 3->1 3->11 4->1 4->5 4->12 5->1 5->1 5->7 5->12 6->1 6->8 7->1 7->1 8->1 8->1 9->1 10->1 10->5 10->11 10->16 11->1 11->1 11->6 11->18 11->21 12->1 12->1 12->1 12->12 12->13 12->13 12->20 12->20 12->21 12->21 12->22 12->23 12->24 12->25 12->25 12->26 12->26 13->1 13->12 14->9 15->2 15->2 16->1 17->3 17->3 18->1 19->1 19->12 20->1 21->1 21->1 21->24 22->1 23->1 24->6 24->21
>>>Token int main ( ) { EOF = XUTWH ( " " , " " ) ; if ( EOF == NULL ) printf ( " \n \n " ) ; NSSV = XUTWH ( " " , " " ) ; if ( NSSV == NULL ) printf ( " \n \n " ) ; int nt , it ; nt = 0 ; GLXKEN ( EOF , " " , & nt ) ; for ( it = 0 ; it < nt ; it ++ ) { printf ( " " , it + 1 ) ; fprintf ( NSSV , " " , it + 1 ) ; LCNF ( ) ; printf ( " \n " ) ; fprintf ( NSSV , " \n " ) ; } fprintf ( NSSV , " \n " ) ; ORJEVB ( EOF ) ; ORJEVB ( NSSV ) ; return 0 ; }
>>>Func
METHOD AEQMWH
METHOD_RETURN QCHAFTI
PARAM WSAFXIPEOQW TUCEDJRTLBWS [ ]
PARAM size_t UFSY
PARAM int k
<operator>.assignment * VIYFFTFM = NULL
RETURN return VIYFFTFM ; return VIYFFTFM ;
<operator>.lessEqualsThan k <= 1
IDENTIFIER VIYFFTFM return VIYFFTFM ;
<operator>.assignment VIYFFTFM = ( QCHAFTI * ) malloc ( sizeof ( QCHAFTI ) )
memset memset ( VIYFFTFM   0   sizeof ( QCHAFTI ) )
RQDVHVTBTXFWIYTVB RQDVHVTBTXFWIYTVB ( TUCEDJRTLBWS , UFSY , VIYFFTFM )
<operator>.cast ( QCHAFTI * ) malloc ( sizeof ( QCHAFTI ) )
<operator>.sizeOf sizeof ( QCHAFTI )
<operator>.lessThan k < UFSY
<operator>.assignment VIYFFTFM = malloc ( sizeof ( QCHAFTI ) * k )
memset memset ( VIYFFTFM   0   k * sizeof ( QCHAFTI ) )
<operator>.assignment XRQWYWQ = 0
<operator>.assignment FJKVOIDNCGHDLELN = UFSY / 10000
<operator>.assignment t = 0
<operator>.lessThan j < UFSY
<operator>.postIncrement j ++
<operator>.greaterThan XRQWYWQ > FJKVOIDNCGHDLELN
<operator>.assignment VIYFFTFM = ( QCHAFTI * ) malloc ( sizeof ( QCHAFTI ) * k )
memset memset ( VIYFFTFM   0   k * sizeof ( QCHAFTI ) )
malloc malloc ( sizeof ( QCHAFTI ) * k )
<operator>.multiplication k * sizeof ( QCHAFTI )
<operator>.assignment j = 0
<operator>.assignment TUCEDJRTLBWS [ j ] . QPVVI = rand ( ) % k
<operator>.division UFSY / 10000
<operator>.assignment XRQWYWQ = 0
<operator>.lessThan j < UFSY
<operator>.postIncrement j ++
<operator>.multiplication sizeof ( QCHAFTI ) * k
<operator>.sizeOf sizeof ( QCHAFTI )
<operator>.lessThan i < k
<operator>.postIncrement i ++
<operator>.lessThan j < UFSY
<operator>.postIncrement j ++
<operator>.lessThan i < k
<operator>.postIncrement i ++
<operator>.lessThan j < UFSY
<operator>.postIncrement j ++
<operator>.cast ( QCHAFTI * ) malloc ( sizeof ( QCHAFTI ) * k )
<operator>.multiplication k * sizeof ( QCHAFTI )
<operator>.assignment j = 0
<operator>.assignment VIYFFTFM [ j ] . x = TUCEDJRTLBWS [ j ] . x
<operator>.assignment VIYFFTFM [ j ] . y = TUCEDJRTLBWS [ j ] . y
<operator>.assignment VIYFFTFM [ j ] . XJOOY = 1
<operator>.assignment TUCEDJRTLBWS [ j ] . QPVVI = j
<operator>.modulo rand ( ) % k
<operator>.assignment i = 0
<operator>.assignment VIYFFTFM [ i ] . x = 0
<operator>.assignment VIYFFTFM [ i ] . y = 0
<operator>.assignment VIYFFTFM [ i ] . XJOOY = 0
<operator>.assignment j = 0
<operator>.assignment t = TUCEDJRTLBWS [ j ] . QPVVI
<operator>.assignmentPlus VIYFFTFM [ t ] . x += TUCEDJRTLBWS [ j ] . x
<operator>.assignmentPlus VIYFFTFM [ t ] . y += TUCEDJRTLBWS [ j ] . y
<operator>.postIncrement VIYFFTFM [ t ] . XJOOY ++
<operator>.assignment i = 0
<operator>.assignmentDivision VIYFFTFM [ i ] . x /= VIYFFTFM [ i ] . XJOOY
<operator>.assignmentDivision VIYFFTFM [ i ] . y /= VIYFFTFM [ i ] . XJOOY
<operator>.assignment j = 0
<operator>.assignment t = KKIIEBHGAALMKJB ( TUCEDJRTLBWS + j , VIYFFTFM , k )
malloc malloc ( sizeof ( QCHAFTI ) * k )
<operator>.sizeOf sizeof ( QCHAFTI )
<operator>.notEquals t != TUCEDJRTLBWS [ j ] . QPVVI
<operator>.multiplication sizeof ( QCHAFTI ) * k
KKIIEBHGAALMKJB KKIIEBHGAALMKJB ( TUCEDJRTLBWS + j , VIYFFTFM , k )
<operator>.postIncrement XRQWYWQ ++
<operator>.assignment TUCEDJRTLBWS [ j ] . QPVVI = t
<operator>.addition TUCEDJRTLBWS + j
UNKNOWN QCHAFTI * QCHAFTI *
malloc malloc ( sizeof ( QCHAFTI ) )
<operator>.sizeOf sizeof ( QCHAFTI )
<operator>.sizeOf sizeof ( QCHAFTI )
<operator>.fieldAccess TUCEDJRTLBWS [ j ] . QPVVI
UNKNOWN QCHAFTI * QCHAFTI *
<operator>.indirectIndexAccess TUCEDJRTLBWS [ j ]
FIELD_IDENTIFIER QPVVI QPVVI
rand rand ( )
<operator>.fieldAccess VIYFFTFM [ j ] . x
<operator>.fieldAccess TUCEDJRTLBWS [ j ] . x
<operator>.fieldAccess VIYFFTFM [ j ] . y
<operator>.fieldAccess TUCEDJRTLBWS [ j ] . y
<operator>.fieldAccess VIYFFTFM [ j ] . XJOOY
<operator>.fieldAccess TUCEDJRTLBWS [ j ] . QPVVI
<operator>.fieldAccess VIYFFTFM [ i ] . x
<operator>.fieldAccess VIYFFTFM [ i ] . y
<operator>.fieldAccess VIYFFTFM [ i ] . XJOOY
<operator>.fieldAccess TUCEDJRTLBWS [ j ] . QPVVI
<operator>.fieldAccess VIYFFTFM [ t ] . x
<operator>.fieldAccess TUCEDJRTLBWS [ j ] . x
<operator>.fieldAccess VIYFFTFM [ t ] . y
<operator>.fieldAccess TUCEDJRTLBWS [ j ] . y
<operator>.fieldAccess VIYFFTFM [ t ] . XJOOY
<operator>.fieldAccess VIYFFTFM [ i ] . x
<operator>.fieldAccess VIYFFTFM [ i ] . XJOOY
<operator>.fieldAccess VIYFFTFM [ i ] . y
<operator>.fieldAccess VIYFFTFM [ i ] . XJOOY
<operator>.sizeOf sizeof ( QCHAFTI )
<operator>.indirectIndexAccess VIYFFTFM [ j ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess TUCEDJRTLBWS [ j ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess VIYFFTFM [ j ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess TUCEDJRTLBWS [ j ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess VIYFFTFM [ j ]
FIELD_IDENTIFIER XJOOY XJOOY
<operator>.indirectIndexAccess TUCEDJRTLBWS [ j ]
FIELD_IDENTIFIER QPVVI QPVVI
<operator>.indirectIndexAccess VIYFFTFM [ i ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess VIYFFTFM [ i ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess VIYFFTFM [ i ]
FIELD_IDENTIFIER XJOOY XJOOY
<operator>.indirectIndexAccess TUCEDJRTLBWS [ j ]
FIELD_IDENTIFIER QPVVI QPVVI
<operator>.indirectIndexAccess VIYFFTFM [ t ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess TUCEDJRTLBWS [ j ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess VIYFFTFM [ t ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess TUCEDJRTLBWS [ j ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess VIYFFTFM [ t ]
FIELD_IDENTIFIER XJOOY XJOOY
<operator>.indirectIndexAccess VIYFFTFM [ i ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess VIYFFTFM [ i ]
FIELD_IDENTIFIER XJOOY XJOOY
<operator>.indirectIndexAccess VIYFFTFM [ i ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess VIYFFTFM [ i ]
FIELD_IDENTIFIER XJOOY XJOOY
<operator>.fieldAccess TUCEDJRTLBWS [ j ] . QPVVI
<operator>.indirectIndexAccess TUCEDJRTLBWS [ j ]
FIELD_IDENTIFIER QPVVI QPVVI
<operator>.fieldAccess TUCEDJRTLBWS [ j ] . QPVVI
<operator>.indirectIndexAccess TUCEDJRTLBWS [ j ]
FIELD_IDENTIFIER QPVVI QPVVI
>>>PDG&146 0->2 0->3 0->4 0->5 0->7 0->8 0->10 0->11 0->14 0->16 0->17 0->19 0->20 0->21 0->22 0->24 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->60 0->63 0->67 0->68 0->69 0->70 0->71 0->72 2->1 2->11 2->69 2->72 3->11 3->14 4->7 5->1 5->1 6->1 7->1 7->1 7->9 7->10 7->11 7->12 7->13 7->14 7->14 7->73 7->74 7->75 8->6 9->1 9->1 9->10 10->1 10->11 11->1 11->1 11->1 11->1 11->8 12->1 13->1 14->1 14->15 14->16 14->17 14->18 14->19 14->20 14->20 14->22 14->23 14->24 14->25 14->26 14->27 14->29 14->30 14->31 14->31 14->33 14->33 14->34 14->35 14->37 14->39 14->41 14->43 14->44 14->45 14->51 14->55 14->60 14->63 14->65 14->66 14->68 14->68 14->76 14->78 14->101 15->1 15->1 15->16 16->1 16->1 16->1 16->8 16->69 18->1 18->1 18->22 19->1 19->1 20->20 20->21 20->21 20->28 20->29 20->50 20->77 20->79 20->80 20->81 21->1 21->20 22->1 22->1 22->1 22->22 22->30 22->35 22->37 22->39 22->41 22->51 22->55 22->60 22->63 23->1 23->1 23->24 24->1 24->1 24->1 24->8 25->1 25->15 26->16 26->35 26->50 27->20 28->1 28->1 29->18 29->18 29->37 30->1 30->22 30->70 31->1 31->1 31->1 31->31 31->32 31->32 31->46 31->47 31->48 31->49 31->49 31->82 31->83 31->84 31->85 31->86 31->87 31->102 31->103 31->104 31->105 31->106 31->107 31->108 31->109 31->110 31->111 31->112 31->113 32->1 32->31 33->25 33->26 34->1 35->35 35->36 35->36 35->39 35->52 35->53 35->54 35->88 35->89 35->90 35->114 35->115 35->116 35->117 35->118 35->119 36->1 36->35 37->37 37->38 37->38 37->41 37->56 37->57 37->58 37->59 37->91 37->92 37->93 37->94 37->95 37->96 37->120 37->121 37->122 37->123 37->124 37->125 37->126 37->127 37->128 37->129 37->130 37->131 38->1 38->37 39->1 39->1 39->1 39->35 39->39 39->40 39->40 39->61 39->62 39->69 39->97 39->98 39->99 39->100 39->132 39->133 39->134 39->135 39->136 39->137 39->138 39->139 40->1 40->39 41->1 41->1 41->1 41->37 41->41 41->42 41->42 41->64 41->67 41->69 41->69 41->72 41->72 41->140 41->141 41->142 42->1 42->41 43->1 44->1 44->24 45->1 45->31 46->1 47->1 48->1 49->1 50->1 50->28 50->28 50->35 51->35 52->1 53->1 54->1 55->37 56->1 56->1 57->1 57->1 58->1 58->1 59->1 59->1 60->1 60->39 61->1 62->1 63->1 63->41 64->1 64->1 64->67 65->1 65->23 65->43 66->1 67->1 67->1 67->70 67->71 67->71 67->143 67->144 67->145 68->44 68->65 69->1 69->1 69->1 69->8 69->35 69->64 69->64 69->64 70->1 70->22 71->1 71->1 72->1
>>>Token QCHAFTI * AEQMWH ( WSAFXIPEOQW TUCEDJRTLBWS [ ] , size_t UFSY , int k ) { QCHAFTI * VIYFFTFM = NULL ; if ( k <= 1 ) { VIYFFTFM = ( QCHAFTI * ) malloc ( sizeof ( QCHAFTI ) ) ; memset ( VIYFFTFM , 0 , sizeof ( QCHAFTI ) ) ; RQDVHVTBTXFWIYTVB ( TUCEDJRTLBWS , UFSY , VIYFFTFM ) ; } else if ( k < UFSY ) { VIYFFTFM = malloc ( sizeof ( QCHAFTI ) * k ) ; memset ( VIYFFTFM , 0 , k * sizeof ( QCHAFTI ) ) ; for ( size_t j = 0 ; j < UFSY ; j ++ ) { TUCEDJRTLBWS [ j ] . QPVVI = rand ( ) % k ; } size_t XRQWYWQ = 0 ; size_t FJKVOIDNCGHDLELN = UFSY / 10000 ; int t = 0 ; do { for ( int i = 0 ; i < k ; i ++ ) { VIYFFTFM [ i ] . x = 0 ; VIYFFTFM [ i ] . y = 0 ; VIYFFTFM [ i ] . XJOOY = 0 ; } for ( size_t j = 0 ; j < UFSY ; j ++ ) { t = TUCEDJRTLBWS [ j ] . QPVVI ; VIYFFTFM [ t ] . x += TUCEDJRTLBWS [ j ] . x ; VIYFFTFM [ t ] . y += TUCEDJRTLBWS [ j ] . y ; VIYFFTFM [ t ] . XJOOY ++ ; } for ( int i = 0 ; i < k ; i ++ ) { VIYFFTFM [ i ] . x /= VIYFFTFM [ i ] . XJOOY ; VIYFFTFM [ i ] . y /= VIYFFTFM [ i ] . XJOOY ; } XRQWYWQ = 0 ; for ( size_t j = 0 ; j < UFSY ; j ++ ) { t = KKIIEBHGAALMKJB ( TUCEDJRTLBWS + j , VIYFFTFM , k ) ; if ( t != TUCEDJRTLBWS [ j ] . QPVVI ) { XRQWYWQ ++ ; TUCEDJRTLBWS [ j ] . QPVVI = t ; } } } while ( XRQWYWQ > FJKVOIDNCGHDLELN ) ; } else { VIYFFTFM = ( QCHAFTI * ) malloc ( sizeof ( QCHAFTI ) * k ) ; memset ( VIYFFTFM , 0 , k * sizeof ( QCHAFTI ) ) ; for ( int j = 0 ; j < UFSY ; j ++ ) { VIYFFTFM [ j ] . x = TUCEDJRTLBWS [ j ] . x ; VIYFFTFM [ j ] . y = TUCEDJRTLBWS [ j ] . y ; VIYFFTFM [ j ] . XJOOY = 1 ; TUCEDJRTLBWS [ j ] . QPVVI = j ; } } return VIYFFTFM ; }
>>>Func
METHOD THUMQOTL
METHOD_RETURN void
PARAM int n
<operator>.notEquals QFPQ [ x ] != x
<operator>.assignment x = QFPQ [ x ]
<operator>.notEquals QFPQ [ y ] != y
<operator>.assignment x = n
<operator>.assignment y = n
<operator>.assignment z = QFPQ [ y ]
<operator>.assignment QFPQ [ y ] = x
<operator>.assignment y = z
<operator>.indirectIndexAccess QFPQ [ x ]
<operator>.indirectIndexAccess QFPQ [ x ]
<operator>.indirectIndexAccess QFPQ [ y ]
<operator>.indirectIndexAccess QFPQ [ y ]
<operator>.indirectIndexAccess QFPQ [ y ]
>>>PDG&16 0->2 0->3 0->5 0->6 0->7 0->9 0->10 2->6 2->7 3->1 3->1 3->1 3->3 3->4 3->4 3->9 3->11 3->12 4->1 4->3 5->1 5->1 5->1 5->5 5->8 5->8 5->9 5->10 5->13 5->14 5->15 6->1 6->3 7->1 7->1 7->5 8->10 9->5 10->1 10->1 10->5
>>>Token void THUMQOTL ( int n ) { int x , y , z ; for ( x = n ; QFPQ [ x ] != x ; ) x = QFPQ [ x ] ; for ( y = n ; QFPQ [ y ] != y ; ) { z = QFPQ [ y ] ; QFPQ [ y ] = x ; y = z ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment JUSQYXQNVH = 10
<operator>.assignment * KSUDXPMSEDKARBFJ = NULL
TJDUGNSBERBWFXF TJDUGNSBERBWFXF ( & argc , & argv )
RSAUQRHKXNUXFXFQ RSAUQRHKXNUXFXFQ ( argv [ 0 ] )
RRUPXKIBQ RRUPXKIBQ ( CDOJDV , "" )
BVVXOQHYOUVPCV BVVXOQHYOUVPCV ( WTOOQGO , BOQTSVICY )
EDWDBLVINK EDWDBLVINK ( WTOOQGO )
GJCKGAGWQWDGATWWMUFOTMT GJCKGAGWQWDGATWWMUFOTMT ( QRWCNHPANCDBK )
FHHVHM FHHVHM ( CJGBGSVOJPDD )
<operator>.assignment TBXXD = 0
<operator>.assignment ok = ( HMTH ( JUSQYXQNVH ) != - 1 || TBXXD == 0 )
<operator>.assignment THUMQOTLQFPQCTBV = GDUQHTKISESN ( )
<operator>.assignment ok = ( TNQAQLRYHCJ ( CICPXNNUPJKV , 0 , THUMQOTLQFPQCTBV + JUSQYXQNVH ) == 0 )
IDENTIFIER PTLL <empty>
TOCLIP TOCLIP ( argv [ i ] , & argv [ i ] )
<operator>.assignment XMTBEUUJXGF = TBXXD == STFRPK ? BRGKFQMKMDO : XLEXYBAFXWQVFVQAEK
TGNXE TGNXE ( 0   TBXXD   "%s"   KSHNK ( argv [ i ] ) )
RETURN return XMTBEUUJXGF ; return XMTBEUUJXGF ;
<operator>.lessThan i < argc
IDENTIFIER KSUDXPMSEDKARBFJ if (KSUDXPMSEDKARBFJ)
<operator>.equals i == argc
<operator>.logicalAnd THUMQOTLQFPQCTBV == - 1 && TBXXD != 0
<operator>.logicalNot ! ok
IDENTIFIER XMTBEUUJXGF return XMTBEUUJXGF ;
<operator>.assignment i = 1
<operator>.assignment * s = argv [ i ]
<operator>.assignment JUSQYXQNVH = HRT ( OTIPVMYRHFDTSH   QBL ( LCP , VWLXOCAHGVXCKT ) )
<operator>.assignment TBXXD = 0
<operator>.assignment THUMQOTLQFPQCTBV = GDUQHTKISESN ( )
printf printf ( "%d\n" , THUMQOTLQFPQCTBV )
RETURN return EXIT_SUCCESS ; return EXIT_SUCCESS ;
<operator>.logicalOr HMTH ( JUSQYXQNVH ) != - 1 || TBXXD == 0
AYT AYT ( QRWCNHPANCDBK   TBXXD   _ ( "cannot get niceness" ) )
<operator>.equals TNQAQLRYHCJ ( CICPXNNUPJKV , 0 , THUMQOTLQFPQCTBV + JUSQYXQNVH ) == 0
TGNXE TGNXE ( EEBOARFBKSULAYUEJA ( TBXXD ) ? 0 : QRWCNHPANCDBK   TBXXD   _ ( "cannot set niceness" ) )
<operator>.conditional TBXXD == STFRPK ? BRGKFQMKMDO : XLEXYBAFXWQVFVQAEK
KSHNK KSHNK ( argv [ i ] )
<operator>.logicalAnd s [ 0 ] == '-' && IUANKHF ( s [ 1 + ( s [ 1 ] == '-' || s [ 1 ] == '+' ) ] )
<operator>.lessThan ACJHJPBDYDUGBTEA < GCQKCYQ ( KSUDXPMSEDKARBFJ , NULL , 10 , & LCP , "" )
IDENTIFIER KSUDXPMSEDKARBFJ if (KSUDXPMSEDKARBFJ)
<operator>.logicalAnd THUMQOTLQFPQCTBV == - 1 && TBXXD != 0
IDENTIFIER EXIT_SUCCESS return EXIT_SUCCESS ;
<operator>.notEquals HMTH ( JUSQYXQNVH ) != - 1
<operator>.equals TBXXD == 0
<operator>.equals THUMQOTLQFPQCTBV == - 1
<operator>.notEquals TBXXD != 0
TNQAQLRYHCJ TNQAQLRYHCJ ( CICPXNNUPJKV , 0 , THUMQOTLQFPQCTBV + JUSQYXQNVH )
THNJCF THNJCF ( stderr )
<operator>.equals TBXXD == STFRPK
<operator>.assignment KSUDXPMSEDKARBFJ = s + 1
<operator>.preIncrement ++ i
AYT AYT ( QRWCNHPANCDBK   0   _ ( "invalid adjustment %s" )   KSHNK ( KSUDXPMSEDKARBFJ ) )
HRT HRT ( OTIPVMYRHFDTSH   QBL ( LCP , VWLXOCAHGVXCKT ) )
TGNXE TGNXE ( 0   0   _ ( "a command must be given with an adjustment" ) )
QCVPV QCVPV ( QRWCNHPANCDBK )
AYT AYT ( QRWCNHPANCDBK   TBXXD   _ ( "cannot get niceness" ) )
HMTH HMTH ( JUSQYXQNVH )
<operator>.minus - 1
<operator>.minus - 1
_ _ ( "cannot get niceness" )
<operator>.addition THUMQOTLQFPQCTBV + JUSQYXQNVH
<operator>.conditional EEBOARFBKSULAYUEJA ( TBXXD ) ? 0 : QRWCNHPANCDBK
_ _ ( "cannot set niceness" )
RETURN return QRWCNHPANCDBK ; return QRWCNHPANCDBK ;
<operator>.equals s [ 0 ] == '-'
IUANKHF IUANKHF ( s [ 1 + ( s [ 1 ] == '-' || s [ 1 ] == '+' ) ] )
<operator>.assignment KXJPBTUID = argc - ( i - 1 )
<operator>.assignment * * RRPVCVXKQ = argv + ( i - 1 )
<operator>.assignment RRPVCVXKQ [ 0 ] = argv [ 0 ]
<operator>.assignment TBCMEH = 0
<operator>.assignment c = WYJMLTSWRCM ( KXJPBTUID , RRPVCVXKQ , "+n:" , UYKDCCXS , NULL )
<operator>.assignmentPlus i += TBCMEH - 1
GCQKCYQ GCQKCYQ ( KSUDXPMSEDKARBFJ , NULL , 10 , & LCP , "" )
QBL QBL ( LCP , VWLXOCAHGVXCKT )
<operator>.equals THUMQOTLQFPQCTBV == - 1
<operator>.notEquals TBXXD != 0
EEBOARFBKSULAYUEJA EEBOARFBKSULAYUEJA ( TBXXD )
IDENTIFIER QRWCNHPANCDBK return QRWCNHPANCDBK ;
<operator>.addition s + 1
IDENTIFIER c switch(c)
<operator>.equals c == - 1
_ _ ( "invalid adjustment %s" )
KSHNK KSHNK ( KSUDXPMSEDKARBFJ )
_ _ ( "a command must be given with an adjustment" )
<operator>.minus - 1
_ _ ( "cannot get niceness" )
<operator>.addition 1 + ( s [ 1 ] == '-' || s [ 1 ] == '+' )
<operator>.subtraction argc - ( i - 1 )
<operator>.addition argv + ( i - 1 )
WYJMLTSWRCM WYJMLTSWRCM ( KXJPBTUID , RRPVCVXKQ , "+n:" , UYKDCCXS , NULL )
<operator>.subtraction TBCMEH - 1
LITERAL 'n' <empty>
<operator>.assignment KSUDXPMSEDKARBFJ = XCQVMI
<operator>.minus - 1
SJQNHSEGHOBXCKTWSQBMBCBJ SJQNHSEGHOBXCKTWSQBMBCBJ ( VUEJKLEFWUUE , PAMYOPA )
QCVPV QCVPV ( QRWCNHPANCDBK )
<operator>.logicalOr s [ 1 ] == '-' || s [ 1 ] == '+'
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.minus - 1
<operator>.equals s [ 1 ] == '-'
<operator>.equals s [ 1 ] == '+'
UNKNOWN L L
GDUQHTKISESN GDUQHTKISESN ( )
<operator>.indirectIndexAccess argv [ i ]
<operator>.addressOf & argv [ i ]
<operator>.indirectIndexAccess argv [ i ]
<operator>.indirectIndexAccess argv [ i ]
<operator>.indirectIndexAccess argv [ i ]
GDUQHTKISESN GDUQHTKISESN ( )
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 + ( s [ 1 ] == '-' || s [ 1 ] == '+' ) ]
<operator>.indirectIndexAccess RRPVCVXKQ [ 0 ]
<operator>.indirectIndexAccess argv [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess s [ 1 ]
>>>PDG&120 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->31 0->32 0->33 0->34 0->36 0->37 0->38 0->39 0->40 0->42 0->43 0->45 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->68 0->71 0->73 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->99 0->101 0->102 0->103 0->104 0->105 2->6 2->22 3->1 3->6 3->7 3->18 3->29 3->40 3->71 3->92 4->1 4->1 4->60 5->1 5->1 5->1 5->76 6->1 6->1 6->1 6->18 6->22 6->24 6->29 6->40 6->71 6->91 6->92 7->1 7->1 7->18 7->29 7->40 7->71 7->72 7->92 8->1 8->1 9->1 9->1 9->10 10->1 10->1 11->1 11->1 11->36 11->38 11->55 11->58 11->59 11->65 11->81 11->99 12->1 12->1 13->36 13->47 13->49 13->52 13->80 15->48 16->26 18->40 18->40 19->27 21->1 22->1 22->24 22->24 22->29 22->41 22->54 22->68 22->91 22->101 22->112 22->114 24->1 24->1 24->1 24->13 24->14 24->15 24->16 24->25 24->26 24->31 24->32 24->33 24->34 24->35 24->37 24->44 24->46 24->48 24->50 24->57 24->58 24->60 24->61 24->62 24->64 24->78 24->87 24->88 24->106 24->107 24->113 25->36 25->63 26->18 26->19 26->20 26->21 26->38 26->39 26->40 26->51 26->52 26->65 26->66 26->80 26->108 26->109 26->110 26->111 27->21 28->1 28->22 29->1 29->1 29->1 29->53 29->68 29->69 29->82 29->104 29->105 30->1 30->1 30->1 30->60 31->1 31->1 31->59 31->79 32->1 32->1 32->78 33->1 33->1 34->1 35->14 35->14 36->38 36->52 36->65 36->80 36->81 37->16 37->16 38->52 39->1 40->20 41->1 41->1 41->1 41->22 41->53 41->54 41->70 41->71 41->72 41->73 41->74 41->75 41->82 41->84 41->91 41->92 41->93 41->94 41->96 41->97 41->99 41->101 41->102 41->103 41->116 41->117 42->1 42->1 42->1 42->55 42->85 42->86 44->1 44->1 44->1 44->59 44->89 45->34 46->35 46->35 46->47 47->35 47->35 47->36 47->49 47->52 47->80 48->25 48->25 48->49 48->50 48->64 49->25 49->25 49->36 49->52 49->80 50->1 50->37 50->37 50->37 51->1 51->18 51->19 51->20 51->21 51->39 51->40 51->52 51->67 51->108 51->109 51->110 51->111 52->1 52->20 53->1 53->1 53->1 53->76 54->1 54->22 55->1 55->1 55->1 55->1 55->36 55->38 55->58 55->59 55->65 55->81 56->1 56->1 56->30 56->30 57->1 57->1 58->1 58->1 58->59 59->1 59->1 59->1 59->1 60->46 60->50 60->64 61->46 62->48 63->36 66->38 67->1 68->1 68->41 68->41 68->53 68->69 68->82 68->90 68->100 68->104 68->115 68->118 69->1 69->41 69->53 69->82 70->1 70->1 70->93 71->1 71->1 71->93 72->1 72->1 72->1 72->93 73->1 73->94 74->1 74->1 74->84 75->1 75->1 75->22 75->24 76->1 76->1 76->1 76->42 76->42 76->42 76->42 76->42 76->77 76->86 77->1 77->1 77->56 77->56 78->1 78->33 78->44 78->44 78->79 79->1 79->44 79->44 79->59 80->38 81->67 82->1 84->1 84->1 84->22 85->55 86->1 86->55 87->57 88->78 89->59 90->1 91->22 91->24 91->70 91->70 92->1 92->1 93->1 93->1 93->1 93->1 93->74 93->74 93->74 93->74 93->74 93->76 94->1 94->75 94->75 96->1 96->1 96->1 96->76 98->1 98->1 98->1 99->1 99->1 99->36 99->38 99->55 99->58 99->59 99->65 99->81 100->1 100->1 100->90 100->90 101->91 101->91 101->102 102->71 102->71 102->75 102->92 102->92 103->84 104->1 104->53 104->82 104->100 104->100 104->105 104->105 104->119 105->1 105->53 105->82 105->100 105->100 105->104
>>>Token int main ( int argc , char * * argv ) { int THUMQOTLQFPQCTBV ; int JUSQYXQNVH = 10 ; char const * KSUDXPMSEDKARBFJ = NULL ; bool ok ; int i ; TJDUGNSBERBWFXF ( & argc , & argv ) ; RSAUQRHKXNUXFXFQ ( argv [ 0 ] ) ; RRUPXKIBQ ( CDOJDV , " " ) ; BVVXOQHYOUVPCV ( WTOOQGO , BOQTSVICY ) ; EDWDBLVINK ( WTOOQGO ) ; GJCKGAGWQWDGATWWMUFOTMT ( QRWCNHPANCDBK ) ; FHHVHM ( CJGBGSVOJPDD ) ; for ( i = 1 ; i < argc ; ) { char const * s = argv [ i ] ; if ( s [ 0 ] == ' ' && IUANKHF ( s [ 1 + ( s [ 1 ] == ' ' || s [ 1 ] == ' ' ) ] ) ) { KSUDXPMSEDKARBFJ = s + 1 ; ++ i ; } else { int c ; int KXJPBTUID = argc - ( i - 1 ) ; char * * RRPVCVXKQ = argv + ( i - 1 ) ; RRPVCVXKQ [ 0 ] = argv [ 0 ] ; TBCMEH = 0 ; c = WYJMLTSWRCM ( KXJPBTUID , RRPVCVXKQ , " " , UYKDCCXS , NULL ) ; i += TBCMEH - 1 ; switch ( c ) { case ' ' : KSUDXPMSEDKARBFJ = XCQVMI ; break ; case - 1 : break ; SOMHUUGWETIXMFRQUMPFS ; SJQNHSEGHOBXCKTWSQBMBCBJ ( VUEJKLEFWUUE , PAMYOPA ) ; default : QCVPV ( QRWCNHPANCDBK ) ; break ; } if ( c == - 1 ) break ; } } if ( KSUDXPMSEDKARBFJ ) { enum { OTIPVMYRHFDTSH = 1 - 2 * CPEWW , VWLXOCAHGVXCKT = 2 * CPEWW - 1 } ; long int LCP ; if ( ACJHJPBDYDUGBTEA < GCQKCYQ ( KSUDXPMSEDKARBFJ , NULL , 10 , & LCP , " " ) ) AYT ( QRWCNHPANCDBK , 0 , _ ( " " ) , KSHNK ( KSUDXPMSEDKARBFJ ) ) ; JUSQYXQNVH = HRT ( OTIPVMYRHFDTSH , QBL ( LCP , VWLXOCAHGVXCKT ) ) ; } if ( i == argc ) { if ( KSUDXPMSEDKARBFJ ) { TGNXE ( 0 , 0 , _ ( " " ) ) ; QCVPV ( QRWCNHPANCDBK ) ; } TBXXD = 0 ; THUMQOTLQFPQCTBV = GDUQHTKISESN ( ) ; if ( THUMQOTLQFPQCTBV == - 1 && TBXXD != 0 ) AYT ( QRWCNHPANCDBK , TBXXD , _ ( " " ) ) ; printf ( " \n " , THUMQOTLQFPQCTBV ) ; return EXIT_SUCCESS ; } TBXXD = 0 ; NIXWCTNGG ok = ( HMTH ( JUSQYXQNVH ) != - 1 || TBXXD == 0 ) ; SPK THUMQOTLQFPQCTBV = GDUQHTKISESN ( ) ; if ( THUMQOTLQFPQCTBV == - 1 && TBXXD != 0 ) AYT ( QRWCNHPANCDBK , TBXXD , _ ( " " ) ) ; ok = ( TNQAQLRYHCJ ( CICPXNNUPJKV , 0 , THUMQOTLQFPQCTBV + JUSQYXQNVH ) == 0 ) ; PTLL if ( ! ok ) { TGNXE ( EEBOARFBKSULAYUEJA ( TBXXD ) ? 0 : QRWCNHPANCDBK , TBXXD , _ ( " " ) ) ; if ( THNJCF ( stderr ) ) return QRWCNHPANCDBK ; } TOCLIP ( argv [ i ] , & argv [ i ] ) ; int XMTBEUUJXGF = TBXXD == STFRPK ? BRGKFQMKMDO : XLEXYBAFXWQVFVQAEK ; TGNXE ( 0 , TBXXD , " " , KSHNK ( argv [ i ] ) ) ; return XMTBEUUJXGF ; }
>>>Func
METHOD EOFX
METHOD_RETURN int
PARAM const void * a
PARAM const void * b
<operator>.assignment aa = * ( ( long long * ) a )
<operator>.assignment bb = * ( ( long long * ) b )
<operator>.equals aa == bb
<operator>.greaterThan aa > bb
<operator>.lessThan aa < bb
RETURN return 0 ; return 0 ;
RETURN return 1 ; return 1 ;
RETURN return - 1 ; return - 1 ;
<operator>.cast ( long long * ) a
<operator>.cast ( long long * ) b
LITERAL 0 return 0 ;
LITERAL 1 return 1 ;
<operator>.minus - 1
>>>PDG&17 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 2->12 3->13 4->1 4->1 4->6 5->1 5->1 5->6 6->1 6->1 6->1 6->7 6->7 6->7 6->9 7->8 7->8 7->8 7->10 8->11 8->16 9->1 10->1 11->1 12->1 13->1 14->9 15->10 16->11
>>>Token int EOFX ( const void * a , const void * b ) { long long aa = * ( ( long long * ) a ) ; long long bb = * ( ( long long * ) b ) ; if ( aa == bb ) return 0 ; if ( aa > bb ) return 1 ; if ( aa < bb ) return - 1 ; }
>>>Func
METHOD SIXAEPVIKRI
METHOD_RETURN int
PARAM char * * TMLCANHQ
PARAM char * IAJCGUT
PARAM int n
RETURN return 0 ; return 0 ;
<operator>.lessThan i < n
<operator>.preIncrement ++ i
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.equals strcmp ( TMLCANHQ [ i ] , IAJCGUT ) == 0
RETURN return 1 ; return 1 ;
strcmp strcmp ( TMLCANHQ [ i ] , IAJCGUT )
LITERAL 1 return 1 ;
<operator>.indirectIndexAccess TMLCANHQ [ i ]
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->1 2->12 3->12 4->6 5->1 6->1 6->1 6->1 6->5 6->7 6->10 6->12 6->14 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->6 10->7 10->11 11->1 12->1 12->1 12->10 12->10 13->11
>>>Token int SIXAEPVIKRI ( char * * TMLCANHQ , char * IAJCGUT , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) if ( strcmp ( TMLCANHQ [ i ] , IAJCGUT ) == 0 ) return 1 ; return 0 ; }
>>>Func
METHOD TKKEMT
METHOD_RETURN int
PARAM int a
PARAM int b
<operator>.greaterThan a > b
RETURN return a ; return a ;
IDENTIFIER a return a ;
RETURN return b ; return b ;
IDENTIFIER b return b ;
>>>PDG&9 0->2 0->3 0->4 0->6 0->8 2->4 3->4 4->1 4->1 4->1 4->5 4->6 4->7 4->8 5->1 6->5 7->1 8->7
>>>Token int TKKEMT ( int a , int b ) { if ( a > b ) return a ; else return b ; }
>>>Func
METHOD IUK
METHOD_RETURN void*
PARAM GXASXLSLASUNQCL * da
PARAM const unsigned AMTKQ
RETURN return da -> FPOSI [ AMTKQ ] ; return da -> FPOSI [ AMTKQ ] ;
<operator>.logicalNot ! MBRMSJFW ( da -> TAHC , AMTKQ )
RETURN return AHUBUOMXJJLCMWCBSMU ; return AHUBUOMXJJLCMWCBSMU ;
MBRMSJFW MBRMSJFW ( da -> TAHC , AMTKQ )
IDENTIFIER AHUBUOMXJJLCMWCBSMU return AHUBUOMXJJLCMWCBSMU ;
<operator>.indirectIndexAccess da -> FPOSI [ AMTKQ ]
<operator>.indirectFieldAccess da -> FPOSI
FIELD_IDENTIFIER FPOSI FPOSI
>>>PDG&12 0->2 0->3 0->4 0->6 0->7 0->8 2->1 3->7 4->1 5->1 5->1 5->4 5->6 5->9 5->10 5->11 6->1 7->1 7->1 7->5 7->5 8->6
>>>Token void * IUK ( GXASXLSLASUNQCL * da , const unsigned AMTKQ ) { if ( ! MBRMSJFW ( da -> TAHC , AMTKQ ) ) return AHUBUOMXJJLCMWCBSMU ; return da -> FPOSI [ AMTKQ ] ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment * ip = KERJK ( "B-small-attempt1.in" , "r" )
<operator>.assignment * op = KERJK ( "B-small-output.txt" , "w" )
<operator>.assignment b [ 30 ] = { - 1 }
NUEJHY NUEJHY ( ip , "%d" , & t )
QBAELO QBAELO ( ip )
QBAELO QBAELO ( op )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
KERJK KERJK ( "B-small-attempt1.in" , "r" )
KERJK KERJK ( "B-small-output.txt" , "w" )
<operator>.arrayInitializer { - 1 }
<operator>.assignment i = 1
NUEJHY NUEJHY ( ip , "%d" , & c )
NUEJHY NUEJHY ( ip , "%d" , & d )
NUEJHY NUEJHY ( ip , "%d" , & n )
NUEJHY NUEJHY ( ip , "%s" , s )
fprintf fprintf ( op , "Case #%d: [" , i )
fprintf fprintf ( op , "]\n" )
<operator>.minus - 1
<operator>.lessThan j < 30
<operator>.postIncrement j ++
<operator>.lessThan j < 30
<operator>.postIncrement j ++
<operator>.assignment b [ j ] = - 1
<operator>.lessThan j < c
<operator>.postIncrement j ++
<operator>.lessThan j < d
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < k
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.lessThan k < 30
<operator>.postIncrement k ++
<operator>.assignment a [ j ] [ k ] = - 1
<operator>.assignment j = 0
<operator>.assignment j = 0
NUEJHY NUEJHY ( ip , "%s" , s )
<operator>.assignment a [ s [ 0 ] - 'A' ] [ s [ 1 ] - 'A' ] = a [ s [ 1 ] - 'A' ] [ s [ 0 ] - 'A' ] = s [ 2 ]
<operator>.assignment j = 0
NUEJHY NUEJHY ( ip , "%s" , s )
<operator>.assignment b [ s [ 0 ] - 'A' ] = s [ 1 ]
<operator>.assignment b [ s [ 1 ] - 'A' ] = s [ 0 ]
<operator>.expressionList j = 0   k = 0
<operator>.assignment p [ k ++ ] = s [ j ]
<operator>.assignment j = 0
fprintf fprintf ( op , "%c" , p [ j ] )
<operator>.assignment k = 0
<operator>.minus - 1
<operator>.logicalAnd k >= 2 && a [ p [ k - 1 ] - 'A' ] [ p [ k - 2 ] - 'A' ] != - 1
<operator>.logicalAnd k >= 2 && b [ p [ k - 1 ] - 'A' ] != - 1
<operator>.lessThan j + 1 < k
<operator>.minus - 1
<operator>.assignment a [ s [ 1 ] - 'A' ] [ s [ 0 ] - 'A' ] = s [ 2 ]
<operator>.assignment j = 0
<operator>.assignment k = 0
<operator>.assignment p [ k - 2 ] = ( char ) a [ p [ k - 1 ] - 'A' ] [ p [ k - 2 ] - 'A' ]
<operator>.postDecrement k --
<operator>.assignment x = ( char ) b [ p [ k - 1 ] - 'A' ]
fprintf fprintf ( op , ", " )
<operator>.subtraction s [ 1 ] - 'A'
<operator>.subtraction s [ 0 ] - 'A'
<operator>.subtraction s [ 1 ] - 'A'
<operator>.postIncrement k ++
<operator>.greaterEqualsThan k >= 2
<operator>.notEquals a [ p [ k - 1 ] - 'A' ] [ p [ k - 2 ] - 'A' ] != - 1
<operator>.greaterEqualsThan k >= 2
<operator>.notEquals b [ p [ k - 1 ] - 'A' ] != - 1
<operator>.lessThan l < k
<operator>.postIncrement l ++
<operator>.addition j + 1
<operator>.subtraction s [ 0 ] - 'A'
<operator>.subtraction s [ 0 ] - 'A'
<operator>.minus - 1
<operator>.cast ( char ) a [ p [ k - 1 ] - 'A' ] [ p [ k - 2 ] - 'A' ]
<operator>.minus - 1
<operator>.cast ( char ) b [ p [ k - 1 ] - 'A' ]
<operator>.assignment l = 0
<operator>.equals x == p [ l ]
<operator>.subtraction s [ 1 ] - 'A'
<operator>.subtraction p [ k - 2 ] - 'A'
<operator>.subtraction k - 2
<operator>.subtraction p [ k - 1 ] - 'A'
<operator>.assignment k = 0
<operator>.subtraction p [ k - 1 ] - 'A'
<operator>.subtraction p [ k - 2 ] - 'A'
<operator>.subtraction p [ k - 1 ] - 'A'
<operator>.subtraction k - 2
<operator>.subtraction p [ k - 1 ] - 'A'
<operator>.subtraction k - 1
<operator>.subtraction k - 1
<operator>.subtraction k - 2
<operator>.subtraction k - 1
<operator>.subtraction k - 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess b [ j ]
<operator>.indirectIndexAccess a [ j ] [ k ]
<operator>.indirectIndexAccess a [ s [ 0 ] - 'A' ] [ s [ 1 ] - 'A' ]
<operator>.indirectIndexAccess b [ s [ 0 ] - 'A' ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess b [ s [ 1 ] - 'A' ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess p [ k ++ ]
<operator>.indirectIndexAccess s [ j ]
<operator>.indirectIndexAccess p [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ s [ 0 ] - 'A' ]
<operator>.indirectIndexAccess a [ s [ 1 ] - 'A' ] [ s [ 0 ] - 'A' ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess a [ s [ 1 ] - 'A' ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess a [ p [ k - 1 ] - 'A' ] [ p [ k - 2 ] - 'A' ]
<operator>.indirectIndexAccess p [ k - 2 ]
<operator>.indirectIndexAccess b [ p [ k - 1 ] - 'A' ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess a [ p [ k - 1 ] - 'A' ]
UNKNOWN char char
<operator>.indirectIndexAccess a [ p [ k - 1 ] - 'A' ] [ p [ k - 2 ] - 'A' ]
UNKNOWN char char
<operator>.indirectIndexAccess b [ p [ k - 1 ] - 'A' ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess p [ k - 2 ]
<operator>.indirectIndexAccess a [ p [ k - 1 ] - 'A' ]
<operator>.indirectIndexAccess p [ k - 1 ]
<operator>.indirectIndexAccess p [ l ]
<operator>.indirectIndexAccess p [ k - 1 ]
<operator>.indirectIndexAccess p [ k - 2 ]
<operator>.indirectIndexAccess p [ k - 1 ]
<operator>.indirectIndexAccess p [ k - 1 ]
>>>PDG&139 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->42 0->44 0->45 0->48 0->50 0->51 0->52 0->53 0->56 0->57 0->59 0->60 0->62 0->64 0->65 0->66 0->67 0->68 0->69 0->71 0->73 0->74 0->75 0->76 0->77 0->78 0->80 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 2->1 2->1 2->5 3->1 3->1 3->7 3->20 4->1 4->1 4->1 4->63 4->72 4->81 5->1 5->1 5->6 5->9 5->16 6->1 6->1 7->1 7->1 8->1 9->1 9->1 9->1 9->9 9->10 9->16 9->17 9->18 9->19 9->20 9->20 9->21 9->23 9->25 9->28 9->30 9->32 9->34 9->36 9->40 9->41 9->44 9->48 9->50 9->59 9->60 9->99 9->100 9->101 10->1 10->9 11->8 12->2 12->2 13->3 13->3 14->1 14->4 15->1 15->9 16->1 16->1 16->17 16->28 16->42 17->1 17->1 17->18 17->30 17->45 18->1 18->1 18->19 18->32 19->1 19->1 19->6 19->16 19->42 19->45 19->49 20->1 20->10 20->21 20->51 21->1 21->7 21->20 22->14 23->23 23->24 23->24 23->37 23->52 24->1 24->23 25->1 25->25 25->26 25->26 25->27 25->53 25->102 26->1 26->25 27->1 27->1 27->1 28->1 28->1 28->16 28->28 28->29 28->29 28->42 28->43 28->58 28->65 28->76 28->77 28->84 28->104 28->113 28->114 28->115 28->116 28->117 28->123 28->124 28->130 29->1 29->28 30->1 30->1 30->17 30->30 30->31 30->31 30->45 30->46 30->47 30->66 30->67 30->105 30->106 30->107 30->108 30->118 30->119 31->1 31->30 32->1 32->1 32->18 32->32 32->33 32->33 32->49 32->54 32->55 32->68 32->69 32->71 32->109 32->110 33->1 33->32 34->1 34->1 34->1 34->34 34->35 34->35 34->51 34->56 34->56 34->56 34->75 34->75 34->111 35->1 35->34 36->23 37->1 37->37 37->38 37->38 37->39 37->57 37->103 37->112 38->1 38->37 39->1 39->1 39->1 40->25 41->28 42->17 42->19 42->43 42->45 42->58 42->65 42->76 42->77 42->84 43->1 43->1 43->1 44->30 45->18 45->19 45->42 45->46 45->47 45->66 45->67 45->76 46->1 46->1 47->1 47->1 47->1 48->1 48->1 49->1 49->1 49->1 50->1 50->34 51->1 51->1 51->21 51->64 52->37 53->27 54->1 54->1 54->54 54->61 54->62 54->69 54->79 54->86 54->90 54->93 54->96 54->98 54->121 54->126 54->127 54->132 54->136 54->138 55->1 55->1 55->1 55->63 55->73 55->81 55->82 55->91 55->97 55->128 55->129 55->137 56->1 56->1 56->34 56->64 57->39 58->1 58->1 58->43 59->32 59->48 60->34 60->48 60->68 61->1 61->1 61->1 61->85 61->90 62->1 62->69 63->1 63->1 63->1 63->83 64->1 64->21 64->51 65->84 66->19 66->42 66->45 66->47 66->76 67->1 67->19 67->42 67->45 67->46 67->65 68->69 69->54 69->54 69->70 69->71 69->78 69->85 69->86 69->89 69->92 69->95 69->95 69->120 69->125 69->131 69->135 70->1 70->1 70->54 70->54 70->61 70->79 71->34 71->55 71->55 71->68 71->72 71->80 71->87 71->94 71->94 71->97 71->122 71->133 72->1 72->1 72->55 72->55 72->63 72->81 73->1 73->1 73->34 73->68 73->73 73->74 73->74 73->83 73->134 74->1 74->73 76->77 77->1 77->19 77->42 77->45 77->66 77->76 78->70 79->1 80->72 81->1 82->1 82->73 83->1 83->1 83->1 83->88 84->1 84->19 84->42 84->45 84->46 84->65 84->67 85->1 85->90 86->98 87->1 87->89 87->91 87->93 88->1 88->73 89->1 89->87 89->91 89->93 91->1 91->87 91->89 91->93 92->71 92->86 93->1 93->87 93->89 93->91 94->34 94->68 94->97 95->92 96->62 97->73 98->96
>>>Token int main ( ) { GYOE * ip = KERJK ( " " , " " ) , * op = KERJK ( " " , " " ) ; int t , i , j , k , l , c , d , n , a [ 30 ] [ 30 ] , b [ 30 ] = { - 1 } ; char s [ 110 ] , p [ 110 ] ; NUEJHY ( ip , " " , & t ) ; for ( i = 1 ; i <= t ; i ++ ) { NUEJHY ( ip , " " , & c ) ; for ( j = 0 ; j < 30 ; j ++ ) for ( k = 0 ; k < 30 ; k ++ ) a [ j ] [ k ] = - 1 ; for ( j = 0 ; j < 30 ; j ++ ) b [ j ] = - 1 ; for ( j = 0 ; j < c ; j ++ ) { NUEJHY ( ip , " " , s ) ; a [ s [ 0 ] - ' ' ] [ s [ 1 ] - ' ' ] = a [ s [ 1 ] - ' ' ] [ s [ 0 ] - ' ' ] = s [ 2 ] ; } NUEJHY ( ip , " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) { NUEJHY ( ip , " " , s ) ; b [ s [ 0 ] - ' ' ] = s [ 1 ] ; b [ s [ 1 ] - ' ' ] = s [ 0 ] ; } NUEJHY ( ip , " " , & n ) ; NUEJHY ( ip , " " , s ) ; for ( j = 0 , k = 0 ; j < n ; j ++ ) { p [ k ++ ] = s [ j ] ; while ( k >= 2 && a [ p [ k - 1 ] - ' ' ] [ p [ k - 2 ] - ' ' ] != - 1 ) { p [ k - 2 ] = ( char ) a [ p [ k - 1 ] - ' ' ] [ p [ k - 2 ] - ' ' ] ; k -- ; } if ( k >= 2 && b [ p [ k - 1 ] - ' ' ] != - 1 ) { char x = ( char ) b [ p [ k - 1 ] - ' ' ] ; for ( l = 0 ; l < k ; l ++ ) if ( x == p [ l ] ) k = 0 ; } } fprintf ( op , " " , i ) ; for ( j = 0 ; j < k ; j ++ ) { fprintf ( op , " " , p [ j ] ) ; if ( j + 1 < k ) fprintf ( op , " " ) ; } fprintf ( op , " \n " ) ; } QBAELO ( ip ) ; QBAELO ( op ) ; return 0 ; }
>>>Func
METHOD NFBSLBKJC
METHOD_RETURN void*
PARAM KOQYANA NDSY
<operator>.assignment p = calloc ( NDSY , 1 )
RETURN return p ; return p ;
<operator>.equals p == NULL
IDENTIFIER p return p ;
calloc calloc ( NDSY , 1 )
HJKFU HJKFU ( )
>>>PDG&9 0->2 0->3 0->5 0->6 0->7 0->8 2->3 2->7 3->1 3->1 3->5 4->1 5->1 5->1 5->1 5->6 5->8 6->4 7->1 8->1
>>>Token void * NFBSLBKJC ( KOQYANA NDSY ) { void * p ; p = calloc ( NDSY , 1 ) ; if ( p == NULL ) HJKFU ( ) ; return p ; }
>>>Func
METHOD XRTIDH
METHOD_RETURN void
printf printf ( "\nenter the position to update? " )
XKTQH XKTQH ( "%d" , & i )
printf printf ( "\nenter the item to insert? " )
XKTQH XKTQH ( "%d" , & n )
<operator>.lessThan YGG - i + 1 < 0
printf printf ( "\nunderflow condition" )
<operator>.addition YGG - i + 1
<operator>.assignment a [ YGG - i + 1 ] = n
<operator>.subtraction YGG - i
<operator>.addition YGG - i + 1
<operator>.subtraction YGG - i
<operator>.indirectIndexAccess a [ YGG - i + 1 ]
>>>PDG&14 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 3->1 3->1 3->10 3->12 4->1 5->1 5->1 5->9 6->1 6->1 6->7 6->9 6->11 6->12 6->13 7->1 8->1 10->1 10->1 10->6 10->6 10->8 10->8 10->12 10->12 12->11 12->11
>>>Token void XRTIDH ( ) { int i , n ; printf ( " \n " ) ; XKTQH ( " " , & i ) ; printf ( " \n " ) ; XKTQH ( " " , & n ) ; if ( YGG - i + 1 < 0 ) { printf ( " \n " ) ; } else { a [ YGG - i + 1 ] = n ; } }
>>>Func
METHOD main
METHOD_RETURN int
IQMTJUG IQMTJUG ( "./B-small.in" , "r" , stdin )
MHTXB MHTXB ( "%d" , & T )
BSHYAXH BSHYAXH ( "%d\n" , T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan k <= T
<operator>.postIncrement k ++
LITERAL 0 return 0 ;
<operator>.assignment k = 1
printf printf ( "Case #%d: " , k )
memset memset ( C   0   sizeof ( C ) )
memset memset ( D   0   sizeof ( C ) )
memset memset ( WGGXOI   0   sizeof ( WGGXOI ) )
<operator>.assignment NTI = - 1
MHTXB MHTXB ( "%d" , & nC )
BSHYAXH BSHYAXH ( "%d\n" , nC )
MHTXB MHTXB ( "%d" , & nD )
BSHYAXH BSHYAXH ( "%d\n" , nD )
MHTXB MHTXB ( "%d" , & RHSE )
BSHYAXH BSHYAXH ( "%d\n" , RHSE )
MHTXB MHTXB ( "%s" , WGGXOI )
BSHYAXH BSHYAXH ( "%s\n" , WGGXOI )
printf printf ( "[" )
printf printf ( "]\n" )
BSHYAXH BSHYAXH ( "-----------\n" )
<operator>.lessThan j < nC
<operator>.postIncrement j ++
<operator>.lessThan j < nD
<operator>.postIncrement j ++
<operator>.lessThan i < RHSE
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= NTI
<operator>.postIncrement i ++
<operator>.sizeOf sizeof ( C )
<operator>.minus - 1
<operator>.assignment j = 0
MHTXB MHTXB ( " %c" , & C [ j ] [ 0 ] )
MHTXB MHTXB ( "%c" , & C [ j ] [ 1 ] )
MHTXB MHTXB ( "%c" , & C [ j ] [ 2 ] )
BSHYAXH BSHYAXH ( "%s\n" , C [ j ] )
<operator>.assignment j = 0
MHTXB MHTXB ( " %c" , & D [ j ] [ 0 ] )
MHTXB MHTXB ( "%c" , & D [ j ] [ 1 ] )
BSHYAXH BSHYAXH ( "%s\n" , D [ j ] )
<operator>.assignment i = 0
<operator>.assignment VHNHW = 0
<operator>.assignment GWYIC = 0
<operator>.assignment i = 0
printf printf ( "%c" , SMKABUVB [ i ] )
<operator>.notEquals NTI != - 1
<operator>.lessThan i < NTI
<operator>.assignment VHNHW = NLBWDP ( WGGXOI [ i ] , & PDXXPR )
printf printf ( ", " )
<operator>.minus - 1
IDENTIFIER VHNHW if (VHNHW)
<operator>.assignment SMKABUVB [ ++ NTI ] = WGGXOI [ i ]
NLBWDP NLBWDP ( WGGXOI [ i ] , & PDXXPR )
<operator>.assignment SMKABUVB [ NTI ] = PDXXPR
<operator>.assignment GWYIC = XATIYT ( WGGXOI [ i ] )
IDENTIFIER GWYIC if (GWYIC)
<operator>.preIncrement ++ NTI
XATIYT XATIYT ( WGGXOI [ i ] )
<operator>.assignment NTI = - 1
<operator>.assignment SMKABUVB [ ++ NTI ] = WGGXOI [ i ]
<operator>.minus - 1
<operator>.preIncrement ++ NTI
<operator>.sizeOf sizeof ( C )
<operator>.sizeOf sizeof ( WGGXOI )
<operator>.addressOf & nC
<operator>.addressOf & nD
<operator>.addressOf & RHSE
<operator>.addressOf & C [ j ] [ 0 ]
<operator>.addressOf & C [ j ] [ 1 ]
<operator>.addressOf & C [ j ] [ 2 ]
<operator>.indirectIndexAccess C [ j ]
<operator>.addressOf & D [ j ] [ 0 ]
<operator>.addressOf & D [ j ] [ 1 ]
<operator>.indirectIndexAccess D [ j ]
<operator>.indirectIndexAccess SMKABUVB [ i ]
<operator>.indirectIndexAccess C [ j ] [ 0 ]
<operator>.indirectIndexAccess C [ j ] [ 1 ]
<operator>.indirectIndexAccess C [ j ] [ 2 ]
<operator>.indirectIndexAccess D [ j ] [ 0 ]
<operator>.indirectIndexAccess D [ j ] [ 1 ]
<operator>.indirectIndexAccess C [ j ]
<operator>.indirectIndexAccess C [ j ]
<operator>.indirectIndexAccess C [ j ]
<operator>.indirectIndexAccess D [ j ]
<operator>.indirectIndexAccess D [ j ]
<operator>.indirectIndexAccess WGGXOI [ i ]
<operator>.addressOf & PDXXPR
<operator>.indirectIndexAccess SMKABUVB [ ++ NTI ]
<operator>.indirectIndexAccess WGGXOI [ i ]
<operator>.indirectIndexAccess SMKABUVB [ NTI ]
<operator>.indirectIndexAccess WGGXOI [ i ]
<operator>.indirectIndexAccess SMKABUVB [ ++ NTI ]
<operator>.indirectIndexAccess WGGXOI [ i ]
>>>PDG&98 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->53 0->54 0->55 0->57 0->58 0->60 0->61 0->65 0->66 2->1 2->1 3->1 3->1 3->4 3->6 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->20 6->21 6->22 6->23 6->24 6->25 6->26 6->28 6->30 6->32 6->34 6->35 6->36 6->41 6->45 6->48 6->67 6->68 6->69 6->70 6->71 7->1 7->6 8->5 9->1 9->6 10->1 10->7 11->1 12->1 12->1 12->44 13->1 13->21 14->1 14->1 14->32 14->50 15->1 15->1 15->16 15->26 16->1 16->26 17->1 17->1 17->18 17->28 18->1 18->28 19->1 19->1 19->20 19->30 20->1 20->30 21->1 21->22 22->1 22->1 22->13 22->21 22->56 22->57 22->62 22->64 23->1 24->1 25->1 26->1 26->1 26->15 26->16 26->26 26->27 26->27 26->37 26->38 26->39 26->40 26->72 26->73 26->74 26->75 26->80 26->81 26->82 26->85 26->86 26->87 27->1 27->26 28->1 28->1 28->1 28->17 28->18 28->28 28->29 28->29 28->42 28->43 28->44 28->76 28->77 28->78 28->83 28->84 28->88 28->89 29->1 29->28 30->1 30->1 30->19 30->20 30->30 30->31 30->31 30->46 30->47 30->50 30->54 31->1 31->30 32->1 32->1 32->1 32->32 32->33 32->49 32->51 32->51 32->51 32->79 33->1 33->32 34->1 35->14 36->26 37->1 37->1 37->40 38->1 38->1 38->40 39->1 39->1 39->40 40->1 40->1 40->11 41->1 41->28 42->1 42->1 42->44 43->1 43->1 43->44 44->1 44->1 44->12 45->30 46->1 46->1 47->1 47->1 48->1 48->32 49->1 49->1 50->1 50->1 50->32 50->52 50->56 50->57 50->58 50->59 50->61 50->61 50->62 50->63 50->64 50->65 50->66 50->66 50->90 50->91 50->92 50->93 50->94 50->95 50->96 50->97 51->1 51->32 51->33 51->53 52->1 52->1 52->1 53->1 54->50 56->1 56->1 56->1 57->1 57->1 57->13 57->21 57->22 57->52 57->52 57->56 57->58 57->62 58->1 58->1 58->1 59->1 59->1 59->1 61->32 61->50 62->1 62->13 62->21 62->22 62->56 62->57 62->59 62->64 63->1 63->1 63->32 63->50 64->1 64->1 64->1 65->63 66->32 66->50
>>>Token int main ( ) { int T , i , j , k , RHSE , VHNHW , GWYIC ; char PDXXPR ; IQMTJUG ( " " , " " , stdin ) ; MHTXB ( " " , & T ) ; BSHYAXH ( " \n " , T ) ; for ( k = 1 ; k <= T ; k ++ ) { printf ( " " , k ) ; memset ( C , 0 , sizeof ( C ) ) ; memset ( D , 0 , sizeof ( C ) ) ; memset ( WGGXOI , 0 , sizeof ( WGGXOI ) ) ; NTI = - 1 ; MHTXB ( " " , & nC ) ; BSHYAXH ( " \n " , nC ) ; for ( j = 0 ; j < nC ; j ++ ) { MHTXB ( " " , & C [ j ] [ 0 ] ) ; MHTXB ( " " , & C [ j ] [ 1 ] ) ; MHTXB ( " " , & C [ j ] [ 2 ] ) ; BSHYAXH ( " \n " , C [ j ] ) ; } MHTXB ( " " , & nD ) ; BSHYAXH ( " \n " , nD ) ; for ( j = 0 ; j < nD ; j ++ ) { MHTXB ( " " , & D [ j ] [ 0 ] ) ; MHTXB ( " " , & D [ j ] [ 1 ] ) ; BSHYAXH ( " \n " , D [ j ] ) ; } MHTXB ( " " , & RHSE ) ; BSHYAXH ( " \n " , RHSE ) ; MHTXB ( " " , WGGXOI ) ; BSHYAXH ( " \n " , WGGXOI ) ; for ( i = 0 ; i < RHSE ; i ++ ) { VHNHW = 0 ; GWYIC = 0 ; if ( NTI != - 1 ) { VHNHW = NLBWDP ( WGGXOI [ i ] , & PDXXPR ) ; if ( VHNHW ) { SMKABUVB [ NTI ] = PDXXPR ; continue ; } else { GWYIC = XATIYT ( WGGXOI [ i ] ) ; if ( GWYIC ) { NTI = - 1 ; continue ; } else { SMKABUVB [ ++ NTI ] = WGGXOI [ i ] ; continue ; } } } else { SMKABUVB [ ++ NTI ] = WGGXOI [ i ] ; continue ; } } printf ( " " ) ; for ( i = 0 ; i <= NTI ; i ++ ) { printf ( " " , SMKABUVB [ i ] ) ; if ( i < NTI ) { printf ( " " ) ; } } printf ( " \n " ) ; BSHYAXH ( " \n " ) ; } return 0 ; }
>>>Func
METHOD QCHAFTIAEQ
METHOD_RETURN void
PARAM MWHW * SAFX
<operator>.assignment i = 0
IPEOQW IPEOQW ( SAFX , "%d %d %d\n" , & TUC . P , & TUC . K , & TUC . L )
<operator>.lessThan printf <YVIYFFT
<operator>.greaterThan ';'> ( "%d %d %d\n" , TUC . P , TUC . K , TUC . L )
<operator>.lessThan i < TUC . L
<operator>.postIncrement i ++
printf printf ( "\n" )
IDENTIFIER FMRQ <empty>
<operator>.lessThan i < TUC . L
<operator>.postIncrement i ++
<operator>.bracketedPrimary ( "%d %d %d\n" , TUC . P , TUC . K , TUC . L )
<operator>.assignment i = 0
IPEOQW IPEOQW ( SAFX , "%d " , & TUC . F [ i ] )
<operator>.expressionList "%d %d %d\n"   TUC . P   TUC . K   TUC . L
<operator>.fieldAccess TUC . L
FIELD_IDENTIFIER L L
<operator>.addressOf & TUC . F [ i ]
<operator>.indirectIndexAccess TUC . F [ i ]
<operator>.fieldAccess TUC . F
FIELD_IDENTIFIER F F
>>>PDG&23 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 2->4 4->1 4->1 4->1 4->1 4->1 4->7 4->11 4->15 4->16 4->16 4->16 5->1 5->1 5->1 6->1 6->1 7->1 7->1 7->8 8->1 8->1 9->1 11->7 11->7 11->11 11->12 11->12 11->15 11->17 11->18 11->19 11->20 11->21 11->22 12->11 13->1 13->6 14->1 14->11 15->1 15->1 15->1 16->1 16->1 16->11 16->13 16->13 16->13 16->13
>>>Token void QCHAFTIAEQ ( MWHW * SAFX ) { int i = 0 ; IPEOQW ( SAFX , " \n " , & TUC . P , & TUC . K , & TUC . L ) ; EDJ RTLBWSUFS  printf < YVIYFFT ' ' > ( " \n " , TUC . P , TUC . K , TUC . L ) ; FMRQ TUC . F = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * TUC . L ) ; for ( i = 0 ; i < TUC . L ; i ++ ) { IPEOQW ( SAFX , " " , & TUC . F [ i ] ) ; } EDJ RTLBWSUFS  for ( i < YVIYFFT ' ' > = 0 ; i < TUC . L ; i ++ ) { printf ( " " , TUC . F [ i ] ) ; } printf ( " \n " ) ; FMRQ  }
>>>Func
METHOD NBKEMOMMFX
METHOD_RETURN void
PARAM void
XSEJA XSEJA ( "%I64d %d %d " , & N , & D , & G )
<operator>.assignment a = 100 / APE ( 100 , D )
<operator>.logicalOr ( G == 0 && D != 0 ) || ( G == 100 && D != 100 ) || ( ( long long ) a > N )
<operator>.division 100 / APE ( 100 , D )
printf printf ( "Broken\n" )
APE APE ( 100 , D )
<operator>.logicalOr ( G == 0 && D != 0 ) || ( G == 100 && D != 100 )
<operator>.greaterThan ( long long ) a > N
printf printf ( "Possible\n" )
<operator>.logicalAnd G == 0 && D != 0
<operator>.logicalAnd G == 100 && D != 100
<operator>.cast ( long long ) a
<operator>.equals G == 0
<operator>.notEquals D != 0
<operator>.equals G == 100
<operator>.notEquals D != 100
UNKNOWN long long long long
>>>PDG&20 0->2 0->3 0->6 0->7 0->8 0->10 0->11 0->14 0->15 0->16 0->17 0->18 2->1 3->1 3->1 3->1 3->1 3->8 3->10 3->15 3->16 3->17 3->18 4->1 4->1 4->1 4->10 4->14 5->1 5->1 5->1 5->7 5->11 6->1 6->4 6->4 7->1 8->1 8->6 8->6 8->16 8->18 9->1 9->1 9->5 9->5 9->10 9->14 9->19 10->1 10->1 10->5 10->5 12->1 12->1 12->9 12->9 12->13 12->17 13->1 13->1 13->9 13->9 14->1 15->1 15->12 15->12 15->16 15->17 16->1 16->12 16->12 16->18 17->1 17->13 17->13 17->18 18->1 18->13 18->13
>>>Token void NBKEMOMMFX ( void ) { long long N ; int D , G ; XSEJA ( " " , & N , & D , & G ) ; int a = 100 / APE ( 100 , D ) ; if ( ( G == 0 && D != 0 ) || ( G == 100 && D != 100 ) || ( ( long long ) a > N ) ) { printf ( " \n " ) ; } else { printf ( " \n " ) ; } }
>>>Func
METHOD AXQXQIEEC
METHOD_RETURN int
PARAM char UHNCWM [ ]
PARAM int n
PARAM char TEPLLPCBMXJA [ AFTMFTFFLPKRTF ] [ AFTMFTFFLPKRTF ]
PARAM bool BHKAVEEMPSC [ AFTMFTFFLPKRTF ] [ AFTMFTFFLPKRTF ]
<operator>.assignment SVQSFRVKN = '\0'
<operator>.assignment i = 0
RETURN return 0 ; return 0 ;
<operator>.equals n == 0
<operator>.notEquals ( SVQSFRVKN = TEPLLPCBMXJA [ ( unsigned ) UHNCWM [ n ] ] [ ( unsigned ) UHNCWM [ n - 1 ] ] ) != '\0'
LITERAL 0 return 0 ;
RETURN return 0 ; return 0 ;
<operator>.assignment UHNCWM [ n - 1 ] = SVQSFRVKN
<operator>.assignment UHNCWM [ n ] = '\0'
RETURN return 1 + AXQXQIEEC ( UHNCWM , n - 1 , TEPLLPCBMXJA , BHKAVEEMPSC ) ; return 1 + AXQXQIEEC ( UHNCWM , n - 1 , TEPLLPCBMXJA , BHKAVEEMPSC ) ;
LITERAL 0 return 0 ;
<operator>.assignment SVQSFRVKN = TEPLLPCBMXJA [ ( unsigned ) UHNCWM [ n ] ] [ ( unsigned ) UHNCWM [ n - 1 ] ]
<operator>.addition 1 + AXQXQIEEC ( UHNCWM , n - 1 , TEPLLPCBMXJA , BHKAVEEMPSC )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.cast ( unsigned ) UHNCWM [ n - 1 ]
<operator>.subtraction n - 1
AXQXQIEEC AXQXQIEEC ( UHNCWM , n - 1 , TEPLLPCBMXJA , BHKAVEEMPSC )
<operator>.assignment i = 0
<operator>.cast ( unsigned ) UHNCWM [ n ]
<operator>.subtraction n - 1
<operator>.subtraction n - 1
RETURN return n + 1 ; return n + 1 ;
<operator>.cast ( unsigned ) UHNCWM [ i ]
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
<operator>.addition n + 1
<operator>.cast ( unsigned ) UHNCWM [ n ]
<operator>.assignment i = 0
<operator>.assignment UHNCWM [ i ] = '\0'
<operator>.indirectIndexAccess TEPLLPCBMXJA [ ( unsigned ) UHNCWM [ n ] ] [ ( unsigned ) UHNCWM [ n - 1 ] ]
<operator>.indirectIndexAccess UHNCWM [ n - 1 ]
<operator>.indirectIndexAccess UHNCWM [ n ]
<operator>.indirectIndexAccess TEPLLPCBMXJA [ ( unsigned ) UHNCWM [ n ] ]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess UHNCWM [ n - 1 ]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess UHNCWM [ n ]
<operator>.indirectIndexAccess BHKAVEEMPSC [ ( unsigned ) UHNCWM [ n ] ] [ ( unsigned ) UHNCWM [ i ] ]
<operator>.indirectIndexAccess BHKAVEEMPSC [ ( unsigned ) UHNCWM [ n ] ]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess UHNCWM [ i ]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess UHNCWM [ n ]
<operator>.indirectIndexAccess UHNCWM [ i ]
>>>PDG&51 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->18 0->19 0->20 0->22 0->23 0->24 0->26 0->27 0->30 0->31 0->32 0->34 0->35 2->1 2->21 2->23 2->25 2->29 2->33 3->9 4->1 4->23 5->1 5->23 8->1 9->1 9->1 9->6 9->7 9->10 9->12 9->17 9->21 9->25 9->27 9->27 9->36 9->39 9->40 9->41 9->42 9->43 10->13 10->14 10->15 10->18 10->19 10->22 10->23 10->24 10->26 10->37 10->38 11->8 12->1 13->23 14->23 15->1 16->12 17->10 17->13 18->15 19->8 19->20 19->29 19->30 19->33 19->44 19->45 19->46 19->47 19->48 19->49 20->19 22->26 23->18 23->18 23->18 23->18 24->19 26->23 26->23 27->19 27->22 28->1 30->30 30->31 30->31 30->32 30->35 30->50 31->30 32->28 34->30 44->19 44->20 44->28 44->30 44->32 44->34
>>>Token int AXQXQIEEC ( char UHNCWM [ ] , int n , char TEPLLPCBMXJA [ AFTMFTFFLPKRTF ] [ AFTMFTFFLPKRTF ] , bool BHKAVEEMPSC [ AFTMFTFFLPKRTF ] [ AFTMFTFFLPKRTF ] ) { if ( n == 0 ) { return 0 ; } char SVQSFRVKN = ' \0 ' ; int i = 0 ; if ( ( SVQSFRVKN = TEPLLPCBMXJA [ ( unsigned ) UHNCWM [ n ] ] [ ( unsigned ) UHNCWM [ n - 1 ] ] ) != ' \0 ' ) { UHNCWM [ n - 1 ] = SVQSFRVKN ; UHNCWM [ n ] = ' \0 ' ; return 1 + AXQXQIEEC ( UHNCWM , n - 1 , TEPLLPCBMXJA , BHKAVEEMPSC ) ; } else { for ( i = 0 ; i < n ; i ++ ) { if ( BHKAVEEMPSC [ ( unsigned ) UHNCWM [ n ] ] [ ( unsigned ) UHNCWM [ i ] ] ) { for ( i = 0 ; i <= n ; i ++ ) { UHNCWM [ i ] = ' \0 ' ; } return n + 1 ; } } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
MACAY MACAY ( "%d" , & tc )
RETURN return EXIT_SUCCESS ; return EXIT_SUCCESS ;
<operator>.lessThan k < tc
<operator>.postIncrement k ++
IDENTIFIER EXIT_SUCCESS return EXIT_SUCCESS ;
<operator>.assignment k = 0
MACAY MACAY ( "%d" , & n )
printf printf ( "Case #%d:\n" , k + 1 )
<operator>.lessThan i < n
<operator>.postIncrement i ++
MACAY MACAY ( "%s" , bd [ i ] )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
printf printf ( "%.9f\n" , 0.25 * op [ i ] + 0.5 * CDO [ i ] + 0.25 * QBEO [ i ] )
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment tt [ i ] = wn = 0
<operator>.assignment op [ i ] = ( double ) wn / tt [ i ]
<operator>.assignment i = 0
<operator>.assignment sc = 0.0
<operator>.assignment CDO [ i ] = sc / tt [ i ]
<operator>.assignment i = 0
<operator>.assignment sc = 0.0
<operator>.assignment QBEO [ i ] = sc / tt [ i ]
<operator>.addition k + 1
<operator>.assignment i = 0
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.addition 0.25 * op [ i ] + 0.5 * CDO [ i ] + 0.25 * QBEO [ i ]
<operator>.assignment wn = 0
<operator>.assignment j = 0
<operator>.division ( double ) wn / tt [ i ]
<operator>.assignment j = 0
<operator>.division sc / tt [ i ]
<operator>.assignment j = 0
<operator>.division sc / tt [ i ]
<operator>.addition 0.25 * op [ i ] + 0.5 * CDO [ i ]
<operator>.multiplication 0.25 * QBEO [ i ]
<operator>.equals bd [ i ] [ j ] == '1'
<operator>.notEquals bd [ i ] [ j ] != '.'
<operator>.cast ( double ) wn
<operator>.notEquals bd [ i ] [ j ] != '.'
<operator>.notEquals bd [ i ] [ j ] != '.'
<operator>.multiplication 0.25 * op [ i ]
<operator>.multiplication 0.5 * CDO [ i ]
<operator>.postIncrement wn ++
<operator>.postIncrement tt [ i ] ++
<operator>.assignmentPlus sc += ( op [ j ] * tt [ j ] - ( bd [ i ] [ j ] == '0' ? 1 : 0 ) ) / ( tt [ j ] - 1 )
<operator>.assignmentPlus sc += CDO [ j ]
<operator>.division ( op [ j ] * tt [ j ] - ( bd [ i ] [ j ] == '0' ? 1 : 0 ) ) / ( tt [ j ] - 1 )
<operator>.subtraction op [ j ] * tt [ j ] - ( bd [ i ] [ j ] == '0' ? 1 : 0 )
<operator>.subtraction tt [ j ] - 1
<operator>.multiplication op [ j ] * tt [ j ]
<operator>.conditional bd [ i ] [ j ] == '0' ? 1 : 0
<operator>.equals bd [ i ] [ j ] == '0'
<operator>.addressOf & n
<operator>.indirectIndexAccess bd [ i ]
<operator>.indirectIndexAccess tt [ i ]
<operator>.indirectIndexAccess op [ i ]
<operator>.indirectIndexAccess CDO [ i ]
<operator>.indirectIndexAccess QBEO [ i ]
<operator>.indirectIndexAccess tt [ i ]
<operator>.indirectIndexAccess tt [ i ]
<operator>.indirectIndexAccess tt [ i ]
<operator>.indirectIndexAccess QBEO [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess op [ i ]
<operator>.indirectIndexAccess CDO [ i ]
<operator>.indirectIndexAccess bd [ i ] [ j ]
<operator>.indirectIndexAccess bd [ i ] [ j ]
<operator>.indirectIndexAccess bd [ i ] [ j ]
<operator>.indirectIndexAccess bd [ i ] [ j ]
<operator>.indirectIndexAccess bd [ i ]
<operator>.indirectIndexAccess bd [ i ]
<operator>.indirectIndexAccess tt [ i ]
<operator>.indirectIndexAccess bd [ i ]
<operator>.indirectIndexAccess bd [ i ]
<operator>.indirectIndexAccess CDO [ j ]
<operator>.indirectIndexAccess tt [ j ]
<operator>.indirectIndexAccess op [ j ]
<operator>.indirectIndexAccess tt [ j ]
<operator>.indirectIndexAccess bd [ i ] [ j ]
<operator>.indirectIndexAccess bd [ i ]
>>>PDG&97 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->29 0->31 0->32 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->61 0->62 0->64 0->65 0->67 0->68 2->1 3->1 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->11 6->11 6->12 6->15 6->17 6->19 6->21 6->24 6->25 6->28 6->31 6->34 6->34 6->35 6->69 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->12 10->15 10->17 10->19 10->21 10->36 10->38 10->40 11->1 11->1 12->12 12->13 12->13 12->14 12->15 12->70 13->1 13->12 14->1 14->1 15->15 15->16 15->16 15->17 15->26 15->27 15->36 15->36 15->43 15->44 15->45 15->54 15->71 15->72 15->75 15->79 16->1 16->15 17->17 17->18 17->18 17->19 17->29 17->30 17->38 17->38 17->46 17->47 17->73 17->76 18->1 18->17 19->19 19->20 19->20 19->21 19->32 19->33 19->40 19->40 19->48 19->49 19->74 19->77 20->1 20->19 21->1 21->1 21->1 21->10 21->12 21->21 21->22 21->22 21->23 21->42 21->50 21->51 21->57 21->58 21->78 21->80 21->81 22->1 22->21 23->1 23->1 24->12 25->15 26->1 26->1 26->45 26->60 27->1 27->1 27->1 27->57 28->17 29->1 29->47 29->61 30->1 30->1 30->1 30->58 31->19 32->1 32->49 32->62 33->1 33->1 33->1 33->51 35->1 35->21 36->1 36->1 36->15 36->36 36->37 36->37 36->52 36->53 36->82 36->83 36->86 36->87 37->1 37->36 38->1 38->1 38->17 38->38 38->39 38->39 38->55 38->84 38->89 39->1 39->38 40->1 40->1 40->19 40->40 40->41 40->41 40->56 40->85 40->90 41->1 41->40 42->1 42->1 43->26 43->45 43->54 43->59 44->1 44->36 45->1 45->1 45->27 45->27 45->47 45->49 46->1 46->38 47->1 47->1 47->30 47->30 47->49 48->1 48->40 49->1 49->1 49->33 49->33 49->47 50->1 50->1 51->1 51->23 51->23 51->42 51->42 52->1 52->53 52->59 53->1 53->1 53->14 53->52 53->55 53->56 53->60 53->88 54->1 55->1 55->1 55->14 55->52 55->56 55->61 55->63 55->64 55->65 55->66 55->67 55->68 55->68 55->92 55->93 55->94 55->95 55->96 56->1 56->1 56->14 56->52 56->55 56->62 56->91 57->1 57->23 57->23 57->42 57->42 57->50 57->50 58->1 58->23 58->23 58->42 58->42 58->50 58->50 59->1 59->45 59->54 60->1 60->45 61->1 61->1 61->47 62->1 62->1 62->49 63->1 63->1 63->61 63->61 64->1 64->1 64->63 64->63 65->1 65->63 65->63 65->66 66->1 66->64 66->64 66->65 67->1 68->1 68->14 68->52 68->55 68->56
>>>Token int main ( int argc , char * argv [ ] ) { int i , tc , j , k ; MACAY ( " " , & tc ) ; for ( k = 0 ; k < tc ; k ++ ) { MACAY ( " " , & n ) ; for ( i = 0 ; i < n ; i ++ ) MACAY ( " " , bd [ i ] ) ; int wn ; for ( i = 0 ; i < n ; i ++ ) { tt [ i ] = wn = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( bd [ i ] [ j ] == ' ' ) wn ++ ; if ( bd [ i ] [ j ] != ' ' ) tt [ i ] ++ ; } op [ i ] = ( double ) wn / tt [ i ] ; } double sc ; for ( i = 0 ; i < n ; i ++ ) { sc = 0.0 ; for ( j = 0 ; j < n ; j ++ ) { if ( bd [ i ] [ j ] != ' ' ) { sc += ( op [ j ] * tt [ j ] - ( bd [ i ] [ j ] == ' ' ? 1 : 0 ) ) / ( tt [ j ] - 1 ) ; } } CDO [ i ] = sc / tt [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { sc = 0.0 ; for ( j = 0 ; j < n ; j ++ ) { if ( bd [ i ] [ j ] != ' ' ) { sc += CDO [ j ] ; } } QBEO [ i ] = sc / tt [ i ] ; } printf ( " \n " , k + 1 ) ; for ( i = 0 ; i < n ; i ++ ) printf ( " \n " , 0.25 * op [ i ] + 0.5 * CDO [ i ] + 0.25 * QBEO [ i ] ) ; } return EXIT_SUCCESS ; }
>>>Func
METHOD NFBSLB
METHOD_RETURN void
PARAM void
<operator>.assignment n = KOQYANAND ( KJC , 4096 )
SYHJKFUHNLHPOWWPPJSC SYHJKFUHNLHPOWWPPJSC ( KJC , n , 1 )
RETURN return ; return ;
KOQYANAND KOQYANAND ( KJC , 4096 )
>>>PDG&7 0->2 0->4 0->5 0->6 2->1 3->1 3->1 3->4 4->1 4->1 4->1 5->1 6->3 6->3 6->4
>>>Token void NFBSLB ( void ) { int n ; void * KJC [ 4096 ] ; n = KOQYANAND ( KJC , 4096 ) ; SYHJKFUHNLHPOWWPPJSC ( KJC , n , 1 ) ; return ; }
>>>Func
METHOD GLJJXVAHQCLTONWSVI
METHOD_RETURN int
PARAM char c
PARAM int D
PARAM int io
RETURN return 0 ; return 0 ;
<operator>.lessThan i < D
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.logicalOr ( c == KNVRLFE [ i ] [ 0 ] ) || ( c == KNVRLFE [ i ] [ 1 ] )
<operator>.equals c == KNVRLFE [ i ] [ 0 ]
<operator>.equals c == KNVRLFE [ i ] [ 1 ]
<operator>.equals c == KNVRLFE [ i ] [ 0 ]
<operator>.lessThan j < io
<operator>.postIncrement j ++
<operator>.assignment YTS = KNVRLFE [ i ] [ 1 ]
<operator>.assignment j = 0
<operator>.assignment YTS = KNVRLFE [ i ] [ 0 ]
<operator>.equals ABAINJ [ j ] == YTS
RETURN return 1 ; return 1 ;
LITERAL 1 return 1 ;
<operator>.indirectIndexAccess KNVRLFE [ i ] [ 0 ]
<operator>.indirectIndexAccess KNVRLFE [ i ] [ 1 ]
<operator>.indirectIndexAccess KNVRLFE [ i ]
<operator>.indirectIndexAccess KNVRLFE [ i ]
<operator>.indirectIndexAccess KNVRLFE [ i ] [ 0 ]
<operator>.indirectIndexAccess KNVRLFE [ i ]
<operator>.indirectIndexAccess KNVRLFE [ i ] [ 1 ]
<operator>.indirectIndexAccess KNVRLFE [ i ]
<operator>.indirectIndexAccess KNVRLFE [ i ] [ 0 ]
<operator>.indirectIndexAccess ABAINJ [ j ]
<operator>.indirectIndexAccess KNVRLFE [ i ]
>>>PDG&33 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->17 0->19 0->20 0->21 2->11 3->6 4->14 5->1 6->1 6->1 6->1 6->5 6->7 6->10 6->11 6->22 6->24 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->6 10->7 10->13 10->14 10->17 10->26 10->27 11->10 11->10 11->12 11->12 11->13 11->13 11->23 11->25 12->1 12->10 12->10 12->11 12->13 12->16 13->1 13->1 13->1 13->11 13->11 13->16 13->18 13->18 13->28 13->29 13->30 13->32 14->1 14->1 14->1 14->6 14->7 14->15 14->19 14->31 15->1 15->14 16->1 16->1 16->19 17->1 17->14 18->1 18->1 18->19 19->1 19->1 19->1 19->14 19->15 19->20 20->1 21->20
>>>Token int GLJJXVAHQCLTONWSVI ( char c , int D , int io ) { int i , j ; char YTS ; for ( i = 0 ; i < D ; i ++ ) { if ( ( c == KNVRLFE [ i ] [ 0 ] ) || ( c == KNVRLFE [ i ] [ 1 ] ) ) { if ( c == KNVRLFE [ i ] [ 0 ] ) { YTS = KNVRLFE [ i ] [ 1 ] ; } else { YTS = KNVRLFE [ i ] [ 0 ] ; } for ( j = 0 ; j < io ; j ++ ) { if ( ABAINJ [ j ] == YTS ) { return 1 ; } } } } return 0 ; }
>>>Func
METHOD UBHHXWGQMNJQJGOYARLRPWI
METHOD_RETURN void
PARAM char * DWX
<operator>.assignment YRBVPVY = strlen ( DWX )
YGXVM YGXVM ( DWX   YRBVPVY   sizeof ( char ) , QKCCDNJ )
<operator>.assignment TOLMBGEAOHYPIQQ = 1
IDENTIFIER TOLMBGEAOHYPIQQ do { printf ( "%s\n" , DWX ) ; int i ; for ( i = YRBVPVY - 2 ; i >= 0 && DWX [ i ] >= DWX [ i + 1 ] ; -- i ) { } if ( i >= 0 ) { int j = i + 1   k ; for ( k = j ; k < YRBVPVY && DWX [ k ] ; k ++ ) { if ( DWX [ k ] > DWX [ i ] && DWX [ k ] < DWX [ j ] ) j = k ; } EIPG ( & DWX [ i ] , & DWX [ j ] ) ; YGXVM ( DWX + i + 1   YRBVPVY - i - 1   sizeof ( char ) , QKCCDNJ ) ; } else TOLMBGEAOHYPIQQ = 0 ; } while ( TOLMBGEAOHYPIQQ ) ;
strlen strlen ( DWX )
<operator>.sizeOf sizeof ( char )
printf printf ( "%s\n" , DWX )
<operator>.logicalAnd i >= 0 && DWX [ i ] >= DWX [ i + 1 ]
<operator>.preDecrement -- i
<operator>.greaterEqualsThan i >= 0
<operator>.assignment i = YRBVPVY - 2
<operator>.assignment j = i + 1
EIPG EIPG ( & DWX [ i ] , & DWX [ j ] )
YGXVM YGXVM ( DWX + i + 1   YRBVPVY - i - 1   sizeof ( char ) , QKCCDNJ )
<operator>.greaterEqualsThan i >= 0
<operator>.greaterEqualsThan DWX [ i ] >= DWX [ i + 1 ]
<operator>.logicalAnd k < YRBVPVY && DWX [ k ]
<operator>.postIncrement k ++
<operator>.assignment TOLMBGEAOHYPIQQ = 0
<operator>.subtraction YRBVPVY - 2
<operator>.addition i + 1
<operator>.assignment k = j
<operator>.addition DWX + i + 1
<operator>.subtraction YRBVPVY - i - 1
<operator>.sizeOf sizeof ( char )
<operator>.addition i + 1
<operator>.lessThan k < YRBVPVY
<operator>.logicalAnd DWX [ k ] > DWX [ i ] && DWX [ k ] < DWX [ j ]
<operator>.addition DWX + i
<operator>.subtraction YRBVPVY - i
<operator>.assignment j = k
<operator>.greaterThan DWX [ k ] > DWX [ i ]
<operator>.lessThan DWX [ k ] < DWX [ j ]
<operator>.indirectIndexAccess DWX [ i ]
<operator>.indirectIndexAccess DWX [ i + 1 ]
<operator>.addressOf & DWX [ i ]
<operator>.addressOf & DWX [ j ]
<operator>.indirectIndexAccess DWX [ k ]
<operator>.indirectIndexAccess DWX [ i ]
<operator>.indirectIndexAccess DWX [ j ]
<operator>.indirectIndexAccess DWX [ k ]
<operator>.indirectIndexAccess DWX [ i ]
<operator>.indirectIndexAccess DWX [ k ]
<operator>.indirectIndexAccess DWX [ j ]
>>>PDG&47 0->2 0->4 0->5 0->6 0->7 0->9 0->11 0->12 0->14 0->16 0->17 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->29 0->31 0->32 0->33 2->7 3->1 3->1 3->4 4->1 4->1 4->9 4->16 4->22 5->1 5->1 7->3 7->4 8->1 9->1 9->1 9->15 9->16 9->18 9->19 9->25 9->31 9->34 9->35 10->1 10->1 10->10 10->11 10->17 11->1 11->17 12->1 12->1 12->14 12->14 12->15 12->16 12->16 12->19 12->21 12->23 12->23 12->24 12->25 12->25 12->26 12->27 12->29 12->31 12->31 12->32 12->32 12->38 12->39 12->41 12->42 13->1 13->1 13->17 14->1 14->1 14->24 15->1 15->1 15->1 15->9 15->9 15->16 15->16 15->18 15->25 15->25 15->31 15->31 15->34 15->35 16->1 16->1 16->1 16->1 17->10 17->10 17->11 17->12 17->18 17->28 17->28 17->36 17->37 18->1 18->1 18->9 18->9 18->10 18->10 18->15 18->16 18->16 18->25 18->25 18->31 18->31 18->34 19->1 19->1 19->1 19->9 19->16 19->19 19->20 19->25 19->29 19->30 19->31 19->34 19->34 19->43 19->44 20->1 20->29 21->1 21->1 22->1 22->13 22->13 22->29 24->1 24->1 24->29 25->1 26->1 26->16 26->16 27->1 29->1 29->19 29->19 29->20 29->32 29->33 29->40 30->33 31->1 32->1 32->1 32->22 32->26 32->26 34->9 34->15 34->16 34->18 34->19 34->25 34->30 34->30 34->31 34->35 34->35 34->45 34->46 35->9 35->15 35->16 35->19 35->25 35->30 35->30 35->31
>>>Token void UBHHXWGQMNJQJGOYARLRPWI ( char * DWX ) { int YRBVPVY = strlen ( DWX ) ; YGXVM ( DWX , YRBVPVY , sizeof ( char ) , QKCCDNJ ) ; int TOLMBGEAOHYPIQQ = 1 ; do { printf ( " \n " , DWX ) ; int i ; for ( i = YRBVPVY - 2 ; i >= 0 && DWX [ i ] >= DWX [ i + 1 ] ; -- i ) { } if ( i >= 0 ) { int j = i + 1 , k ; for ( k = j ; k < YRBVPVY && DWX [ k ] ; k ++ ) { if ( DWX [ k ] > DWX [ i ] && DWX [ k ] < DWX [ j ] ) j = k ; } EIPG ( & DWX [ i ] , & DWX [ j ] ) ; YGXVM ( DWX + i + 1 , YRBVPVY - i - 1 , sizeof ( char ) , QKCCDNJ ) ; } else TOLMBGEAOHYPIQQ = 0 ; } while ( TOLMBGEAOHYPIQQ ) ; }
>>>Func
METHOD SIXAEP
METHOD_RETURN unsigned int
PARAM char * VIK
PARAM unsigned int RIT
<operator>.assignment MLCA = 0
<operator>.assignment i = 0
RETURN return MLCA ; return MLCA ;
<operator>.lessThan i < RIT
<operator>.expressionList VIK ++   i ++
IDENTIFIER MLCA return MLCA ;
<operator>.assignment i = 0
<operator>.assignment MLCA = MLCA << 7 ^ ( * VIK )
<operator>.postIncrement VIK ++
<operator>.postIncrement i ++
<operator>.xor MLCA << 7 ^ ( * VIK )
<operator>.shiftLeft MLCA << 7
<operator>.indirection * VIK
>>>PDG&17 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->12 0->13 0->15 2->1 2->12 3->7 4->1 4->1 4->9 4->15 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->13 7->13 7->14 7->15 7->16 8->1 8->1 8->1 9->6 10->1 10->7 11->1 11->1 11->1 11->9 11->15 12->1 12->8 13->7 13->8 14->1 14->1 14->11 14->11 14->12 15->14 15->14
>>>Token unsigned int SIXAEP ( char * VIK , unsigned int RIT ) { unsigned int MLCA = 0 ; unsigned int i = 0 ; for ( i = 0 ; i < RIT ; VIK ++ , i ++ ) { MLCA = MLCA << 7 ^ ( * VIK ) ; } return MLCA ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment XRTI = 1
<operator>.assignment UUNMQWRXUCT = 0
<operator>.assignment NKSVQQ = 0
YRQMV YRQMV ( "%d " , & n )
RETURN return 1 ; return 1 ;
<operator>.postDecrement n --
LITERAL 1 return 1 ;
<operator>.assignment UUNMQWRXUCT = 0
<operator>.assignment NKSVQQ = 0
YRQMV YRQMV ( "%d " , & GIAV )
YRQMV YRQMV ( "%d" , & PLJN )
<operator>.lessThan i < 17
<operator>.postIncrement i ++
<operator>.lessThan i < 4
<operator>.postIncrement i ++
<operator>.lessThan i < 4
<operator>.postIncrement i ++
<operator>.lessThan i < 4
<operator>.postIncrement i ++
<operator>.lessThan i < 17
<operator>.postIncrement i ++
<operator>.equals UUNMQWRXUCT == 0
<operator>.assignment i = 0
<operator>.assignment LEF [ i ] = 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.postIncrement LEF [ DHXKTQH [ GIAV - 1 ] [ i ] ] ++
<operator>.postIncrement LEF [ YGGUBYX [ PLJN - 1 ] [ i ] ] ++
<operator>.assignment i = 0
printf printf ( "Case #%d: Volunteer cheated!\n" , XRTI ++ )
<operator>.lessThan j < 4
<operator>.postIncrement j ++
<operator>.lessThan j < 4
<operator>.postIncrement j ++
<operator>.equals LEF [ i ] == 2
<operator>.assignment j = 0
YRQMV YRQMV ( "%d " , & DHXKTQH [ i ] [ j ] )
<operator>.assignment j = 0
YRQMV YRQMV ( "%d" , & YGGUBYX [ i ] [ j ] )
<operator>.assignment NKSVQQ = i
<operator>.postIncrement UUNMQWRXUCT ++
<operator>.postIncrement XRTI ++
<operator>.equals UUNMQWRXUCT == 1
printf printf ( "Case #%d: %d\n" , XRTI ++ , NKSVQQ )
<operator>.subtraction GIAV - 1
<operator>.subtraction PLJN - 1
<operator>.postIncrement XRTI ++
<operator>.greaterEqualsThan UUNMQWRXUCT >= 2
printf printf ( "Case #%d: Bad magician!\n" , XRTI ++ )
<operator>.postIncrement XRTI ++
<operator>.addressOf & GIAV
<operator>.addressOf & PLJN
<operator>.indirectIndexAccess LEF [ i ]
<operator>.indirectIndexAccess LEF [ DHXKTQH [ GIAV - 1 ] [ i ] ]
<operator>.indirectIndexAccess LEF [ YGGUBYX [ PLJN - 1 ] [ i ] ]
<operator>.indirectIndexAccess DHXKTQH [ GIAV - 1 ] [ i ]
<operator>.indirectIndexAccess YGGUBYX [ PLJN - 1 ] [ i ]
<operator>.indirectIndexAccess LEF [ i ]
<operator>.addressOf & DHXKTQH [ i ] [ j ]
<operator>.addressOf & YGGUBYX [ i ] [ j ]
<operator>.indirectIndexAccess DHXKTQH [ GIAV - 1 ]
<operator>.indirectIndexAccess YGGUBYX [ PLJN - 1 ]
<operator>.indirectIndexAccess DHXKTQH [ i ] [ j ]
<operator>.indirectIndexAccess YGGUBYX [ i ] [ j ]
<operator>.indirectIndexAccess DHXKTQH [ i ]
<operator>.indirectIndexAccess YGGUBYX [ i ]
>>>PDG&69 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 2->1 2->1 2->44 2->49 2->52 3->1 3->1 4->1 4->1 5->1 5->1 5->7 6->1 7->1 7->1 7->7 7->9 7->10 7->11 7->12 7->13 7->15 7->17 7->19 7->21 7->23 7->24 7->26 7->27 7->28 7->31 7->53 7->54 8->6 9->1 9->23 9->43 10->1 10->1 10->46 11->1 11->1 11->47 12->1 12->1 12->48 13->13 13->14 13->14 13->25 13->55 14->1 14->13 15->15 15->16 15->16 15->33 15->38 16->1 16->15 17->17 17->18 17->18 17->35 17->40 18->1 18->17 19->1 19->19 19->20 19->20 19->29 19->30 19->47 19->48 19->56 19->57 19->58 19->59 19->63 19->64 20->1 20->19 21->1 21->1 21->21 21->22 21->22 21->37 21->42 21->60 22->1 22->21 23->1 23->1 23->32 23->44 23->45 23->45 24->13 25->1 25->1 25->37 26->15 27->17 28->19 29->1 29->1 30->1 30->1 31->1 31->21 32->1 32->1 33->1 33->1 33->33 33->34 33->34 33->39 33->61 33->65 33->67 34->1 34->33 35->1 35->1 35->35 35->36 35->36 35->41 35->62 35->66 35->68 36->1 36->35 37->1 37->1 37->42 37->43 38->1 38->33 39->1 39->1 40->1 40->35 41->1 41->1 42->1 42->1 42->46 43->1 43->23 44->1 44->32 44->49 44->52 45->1 45->1 45->46 45->49 45->50 45->50 46->1 46->1 46->1 47->1 47->11 48->1 48->12 49->1 49->44 49->46 49->52 50->1 50->1 50->51 50->52 51->1 51->1 52->1 52->44 52->49 52->51
>>>Token int main ( ) { int i , j , n , XRTI = 1 ; int DHXKTQH [ 4 ] [ 4 ] , YGGUBYX [ 4 ] [ 4 ] , LEF [ 17 ] ; int GIAV , PLJN ; int UUNMQWRXUCT = 0 , NKSVQQ = 0 ; YRQMV ( " " , & n ) ; while ( n -- ) { for ( i = 0 ; i < 17 ; i ++ ) { LEF [ i ] = 0 ; } UUNMQWRXUCT = 0 ; NKSVQQ = 0 ; YRQMV ( " " , & GIAV ) ; for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) { YRQMV ( " " , & DHXKTQH [ i ] [ j ] ) ; } } YRQMV ( " " , & PLJN ) ; for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) { YRQMV ( " " , & YGGUBYX [ i ] [ j ] ) ; } } for ( i = 0 ; i < 4 ; i ++ ) { LEF [ DHXKTQH [ GIAV - 1 ] [ i ] ] ++ ; LEF [ YGGUBYX [ PLJN - 1 ] [ i ] ] ++ ; } for ( i = 0 ; i < 17 ; i ++ ) { if ( LEF [ i ] == 2 ) { NKSVQQ = i ; UUNMQWRXUCT ++ ; } } if ( UUNMQWRXUCT == 0 ) { printf ( " \n " , XRTI ++ ) ; } else if ( UUNMQWRXUCT == 1 ) { printf ( " \n " , XRTI ++ , NKSVQQ ) ; } else if ( UUNMQWRXUCT >= 2 ) { printf ( " \n " , XRTI ++ ) ; } } return 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
printf printf ( "Enter the number of vertices: " )
BFCHP BFCHP ( "%d" , & n )
<operator>.assignment g = NSDIPMVC ( n )
printf printf ( "Enter source node: " )
BFCHP BFCHP ( "%d" , & GXW )
printf printf ( "Enter destination node: " )
BFCHP BFCHP ( "%d" , & XXTP )
printf printf ( "Enter an edge (from): " )
printf printf ( "Finished.\n" )
printf printf ( "The graph has " )
printf printf ( " Hamiltonian path from %d to %d.\n" , GXW , XXTP )
QFCPGWBXD QFCPGWBXD ( g )
RETURN return 0 ; return 0 ;
<operator>.equals BFCHP ( "%d" , & e . v ) == 1
BCTJTJFWMXDBSMKSJK BCTJTJFWMXDBSMKSJK ( g , n , GXW , XXTP )
LITERAL 0 return 0 ;
NSDIPMVC NSDIPMVC ( n )
printf printf ( "Enter an edge (to): " )
BFCHP BFCHP ( "%d" , & e . w )
YBTIQECNJO YBTIQECNJO ( g , e )
printf printf ( "Enter an edge (from): " )
printf printf ( "a" )
BFCHP BFCHP ( "%d" , & e . v )
printf printf ( "no" )
<operator>.addressOf & e . v
<operator>.addressOf & e . w
<operator>.fieldAccess e . v
<operator>.fieldAccess e . w
FIELD_IDENTIFIER v v
FIELD_IDENTIFIER w w
>>>PDG&33 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->1 3->1 4->1 4->1 4->17 4->19 5->1 5->1 5->17 5->22 6->1 7->1 7->1 7->13 7->17 8->1 9->1 9->1 9->13 9->17 10->1 11->1 12->1 13->1 13->1 13->1 14->1 14->1 15->1 16->1 16->1 16->16 16->20 16->21 16->22 16->23 16->25 16->27 16->28 16->29 16->30 16->31 16->32 17->1 17->1 17->13 17->13 17->14 17->24 17->26 18->15 19->5 19->17 20->1 21->1 21->1 21->22 22->1 22->1 22->17 22->21 22->25 23->1 24->1 25->1 25->16 25->16 25->22 26->1
>>>Token int main ( void ) { RAVO e ; int n ; printf ( " " ) ; BFCHP ( " " , & n ) ; JQWDM g = NSDIPMVC ( n ) ; DQEMTJ GXW , XXTP ; printf ( " " ) ; BFCHP ( " " , & GXW ) ; printf ( " " ) ; BFCHP ( " " , & XXTP ) ; printf ( " " ) ; while ( BFCHP ( " " , & e . v ) == 1 ) { printf ( " " ) ; BFCHP ( " " , & e . w ) ; YBTIQECNJO ( g , e ) ; printf ( " " ) ; } printf ( " \n " ) ; printf ( " " ) ; if ( BCTJTJFWMXDBSMKSJK ( g , n , GXW , XXTP ) ) printf ( " " ) ; else printf ( " " ) ; printf ( " \n " , GXW , XXTP ) ; QFCPGWBXD ( g ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
WWSCB WWSCB ( "%d" , & XTFKWEQHMI )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan DVCUMUXDUL <= XTFKWEQHMI
<operator>.postIncrement DVCUMUXDUL ++
LITERAL 0 return 0 ;
<operator>.assignment DVCUMUXDUL = 1
WWSCB WWSCB ( "%d %d" , & MKKHON , & XOBAA )
<operator>.assignment QMLBMN = 2 * MKKHON - 1
<operator>.assignment QHDEAB = 0
<operator>.assignment time [ QMLBMN ] [ QHDEAB ] = 0
printf printf ( "Case #%d: %d\n" , DVCUMUXDUL , time [ QMLBMN ] [ QHDEAB ] )
<operator>.lessThan i < MKKHON
<operator>.postIncrement i ++
<operator>.lessThan i < 2 * MKKHON
<operator>.postIncrement i ++
<operator>.logicalOr QMLBMN != 0 || QHDEAB != 2 * XOBAA - 1
<operator>.assignment i = 0
<operator>.lessThan j < XOBAA
<operator>.postIncrement j ++
WWSCB WWSCB ( "%d %d %d" , & NUNLQVXOCQ [ i ] [ j ] . s , & NUNLQVXOCQ [ i ] [ j ] . w , & NUNLQVXOCQ [ i ] [ j ] . t )
<operator>.assignment i = 0
<operator>.lessThan j < 2 * XOBAA
<operator>.postIncrement j ++
<operator>.subtraction 2 * MKKHON - 1
<operator>.expressionList i = QMLBMN   j = QHDEAB
<operator>.assignment QMLBMN = i % 2 ? i + 1 : i - 1
<operator>.assignment QHDEAB = j % 2 ? j + 1 : j - 1
<operator>.assignment CXGW = time [ i ] [ j ] + 2
<operator>.assignment QMLBMN = i ^ 1
<operator>.assignment QHDEAB = j ^ 1
<operator>.assignment CQDUPWU = & NUNLQVXOCQ [ i / 2 ] [ j / 2 ]
<operator>.assignment s = CQDUPWU -> s
<operator>.assignment w = CQDUPWU -> w
<operator>.assignment t = CQDUPWU -> t
<operator>.assignment KIXBUJEJ = ( ( int ) time [ i ] [ j ] - t ) % ( s + w )
<operator>.assignment ASGDSHJ [ i ] [ j ] = 1
<operator>.assignment CXGW = ~ 0
<operator>.assignment j = 0
<operator>.multiplication 2 * MKKHON
<operator>.assignment j = 0
<operator>.assignment ASGDSHJ [ i ] [ j ] = 0
<operator>.assignment time [ i ] [ j ] = ~ 0
<operator>.multiplication 2 * MKKHON
<operator>.notEquals QMLBMN != 0
<operator>.notEquals QHDEAB != 2 * XOBAA - 1
<operator>.logicalAnd QMLBMN >= 0 && QMLBMN < 2 * MKKHON && CXGW < time [ QMLBMN ] [ j ]
<operator>.logicalAnd QHDEAB >= 0 && QHDEAB < 2 * XOBAA && CXGW < time [ i ] [ QHDEAB ]
<operator>.lessThan KIXBUJEJ < 0
<operator>.lessThan KIXBUJEJ < s
<operator>.logicalAnd QMLBMN >= 0 && QMLBMN < 2 * MKKHON && CXGW < time [ QMLBMN ] [ j ]
<operator>.logicalAnd QHDEAB >= 0 && QHDEAB < 2 * XOBAA && SIRYL < time [ i ] [ QHDEAB ]
<operator>.lessThan i < 2 * MKKHON
<operator>.postIncrement i ++
<operator>.multiplication 2 * XOBAA
<operator>.subtraction 2 * XOBAA - 1
<operator>.assignment i = QMLBMN
<operator>.assignment j = QHDEAB
<operator>.conditional i % 2 ? i + 1 : i - 1
<operator>.conditional j % 2 ? j + 1 : j - 1
<operator>.addition time [ i ] [ j ] + 2
<operator>.assignment time [ QMLBMN ] [ j ] = CXGW
<operator>.assignment time [ i ] [ QHDEAB ] = CXGW
<operator>.xor i ^ 1
<operator>.xor j ^ 1
<operator>.modulo ( ( int ) time [ i ] [ j ] - t ) % ( s + w )
<operator>.assignmentPlus KIXBUJEJ += s + w
<operator>.assignment CXGW = time [ i ] [ j ] + 1
<operator>.assignment SIRYL = time [ i ] [ j ] + s - KIXBUJEJ + 1
<operator>.assignment time [ QMLBMN ] [ j ] = CXGW
<operator>.assignment time [ i ] [ QHDEAB ] = SIRYL
<operator>.not ~ 0
<operator>.assignment i = 0
<operator>.lessThan j < 2 * XOBAA
<operator>.postIncrement j ++
<operator>.not ~ 0
<operator>.multiplication 2 * XOBAA
<operator>.modulo i % 2
<operator>.addition i + 1
<operator>.subtraction i - 1
<operator>.modulo j % 2
<operator>.addition j + 1
<operator>.subtraction j - 1
<operator>.logicalAnd QMLBMN >= 0 && QMLBMN < 2 * MKKHON
<operator>.lessThan CXGW < time [ QMLBMN ] [ j ]
<operator>.logicalAnd QHDEAB >= 0 && QHDEAB < 2 * XOBAA
<operator>.lessThan CXGW < time [ i ] [ QHDEAB ]
<operator>.subtraction ( int ) time [ i ] [ j ] - t
<operator>.addition s + w
<operator>.assignment CXGW = time [ i ] [ j ] + s + w - KIXBUJEJ + 1
<operator>.assignment SIRYL = time [ i ] [ j ] + 1
<operator>.logicalAnd QMLBMN >= 0 && QMLBMN < 2 * MKKHON
<operator>.lessThan CXGW < time [ QMLBMN ] [ j ]
<operator>.logicalAnd QHDEAB >= 0 && QHDEAB < 2 * XOBAA
<operator>.lessThan SIRYL < time [ i ] [ QHDEAB ]
<operator>.multiplication 2 * MKKHON
<operator>.assignment j = 0
<operator>.logicalAnd ! ASGDSHJ [ i ] [ j ] && time [ i ] [ j ] < CXGW
<operator>.greaterEqualsThan QMLBMN >= 0
<operator>.lessThan QMLBMN < 2 * MKKHON
<operator>.greaterEqualsThan QHDEAB >= 0
<operator>.lessThan QHDEAB < 2 * XOBAA
<operator>.division j / 2
<operator>.addition s + w
<operator>.addition time [ i ] [ j ] + 1
<operator>.addition time [ i ] [ j ] + s - KIXBUJEJ + 1
<operator>.greaterEqualsThan QMLBMN >= 0
<operator>.lessThan QMLBMN < 2 * MKKHON
<operator>.greaterEqualsThan QHDEAB >= 0
<operator>.lessThan QHDEAB < 2 * XOBAA
<operator>.multiplication 2 * XOBAA
<operator>.expressionList QMLBMN = i   QHDEAB = j   CXGW = time [ i ] [ j ]
<operator>.multiplication 2 * MKKHON
<operator>.multiplication 2 * XOBAA
<operator>.division i / 2
<operator>.subtraction time [ i ] [ j ] + s - KIXBUJEJ
<operator>.addition time [ i ] [ j ] + s + w - KIXBUJEJ + 1
<operator>.addition time [ i ] [ j ] + 1
<operator>.multiplication 2 * MKKHON
<operator>.multiplication 2 * XOBAA
<operator>.logicalNot ! ASGDSHJ [ i ] [ j ]
<operator>.lessThan time [ i ] [ j ] < CXGW
<operator>.addition time [ i ] [ j ] + s
<operator>.subtraction time [ i ] [ j ] + s + w - KIXBUJEJ
<operator>.assignment QMLBMN = i
<operator>.assignment QHDEAB = j
<operator>.assignment CXGW = time [ i ] [ j ]
<operator>.addition time [ i ] [ j ] + s + w
<operator>.addition time [ i ] [ j ] + s
<operator>.addressOf & MKKHON
<operator>.addressOf & XOBAA
<operator>.indirectIndexAccess time [ QMLBMN ] [ QHDEAB ]
<operator>.indirectIndexAccess time [ QMLBMN ] [ QHDEAB ]
<operator>.indirectIndexAccess time [ QMLBMN ]
<operator>.indirectIndexAccess time [ QMLBMN ]
<operator>.addressOf & NUNLQVXOCQ [ i ] [ j ] . s
<operator>.addressOf & NUNLQVXOCQ [ i ] [ j ] . w
<operator>.addressOf & NUNLQVXOCQ [ i ] [ j ] . t
<operator>.addressOf & NUNLQVXOCQ [ i / 2 ] [ j / 2 ]
<operator>.indirectFieldAccess CQDUPWU -> s
<operator>.indirectFieldAccess CQDUPWU -> w
<operator>.indirectFieldAccess CQDUPWU -> t
<operator>.indirectIndexAccess ASGDSHJ [ i ] [ j ]
<operator>.fieldAccess NUNLQVXOCQ [ i ] [ j ] . s
<operator>.fieldAccess NUNLQVXOCQ [ i ] [ j ] . w
<operator>.fieldAccess NUNLQVXOCQ [ i ] [ j ] . t
<operator>.indirectIndexAccess ASGDSHJ [ i ] [ j ]
<operator>.indirectIndexAccess time [ i ] [ j ]
<operator>.indirectIndexAccess time [ i ] [ j ]
<operator>.indirectIndexAccess NUNLQVXOCQ [ i / 2 ] [ j / 2 ]
FIELD_IDENTIFIER s s
FIELD_IDENTIFIER w w
FIELD_IDENTIFIER t t
<operator>.indirectIndexAccess ASGDSHJ [ i ]
<operator>.indirectIndexAccess NUNLQVXOCQ [ i ] [ j ]
FIELD_IDENTIFIER s s
<operator>.indirectIndexAccess NUNLQVXOCQ [ i ] [ j ]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess NUNLQVXOCQ [ i ] [ j ]
FIELD_IDENTIFIER t t
<operator>.indirectIndexAccess ASGDSHJ [ i ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess time [ QMLBMN ] [ j ]
<operator>.indirectIndexAccess time [ QMLBMN ] [ j ]
<operator>.indirectIndexAccess time [ i ] [ QHDEAB ]
<operator>.indirectIndexAccess time [ i ] [ QHDEAB ]
<operator>.indirectIndexAccess NUNLQVXOCQ [ i / 2 ]
<operator>.cast ( int ) time [ i ] [ j ]
<operator>.indirectIndexAccess time [ QMLBMN ] [ j ]
<operator>.indirectIndexAccess time [ QMLBMN ] [ j ]
<operator>.indirectIndexAccess time [ i ] [ QHDEAB ]
<operator>.indirectIndexAccess time [ i ] [ QHDEAB ]
<operator>.indirectIndexAccess NUNLQVXOCQ [ i ]
<operator>.indirectIndexAccess NUNLQVXOCQ [ i ]
<operator>.indirectIndexAccess NUNLQVXOCQ [ i ]
<operator>.indirectIndexAccess time [ QMLBMN ]
<operator>.indirectIndexAccess time [ QMLBMN ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess time [ i ]
UNKNOWN int int
<operator>.indirectIndexAccess time [ i ] [ j ]
<operator>.indirectIndexAccess time [ i ] [ j ]
<operator>.indirectIndexAccess time [ QMLBMN ]
<operator>.indirectIndexAccess time [ QMLBMN ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess time [ i ] [ j ]
<operator>.indirectIndexAccess ASGDSHJ [ i ] [ j ]
<operator>.indirectIndexAccess time [ i ] [ j ]
<operator>.indirectIndexAccess time [ i ] [ j ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess ASGDSHJ [ i ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess time [ i ] [ j ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess time [ i ]
<operator>.indirectIndexAccess time [ i ] [ j ]
<operator>.indirectIndexAccess time [ i ]
>>>PDG&202 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->37 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->49 0->50 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->85 0->87 0->88 0->89 0->90 0->91 0->93 0->95 0->96 0->97 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->122 0->123 0->124 0->125 0->126 0->128 0->129 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->15 4->17 4->18 4->22 4->25 4->40 4->44 4->45 4->130 4->131 4->132 4->133 4->134 4->135 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->13 8->19 8->40 8->44 8->55 8->77 8->96 8->111 8->113 8->114 8->119 8->120 9->1 9->1 9->45 10->1 10->1 10->26 10->46 10->58 11->1 11->12 12->1 12->1 12->5 13->1 13->13 13->14 13->14 13->19 13->39 13->40 14->1 14->13 15->1 15->1 15->15 15->16 15->16 15->23 15->40 15->41 15->55 16->1 16->15 17->1 17->1 17->1 17->17 17->26 17->27 17->28 17->29 17->30 17->31 17->32 17->33 17->34 17->35 17->36 17->37 17->38 17->45 17->47 17->48 17->49 17->50 17->51 17->52 17->53 17->57 17->58 17->59 17->60 17->61 17->64 17->65 17->66 17->72 17->73 17->78 17->81 17->84 17->86 17->88 17->89 17->92 17->94 17->96 17->99 17->101 17->103 17->107 17->109 17->115 17->139 17->140 17->141 17->142 17->143 17->149 17->150 17->151 17->152 17->153 17->154 17->163 17->168 17->169 17->181 17->182 17->188 18->13 19->1 19->1 19->1 19->8 19->19 19->20 19->20 19->21 19->55 19->77 19->111 19->114 19->120 19->136 19->137 19->138 19->144 19->145 19->146 19->155 19->156 19->157 19->158 19->159 19->160 19->174 19->175 19->176 20->1 20->19 21->1 21->1 21->1 21->1 22->1 22->15 23->1 23->1 23->1 23->23 23->24 23->24 23->42 23->43 23->55 23->76 23->147 23->148 23->161 23->162 24->1 24->23 25->1 25->9 25->9 26->1 26->1 26->1 27->1 27->1 27->99 28->1 28->1 28->101 29->1 29->1 29->62 29->63 29->85 29->87 30->1 30->1 30->107 31->1 31->1 31->109 32->1 32->1 32->1 33->1 33->1 33->50 33->66 33->67 33->89 33->104 34->1 34->1 34->66 34->67 34->89 34->104 34->124 34->128 35->1 35->1 35->88 36->1 36->1 36->49 37->1 37->1 37->121 38->1 38->1 38->1 38->122 39->1 39->19 40->15 40->15 40->44 41->1 41->23 42->1 42->1 43->1 43->1 43->1 43->29 43->61 44->1 44->8 44->13 44->25 44->25 44->96 44->113 44->119 45->1 45->17 45->17 45->26 45->46 45->56 45->57 45->77 46->1 46->1 46->17 46->17 46->26 46->58 47->51 47->62 47->165 47->178 48->1 48->1 48->63 48->167 48->180 49->1 49->50 49->67 49->67 49->104 50->1 50->68 50->69 50->90 50->91 50->105 50->106 50->116 50->116 50->116 50->117 50->118 50->123 50->123 50->124 50->124 50->124 50->128 50->128 50->129 50->129 50->183 50->189 50->190 50->193 50->194 50->198 50->200 50->201 51->1 51->1 51->1 51->47 51->70 51->171 51->185 52->1 52->1 52->1 52->71 52->173 52->187 53->1 53->1 53->1 53->53 53->54 53->54 53->74 53->96 53->97 53->111 53->112 53->125 54->1 54->53 55->1 55->8 55->19 55->23 55->23 55->77 55->111 55->114 55->120 56->1 56->46 56->46 57->26 57->78 58->26 58->81 59->1 59->1 59->1 60->1 60->1 60->1 62->1 62->1 62->85 62->93 63->1 63->1 63->87 63->95 64->30 64->30 64->115 65->31 65->31 65->103 66->1 66->1 66->36 66->36 67->1 67->1 67->50 68->1 68->1 68->70 68->93 69->1 69->1 69->1 69->71 69->95 70->1 70->1 70->85 70->93 71->1 71->1 71->1 71->87 71->95 72->38 73->1 73->53 74->1 74->1 74->1 74->74 74->75 74->75 74->98 74->111 74->112 74->121 74->126 74->191 74->195 75->1 75->74 76->43 77->1 77->8 77->19 77->55 77->56 77->56 77->111 77->114 77->120 78->27 78->59 78->64 78->79 78->79 78->80 78->80 80->27 80->27 80->59 80->59 80->64 81->28 81->60 81->65 81->82 81->82 81->83 81->83 83->28 83->28 83->60 83->60 83->65 84->47 84->47 84->85 84->92 84->164 84->177 85->1 85->47 85->47 85->62 85->63 85->87 85->93 86->48 86->48 86->87 86->94 86->166 86->179 87->1 87->48 87->48 87->63 87->95 88->1 88->1 88->66 88->66 89->1 90->1 90->1 90->70 90->93 91->1 91->1 91->1 91->71 91->95 92->1 92->1 92->51 92->51 92->84 92->93 92->170 92->184 93->1 93->51 93->51 93->70 93->85 94->1 94->1 94->52 94->52 94->86 94->95 94->172 94->186 95->1 95->1 95->52 95->52 95->71 95->87 96->1 96->8 96->13 96->53 96->53 96->113 96->119 97->1 97->74 98->1 98->1 98->1 98->112 98->125 98->126 98->127 98->197 98->199 99->84 99->84 99->100 99->100 99->113 100->84 100->84 101->86 101->86 101->102 101->102 101->114 102->1 102->86 102->86 103->1 104->1 106->1 107->45 107->92 107->92 107->108 107->108 107->119 108->45 108->92 108->92 109->1 109->26 109->46 109->58 109->94 109->94 109->110 109->110 109->120 110->1 110->1 110->26 110->46 110->58 110->94 110->94 111->1 111->8 111->19 111->55 111->74 111->74 111->77 111->114 111->120 112->1 112->1 112->1 112->1 113->96 113->100 113->100 113->119 114->1 114->8 114->19 114->55 114->77 114->102 114->102 114->111 114->120 116->1 116->1 116->69 116->69 116->106 116->106 117->1 118->1 119->96 119->108 119->108 120->1 120->8 120->19 120->55 120->77 120->110 120->110 120->111 120->114 121->1 121->98 121->122 121->192 121->196 122->1 122->1 122->29 122->61 122->98 122->98 122->112 122->127 123->1 123->1 124->1 124->1 124->90 124->90 124->117 124->117 125->45 125->112 126->1 126->26 126->46 126->58 126->112 127->1 127->1 127->112 127->122 128->1 128->1 129->1
>>>Token int main ( ) { int DVCUMUXDUL , XTFKWEQHMI ; int MKKHON , XOBAA ; struct EVDBKAC NUNLQVXOCQ [ XQYMBLUR ] [ XQYMBLUR ] ; unsigned int time [ 2 * XQYMBLUR ] [ 2 * XQYMBLUR ] ; int ASGDSHJ [ 2 * XQYMBLUR ] [ 2 * XQYMBLUR ] ; int i , j , QMLBMN , QHDEAB ; struct EVDBKAC * CQDUPWU ; unsigned int CXGW , SIRYL ; int KIXBUJEJ , s , w , t ; WWSCB ( " " , & XTFKWEQHMI ) ; for ( DVCUMUXDUL = 1 ; DVCUMUXDUL <= XTFKWEQHMI ; DVCUMUXDUL ++ ) { WWSCB ( " " , & MKKHON , & XOBAA ) ; for ( i = 0 ; i < MKKHON ; i ++ ) for ( j = 0 ; j < XOBAA ; j ++ ) WWSCB ( " " , & NUNLQVXOCQ [ i ] [ j ] . s , & NUNLQVXOCQ [ i ] [ j ] . w , & NUNLQVXOCQ [ i ] [ j ] . t ) ; for ( i = 0 ; i < 2 * MKKHON ; i ++ ) for ( j = 0 ; j < 2 * XOBAA ; j ++ ) { ASGDSHJ [ i ] [ j ] = 0 ; time [ i ] [ j ] = ~ 0 ; } QMLBMN = 2 * MKKHON - 1 ; QHDEAB = 0 ; time [ QMLBMN ] [ QHDEAB ] = 0 ; while ( QMLBMN != 0 || QHDEAB != 2 * XOBAA - 1 ) { i = QMLBMN , j = QHDEAB ; QMLBMN = i % 2 ? i + 1 : i - 1 ; QHDEAB = j % 2 ? j + 1 : j - 1 ; CXGW = time [ i ] [ j ] + 2 ; if ( QMLBMN >= 0 && QMLBMN < 2 * MKKHON && CXGW < time [ QMLBMN ] [ j ] ) time [ QMLBMN ] [ j ] = CXGW ; if ( QHDEAB >= 0 && QHDEAB < 2 * XOBAA && CXGW < time [ i ] [ QHDEAB ] ) time [ i ] [ QHDEAB ] = CXGW ; QMLBMN = i ^ 1 ; QHDEAB = j ^ 1 ; CQDUPWU = & NUNLQVXOCQ [ i / 2 ] [ j / 2 ] ; s = CQDUPWU -> s ; w = CQDUPWU -> w ; t = CQDUPWU -> t ; KIXBUJEJ = ( ( int ) time [ i ] [ j ] - t ) % ( s + w ) ; if ( KIXBUJEJ < 0 ) KIXBUJEJ += s + w ; if ( KIXBUJEJ < s ) { CXGW = time [ i ] [ j ] + 1 ; SIRYL = time [ i ] [ j ] + s - KIXBUJEJ + 1 ; } else { CXGW = time [ i ] [ j ] + s + w - KIXBUJEJ + 1 ; SIRYL = time [ i ] [ j ] + 1 ; } if ( QMLBMN >= 0 && QMLBMN < 2 * MKKHON && CXGW < time [ QMLBMN ] [ j ] ) time [ QMLBMN ] [ j ] = CXGW ; if ( QHDEAB >= 0 && QHDEAB < 2 * XOBAA && SIRYL < time [ i ] [ QHDEAB ] ) time [ i ] [ QHDEAB ] = SIRYL ; ASGDSHJ [ i ] [ j ] = 1 ; CXGW = ~ 0 ; for ( i = 0 ; i < 2 * MKKHON ; i ++ ) for ( j = 0 ; j < 2 * XOBAA ; j ++ ) if ( ! ASGDSHJ [ i ] [ j ] && time [ i ] [ j ] < CXGW ) QMLBMN = i , QHDEAB = j , CXGW = time [ i ] [ j ] ; } printf ( " \n " , DVCUMUXDUL , time [ QMLBMN ] [ QHDEAB ] ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
BSHTF BSHTF ( "%d\n" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= T
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 1
BSHTF BSHTF ( "%d " , & C )
BSHTF BSHTF ( "%d " , & D )
BSHTF BSHTF ( "%d " , & N )
<operator>.assignment NJCM = 0
<operator>.assignment * ADX = PBXWTCXORA ( IBRCIDNT , NJCM )
printf printf ( "Case #%d: %s\n" , t , ADX )
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
IDENTIFIER NJCM if (NJCM)
<operator>.assignment i = 0
BSHTF BSHTF ( "%c%c%c "   & ( NWSTAS [ i ] . a )   & ( NWSTAS [ i ] . b )   & ( NWSTAS [ i ] . BMA ) )
<operator>.assignment i = 0
BSHTF BSHTF ( "%c%c "   & ( FII [ i ] . a )   & ( FII [ i ] . b ) )
<operator>.assignment i = 0
BSHTF BSHTF ( "%c" , & WAHQ )
PBXWTCXORA PBXWTCXORA ( IBRCIDNT , NJCM )
free free ( ADX )
<operator>.logicalNot ! CAROAVRTHKD ( WAHQ , IBRCIDNT , NJCM , NWSTAS , C )
CAROAVRTHKD CAROAVRTHKD ( WAHQ , IBRCIDNT , NJCM , NWSTAS , C )
<operator>.logicalNot ! ERLOCOHEYMTT ( WAHQ , IBRCIDNT , & NJCM , FII , D )
<operator>.assignment IBRCIDNT [ NJCM ++ ] = WAHQ
ERLOCOHEYMTT ERLOCOHEYMTT ( WAHQ , IBRCIDNT , & NJCM , FII , D )
<operator>.postIncrement NJCM ++
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.addressOf & ( NWSTAS [ i ] . a )
<operator>.addressOf & ( NWSTAS [ i ] . b )
<operator>.addressOf & ( NWSTAS [ i ] . BMA )
<operator>.addressOf & ( FII [ i ] . a )
<operator>.addressOf & ( FII [ i ] . b )
<operator>.addressOf & WAHQ
<operator>.fieldAccess NWSTAS [ i ] . a
<operator>.fieldAccess NWSTAS [ i ] . b
<operator>.fieldAccess NWSTAS [ i ] . BMA
<operator>.fieldAccess FII [ i ] . a
<operator>.fieldAccess FII [ i ] . b
<operator>.indirectIndexAccess NWSTAS [ i ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess NWSTAS [ i ]
FIELD_IDENTIFIER b b
<operator>.indirectIndexAccess NWSTAS [ i ]
FIELD_IDENTIFIER BMA BMA
<operator>.indirectIndexAccess FII [ i ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess FII [ i ]
FIELD_IDENTIFIER b b
<operator>.addressOf & NJCM
<operator>.indirectIndexAccess IBRCIDNT [ NJCM ++ ]
>>>PDG&61 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->32 0->33 0->34 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->13 4->14 4->16 4->18 4->21 4->23 4->25 4->27 4->28 4->35 4->36 4->37 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->14 8->30 9->1 9->1 9->16 9->33 10->1 10->1 10->18 11->1 11->27 11->30 12->1 12->1 12->13 13->1 13->1 13->5 13->28 14->1 14->1 14->8 14->14 14->15 14->15 14->22 14->30 14->38 14->39 14->40 14->44 14->45 14->46 14->49 14->50 14->51 14->52 14->53 14->54 15->1 15->14 16->1 16->1 16->9 16->16 16->17 16->17 16->24 16->33 16->41 16->42 16->47 16->48 16->55 16->56 16->57 16->58 17->1 17->16 18->1 18->1 18->1 18->10 18->18 18->19 18->19 18->26 18->29 18->30 18->43 19->1 19->18 21->14 22->1 22->1 22->1 22->1 23->16 24->1 24->1 24->1 25->1 25->18 26->1 26->1 26->30 26->32 26->33 27->1 27->1 27->12 27->12 27->30 28->1 29->1 29->1 29->31 29->33 29->59 30->1 30->1 30->1 30->8 30->14 30->26 30->27 30->27 30->29 30->29 30->29 30->29 30->29 30->33 30->33 30->33 30->34 31->1 31->1 31->32 31->34 31->60 32->1 32->1 32->1 32->27 32->30 32->33 33->1 33->1 33->1 33->1 33->9 33->16 33->26 33->27 33->27 33->30 33->30 33->30 33->31 33->31 33->31 33->31 33->31 33->32 33->34 34->27 34->30
>>>Token int main ( ) { int T ; BSHTF ( " \n " , & T ) ; for ( int t = 1 ; t <= T ; t ++ ) { int C , D , N ; BSHTF ( " " , & C ) ; LILHTGY NWSTAS [ C ] ; for ( int i = 0 ; i < C ; i ++ ) { BSHTF ( " " , & ( NWSTAS [ i ] . a ) , & ( NWSTAS [ i ] . b ) , & ( NWSTAS [ i ] . BMA ) ) ; } BSHTF ( " " , & D ) ; CAQKSJW FII [ D ] ; for ( int i = 0 ; i < D ; i ++ ) { BSHTF ( " " , & ( FII [ i ] . a ) , & ( FII [ i ] . b ) ) ; } BSHTF ( " " , & N ) ; char IBRCIDNT [ N ] ; int NJCM = 0 ; for ( int i = 0 ; i < N ; i ++ ) { char WAHQ ; BSHTF ( " " , & WAHQ ) ; if ( ! CAROAVRTHKD ( WAHQ , IBRCIDNT , NJCM , NWSTAS , C ) ) if ( ! ERLOCOHEYMTT ( WAHQ , IBRCIDNT , & NJCM , FII , D ) ) IBRCIDNT [ NJCM ++ ] = WAHQ ; } char * ADX = PBXWTCXORA ( IBRCIDNT , NJCM ) ; printf ( " \n " , t , ADX ) ; if ( NJCM ) free ( ADX ) ; } return 0 ; }
>>>Func
METHOD THDQ
METHOD_RETURN void
PARAM int m
<operator>.postDecrement KBN --
<operator>.lessEqualsThan i <= KBN - 1
<operator>.postIncrement i ++
<operator>.assignment i = m
<operator>.assignment PKVM [ i ] = PKVM [ i + 1 ]
<operator>.subtraction KBN - 1
<operator>.addition i + 1
<operator>.indirectIndexAccess PKVM [ i ]
<operator>.indirectIndexAccess PKVM [ i + 1 ]
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->8 0->9 2->6 3->1 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->7 4->8 4->9 4->9 4->10 4->11 5->1 5->4 6->1 6->1 6->4 7->1 7->1 7->1 8->3 8->4 8->4
>>>Token void THDQ ( int m ) { int i ; for ( i = m ; i <= KBN - 1 ; i ++ ) { PKVM [ i ] = PKVM [ i + 1 ] ; } KBN -- ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
VEDXUV VEDXUV ( BRU , UVYIJ , "B-small-attempt0.out" )
RETURN return 0 ; return 0 ;
<operator>.equals ( UVYIJ = EVATYQBJWD ( BRU , "B-small-attempt0.in" ) ) == - 1
<operator>.lessThan k < UVYIJ
<operator>.postIncrement k ++
YUTKQJ YUTKQJ ( & BRU [ k ] )
LITERAL 0 return 0 ;
RETURN return - 1 ; return - 1 ;
<operator>.assignment k = 0
<operator>.assignment UVYIJ = EVATYQBJWD ( BRU , "B-small-attempt0.in" )
<operator>.minus - 1
<operator>.minus - 1
EVATYQBJWD EVATYQBJWD ( BRU , "B-small-attempt0.in" )
<operator>.addressOf & BRU [ k ]
<operator>.indirectIndexAccess BRU [ k ]
>>>PDG&19 0->2 0->3 0->4 0->5 0->7 0->8 0->10 0->12 0->14 0->15 0->16 2->1 3->1 5->1 6->1 6->1 6->4 6->5 6->7 6->11 6->12 6->15 7->4 7->7 7->8 7->8 7->9 7->17 7->18 8->7 9->4 10->5 11->1 12->7 13->1 13->1 13->6 13->7 14->6 15->1 15->11 16->1 16->4 16->6 16->6 16->9 16->13 16->13
>>>Token int main ( int argc , char * argv [ ] ) { CQPO BRU [ 100 ] ; int k ; int UVYIJ ; if ( ( UVYIJ = EVATYQBJWD ( BRU , " " ) ) == - 1 ) return - 1 ; for ( k = 0 ; k < UVYIJ ; k ++ ) YUTKQJ ( & BRU [ k ] ) ; VEDXUV ( BRU , UVYIJ , " " ) ; return 0 ; }
>>>Func
METHOD AXRC
METHOD_RETURN void
PARAM int x
PARAM int y
PARAM int * nx
PARAM int * ny
PARAM int N
PARAM int M
<operator>.assignment ( * nx ) = ( ( * nx ) + N ) % N
<operator>.assignment ( * ny ) = ( ( * ny ) + M ) % M
<operator>.equals a [ x ] [ y ] == '|'
<operator>.modulo ( ( * nx ) + N ) % N
<operator>.modulo ( ( * ny ) + M ) % M
<operator>.addition ( * nx ) + N
<operator>.addition ( * ny ) + M
<operator>.assignment ( * nx ) = x - 1
<operator>.assignment ( * ny ) = y
<operator>.equals a [ x ] [ y ] == '-'
<operator>.assignment ( * nx ) = x + 1
<operator>.assignment ( * ny ) = y
<operator>.subtraction x - 1
<operator>.addition x + 1
<operator>.assignment ( * nx ) = x
<operator>.assignment ( * ny ) = y - 1
<operator>.equals a [ x ] [ y ] == '/'
<operator>.assignment ( * nx ) = x
<operator>.assignment ( * ny ) = y + 1
<operator>.subtraction y - 1
<operator>.addition y + 1
<operator>.assignment ( * nx ) = x - 1
<operator>.assignment ( * ny ) = y + 1
<operator>.assignment ( * nx ) = x + 1
<operator>.assignment ( * ny ) = y - 1
<operator>.assignment ( * nx ) = x - 1
<operator>.assignment ( * ny ) = y - 1
<operator>.subtraction x - 1
<operator>.addition y + 1
<operator>.assignment ( * nx ) = x + 1
<operator>.assignment ( * ny ) = y + 1
<operator>.addition x + 1
<operator>.subtraction y - 1
<operator>.subtraction x - 1
<operator>.subtraction y - 1
<operator>.addition x + 1
<operator>.addition y + 1
<operator>.indirectIndexAccess d [ x ] [ y ]
<operator>.indirectIndexAccess d [ x ]
<operator>.indirection * nx
<operator>.indirection * ny
<operator>.indirectIndexAccess a [ x ] [ y ]
<operator>.indirection * nx
<operator>.indirection * ny
<operator>.indirectIndexAccess a [ x ]
<operator>.indirectIndexAccess d [ x ] [ y ]
<operator>.indirectIndexAccess d [ x ]
<operator>.indirection * nx
<operator>.indirection * ny
<operator>.indirectIndexAccess a [ x ] [ y ]
<operator>.indirection * nx
<operator>.indirection * ny
<operator>.indirectIndexAccess a [ x ]
<operator>.indirectIndexAccess d [ x ] [ y ]
<operator>.indirectIndexAccess d [ x ]
<operator>.indirectIndexAccess d [ x ] [ y ]
<operator>.indirection * nx
<operator>.indirection * ny
<operator>.indirectIndexAccess d [ x ]
<operator>.indirection * nx
<operator>.indirection * ny
<operator>.indirection * nx
<operator>.indirection * ny
<operator>.indirection * nx
<operator>.indirection * ny
>>>PDG&73 0->2 0->3 0->4 0->5 0->6 0->7 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->30 0->31 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 2->18 2->20 2->21 2->22 2->25 2->31 2->35 2->37 2->39 2->41 2->43 3->16 3->19 3->26 3->27 3->28 3->30 3->36 3->38 3->40 3->42 3->44 4->1 5->1 6->11 6->13 7->12 7->14 8->1 8->1 8->1 9->1 9->1 9->1 10->1 10->1 10->17 10->17 10->45 10->46 10->49 10->52 11->1 11->1 11->8 11->8 12->1 12->1 12->9 12->9 15->1 15->1 15->11 15->13 16->1 16->1 16->12 16->14 17->1 17->1 17->24 17->24 17->53 17->54 17->57 17->60 18->1 18->1 18->11 18->13 19->1 19->1 19->12 19->14 20->1 20->15 20->15 21->1 22->1 22->1 22->11 22->13 23->1 23->1 23->12 23->14 24->1 24->1 24->61 24->62 24->63 24->66 25->1 25->1 25->11 25->13 26->1 26->1 26->12 26->14 27->1 27->23 27->23 28->1 29->1 29->1 29->11 29->13 30->1 30->1 30->12 30->14 31->1 31->1 31->11 31->13 32->1 32->1 32->12 32->14 33->1 33->1 33->11 33->13 34->1 34->1 34->12 34->14 35->1 35->29 35->29 36->1 37->1 37->1 37->11 37->13 38->1 38->1 38->12 38->14 39->1 40->1 40->32 40->32 41->1 41->33 41->33 42->1 42->34 42->34 43->1 44->1 45->15 45->16 45->18 45->19 45->20 45->21 45->47 45->48 45->50 45->51 53->22 53->23 53->25 53->26 53->27 53->28 53->55 53->56 53->58 53->59 61->29 61->30 61->31 61->32 61->35 61->36 61->39 61->40 61->64 61->65 61->67 61->68 63->33 63->34 63->37 63->38 63->41 63->42 63->43 63->44 63->69 63->70 63->71 63->72
>>>Token void AXRC ( int x , int y , int * nx , int * ny , int N , int M ) { if ( a [ x ] [ y ] == ' ' ) { if ( d [ x ] [ y ] ) { ( * nx ) = x - 1 ; ( * ny ) = y ; } else { ( * nx ) = x + 1 ; ( * ny ) = y ; } } else if ( a [ x ] [ y ] == ' ' ) { if ( d [ x ] [ y ] ) { ( * nx ) = x ; ( * ny ) = y - 1 ; } else { ( * nx ) = x ; ( * ny ) = y + 1 ; } } else if ( a [ x ] [ y ] == ' ' ) { if ( d [ x ] [ y ] ) { ( * nx ) = x - 1 ; ( * ny ) = y + 1 ; } else { ( * nx ) = x + 1 ; ( * ny ) = y - 1 ; } } else { if ( d [ x ] [ y ] ) { ( * nx ) = x - 1 ; ( * ny ) = y - 1 ; } else { ( * nx ) = x + 1 ; ( * ny ) = y + 1 ; } } ( * nx ) = ( ( * nx ) + N ) % N ; ( * ny ) = ( ( * ny ) + M ) % M ; }
>>>Func
METHOD PJQW
METHOD_RETURN RAVOBFCH
PARAM const char * s
<operator>.assignment DMNS = 5381
<operator>.assignment i = 0
RETURN return DMNS ; return DMNS ;
<operator>.notEquals s [ i ] != '\0'
IDENTIFIER DMNS return DMNS ;
<operator>.assignment DMNS = ( ( DMNS << 5 ) + DMNS ) + s [ i ]
<operator>.postIncrement i ++
<operator>.addition ( ( DMNS << 5 ) + DMNS ) + s [ i ]
<operator>.addition ( DMNS << 5 ) + DMNS
<operator>.shiftLeft DMNS << 5
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i ]
>>>PDG&15 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 2->6 2->8 2->10 3->1 3->1 3->7 3->12 4->1 4->1 4->9 5->1 6->1 6->1 6->6 6->8 6->8 6->9 6->10 6->10 6->11 6->12 6->13 6->14 7->5 8->1 8->1 8->1 8->7 8->12 9->1 9->1 10->1 11->1 12->8 12->8 12->10 12->10 12->11 12->11
>>>Token RAVOBFCH PJQW ( const char * s ) { RAVOBFCH DMNS = 5381 ; size_t i = 0 ; while ( s [ i ] != ' \0 ' ) { DMNS = ( ( DMNS << 5 ) + DMNS ) + s [ i ] ; i ++ ; } return DMNS ; }
>>>Func
METHOD MFX
METHOD_RETURN NBKEMOM
PARAM NBKEMOM x
PARAM NBKEMOM y
RETURN return x ; return x ;
IDENTIFIER y while (y)
IDENTIFIER x return x ;
<operator>.assignment t = y
<operator>.assignment y = x % y
<operator>.assignment x = t
<operator>.modulo x % y
>>>PDG&11 0->2 0->3 0->5 0->6 0->7 0->9 0->10 2->1 2->6 2->10 3->1 3->7 3->10 4->1 6->4 7->9 10->8 10->8
>>>Token NBKEMOM MFX ( NBKEMOM x , NBKEMOM y ) { NBKEMOM t ; while ( y ) { t = y ; y = x % y ; x = t ; } return x ; }
>>>Func
METHOD main
METHOD_RETURN int
RETURN return 0 ; return 0 ;
<operator>.lessThan i < 10000000
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
<operator>.logicalAnd MUS ( i ) && MUS ( ( unsigned long long ) ( i * i ) )
printf printf ( "%llu \n"   ( unsigned long long ) ( i * i ) )
MUS MUS ( i )
MUS MUS ( ( unsigned long long ) ( i * i ) )
<operator>.cast ( unsigned long long ) ( i * i )
<operator>.cast ( unsigned long long ) ( i * i )
<operator>.multiplication i * i
<operator>.multiplication i * i
UNKNOWN unsigned long long unsigned long long
UNKNOWN unsigned long long unsigned long long
>>>PDG&17 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->13 0->14 2->1 3->1 3->1 3->3 3->4 3->7 3->9 3->9 4->1 4->3 5->2 6->1 6->3 7->1 7->1 7->1 7->8 7->12 7->14 7->16 8->1 8->1 9->4 9->7 9->10 9->11 9->13 9->13 9->14 9->15 10->1 10->7 11->1 12->1 13->4 13->10 13->11 13->14 14->4 14->8 14->12
>>>Token int main ( ) { unsigned long long i ; for ( i = 1 ; i < 10000000 ; i ++ ) { if ( MUS ( i ) && MUS ( ( unsigned long long ) ( i * i ) ) ) { printf ( " \n " , ( unsigned long long ) ( i * i ) ) ; } } return 0 ; }
>>>Func
METHOD PWBVG
METHOD_RETURN void
<operator>.assignment THLRJP = 0
<operator>.assignmentPlus ex += THLRJP
<operator>.assignmentPlus THLRJP += k
<operator>.lessThan i < 2 * k - 1
<operator>.postIncrement i ++
<operator>.lessThan VHE < THLRJP * THLRJP - k * k
<operator>.assignment i = 0
<operator>.assignment FPJ = 0
<operator>.assignment VHE = THLRJP * THLRJP - k * k
<operator>.subtraction 2 * k - 1
<operator>.lessThan i < k
<operator>.equals j == 1
<operator>.postIncrement m ++
<operator>.lessThan THLRJP < FPJ
<operator>.subtraction THLRJP * THLRJP - k * k
<operator>.multiplication 2 * k
<operator>.assignment j = i + 1
<operator>.assignment m = 0
<operator>.assignment GCNI = m
<operator>.assignment PEUUB = j - 1
<operator>.assignment FPJ = m
<operator>.assignment THLRJP = FPJ
<operator>.multiplication THLRJP * THLRJP
<operator>.multiplication k * k
<operator>.subtraction THLRJP * THLRJP - k * k
<operator>.assignment j = 2 * k - i - 1
<operator>.equals m == j - 1
<operator>.lessThan GCNI < j
<operator>.expressionList GCNI ++   PEUUB --
<operator>.multiplication THLRJP * THLRJP
<operator>.multiplication k * k
<operator>.addition i + 1
<operator>.assignment FPJ = j - 1
<operator>.subtraction j - 1
<operator>.subtraction 2 * k - i - 1
<operator>.subtraction j - 1
<operator>.postIncrement GCNI ++
<operator>.postDecrement PEUUB --
<operator>.notEquals ISR [ i ] [ GCNI ] != ISR [ i ] [ PEUUB ]
<operator>.subtraction 2 * k - i
<operator>.subtraction j - 1
<operator>.multiplication 2 * k
<operator>.indirectIndexAccess ISR [ i ] [ GCNI ]
<operator>.indirectIndexAccess ISR [ i ] [ PEUUB ]
<operator>.indirectIndexAccess ISR [ i ]
<operator>.indirectIndexAccess ISR [ i ]
>>>PDG&48 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->28 0->29 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->41 0->42 0->43 2->1 2->3 2->4 2->15 3->1 3->1 4->1 4->24 5->1 5->1 5->1 5->5 5->6 5->11 5->12 5->12 5->13 5->17 6->1 6->5 7->1 7->10 7->26 7->31 7->32 8->1 8->5 9->1 9->15 10->1 10->1 10->1 11->1 11->5 11->5 12->1 12->6 12->17 12->18 12->18 12->27 12->33 12->33 12->36 12->41 12->41 12->43 12->43 13->1 13->1 13->9 13->14 13->15 13->19 13->37 14->1 14->1 14->28 14->28 14->37 15->1 15->1 15->3 15->4 15->23 15->23 16->7 16->7 17->4 17->11 17->11 17->12 17->25 18->1 18->1 18->13 19->1 19->14 20->1 20->29 21->1 21->1 21->1 21->39 22->1 22->1 22->15 23->1 23->1 23->3 23->4 23->15 24->16 24->31 25->16 25->32 26->1 26->1 26->10 26->10 27->1 27->1 27->13 28->1 28->1 28->14 28->20 28->20 28->21 28->22 28->29 28->34 28->35 28->42 29->1 29->1 29->1 29->22 29->37 29->38 29->40 29->44 29->45 29->46 29->47 30->1 30->1 30->1 31->1 31->26 32->1 32->26 34->1 34->1 34->15 35->21 35->21 35->29 36->1 36->27 36->27 37->28 37->28 37->35 37->42 38->29 38->30 39->1 39->30 40->1 40->1 40->1 40->14 40->29 40->30 40->38 40->39 41->6 41->36 41->36 42->1 42->34 42->34 43->17 43->41 43->41
>>>Token void PWBVG ( ) { int THLRJP = 0 , i , j , m , FPJ , GCNI , PEUUB ; for ( i = 0 ; i < 2 * k - 1 ; i ++ ) { if ( i < k ) j = i + 1 ; else j = 2 * k - i - 1 ; if ( j == 1 ) continue ; FPJ = 0 ; for ( m = 0 ; ; m ++ ) { if ( m == j - 1 ) { FPJ = j - 1 ; break ; } GCNI = m ; PEUUB = j - 1 ; for ( ; GCNI < j ; GCNI ++ , PEUUB -- ) { if ( ISR [ i ] [ GCNI ] != ISR [ i ] [ PEUUB ] ) goto XMRF ; } FPJ = m ; break ; XMRF : ; } if ( THLRJP < FPJ ) THLRJP = FPJ ; } ex += THLRJP ; THLRJP += k ; if ( VHE < THLRJP * THLRJP - k * k ) VHE = THLRJP * THLRJP - k * k ; }
>>>Func
METHOD NFBSLBKJCKOQ
METHOD_RETURN void
PARAM YANAND * SYH
<operator>.assignment HPOWWP = 0
<operator>.assignment PJSC = sizeof ( YANAND )
memcpy memcpy ( & UUMLMLLANYFGAMQKTNRI , SYH + HPOWWP , PJSC )
<operator>.assignmentPlus HPOWWP += PJSC
<operator>.assignment PJSC = sizeof ( JKFUHNL )
memcpy memcpy ( & BBAPXWHNICRGWE , SYH + HPOWWP , PJSC )
<operator>.assignmentPlus HPOWWP += PJSC
<operator>.assignment PJSC = sizeof ( JKFUHNL )
memcpy memcpy ( & RLQENEFTNGIESDT , SYH + HPOWWP , PJSC )
<operator>.assignmentPlus HPOWWP += PJSC
<operator>.assignment PJSC = 521 * sizeof ( NNUONMNK )
memcpy memcpy ( VDTXVCWATJSX , SYH + HPOWWP , PJSC )
<operator>.assignmentPlus HPOWWP += PJSC
RETURN return ; return ;
<operator>.sizeOf sizeof ( YANAND )
<operator>.addition SYH + HPOWWP
<operator>.addition SYH + HPOWWP
<operator>.sizeOf sizeof ( JKFUHNL )
<operator>.addition SYH + HPOWWP
<operator>.multiplication 521 * sizeof ( NNUONMNK )
<operator>.addition SYH + HPOWWP
<operator>.sizeOf sizeof ( NNUONMNK )
>>>PDG&25 0->2 0->3 0->5 0->6 0->8 0->9 0->11 0->12 0->14 0->15 0->16 0->18 0->19 0->21 0->22 0->23 2->5 2->8 2->11 2->14 2->18 2->19 2->21 2->23 3->1 3->5 3->6 3->18 4->1 4->5 5->1 5->1 5->6 6->8 6->9 6->19 7->8 8->1 8->1 8->9 9->11 9->12 9->21 10->1 10->11 11->1 11->1 11->12 12->14 12->15 12->23 13->1 13->1 13->14 14->1 14->1 14->1 14->15 15->1 15->1 15->1 16->1 17->1 20->1 22->13 23->1 24->1
>>>Token void NFBSLBKJCKOQ ( YANAND * SYH ) { JKFUHNL HPOWWP , PJSC ; HPOWWP = 0 ; PJSC = sizeof ( YANAND ) ; memcpy ( & UUMLMLLANYFGAMQKTNRI , SYH + HPOWWP , PJSC ) ; HPOWWP += PJSC ; PJSC = sizeof ( JKFUHNL ) ; memcpy ( & BBAPXWHNICRGWE , SYH + HPOWWP , PJSC ) ; HPOWWP += PJSC ; PJSC = sizeof ( JKFUHNL ) ; memcpy ( & RLQENEFTNGIESDT , SYH + HPOWWP , PJSC ) ; HPOWWP += PJSC ; PJSC = 521 * sizeof ( NNUONMNK ) ; memcpy ( VDTXVCWATJSX , SYH + HPOWWP , PJSC ) ; HPOWWP += PJSC ; return ; }
>>>Func
METHOD main
METHOD_RETURN int
srand srand ( time ( NULL ) )
QCHA QCHA ( )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
time time ( NULL )
>>>PDG&7 0->3 0->4 0->5 0->6 2->1 2->1 3->1 4->1 5->4 6->1 6->2
>>>Token int main ( ) { srand ( time ( NULL ) ) ; QCHA ( ) ; return 0 ; }
>>>Func
