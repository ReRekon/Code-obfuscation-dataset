METHOD copy_rest
METHOD_RETURN int
PARAM FILE * f
PARAM int c
<operator>.assignment out_column = 0
RETURN return c ; return c ;
<operator>.logicalOr in_column > next_prefix_indent || ( c != '\n' && c != EOF )
<operator>.logicalAnd c != '\n' && c != EOF
IDENTIFIER c return c ;
put_space put_space ( next_prefix_indent )
putchar putchar ( c )
<operator>.assignment c = getc ( f )
<operator>.greaterThan in_column > next_prefix_indent
<operator>.logicalAnd c != '\n' && c != EOF
<operator>.logicalAnd out_column != in_column && * s
<operator>.postIncrement out_column ++
putchar putchar ( * s ++ )
<operator>.logicalAnd c != EOF && c != '\n'
<operator>.logicalAnd c == EOF && in_column >= next_prefix_indent + prefix_length
<operator>.notEquals c != '\n'
<operator>.notEquals c != EOF
<operator>.notEquals c != '\n'
<operator>.notEquals c != EOF
<operator>.assignment s = prefix
put_space put_space ( in_column - out_column )
putchar putchar ( '\n' )
getc getc ( f )
<operator>.notEquals out_column != in_column
<operator>.notEquals c != EOF
<operator>.notEquals c != '\n'
<operator>.equals c == EOF
<operator>.greaterEqualsThan in_column >= next_prefix_indent + prefix_length
<operator>.postIncrement s ++
<operator>.subtraction in_column - out_column
<operator>.addition next_prefix_indent + prefix_length
<operator>.indirection * s
<operator>.indirection * s ++
>>>PDG&37 0->2 0->3 0->4 0->8 0->9 0->10 0->12 0->15 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 2->1 2->26 3->19 3->21 3->28 4->1 4->1 4->27 5->1 6->1 6->1 6->9 6->14 6->17 6->18 6->23 6->27 6->28 6->30 7->1 7->1 7->1 7->7 7->10 7->11 7->19 7->26 8->5 9->1 9->1 9->31 9->34 10->1 11->1 11->19 12->1 12->1 12->6 12->6 12->9 12->13 12->21 12->27 13->6 13->6 13->7 13->17 14->1 14->1 14->1 14->14 14->15 14->16 14->27 14->32 14->32 14->36 15->1 15->27 16->1 16->1 17->1 17->7 17->24 17->33 18->1 18->1 18->1 18->25 19->1 19->7 19->7 19->8 19->10 19->20 19->20 20->1 20->1 20->7 20->7 20->8 20->10 21->13 21->13 21->19 21->22 21->22 21->28 22->1 22->13 22->13 22->19 22->20 22->28 22->28 23->1 23->1 23->1 23->32 24->1 24->1 25->1 26->1 26->11 27->1 27->1 27->14 27->14 27->15 27->31 27->33 27->33 27->35 28->17 28->17 28->29 28->29 28->30 28->30 29->17 29->17 29->30 30->1 30->18 30->18 30->19 30->20 30->31 30->34 31->1 31->1 31->18 31->18 32->1 33->1 33->1 33->24 33->24 33->31 34->1 34->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static int copy_rest ( FILE * f , int c ) { char const * s ; out_column = 0 ; if ( in_column > next_prefix_indent || ( c != '\n' && c != EOF ) ) { put_space ( next_prefix_indent ) ; for ( s = prefix ; out_column != in_column && * s ; out_column ++ ) putchar ( * s ++ ) ; if ( c != EOF && c != '\n' ) put_space ( in_column - out_column ) ; if ( c == EOF && in_column >= next_prefix_indent + prefix_length ) putchar ( '\n' ) ; } while ( c != '\n' && c != EOF ) { putchar ( c ) ; c = getc ( f ) ; } return c ; }
>>>Func
METHOD fsqr
METHOD_RETURN double
PARAM double x
RETURN return x * x ; return x * x ;
<operator>.multiplication x * x
>>>PDG&5 0->2 0->4 2->4 3->1 4->1 4->1 4->3
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) inline static double fsqr ( double x ) { return x * x ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan t < T
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 0
scanf scanf ( "%d\n" , & N )
printf printf ( "Case #%d:\n" , t + 1 )
<operator>.lessThan i < 100
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment WP [ i ] . total = 0
<operator>.assignment WP [ i ] . win = 0
<operator>.assignment OWP [ i ] = 0
<operator>.assignment OOWP [ i ] = 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment total = 0
<operator>.assignment OWP [ i ] = OWP [ i ] / total
<operator>.assignment i = 0
<operator>.assignment total = 0
<operator>.assignment OOWP [ i ] = OOWP [ i ] / total
<operator>.addition t + 1
<operator>.assignment i = 0
<operator>.assignment RIP [ i ] = 0.25 * ( ( long double ) WP [ i ] . win / WP [ i ] . total ) + 0.5 * ( OWP [ i ] ) + 0.25 * ( OOWP [ i ] )
printf printf ( "%.8Lf\n" , RIP [ i ] )
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.assignment j = 0
scanf scanf ( "%c" , & aux )
<operator>.assignment j = 0
<operator>.division OWP [ i ] / total
<operator>.assignment j = 0
<operator>.division OOWP [ i ] / total
<operator>.addition 0.25 * ( ( long double ) WP [ i ] . win / WP [ i ] . total ) + 0.5 * ( OWP [ i ] ) + 0.25 * ( OOWP [ i ] )
<operator>.equals aux == '1'
<operator>.equals aux == '0'
<operator>.equals aux == '.'
<operator>.notEquals result [ i ] [ j ] != - 1
<operator>.notEquals result [ i ] [ j ] != - 1
<operator>.addition 0.25 * ( ( long double ) WP [ i ] . win / WP [ i ] . total ) + 0.5 * ( OWP [ i ] )
<operator>.multiplication 0.25 * ( OOWP [ i ] )
<operator>.assignment result [ i ] [ j ] = 1
<operator>.postIncrement WP [ i ] . total ++
<operator>.postIncrement WP [ i ] . win ++
<operator>.assignment result [ i ] [ j ] = 0
<operator>.postIncrement WP [ i ] . total ++
<operator>.assignment result [ i ] [ j ] = - 1
<operator>.postIncrement total ++
<operator>.postIncrement total ++
<operator>.assignmentPlus OOWP [ i ] += OWP [ j ]
<operator>.multiplication 0.25 * ( ( long double ) WP [ i ] . win / WP [ i ] . total )
<operator>.multiplication 0.5 * ( OWP [ i ] )
<operator>.minus - 1
<operator>.equals result [ i ] [ j ] == 1
<operator>.minus - 1
<operator>.division ( long double ) WP [ i ] . win / WP [ i ] . total
<operator>.minus - 1
<operator>.assignmentPlus OWP [ i ] += ( ( double ) WP [ j ] . win / ( WP [ j ] . total - 1 ) )
<operator>.assignmentPlus OWP [ i ] += ( ( double ) ( WP [ j ] . win - 1 ) / ( WP [ j ] . total - 1 ) )
<operator>.division ( double ) WP [ j ] . win / ( WP [ j ] . total - 1 )
<operator>.subtraction WP [ j ] . total - 1
<operator>.division ( double ) ( WP [ j ] . win - 1 ) / ( WP [ j ] . total - 1 )
<operator>.cast ( double ) ( WP [ j ] . win - 1 )
<operator>.subtraction WP [ j ] . total - 1
<operator>.subtraction WP [ j ] . win - 1
<operator>.addressOf & N
scanf scanf ( " " )
<operator>.fieldAccess WP [ i ] . total
<operator>.fieldAccess WP [ i ] . win
<operator>.indirectIndexAccess OWP [ i ]
<operator>.indirectIndexAccess OOWP [ i ]
<operator>.indirectIndexAccess OWP [ i ]
<operator>.indirectIndexAccess OOWP [ i ]
<operator>.indirectIndexAccess RIP [ i ]
<operator>.indirectIndexAccess RIP [ i ]
<operator>.indirectIndexAccess WP [ i ]
FIELD_IDENTIFIER total total
<operator>.indirectIndexAccess WP [ i ]
FIELD_IDENTIFIER win win
<operator>.indirectIndexAccess OWP [ i ]
<operator>.indirectIndexAccess OOWP [ i ]
<operator>.addressOf & aux
<operator>.indirectIndexAccess OOWP [ i ]
<operator>.indirectIndexAccess result [ i ] [ j ]
<operator>.indirectIndexAccess result [ i ] [ j ]
<operator>.indirectIndexAccess OWP [ i ]
<operator>.indirectIndexAccess result [ i ] [ j ]
<operator>.fieldAccess WP [ i ] . total
<operator>.fieldAccess WP [ i ] . win
<operator>.indirectIndexAccess result [ i ] [ j ]
<operator>.fieldAccess WP [ i ] . total
<operator>.indirectIndexAccess result [ i ] [ j ]
<operator>.indirectIndexAccess result [ i ]
<operator>.indirectIndexAccess result [ i ]
<operator>.indirectIndexAccess OOWP [ i ]
<operator>.indirectIndexAccess OWP [ j ]
<operator>.cast ( long double ) WP [ i ] . win
<operator>.fieldAccess WP [ i ] . total
<operator>.indirectIndexAccess result [ i ]
<operator>.indirectIndexAccess WP [ i ]
FIELD_IDENTIFIER total total
<operator>.indirectIndexAccess WP [ i ]
FIELD_IDENTIFIER win win
<operator>.indirectIndexAccess result [ i ]
<operator>.indirectIndexAccess WP [ i ]
FIELD_IDENTIFIER total total
<operator>.indirectIndexAccess result [ i ]
<operator>.indirectIndexAccess result [ i ] [ j ]
UNKNOWN long double long double
<operator>.fieldAccess WP [ i ] . win
<operator>.indirectIndexAccess WP [ i ]
FIELD_IDENTIFIER total total
<operator>.indirectIndexAccess result [ i ]
<operator>.indirectIndexAccess OWP [ i ]
<operator>.indirectIndexAccess WP [ i ]
FIELD_IDENTIFIER win win
<operator>.cast ( double ) WP [ j ] . win
<operator>.indirectIndexAccess OWP [ i ]
UNKNOWN double double
<operator>.fieldAccess WP [ j ] . win
<operator>.fieldAccess WP [ j ] . total
<operator>.indirectIndexAccess WP [ j ]
FIELD_IDENTIFIER win win
<operator>.indirectIndexAccess WP [ j ]
FIELD_IDENTIFIER total total
UNKNOWN double double
<operator>.fieldAccess WP [ j ] . total
<operator>.fieldAccess WP [ j ] . win
<operator>.indirectIndexAccess WP [ j ]
FIELD_IDENTIFIER total total
<operator>.indirectIndexAccess WP [ j ]
FIELD_IDENTIFIER win win
>>>PDG&147 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->49 0->50 0->51 0->55 0->56 0->59 0->62 0->63 0->65 0->66 0->67 0->68 0->69 0->71 0->75 0->78 0->79 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->9 4->10 4->12 4->14 4->16 4->18 4->20 4->25 4->26 4->29 4->32 4->32 4->33 4->80 5->1 5->4 6->3 7->1 7->4 8->1 8->12 8->14 8->16 8->18 8->36 8->38 8->40 9->1 9->1 10->1 10->10 10->11 10->11 10->21 10->22 10->23 10->24 10->82 10->83 10->84 10->85 10->90 10->91 10->92 10->93 11->1 11->10 12->12 12->13 12->13 12->14 12->36 12->36 12->42 12->81 13->1 13->12 14->14 14->15 14->15 14->16 14->27 14->28 14->38 14->38 14->44 14->45 14->86 14->94 15->1 15->14 16->16 16->17 16->17 16->18 16->30 16->31 16->40 16->40 16->46 16->47 16->87 16->95 17->1 17->16 18->1 18->1 18->1 18->8 18->12 18->18 18->19 18->19 18->34 18->35 18->48 18->54 18->55 18->65 18->66 18->70 18->88 18->89 18->97 18->100 18->111 18->112 18->123 18->124 18->125 18->126 18->129 18->130 19->1 19->18 20->10 21->1 22->1 23->1 23->1 23->45 23->66 23->72 23->73 24->1 24->1 24->47 24->55 24->64 25->12 26->14 27->1 27->45 27->62 28->1 28->1 28->1 28->45 28->66 28->72 28->73 29->16 30->1 30->47 30->63 31->1 31->1 31->1 31->47 31->55 31->64 33->1 33->18 34->1 34->1 34->35 35->1 35->1 36->1 36->1 36->12 36->36 36->37 36->37 36->43 36->49 36->50 36->51 36->96 37->1 37->36 38->1 38->1 38->14 38->38 38->39 38->39 38->52 38->67 38->98 38->107 39->1 39->38 40->1 40->1 40->16 40->40 40->41 40->41 40->53 40->69 40->99 40->108 41->1 41->40 42->1 42->36 43->1 43->49 43->50 43->51 44->1 44->38 45->1 45->28 45->28 46->1 46->40 47->1 47->31 47->31 48->1 48->1 49->1 49->50 49->56 49->57 49->58 49->101 49->102 49->103 49->113 49->114 49->115 49->116 49->117 50->1 50->51 50->59 50->60 50->104 50->105 50->118 50->119 50->120 51->1 51->1 51->43 51->49 51->61 51->71 51->106 51->121 52->1 52->1 52->1 52->53 52->62 52->68 52->68 52->122 52->127 53->1 53->1 53->1 53->52 53->63 53->64 53->109 53->110 54->1 54->1 55->1 55->34 55->34 55->47 55->48 55->48 55->64 56->1 56->1 56->52 56->53 57->1 57->60 58->1 59->1 59->1 59->52 59->53 60->1 60->57 61->1 61->1 61->1 61->52 61->53 62->1 62->45 63->1 63->47 64->1 64->1 64->47 65->1 65->34 65->34 65->48 65->48 65->54 65->54 66->1 66->34 66->34 66->45 66->48 66->48 66->54 66->54 66->72 66->73 67->52 68->1 68->1 68->52 68->53 68->72 68->73 68->74 68->75 68->76 68->77 68->78 68->79 68->128 68->131 68->132 68->133 68->134 68->135 68->136 68->137 68->138 68->139 68->140 68->141 68->142 68->143 68->144 68->145 68->146 69->53 70->1 70->65 70->65 71->61 72->1 72->1 72->45 72->73 73->1 73->1 73->45 73->72 74->1 74->1 74->72 74->72 75->74 75->74 76->1 76->1 76->73 76->73 77->1 78->76 78->76 79->76 79->76 79->77 79->77
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int i , j ; int t , T ; int N ; int total ; char aux ; scanf ( "\x25\x64\x0" , & T ) ; for ( t = 0 ; t < T ; t ++ ) { for ( i = 0 ; i < 100 ; i ++ ) { WP [ i ] . total = 0 ; WP [ i ] . win = 0 ; OWP [ i ] = 0 ; OOWP [ i ] = 0 ; } scanf ( "%d\n" , & N ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { scanf ( "%c" , & aux ) ; if ( aux == '1' ) { result [ i ] [ j ] = 1 ; WP [ i ] . total ++ ; WP [ i ] . win ++ ; } if ( aux == '0' ) { result [ i ] [ j ] = 0 ; WP [ i ] . total ++ ; } if ( aux == '.' ) result [ i ] [ j ] = - 1 ; } scanf ( " " ) ; } for ( i = 0 ; i < N ; i ++ ) { total = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( result [ i ] [ j ] != - 1 ) { total ++ ; if ( result [ i ] [ j ] == 1 ) OWP [ i ] += ( ( double ) WP [ j ] . win / ( WP [ j ] . total - 1 ) ) ; else OWP [ i ] += ( ( double ) ( WP [ j ] . win - 1 ) / ( WP [ j ] . total - 1 ) ) ; } } OWP [ i ] = OWP [ i ] / total ; } for ( i = 0 ; i < N ; i ++ ) { total = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( result [ i ] [ j ] != - 1 ) { total ++ ; OOWP [ i ] += OWP [ j ] ; } } OOWP [ i ] = OOWP [ i ] / total ; } printf ( "Case #%d:\n" , t + 1 ) ; for ( i = 0 ; i < N ; i ++ ) { RIP [ i ] = 0.25 * ( ( long double ) WP [ i ] . win / WP [ i ] . total ) + 0.5 * ( OWP [ i ] ) + 0.25 * ( OOWP [ i ] ) ; printf ( "%.8Lf\n" , RIP [ i ] ) ; } } return 0 ; }
>>>Func
METHOD find
METHOD_RETURN int
PARAM struct subset subsets [ ]
PARAM int i
RETURN return subsets [ i ] . parent ; return subsets [ i ] . parent ;
<operator>.notEquals subsets [ i ] . parent != i
<operator>.assignment subsets [ i ] . parent = find ( subsets , subsets [ i ] . parent )
find find ( subsets , subsets [ i ] . parent )
<operator>.fieldAccess subsets [ i ] . parent
<operator>.indirectIndexAccess subsets [ i ]
FIELD_IDENTIFIER parent parent
<operator>.fieldAccess subsets [ i ] . parent
<operator>.indirectIndexAccess subsets [ i ]
FIELD_IDENTIFIER parent parent
>>>PDG&14 0->2 0->3 0->5 0->7 2->1 2->7 3->5 4->1 5->1 5->1 5->1 5->6 5->7 5->7 5->8 5->9 5->10 5->11 5->12 5->13 6->1 6->1 6->1 7->1 7->6 7->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int find ( struct subset subsets [ ] , int i ) { if ( subsets [ i ] . parent != i ) subsets [ i ] . parent = find ( subsets , subsets [ i ] . parent ) ; return subsets [ i ] . parent ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & notc )
RETURN return 0 ; return 0 ;
<operator>.lessThan nc < notc
<operator>.postIncrement nc ++
LITERAL 0 return 0 ;
<operator>.assignment nc = 0
scanf scanf ( "%lld %lld %lld" , & n , & pd , & pg )
<operator>.assignment mind = 100 / gcd ( 100 , pd )
<operator>.assignment ming = 100 / gcd ( 100 , pg )
<operator>.assignment wd = pd / gcd ( 100 , pd )
<operator>.assignment wg = pg / gcd ( 100 , pd )
<operator>.assignment mgame = ming
<operator>.assignment i = 1
<operator>.assignment minl = mind - wd
<operator>.lessEqualsThan mind <= n
<operator>.division 100 / gcd ( 100 , pd )
<operator>.division 100 / gcd ( 100 , pg )
<operator>.division pd / gcd ( 100 , pd )
<operator>.division pg / gcd ( 100 , pd )
<operator>.subtraction mind - wd
gcd gcd ( 100 , pd )
gcd gcd ( 100 , pg )
gcd gcd ( 100 , pd )
gcd gcd ( 100 , pd )
<operator>.equals pd == pg
printf printf ( "Case #%d: %s\n" , nc + 1 , "Broken" )
printf printf ( "Case #%d: %s\n" , nc + 1 , "Possible" )
<operator>.addition nc + 1
<operator>.addition nc + 1
<operator>.logicalOr pg == 100 || pg == 0
printf printf ( "Case #%d: %s\n" , nc + 1 , "Broken" )
<operator>.equals pg == 100
<operator>.equals pg == 0
printf printf ( "Case #%d: %s\n" , nc + 1 , "Possible" )
<operator>.addition nc + 1
<operator>.addition nc + 1
<operator>.addressOf & n
<operator>.addressOf & pd
<operator>.addressOf & pg
>>>PDG&41 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->34 0->35 0->36 0->37 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->18 4->19 4->20 4->21 4->22 4->23 4->24 4->25 4->27 4->28 4->29 4->30 4->32 4->35 4->36 4->37 4->38 4->39 4->40 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->16 9->1 9->1 9->21 10->1 10->1 10->13 11->1 11->1 11->21 12->1 12->1 12->1 13->1 13->1 13->1 14->1 14->1 15->1 15->1 15->1 16->1 16->1 16->1 16->8 16->26 16->27 16->29 17->9 17->9 18->1 18->10 18->10 19->11 19->11 19->25 20->1 20->1 20->12 20->12 20->23 20->26 21->1 21->15 21->15 21->16 22->17 22->17 22->24 23->18 23->18 23->20 24->19 24->19 25->1 25->20 25->20 25->22 25->26 26->1 26->1 26->1 26->22 26->23 26->28 26->30 26->31 26->33 26->33 27->1 27->1 28->1 28->1 31->1 31->1 31->1 31->32 31->35 31->36 31->37 32->1 32->1 33->1 33->23 33->31 33->31 33->34 33->34 34->1 34->23 34->31 34->31 35->1 35->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int notc , nc ; int i , j ; scanf ( "\x25\x64\x0" , & notc ) ; for ( nc = 0 ; nc < notc ; nc ++ ) { LD n , pd , pg ; scanf ( "%lld %lld %lld" , & n , & pd , & pg ) ; LD mind = 100 / gcd ( 100 , pd ) ; LD ming = 100 / gcd ( 100 , pg ) ; LD wd = pd / gcd ( 100 , pd ) ; LD wg = pg / gcd ( 100 , pd ) ; LD mgame = ming ; LD i = 1 ; LD minl = mind - wd ; if ( mind <= n ) { if ( pd == pg ) printf ( "Case #%d: %s\n" , nc + 1 , "Possible" ) ; else if ( pg == 100 || pg == 0 ) printf ( "Case #%d: %s\n" , nc + 1 , "Broken" ) ; else printf ( "Case #%d: %s\n" , nc + 1 , "Possible" ) ; } else printf ( "Case #%d: %s\n" , nc + 1 , "Broken" ) ; } return 0 ; }
>>>Func
METHOD solve
METHOD_RETURN void
<operator>.assignment nlen = 0
<operator>.assignment res = 1
IDENTIFIER res while (res)
<operator>.assignment res = solve3 ( )
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 2->1 3->1 3->1 5->1 5->1 5->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void solve ( ) { int i ; int nlen = 0 ; int res = 1 ; while ( res ) { res = solve3 ( ) ; } }
>>>Func
METHOD hasPathSum
METHOD_RETURN bool
PARAM struct TreeNode * root
PARAM int sum
RETURN return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ) ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ) ;
<operator>.equals root == NULL
<operator>.logicalAnd ! root -> left && ! root -> right && sum - root -> val == 0
<operator>.logicalOr hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val )
RETURN return 0 ; return 0 ;
RETURN return 1 ; return 1 ;
LITERAL 0 return 0 ;
<operator>.logicalAnd ! root -> left && ! root -> right
<operator>.equals sum - root -> val == 0
LITERAL 1 return 1 ;
hasPathSum hasPathSum ( root -> left , sum - root -> val )
hasPathSum hasPathSum ( root -> right , sum - root -> val )
<operator>.logicalNot ! root -> left
<operator>.logicalNot ! root -> right
<operator>.subtraction sum - root -> val
<operator>.subtraction sum - root -> val
<operator>.subtraction sum - root -> val
<operator>.indirectFieldAccess root -> left
<operator>.indirectFieldAccess root -> right
<operator>.indirectFieldAccess root -> left
<operator>.indirectFieldAccess root -> right
<operator>.indirectFieldAccess root -> val
FIELD_IDENTIFIER left left
<operator>.indirectFieldAccess root -> val
FIELD_IDENTIFIER right right
<operator>.indirectFieldAccess root -> val
FIELD_IDENTIFIER left left
FIELD_IDENTIFIER right right
FIELD_IDENTIFIER val val
FIELD_IDENTIFIER val val
FIELD_IDENTIFIER val val
>>>PDG&35 0->2 0->3 0->5 0->8 0->9 0->10 0->12 0->13 0->18 0->19 0->20 2->5 3->1 3->18 3->19 4->1 5->1 5->1 5->1 5->6 5->8 5->11 5->16 5->23 5->30 6->4 6->7 6->9 6->14 6->19 6->21 6->26 6->27 6->33 7->4 8->1 9->1 10->8 11->6 11->6 11->12 11->18 11->25 11->32 12->6 12->6 13->9 14->7 14->7 14->15 14->20 14->22 14->28 14->29 14->34 15->7 15->7 16->11 16->14 16->17 16->24 16->31 17->11 17->15 18->12 18->12 18->19 18->19 19->14 19->14 19->20 19->20 20->15 20->15
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) bool hasPathSum ( struct TreeNode * root , int sum ) { if ( root == NULL ) return 0 ; if ( ! root -> left && ! root -> right && sum - root -> val == 0 ) return 1 ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment i = 0
printf printf ( "\x45\x6e\x74\x65\x72\x20\x61\x6e\x79\x20\x68\x65\x78\x61\x64\x65\x63\x69\x6d\x61\x6c\x20\x6e\x75\x6d\x62\x65\x72\x3a\x20\x0" )
fgets fgets ( hex , MAX_STR_LEN , stdin )
<operator>.assignment octal = 0ll
<operator>.assignment bin = 0ll
<operator>.assignment place = 0ll
<operator>.assignment place = 1
printf printf ( "Hexadecimal number = %s\n" , hex )
printf printf ( "Octal number = %lld" , octal )
RETURN return 0 ; return 0 ;
<operator>.notEquals hex [ i ] != '\0'
<operator>.postIncrement i ++
<operator>.greaterThan bin > 0
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.assignment bin = bin * place
<operator>.assignment place = 10000
<operator>.assignment rem = bin % 1000
<operator>.assignment octal = ( val * place ) + octal
<operator>.assignmentDivision bin /= 1000
<operator>.assignmentMultiplication place *= 10
IDENTIFIER rem switch(rem)
<operator>.multiplication bin * place
LITERAL '0' <empty>
<operator>.assignmentPlus bin += 0
LITERAL '1' <empty>
<operator>.assignmentPlus bin += 1
LITERAL '2' <empty>
<operator>.assignmentPlus bin += 10
LITERAL '3' <empty>
<operator>.assignmentPlus bin += 11
LITERAL '4' <empty>
<operator>.assignmentPlus bin += 100
LITERAL '5' <empty>
<operator>.assignmentPlus bin += 101
LITERAL '6' <empty>
<operator>.assignmentPlus bin += 110
LITERAL '7' <empty>
<operator>.assignmentPlus bin += 111
LITERAL '8' <empty>
<operator>.assignmentPlus bin += 1000
LITERAL '9' <empty>
<operator>.assignmentPlus bin += 1001
LITERAL 'a' <empty>
LITERAL 'A' <empty>
<operator>.assignmentPlus bin += 1010
LITERAL 'b' <empty>
LITERAL 'B' <empty>
<operator>.assignmentPlus bin += 1011
LITERAL 'c' <empty>
LITERAL 'C' <empty>
<operator>.assignmentPlus bin += 1100
LITERAL 'd' <empty>
LITERAL 'D' <empty>
<operator>.assignmentPlus bin += 1101
LITERAL 'e' <empty>
LITERAL 'E' <empty>
<operator>.assignmentPlus bin += 1110
LITERAL 'f' <empty>
LITERAL 'F' <empty>
<operator>.assignmentPlus bin += 1111
printf printf ( "Invalid hexadecimal input." )
<operator>.modulo bin % 1000
LITERAL 0 <empty>
<operator>.assignment val = 0
LITERAL 1 <empty>
<operator>.assignment val = 1
LITERAL 10 <empty>
<operator>.assignment val = 2
LITERAL 11 <empty>
<operator>.assignment val = 3
LITERAL 100 <empty>
<operator>.assignment val = 4
LITERAL 101 <empty>
<operator>.assignment val = 5
LITERAL 110 <empty>
<operator>.assignment val = 6
LITERAL 111 <empty>
<operator>.assignment val = 7
<operator>.addition ( val * place ) + octal
<operator>.multiplication val * place
<operator>.indirectIndexAccess hex [ i ]
<operator>.indirectIndexAccess hex [ i ]
>>>PDG&85 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 3->1 4->1 4->1 4->1 4->9 4->12 5->1 5->10 5->20 5->81 6->1 6->14 6->24 7->1 7->24 8->1 8->1 8->82 9->1 9->1 10->1 10->1 11->1 12->1 12->1 12->9 12->12 12->13 12->17 12->18 12->24 12->83 12->84 13->1 13->1 14->1 14->1 14->14 14->19 14->20 14->21 14->22 14->64 14->64 14->66 14->68 14->70 14->72 14->74 14->76 14->78 14->80 14->81 14->82 15->11 16->1 16->1 16->13 17->1 17->1 17->14 17->24 17->26 17->28 17->30 17->32 17->34 17->36 17->38 17->40 17->42 17->44 17->47 17->50 17->53 17->56 17->59 17->62 18->1 18->24 19->1 19->1 19->1 20->1 20->1 20->10 20->81 21->1 21->14 22->1 22->1 22->82 24->17 24->17 26->1 26->14 26->24 28->1 28->14 28->24 30->1 30->14 30->24 32->1 32->14 32->24 34->1 34->14 34->24 36->1 36->14 36->24 38->1 38->14 38->24 40->1 40->14 40->24 42->1 42->14 42->24 44->1 44->14 44->24 47->1 47->14 47->24 50->1 50->14 50->24 53->1 53->14 53->24 56->1 56->14 56->24 59->1 59->14 59->24 62->1 62->14 62->24 63->1 64->19 64->19 64->21 66->1 66->82 68->1 68->82 70->1 70->82 72->1 72->82 74->1 74->82 76->1 76->82 78->1 78->82 80->1 80->82 81->1 82->1 82->20 82->20 82->22 82->81 82->81 84->26 84->28 84->30 84->32 84->34 84->36 84->38 84->40 84->42 84->44 84->47 84->50 84->53 84->56 84->59 84->62 84->63
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { char hex [ MAX_STR_LEN ] ; long long octal , bin , place ; int i = 0 , rem , val ; printf ( "\x45\x6e\x74\x65\x72\x20\x61\x6e\x79\x20\x68\x65\x78\x61\x64\x65\x63\x69\x6d\x61\x6c\x20\x6e\x75\x6d\x62\x65\x72\x3a\x20\x0" ) ; fgets ( hex , MAX_STR_LEN , stdin ) ; octal = 0ll ; bin = 0ll ; place = 0ll ; for ( i = 0 ; hex [ i ] != '\0' ; i ++ ) { bin = bin * place ; switch ( hex [ i ] ) { case '0' : bin += 0 ; break ; case '1' : bin += 1 ; break ; case '2' : bin += 10 ; break ; case '3' : bin += 11 ; break ; case '4' : bin += 100 ; break ; case '5' : bin += 101 ; break ; case '6' : bin += 110 ; break ; case '7' : bin += 111 ; break ; case '8' : bin += 1000 ; break ; case '9' : bin += 1001 ; break ; case 'a' : case 'A' : bin += 1010 ; break ; case 'b' : case 'B' : bin += 1011 ; break ; case 'c' : case 'C' : bin += 1100 ; break ; case 'd' : case 'D' : bin += 1101 ; break ; case 'e' : case 'E' : bin += 1110 ; break ; case 'f' : case 'F' : bin += 1111 ; break ; default : printf ( "Invalid hexadecimal input." ) ; } place = 10000 ; } place = 1 ; while ( bin > 0 ) { rem = bin % 1000 ; switch ( rem ) { case 0 : val = 0 ; break ; case 1 : val = 1 ; break ; case 10 : val = 2 ; break ; case 11 : val = 3 ; break ; case 100 : val = 4 ; break ; case 101 : val = 5 ; break ; case 110 : val = 6 ; break ; case 111 : val = 7 ; break ; } octal = ( val * place ) + octal ; bin /= 1000 ; place *= 10 ; } printf ( "Hexadecimal number = %s\n" , hex ) ; printf ( "Octal number = %lld" , octal ) ; return 0 ; }
>>>Func
METHOD invoke
METHOD_RETURN int
PARAM Case * c
<operator>.assignment wordpos = 0
<operator>.assignment i = 0
<operator>.assignment combined = 0
<operator>.assignment c -> nwordCount = 0
<operator>.assignment c -> nwordCount = add ( c -> nword , c -> nwordCount , c -> word [ wordpos ] )
<operator>.postIncrement wordpos ++
RETURN return 1 ; return 1 ;
<operator>.equals c -> wordCount == 1
<operator>.lessThan wordpos < c -> wordCount
LITERAL 1 return 1 ;
<operator>.assignment c -> nword [ 0 ] = c -> word [ 0 ]
<operator>.assignment c -> nwordCount = 1
RETURN return 1 ; return 1 ;
add add ( c -> nword , c -> nwordCount , c -> word [ wordpos ] )
<operator>.assignment c -> nwordCount = add ( c -> nword , c -> nwordCount , c -> word [ wordpos ] )
<operator>.assignment combined = 0
<operator>.postIncrement wordpos ++
LITERAL 1 return 1 ;
<operator>.lessThan i < c -> combineCount
<operator>.postIncrement i ++
<operator>.logicalNot ! combined
add add ( c -> nword , c -> nwordCount , c -> word [ wordpos ] )
<operator>.assignment i = 0
<operator>.logicalOr ( c -> nword [ c -> nwordCount - 1 ] == c -> Combine [ i ] . ele1 && c -> nword [ c -> nwordCount - 2 ] == c -> Combine [ i ] . ele2 ) || ( c -> nword [ c -> nwordCount - 1 ] == c -> Combine [ i ] . ele2 && c -> nword [ c -> nwordCount - 2 ] == c -> Combine [ i ] . ele1 )
<operator>.lessThan i < c -> repulseCount
<operator>.postIncrement i ++
<operator>.postDecrement c -> nwordCount --
<operator>.assignment c -> nword [ c -> nwordCount - 1 ] = c -> Combine [ i ] . nele
<operator>.assignment combined = 1
<operator>.assignment i = 0
<operator>.logicalAnd c -> nword [ c -> nwordCount - 1 ] == c -> Combine [ i ] . ele1 && c -> nword [ c -> nwordCount - 2 ] == c -> Combine [ i ] . ele2
<operator>.logicalAnd c -> nword [ c -> nwordCount - 1 ] == c -> Combine [ i ] . ele2 && c -> nword [ c -> nwordCount - 2 ] == c -> Combine [ i ] . ele1
<operator>.logicalAnd contain ( c -> nword , c -> nwordCount , c -> Repulse [ i ] . ele1 ) && contain ( c -> nword , c -> nwordCount , c -> Repulse [ i ] . ele2 )
<operator>.equals c -> nword [ c -> nwordCount - 1 ] == c -> Combine [ i ] . ele1
<operator>.equals c -> nword [ c -> nwordCount - 2 ] == c -> Combine [ i ] . ele2
<operator>.equals c -> nword [ c -> nwordCount - 1 ] == c -> Combine [ i ] . ele2
<operator>.equals c -> nword [ c -> nwordCount - 2 ] == c -> Combine [ i ] . ele1
<operator>.assignment c -> nwordCount = 0
<operator>.subtraction c -> nwordCount - 1
contain contain ( c -> nword , c -> nwordCount , c -> Repulse [ i ] . ele1 )
contain contain ( c -> nword , c -> nwordCount , c -> Repulse [ i ] . ele2 )
<operator>.subtraction c -> nwordCount - 1
<operator>.subtraction c -> nwordCount - 2
<operator>.subtraction c -> nwordCount - 1
<operator>.subtraction c -> nwordCount - 2
<operator>.indirectFieldAccess c -> nwordCount
<operator>.indirectFieldAccess c -> nwordCount
FIELD_IDENTIFIER nwordCount nwordCount
FIELD_IDENTIFIER nwordCount nwordCount
<operator>.indirectFieldAccess c -> nword
<operator>.indirectFieldAccess c -> nwordCount
<operator>.indirectIndexAccess c -> word [ wordpos ]
<operator>.indirectFieldAccess c -> wordCount
<operator>.indirectIndexAccess c -> nword [ 0 ]
<operator>.indirectIndexAccess c -> word [ 0 ]
<operator>.indirectFieldAccess c -> nwordCount
FIELD_IDENTIFIER nword nword
FIELD_IDENTIFIER nwordCount nwordCount
<operator>.indirectFieldAccess c -> word
FIELD_IDENTIFIER wordCount wordCount
<operator>.indirectFieldAccess c -> nwordCount
<operator>.indirectFieldAccess c -> nword
<operator>.indirectFieldAccess c -> word
FIELD_IDENTIFIER nwordCount nwordCount
FIELD_IDENTIFIER word word
FIELD_IDENTIFIER nwordCount nwordCount
<operator>.indirectFieldAccess c -> nword
<operator>.indirectFieldAccess c -> nwordCount
<operator>.indirectIndexAccess c -> word [ wordpos ]
<operator>.indirectFieldAccess c -> combineCount
FIELD_IDENTIFIER nword nword
FIELD_IDENTIFIER word word
FIELD_IDENTIFIER nword nword
FIELD_IDENTIFIER nwordCount nwordCount
<operator>.indirectFieldAccess c -> word
FIELD_IDENTIFIER combineCount combineCount
FIELD_IDENTIFIER word word
<operator>.indirectFieldAccess c -> repulseCount
<operator>.indirectFieldAccess c -> nwordCount
<operator>.indirectIndexAccess c -> nword [ c -> nwordCount - 1 ]
<operator>.fieldAccess c -> Combine [ i ] . nele
FIELD_IDENTIFIER repulseCount repulseCount
<operator>.indirectIndexAccess c -> nword [ c -> nwordCount - 1 ]
<operator>.fieldAccess c -> Combine [ i ] . ele1
<operator>.indirectIndexAccess c -> nword [ c -> nwordCount - 2 ]
<operator>.fieldAccess c -> Combine [ i ] . ele2
<operator>.indirectIndexAccess c -> nword [ c -> nwordCount - 1 ]
<operator>.fieldAccess c -> Combine [ i ] . ele2
<operator>.indirectIndexAccess c -> nword [ c -> nwordCount - 2 ]
<operator>.fieldAccess c -> Combine [ i ] . ele1
FIELD_IDENTIFIER nwordCount nwordCount
<operator>.indirectFieldAccess c -> nword
<operator>.indirectIndexAccess c -> Combine [ i ]
FIELD_IDENTIFIER nele nele
<operator>.indirectFieldAccess c -> nword
<operator>.indirectIndexAccess c -> Combine [ i ]
FIELD_IDENTIFIER ele1 ele1
<operator>.indirectFieldAccess c -> nword
<operator>.indirectIndexAccess c -> Combine [ i ]
FIELD_IDENTIFIER ele2 ele2
<operator>.indirectFieldAccess c -> nword
<operator>.indirectIndexAccess c -> Combine [ i ]
FIELD_IDENTIFIER ele2 ele2
<operator>.indirectFieldAccess c -> nword
<operator>.indirectIndexAccess c -> Combine [ i ]
FIELD_IDENTIFIER ele1 ele1
FIELD_IDENTIFIER nword nword
<operator>.indirectFieldAccess c -> nwordCount
<operator>.indirectFieldAccess c -> Combine
<operator>.indirectFieldAccess c -> nword
<operator>.indirectFieldAccess c -> nwordCount
<operator>.fieldAccess c -> Repulse [ i ] . ele1
<operator>.indirectFieldAccess c -> nword
<operator>.indirectFieldAccess c -> nwordCount
<operator>.fieldAccess c -> Repulse [ i ] . ele2
<operator>.indirectFieldAccess c -> nwordCount
FIELD_IDENTIFIER nword nword
<operator>.indirectFieldAccess c -> nwordCount
<operator>.indirectFieldAccess c -> Combine
FIELD_IDENTIFIER nword nword
<operator>.indirectFieldAccess c -> nwordCount
<operator>.indirectFieldAccess c -> Combine
FIELD_IDENTIFIER nword nword
<operator>.indirectFieldAccess c -> nwordCount
<operator>.indirectFieldAccess c -> Combine
FIELD_IDENTIFIER nword nword
<operator>.indirectFieldAccess c -> nwordCount
<operator>.indirectFieldAccess c -> Combine
FIELD_IDENTIFIER nwordCount nwordCount
FIELD_IDENTIFIER Combine Combine
FIELD_IDENTIFIER nword nword
FIELD_IDENTIFIER nwordCount nwordCount
<operator>.indirectIndexAccess c -> Repulse [ i ]
FIELD_IDENTIFIER ele1 ele1
FIELD_IDENTIFIER nword nword
FIELD_IDENTIFIER nwordCount nwordCount
<operator>.indirectIndexAccess c -> Repulse [ i ]
FIELD_IDENTIFIER ele2 ele2
FIELD_IDENTIFIER nwordCount nwordCount
FIELD_IDENTIFIER nwordCount nwordCount
FIELD_IDENTIFIER Combine Combine
FIELD_IDENTIFIER nwordCount nwordCount
FIELD_IDENTIFIER Combine Combine
FIELD_IDENTIFIER nwordCount nwordCount
FIELD_IDENTIFIER Combine Combine
FIELD_IDENTIFIER nwordCount nwordCount
FIELD_IDENTIFIER Combine Combine
<operator>.indirectFieldAccess c -> Repulse
<operator>.indirectFieldAccess c -> Repulse
FIELD_IDENTIFIER Repulse Repulse
FIELD_IDENTIFIER Repulse Repulse
>>>PDG&154 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->27 0->28 0->31 0->32 0->40 0->41 0->44 0->45 0->46 0->47 2->1 3->1 3->1 3->8 4->1 4->1 5->1 5->1 6->16 7->24 8->11 9->1 10->1 10->1 10->6 10->7 10->8 10->9 10->11 10->11 10->13 10->14 10->15 10->16 10->48 10->49 10->50 10->51 10->52 10->53 10->54 10->55 10->56 10->57 10->58 10->59 10->60 10->61 10->62 10->64 10->65 10->66 10->67 10->73 10->74 11->11 11->17 11->18 11->19 11->19 11->21 11->23 11->24 11->25 11->55 11->62 11->63 11->68 11->69 11->70 11->71 11->72 11->75 11->76 11->77 11->78 11->79 12->9 13->1 13->1 13->1 14->1 14->1 15->1 16->7 16->7 16->7 16->24 16->24 17->24 17->42 17->44 18->23 19->11 20->15 21->21 21->22 21->22 21->26 21->33 21->36 21->44 21->72 21->78 21->85 21->86 21->97 21->98 21->99 21->119 21->120 21->121 21->142 21->143 22->21 23->27 23->32 23->80 23->84 24->17 24->17 24->17 24->42 25->21 26->29 26->30 26->31 26->41 26->81 26->82 26->83 26->93 26->94 26->95 26->96 26->109 26->110 26->111 26->131 26->132 27->27 27->28 27->28 27->35 27->42 27->80 27->84 27->112 27->113 27->114 27->133 27->134 27->135 27->136 27->150 27->152 28->27 29->41 30->24 30->36 30->42 30->43 31->23 32->27 33->26 33->26 33->34 33->38 33->46 33->89 33->90 33->103 33->104 33->105 33->125 33->126 33->127 33->146 33->147 34->26 34->26 35->40 35->118 35->141 36->24 36->33 36->33 36->37 36->38 36->39 36->42 36->43 36->45 36->87 36->88 36->100 36->101 36->102 36->122 36->123 36->124 36->144 36->145 37->24 37->33 37->33 37->38 37->39 37->42 37->43 38->24 38->34 38->34 38->36 38->39 38->42 38->43 38->47 38->91 38->92 38->106 38->107 38->108 38->128 38->129 38->130 38->148 38->149 39->24 39->34 39->34 39->37 39->42 39->43 40->24 40->42 41->24 41->42 41->44 42->24 42->24 42->35 42->35 42->35 42->43 42->43 42->43 42->115 42->116 42->117 42->137 42->138 42->139 42->140 42->151 42->153 43->24 43->24 43->35 43->35 43->35 43->42 43->42 44->24 44->29 44->42 44->45 44->46 45->24 45->29 45->42 45->44 45->46 46->24 46->29 46->42 46->44 46->47 47->24 47->29 47->42 47->44
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int invoke ( Case * c ) { int wordpos = 0 ; int i = 0 ; int combined = 0 ; if ( c -> wordCount == 1 ) { c -> nword [ 0 ] = c -> word [ 0 ] ; c -> nwordCount = 1 ; return 1 ; } c -> nwordCount = 0 ; c -> nwordCount = add ( c -> nword , c -> nwordCount , c -> word [ wordpos ] ) ; wordpos ++ ; while ( wordpos < c -> wordCount ) { c -> nwordCount = add ( c -> nword , c -> nwordCount , c -> word [ wordpos ] ) ; combined = 0 ; for ( i = 0 ; i < c -> combineCount ; i ++ ) { if ( ( c -> nword [ c -> nwordCount - 1 ] == c -> Combine [ i ] . ele1 && c -> nword [ c -> nwordCount - 2 ] == c -> Combine [ i ] . ele2 ) || ( c -> nword [ c -> nwordCount - 1 ] == c -> Combine [ i ] . ele2 && c -> nword [ c -> nwordCount - 2 ] == c -> Combine [ i ] . ele1 ) ) { c -> nwordCount -- ; c -> nword [ c -> nwordCount - 1 ] = c -> Combine [ i ] . nele ; combined = 1 ; } } if ( ! combined ) for ( i = 0 ; i < c -> repulseCount ; i ++ ) { if ( contain ( c -> nword , c -> nwordCount , c -> Repulse [ i ] . ele1 ) && contain ( c -> nword , c -> nwordCount , c -> Repulse [ i ] . ele2 ) ) { c -> nwordCount = 0 ; } } wordpos ++ ; } return 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM char * argv [ ]
PARAM int argc
<operator>.assignment * input_data = fopen ( "\x69\x6e\x70\x75\x74\x2e\x74\x78\x74\x0" , "r" )
<operator>.assignment * buf = malloc ( 1000000 )
<operator>.assignment index = - 1
<operator>.assignment buf [ ++ index ] = '\0'
fclose fclose ( input_data )
<operator>.assignment * output_data = fopen ( "output.txt" , "w" )
<operator>.assignment index = 0
<operator>.assignment case_id = 1
<operator>.assignment base [ 8 ] = { 'Q'   'W'   'E'   'R'   'A'   'S'   'D'   'F' }
fclose fclose ( output_data )
RETURN return 0 ; return 0 ;
<operator>.logicalNot ! feof ( input_data )
<operator>.notEquals buf [ index ] != '\n'
<operator>.preIncrement ++ index
<operator>.notEquals buf [ index ] != 0
LITERAL 0 return 0 ;
fopen fopen ( "\x69\x6e\x70\x75\x74\x2e\x74\x78\x74\x0" , "r" )
malloc malloc ( 1000000 )
<operator>.minus - 1
<operator>.assignment buf [ ++ index ] = getc ( input_data )
fopen fopen ( "output.txt" , "w" )
<operator>.arrayInitializer { 'Q'   'W'   'E'   'R'   'A'   'S'   'D'   'F' }
<operator>.assignment Ci = 0
<operator>.assignment Di = 0
<operator>.assignment Ni = 0
memset memset ( C , 0 , 36 * 3 )
memset memset ( D , 0 , 28 * 2 )
<operator>.assignment num_index = - 1
<operator>.assignment temp_index = index
<operator>.assignment index = temp_index + 1
<operator>.assignment num_index = - 1
<operator>.assignment temp_index = index - 1
<operator>.assignment index = temp_index + 1
<operator>.assignment num_index = - 1
<operator>.assignment temp_index = index - 1
<operator>.assignment index = temp_index + 1
memset memset ( Q , 0 , 101 )
<operator>.assignment * N = Q
<operator>.assignment element_num = 0
<operator>.assignment old_Ni = Ni
<operator>.assignment try_again = 0
fprintf fprintf ( output_data , "Case #%i: [" , case_id )
<operator>.preIncrement ++ case_id
feof feof ( input_data )
<operator>.preIncrement ++ index
<operator>.logicalAnd buf [ ++ temp_index ] < 0x3A && buf [ temp_index ] > 0x2F
<operator>.greaterThan num_index > - 1
<operator>.lessThan i < Ci
<operator>.preIncrement ++ i
<operator>.logicalAnd buf [ ++ temp_index ] < 0x3A && buf [ temp_index ] > 0x2F
<operator>.greaterThan num_index > - 1
<operator>.lessThan i < Di
<operator>.preIncrement ++ i
<operator>.logicalAnd buf [ ++ temp_index ] < 0x3A && buf [ temp_index ] > 0x2F
<operator>.greaterThan num_index > - 1
<operator>.lessThan i < Ni
<operator>.preIncrement ++ i
LITERAL 1 while (1)
<operator>.lessThan i < Ni - 1
<operator>.preIncrement ++ i
<operator>.notEquals N [ i ] != 0
getc getc ( input_data )
<operator>.multiplication 36 * 3
<operator>.multiplication 28 * 2
<operator>.minus - 1
<operator>.assignment num_buf [ ++ num_index ] = buf [ temp_index ]
<operator>.assignment num_buf [ ++ num_index ] = '\0'
<operator>.assignment Ci = atoi ( num_buf )
<operator>.addition temp_index + 1
<operator>.assignment i = 0
memcpy memcpy ( C [ i ] , buf + index , 3 )
<operator>.assignmentPlus index += 4
<operator>.minus - 1
<operator>.subtraction index - 1
<operator>.assignment num_buf [ ++ num_index ] = buf [ temp_index ]
<operator>.assignment num_buf [ ++ num_index ] = '\0'
<operator>.assignment Di = atoi ( num_buf )
<operator>.addition temp_index + 1
<operator>.assignment i = 0
memcpy memcpy ( D [ i ] , buf + index , 2 )
<operator>.assignmentPlus index += 3
<operator>.minus - 1
<operator>.subtraction index - 1
<operator>.assignment num_buf [ ++ num_index ] = buf [ temp_index ]
<operator>.assignment num_buf [ ++ num_index ] = '\0'
<operator>.assignment Ni = atoi ( num_buf )
<operator>.addition temp_index + 1
<operator>.assignment i = 0
<operator>.assignment invokeable = 0
<operator>.assignment N [ i ] = buf [ index ]
<operator>.preIncrement ++ index
<operator>.assignment try_again = 0
<operator>.preIncrement ++ element_num
<operator>.assignment i = 0
fprintf fprintf ( output_data , "%c]\n" , N [ i ] )
<operator>.preIncrement ++ index
<operator>.lessThan buf [ ++ temp_index ] < 0x3A
<operator>.greaterThan buf [ temp_index ] > 0x2F
<operator>.minus - 1
<operator>.lessThan buf [ ++ temp_index ] < 0x3A
<operator>.greaterThan buf [ temp_index ] > 0x2F
<operator>.minus - 1
<operator>.lessThan buf [ ++ temp_index ] < 0x3A
<operator>.greaterThan buf [ temp_index ] > 0x2F
<operator>.minus - 1
<operator>.lessThan j < 8
<operator>.preIncrement ++ j
<operator>.logicalNot ! invokeable
<operator>.lessThan element_num < 2
<operator>.logicalAnd element_num > Ni && try_again == 0
<operator>.lessThan i < Ci
<operator>.preIncrement ++ i
IDENTIFIER try_again if (try_again)
<operator>.lessThan i < element_num
<operator>.preIncrement ++ i
IDENTIFIER try_again if (try_again)
<operator>.subtraction Ni - 1
<operator>.notEquals N [ i ] != 0
fprintf fprintf ( output_data , "]\n" )
atoi atoi ( num_buf )
<operator>.addition buf + index
atoi atoi ( num_buf )
<operator>.addition buf + index
atoi atoi ( num_buf )
<operator>.assignment j = 0
<operator>.preDecrement -- i
<operator>.preDecrement -- Ni
<operator>.preIncrement ++ element_num
<operator>.assignment try_again = 0
<operator>.assignment i = 0
<operator>.assignment i = 0
fprintf fprintf ( output_data , "%c, " , N [ i ] )
<operator>.preIncrement ++ temp_index
<operator>.preIncrement ++ num_index
<operator>.preIncrement ++ num_index
<operator>.preIncrement ++ temp_index
<operator>.preIncrement ++ num_index
<operator>.preIncrement ++ num_index
<operator>.preIncrement ++ temp_index
<operator>.preIncrement ++ num_index
<operator>.preIncrement ++ num_index
<operator>.equals buf [ index ] == base [ j ]
<operator>.greaterThan element_num > Ni
<operator>.equals try_again == 0
<operator>.logicalOr ( N [ element_num - 1 ] == C [ i ] [ 0 ] && N [ element_num - 2 ] == C [ i ] [ 1 ] ) || ( N [ element_num - 1 ] == C [ i ] [ 1 ] && N [ element_num - 2 ] == C [ i ] [ 0 ] )
<operator>.lessThan j < element_num
<operator>.preIncrement ++ j
IDENTIFIER try_again if (try_again)
<operator>.assignment invokeable = 1
<operator>.assignment N [ element_num - 2 ] = C [ i ] [ 2 ]
<operator>.preDecrement -- element_num
<operator>.preDecrement -- Ni
<operator>.assignment try_again = 1
<operator>.assignment j = 0
<operator>.logicalAnd N [ element_num - 1 ] == C [ i ] [ 0 ] && N [ element_num - 2 ] == C [ i ] [ 1 ]
<operator>.logicalAnd N [ element_num - 1 ] == C [ i ] [ 1 ] && N [ element_num - 2 ] == C [ i ] [ 0 ]
<operator>.lessThan j < Ni
<operator>.preIncrement ++ j
<operator>.equals i == j
<operator>.lessThan k < Di
<operator>.preIncrement ++ k
IDENTIFIER try_again if (try_again)
<operator>.equals N [ element_num - 1 ] == C [ i ] [ 0 ]
<operator>.equals N [ element_num - 2 ] == C [ i ] [ 1 ]
<operator>.equals N [ element_num - 1 ] == C [ i ] [ 1 ]
<operator>.equals N [ element_num - 2 ] == C [ i ] [ 0 ]
<operator>.assignment j = element_num - 1
<operator>.assignment N [ j ] = N [ j + 1 ]
<operator>.assignment k = 0
<operator>.subtraction element_num - 2
<operator>.logicalOr ( N [ i ] == D [ k ] [ 0 ] && N [ j ] == D [ k ] [ 1 ] ) || ( N [ i ] == D [ k ] [ 1 ] && N [ j ] == D [ k ] [ 0 ] )
<operator>.subtraction element_num - 1
<operator>.subtraction element_num - 2
<operator>.subtraction element_num - 1
<operator>.subtraction element_num - 2
<operator>.subtraction element_num - 1
<operator>.assignment try_again = 1
<operator>.addition j + 1
<operator>.logicalAnd N [ i ] == D [ k ] [ 0 ] && N [ j ] == D [ k ] [ 1 ]
<operator>.logicalAnd N [ i ] == D [ k ] [ 1 ] && N [ j ] == D [ k ] [ 0 ]
<operator>.lessThan l < element_num
<operator>.preIncrement ++ l
<operator>.assignment N [ l ] = 0
<operator>.equals N [ i ] == D [ k ] [ 0 ]
<operator>.equals N [ j ] == D [ k ] [ 1 ]
<operator>.equals N [ i ] == D [ k ] [ 1 ]
<operator>.equals N [ j ] == D [ k ] [ 0 ]
<operator>.assignment l = 0
<operator>.indirectIndexAccess buf [ index ]
<operator>.indirectIndexAccess buf [ index ]
<operator>.indirectIndexAccess buf [ ++ index ]
<operator>.indirectIndexAccess N [ i ]
<operator>.indirectIndexAccess buf [ ++ temp_index ]
<operator>.indirectIndexAccess buf [ temp_index ]
<operator>.indirectIndexAccess num_buf [ ++ num_index ]
<operator>.indirectIndexAccess buf [ temp_index ]
<operator>.indirectIndexAccess num_buf [ ++ num_index ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess buf [ ++ temp_index ]
<operator>.indirectIndexAccess buf [ temp_index ]
<operator>.indirectIndexAccess num_buf [ ++ num_index ]
<operator>.indirectIndexAccess buf [ temp_index ]
<operator>.indirectIndexAccess num_buf [ ++ num_index ]
<operator>.indirectIndexAccess D [ i ]
<operator>.indirectIndexAccess buf [ ++ temp_index ]
<operator>.indirectIndexAccess buf [ temp_index ]
<operator>.indirectIndexAccess num_buf [ ++ num_index ]
<operator>.indirectIndexAccess buf [ temp_index ]
<operator>.indirectIndexAccess num_buf [ ++ num_index ]
<operator>.indirectIndexAccess N [ i ]
<operator>.indirectIndexAccess buf [ index ]
<operator>.indirectIndexAccess N [ i ]
<operator>.indirectIndexAccess N [ i ]
<operator>.indirectIndexAccess N [ i ]
<operator>.indirectIndexAccess buf [ index ]
<operator>.indirectIndexAccess base [ j ]
<operator>.indirectIndexAccess N [ element_num - 2 ]
<operator>.indirectIndexAccess C [ i ] [ 2 ]
<operator>.indirectIndexAccess N [ element_num - 1 ]
<operator>.indirectIndexAccess C [ i ] [ 0 ]
<operator>.indirectIndexAccess N [ element_num - 2 ]
<operator>.indirectIndexAccess C [ i ] [ 1 ]
<operator>.indirectIndexAccess N [ element_num - 1 ]
<operator>.indirectIndexAccess C [ i ] [ 1 ]
<operator>.indirectIndexAccess N [ element_num - 2 ]
<operator>.indirectIndexAccess C [ i ] [ 0 ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess N [ j ]
<operator>.indirectIndexAccess N [ j + 1 ]
<operator>.indirectIndexAccess N [ i ]
<operator>.indirectIndexAccess D [ k ] [ 0 ]
<operator>.indirectIndexAccess N [ j ]
<operator>.indirectIndexAccess D [ k ] [ 1 ]
<operator>.indirectIndexAccess N [ i ]
<operator>.indirectIndexAccess D [ k ] [ 1 ]
<operator>.indirectIndexAccess N [ j ]
<operator>.indirectIndexAccess D [ k ] [ 0 ]
<operator>.indirectIndexAccess N [ l ]
<operator>.indirectIndexAccess D [ k ]
<operator>.indirectIndexAccess D [ k ]
<operator>.indirectIndexAccess D [ k ]
<operator>.indirectIndexAccess D [ k ]
>>>PDG&250 0->2 0->3 0->7 0->8 0->10 0->11 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->36 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->54 0->55 0->56 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->70 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->127 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->138 0->139 0->140 0->141 0->142 0->143 0->144 0->145 0->146 0->147 0->149 0->150 0->151 0->152 0->154 0->155 0->156 0->157 0->160 0->161 0->162 0->163 0->164 0->165 0->172 0->173 0->175 0->176 0->177 0->178 0->179 0->180 0->181 0->184 0->185 0->186 0->191 2->1 3->1 4->1 4->1 4->47 5->1 5->1 5->1 5->16 5->18 5->69 5->74 5->78 5->83 5->87 5->93 5->100 5->101 5->103 5->104 5->106 5->107 5->124 5->126 5->145 6->1 6->1 6->48 6->99 7->1 7->1 7->18 7->74 7->78 7->83 7->87 7->93 7->100 7->101 7->103 7->104 7->106 7->107 7->124 7->126 7->145 8->1 8->1 9->1 9->1 9->13 9->45 10->1 10->1 10->17 10->32 11->1 11->1 11->45 12->1 12->1 12->1 12->145 13->1 13->1 14->1 15->1 15->1 15->15 15->23 15->47 15->65 15->99 15->194 16->1 16->16 16->17 16->18 16->192 17->1 17->1 17->32 18->1 18->1 18->26 18->27 18->28 18->29 18->30 18->31 18->32 18->49 18->50 18->66 18->67 18->68 18->74 18->78 18->83 18->87 18->93 18->100 18->100 18->101 18->102 18->103 18->104 18->106 18->107 18->124 18->126 18->136 18->145 18->196 19->14 20->4 20->4 21->5 22->6 23->1 24->9 24->9 25->12 25->12 25->12 25->12 25->12 25->12 25->12 25->12 26->1 26->1 27->1 27->1 28->1 28->1 29->1 29->1 29->1 29->74 30->1 30->1 30->1 30->83 31->1 31->50 31->137 32->1 32->1 32->136 33->1 33->1 33->74 33->75 33->77 33->124 34->1 34->54 34->140 35->1 35->1 35->139 36->1 36->1 36->83 36->84 36->86 36->126 37->1 37->58 37->143 38->1 38->1 38->142 39->1 39->1 39->1 39->32 39->94 40->1 40->41 41->1 41->1 41->1 41->64 41->98 41->121 41->135 41->166 41->167 41->168 41->169 41->171 41->187 41->188 41->189 41->190 42->1 42->1 42->112 43->1 43->1 44->1 44->1 44->147 45->1 45->46 45->98 45->122 45->135 46->1 46->1 46->45 47->8 47->15 47->65 49->1 49->1 49->1 49->49 49->53 49->69 49->100 49->136 49->137 49->196 49->198 49->199 50->1 50->1 50->1 50->33 50->34 50->35 50->51 50->53 50->54 50->70 50->71 50->72 50->73 50->76 50->77 50->103 50->105 50->123 50->138 50->138 50->139 50->200 50->202 51->1 51->1 51->1 51->51 51->52 51->52 51->74 51->75 51->114 51->124 51->201 52->1 52->51 53->1 53->1 53->1 53->53 53->57 53->78 53->103 53->139 53->140 53->202 53->204 53->205 54->1 54->1 54->1 54->36 54->37 54->38 54->55 54->57 54->58 54->79 54->80 54->81 54->82 54->85 54->86 54->106 54->108 54->125 54->141 54->141 54->142 54->206 54->208 55->1 55->1 55->1 55->55 55->56 55->56 55->83 55->84 55->126 55->163 55->207 56->1 56->55 57->1 57->1 57->1 57->49 57->57 57->87 57->106 57->142 57->143 57->208 57->210 57->211 58->1 58->1 58->1 58->18 58->39 58->40 58->41 58->42 58->43 58->44 58->45 58->46 58->59 58->62 58->64 58->88 58->89 58->90 58->91 58->97 58->112 58->120 58->127 58->144 58->144 58->193 58->195 58->212 59->1 59->43 59->59 59->60 59->60 59->92 59->109 59->111 59->120 59->128 59->129 59->130 59->146 60->1 60->59 62->1 62->1 62->1 62->62 62->63 62->63 62->120 62->121 62->216 63->1 63->62 64->1 64->1 64->98 64->98 64->121 64->122 64->187 64->215 65->23 65->47 66->29 66->29 67->30 67->30 68->31 69->1 69->1 69->1 70->1 70->1 70->123 71->1 71->1 71->51 73->1 73->51 74->1 74->1 74->1 74->29 75->1 75->74 75->77 75->124 76->34 77->1 77->35 77->35 78->1 78->1 78->1 79->1 79->1 79->125 80->1 80->1 80->55 82->1 82->55 83->1 83->1 83->1 83->30 84->1 84->83 84->86 84->126 85->37 86->1 86->38 86->38 87->1 87->1 87->1 88->1 88->1 88->127 89->1 89->1 89->59 90->1 91->59 92->1 92->111 93->1 93->64 93->121 93->187 94->1 94->1 94->32 95->1 95->1 95->147 96->1 96->1 96->112 97->1 97->62 98->1 98->1 98->13 98->45 98->64 98->121 98->187 99->48 100->1 100->18 100->49 100->49 100->74 100->78 100->83 100->87 100->93 100->101 100->101 100->103 100->104 100->106 100->107 100->124 100->126 100->145 100->197 101->1 101->18 101->49 101->49 101->69 101->74 101->78 101->83 101->87 101->93 101->100 101->103 101->104 101->106 101->107 101->124 101->126 101->145 102->50 103->1 103->18 103->53 103->53 103->83 103->93 103->100 103->101 103->104 103->104 103->106 103->107 103->126 103->145 103->203 104->1 104->18 104->53 104->53 104->69 104->74 104->78 104->83 104->87 104->93 104->100 104->101 104->103 104->106 104->107 104->124 104->126 104->145 105->54 106->1 106->57 106->57 106->100 106->107 106->209 107->1 107->18 107->57 107->57 107->69 107->74 107->78 107->83 107->87 107->93 107->100 107->101 107->103 107->104 107->106 107->124 107->126 107->145 108->58 109->1 109->1 109->110 109->145 109->218 109->219 110->1 110->109 111->1 111->1 111->93 111->94 111->129 111->130 111->213 111->214 112->1 112->112 112->113 112->131 112->131 112->132 112->146 112->146 113->1 113->1 113->1 113->95 113->96 113->112 113->114 113->117 113->133 113->134 114->1 114->1 114->115 114->148 114->158 114->166 114->175 114->222 114->223 114->231 115->1 115->114 117->1 117->1 117->96 117->112 117->117 117->118 117->118 117->149 117->149 117->157 117->162 118->1 118->117 120->1 120->62 120->62 121->64 121->135 121->135 121->217 122->1 122->13 122->45 123->1 123->71 123->125 124->1 125->1 125->80 125->127 126->1 127->1 127->89 127->123 128->1 128->109 129->1 129->60 130->1 130->59 131->1 131->1 131->112 132->1 132->1 132->147 133->114 134->117 135->1 135->64 135->98 135->121 135->122 136->1 136->33 136->72 137->50 139->1 139->36 139->81 140->54 142->1 142->39 142->90 143->58 144->1 145->1 145->1 145->18 145->93 145->109 145->110 145->152 146->1 146->112 146->113 146->113 146->117 146->120 146->147 146->160 146->175 147->1 147->113 147->113 148->1 148->1 148->1 148->114 148->115 148->153 148->154 148->155 148->156 148->160 148->170 148->173 148->179 148->220 148->221 148->230 149->1 149->1 149->1 149->96 149->112 149->117 149->162 149->162 149->184 150->1 150->149 152->1 152->111 153->1 153->1 153->1 153->167 153->169 154->1 154->1 154->112 154->117 155->1 155->120 155->146 156->1 156->1 156->147 157->1 157->149 158->1 158->1 158->148 158->148 158->159 158->168 158->177 158->226 158->227 158->233 159->1 159->1 159->148 159->148 160->1 160->1 160->155 160->160 160->161 160->161 160->171 160->181 160->181 160->235 160->236 161->1 161->160 162->1 162->1 162->118 162->149 162->150 162->150 162->163 162->172 163->1 163->1 163->1 163->164 163->174 163->182 163->187 163->237 163->238 163->246 164->1 164->163 166->1 166->1 166->74 166->158 166->158 166->167 166->168 166->169 166->176 166->224 166->225 166->232 167->1 167->1 167->74 167->158 167->158 167->168 167->169 168->1 168->1 168->74 168->159 168->159 168->166 168->167 168->169 168->178 168->228 168->229 168->234 169->1 169->1 169->74 169->159 169->159 169->166 169->167 170->1 170->1 170->160 171->1 171->1 171->1 171->188 171->190 172->1 172->163 173->179 174->1 174->1 174->1 174->163 174->164 174->180 174->184 174->191 175->1 175->112 175->117 175->173 175->176 175->177 176->1 176->112 176->117 176->173 176->175 176->177 177->1 177->112 177->117 177->173 177->175 177->178 178->1 178->112 178->117 178->173 178->175 179->154 179->170 179->170 180->1 180->1 180->147 182->1 182->1 182->174 182->174 182->183 182->189 182->241 182->242 182->248 183->1 183->1 183->174 183->174 184->1 184->1 184->1 184->96 184->112 184->117 184->149 184->184 184->185 184->185 184->186 184->245 185->1 185->184 186->1 186->1 187->1 187->64 187->121 187->182 187->182 187->188 187->189 187->190 187->239 187->240 187->247 188->1 188->1 188->182 188->182 188->189 188->190 189->1 189->64 189->121 189->183 189->183 189->187 189->188 189->190 189->243 189->244 189->249 190->1 190->1 190->183 190->183 190->187 190->188 191->1 191->184
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( char * argv [ ] , int argc ) { FILE * input_data = fopen ( "\x69\x6e\x70\x75\x74\x2e\x74\x78\x74\x0" , "r" ) ; char * buf = malloc ( 1000000 ) ; int index = - 1 ; while ( ! feof ( input_data ) ) { buf [ ++ index ] = getc ( input_data ) ; } buf [ ++ index ] = '\0' ; fclose ( input_data ) ; FILE * output_data = fopen ( "output.txt" , "w" ) ; index = 0 ; while ( buf [ index ] != '\n' ) ++ index ; int case_id = 1 ; char C [ 36 ] [ 3 ] ; char D [ 28 ] [ 2 ] ; char base [ 8 ] = { 'Q' , 'W' , 'E' , 'R' , 'A' , 'S' , 'D' , 'F' } ; while ( buf [ index ] != 0 ) { int Ci = 0 ; int Di = 0 ; int Ni = 0 ; memset ( C , 0 , 36 * 3 ) ; memset ( D , 0 , 28 * 2 ) ; char num_buf [ 10 ] ; int num_index = - 1 ; int temp_index = index ; while ( buf [ ++ temp_index ] < 0x3A && buf [ temp_index ] > 0x2F ) { num_buf [ ++ num_index ] = buf [ temp_index ] ; } if ( num_index > - 1 ) { num_buf [ ++ num_index ] = '\0' ; Ci = atoi ( num_buf ) ; } else break ; index = temp_index + 1 ; int i ; for ( i = 0 ; i < Ci ; ++ i ) { memcpy ( C [ i ] , buf + index , 3 ) ; index += 4 ; } num_index = - 1 ; temp_index = index - 1 ; while ( buf [ ++ temp_index ] < 0x3A && buf [ temp_index ] > 0x2F ) { num_buf [ ++ num_index ] = buf [ temp_index ] ; } if ( num_index > - 1 ) { num_buf [ ++ num_index ] = '\0' ; Di = atoi ( num_buf ) ; } else break ; index = temp_index + 1 ; for ( i = 0 ; i < Di ; ++ i ) { memcpy ( D [ i ] , buf + index , 2 ) ; index += 3 ; } num_index = - 1 ; temp_index = index - 1 ; while ( buf [ ++ temp_index ] < 0x3A && buf [ temp_index ] > 0x2F ) { num_buf [ ++ num_index ] = buf [ temp_index ] ; } if ( num_index > - 1 ) { num_buf [ ++ num_index ] = '\0' ; Ni = atoi ( num_buf ) ; } else break ; index = temp_index + 1 ; char Q [ 101 ] ; memset ( Q , 0 , 101 ) ; char * N = Q ; for ( i = 0 ; i < Ni ; ++ i ) { int j ; int invokeable = 0 ; for ( j = 0 ; j < 8 ; ++ j ) { if ( buf [ index ] == base [ j ] ) { invokeable = 1 ; break ; } } if ( ! invokeable ) { -- i ; -- Ni ; continue ; } N [ i ] = buf [ index ] ; ++ index ; } int element_num = 0 ; int old_Ni = Ni ; int try_again = 0 ; while ( 1 ) { if ( element_num < 2 ) { ++ element_num ; try_again = 0 ; continue ; } if ( element_num > Ni && try_again == 0 ) break ; try_again = 0 ; for ( i = 0 ; i < Ci ; ++ i ) { if ( ( N [ element_num - 1 ] == C [ i ] [ 0 ] && N [ element_num - 2 ] == C [ i ] [ 1 ] ) || ( N [ element_num - 1 ] == C [ i ] [ 1 ] && N [ element_num - 2 ] == C [ i ] [ 0 ] ) ) { N [ element_num - 2 ] = C [ i ] [ 2 ] ; int j ; for ( j = element_num - 1 ; j < Ni ; ++ j ) { N [ j ] = N [ j + 1 ] ; } -- element_num ; -- Ni ; try_again = 1 ; break ; } } if ( try_again ) continue ; for ( i = 0 ; i < element_num ; ++ i ) { int j ; for ( j = 0 ; j < element_num ; ++ j ) { if ( i == j ) continue ; int k ; for ( k = 0 ; k < Di ; ++ k ) { if ( ( N [ i ] == D [ k ] [ 0 ] && N [ j ] == D [ k ] [ 1 ] ) || ( N [ i ] == D [ k ] [ 1 ] && N [ j ] == D [ k ] [ 0 ] ) ) { int l ; for ( l = 0 ; l < element_num ; ++ l ) N [ l ] = 0 ; try_again = 1 ; break ; } } if ( try_again ) break ; } if ( try_again ) break ; } if ( try_again ) continue ; ++ element_num ; } fprintf ( output_data , "Case #%i: [" , case_id ) ; for ( i = 0 ; i < Ni - 1 ; ++ i ) { if ( N [ i ] != 0 ) fprintf ( output_data , "%c, " , N [ i ] ) ; } if ( N [ i ] != 0 ) fprintf ( output_data , "%c]\n" , N [ i ] ) ; else fprintf ( output_data , "]\n" ) ; ++ case_id ; } fclose ( output_data ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment inf = fopen ( argv [ 1 ] , "\x72\x0" )
fscanf fscanf ( inf , "%d" , & num_cases )
<operator>.lessThan i < num_cases
<operator>.postIncrement i ++
fopen fopen ( argv [ 1 ] , "\x72\x0" )
<operator>.assignment i = 0
<operator>.assignment sum = 0
fscanf fscanf ( inf , "%d" , & n )
<operator>.assignment x = ( int * ) malloc ( sizeof ( int ) * n )
<operator>.assignment y = ( int * ) malloc ( sizeof ( int ) * n )
qsort qsort ( x   n   sizeof ( int ) , compare_asc )
qsort qsort ( y   n   sizeof ( int ) , compare_desc )
printf printf ( "Case #%d: %d\n" , i + 1 , sum )
free free ( x )
free free ( y )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.cast ( int * ) malloc ( sizeof ( int ) * n )
<operator>.cast ( int * ) malloc ( sizeof ( int ) * n )
<operator>.assignment j = 0
fscanf fscanf ( inf , "%d" , & x [ j ] )
<operator>.assignment j = 0
fscanf fscanf ( inf , "%d" , & y [ j ] )
<operator>.assignment j = 0
<operator>.assignmentPlus sum += ( x [ j ] * y [ j ] )
<operator>.addition i + 1
malloc malloc ( sizeof ( int ) * n )
malloc malloc ( sizeof ( int ) * n )
<operator>.multiplication sizeof ( int ) * n
<operator>.multiplication sizeof ( int ) * n
<operator>.multiplication x [ j ] * y [ j ]
<operator>.addressOf & n
<operator>.sizeOf sizeof ( int )
<operator>.sizeOf sizeof ( int )
UNKNOWN int * int *
UNKNOWN int * int *
<operator>.addressOf & x [ j ]
<operator>.addressOf & y [ j ]
<operator>.sizeOf sizeof ( int )
<operator>.sizeOf sizeof ( int )
<operator>.indirectIndexAccess x [ j ]
<operator>.indirectIndexAccess y [ j ]
<operator>.indirectIndexAccess x [ j ]
<operator>.indirectIndexAccess y [ j ]
>>>PDG&52 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->36 0->37 2->1 3->1 3->8 4->1 4->1 4->5 5->1 5->1 5->1 5->6 5->11 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->16 6->17 6->18 6->19 6->21 6->23 6->25 6->26 6->27 6->29 6->31 6->33 6->33 6->34 6->35 6->36 6->37 6->39 6->40 6->41 6->42 6->43 6->46 6->47 7->1 7->6 8->1 8->4 8->4 9->1 9->6 10->16 10->32 11->14 11->15 11->19 11->21 11->23 11->28 11->30 11->36 11->37 12->14 12->17 12->28 12->38 13->15 13->18 13->30 13->38 14->1 14->15 14->17 14->38 15->1 15->18 15->23 15->38 19->19 19->20 19->20 19->21 19->28 19->44 19->48 20->19 21->14 21->21 21->22 21->22 21->30 21->45 21->49 22->21 23->11 23->23 23->24 23->24 23->32 23->36 23->38 23->50 23->51 24->23 27->19 28->11 28->14 28->17 28->30 28->38 29->21 30->11 30->15 30->18 30->38 31->23 32->16 34->12 34->25 35->13 35->26 36->34 36->37 37->19 37->35 38->14 38->15 38->17 38->18 38->28 38->30 38->32 38->32
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( int argc , char * * argv ) { FILE * inf ; int i ; inf = fopen ( argv [ 1 ] , "\x72\x0" ) ; fscanf ( inf , "%d" , & num_cases ) ; for ( i = 0 ; i < num_cases ; i ++ ) { int n ; int * x ; int * y ; int j ; int sum = 0 ; fscanf ( inf , "%d" , & n ) ; x = ( int * ) malloc ( sizeof ( int ) * n ) ; y = ( int * ) malloc ( sizeof ( int ) * n ) ; for ( j = 0 ; j < n ; j ++ ) { fscanf ( inf , "%d" , & x [ j ] ) ; } for ( j = 0 ; j < n ; j ++ ) { fscanf ( inf , "%d" , & y [ j ] ) ; } qsort ( x , n , sizeof ( int ) , compare_asc ) ; qsort ( y , n , sizeof ( int ) , compare_desc ) ; for ( j = 0 ; j < n ; j ++ ) { sum += ( x [ j ] * y [ j ] ) ; } printf ( "Case #%d: %d\n" , i + 1 , sum ) ; free ( x ) ; free ( y ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment * inf = fopen ( "\x69\x6e\x70\x75\x74\x2e\x74\x78\x74\x0" , "r" )
<operator>.assignment * outf = fopen ( "output.txt" , "w" )
<operator>.assignment number = 0
fscanf fscanf ( inf , "%d" , & number )
printf printf ( "number of cases = %d\n" , number )
RETURN return 1 ; return 1 ;
<operator>.logicalNot ! inf
<operator>.logicalNot ! outf
<operator>.lessThan index < number
<operator>.postIncrement index ++
LITERAL 1 return 1 ;
fopen fopen ( "\x69\x6e\x70\x75\x74\x2e\x74\x78\x74\x0" , "r" )
printf printf ( "Error opening the input file\n" )
RETURN return - 1 ; return - 1 ;
fopen fopen ( "output.txt" , "w" )
printf printf ( "Error opening the output file\n" )
RETURN return - 1 ; return - 1 ;
<operator>.assignment index = 0
memset memset ( element_list , 0 , MAX_ELEMENTS )
memset memset ( combinations , 0 , MAX_COMBS )
memset memset ( oppositions , 0 , MAX_OPPS )
<operator>.assignment list_index = 0
<operator>.assignment element = temp = '\0'
fscanf fscanf ( inf , "%d" , & num_comb )
fscanf fscanf ( inf , "%c" , & temp )
fscanf fscanf ( inf , "%d" , & num_opps )
fscanf fscanf ( inf , "%c" , & temp )
fscanf fscanf ( inf , "%d" , & num_seq )
printf printf ( "number of elements in the sequence = %d\n" , num_seq )
fscanf fscanf ( inf , "%c" , & temp )
<operator>.assignment inner_index = 0
fprintf fprintf ( outf , "Case #%d: [" , index + 1 )
fprintf fprintf ( outf , "]\n" )
<operator>.minus - 1
<operator>.minus - 1
<operator>.lessThan inner_index < num_comb
<operator>.postIncrement inner_index ++
<operator>.lessThan inner_index < num_opps
<operator>.postIncrement inner_index ++
<operator>.lessThan inner_index < num_seq
<operator>.postIncrement inner_index ++
<operator>.notEquals element_list [ inner_index ] != '\0'
<operator>.assignment temp = '\0'
<operator>.assignment inner_index = 0
fscanf fscanf ( inf , "%c" , & temp )
fscanf fscanf ( inf , "%c%c%c" , & combinations [ inner_index ] [ 0 ] [ 0 ] , & combinations [ inner_index ] [ 0 ] [ 1 ] , & combinations [ inner_index ] [ 1 ] [ 1 ] )
printf printf ( "combinations[%d] = %c%c%c\n" , inner_index , combinations [ inner_index ] [ 0 ] [ 0 ] , combinations [ inner_index ] [ 0 ] [ 1 ] , combinations [ inner_index ] [ 1 ] [ 1 ] )
<operator>.assignment inner_index = 0
fscanf fscanf ( inf , "%c" , & temp )
fscanf fscanf ( inf , "%c%c" , & oppositions [ inner_index ] [ 0 ] , & oppositions [ inner_index ] [ 1 ] )
printf printf ( "oppositions[%d] = %c%c\n" , inner_index , oppositions [ inner_index ] [ 0 ] , oppositions [ inner_index ] [ 1 ] )
<operator>.assignment inner_index = 0
fscanf fscanf ( inf , "%c" , & element )
printf printf ( "Element read = %c\n" , element )
<operator>.assignment opposed = 0
<operator>.assignment combined = 0
<operator>.addition index + 1
fprintf fprintf ( outf , "%c" , element_list [ inner_index ] )
<operator>.postIncrement inner_index ++
<operator>.equals inner_index == 0
<operator>.notEquals element_list [ inner_index + 1 ] != '\0'
<operator>.assignment element_list [ list_index ] = element
printf printf ( "element_list = %s\n" , element_list )
<operator>.assignmentPlus list_index += 1
fprintf fprintf ( outf , ", " )
<operator>.assignment temp = element_list [ list_index - 1 ]
printf printf ( "element_list[index - 1] = %c\n" , temp )
<operator>.assignment comb_element = findCombinationElement ( temp , element )
printf printf ( "combination element = %c\n" , comb_element )
<operator>.assignment opp_index = findOppositIndex ( element )
printf printf ( "opposite index = %d\n" , opp_index )
printf printf ( "opposed = %d, combined = %d\n" , opposed , combined )
printf printf ( "element list = %s\n" , element_list )
<operator>.notEquals comb_element != '\0'
<operator>.notEquals opp_index != - 1
<operator>.logicalAnd ! opposed && ! combined
<operator>.addition inner_index + 1
findCombinationElement findCombinationElement ( temp , element )
<operator>.assignment element_list [ list_index - 1 ] = comb_element
<operator>.assignment combined = 1
<operator>.assignment element = comb_element
findOppositIndex findOppositIndex ( element )
<operator>.assignment opind = 0
<operator>.assignment list_index = opp_index
<operator>.assignment opposed = 1
<operator>.assignment element_list [ list_index ] = element
<operator>.assignmentPlus list_index += 1
<operator>.subtraction list_index - 1
<operator>.minus - 1
<operator>.lessThan opind < list_index
<operator>.postIncrement opind ++
<operator>.logicalNot ! opposed
<operator>.logicalNot ! combined
<operator>.assignment opind = opp_index
<operator>.assignment element_list [ opind ] = '\0'
<operator>.subtraction list_index - 1
<operator>.addressOf & number
<operator>.addressOf & num_comb
<operator>.addressOf & temp
<operator>.addressOf & num_opps
<operator>.addressOf & temp
<operator>.addressOf & num_seq
<operator>.addressOf & temp
<operator>.indirectIndexAccess element_list [ inner_index ]
<operator>.addressOf & temp
<operator>.addressOf & combinations [ inner_index ] [ 0 ] [ 0 ]
<operator>.addressOf & combinations [ inner_index ] [ 0 ] [ 1 ]
<operator>.addressOf & combinations [ inner_index ] [ 1 ] [ 1 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 0 ] [ 0 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 0 ] [ 1 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 1 ] [ 1 ]
<operator>.addressOf & temp
<operator>.addressOf & oppositions [ inner_index ] [ 0 ]
<operator>.addressOf & oppositions [ inner_index ] [ 1 ]
<operator>.indirectIndexAccess oppositions [ inner_index ] [ 0 ]
<operator>.indirectIndexAccess oppositions [ inner_index ] [ 1 ]
<operator>.addressOf & element
<operator>.indirectIndexAccess element_list [ inner_index ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 0 ] [ 0 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 0 ] [ 1 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 1 ] [ 1 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 0 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 0 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 1 ]
<operator>.indirectIndexAccess oppositions [ inner_index ] [ 0 ]
<operator>.indirectIndexAccess oppositions [ inner_index ] [ 1 ]
<operator>.indirectIndexAccess oppositions [ inner_index ]
<operator>.indirectIndexAccess oppositions [ inner_index ]
<operator>.indirectIndexAccess element_list [ inner_index + 1 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 0 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 0 ]
<operator>.indirectIndexAccess combinations [ inner_index ] [ 1 ]
<operator>.indirectIndexAccess combinations [ inner_index ]
<operator>.indirectIndexAccess combinations [ inner_index ]
<operator>.indirectIndexAccess combinations [ inner_index ]
<operator>.indirectIndexAccess oppositions [ inner_index ]
<operator>.indirectIndexAccess oppositions [ inner_index ]
<operator>.indirectIndexAccess element_list [ list_index ]
<operator>.indirectIndexAccess combinations [ inner_index ]
<operator>.indirectIndexAccess combinations [ inner_index ]
<operator>.indirectIndexAccess combinations [ inner_index ]
<operator>.indirectIndexAccess element_list [ list_index - 1 ]
<operator>.indirectIndexAccess element_list [ list_index - 1 ]
<operator>.indirectIndexAccess element_list [ list_index ]
<operator>.indirectIndexAccess element_list [ opind ]
>>>PDG&147 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->68 0->70 0->72 0->73 0->74 0->75 0->76 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 2->1 2->1 2->8 3->9 4->5 4->6 5->6 5->10 5->25 6->10 7->1 8->1 8->1 8->3 8->5 8->9 8->14 8->15 8->16 8->35 9->4 9->5 9->6 9->7 9->10 9->17 9->18 9->19 9->33 9->36 9->98 10->10 10->11 10->11 10->20 10->21 10->22 10->23 10->24 10->25 10->26 10->27 10->28 10->29 10->30 10->31 10->32 10->33 10->33 10->34 10->37 10->39 10->41 10->43 10->44 10->45 10->49 10->53 10->58 10->58 10->99 10->100 10->101 10->102 10->103 10->104 10->105 11->10 12->7 13->2 13->2 14->1 15->1 16->3 16->3 18->1 19->10 20->1 20->43 20->59 20->62 20->64 20->67 20->74 21->1 22->1 23->65 23->89 24->54 24->55 25->26 25->37 25->46 26->27 26->28 26->31 26->50 27->28 27->39 27->50 28->29 28->31 29->30 29->31 29->41 30->41 31->25 31->26 31->28 31->46 31->50 31->54 31->68 31->79 32->60 32->78 33->34 33->59 34->33 35->1 35->15 36->18 37->25 37->37 37->38 37->46 37->47 37->48 37->48 37->106 37->107 37->108 37->109 37->110 37->111 37->112 37->120 37->121 37->122 37->123 37->124 37->125 37->131 37->132 37->133 37->134 37->135 37->136 37->140 37->141 37->142 38->37 39->27 39->39 39->40 39->50 39->51 39->52 39->52 39->113 39->114 39->115 39->116 39->117 39->126 39->127 39->128 39->129 39->137 39->138 40->39 41->29 41->30 41->41 41->42 41->54 41->55 41->56 41->57 41->61 41->61 41->118 42->41 43->20 43->43 43->59 43->59 43->60 43->62 43->64 43->74 43->78 43->105 43->119 43->130 44->24 44->26 44->28 44->31 44->46 44->50 45->37 46->26 46->28 46->31 46->47 46->50 47->26 47->46 47->48 47->48 47->48 48->38 48->47 48->47 48->47 49->39 50->28 50->31 50->51 51->28 51->50 51->52 51->52 52->40 52->51 52->51 53->41 54->25 54->55 54->63 54->79 54->83 54->87 55->54 55->63 55->79 56->73 57->73 59->34 59->43 59->66 60->78 61->42 61->63 61->64 61->65 61->67 61->68 61->69 61->70 61->71 61->72 61->73 61->74 61->75 61->76 61->77 61->79 61->83 61->89 61->90 61->93 61->139 61->143 62->20 62->64 62->66 62->74 63->20 63->64 63->74 64->20 64->43 64->59 64->62 64->67 64->74 65->89 66->34 66->59 67->68 68->79 69->70 70->75 71->72 72->76 73->93 73->94 74->20 74->43 74->59 74->62 74->64 74->67 75->80 75->80 75->81 75->82 75->82 75->97 75->144 76->84 76->85 76->85 76->86 76->91 76->95 76->95 77->87 77->88 77->145 79->69 79->69 79->83 80->20 80->64 80->67 80->74 81->73 82->83 83->54 83->55 83->71 83->87 85->65 85->88 85->89 86->73 87->20 87->74 88->65 88->89 89->65 89->88 89->91 89->97 90->76 91->91 91->92 91->92 91->96 91->146 92->91 93->77 93->94 94->77 95->91 96->20 96->64 96->74 97->65 97->88 97->89 97->91
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { FILE * inf = fopen ( "\x69\x6e\x70\x75\x74\x2e\x74\x78\x74\x0" , "r" ) ; if ( ! inf ) { printf ( "Error opening the input file\n" ) ; return - 1 ; } FILE * outf = fopen ( "output.txt" , "w" ) ; if ( ! outf ) { printf ( "Error opening the output file\n" ) ; return - 1 ; } int index ; int inner_index ; char temp ; char element ; int number = 0 ; fscanf ( inf , "%d" , & number ) ; printf ( "number of cases = %d\n" , number ) ; for ( index = 0 ; index < number ; index ++ ) { memset ( element_list , 0 , MAX_ELEMENTS ) ; memset ( combinations , 0 , MAX_COMBS ) ; memset ( oppositions , 0 , MAX_OPPS ) ; list_index = 0 ; element = temp = '\0' ; fscanf ( inf , "%d" , & num_comb ) ; for ( inner_index = 0 ; inner_index < num_comb ; inner_index ++ ) { fscanf ( inf , "%c" , & temp ) ; fscanf ( inf , "%c%c%c" , & combinations [ inner_index ] [ 0 ] [ 0 ] , & combinations [ inner_index ] [ 0 ] [ 1 ] , & combinations [ inner_index ] [ 1 ] [ 1 ] ) ; printf ( "combinations[%d] = %c%c%c\n" , inner_index , combinations [ inner_index ] [ 0 ] [ 0 ] , combinations [ inner_index ] [ 0 ] [ 1 ] , combinations [ inner_index ] [ 1 ] [ 1 ] ) ; } fscanf ( inf , "%c" , & temp ) ; fscanf ( inf , "%d" , & num_opps ) ; for ( inner_index = 0 ; inner_index < num_opps ; inner_index ++ ) { fscanf ( inf , "%c" , & temp ) ; fscanf ( inf , "%c%c" , & oppositions [ inner_index ] [ 0 ] , & oppositions [ inner_index ] [ 1 ] ) ; printf ( "oppositions[%d] = %c%c\n" , inner_index , oppositions [ inner_index ] [ 0 ] , oppositions [ inner_index ] [ 1 ] ) ; } fscanf ( inf , "%c" , & temp ) ; fscanf ( inf , "%d" , & num_seq ) ; printf ( "number of elements in the sequence = %d\n" , num_seq ) ; fscanf ( inf , "%c" , & temp ) ; for ( inner_index = 0 ; inner_index < num_seq ; inner_index ++ ) { fscanf ( inf , "%c" , & element ) ; printf ( "Element read = %c\n" , element ) ; int opposed = 0 ; int combined = 0 ; char comb_element ; if ( inner_index == 0 ) { element_list [ list_index ] = element ; printf ( "element_list = %s\n" , element_list ) ; list_index += 1 ; } else { temp = element_list [ list_index - 1 ] ; printf ( "element_list[index - 1] = %c\n" , temp ) ; comb_element = findCombinationElement ( temp , element ) ; printf ( "combination element = %c\n" , comb_element ) ; if ( comb_element != '\0' ) { element_list [ list_index - 1 ] = comb_element ; combined = 1 ; element = comb_element ; } int opp_index = findOppositIndex ( element ) ; printf ( "opposite index = %d\n" , opp_index ) ; if ( opp_index != - 1 ) { int opind = 0 ; for ( opind = opp_index ; opind < list_index ; opind ++ ) { element_list [ opind ] = '\0' ; } list_index = opp_index ; opposed = 1 ; } printf ( "opposed = %d, combined = %d\n" , opposed , combined ) ; if ( ! opposed && ! combined ) { element_list [ list_index ] = element ; list_index += 1 ; } printf ( "element list = %s\n" , element_list ) ; } } inner_index = 0 ; fprintf ( outf , "Case #%d: [" , index + 1 ) ; while ( element_list [ inner_index ] != '\0' ) { fprintf ( outf , "%c" , element_list [ inner_index ] ) ; if ( element_list [ inner_index + 1 ] != '\0' ) fprintf ( outf , ", " ) ; inner_index ++ ; } fprintf ( outf , "]\n" ) ; } return 1 ; }
>>>Func
METHOD fit
METHOD_RETURN int
PARAM char * s
PARAM int a
PARAM int e
PARAM int n
RETURN return n - ( e - a ) ; return n - ( e - a ) ;
<operator>.lessEqualsThan e <= n
<operator>.assignment s [ a ++ ] = s [ e ++ ]
<operator>.subtraction n - ( e - a )
<operator>.subtraction e - a
<operator>.postIncrement a ++
<operator>.postIncrement e ++
<operator>.indirectIndexAccess s [ a ++ ]
<operator>.indirectIndexAccess s [ e ++ ]
>>>PDG&15 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->11 0->12 2->1 2->8 3->10 3->11 4->7 5->7 6->1 7->1 7->7 7->8 7->9 7->10 7->11 7->12 7->12 7->13 7->14 9->1 9->1 9->1 9->6 10->1 10->1 10->9 10->9
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int fit ( char * s , int a , int e , int n ) { while ( e <= n ) s [ a ++ ] = s [ e ++ ] ; return n - ( e - a ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment T = 0
<operator>.assignment N = 0
<operator>.assignment * pEnd = NULL
<operator>.assignment * file = fopen ( "\x43\x3a\x5c\x5c\x55\x73\x65\x72\x73\x5c\x5c\x42\x61\x72\x62\x69\x65\x5c\x5c\x43\x6f\x64\x65\x6a\x61\x6d\x5c\x5c\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e\x0" , "r" )
<operator>.assignment * file2 = fopen ( "C:\\Users\\Barbie\\Codejam\\output.txt" , "w" )
fscanf fscanf ( file , "%d" , & T )
fclose fclose ( file )
fclose fclose ( file2 )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
fopen fopen ( "\x43\x3a\x5c\x5c\x55\x73\x65\x72\x73\x5c\x5c\x42\x61\x72\x62\x69\x65\x5c\x5c\x43\x6f\x64\x65\x6a\x61\x6d\x5c\x5c\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e\x0" , "r" )
fopen fopen ( "C:\\Users\\Barbie\\Codejam\\output.txt" , "w" )
<operator>.assignment i = 1
fscanf fscanf ( file , "%d" , & N )
fprintf fprintf ( file2 , "Case #%d:\n" , i )
<operator>.lessThan j < ( N )
<operator>.postIncrement j ++
<operator>.lessThan j < ( N )
<operator>.postIncrement j ++
<operator>.lessThan j < ( N )
<operator>.postIncrement j ++
<operator>.lessThan j < ( N )
<operator>.postIncrement j ++
<operator>.lessThan j < ( N )
<operator>.postIncrement j ++
<operator>.lessThan j < ( N )
<operator>.postIncrement j ++
<operator>.lessThan j < ( N )
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment rpi [ j ] = 0
<operator>.assignment wp [ j ] = 0
<operator>.assignment owp [ j ] = 0
<operator>.assignment oowp [ j ] = 0
<operator>.assignment sum [ j ] = 0
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment rpi [ j ] = ( 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ] ) / sum [ j ]
<operator>.assignment j = 0
fprintf fprintf ( file2 , "%.12f\n" , rpi [ j ] )
<operator>.lessThan k < ( N )
<operator>.postIncrement k ++
<operator>.lessThan k < ( N )
<operator>.postIncrement k ++
<operator>.lessThan k < ( N )
<operator>.postIncrement k ++
<operator>.lessThan k < ( N )
<operator>.postIncrement k ++
<operator>.assignment k = 0
<operator>.assignment wins = getc ( file )
<operator>.assignment intWins [ j ] [ k ] = strtoul ( & wins , & pEnd , 10 )
<operator>.assignment k = 0
<operator>.assignment k = 0
<operator>.assignment k = 0
<operator>.division ( 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ] ) / sum [ j ]
<operator>.logicalAnd ( wins != '0' ) && ( wins != '1' ) && ( wins != '.' )
<operator>.equals wins == '.'
<operator>.notEquals intWins [ j ] [ k ] != 2
<operator>.notEquals j != k
<operator>.notEquals j != k
<operator>.addition 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ]
getc getc ( file )
<operator>.assignment wins = getc ( file )
<operator>.assignment wins = '2'
strtoul strtoul ( & wins , & pEnd , 10 )
<operator>.assignmentPlus wp [ j ] += intWins [ j ] [ k ]
<operator>.assignmentPlus sum [ j ] += 1
<operator>.addition 0.25 * wp [ j ] + 0.5 * owp [ j ]
<operator>.multiplication 0.25 * oowp [ j ]
<operator>.logicalAnd ( wins != '0' ) && ( wins != '1' )
<operator>.notEquals wins != '.'
<operator>.notEquals intWins [ k ] [ j ] != 2
<operator>.notEquals intWins [ k ] [ j ] != 2
<operator>.multiplication 0.25 * wp [ j ]
<operator>.multiplication 0.5 * owp [ j ]
<operator>.notEquals wins != '0'
<operator>.notEquals wins != '1'
getc getc ( file )
<operator>.assignmentPlus owp [ j ] += ( ( wp [ k ] - intWins [ k ] [ j ] ) / ( sum [ k ] - 1 ) )
<operator>.assignmentPlus oowp [ j ] += ( owp [ k ] ) / sum [ k ]
<operator>.division ( wp [ k ] - intWins [ k ] [ j ] ) / ( sum [ k ] - 1 )
<operator>.division ( owp [ k ] ) / sum [ k ]
<operator>.subtraction wp [ k ] - intWins [ k ] [ j ]
<operator>.subtraction sum [ k ] - 1
<operator>.addressOf & N
<operator>.indirectIndexAccess rpi [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess oowp [ j ]
<operator>.indirectIndexAccess sum [ j ]
<operator>.indirectIndexAccess rpi [ j ]
<operator>.indirectIndexAccess rpi [ j ]
<operator>.indirectIndexAccess sum [ j ]
<operator>.indirectIndexAccess intWins [ j ] [ k ]
<operator>.indirectIndexAccess intWins [ j ]
<operator>.addressOf & wins
<operator>.addressOf & pEnd
<operator>.indirectIndexAccess intWins [ j ] [ k ]
<operator>.indirectIndexAccess oowp [ j ]
<operator>.indirectIndexAccess intWins [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess intWins [ j ] [ k ]
<operator>.indirectIndexAccess sum [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess intWins [ j ]
<operator>.indirectIndexAccess intWins [ k ] [ j ]
<operator>.indirectIndexAccess intWins [ k ] [ j ]
<operator>.indirectIndexAccess intWins [ k ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess intWins [ k ]
<operator>.indirectIndexAccess oowp [ j ]
<operator>.indirectIndexAccess owp [ k ]
<operator>.indirectIndexAccess sum [ k ]
<operator>.indirectIndexAccess wp [ k ]
<operator>.indirectIndexAccess intWins [ k ] [ j ]
<operator>.indirectIndexAccess sum [ k ]
<operator>.indirectIndexAccess intWins [ k ]
>>>PDG&125 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->58 0->59 0->60 0->63 0->64 0->65 0->66 0->68 0->70 0->71 0->73 0->75 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->90 2->1 2->7 2->11 3->1 3->1 3->17 3->19 4->1 4->1 4->1 4->71 5->1 5->1 5->7 6->1 6->1 6->9 6->18 7->1 7->1 7->8 7->11 7->17 8->1 8->1 9->1 9->1 10->1 11->1 11->1 11->1 11->11 11->12 11->17 11->18 11->18 11->19 11->21 11->23 11->25 11->27 11->29 11->31 11->33 11->34 11->40 11->41 11->42 11->43 11->45 11->91 12->1 12->11 13->10 14->5 14->5 15->6 15->6 16->1 16->11 17->1 17->1 17->8 17->19 17->21 17->23 17->25 17->27 17->29 17->31 17->47 17->49 17->51 17->53 17->68 18->1 18->9 18->12 18->46 19->19 19->20 19->20 19->21 19->47 19->47 19->55 20->1 20->19 21->21 21->22 21->22 21->23 21->35 21->36 21->37 21->38 21->39 21->92 21->93 21->94 21->95 21->96 22->1 22->21 23->23 23->24 23->24 23->25 23->49 23->49 23->58 24->1 24->23 25->25 25->26 25->26 25->27 25->51 25->51 25->59 25->65 26->1 26->25 27->27 27->28 27->28 27->29 27->53 27->53 27->60 27->66 28->1 28->27 29->29 29->30 29->30 29->31 29->44 29->61 29->67 29->74 29->75 29->80 29->81 29->97 29->99 29->105 29->110 29->111 30->1 30->29 31->1 31->1 31->1 31->17 31->19 31->31 31->32 31->32 31->46 31->98 32->1 32->31 33->19 34->21 35->1 35->1 35->46 36->1 36->1 36->72 36->80 37->1 37->1 37->81 37->85 38->1 38->1 38->75 38->86 39->1 39->1 39->61 39->73 40->23 41->25 42->27 43->29 44->1 44->1 44->1 44->46 45->1 45->31 46->1 46->1 46->9 46->18 47->1 47->1 47->19 47->47 47->48 47->48 47->56 47->57 47->62 47->63 47->68 47->71 47->76 47->82 47->100 47->101 47->102 47->103 48->1 48->47 49->1 49->1 49->23 49->49 49->50 49->50 49->64 49->104 49->106 50->1 50->49 51->1 51->1 51->25 51->51 51->52 51->65 51->65 52->1 52->51 53->1 53->1 53->27 53->53 53->54 53->66 53->66 54->1 54->53 55->1 55->47 56->1 56->82 57->1 57->1 57->1 57->64 58->1 58->49 59->1 59->51 60->1 60->53 61->1 61->1 61->44 61->44 61->73 62->1 62->1 62->1 62->69 62->84 63->1 63->1 63->70 63->71 64->1 64->1 64->72 64->72 64->73 64->107 64->108 64->109 64->112 65->1 65->26 65->52 65->78 65->113 65->115 66->1 66->28 66->54 66->79 66->114 66->117 67->1 67->1 68->8 68->17 68->56 68->84 69->1 69->63 70->1 70->1 70->71 71->1 71->1 71->57 71->57 71->57 71->63 71->77 71->82 71->83 72->1 72->1 72->1 72->80 73->1 73->1 73->61 74->1 74->1 75->1 75->61 75->61 75->67 75->67 75->86 76->1 76->1 76->62 76->62 76->77 77->62 77->62 77->63 78->1 78->1 78->79 78->85 78->87 78->89 78->89 78->90 78->116 78->121 78->122 78->123 78->124 79->1 79->1 79->78 79->86 79->88 79->118 79->119 79->120 80->1 80->61 80->61 80->67 80->67 80->72 80->74 80->74 81->1 81->61 81->61 81->67 81->67 81->74 81->74 81->85 82->63 82->76 82->76 82->77 82->83 82->83 83->63 83->76 83->76 83->77 84->8 84->17 84->68 84->69 85->1 85->1 85->1 85->81 86->1 86->1 86->1 86->75 87->1 87->1 87->85 87->85 88->1 88->1 88->86 88->86 88->90 89->1 89->1 89->78 89->79 89->87 89->87 90->1 90->87 90->87 90->88
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T = 0 ; int N = 0 ; int sum [ 100 ] ; double rpi [ 100 ] ; double wp [ 100 ] ; double owp [ 100 ] ; double oowp [ 100 ] ; char wins ; long int intWins [ 100 ] [ 100 ] ; char * pEnd = NULL ; FILE * file = fopen ( "\x43\x3a\x5c\x5c\x55\x73\x65\x72\x73\x5c\x5c\x42\x61\x72\x62\x69\x65\x5c\x5c\x43\x6f\x64\x65\x6a\x61\x6d\x5c\x5c\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e\x0" , "r" ) ; FILE * file2 = fopen ( "C:\\Users\\Barbie\\Codejam\\output.txt" , "w" ) ; fscanf ( file , "%d" , & T ) ; for ( int i = 1 ; i <= T ; i ++ ) { fscanf ( file , "%d" , & N ) ; for ( int j = 0 ; j < ( N ) ; j ++ ) { for ( int k = 0 ; k < ( N ) ; k ++ ) { wins = getc ( file ) ; if ( ( wins != '0' ) && ( wins != '1' ) && ( wins != '.' ) ) wins = getc ( file ) ; if ( wins == '.' ) wins = '2' ; intWins [ j ] [ k ] = strtoul ( & wins , & pEnd , 10 ) ; } } for ( int j = 0 ; j < ( N ) ; j ++ ) { rpi [ j ] = 0 ; wp [ j ] = 0 ; owp [ j ] = 0 ; oowp [ j ] = 0 ; sum [ j ] = 0 ; } for ( int j = 0 ; j < ( N ) ; j ++ ) { for ( int k = 0 ; k < ( N ) ; k ++ ) { if ( intWins [ j ] [ k ] != 2 ) { wp [ j ] += intWins [ j ] [ k ] ; sum [ j ] += 1 ; } } } for ( int j = 0 ; j < ( N ) ; j ++ ) { for ( int k = 0 ; k < ( N ) ; k ++ ) { if ( ( j != k ) ) { if ( intWins [ k ] [ j ] != 2 ) { owp [ j ] += ( ( wp [ k ] - intWins [ k ] [ j ] ) / ( sum [ k ] - 1 ) ) ; } } } } for ( int j = 0 ; j < ( N ) ; j ++ ) { for ( int k = 0 ; k < ( N ) ; k ++ ) { if ( ( j != k ) ) { if ( intWins [ k ] [ j ] != 2 ) { oowp [ j ] += ( owp [ k ] ) / sum [ k ] ; } } } } for ( int j = 0 ; j < ( N ) ; j ++ ) { rpi [ j ] = ( 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ] ) / sum [ j ] ; } fprintf ( file2 , "Case #%d:\n" , i ) ; for ( int j = 0 ; j < ( N ) ; j ++ ) { fprintf ( file2 , "%.12f\n" , rpi [ j ] ) ; } } fclose ( file ) ; fclose ( file2 ) ; return 0 ; }
>>>Func
METHOD removeElement
METHOD_RETURN int
PARAM int * nums
PARAM int numsSize
PARAM int val
<operator>.assignment start = 0
RETURN return start ; return start ;
<operator>.lessThan i < numsSize
<operator>.postIncrement i ++
IDENTIFIER start return start ;
<operator>.assignment i = 0
<operator>.notEquals nums [ i ] != val
<operator>.assignment nums [ start ++ ] = nums [ i ]
<operator>.postIncrement start ++
<operator>.indirectIndexAccess nums [ i ]
<operator>.indirectIndexAccess nums [ start ++ ]
<operator>.indirectIndexAccess nums [ i ]
>>>PDG&17 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->13 2->1 2->11 2->12 3->7 4->1 4->11 5->1 5->1 5->9 5->13 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->11 7->14 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->1 11->12 11->12 11->13 11->15 11->16 12->1 12->1 12->1 13->1 13->9
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int removeElement ( int * nums , int numsSize , int val ) { int i , start = 0 ; for ( i = 0 ; i < numsSize ; i ++ ) { if ( nums [ i ] != val ) nums [ start ++ ] = nums [ i ] ; } return start ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
scanf scanf ( " %d" , & c )
scanf scanf ( " %d" , & d )
scanf scanf ( " %d" , & n )
scanf scanf ( " %s" , set )
printf printf ( "Case #%d: [" , i + 1 )
<operator>.assignment ctr_temp = 0
printf printf ( "]\n" )
<operator>.lessThan j < c
<operator>.postIncrement j ++
<operator>.lessThan j < d
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment j = 0
scanf scanf ( " %s" , combine [ j ] )
<operator>.assignment j = 0
scanf scanf ( " %s" , opposed [ j ] )
<operator>.assignment j = 1
<operator>.assignment flag_combine = 0
<operator>.assignment flag_opposed = 0
<operator>.addition i + 1
<operator>.assignment j = 0
<operator>.lessThan k < c
<operator>.postIncrement k ++
<operator>.lessThan k < d
<operator>.postIncrement k ++
<operator>.notEquals set [ j ] != '$'
<operator>.assignment k = 0
<operator>.assignment k = 0
<operator>.assignment ctr = j - 1
<operator>.assignment ltr = - 1
<operator>.postIncrement ctr_temp ++
<operator>.logicalOr ( combine [ k ] [ 0 ] == set [ j ] && combine [ k ] [ 1 ] == set [ j - 1 ] ) || ( combine [ k ] [ 0 ] == set [ j - 1 ] && combine [ k ] [ 1 ] == set [ j ] )
<operator>.equals set [ j ] == opposed [ k ] [ 0 ]
<operator>.equals ctr_temp == 1
<operator>.assignment set [ j - 1 ] = '$'
<operator>.assignment set [ j ] = combine [ k ] [ 2 ]
<operator>.assignment flag_combine = 1
<operator>.subtraction j - 1
<operator>.minus - 1
printf printf ( "%c" , set [ j ] )
<operator>.logicalAnd combine [ k ] [ 0 ] == set [ j ] && combine [ k ] [ 1 ] == set [ j - 1 ]
<operator>.logicalAnd combine [ k ] [ 0 ] == set [ j - 1 ] && combine [ k ] [ 1 ] == set [ j ]
LITERAL 1 while (1)
<operator>.notEquals ltr != - 1
printf printf ( ", %c" , set [ j ] )
<operator>.equals combine [ k ] [ 0 ] == set [ j ]
<operator>.equals combine [ k ] [ 1 ] == set [ j - 1 ]
<operator>.equals combine [ k ] [ 0 ] == set [ j - 1 ]
<operator>.equals combine [ k ] [ 1 ] == set [ j ]
<operator>.postDecrement ctr --
<operator>.equals set [ j ] == opposed [ k ] [ 1 ]
<operator>.subtraction j - 1
<operator>.equals ctr == - 1
<operator>.equals set [ ctr ] == opposed [ k ] [ 1 ]
<operator>.minus - 1
<operator>.lessEqualsThan l <= j
<operator>.postIncrement l ++
<operator>.subtraction j - 1
<operator>.subtraction j - 1
<operator>.assignment ltr = ctr
<operator>.assignment l = ltr
<operator>.assignment set [ l ] = '$'
LITERAL 1 while (1)
<operator>.notEquals ltr != - 1
<operator>.minus - 1
<operator>.postDecrement ctr --
<operator>.equals ctr == - 1
<operator>.equals set [ ctr ] == opposed [ k ] [ 0 ]
<operator>.minus - 1
<operator>.lessEqualsThan l <= j
<operator>.postIncrement l ++
<operator>.assignment ltr = ctr
<operator>.assignment l = ltr
<operator>.assignment set [ l ] = '$'
<operator>.minus - 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess combine [ j ]
<operator>.indirectIndexAccess opposed [ j ]
<operator>.indirectIndexAccess set [ j ]
<operator>.indirectIndexAccess set [ j ]
<operator>.indirectIndexAccess opposed [ k ] [ 0 ]
<operator>.indirectIndexAccess set [ j - 1 ]
<operator>.indirectIndexAccess set [ j ]
<operator>.indirectIndexAccess combine [ k ] [ 2 ]
<operator>.indirectIndexAccess opposed [ k ]
<operator>.indirectIndexAccess set [ j ]
<operator>.indirectIndexAccess combine [ k ] [ 0 ]
<operator>.indirectIndexAccess set [ j ]
<operator>.indirectIndexAccess combine [ k ] [ 1 ]
<operator>.indirectIndexAccess set [ j - 1 ]
<operator>.indirectIndexAccess combine [ k ] [ 0 ]
<operator>.indirectIndexAccess set [ j - 1 ]
<operator>.indirectIndexAccess combine [ k ] [ 1 ]
<operator>.indirectIndexAccess set [ j ]
<operator>.indirectIndexAccess combine [ k ]
<operator>.indirectIndexAccess set [ j ]
<operator>.indirectIndexAccess combine [ k ]
<operator>.indirectIndexAccess combine [ k ]
<operator>.indirectIndexAccess combine [ k ]
<operator>.indirectIndexAccess combine [ k ]
<operator>.indirectIndexAccess set [ j ]
<operator>.indirectIndexAccess opposed [ k ] [ 1 ]
<operator>.indirectIndexAccess set [ ctr ]
<operator>.indirectIndexAccess opposed [ k ] [ 1 ]
<operator>.indirectIndexAccess opposed [ k ]
<operator>.indirectIndexAccess opposed [ k ]
<operator>.indirectIndexAccess set [ l ]
<operator>.indirectIndexAccess set [ ctr ]
<operator>.indirectIndexAccess opposed [ k ] [ 0 ]
<operator>.indirectIndexAccess opposed [ k ]
<operator>.indirectIndexAccess set [ l ]
>>>PDG&124 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->41 0->44 0->45 0->47 0->48 0->49 0->50 0->53 0->54 0->55 0->60 0->62 0->63 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->79 0->80 0->81 0->82 0->83 0->84 0->85 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->14 4->15 4->17 4->19 4->21 4->23 4->25 4->27 4->30 4->30 4->31 4->86 4->87 4->88 5->1 5->4 6->3 7->1 7->4 8->1 8->15 8->32 9->1 9->17 9->34 10->1 10->19 10->21 11->1 11->36 11->43 11->50 11->55 11->56 11->57 11->58 11->59 11->61 11->64 11->78 12->1 12->1 13->1 13->1 13->41 14->1 15->1 15->1 15->8 15->15 15->16 15->16 15->24 15->32 15->89 16->1 16->15 17->1 17->1 17->9 17->17 17->18 17->18 17->26 17->34 17->90 18->1 18->17 19->19 19->20 19->20 19->21 19->28 19->29 19->32 19->34 19->37 19->38 19->48 19->62 19->68 19->69 20->1 20->19 21->1 21->1 21->1 21->10 21->19 21->21 21->22 21->22 21->36 21->91 22->1 22->21 23->15 24->1 25->17 26->1 27->1 27->19 28->1 28->1 29->1 29->1 31->1 31->21 32->1 32->1 32->8 32->15 32->33 32->42 32->51 32->56 32->99 32->100 32->109 33->1 33->32 34->1 34->1 34->1 34->9 34->17 34->34 34->35 34->35 34->39 34->40 34->43 34->48 34->49 34->92 34->93 34->97 35->1 35->34 36->1 36->1 36->11 36->41 36->43 36->44 36->50 36->55 36->56 37->32 38->1 38->34 39->1 39->1 39->1 39->63 39->77 40->1 40->1 40->1 40->54 40->74 41->1 41->44 42->1 42->1 42->1 42->32 42->33 42->45 42->46 42->47 42->62 42->94 42->95 42->96 42->107 43->1 43->1 43->1 43->11 43->36 43->54 43->56 43->61 43->61 43->63 43->65 43->75 43->78 43->113 43->114 43->117 44->1 44->1 44->41 44->50 44->55 44->98 44->108 45->1 45->1 45->11 45->57 45->58 46->1 46->1 46->1 46->11 46->36 46->43 46->56 47->1 47->1 48->20 48->39 48->39 48->66 48->80 49->40 50->1 50->1 50->11 50->36 50->43 50->56 51->1 51->1 51->42 51->42 51->52 51->58 51->69 51->103 51->104 51->111 52->1 52->1 52->42 52->42 54->1 54->1 54->1 54->66 54->71 54->71 55->1 55->1 55->11 55->36 55->43 55->56 56->1 56->1 56->11 56->36 56->43 56->51 56->51 56->57 56->58 56->59 56->68 56->101 56->102 56->110 57->1 57->1 57->11 57->51 57->51 57->58 57->59 58->1 58->1 58->11 58->52 58->52 58->56 58->57 58->59 58->105 58->106 58->112 59->1 59->1 59->11 59->36 59->43 59->52 59->52 59->56 59->57 60->1 60->1 60->63 61->1 61->1 61->1 61->11 61->36 61->43 61->56 61->64 61->74 61->77 61->79 61->85 62->20 62->48 63->1 63->1 63->60 63->64 63->70 63->115 63->116 63->118 64->1 64->1 64->1 64->11 64->60 64->61 64->63 64->70 64->75 64->78 65->54 66->1 66->1 66->20 66->48 66->66 66->67 66->67 66->72 66->119 67->1 67->66 68->20 68->48 68->62 68->69 69->20 69->48 69->62 69->68 70->1 70->1 70->54 71->1 71->1 71->66 72->1 72->1 72->11 74->1 74->1 74->1 74->80 74->83 74->83 75->63 76->1 76->1 76->77 77->1 77->1 77->76 77->78 77->82 77->120 77->121 77->122 78->1 78->1 78->1 78->11 78->43 78->64 78->76 78->77 78->82 78->85 79->74 80->1 80->1 80->20 80->48 80->80 80->81 80->81 80->84 80->123 81->1 81->80 82->1 82->1 82->74 83->1 83->1 83->80 84->1 84->1 84->11 85->77
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int t ; scanf ( "\x25\x64\x0" , & t ) ; int i ; int j ; int k ; int l ; int m ; for ( i = 0 ; i < t ; i ++ ) { int c ; char combine [ 38 ] [ 3 ] ; int d ; char opposed [ 30 ] [ 2 ] ; int n ; char set [ 102 ] ; scanf ( " %d" , & c ) ; for ( j = 0 ; j < c ; j ++ ) { scanf ( " %s" , combine [ j ] ) ; } scanf ( " %d" , & d ) ; for ( j = 0 ; j < d ; j ++ ) { scanf ( " %s" , opposed [ j ] ) ; } scanf ( " %d" , & n ) ; scanf ( " %s" , set ) ; int flag_combine ; int flag_opposed ; int ctr ; int ltr ; for ( j = 1 ; j < n ; j ++ ) { flag_combine = 0 ; flag_opposed = 0 ; for ( k = 0 ; k < c ; k ++ ) { if ( ( combine [ k ] [ 0 ] == set [ j ] && combine [ k ] [ 1 ] == set [ j - 1 ] ) || ( combine [ k ] [ 0 ] == set [ j - 1 ] && combine [ k ] [ 1 ] == set [ j ] ) ) { set [ j - 1 ] = '$' ; set [ j ] = combine [ k ] [ 2 ] ; flag_combine = 1 ; break ; } } for ( k = 0 ; k < d ; k ++ ) { ctr = j - 1 ; ltr = - 1 ; if ( set [ j ] == opposed [ k ] [ 0 ] ) { while ( 1 ) { if ( ctr == - 1 ) break ; if ( set [ ctr ] == opposed [ k ] [ 1 ] ) { ltr = ctr ; break ; } ctr -- ; } if ( ltr != - 1 ) { for ( l = ltr ; l <= j ; l ++ ) { set [ l ] = '$' ; } } } else if ( set [ j ] == opposed [ k ] [ 1 ] ) { while ( 1 ) { if ( ctr == - 1 ) break ; if ( set [ ctr ] == opposed [ k ] [ 0 ] ) { ltr = ctr ; break ; } ctr -- ; } if ( ltr != - 1 ) { for ( l = ltr ; l <= j ; l ++ ) { set [ l ] = '$' ; } } } } } printf ( "Case #%d: [" , i + 1 ) ; int ctr_temp = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( set [ j ] != '$' ) { ctr_temp ++ ; if ( ctr_temp == 1 ) { printf ( "%c" , set [ j ] ) ; } else printf ( ", %c" , set [ j ] ) ; } } printf ( "]\n" ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment N = 0
<operator>.assignment T = 0
<operator>.assignment Pd = 0
<operator>.assignment Pg = 0
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
scanf scanf ( "%d %d %d" , & N , & Pd , & Pg )
<operator>.logicalOr ( Pd != 100 && Pg == 100 ) || ( Pd == 0 && Pg > 0 ) || ( Pg == 0 && Pd > 0 )
<operator>.greaterEqualsThan N >= 100
printf printf ( "Case #%d: Broken\n" , i + 1 )
printf printf ( "Case #%d: Possible\n" , i + 1 )
<operator>.logicalOr ( Pd != 100 && Pg == 100 ) || ( Pd == 0 && Pg > 0 )
<operator>.logicalAnd Pg == 0 && Pd > 0
<operator>.logicalAnd Pd != 100 && Pg == 100
<operator>.logicalAnd Pd == 0 && Pg > 0
<operator>.equals Pg == 0
<operator>.greaterThan Pd > 0
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.logicalOr ( N >= 1 && Pd % 100 == 0 ) || ( N >= 2 && ( Pd % 50 == 0 ) ) || ( N >= 4 && ( Pd % 25 == 0 ) ) || ( N >= 5 && ( Pd % 20 == 0 ) ) || ( N >= 10 && ( Pd % 10 == 0 ) ) || ( N >= 25 && ( Pd % 4 == 0 ) ) || ( N >= 50 && ( Pd % 2 == 0 ) )
<operator>.notEquals Pd != 100
<operator>.equals Pg == 100
<operator>.equals Pd == 0
<operator>.greaterThan Pg > 0
printf printf ( "Case #%d: Possible\n" , i + 1 )
<operator>.logicalOr ( N >= 1 && Pd % 100 == 0 ) || ( N >= 2 && ( Pd % 50 == 0 ) ) || ( N >= 4 && ( Pd % 25 == 0 ) ) || ( N >= 5 && ( Pd % 20 == 0 ) ) || ( N >= 10 && ( Pd % 10 == 0 ) ) || ( N >= 25 && ( Pd % 4 == 0 ) )
<operator>.logicalAnd N >= 50 && ( Pd % 2 == 0 )
printf printf ( "Case #%d: Broken\n" , i + 1 )
<operator>.logicalOr ( N >= 1 && Pd % 100 == 0 ) || ( N >= 2 && ( Pd % 50 == 0 ) ) || ( N >= 4 && ( Pd % 25 == 0 ) ) || ( N >= 5 && ( Pd % 20 == 0 ) ) || ( N >= 10 && ( Pd % 10 == 0 ) )
<operator>.logicalAnd N >= 25 && ( Pd % 4 == 0 )
<operator>.greaterEqualsThan N >= 50
<operator>.equals Pd % 2 == 0
<operator>.addition i + 1
<operator>.logicalOr ( N >= 1 && Pd % 100 == 0 ) || ( N >= 2 && ( Pd % 50 == 0 ) ) || ( N >= 4 && ( Pd % 25 == 0 ) ) || ( N >= 5 && ( Pd % 20 == 0 ) )
<operator>.logicalAnd N >= 10 && ( Pd % 10 == 0 )
<operator>.greaterEqualsThan N >= 25
<operator>.equals Pd % 4 == 0
<operator>.modulo Pd % 2
<operator>.addition i + 1
<operator>.logicalOr ( N >= 1 && Pd % 100 == 0 ) || ( N >= 2 && ( Pd % 50 == 0 ) ) || ( N >= 4 && ( Pd % 25 == 0 ) )
<operator>.logicalAnd N >= 5 && ( Pd % 20 == 0 )
<operator>.greaterEqualsThan N >= 10
<operator>.equals Pd % 10 == 0
<operator>.modulo Pd % 4
<operator>.logicalOr ( N >= 1 && Pd % 100 == 0 ) || ( N >= 2 && ( Pd % 50 == 0 ) )
<operator>.logicalAnd N >= 4 && ( Pd % 25 == 0 )
<operator>.greaterEqualsThan N >= 5
<operator>.equals Pd % 20 == 0
<operator>.modulo Pd % 10
<operator>.logicalAnd N >= 1 && Pd % 100 == 0
<operator>.logicalAnd N >= 2 && ( Pd % 50 == 0 )
<operator>.greaterEqualsThan N >= 4
<operator>.equals Pd % 25 == 0
<operator>.modulo Pd % 20
<operator>.greaterEqualsThan N >= 1
<operator>.equals Pd % 100 == 0
<operator>.greaterEqualsThan N >= 2
<operator>.equals Pd % 50 == 0
<operator>.modulo Pd % 25
<operator>.modulo Pd % 100
<operator>.modulo Pd % 50
<operator>.addressOf & N
<operator>.addressOf & Pd
<operator>.addressOf & Pg
>>>PDG&70 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->21 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->33 0->36 0->37 0->38 0->41 0->42 0->43 0->44 0->47 0->48 0->49 0->52 0->53 0->54 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 2->1 2->1 2->12 2->14 3->1 3->6 3->8 4->1 4->1 4->26 5->1 5->1 5->21 5->27 5->29 6->1 6->8 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->12 8->13 8->15 8->16 8->17 8->19 8->23 8->24 8->26 8->30 8->33 8->38 8->44 8->67 8->68 8->69 9->1 9->8 10->7 11->1 11->8 12->1 12->1 12->1 12->14 12->36 12->41 12->47 12->52 12->57 12->60 12->62 13->1 13->1 13->1 13->14 13->15 13->23 14->1 14->1 14->12 14->16 14->24 14->25 14->31 14->34 14->39 14->45 14->50 14->55 14->60 14->60 15->1 15->1 16->1 16->1 17->1 17->1 17->13 17->13 17->18 17->21 18->1 18->1 18->13 18->13 19->1 19->1 19->17 19->17 19->20 19->28 20->1 20->1 20->17 20->17 21->1 21->18 21->18 21->22 21->27 21->29 22->1 22->18 22->18 22->26 22->43 22->49 22->54 22->59 22->64 22->65 22->66 25->1 25->1 25->1 25->30 25->33 25->38 25->44 26->1 26->19 26->19 26->22 26->27 26->28 26->43 26->49 26->54 26->59 26->64 26->65 26->66 27->1 27->19 27->19 27->21 27->29 28->1 28->20 28->20 28->22 28->26 28->29 28->43 28->49 28->54 28->59 28->64 28->65 28->66 29->1 29->20 29->20 29->21 29->27 30->1 30->1 31->1 31->1 31->25 31->25 31->32 31->36 32->1 32->1 32->25 32->25 33->1 33->1 34->1 34->1 34->31 34->31 34->35 34->41 35->1 35->1 35->31 35->31 36->1 36->12 36->14 36->32 36->32 36->37 36->43 37->1 37->32 37->32 39->1 39->1 39->34 39->34 39->40 39->47 40->1 40->1 40->34 40->34 41->1 41->12 41->14 41->35 41->35 41->36 41->42 41->49 42->1 42->35 42->35 43->1 43->26 43->37 43->37 45->1 45->1 45->39 45->39 45->46 45->52 46->1 46->1 46->39 46->39 47->1 47->12 47->14 47->36 47->40 47->40 47->41 47->48 47->54 48->1 48->40 48->40 49->1 49->26 49->42 49->42 49->43 50->1 50->1 50->45 50->45 50->51 50->57 51->1 51->1 51->45 51->45 52->1 52->12 52->14 52->36 52->41 52->46 52->46 52->47 52->53 52->59 53->1 53->46 53->46 54->1 54->26 54->43 54->48 54->48 54->49 55->1 55->1 55->50 55->50 55->56 55->62 56->1 56->1 56->50 56->50 57->1 57->12 57->14 57->36 57->41 57->47 57->51 57->51 57->52 57->58 57->64 58->1 58->51 58->51 59->1 59->26 59->43 59->49 59->53 59->53 59->54 60->1 60->12 60->14 60->36 60->41 60->47 60->52 60->55 60->55 60->57 60->61 60->62 60->65 61->1 61->55 61->55 62->1 62->12 62->14 62->36 62->41 62->47 62->52 62->56 62->56 62->57 62->63 62->66 63->1 63->56 63->56 64->1 64->26 64->43 64->49 64->54 64->58 64->58 64->59 65->1 65->26 65->43 65->49 65->54 65->59 65->61 65->61 65->64 65->66 66->1 66->26 66->43 66->49 66->54 66->59 66->63 66->63 66->64
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int N = 0 ; int T = 0 ; int Pd = 0 , Pg = 0 ; int i , j ; scanf ( "\x25\x64\x0" , & T ) ; for ( i = 0 ; i < T ; i ++ ) { scanf ( "%d %d %d" , & N , & Pd , & Pg ) ; if ( ( Pd != 100 && Pg == 100 ) || ( Pd == 0 && Pg > 0 ) || ( Pg == 0 && Pd > 0 ) ) { printf ( "Case #%d: Broken\n" , i + 1 ) ; continue ; } if ( N >= 100 ) { printf ( "Case #%d: Possible\n" , i + 1 ) ; continue ; } else { if ( ( N >= 1 && Pd % 100 == 0 ) || ( N >= 2 && ( Pd % 50 == 0 ) ) || ( N >= 4 && ( Pd % 25 == 0 ) ) || ( N >= 5 && ( Pd % 20 == 0 ) ) || ( N >= 10 && ( Pd % 10 == 0 ) ) || ( N >= 25 && ( Pd % 4 == 0 ) ) || ( N >= 50 && ( Pd % 2 == 0 ) ) ) { printf ( "Case #%d: Possible\n" , i + 1 ) ; continue ; } else { printf ( "Case #%d: Broken\n" , i + 1 ) ; continue ; } } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & Z )
RETURN return 0 ; return 0 ;
<operator>.lessThan z < Z
<operator>.postIncrement z ++
LITERAL 0 return 0 ;
<operator>.assignment z = 0
scanf scanf ( "%d %d" , & K , & n )
<operator>.assignment p = - 1
printf printf ( "Case #%d: " , z + 1 )
printf printf ( "\n" )
<operator>.lessThan i < n
<operator>.postIncrement i ++
scanf scanf ( "%d" , & ind [ i ] )
<operator>.lessThan i < K
<operator>.postIncrement i ++
<operator>.lessEqualsThan v <= K
<operator>.postIncrement v ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
printf printf ( "%d " , c [ ind [ i ] - 1 ] )
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment c [ i ] = 0
<operator>.assignment w [ i ] = i
<operator>.minus - 1
<operator>.assignment v = 1
<operator>.assignment m = K + 1 - v
<operator>.assignment p = ( p + v ) % m
<operator>.assignment c [ w [ p ] ] = v
<operator>.postDecrement p --
<operator>.addition z + 1
<operator>.assignment i = 0
<operator>.lessThan i < m
<operator>.postIncrement i ++
<operator>.assignment w [ i ] = w [ i + 1 ]
<operator>.subtraction K + 1 - v
<operator>.modulo ( p + v ) % m
<operator>.assignment i = p
<operator>.subtraction ind [ i ] - 1
<operator>.addition K + 1
<operator>.addition p + v
<operator>.addition i + 1
<operator>.addressOf & K
<operator>.addressOf & n
<operator>.addressOf & ind [ i ]
<operator>.indirectIndexAccess c [ ind [ i ] - 1 ]
<operator>.indirectIndexAccess ind [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess c [ w [ p ] ]
<operator>.indirectIndexAccess w [ p ]
<operator>.indirectIndexAccess w [ i ]
<operator>.indirectIndexAccess w [ i + 1 ]
<operator>.indirectIndexAccess ind [ i ]
>>>PDG&56 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->30 0->31 0->32 0->33 0->34 0->35 0->37 0->38 0->39 0->40 0->41 0->42 0->43 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->10 4->11 4->12 4->15 4->17 4->19 4->22 4->23 4->26 4->27 4->32 4->32 4->33 4->44 4->45 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->15 8->17 8->37 8->41 9->1 9->1 9->1 9->38 9->42 10->1 10->1 11->1 12->12 12->13 12->13 12->14 12->19 12->46 12->48 13->1 13->12 14->1 14->40 15->1 15->15 15->16 15->16 15->17 15->24 15->25 15->25 15->49 15->50 16->1 16->15 17->1 17->1 17->1 17->8 17->15 17->17 17->18 17->28 17->29 17->30 17->31 17->34 17->37 17->37 17->37 17->38 17->39 17->41 17->41 17->42 17->51 17->52 18->1 18->17 19->1 19->1 19->1 19->12 19->19 19->20 19->20 19->21 19->40 19->47 19->55 20->1 20->19 21->1 21->1 22->12 23->15 24->1 24->1 25->1 25->1 26->9 27->1 27->17 28->1 28->1 28->38 29->1 29->1 29->31 29->39 30->1 30->1 31->1 31->1 31->38 31->42 33->1 33->19 34->1 34->1 34->34 34->35 34->35 34->36 34->43 34->43 34->53 34->54 35->1 35->34 36->1 36->1 36->1 37->1 37->18 37->28 37->28 37->30 37->38 37->42 38->1 38->29 38->29 38->34 39->1 39->34 40->1 40->14
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int c [ 1000000 ] , w [ 1000000 ] , n , Z , z , ind [ 100 ] , K , i , p , v , m ; scanf ( "\x25\x64\x0" , & Z ) ; for ( z = 0 ; z < Z ; z ++ ) { scanf ( "%d %d" , & K , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & ind [ i ] ) ; for ( i = 0 ; i < K ; i ++ ) { c [ i ] = 0 ; w [ i ] = i ; } p = - 1 ; for ( v = 1 ; v <= K ; v ++ ) { m = K + 1 - v ; p = ( p + v ) % m ; c [ w [ p ] ] = v ; for ( i = p ; i < m ; i ++ ) w [ i ] = w [ i + 1 ] ; p -- ; } printf ( "Case #%d: " , z + 1 ) ; for ( i = 0 ; i < n ; i ++ ) printf ( "%d " , c [ ind [ i ] - 1 ] ) ; printf ( "\n" ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment casen = 1
scanf scanf ( "\x25\x64\x0" , & cases )
RETURN return 0 ; return 0 ;
<operator>.postDecrement cases --
LITERAL 0 return 0 ;
<operator>.assignment d = 0
<operator>.assignment div [ 8 ] = { 100   50   25   20   10   5   2   1 }
scanf scanf ( "%d %d %d" , & n , & pd , & pg )
printf printf ( "Case #%d: %s\n" , casen ++ , str )
<operator>.lessThan i < 8
<operator>.postIncrement i ++
<operator>.lessThan i < 8
<operator>.lessEqualsThan d <= n
<operator>.arrayInitializer { 100   50   25   20   10   5   2   1 }
<operator>.assignment i = 0
<operator>.assignment d = 100 / div [ i ]
<operator>.postIncrement casen ++
<operator>.equals pd % div [ i ] == 0
<operator>.equals pg == 100
<operator>.assignment str = "Broken"
<operator>.division 100 / div [ i ]
<operator>.modulo pd % div [ i ]
<operator>.equals pd == 100
<operator>.assignment str = "Possible"
<operator>.equals pg == 0
<operator>.assignment str = "Broken"
<operator>.equals pd == 0
<operator>.assignment str = "Possible"
<operator>.assignment str = "Possible"
<operator>.assignment str = "Broken"
<operator>.addressOf & n
<operator>.addressOf & pd
<operator>.addressOf & pg
<operator>.indirectIndexAccess div [ i ]
<operator>.indirectIndexAccess div [ i ]
>>>PDG&37 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->1 2->1 2->18 3->1 3->5 4->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->13 5->14 5->15 5->16 5->18 5->32 5->33 5->34 6->4 7->1 7->14 8->1 8->1 8->1 8->22 8->23 9->1 9->1 9->1 9->14 10->1 10->1 10->1 11->12 11->13 11->19 11->23 11->36 12->1 12->11 13->1 13->1 13->17 13->22 13->35 14->1 14->1 14->1 14->9 14->20 14->21 15->8 15->8 15->8 15->8 15->8 15->8 15->8 15->8 16->1 16->11 17->1 17->1 17->14 18->1 18->10 19->1 19->1 19->11 19->12 20->1 20->1 20->24 20->26 20->26 21->1 21->10 22->1 22->17 22->17 22->23 23->1 23->1 23->19 23->19 23->22 23->24 23->28 24->1 24->1 24->23 24->25 24->27 24->28 25->1 25->10 26->1 26->1 26->20 26->28 26->29 27->1 27->10 28->1 28->1 28->23 28->24 28->30 28->31 29->1 29->10 30->1 30->10 31->1 31->10
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int cases , casen = 1 ; scanf ( "\x25\x64\x0" , & cases ) ; while ( cases -- ) { int n , pd , pg ; int d = 0 ; int i ; int div [ 8 ] = { 100 , 50 , 25 , 20 , 10 , 5 , 2 , 1 } ; char * str ; scanf ( "%d %d %d" , & n , & pd , & pg ) ; for ( i = 0 ; i < 8 ; i ++ ) { if ( pd % div [ i ] == 0 ) { break ; } } if ( i < 8 ) { d = 100 / div [ i ] ; } if ( d <= n ) { if ( pg == 100 ) { if ( pd == 100 ) { str = "Possible" ; } else { str = "Broken" ; } } else if ( pg == 0 ) { if ( pd == 0 ) { str = "Possible" ; } else { str = "Broken" ; } } else { str = "Possible" ; } } else { str = "Broken" ; } printf ( "Case #%d: %s\n" , casen ++ , str ) ; } return 0 ; }
>>>Func
METHOD decimal_to_octal
METHOD_RETURN int
PARAM int decimal
<operator>.logicalAnd ( decimal < 8 ) && ( decimal > 0 )
RETURN return decimal ; return decimal ;
<operator>.lessThan decimal < 8
<operator>.greaterThan decimal > 0
IDENTIFIER decimal return decimal ;
<operator>.equals decimal == 0
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
RETURN return ( ( decimal_to_octal ( decimal / 8 ) * 10 ) + decimal % 8 ) ; return ( ( decimal_to_octal ( decimal / 8 ) * 10 ) + decimal % 8 ) ;
<operator>.addition ( decimal_to_octal ( decimal / 8 ) * 10 ) + decimal % 8
<operator>.multiplication decimal_to_octal ( decimal / 8 ) * 10
<operator>.modulo decimal % 8
decimal_to_octal decimal_to_octal ( decimal / 8 )
<operator>.division decimal / 8
>>>PDG&17 0->2 0->5 0->6 0->7 0->8 0->9 0->10 0->13 0->14 0->16 2->5 3->1 3->1 3->1 3->4 3->8 4->1 5->1 5->3 5->3 5->6 5->6 5->7 5->8 6->1 6->3 6->3 6->7 6->8 7->4 8->9 8->11 8->12 8->13 8->14 8->15 8->16 8->16 9->1 10->9 11->1 12->11 13->12 13->12 14->12 14->12 15->13 16->14 16->15 16->15
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int decimal_to_octal ( int decimal ) { if ( ( decimal < 8 ) && ( decimal > 0 ) ) { return decimal ; } else if ( decimal == 0 ) { return 0 ; } else { return ( ( decimal_to_octal ( decimal / 8 ) * 10 ) + decimal % 8 ) ; } }
>>>Func
METHOD getOne
METHOD_RETURN char*
PARAM char c
IDENTIFIER c switch(c)
LITERAL '9' <empty>
RETURN return "\x49\x58\x0" ; return "\x49\x58\x0" ;
LITERAL '8' <empty>
RETURN return "VIII" ; return "VIII" ;
LITERAL '7' <empty>
RETURN return "VII" ; return "VII" ;
LITERAL '6' <empty>
RETURN return "VI" ; return "VI" ;
LITERAL '5' <empty>
RETURN return "V" ; return "V" ;
LITERAL '4' <empty>
RETURN return "IV" ; return "IV" ;
LITERAL '3' <empty>
RETURN return "III" ; return "III" ;
LITERAL '2' <empty>
RETURN return "II" ; return "II" ;
LITERAL '1' <empty>
RETURN return "I" ; return "I" ;
LITERAL '0' <empty>
RETURN return "" ; return "" ;
RETURN return NULL ; return NULL ;
LITERAL "\x49\x58\x0" return "\x49\x58\x0" ;
LITERAL "VIII" return "VIII" ;
LITERAL "VII" return "VII" ;
LITERAL "VI" return "VI" ;
LITERAL "V" return "V" ;
LITERAL "IV" return "IV" ;
LITERAL "III" return "III" ;
LITERAL "II" return "II" ;
LITERAL "I" return "I" ;
LITERAL "" return "" ;
IDENTIFIER NULL return NULL ;
>>>PDG&36 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 2->1 5->1 7->1 9->1 11->1 13->1 15->1 17->1 19->1 21->1 23->1 24->1 25->5 26->7 27->9 28->11 29->13 30->15 31->17 32->19 33->21 34->23 35->24
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) char * getOne ( char c ) { switch ( c ) { case '9' : return "\x49\x58\x0" ; case '8' : return "VIII" ; case '7' : return "VII" ; case '6' : return "VI" ; case '5' : return "V" ; case '4' : return "IV" ; case '3' : return "III" ; case '2' : return "II" ; case '1' : return "I" ; case '0' : return "" ; default : return NULL ; } }
>>>Func
METHOD cmpvalue
METHOD_RETURN int
PARAM const void * a
PARAM const void * b
RETURN return * ( int * ) b - * ( int * ) a ; return * ( int * ) b - * ( int * ) a ;
<operator>.subtraction * ( int * ) b - * ( int * ) a
<operator>.cast ( int * ) b
<operator>.cast ( int * ) a
>>>PDG&8 0->2 0->3 0->6 0->7 2->7 3->6 4->1 5->1 5->1 5->1 5->4 6->1 7->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int cmpvalue ( const void * a , const void * b ) { return * ( int * ) b - * ( int * ) a ; }
>>>Func
METHOD announce_mkdir
METHOD_RETURN void
PARAM char const * dir
PARAM void * options
<operator>.assignment * o = options
prog_fprintf prog_fprintf ( stdout   o -> created_directory_format   quoteaf ( dir ) )
quoteaf quoteaf ( dir )
<operator>.indirectFieldAccess o -> created_directory_format
<operator>.indirectFieldAccess o -> created_directory_format
FIELD_IDENTIFIER created_directory_format created_directory_format
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 2->6 3->4 4->1 4->1 4->1 5->1 5->1 5->1 5->1 6->1 6->5 7->5 7->6 7->8 7->9
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static void announce_mkdir ( char const * dir , void * options ) { struct mkdir_options const * o = options ; if ( o -> created_directory_format ) prog_fprintf ( stdout , o -> created_directory_format , quoteaf ( dir ) ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.lessThan printf <missing
<operator>.greaterThan ';'> ( "\x5c\x6e\x20\x65\x6e\x74\x65\x72\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x74\x65\x73\x74\x20\x63\x61\x73\x65\x73\x20\x0" )
RETURN return 0 ; return 0 ;
<operator>.lessThan k < n_of_test_cases
<operator>.postIncrement k ++
LITERAL 0 return 0 ;
<operator>.assignment k = 0
memset memset ( convert_array   0   26 * 26 * sizeof ( int ) )
memset memset ( destroy_array   0   26 * 26 * sizeof ( int ) )
memset memset ( is_present   0   26 * sizeof ( int ) )
<operator>.lessThan printf <missing
<operator>.greaterThan ';'> ( "\n Enter the number of combing strings followed by strings" )
<operator>.lessThan printf <missing
<operator>.greaterThan ';'> ( "\n enter the number of destroying strings " )
<operator>.lessThan printf <missing
<operator>.greaterThan ';'> ( "\n Enter the string length followed by string " )
scanf scanf ( " %s" , string_call )
<operator>.assignment is_present [ string_call [ 0 ] - 'A' ] = 1
<operator>.assignment final_string [ 0 ] = string_call [ 0 ]
<operator>.assignment final_string_index = 0
<operator>.assignment final_string [ ++ final_string_index ] = '\0'
<operator>.lessThan printf <missing
<operator>.greaterThan ';'> ( "\n the final string is %s " , final_string )
printf printf ( "]\n" )
IDENTIFIER ndif <empty>
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan l < final_string_index
<operator>.postIncrement l ++
<operator>.multiplication 26 * 26 * sizeof ( int )
<operator>.multiplication 26 * 26 * sizeof ( int )
<operator>.multiplication 26 * sizeof ( int )
<operator>.assignment i = 0
scanf scanf ( " %s" , temp_string )
<operator>.assignment convert_array [ temp_string [ 0 ] - 'A' ] [ temp_string [ 1 ] - 'A' ] = convert_array [ temp_string [ 1 ] - 'A' ] [ temp_string [ 0 ] - 'A' ] = temp_string [ 2 ]
<operator>.assignment i = 0
scanf scanf ( " %s" , temp_string )
<operator>.assignment destroy_array [ temp_string [ 0 ] - 'A' ] [ temp_string [ 1 ] - 'A' ] = destroy_array [ temp_string [ 1 ] - 'A' ] [ temp_string [ 0 ] - 'A' ] = 1
<operator>.assignment i = 1
<operator>.assignment flag = 0
<operator>.assignment ch = string_call [ i ]
<operator>.bracketedPrimary ( "\n the final string is %s " , final_string )
<operator>.assignment l = 0
<operator>.multiplication 26 * 26
<operator>.multiplication 26 * 26
<operator>.sizeOf sizeof ( int )
<operator>.subtraction string_call [ 0 ] - 'A'
<operator>.notEquals final_string_index != - 1
<operator>.preIncrement ++ final_string_index
<operator>.expressionList "\n the final string is %s "   final_string
<operator>.notEquals l != final_string_index - 1
<operator>.assignment convert_array [ temp_string [ 1 ] - 'A' ] [ temp_string [ 0 ] - 'A' ] = temp_string [ 2 ]
<operator>.assignment destroy_array [ temp_string [ 1 ] - 'A' ] [ temp_string [ 0 ] - 'A' ] = 1
printf printf ( "%c, " , final_string [ l ] )
<operator>.subtraction temp_string [ 1 ] - 'A'
<operator>.subtraction temp_string [ 1 ] - 'A'
<operator>.minus - 1
<operator>.notEquals ( temp_ch = convert_array [ ch - 'A' ] [ final_string [ final_string_index ] - 'A' ] ) != 0
<operator>.logicalNot ! flag
<operator>.assignment final_string [ ++ final_string_index ] = ch
<operator>.postIncrement is_present [ final_string [ final_string_index ] - 'A' ] ++
<operator>.subtraction final_string_index - 1
printf printf ( "%c" , final_string [ l ] )
<operator>.subtraction temp_string [ 0 ] - 'A'
<operator>.subtraction temp_string [ 0 ] - 'A'
<operator>.subtraction temp_string [ 0 ] - 'A'
<operator>.subtraction temp_string [ 0 ] - 'A'
<operator>.postDecrement is_present [ final_string [ final_string_index ] - 'A' ] --
<operator>.assignment final_string [ final_string_index ] = temp_ch
<operator>.postIncrement is_present [ final_string [ final_string_index ] - 'A' ] ++
<operator>.assignment flag = 1
<operator>.assignment final_string [ ++ final_string_index ] = ch
<operator>.postIncrement is_present [ final_string [ final_string_index ] - 'A' ] ++
<operator>.subtraction temp_string [ 1 ] - 'A'
<operator>.subtraction temp_string [ 1 ] - 'A'
<operator>.assignment temp_ch = convert_array [ ch - 'A' ] [ final_string [ final_string_index ] - 'A' ]
<operator>.lessThan j < 26
<operator>.postIncrement j ++
<operator>.preIncrement ++ final_string_index
<operator>.subtraction final_string [ final_string_index ] - 'A'
<operator>.subtraction final_string [ final_string_index ] - 'A'
<operator>.subtraction final_string [ final_string_index ] - 'A'
<operator>.subtraction final_string [ final_string_index ] - 'A'
<operator>.assignment j = 0
<operator>.preIncrement ++ final_string_index
<operator>.subtraction final_string [ final_string_index ] - 'A'
<operator>.subtraction ch - 'A'
<operator>.logicalAnd is_present [ j ] && destroy_array [ ch - 'A' ] [ j ]
<operator>.assignment final_string_index = - 1
memset memset ( is_present   0   26 * sizeof ( int ) )
<operator>.assignment flag = 1
<operator>.minus - 1
<operator>.multiplication 26 * sizeof ( int )
<operator>.subtraction ch - 'A'
<operator>.sizeOf sizeof ( int )
UNKNOWN _ _
UNKNOWN g g
UNKNOWN f f
UNKNOWN <missing ';'> ( "%d" , & C ) ; <missing ';'> ( "%d" , & C ) ;
UNKNOWN _ _
UNKNOWN g g
UNKNOWN f f
UNKNOWN <missing ';'> ( "%d" , & D ) ; <missing ';'> ( "%d" , & D ) ;
UNKNOWN _ _
UNKNOWN g g
UNKNOWN f f
UNKNOWN <missing ';'> ( "%d" , & N ) ; <missing ';'> ( "%d" , & N ) ;
UNKNOWN _ _
UNKNOWN g g
UNKNOWN f f
UNKNOWN <missing ';'> ( "Case #%d: [" , k + 1 ) ; <missing ';'> ( "Case #%d: [" , k + 1 ) ;
UNKNOWN f f
<operator>.indirectIndexAccess is_present [ string_call [ 0 ] - 'A' ]
<operator>.indirectIndexAccess final_string [ 0 ]
<operator>.indirectIndexAccess string_call [ 0 ]
<operator>.indirectIndexAccess final_string [ ++ final_string_index ]
<operator>.sizeOf sizeof ( int )
<operator>.sizeOf sizeof ( int )
<operator>.indirectIndexAccess convert_array [ temp_string [ 0 ] - 'A' ] [ temp_string [ 1 ] - 'A' ]
<operator>.indirectIndexAccess destroy_array [ temp_string [ 0 ] - 'A' ] [ temp_string [ 1 ] - 'A' ]
<operator>.indirectIndexAccess string_call [ 0 ]
<operator>.indirectIndexAccess string_call [ i ]
<operator>.indirectIndexAccess convert_array [ temp_string [ 0 ] - 'A' ]
<operator>.indirectIndexAccess convert_array [ temp_string [ 1 ] - 'A' ] [ temp_string [ 0 ] - 'A' ]
<operator>.indirectIndexAccess temp_string [ 2 ]
<operator>.indirectIndexAccess destroy_array [ temp_string [ 0 ] - 'A' ]
<operator>.indirectIndexAccess destroy_array [ temp_string [ 1 ] - 'A' ] [ temp_string [ 0 ] - 'A' ]
<operator>.indirectIndexAccess temp_string [ 1 ]
<operator>.indirectIndexAccess convert_array [ temp_string [ 1 ] - 'A' ]
<operator>.indirectIndexAccess temp_string [ 1 ]
<operator>.indirectIndexAccess destroy_array [ temp_string [ 1 ] - 'A' ]
<operator>.indirectIndexAccess final_string [ l ]
<operator>.indirectIndexAccess temp_string [ 0 ]
<operator>.indirectIndexAccess temp_string [ 0 ]
<operator>.indirectIndexAccess temp_string [ 0 ]
<operator>.indirectIndexAccess temp_string [ 0 ]
<operator>.indirectIndexAccess final_string [ ++ final_string_index ]
<operator>.indirectIndexAccess is_present [ final_string [ final_string_index ] - 'A' ]
<operator>.indirectIndexAccess final_string [ l ]
<operator>.indirectIndexAccess temp_string [ 1 ]
<operator>.indirectIndexAccess temp_string [ 1 ]
<operator>.indirectIndexAccess convert_array [ ch - 'A' ] [ final_string [ final_string_index ] - 'A' ]
<operator>.indirectIndexAccess is_present [ final_string [ final_string_index ] - 'A' ]
<operator>.indirectIndexAccess final_string [ final_string_index ]
<operator>.indirectIndexAccess is_present [ final_string [ final_string_index ] - 'A' ]
<operator>.indirectIndexAccess final_string [ ++ final_string_index ]
<operator>.indirectIndexAccess is_present [ final_string [ final_string_index ] - 'A' ]
<operator>.indirectIndexAccess convert_array [ ch - 'A' ]
<operator>.indirectIndexAccess final_string [ final_string_index ]
<operator>.indirectIndexAccess final_string [ final_string_index ]
<operator>.indirectIndexAccess final_string [ final_string_index ]
<operator>.indirectIndexAccess final_string [ final_string_index ]
<operator>.indirectIndexAccess final_string [ final_string_index ]
<operator>.indirectIndexAccess is_present [ j ]
<operator>.indirectIndexAccess destroy_array [ ch - 'A' ] [ j ]
<operator>.indirectIndexAccess destroy_array [ ch - 'A' ]
>>>PDG&162 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->37 0->38 0->39 0->41 0->42 0->43 0->44 0->45 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->56 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->67 0->68 0->69 0->70 0->71 0->72 0->74 0->76 0->77 0->79 0->80 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->95 0->96 0->97 0->98 0->99 2->1 2->1 2->1 2->12 2->12 3->1 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->17 5->18 5->19 5->20 5->21 5->22 5->23 5->24 5->25 5->27 5->29 5->31 5->33 5->35 5->36 5->37 5->38 5->41 5->44 5->47 5->48 5->49 5->50 5->51 5->52 5->54 5->55 5->101 5->102 5->103 5->104 5->105 5->106 5->107 5->108 5->109 5->110 5->111 5->112 5->113 5->114 5->115 5->116 5->117 5->118 5->119 5->120 5->121 5->122 5->123 5->126 6->1 6->5 7->4 8->1 8->5 9->1 9->1 10->1 10->1 10->1 11->1 11->1 11->1 11->66 11->73 11->75 11->78 11->93 11->95 12->14 12->14 13->1 14->16 14->16 15->1 16->23 16->23 17->1 18->1 18->20 18->46 18->52 19->1 19->1 19->11 19->95 20->1 20->1 20->1 20->55 21->1 21->53 21->54 22->1 22->1 22->55 23->1 23->1 23->1 23->12 23->12 24->1 24->1 25->1 27->1 27->1 27->27 27->28 27->28 27->39 27->40 27->57 27->60 27->69 27->70 27->79 27->124 27->128 27->129 27->130 27->133 27->134 27->138 27->139 27->145 28->1 28->27 29->1 29->1 29->29 29->30 29->30 29->42 29->43 29->58 29->61 29->71 29->72 29->80 29->125 29->131 29->132 29->135 29->136 29->140 29->141 29->146 30->1 30->29 31->1 31->1 31->1 31->31 31->32 31->32 31->45 31->46 31->53 31->62 31->127 32->1 32->31 33->1 33->1 33->1 33->33 33->34 33->56 33->56 33->67 33->67 34->1 34->33 35->9 36->1 36->10 37->11 38->27 39->1 39->40 39->42 39->57 39->60 39->69 39->70 39->79 40->1 40->1 40->1 41->1 41->29 42->1 42->39 42->61 42->71 42->72 42->80 43->1 43->1 43->1 44->1 44->31 45->1 45->1 45->64 46->1 46->1 46->65 46->92 47->1 47->24 48->1 48->33 49->35 50->36 51->1 52->18 52->20 53->1 53->1 53->54 53->63 53->64 53->65 53->66 53->81 53->84 53->84 53->85 53->86 53->90 53->92 53->142 53->143 53->147 53->153 53->154 53->155 54->33 55->1 55->47 55->47 55->59 55->68 55->85 55->86 55->87 55->88 55->91 56->1 56->1 56->34 56->59 56->68 56->137 56->144 57->1 57->1 57->40 58->1 58->43 59->1 59->1 59->55 59->68 60->79 61->80 62->53 63->1 63->1 63->73 63->74 63->75 63->76 63->82 63->87 63->88 63->89 63->148 63->149 63->150 63->156 63->157 64->1 64->1 64->77 64->78 64->90 64->91 64->151 64->152 64->158 65->1 65->1 66->1 66->1 66->11 66->73 66->78 66->95 67->33 67->56 67->56 68->1 68->1 68->55 68->59 69->70 70->1 70->39 70->42 70->69 70->71 71->72 72->1 72->39 72->42 72->69 72->71 73->1 73->75 74->1 74->1 74->88 75->1 75->1 75->11 75->66 75->73 75->78 75->95 76->1 76->64 77->1 77->1 78->1 78->1 78->11 78->66 78->73 78->95 79->1 79->39 79->42 79->60 79->61 80->1 80->39 80->42 80->60 80->61 81->1 81->1 81->63 81->74 82->1 82->1 82->83 82->93 82->159 83->1 83->82 84->53 84->54 85->1 85->55 85->86 86->1 86->55 86->85 86->87 86->91 88->1 88->55 88->85 88->86 88->91 89->1 89->82 90->53 90->54 91->1 91->55 91->85 91->86 92->1 92->77 92->99 93->1 93->1 93->1 93->11 93->82 93->83 93->94 93->95 93->95 93->96 93->97 93->98 93->100 94->1 94->1 94->53 94->54 94->90 95->1 95->1 95->1 95->11 95->66 95->73 95->75 95->78 95->93 96->1 96->64 97->94 98->95 99->1 99->77 100->1 159->99 159->160 159->161
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int n_of_test_cases ; int C , D ; int N ; int convert_array [ 26 ] [ 26 ] ; int destroy_array [ 26 ] [ 26 ] ; int i , j , k , l ; char string_call [ 101 ] ; char final_string [ 101 ] ; int final_string_index ; char temp_string [ 4 ] ; int is_present [ 26 ] ; def __debug__ printf <missing ';'> ( "\x5c\x6e\x20\x65\x6e\x74\x65\x72\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x74\x65\x73\x74\x20\x63\x61\x73\x65\x73\x20\x0" ) ; ndif scanf <missing ';'> ( "%d" , & n_of_test_cases ) ; for ( k = 0 ; k < n_of_test_cases ; k ++ ) { memset ( convert_array , 0 , 26 * 26 * sizeof ( int ) ) ; memset ( destroy_array , 0 , 26 * 26 * sizeof ( int ) ) ; memset ( is_present , 0 , 26 * sizeof ( int ) ) ; def __debug__ printf <missing ';'> ( "\n Enter the number of combing strings followed by strings" ) ; ndif scanf <missing ';'> ( "%d" , & C ) ; for ( i = 0 ; i < C ; i ++ ) { scanf ( " %s" , temp_string ) ; convert_array [ temp_string [ 0 ] - 'A' ] [ temp_string [ 1 ] - 'A' ] = convert_array [ temp_string [ 1 ] - 'A' ] [ temp_string [ 0 ] - 'A' ] = temp_string [ 2 ] ; } def __debug__ printf <missing ';'> ( "\n enter the number of destroying strings " ) ; ndif scanf <missing ';'> ( "%d" , & D ) ; for ( i = 0 ; i < D ; i ++ ) { scanf ( " %s" , temp_string ) ; destroy_array [ temp_string [ 0 ] - 'A' ] [ temp_string [ 1 ] - 'A' ] = destroy_array [ temp_string [ 1 ] - 'A' ] [ temp_string [ 0 ] - 'A' ] = 1 ; } def __debug__ printf <missing ';'> ( "\n Enter the string length followed by string " ) ; ndif scanf <missing ';'> ( "%d" , & N ) ; scanf ( " %s" , string_call ) ; is_present [ string_call [ 0 ] - 'A' ] = 1 ; final_string [ 0 ] = string_call [ 0 ] ; final_string_index = 0 ; for ( i = 1 ; i < N ; i ++ ) { char ch ; char temp_ch ; int flag = 0 ; ch = string_call [ i ] ; if ( final_string_index != - 1 ) { if ( ( temp_ch = convert_array [ ch - 'A' ] [ final_string [ final_string_index ] - 'A' ] ) != 0 ) { is_present [ final_string [ final_string_index ] - 'A' ] -- ; final_string [ final_string_index ] = temp_ch ; is_present [ final_string [ final_string_index ] - 'A' ] ++ ; flag = 1 ; } else { for ( j = 0 ; j < 26 ; j ++ ) { if ( is_present [ j ] && destroy_array [ ch - 'A' ] [ j ] ) { final_string_index = - 1 ; memset ( is_present , 0 , 26 * sizeof ( int ) ) ; flag = 1 ; break ; } } } if ( ! flag ) { final_string [ ++ final_string_index ] = ch ; is_present [ final_string [ final_string_index ] - 'A' ] ++ ; } } else { final_string [ ++ final_string_index ] = ch ; is_present [ final_string [ final_string_index ] - 'A' ] ++ ; } } final_string [ ++ final_string_index ] = '\0' ; def __debug__ printf <missing ';'> ( "\n the final string is %s " , final_string ) ; lse printf <missing ';'> ( "Case #%d: [" , k + 1 ) ; for ( l = 0 ; l < final_string_index ; l ++ ) { if ( l != final_string_index - 1 ) printf ( "%c, " , final_string [ l ] ) ; else printf ( "%c" , final_string [ l ] ) ; } printf ( "]\n" ) ; ndif } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
scanf scanf ( "\x25\x64\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan ti <= t
<operator>.postIncrement ti ++
LITERAL 0 return 0 ;
<operator>.assignment ti = 1
scanf scanf ( "%d" , & c )
scanf scanf ( "%d" , & d )
scanf scanf ( "%d" , & invlen )
scanf scanf ( "%s" , invlist )
<operator>.assignment invp = 0
clearlist clearlist ( )
run run ( )
printf printf ( "Case #%d: " , ti )
printelements printelements ( )
<operator>.lessThan ci < c
<operator>.postIncrement ci ++
<operator>.lessThan di < d
<operator>.postIncrement di ++
<operator>.assignment ci = 0
scanf scanf ( "%s" , tmpstr )
<operator>.assignment comb [ ci ] [ 0 ] = tmpstr [ 0 ]
<operator>.assignment comb [ ci ] [ 1 ] = tmpstr [ 1 ]
<operator>.assignment comb [ ci ] [ 2 ] = tmpstr [ 2 ]
<operator>.assignment di = 0
scanf scanf ( "%s" , tmpstr )
<operator>.assignment opp [ di ] [ 0 ] = tmpstr [ 0 ]
<operator>.assignment opp [ di ] [ 1 ] = tmpstr [ 1 ]
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & invlen
<operator>.indirectIndexAccess comb [ ci ] [ 0 ]
<operator>.indirectIndexAccess tmpstr [ 0 ]
<operator>.indirectIndexAccess comb [ ci ] [ 1 ]
<operator>.indirectIndexAccess tmpstr [ 1 ]
<operator>.indirectIndexAccess comb [ ci ] [ 2 ]
<operator>.indirectIndexAccess tmpstr [ 2 ]
<operator>.indirectIndexAccess opp [ di ] [ 0 ]
<operator>.indirectIndexAccess tmpstr [ 0 ]
<operator>.indirectIndexAccess opp [ di ] [ 1 ]
<operator>.indirectIndexAccess tmpstr [ 1 ]
<operator>.indirectIndexAccess comb [ ci ]
<operator>.indirectIndexAccess comb [ ci ]
<operator>.indirectIndexAccess comb [ ci ]
<operator>.indirectIndexAccess opp [ di ]
<operator>.indirectIndexAccess opp [ di ]
>>>PDG&49 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->27 0->28 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->16 5->17 5->18 5->20 5->22 5->27 5->31 5->32 5->33 6->1 6->5 7->4 8->1 8->5 9->1 9->18 10->1 10->20 11->1 12->1 13->1 13->1 14->1 15->1 16->1 16->6 17->1 18->1 18->1 18->1 18->9 18->18 18->19 18->19 18->23 18->24 18->25 18->26 18->34 18->35 18->36 18->37 18->38 18->39 18->44 18->45 18->46 19->1 19->18 20->1 20->1 20->1 20->10 20->20 20->21 20->21 20->28 20->29 20->30 20->40 20->41 20->42 20->43 20->47 20->48 21->1 21->20 22->1 22->18 23->1 23->24 23->25 23->26 23->28 24->1 24->1 24->1 25->1 25->1 25->1 26->1 26->1 26->1 27->1 27->20 28->1 28->23 28->24 28->25 28->29 28->30 29->1 29->1 29->1 30->1 30->1 30->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( void ) { char tmpstr [ 101 ] ; int i , j ; scanf ( "\x25\x64\x0" , & t ) ; for ( ti = 1 ; ti <= t ; ti ++ ) { scanf ( "%d" , & c ) ; for ( ci = 0 ; ci < c ; ci ++ ) { scanf ( "%s" , tmpstr ) ; comb [ ci ] [ 0 ] = tmpstr [ 0 ] ; comb [ ci ] [ 1 ] = tmpstr [ 1 ] ; comb [ ci ] [ 2 ] = tmpstr [ 2 ] ; } scanf ( "%d" , & d ) ; for ( di = 0 ; di < d ; di ++ ) { scanf ( "%s" , tmpstr ) ; opp [ di ] [ 0 ] = tmpstr [ 0 ] ; opp [ di ] [ 1 ] = tmpstr [ 1 ] ; } scanf ( "%d" , & invlen ) ; scanf ( "%s" , invlist ) ; invp = 0 ; clearlist ( ) ; run ( ) ; printf ( "Case #%d: " , ti ) ; printelements ( ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & cases )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < cases
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.assignment elements = 0
scanf scanf ( "%d" , & prod_count )
scanf scanf ( " %d " , & opposition_count )
scanf scanf ( " %d " , & ingredients )
printf printf ( "Case #%d: [" , i + 1 )
printf printf ( "]\n" )
<operator>.lessThan j < 26
<operator>.postIncrement j ++
<operator>.lessThan j < prod_count
<operator>.postIncrement j ++
<operator>.lessThan j < opposition_count
<operator>.postIncrement j ++
<operator>.lessThan j < ingredients
<operator>.postIncrement j ++
IDENTIFIER elements if (elements)
<operator>.lessThan j < elements
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment element_counts [ j ] = 0
<operator>.assignment j = 0
scanf scanf ( " %c%c%c " , & reagent1 , & reagent2 , & product )
<operator>.assignment productions [ reagent1 - 'A' ] [ reagent2 - 'A' ] = product
<operator>.assignment productions [ reagent2 - 'A' ] [ reagent1 - 'A' ] = product
<operator>.assignment j = 0
scanf scanf ( " %c%c " , & op1 , & op2 )
<operator>.assignment oppositions [ op1 - 'A' ] [ op2 - 'A' ] = 1
<operator>.assignment oppositions [ op2 - 'A' ] [ op1 - 'A' ] = 1
<operator>.assignment j = 0
scanf scanf ( "%c" , & next )
<operator>.addition i + 1
printf printf ( "%c" , results [ 0 ] )
<operator>.assignment j = 1
printf printf ( ", %c" , results [ j ] )
<operator>.lessThan k < 26
<operator>.postIncrement k ++
<operator>.logicalAnd elements > 0 && productions [ next - 'A' ] [ results [ elements - 1 ] - 'A' ] != 0
<operator>.lessThan k < 26
<operator>.postIncrement k ++
<operator>.assignment k = 0
<operator>.assignment productions [ j ] [ k ] = 0
<operator>.assignment oppositions [ j ] [ k ] = 0
<operator>.postDecrement element_counts [ results [ elements - 1 ] - 'A' ] --
<operator>.assignment results [ elements - 1 ] = productions [ next - 'A' ] [ results [ elements - 1 ] - 'A' ]
<operator>.postIncrement element_counts [ results [ elements - 1 ] - 'A' ] ++
<operator>.assignment k = 0
<operator>.subtraction reagent2 - 'A'
<operator>.subtraction reagent1 - 'A'
<operator>.subtraction op2 - 'A'
<operator>.subtraction op1 - 'A'
<operator>.greaterThan elements > 0
<operator>.notEquals productions [ next - 'A' ] [ results [ elements - 1 ] - 'A' ] != 0
<operator>.assignment results [ elements ++ ] = next
<operator>.assignmentPlus element_counts [ next - 'A' ] += 1
<operator>.logicalAnd element_counts [ k ] && oppositions [ k ] [ results [ elements - 1 ] - 'A' ]
<operator>.subtraction reagent1 - 'A'
<operator>.subtraction reagent2 - 'A'
<operator>.subtraction op1 - 'A'
<operator>.subtraction op2 - 'A'
<operator>.assignment elements = 0
<operator>.subtraction results [ elements - 1 ] - 'A'
<operator>.subtraction results [ elements - 1 ] - 'A'
<operator>.subtraction elements - 1
<operator>.subtraction results [ elements - 1 ] - 'A'
<operator>.subtraction results [ elements - 1 ] - 'A'
<operator>.lessThan m < 26
<operator>.postIncrement m ++
<operator>.subtraction next - 'A'
<operator>.subtraction next - 'A'
<operator>.postIncrement elements ++
<operator>.subtraction next - 'A'
<operator>.subtraction results [ elements - 1 ] - 'A'
<operator>.assignment m = 0
<operator>.assignment element_counts [ m ] = 0
<operator>.subtraction elements - 1
<operator>.subtraction elements - 1
<operator>.subtraction elements - 1
<operator>.subtraction elements - 1
<operator>.subtraction elements - 1
<operator>.addressOf & prod_count
<operator>.addressOf & opposition_count
<operator>.addressOf & ingredients
<operator>.indirectIndexAccess element_counts [ j ]
<operator>.addressOf & reagent1
<operator>.addressOf & reagent2
<operator>.addressOf & product
<operator>.indirectIndexAccess productions [ reagent1 - 'A' ] [ reagent2 - 'A' ]
<operator>.indirectIndexAccess productions [ reagent2 - 'A' ] [ reagent1 - 'A' ]
<operator>.addressOf & op1
<operator>.addressOf & op2
<operator>.indirectIndexAccess oppositions [ op1 - 'A' ] [ op2 - 'A' ]
<operator>.indirectIndexAccess oppositions [ op2 - 'A' ] [ op1 - 'A' ]
<operator>.addressOf & next
<operator>.indirectIndexAccess results [ 0 ]
<operator>.indirectIndexAccess results [ j ]
<operator>.indirectIndexAccess productions [ reagent1 - 'A' ]
<operator>.indirectIndexAccess productions [ reagent2 - 'A' ]
<operator>.indirectIndexAccess oppositions [ op1 - 'A' ]
<operator>.indirectIndexAccess oppositions [ op2 - 'A' ]
<operator>.indirectIndexAccess productions [ j ] [ k ]
<operator>.indirectIndexAccess oppositions [ j ] [ k ]
<operator>.indirectIndexAccess productions [ next - 'A' ] [ results [ elements - 1 ] - 'A' ]
<operator>.indirectIndexAccess element_counts [ results [ elements - 1 ] - 'A' ]
<operator>.indirectIndexAccess results [ elements - 1 ]
<operator>.indirectIndexAccess productions [ next - 'A' ] [ results [ elements - 1 ] - 'A' ]
<operator>.indirectIndexAccess element_counts [ results [ elements - 1 ] - 'A' ]
<operator>.indirectIndexAccess productions [ j ]
<operator>.indirectIndexAccess oppositions [ j ]
<operator>.indirectIndexAccess productions [ next - 'A' ]
<operator>.indirectIndexAccess productions [ next - 'A' ]
<operator>.indirectIndexAccess results [ elements ++ ]
<operator>.indirectIndexAccess element_counts [ next - 'A' ]
<operator>.indirectIndexAccess element_counts [ k ]
<operator>.indirectIndexAccess oppositions [ k ] [ results [ elements - 1 ] - 'A' ]
<operator>.indirectIndexAccess results [ elements - 1 ]
<operator>.indirectIndexAccess results [ elements - 1 ]
<operator>.indirectIndexAccess results [ elements - 1 ]
<operator>.indirectIndexAccess results [ elements - 1 ]
<operator>.indirectIndexAccess oppositions [ k ]
<operator>.indirectIndexAccess results [ elements - 1 ]
<operator>.indirectIndexAccess element_counts [ m ]
>>>PDG&128 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->48 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->14 4->16 4->18 4->20 4->23 4->25 4->27 4->31 4->35 4->37 4->37 4->38 4->39 4->86 4->87 4->88 4->100 5->1 5->4 6->3 7->1 7->4 8->1 8->23 8->57 9->1 9->16 10->1 10->18 11->1 11->20 12->1 12->1 13->1 14->1 14->14 14->15 14->15 14->26 14->41 14->46 14->89 15->1 15->14 16->1 16->1 16->9 16->16 16->17 16->17 16->28 16->29 16->30 16->53 16->54 16->62 16->63 16->90 16->91 16->92 16->93 16->94 16->102 16->103 17->1 17->16 18->1 18->1 18->10 18->18 18->19 18->19 18->32 18->33 18->34 18->55 18->56 18->64 18->65 18->95 18->96 18->97 18->98 18->104 18->105 19->1 19->18 20->1 20->1 20->11 20->20 20->21 20->21 20->36 20->43 20->44 20->52 20->57 20->99 21->1 21->20 23->1 23->1 23->1 23->23 23->24 23->24 23->40 23->101 24->1 24->23 25->14 26->1 26->1 27->16 28->1 28->1 28->1 28->54 28->62 29->1 29->1 30->1 30->1 30->1 31->18 32->1 32->1 32->56 32->64 33->1 33->1 34->1 34->1 35->1 35->20 36->1 36->59 36->74 36->75 36->77 38->1 38->1 39->1 39->23 40->1 40->1 41->1 41->1 41->41 41->42 41->42 41->47 41->48 41->106 41->107 41->113 41->114 42->1 42->41 43->1 43->1 43->1 43->49 43->50 43->51 43->59 43->60 43->68 43->69 43->70 43->71 43->75 43->76 43->77 43->82 43->83 43->84 43->109 43->110 43->111 43->112 43->116 43->117 43->118 43->122 43->123 43->124 44->1 44->1 44->44 44->45 44->45 44->61 44->119 45->1 45->44 46->1 46->41 47->1 47->1 48->1 48->1 49->1 49->51 50->1 50->1 50->71 51->1 51->1 51->49 52->1 52->44 53->63 54->1 54->28 54->62 55->65 56->1 56->32 56->64 57->43 57->43 57->58 57->67 57->74 57->76 57->81 57->81 57->82 57->108 57->115 57->121 58->1 58->43 58->43 58->50 59->1 59->1 60->1 60->1 61->1 61->1 61->1 61->66 61->72 61->79 62->54 63->1 63->53 64->56 65->1 65->55 66->1 66->23 66->57 66->85 67->1 67->68 67->78 68->70 69->83 71->1 71->67 71->68 71->78 72->1 72->1 72->72 72->73 72->73 72->80 72->127 73->1 73->72 74->59 74->75 74->77 75->1 75->36 75->59 75->74 75->77 76->23 76->57 76->85 77->1 77->36 77->59 77->74 77->75 78->1 78->67 78->68 79->1 79->72 80->1 80->1 81->76 81->82 82->69 83->84 84->23 84->57 84->85 85->23 85->57 119->78 119->85 119->120 119->125 119->126
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int cases ; scanf ( "\x25\x64\x0" , & cases ) ; for ( int i = 0 ; i < cases ; i ++ ) { int results [ 128 ] ; int elements = 0 ; int element_counts [ 26 ] ; char productions [ 26 ] [ 26 ] ; int oppositions [ 26 ] [ 26 ] ; for ( int j = 0 ; j < 26 ; j ++ ) { element_counts [ j ] = 0 ; for ( int k = 0 ; k < 26 ; k ++ ) { productions [ j ] [ k ] = 0 ; oppositions [ j ] [ k ] = 0 ; } } int prod_count ; scanf ( "%d" , & prod_count ) ; for ( int j = 0 ; j < prod_count ; j ++ ) { char reagent1 , reagent2 , product ; scanf ( " %c%c%c " , & reagent1 , & reagent2 , & product ) ; productions [ reagent1 - 'A' ] [ reagent2 - 'A' ] = product ; productions [ reagent2 - 'A' ] [ reagent1 - 'A' ] = product ; } int opposition_count ; scanf ( " %d " , & opposition_count ) ; for ( int j = 0 ; j < opposition_count ; j ++ ) { char op1 , op2 ; scanf ( " %c%c " , & op1 , & op2 ) ; oppositions [ op1 - 'A' ] [ op2 - 'A' ] = 1 ; oppositions [ op2 - 'A' ] [ op1 - 'A' ] = 1 ; } int ingredients ; scanf ( " %d " , & ingredients ) ; for ( int j = 0 ; j < ingredients ; j ++ ) { char next ; scanf ( "%c" , & next ) ; if ( elements > 0 && productions [ next - 'A' ] [ results [ elements - 1 ] - 'A' ] != 0 ) { element_counts [ results [ elements - 1 ] - 'A' ] -- ; results [ elements - 1 ] = productions [ next - 'A' ] [ results [ elements - 1 ] - 'A' ] ; element_counts [ results [ elements - 1 ] - 'A' ] ++ ; } else { results [ elements ++ ] = next ; element_counts [ next - 'A' ] += 1 ; } for ( int k = 0 ; k < 26 ; k ++ ) { if ( element_counts [ k ] && oppositions [ k ] [ results [ elements - 1 ] - 'A' ] ) { elements = 0 ; for ( int m = 0 ; m < 26 ; m ++ ) { element_counts [ m ] = 0 ; } } } } printf ( "Case #%d: [" , i + 1 ) ; if ( elements ) { printf ( "%c" , results [ 0 ] ) ; } for ( int j = 1 ; j < elements ; j ++ ) { printf ( ", %c" , results [ j ] ) ; } printf ( "]\n" ) ; } return 0 ; }
>>>Func
METHOD CombinesWith
METHOD_RETURN char
PARAM char first
PARAM char second
PARAM int nCombination
PARAM char * combinations [ ]
<operator>.assignment curCombo = 0
RETURN return '\0' ; return '\0' ;
<operator>.lessThan curCombo < nCombination
<operator>.postIncrement curCombo ++
LITERAL '\0' return '\0' ;
<operator>.assignment curCombo = 0
<operator>.assignment * combo = combinations [ curCombo ]
<operator>.logicalOr ( first == combo [ 0 ] && second == combo [ 1 ] ) || ( first == combo [ 1 ] && second == combo [ 0 ] )
RETURN return combo [ 2 ] ; return combo [ 2 ] ;
<operator>.logicalAnd first == combo [ 0 ] && second == combo [ 1 ]
<operator>.logicalAnd first == combo [ 1 ] && second == combo [ 0 ]
<operator>.equals first == combo [ 0 ]
<operator>.equals second == combo [ 1 ]
<operator>.equals first == combo [ 1 ]
<operator>.equals second == combo [ 0 ]
<operator>.indirectIndexAccess combinations [ curCombo ]
<operator>.indirectIndexAccess combo [ 2 ]
<operator>.indirectIndexAccess combo [ 0 ]
<operator>.indirectIndexAccess combo [ 1 ]
<operator>.indirectIndexAccess combo [ 1 ]
<operator>.indirectIndexAccess combo [ 0 ]
>>>PDG&27 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->17 0->18 0->19 0->20 2->17 3->1 3->18 3->20 4->8 5->1 5->12 7->1 8->1 8->1 8->1 8->7 8->9 8->12 8->13 8->15 8->17 8->21 8->23 9->1 9->8 10->7 11->1 11->8 12->1 12->1 12->1 12->17 12->18 12->19 12->20 13->1 13->1 13->1 13->8 13->9 13->14 13->22 14->1 15->1 15->1 15->13 15->13 15->16 15->19 15->25 16->1 16->1 16->13 16->13 17->1 17->1 17->15 17->15 17->18 17->19 17->20 17->24 18->1 18->1 18->15 18->15 18->19 18->20 19->1 19->1 19->16 19->16 19->17 19->18 19->20 19->26 20->1 20->1 20->16 20->16 20->17 20->18
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) char CombinesWith ( char first , char second , int nCombination , char * combinations [ ] ) { int curCombo = 0 ; for ( curCombo = 0 ; curCombo < nCombination ; curCombo ++ ) { char * combo = combinations [ curCombo ] ; if ( ( first == combo [ 0 ] && second == combo [ 1 ] ) || ( first == combo [ 1 ] && second == combo [ 0 ] ) ) { return combo [ 2 ] ; } } return '\0' ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & ncases )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan casenum <= ncases
<operator>.postIncrement casenum ++
LITERAL 0 return 0 ;
<operator>.assignment casenum = 1
<operator>.assignment listlen = 0
memset memset ( combinations   0   sizeof ( combinations ) )
memset memset ( opposition   0xff   sizeof ( opposition ) )
<operator>.assignment mask = ~ 0
scanf scanf ( "%d" , & cnt )
scanf scanf ( "%d" , & cnt )
scanf scanf ( "%d %s" , & cnt , buf )
printf printf ( "Case #%d: [" , casenum )
printf printf ( "]\n" )
<operator>.lessThan i < cnt
<operator>.postIncrement i ++
<operator>.lessThan i < cnt
<operator>.postIncrement i ++
<operator>.lessThan i < cnt
<operator>.postIncrement i ++
<operator>.greaterThan listlen > 0
<operator>.lessThan i < listlen
<operator>.postIncrement i ++
<operator>.not ~ 0
<operator>.assignment i = 0
scanf scanf ( "%s" , buf )
combine combine ( buf )
<operator>.assignment i = 0
scanf scanf ( "%s" , buf )
oppose oppose ( buf )
<operator>.assignment i = 0
simulate simulate ( buf [ i ] - 'A' )
printf printf ( "%c" , list [ 0 ] + 'A' )
<operator>.assignment i = 1
printf printf ( ", %c" , list [ i ] + 'A' )
<operator>.subtraction buf [ i ] - 'A'
<operator>.addition list [ 0 ] + 'A'
<operator>.addition list [ i ] + 'A'
<operator>.sizeOf sizeof ( combinations )
<operator>.sizeOf sizeof ( opposition )
<operator>.addressOf & cnt
<operator>.addressOf & cnt
<operator>.addressOf & cnt
<operator>.indirectIndexAccess buf [ i ]
<operator>.indirectIndexAccess list [ 0 ]
<operator>.indirectIndexAccess list [ i ]
>>>PDG&49 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->15 4->16 4->17 4->19 4->21 4->23 4->24 4->26 4->27 4->30 4->33 4->36 4->41 4->42 4->43 4->44 4->45 5->1 5->4 6->3 7->1 7->4 8->1 8->23 9->1 9->1 10->1 10->1 11->1 11->1 11->1 12->13 12->17 12->19 13->14 13->19 13->21 14->1 14->1 14->12 14->17 14->21 15->1 15->5 16->1 17->13 17->17 17->18 17->18 17->19 17->28 17->29 18->1 18->17 19->14 19->19 19->20 19->20 19->21 19->31 19->32 20->1 20->19 21->1 21->1 21->12 21->17 21->21 21->22 21->22 21->34 21->38 21->46 22->1 22->21 23->1 23->24 23->35 23->39 23->47 24->1 24->1 24->1 24->24 24->25 24->25 24->37 24->40 24->48 25->1 25->24 26->11 27->17 28->29 29->1 29->28 29->31 30->19 31->32 32->1 32->31 33->1 33->21 34->1 34->1 35->1 35->1 36->1 36->24 37->1 37->1 38->1 38->28 38->29 38->31 38->32 38->34 38->34 39->1 40->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int ncases , casenum ; int cnt , i ; char buf [ 150 ] ; scanf ( "\x25\x64\x0" , & ncases ) ; for ( casenum = 1 ; casenum <= ncases ; casenum ++ ) { listlen = 0 ; memset ( combinations , 0 , sizeof ( combinations ) ) ; memset ( opposition , 0xff , sizeof ( opposition ) ) ; mask = ~ 0 ; scanf ( "%d" , & cnt ) ; for ( i = 0 ; i < cnt ; i ++ ) { scanf ( "%s" , buf ) ; combine ( buf ) ; } scanf ( "%d" , & cnt ) ; for ( i = 0 ; i < cnt ; i ++ ) { scanf ( "%s" , buf ) ; oppose ( buf ) ; } scanf ( "%d %s" , & cnt , buf ) ; for ( i = 0 ; i < cnt ; i ++ ) { simulate ( buf [ i ] - 'A' ) ; } printf ( "Case #%d: [" , casenum ) ; if ( listlen > 0 ) { printf ( "%c" , list [ 0 ] + 'A' ) ; } for ( i = 1 ; i < listlen ; i ++ ) { printf ( ", %c" , list [ i ] + 'A' ) ; } printf ( "]\n" ) ; } return 0 ; }
>>>Func
METHOD isInt
METHOD_RETURN int
PARAM float f
RETURN return ( fabs ( ( int ) f - f ) < 10e-5 ) ; return ( fabs ( ( int ) f - f ) < 10e-5 ) ;
<operator>.lessThan fabs ( ( int ) f - f ) < 10e-5
fabs fabs ( ( int ) f - f )
<operator>.subtraction ( int ) f - f
<operator>.cast ( int ) f
>>>PDG&8 0->2 0->4 0->6 0->7 2->6 2->7 3->1 4->1 4->1 4->3 5->1 6->1 6->1 6->4 6->4 6->5 6->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int isInt ( float f ) { return ( fabs ( ( int ) f - f ) < 10e-5 ) ; }
>>>Func
METHOD top
METHOD_RETURN int
PARAM Heap * heap
<operator>.notEquals heap -> count != 0
RETURN return * ( heap -> p ) ; return * ( heap -> p ) ;
RETURN return INT_MIN ; return INT_MIN ;
IDENTIFIER INT_MIN return INT_MIN ;
<operator>.indirection * ( heap -> p )
<operator>.indirectFieldAccess heap -> p
FIELD_IDENTIFIER p p
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 2->1 3->1 3->1 3->4 3->5 3->7 3->8 3->9 4->1 5->1 6->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int top ( Heap * heap ) { if ( heap -> count != 0 ) return * ( heap -> p ) ; else return INT_MIN ; }
>>>Func
METHOD cmp
METHOD_RETURN int
PARAM const void * a
PARAM const void * b
RETURN return ( * ( int * ) b - * ( int * ) a ) ; return ( * ( int * ) b - * ( int * ) a ) ;
<operator>.subtraction * ( int * ) b - * ( int * ) a
<operator>.cast ( int * ) b
<operator>.cast ( int * ) a
>>>PDG&8 0->2 0->3 0->6 0->7 2->7 3->6 4->1 5->1 5->1 5->1 5->4 6->1 7->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int cmp ( const void * a , const void * b ) { return ( * ( int * ) b - * ( int * ) a ) ; }
>>>Func
METHOD main
METHOD_RETURN ANY
freopen freopen ( "\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e\x0" , "r" , stdin )
freopen freopen ( "Bs.txt" , "w" , stdout )
scanf scanf ( "%d" , & t )
<operator>.lessEqualsThan i <= t
<operator>.postIncrement i ++
<operator>.assignment i = 1
<operator>.assignment tot = co = 0
scanf scanf ( "%d%d%d%d" , & l , & ti , & n , & c )
<operator>.assignment k = 0
<operator>.assignment tim = ti
<operator>.assignment j = co = 0
<operator>.assignment tot = ti
<operator>.lessThan j < c
<operator>.postIncrement j ++
scanf scanf ( "%d" , & a [ j ] )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.greaterThan tim > 0
<operator>.lessEqualsThan ( n - co ) <= l
<operator>.assignment co = 0
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment b [ j ] = a [ k ++ ]
<operator>.assignment co = 0
<operator>.postIncrement j ++
printf printf ( "Case #%d: %d\n" , i , tot )
<operator>.equals k == c
<operator>.greaterThan b [ j ] > tim / 2
<operator>.subtraction n - co
<operator>.lessThan co < n
<operator>.assignment z = 0
qsort qsort ( d   z   sizeof ( int ) , compare )
<operator>.assignment j = z - 1
printf printf ( "Case #%d: %d\n" , i , tot )
<operator>.assignment k = 0
<operator>.assignment b [ j ] = b [ j ] - tim / 2
<operator>.assignment tim = 0
<operator>.assignmentPlus tot += b [ j ++ ]
<operator>.postIncrement co ++
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.assignment d [ z ++ ] = b [ k ]
<operator>.greaterThan l > 0
<operator>.greaterEqualsThan j >= 0
<operator>.assignmentPlus tot += d [ j -- ] * 2
<operator>.postIncrement k ++
<operator>.division tim / 2
<operator>.assignment k = j
<operator>.sizeOf sizeof ( int )
<operator>.subtraction z - 1
<operator>.assignmentPlus tot += d [ j -- ]
<operator>.postDecrement l --
<operator>.subtraction b [ j ] - tim / 2
<operator>.greaterEqualsThan tim / 2 >= b [ j ]
<operator>.multiplication d [ j -- ] * 2
<operator>.division tim / 2
<operator>.assignment tim = tim - b [ j ] * 2
<operator>.postIncrement co ++
<operator>.postIncrement j ++
<operator>.postIncrement z ++
<operator>.division tim / 2
<operator>.postDecrement j --
<operator>.postDecrement j --
<operator>.subtraction tim - b [ j ] * 2
<operator>.multiplication b [ j ] * 2
<operator>.addressOf & l
<operator>.addressOf & ti
<operator>.addressOf & n
<operator>.addressOf & c
<operator>.addressOf & a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess b [ j ]
<operator>.indirectIndexAccess a [ k ++ ]
<operator>.indirectIndexAccess b [ j ]
<operator>.indirectIndexAccess b [ j ]
<operator>.indirectIndexAccess b [ j ++ ]
<operator>.indirectIndexAccess d [ z ++ ]
<operator>.indirectIndexAccess b [ k ]
<operator>.indirectIndexAccess b [ j ]
<operator>.indirectIndexAccess d [ j -- ]
<operator>.indirectIndexAccess d [ j -- ]
<operator>.indirectIndexAccess b [ j ]
<operator>.indirectIndexAccess b [ j ]
>>>PDG&85 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->30 0->31 0->32 0->33 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->52 0->53 0->56 0->57 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 2->1 2->1 3->1 3->1 4->1 4->5 5->1 5->1 5->1 5->5 5->6 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->17 5->19 5->20 5->21 5->22 5->23 5->25 5->27 5->30 5->35 5->67 5->68 5->69 5->70 6->1 6->5 7->1 7->5 8->1 9->1 9->1 9->1 9->1 9->20 9->44 9->53 10->1 10->1 10->47 11->1 11->19 12->1 12->1 12->1 12->26 12->49 12->60 13->1 13->1 13->27 13->35 13->39 13->46 13->52 14->1 14->1 14->14 14->15 14->15 14->16 14->28 14->71 14->72 15->1 15->14 16->1 17->1 17->17 17->18 17->18 17->24 17->28 17->30 17->47 17->73 17->74 18->1 18->17 19->1 19->1 19->29 19->48 19->48 19->75 20->1 20->1 20->1 20->9 20->27 20->31 20->32 20->33 20->34 20->35 20->41 20->44 20->44 20->45 20->49 20->50 20->51 21->8 22->14 23->1 23->17 24->1 24->1 24->1 24->29 25->12 25->30 25->59 26->1 26->1 26->49 26->60 27->1 27->1 27->6 28->1 28->1 28->1 28->14 28->36 28->47 29->1 29->19 29->26 29->37 29->38 29->54 29->54 29->55 29->55 29->57 29->62 29->76 29->80 29->83 30->1 30->20 30->20 30->31 30->31 30->41 31->1 31->1 31->1 31->17 31->31 31->39 31->40 31->40 31->60 31->77 32->1 32->33 32->61 33->1 33->1 33->1 33->51 33->52 33->56 34->1 34->1 34->45 34->63 35->1 35->1 35->6 36->1 36->1 36->47 37->1 37->1 37->1 37->29 38->1 38->1 39->1 39->1 39->27 40->1 40->31 41->1 41->1 41->1 41->17 41->41 41->42 41->42 41->43 41->61 41->78 41->79 42->1 42->41 43->1 43->1 43->1 43->33 44->1 44->1 44->9 44->20 44->44 44->52 44->53 44->53 44->63 44->81 45->1 45->1 45->45 45->46 45->56 45->64 45->64 45->82 46->1 46->1 46->35 47->28 48->29 48->29 48->57 48->62 49->1 49->41 50->1 51->1 51->34 51->34 52->1 52->1 52->35 52->46 53->1 53->44 54->1 54->37 54->37 55->1 55->1 55->1 55->29 55->58 55->59 55->65 55->66 55->66 55->84 56->1 56->33 56->46 56->46 56->52 57->54 57->54 58->1 58->1 58->19 59->1 59->30 60->1 61->33 62->19 62->55 62->55 62->65 63->45 64->45 65->1 65->58 65->58 66->1 66->29 66->65 66->65
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  main ( ) { freopen ( "\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e\x0" , "r" , stdin ) ; freopen ( "Bs.txt" , "w" , stdout ) ; int t , n , l , c , ti , i , j , a [ 1000 ] , tot , tim , co , b [ 1000 ] , d [ 1000 ] , k , z ; scanf ( "%d" , & t ) ; for ( i = 1 ; i <= t ; i ++ ) { tot = co = 0 ; scanf ( "%d%d%d%d" , & l , & ti , & n , & c ) ; for ( j = 0 ; j < c ; j ++ ) scanf ( "%d" , & a [ j ] ) ; k = 0 ; for ( j = 0 ; j < n ; j ++ ) { b [ j ] = a [ k ++ ] ; if ( k == c ) k = 0 ; } tim = ti ; j = co = 0 ; while ( tim > 0 ) { if ( b [ j ] > tim / 2 ) { b [ j ] = b [ j ] - tim / 2 ; tim = 0 ; break ; } else if ( tim / 2 >= b [ j ] ) { tim = tim - b [ j ] * 2 ; co ++ ; } j ++ ; } tot = ti ; if ( ( n - co ) <= l ) { while ( co < n ) { tot += b [ j ++ ] ; co ++ ; } printf ( "Case #%d: %d\n" , i , tot ) ; } else { z = 0 ; for ( k = j ; k < n ; k ++ ) d [ z ++ ] = b [ k ] ; qsort ( d , z , sizeof ( int ) , compare ) ; j = z - 1 ; while ( l > 0 ) { tot += d [ j -- ] ; l -- ; } while ( j >= 0 ) tot += d [ j -- ] * 2 ; printf ( "Case #%d: %d\n" , i , tot ) ; } } }
>>>Func
METHOD bt
METHOD_RETURN void
PARAM int a
PARAM int p
<operator>.equals p == n
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment r = MIN ( r , a )
RETURN return ; return ;
<operator>.assignment i = 0
<operator>.assignment mrc [ i ] = 1
bt bt ( a + v [ 0 ] [ p ] * v [ 1 ] [ i ] , p + 1 )
<operator>.assignment mrc [ i ] = 0
MIN MIN ( r , a )
<operator>.addition a + v [ 0 ] [ p ] * v [ 1 ] [ i ]
<operator>.addition p + 1
<operator>.multiplication v [ 0 ] [ p ] * v [ 1 ] [ i ]
<operator>.indirectIndexAccess mrc [ i ]
<operator>.indirectIndexAccess mrc [ i ]
<operator>.indirectIndexAccess mrc [ i ]
<operator>.indirectIndexAccess v [ 0 ] [ p ]
<operator>.indirectIndexAccess v [ 1 ] [ i ]
<operator>.indirectIndexAccess v [ 0 ]
<operator>.indirectIndexAccess v [ 1 ]
>>>PDG&24 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->11 2->13 2->14 3->4 4->1 4->1 4->1 4->5 4->5 4->7 4->8 4->9 4->11 4->13 4->15 5->5 5->6 5->6 5->17 6->5 7->1 7->1 7->1 8->1 9->5 13->1 13->7 13->7 16->11 16->11 16->14 16->14 17->10 17->11 17->12 17->14 17->15 17->16 17->18 17->19 17->20 17->21 17->22 17->23
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void bt ( int a , int p ) { int i ; if ( p == n ) { r = MIN ( r , a ) ; return ; } for ( i = 0 ; i < n ; i ++ ) { if ( mrc [ i ] ) { continue ; } mrc [ i ] = 1 ; bt ( a + v [ 0 ] [ p ] * v [ 1 ] [ i ] , p + 1 ) ; mrc [ i ] = 0 ; } }
>>>Func
METHOD free_opposer
METHOD_RETURN void
<operator>.assignment * t_opposer = & first_opposer
<operator>.assignment t_opposer = t_opposer -> next
RETURN return ; return ;
<operator>.equals t_opposer -> next == NULL
IDENTIFIER t_opposer if (t_opposer)
RETURN return ; return ;
<operator>.assignment temp = t_opposer
<operator>.assignment t_opposer = t_opposer -> next
free free ( t_opposer )
IDENTIFIER temp if (temp)
free free ( temp )
<operator>.indirectFieldAccess t_opposer -> next
<operator>.indirectFieldAccess t_opposer -> next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess t_opposer -> next
FIELD_IDENTIFIER next next
>>>PDG&19 0->2 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 2->1 2->1 2->1 3->8 3->10 4->1 5->1 5->1 5->1 5->3 5->3 5->4 5->7 5->9 5->10 5->13 5->14 5->15 5->16 7->1 8->12 9->8 9->10 14->8 14->9 14->12 14->14 14->16 14->17 14->18
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void free_opposer ( ) { struct s_opposer * t_opposer = & first_opposer ; struct s_opposer * temp ; if ( t_opposer -> next == NULL ) return ; t_opposer = t_opposer -> next ; while ( t_opposer -> next ) { temp = t_opposer ; t_opposer = t_opposer -> next ; if ( temp ) free ( temp ) ; } if ( t_opposer ) free ( t_opposer ) ; return ; }
>>>Func
METHOD owpx
METHOD_RETURN double
PARAM k
PARAM j
<operator>.assignment games_played = 0
<operator>.assignment games_won = 0
RETURN return ( games_won / games_played ) ; return ( games_won / games_played ) ;
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.division games_won / games_played
<operator>.assignment i = 0
<operator>.equals i == j
<operator>.notEquals A [ k ] [ i ] != '.'
<operator>.postIncrement games_played ++
<operator>.equals A [ k ] [ i ] == '1'
<operator>.postIncrement games_won ++
<operator>.indirectIndexAccess A [ k ] [ i ]
<operator>.indirectIndexAccess A [ k ]
<operator>.indirectIndexAccess A [ k ] [ i ]
<operator>.indirectIndexAccess A [ k ]
>>>PDG&20 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->1 3->1 3->11 4->1 4->9 4->13 5->1 5->9 5->15 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->11 8->1 8->7 9->1 9->1 9->1 9->6 10->1 10->7 11->1 11->1 11->8 11->12 11->16 11->17 12->1 12->1 12->13 12->14 12->14 12->18 12->19 13->1 13->9 14->1 14->1 14->12 14->15 15->1 15->9
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) double owpx ( k , j ) { int i ; double games_played = 0 , games_won = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i == j ) { continue ; } if ( A [ k ] [ i ] != '.' ) { games_played ++ ; if ( A [ k ] [ i ] == '1' ) { games_won ++ ; } } } return ( games_won / games_played ) ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf ( "\x45\x6e\x74\x65\x72\x20\x61\x6e\x20\x6f\x63\x74\x61\x6c\x20\x6e\x75\x6d\x62\x65\x72\x3a\x20\x0" )
scanf scanf ( "%d" , & octalnum )
printf printf ( "Equivalent binary number is: %ld"   octalToBinary ( octalnum ) )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
octalToBinary octalToBinary ( octalnum )
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 3->1 3->7 4->1 4->1 5->1 6->5 7->1 7->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { int octalnum ; printf ( "\x45\x6e\x74\x65\x72\x20\x61\x6e\x20\x6f\x63\x74\x61\x6c\x20\x6e\x75\x6d\x62\x65\x72\x3a\x20\x0" ) ; scanf ( "%d" , & octalnum ) ; printf ( "Equivalent binary number is: %ld" , octalToBinary ( octalnum ) ) ; return 0 ; }
>>>Func
METHOD list_free
METHOD_RETURN void
PARAM ListEntry * list
<operator>.assignment entry = list
<operator>.notEquals entry != NULL
<operator>.assignment next = entry -> next
free free ( entry )
<operator>.assignment entry = next
<operator>.indirectFieldAccess entry -> next
FIELD_IDENTIFIER next next
>>>PDG&10 0->2 0->3 0->4 0->6 0->7 2->3 3->1 3->1 3->4 4->1 4->1 4->1 4->4 4->5 4->6 4->6 4->7 4->8 4->9 5->7 7->1 7->1 7->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void list_free ( ListEntry * list ) { ListEntry * entry ; entry = list ; while ( entry != NULL ) { ListEntry * next ; next = entry -> next ; free ( entry ) ; entry = next ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment size = 6
<operator>.assignment * numbers = malloc ( size * sizeof ( int ) )
printf printf ( "\x49\x6e\x73\x65\x72\x74\x20\x25\x64\x20\x75\x6e\x73\x6f\x72\x74\x65\x64\x20\x6e\x75\x6d\x62\x65\x72\x73\x3a\x20\x5c\x6e\x0" , size )
printf printf ( "Initial array: " )
display display ( numbers , size )
sort sort ( numbers , size )
printf printf ( "Sorted array: " )
display display ( numbers , size )
free free ( numbers )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < size
<operator>.preIncrement ++ i
scanf scanf ( "%d" , & numbers [ i ] )
LITERAL 0 return 0 ;
malloc malloc ( size * sizeof ( int ) )
<operator>.assignment i = 0
<operator>.multiplication size * sizeof ( int )
<operator>.sizeOf sizeof ( int )
<operator>.addressOf & numbers [ i ]
<operator>.indirectIndexAccess numbers [ i ]
>>>PDG&22 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->17 0->18 2->1 2->18 3->1 3->1 3->6 3->7 3->9 3->10 3->14 4->1 4->12 5->1 6->7 6->7 7->1 7->9 7->9 8->1 9->1 9->1 9->10 10->1 11->1 12->1 12->1 12->6 12->12 12->13 12->13 12->14 12->20 12->21 13->1 13->12 14->1 14->6 14->7 14->9 14->10 15->11 16->1 16->3 17->1 17->12 18->4 18->16 19->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { int size = 6 ; int i ; int * numbers = malloc ( size * sizeof ( int ) ) ; printf ( "\x49\x6e\x73\x65\x72\x74\x20\x25\x64\x20\x75\x6e\x73\x6f\x72\x74\x65\x64\x20\x6e\x75\x6d\x62\x65\x72\x73\x3a\x20\x5c\x6e\x0" , size ) ; for ( i = 0 ; i < size ; ++ i ) scanf ( "%d" , & numbers [ i ] ) ; printf ( "Initial array: " ) ; display ( numbers , size ) ; sort ( numbers , size ) ; printf ( "Sorted array: " ) ; display ( numbers , size ) ; free ( numbers ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment c = argv [ 1 ] [ 0 ]
RETURN return 0 ; return 0 ;
<operator>.equals c == 127
<operator>.equals c == 63
LITERAL 0 return 0 ;
printf printf ( "\x69\x66\x2d\x31\x2d\x77\x69\x6e\x20\x0" )
printf printf ( "if-2-win\n" )
printf printf ( "if-1-lose " )
printf printf ( "if-2-lose\n" )
>>>PDG&13 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 3->1 4->1 4->1 4->6 5->1 6->1 6->7 6->9 6->11 7->1 7->1 7->10 7->12 8->5 9->1 10->1 11->1 12->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * argv [ ] ) { unsigned char c = argv [ 1 ] [ 0 ] ; if ( c == 127 ) printf ( "\x69\x66\x2d\x31\x2d\x77\x69\x6e\x20\x0" ) ; else printf ( "if-1-lose " ) ; if ( c == 63 ) printf ( "if-2-win\n" ) ; else printf ( "if-2-lose\n" ) ; return 0 ; }
>>>Func
METHOD comp
METHOD_RETURN bool
PARAM string a
PARAM string b
<operator>.expressionList vector < string > str1   str2
StringSplit StringSplit ( a , "\x20\x0" , str1 )
StringSplit StringSplit ( b , " " , str2 )
<operator>.equals str1 [ 0 ] . compare ( str2 [ 0 ] ) == - 1
<operator>.greaterThan vector < string > str1
RETURN return true ; return true ;
<operator>.lessThan vector < string
compare str1 [ 0 ] . compare ( str2 [ 0 ] )
<operator>.minus - 1
IDENTIFIER true return true ;
RETURN return false ; return false ;
IDENTIFIER false return false ;
>>>PDG&16 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->12 0->13 0->14 0->15 2->5 3->6 4->1 4->1 4->6 5->1 5->1 5->1 6->1 6->1 6->1 6->11 7->1 7->1 7->1 7->9 7->14 8->1 8->4 8->4 8->5 9->1 10->1 10->1 10->8 10->8 11->1 11->1 11->7 11->7 12->7 13->9 14->1 15->14
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) bool comp ( string a , string b ) { vector < string > str1 , str2 ; StringSplit ( a , "\x20\x0" , str1 ) ; StringSplit ( b , " " , str2 ) ; if ( str1 [ 0 ] . compare ( str2 [ 0 ] ) == - 1 ) return true ; else return false ; }
>>>Func
METHOD line_intersect
METHOD_RETURN bool
PARAM double x1
PARAM double y1
PARAM double x2
PARAM double y2
PARAM double x3
PARAM double y3
PARAM double x4
PARAM double y4
RETURN return ( ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 ) < 0 && ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 ) < 0 ) ; return ( ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 ) < 0 && ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 ) < 0 ) ;
<operator>.logicalAnd ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 ) < 0 && ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 ) < 0
<operator>.lessThan ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 ) < 0
<operator>.lessThan ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 ) < 0
<operator>.multiplication ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 )
<operator>.multiplication ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 )
ccw ccw ( x1 , y1 , x2 , y2 , x3 , y3 )
ccw ccw ( x1 , y1 , x2 , y2 , x4 , y4 )
ccw ccw ( x3 , y3 , x4 , y4 , x1 , y1 )
ccw ccw ( x3 , y3 , x4 , y4 , x2 , y2 )
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->12 0->13 0->16 0->17 0->18 0->19 2->16 3->16 4->16 5->16 6->16 7->16 8->17 9->17 10->1 11->1 11->1 11->1 11->10 12->1 12->11 12->11 12->13 12->15 12->18 12->19 13->1 13->11 13->11 14->1 14->1 14->12 14->12 15->1 15->1 15->13 15->13 16->1 16->1 16->14 16->14 16->14 16->14 16->14 16->14 16->17 16->17 16->17 16->17 16->18 16->18 17->1 17->1 17->1 17->1 17->1 17->1 17->14 17->14 17->14 17->14 17->14 17->14 17->18 17->18 17->18 17->18 17->19 17->19 18->1 18->1 18->15 18->15 18->15 18->15 18->15 18->15 18->19 18->19 18->19 18->19 19->1 19->1 19->1 19->1 19->1 19->1 19->15 19->15 19->15 19->15 19->15 19->15
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) bool line_intersect ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 , double x4 , double y4 ) { return ( ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 ) < 0 && ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 ) < 0 ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
scanf scanf ( "\x25\x64\x0" , & num_cases )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan curr_case <= num_cases
<operator>.postIncrement curr_case ++
LITERAL 0 return 0 ;
<operator>.assignment curr_case = 1
memset memset ( interactions   0   26 * 26 * sizeof ( char ) )
memset memset ( oppositions   0   26 * 26 * sizeof ( char ) )
memset memset ( char_count   0   26 * sizeof ( int ) )
scanf scanf ( "%d" , & num_merge )
scanf scanf ( "%d" , & num_oppose )
scanf scanf ( "%d %s" , & num_oppose , input )
<operator>.assignment stack_top = 0
printf printf ( "Case #%d: [" , curr_case )
printf printf ( "%c]\n" , stack [ i ] + 'A' )
<operator>.lessThan i < num_merge
<operator>.postIncrement i ++
<operator>.lessThan i < num_oppose
<operator>.postIncrement i ++
<operator>.assignment curr_char = * char_ptr
<operator>.postIncrement char_ptr ++
<operator>.equals stack_top == 0
<operator>.lessThan i < stack_top - 1
<operator>.postIncrement i ++
<operator>.multiplication 26 * 26 * sizeof ( char )
<operator>.multiplication 26 * 26 * sizeof ( char )
<operator>.multiplication 26 * sizeof ( int )
<operator>.assignment i = 0
scanf scanf ( "%s" , temp )
<operator>.assignment interactions [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ] = interactions [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ] = temp [ 2 ]
<operator>.assignment i = 0
scanf scanf ( "%s" , temp )
<operator>.assignment oppositions [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ] = CLEAR
<operator>.assignment oppositions [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ] = CLEAR
<operator>.assignment char_ptr = input
<operator>.assignment curr_top = stack [ stack_top - 1 ]
<operator>.assignmentMinus curr_char -= 'A'
<operator>.assignment stack [ stack_top ++ ] = curr_char
<operator>.postIncrement char_count [ curr_char ] ++
printf printf ( "Case #%d: []\n" , curr_case )
<operator>.assignment i = 0
printf printf ( "%c, " , stack [ i ] + 'A' )
<operator>.addition stack [ i ] + 'A'
<operator>.multiplication 26 * 26
<operator>.multiplication 26 * 26
<operator>.sizeOf sizeof ( char )
<operator>.sizeOf sizeof ( int )
<operator>.equals stack_top == 0
<operator>.greaterThan ( temp [ 0 ] = interactions [ curr_top ] [ curr_char ] ) > 0
<operator>.lessThan i < 26
<operator>.postIncrement i ++
<operator>.notEquals i != 26
<operator>.subtraction stack_top - 1
<operator>.assignment interactions [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ] = temp [ 2 ]
<operator>.assignment stack [ stack_top ++ ] = curr_char - 'A'
<operator>.postIncrement char_count [ stack [ stack_top - 1 ] ] ++
<operator>.assignment stack [ stack_top - 1 ] = temp [ 0 ] - 'A'
<operator>.postDecrement char_count [ curr_top ] --
<operator>.assignment i = 0
<operator>.assignment stack_top = 0
memset memset ( char_count   0   26 * sizeof ( int ) )
<operator>.addition stack [ i ] + 'A'
<operator>.subtraction temp [ 1 ] - 'A'
<operator>.subtraction temp [ 1 ] - 'A'
<operator>.subtraction temp [ 0 ] - 'A'
<operator>.subtraction stack_top - 1
<operator>.assignment temp [ 0 ] = interactions [ curr_top ] [ curr_char ]
<operator>.logicalAnd oppositions [ curr_char ] [ i ] == CLEAR && char_count [ i ] != 0
<operator>.postIncrement stack_top ++
<operator>.subtraction temp [ 0 ] - 'A'
<operator>.subtraction temp [ 0 ] - 'A'
<operator>.subtraction temp [ 0 ] - 'A'
<operator>.subtraction temp [ 1 ] - 'A'
<operator>.subtraction curr_char - 'A'
<operator>.subtraction temp [ 0 ] - 'A'
<operator>.multiplication 26 * sizeof ( int )
<operator>.subtraction temp [ 1 ] - 'A'
<operator>.postIncrement stack_top ++
<operator>.subtraction stack_top - 1
<operator>.equals oppositions [ curr_char ] [ i ] == CLEAR
<operator>.notEquals char_count [ i ] != 0
<operator>.sizeOf sizeof ( int )
<operator>.subtraction stack_top - 1
<operator>.addressOf & num_merge
<operator>.addressOf & num_oppose
<operator>.addressOf & num_oppose
<operator>.sizeOf sizeof ( char )
<operator>.indirection * char_ptr
<operator>.indirectIndexAccess stack [ i ]
<operator>.indirectIndexAccess interactions [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ]
<operator>.indirectIndexAccess oppositions [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ]
<operator>.indirectIndexAccess oppositions [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ]
<operator>.indirectIndexAccess stack [ stack_top - 1 ]
<operator>.indirectIndexAccess stack [ stack_top ++ ]
<operator>.indirectIndexAccess char_count [ curr_char ]
<operator>.indirectIndexAccess interactions [ temp [ 0 ] - 'A' ]
<operator>.indirectIndexAccess interactions [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ]
<operator>.indirectIndexAccess temp [ 2 ]
<operator>.indirectIndexAccess oppositions [ temp [ 0 ] - 'A' ]
<operator>.indirectIndexAccess oppositions [ temp [ 1 ] - 'A' ]
<operator>.indirectIndexAccess stack [ i ]
<operator>.indirectIndexAccess temp [ 1 ]
<operator>.indirectIndexAccess interactions [ temp [ 1 ] - 'A' ]
<operator>.indirectIndexAccess temp [ 1 ]
<operator>.indirectIndexAccess temp [ 0 ]
<operator>.indirectIndexAccess stack [ stack_top ++ ]
<operator>.indirectIndexAccess char_count [ stack [ stack_top - 1 ] ]
<operator>.indirectIndexAccess temp [ 0 ]
<operator>.indirectIndexAccess interactions [ curr_top ] [ curr_char ]
<operator>.indirectIndexAccess stack [ stack_top - 1 ]
<operator>.indirectIndexAccess char_count [ curr_top ]
<operator>.indirectIndexAccess temp [ 0 ]
<operator>.indirectIndexAccess temp [ 0 ]
<operator>.indirectIndexAccess temp [ 0 ]
<operator>.indirectIndexAccess temp [ 1 ]
<operator>.indirectIndexAccess stack [ stack_top - 1 ]
<operator>.indirectIndexAccess interactions [ curr_top ]
<operator>.indirectIndexAccess temp [ 0 ]
<operator>.indirectIndexAccess temp [ 1 ]
<operator>.indirectIndexAccess oppositions [ curr_char ] [ i ]
<operator>.indirectIndexAccess char_count [ i ]
<operator>.indirectIndexAccess oppositions [ curr_char ]
>>>PDG&125 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->24 0->25 0->26 0->29 0->30 0->31 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->42 0->43 0->44 0->45 0->46 0->47 0->50 0->51 0->52 0->53 0->54 0->55 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->85 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->18 5->20 5->22 5->24 5->27 5->28 5->29 5->30 5->33 5->37 5->42 5->46 5->47 5->48 5->49 5->86 5->87 5->88 5->89 5->90 6->1 6->5 7->4 8->1 8->5 9->1 9->1 10->1 10->1 10->1 11->1 11->1 11->1 11->41 11->58 11->60 11->63 11->83 12->1 12->18 13->14 13->20 14->1 14->13 14->20 15->1 15->24 15->50 16->1 16->6 17->1 17->1 18->1 18->1 18->12 18->18 18->19 18->19 18->31 18->32 18->56 18->65 18->72 18->73 18->79 18->92 18->98 18->99 18->100 18->104 18->105 18->114 18->115 18->121 19->1 19->18 20->1 20->1 20->1 20->13 20->14 20->20 20->21 20->21 20->34 20->35 20->36 20->66 20->67 20->74 20->75 20->93 20->94 20->101 20->102 20->106 20->107 20->116 20->117 21->1 21->20 22->1 22->1 22->1 22->22 22->23 22->39 22->50 22->76 22->90 23->1 23->1 24->1 24->1 24->16 24->17 24->25 24->42 24->43 24->45 24->55 24->55 24->91 25->1 25->1 25->1 25->25 25->26 25->26 25->44 25->55 25->64 25->103 26->1 26->25 27->9 28->1 28->10 29->11 30->18 31->1 31->32 31->34 31->56 31->65 31->72 31->73 31->77 31->79 32->1 32->1 32->1 33->1 33->20 34->1 34->31 34->66 34->67 34->74 34->75 34->77 35->1 35->1 36->1 36->1 36->1 37->1 37->1 37->1 37->23 38->1 38->1 38->1 39->1 39->40 40->1 40->1 41->1 41->1 41->11 41->63 42->1 42->6 43->1 43->25 44->1 45->1 46->27 47->28 48->1 49->1 50->38 50->39 50->51 50->57 50->58 50->68 50->68 50->69 50->76 50->80 50->80 50->85 50->95 50->108 50->109 50->110 50->111 50->118 50->119 51->1 51->1 51->52 51->54 51->59 51->60 51->61 51->77 51->81 51->112 51->113 51->120 52->1 52->53 52->54 52->70 52->82 52->122 52->124 53->1 53->52 54->1 54->1 54->40 54->41 54->62 54->63 54->71 54->78 54->84 54->96 54->97 55->1 55->25 55->25 56->1 56->1 56->32 57->1 57->1 57->1 58->1 58->1 58->11 58->63 59->1 59->1 59->1 59->38 60->1 60->1 60->11 60->63 61->1 61->52 62->1 62->24 62->50 63->1 63->1 63->1 63->11 63->41 63->58 63->60 63->83 65->79 66->75 67->1 67->31 67->34 67->72 67->74 68->71 68->81 69->1 69->1 69->31 69->34 69->51 69->72 69->74 69->77 70->1 70->1 70->1 70->52 70->53 71->24 71->50 72->73 73->1 73->31 73->34 73->72 73->74 74->67 75->1 75->31 75->34 75->65 75->66 76->57 76->57 77->1 77->31 77->34 77->59 77->59 77->72 77->74 78->63 79->1 79->31 79->34 79->65 79->66 80->85 81->24 81->50 82->1 82->1 82->35 82->70 82->70 82->83 82->123 83->1 83->11 83->63 83->70 83->70 84->1 85->24 85->50
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( void ) { char input [ 200 ] ; int num_cases , curr_case ; char interactions [ 26 ] [ 26 ] ; int num_merge , num_oppose , i ; char temp [ 4 ] ; char oppositions [ 26 ] [ 26 ] ; int opposition_top [ 26 ] ; char stack [ 1000 ] ; int stack_top ; int char_count [ 100 ] ; char * char_ptr ; char curr_top ; char curr_char ; scanf ( "\x25\x64\x0" , & num_cases ) ; for ( curr_case = 1 ; curr_case <= num_cases ; curr_case ++ ) { memset ( interactions , 0 , 26 * 26 * sizeof ( char ) ) ; memset ( oppositions , 0 , 26 * 26 * sizeof ( char ) ) ; memset ( char_count , 0 , 26 * sizeof ( int ) ) ; scanf ( "%d" , & num_merge ) ; for ( i = 0 ; i < num_merge ; i ++ ) { scanf ( "%s" , temp ) ; interactions [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ] = interactions [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ] = temp [ 2 ] ; } scanf ( "%d" , & num_oppose ) ; for ( i = 0 ; i < num_oppose ; i ++ ) { scanf ( "%s" , temp ) ; oppositions [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ] = CLEAR ; oppositions [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ] = CLEAR ; } scanf ( "%d %s" , & num_oppose , input ) ; stack_top = 0 ; for ( char_ptr = input ; curr_char = * char_ptr ; char_ptr ++ ) { if ( stack_top == 0 ) { stack [ stack_top ++ ] = curr_char - 'A' ; char_count [ stack [ stack_top - 1 ] ] ++ ; continue ; } curr_top = stack [ stack_top - 1 ] ; curr_char -= 'A' ; if ( ( temp [ 0 ] = interactions [ curr_top ] [ curr_char ] ) > 0 ) { stack [ stack_top - 1 ] = temp [ 0 ] - 'A' ; char_count [ curr_top ] -- ; continue ; } for ( i = 0 ; i < 26 ; i ++ ) { if ( oppositions [ curr_char ] [ i ] == CLEAR && char_count [ i ] != 0 ) break ; } if ( i != 26 ) { stack_top = 0 ; memset ( char_count , 0 , 26 * sizeof ( int ) ) ; continue ; } stack [ stack_top ++ ] = curr_char ; char_count [ curr_char ] ++ ; } if ( stack_top == 0 ) { printf ( "Case #%d: []\n" , curr_case ) ; continue ; } printf ( "Case #%d: [" , curr_case ) ; for ( i = 0 ; i < stack_top - 1 ; i ++ ) { printf ( "%c, " , stack [ i ] + 'A' ) ; } printf ( "%c]\n" , stack [ i ] + 'A' ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM const char * argv [ ]
scanf scanf ( "\x25\x73\x0" , filename )
strcpy strcpy ( infile , filename )
strcpy strcpy ( outfile , filename )
strcat strcat ( infile , ".in" )
strcat strcat ( outfile , ".out" )
<operator>.assignment * fp = fopen ( infile , "r" )
<operator>.assignment * ofp = fopen ( outfile , "w" )
<operator>.assignment rval = 0
fscanf fscanf ( fp , "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
fopen fopen ( infile , "r" )
fopen fopen ( outfile , "w" )
<operator>.assignment i = 1
fscanf fscanf ( fp , "%d" , & C )
fscanf fscanf ( fp , "%d" , & D )
fscanf fscanf ( fp , "%d" , & N )
fscanf fscanf ( fp , "%s" , & out [ 1 ] )
<operator>.assignment N_ans = N
<operator>.assignment w_idx = 1
memset memset ( w_tbl   0   sizeof ( w_tbl ) )
<operator>.lessThan 1 <missing
<operator>.greaterThan ';'> fprintf ( ofp , "Case #%d: [" , i )
IDENTIFIER ndif <empty>
<operator>.lessEqualsThan j <= C
<operator>.postIncrement j ++
<operator>.lessEqualsThan j <= D
<operator>.postIncrement j ++
<operator>.lessThan j < N_ans
<operator>.lessEqualsThan j <= N_ans
<operator>.postIncrement j ++
<operator>.lessThan i < T
<operator>.lessEqualsThan j <= N_ans
<operator>.postIncrement j ++
<operator>.lessThan i < T
<operator>.assignment j = 1
fscanf fscanf ( fp , "%s" , & c_tbl [ j ] [ 0 ] )
<operator>.assignment j = 1
fscanf fscanf ( fp , "%s" , & d_tbl [ j ] [ 0 ] )
<operator>.assignment j = 1
<operator>.postIncrement j ++
fprintf fprintf ( ofp , "Case #%d: [" , i )
<operator>.assignment j = 1
fprintf fprintf ( ofp , "%c" , out [ j ] )
fprintf fprintf ( ofp , "]\n" )
<operator>.assignment j = 1
printf printf ( "%c" , out [ j ] )
printf printf ( "]\n" )
ctbl_check2 ctbl_check2 ( out [ j ] , out [ j + 1 ] , & rr )
dtbl_check1 dtbl_check1 ( out [ j ] , & rr )
wtbl_check1 wtbl_check1 ( out [ j + 1 ] , & s )
<operator>.lessThan j < N_ans
fprintf fprintf ( ofp , "]" )
<operator>.lessThan j < N_ans
printf printf ( "]" )
out_combine out_combine ( j , rr )
come_back_len come_back_len ( & j , 1 )
<operator>.assignment w_tbl [ w_idx ] = rr
<operator>.postIncrement w_idx ++
out_delete out_delete ( 1 , j + 1 )
<operator>.assignment w_idx = 1
come_back_len come_back_len ( & j , j + 1 )
fprintf fprintf ( ofp , ", " )
printf printf ( ", " )
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.addition j + 1
UNKNOWN g g
UNKNOWN f f
UNKNOWN <missing ';'> ( "Case #%d: [" , i ) ; <missing ';'> ( "Case #%d: [" , i ) ;
UNKNOWN f f
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.addressOf & out [ 1 ]
<operator>.sizeOf sizeof ( w_tbl )
<operator>.indirectIndexAccess out [ 1 ]
<operator>.addressOf & c_tbl [ j ] [ 0 ]
<operator>.addressOf & d_tbl [ j ] [ 0 ]
<operator>.indirectIndexAccess out [ j ]
<operator>.indirectIndexAccess out [ j ]
<operator>.indirectIndexAccess c_tbl [ j ] [ 0 ]
<operator>.indirectIndexAccess d_tbl [ j ] [ 0 ]
<operator>.indirectIndexAccess out [ j ]
<operator>.indirectIndexAccess out [ j + 1 ]
<operator>.addressOf & rr
<operator>.indirectIndexAccess out [ j ]
<operator>.addressOf & rr
<operator>.indirectIndexAccess out [ j + 1 ]
<operator>.addressOf & s
<operator>.indirectIndexAccess c_tbl [ j ]
<operator>.indirectIndexAccess d_tbl [ j ]
<operator>.addressOf & j
<operator>.indirectIndexAccess w_tbl [ w_idx ]
<operator>.addressOf & j
>>>PDG&102 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 2->1 3->1 4->5 5->1 5->6 5->7 6->1 6->1 6->8 7->1 7->17 8->1 8->18 9->1 9->1 9->12 10->1 10->1 10->1 10->47 11->1 11->1 12->1 12->1 12->1 12->14 12->20 12->37 12->40 13->1 14->1 14->1 14->1 14->14 14->15 14->20 14->21 14->22 14->23 14->24 14->25 14->26 14->27 14->28 14->30 14->32 14->34 14->35 14->37 14->37 14->38 14->40 14->41 14->43 14->45 14->47 14->47 14->48 14->51 14->74 14->75 14->76 14->77 14->78 14->79 14->80 14->81 14->82 14->83 15->1 15->14 16->13 17->1 17->9 17->9 18->1 18->10 18->10 19->1 19->14 20->1 20->1 20->21 20->30 20->42 21->1 21->1 21->22 21->32 21->44 22->1 22->1 22->23 22->24 23->1 23->1 23->1 23->20 24->1 24->1 24->34 25->1 25->1 25->64 26->1 26->1 27->1 27->1 28->1 28->1 30->1 30->1 30->20 30->30 30->31 30->31 30->42 30->84 30->88 30->97 31->1 31->30 32->1 32->1 32->21 32->32 32->33 32->33 32->44 32->85 32->89 32->98 33->1 33->32 34->1 34->34 34->35 34->46 34->54 34->61 34->65 34->67 34->70 34->70 34->71 34->72 34->73 34->90 34->91 34->92 35->35 35->36 35->38 35->49 35->57 35->57 35->57 35->86 36->1 36->35 37->40 37->40 37->50 37->58 38->1 38->1 38->1 38->38 38->39 38->52 38->59 38->59 38->59 38->87 39->1 39->38 40->1 40->14 40->15 40->53 40->60 41->30 42->1 42->1 42->21 43->32 44->1 44->1 44->22 45->34 46->1 46->34 47->28 47->28 47->28 47->37 47->49 47->50 47->58 48->35 49->1 49->1 49->50 49->52 49->54 49->58 49->68 50->1 50->1 50->47 51->1 51->38 52->1 52->1 52->49 52->54 53->1 54->1 54->1 54->1 54->1 54->49 54->52 54->55 54->55 54->55 54->56 54->56 54->61 54->61 54->62 54->71 54->93 54->94 54->95 54->96 54->99 55->1 55->1 55->1 55->49 55->52 55->54 55->54 55->61 55->63 55->63 55->64 55->100 56->1 56->1 56->1 56->46 56->54 56->65 56->66 56->67 56->72 56->73 56->101 57->1 57->35 57->36 57->68 58->1 58->1 58->47 59->1 59->38 59->39 59->69 60->1 61->1 61->1 61->34 61->54 61->55 61->62 61->63 62->1 62->1 62->30 62->31 62->32 62->33 62->34 62->35 62->36 62->38 62->39 62->46 62->57 62->59 62->61 62->65 62->67 62->70 62->71 62->72 62->73 63->1 63->1 63->1 63->26 64->1 64->1 65->1 66->1 66->1 66->64 67->1 67->1 67->1 67->30 67->31 67->32 67->33 67->34 67->35 67->36 67->38 67->39 67->46 67->57 67->59 67->61 67->62 67->65 67->70 67->71 67->72 67->73 68->1 68->49 68->50 68->58 69->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( int argc , const char * argv [ ] ) { char filename [ 32 ] ; char infile [ 32 ] , outfile [ 32 ] ; scanf ( "\x25\x73\x0" , filename ) ; strcpy ( infile , filename ) ; strcpy ( outfile , filename ) ; strcat ( infile , ".in" ) ; strcat ( outfile , ".out" ) ; FILE * fp = fopen ( infile , "r" ) , * ofp = fopen ( outfile , "w" ) ; int i , j , k , s , rval = 0 ; fscanf ( fp , "%d" , & T ) ; for ( i = 1 ; i <= T ; i ++ ) { fscanf ( fp , "%d" , & C ) ; for ( j = 1 ; j <= C ; j ++ ) { fscanf ( fp , "%s" , & c_tbl [ j ] [ 0 ] ) ; } fscanf ( fp , "%d" , & D ) ; for ( j = 1 ; j <= D ; j ++ ) { fscanf ( fp , "%s" , & d_tbl [ j ] [ 0 ] ) ; } fscanf ( fp , "%d" , & N ) ; fscanf ( fp , "%s" , & out [ 1 ] ) ; N_ans = N ; w_idx = 1 ; memset ( w_tbl , 0 , sizeof ( w_tbl ) ) ; for ( j = 1 ; j < N_ans ; ) { if ( ctbl_check2 ( out [ j ] , out [ j + 1 ] , & rr ) ) { out_combine ( j , rr ) ; come_back_len ( & j , 1 ) ; continue ; } if ( dtbl_check1 ( out [ j ] , & rr ) ) { w_tbl [ w_idx ] = rr ; w_idx ++ ; } if ( wtbl_check1 ( out [ j + 1 ] , & s ) ) { out_delete ( 1 , j + 1 ) ; w_idx = 1 ; come_back_len ( & j , j + 1 ) ; continue ; } j ++ ; } 1 <missing ';'> fprintf ( ofp , "Case #%d: [" , i ) ; for ( j = 1 ; j <= N_ans ; j ++ ) { fprintf ( ofp , "%c" , out [ j ] ) ; if ( j < N_ans ) fprintf ( ofp , ", " ) ; } if ( i < T ) { fprintf ( ofp , "]\n" ) ; } else { fprintf ( ofp , "]" ) ; } lse printf <missing ';'> ( "Case #%d: [" , i ) ; for ( j = 1 ; j <= N_ans ; j ++ ) { printf ( "%c" , out [ j ] ) ; if ( j < N_ans ) printf ( ", " ) ; } if ( i < T ) { printf ( "]\n" ) ; } else { printf ( "]" ) ; } ndif } return 0 ; }
>>>Func
METHOD toLowerCase
METHOD_RETURN char*
PARAM char * str
RETURN return str ; return str ;
<operator>.lessThan i < strlen ( str )
<operator>.postIncrement i ++
<operator>.assignment str [ i ] = tolower ( str [ i ] )
IDENTIFIER str return str ;
<operator>.assignment i = 0
strlen strlen ( str )
tolower tolower ( str [ i ] )
<operator>.indirectIndexAccess str [ i ]
<operator>.indirectIndexAccess str [ i ]
>>>PDG&13 0->2 0->4 0->5 0->7 0->8 0->9 2->9 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->6 4->9 4->10 4->11 4->12 5->1 5->4 6->1 6->1 6->1 6->7 6->9 6->10 7->3 8->1 8->4 9->1 9->4 9->7 9->10 10->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) char * toLowerCase ( char * str ) { for ( int i = 0 ; i < strlen ( str ) ; i ++ ) str [ i ] = tolower ( str [ i ] ) ; return str ; }
>>>Func
METHOD calc_owp
METHOD_RETURN double
PARAM char grid [ 100 ] [ 101 ]
PARAM int n
PARAM int team
PARAM int exclude
<operator>.assignment owp_total = 0.0
<operator>.assignment opponents = 0
<operator>.assignment owp_avg = owp_total / opponents
RETURN return owp_avg ; return owp_avg ;
<operator>.notEquals i != n
<operator>.preIncrement ++ i
<operator>.notEquals exclude != - 1
IDENTIFIER owp_avg return owp_avg ;
<operator>.assignment i = 0
<operator>.division owp_total / opponents
<operator>.division owp_total / ( n - 2 )
<operator>.logicalAnd i != exclude && grid [ team ] [ i ] != '.'
<operator>.minus - 1
<operator>.assignmentPlus owp_total += calc_wp ( grid , n , i , exclude != - 1 ? exclude : team )
<operator>.preIncrement ++ opponents
<operator>.subtraction n - 2
<operator>.notEquals i != exclude
<operator>.notEquals grid [ team ] [ i ] != '.'
calc_wp calc_wp ( grid , n , i , exclude != - 1 ? exclude : team )
<operator>.conditional exclude != - 1 ? exclude : team
<operator>.notEquals exclude != - 1
<operator>.minus - 1
<operator>.indirectIndexAccess grid [ team ] [ i ]
<operator>.indirectIndexAccess grid [ team ]
>>>PDG&30 0->2 0->3 0->4 0->5 0->6 0->7 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->1 2->24 3->10 4->1 4->24 4->25 5->12 5->22 6->1 6->15 6->19 7->1 7->15 7->20 8->1 8->1 8->1 8->13 9->1 10->1 10->1 10->1 10->10 10->11 10->17 10->21 10->22 10->22 10->24 11->1 11->10 12->1 12->1 12->1 12->16 12->21 13->9 14->1 14->10 15->1 15->1 15->8 15->8 15->16 16->1 16->1 16->1 17->1 17->1 17->1 17->19 17->20 17->24 17->25 17->26 17->27 18->12 19->1 19->1 19->15 20->1 20->15 21->1 21->16 21->16 22->11 22->12 22->17 22->17 22->23 22->24 22->26 22->28 22->29 23->1 23->17 23->17 24->1 24->1 24->10 24->11 24->19 24->19 24->19 24->19 25->1 26->12 26->22 26->24 26->25 27->26
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) double calc_owp ( char grid [ 100 ] [ 101 ] , int n , int team , int exclude ) { double owp_total = 0.0 ; int opponents = 0 ; for ( int i = 0 ; i != n ; ++ i ) { if ( i != exclude && grid [ team ] [ i ] != '.' ) { owp_total += calc_wp ( grid , n , i , exclude != - 1 ? exclude : team ) ; ++ opponents ; } } double owp_avg = owp_total / opponents ; if ( exclude != - 1 ) { owp_total / ( n - 2 ) ; } return owp_avg ; }
>>>Func
METHOD if_oppse
METHOD_RETURN char
PARAM char x
RETURN return 0 ; return 0 ;
<operator>.logicalOr occur [ 'A' - 'A' ] && oops [ x - 'A' ] [ 'A' - 'A' ] || occur [ 'S' - 'A' ] && oops [ x - 'A' ] [ 'S' - 'A' ] || occur [ 'D' - 'A' ] && oops [ x - 'A' ] [ 'D' - 'A' ] || occur [ 'F' - 'A' ] && oops [ x - 'A' ] [ 'F' - 'A' ] || occur [ 'Q' - 'A' ] && oops [ x - 'A' ] [ 'Q' - 'A' ] || occur [ 'W' - 'A' ] && oops [ x - 'A' ] [ 'W' - 'A' ] || occur [ 'E' - 'A' ] && oops [ x - 'A' ] [ 'E' - 'A' ] || occur [ 'R' - 'A' ] && oops [ x - 'A' ] [ 'R' - 'A' ]
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
<operator>.logicalOr occur [ 'A' - 'A' ] && oops [ x - 'A' ] [ 'A' - 'A' ] || occur [ 'S' - 'A' ] && oops [ x - 'A' ] [ 'S' - 'A' ] || occur [ 'D' - 'A' ] && oops [ x - 'A' ] [ 'D' - 'A' ] || occur [ 'F' - 'A' ] && oops [ x - 'A' ] [ 'F' - 'A' ] || occur [ 'Q' - 'A' ] && oops [ x - 'A' ] [ 'Q' - 'A' ] || occur [ 'W' - 'A' ] && oops [ x - 'A' ] [ 'W' - 'A' ] || occur [ 'E' - 'A' ] && oops [ x - 'A' ] [ 'E' - 'A' ]
<operator>.logicalAnd occur [ 'R' - 'A' ] && oops [ x - 'A' ] [ 'R' - 'A' ]
LITERAL 1 return 1 ;
<operator>.logicalOr occur [ 'A' - 'A' ] && oops [ x - 'A' ] [ 'A' - 'A' ] || occur [ 'S' - 'A' ] && oops [ x - 'A' ] [ 'S' - 'A' ] || occur [ 'D' - 'A' ] && oops [ x - 'A' ] [ 'D' - 'A' ] || occur [ 'F' - 'A' ] && oops [ x - 'A' ] [ 'F' - 'A' ] || occur [ 'Q' - 'A' ] && oops [ x - 'A' ] [ 'Q' - 'A' ] || occur [ 'W' - 'A' ] && oops [ x - 'A' ] [ 'W' - 'A' ]
<operator>.logicalAnd occur [ 'E' - 'A' ] && oops [ x - 'A' ] [ 'E' - 'A' ]
<operator>.logicalOr occur [ 'A' - 'A' ] && oops [ x - 'A' ] [ 'A' - 'A' ] || occur [ 'S' - 'A' ] && oops [ x - 'A' ] [ 'S' - 'A' ] || occur [ 'D' - 'A' ] && oops [ x - 'A' ] [ 'D' - 'A' ] || occur [ 'F' - 'A' ] && oops [ x - 'A' ] [ 'F' - 'A' ] || occur [ 'Q' - 'A' ] && oops [ x - 'A' ] [ 'Q' - 'A' ]
<operator>.logicalAnd occur [ 'W' - 'A' ] && oops [ x - 'A' ] [ 'W' - 'A' ]
<operator>.subtraction 'R' - 'A'
<operator>.subtraction 'R' - 'A'
<operator>.logicalOr occur [ 'A' - 'A' ] && oops [ x - 'A' ] [ 'A' - 'A' ] || occur [ 'S' - 'A' ] && oops [ x - 'A' ] [ 'S' - 'A' ] || occur [ 'D' - 'A' ] && oops [ x - 'A' ] [ 'D' - 'A' ] || occur [ 'F' - 'A' ] && oops [ x - 'A' ] [ 'F' - 'A' ]
<operator>.logicalAnd occur [ 'Q' - 'A' ] && oops [ x - 'A' ] [ 'Q' - 'A' ]
<operator>.subtraction 'E' - 'A'
<operator>.subtraction 'E' - 'A'
<operator>.subtraction x - 'A'
<operator>.logicalOr occur [ 'A' - 'A' ] && oops [ x - 'A' ] [ 'A' - 'A' ] || occur [ 'S' - 'A' ] && oops [ x - 'A' ] [ 'S' - 'A' ] || occur [ 'D' - 'A' ] && oops [ x - 'A' ] [ 'D' - 'A' ]
<operator>.logicalAnd occur [ 'F' - 'A' ] && oops [ x - 'A' ] [ 'F' - 'A' ]
<operator>.subtraction 'W' - 'A'
<operator>.subtraction 'W' - 'A'
<operator>.subtraction x - 'A'
<operator>.logicalOr occur [ 'A' - 'A' ] && oops [ x - 'A' ] [ 'A' - 'A' ] || occur [ 'S' - 'A' ] && oops [ x - 'A' ] [ 'S' - 'A' ]
<operator>.logicalAnd occur [ 'D' - 'A' ] && oops [ x - 'A' ] [ 'D' - 'A' ]
<operator>.subtraction 'Q' - 'A'
<operator>.subtraction 'Q' - 'A'
<operator>.subtraction x - 'A'
<operator>.logicalAnd occur [ 'A' - 'A' ] && oops [ x - 'A' ] [ 'A' - 'A' ]
<operator>.logicalAnd occur [ 'S' - 'A' ] && oops [ x - 'A' ] [ 'S' - 'A' ]
<operator>.subtraction 'F' - 'A'
<operator>.subtraction 'F' - 'A'
<operator>.subtraction x - 'A'
<operator>.subtraction 'D' - 'A'
<operator>.subtraction 'D' - 'A'
<operator>.subtraction x - 'A'
<operator>.subtraction 'A' - 'A'
<operator>.subtraction 'A' - 'A'
<operator>.subtraction 'S' - 'A'
<operator>.subtraction 'S' - 'A'
<operator>.subtraction x - 'A'
<operator>.subtraction x - 'A'
<operator>.subtraction x - 'A'
<operator>.indirectIndexAccess occur [ 'R' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ] [ 'R' - 'A' ]
<operator>.indirectIndexAccess occur [ 'E' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ] [ 'E' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ]
<operator>.indirectIndexAccess occur [ 'W' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ] [ 'W' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ]
<operator>.indirectIndexAccess occur [ 'Q' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ] [ 'Q' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ]
<operator>.indirectIndexAccess occur [ 'F' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ] [ 'F' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ]
<operator>.indirectIndexAccess occur [ 'D' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ] [ 'D' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ]
<operator>.indirectIndexAccess occur [ 'A' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ] [ 'A' - 'A' ]
<operator>.indirectIndexAccess occur [ 'S' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ] [ 'S' - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ]
<operator>.indirectIndexAccess oops [ x - 'A' ]
>>>PDG&70 0->2 0->3 0->5 0->6 0->9 0->14 0->15 0->18 0->19 0->20 0->23 0->24 0->25 0->28 0->29 0->30 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 2->1 2->20 2->25 2->30 2->35 2->38 2->43 2->44 2->45 3->1 4->1 4->1 4->1 4->3 4->6 5->3 6->1 7->1 7->1 7->4 7->4 7->8 7->14 7->46 8->1 8->1 8->4 8->4 9->6 10->1 10->1 10->7 10->7 10->11 10->18 10->48 11->1 11->1 11->7 11->7 12->1 12->1 12->10 12->10 12->13 12->23 12->51 13->1 13->1 13->10 13->10 16->1 16->1 16->12 16->12 16->17 16->28 16->54 17->1 17->1 17->12 17->12 20->1 21->1 21->1 21->16 21->16 21->22 21->33 21->57 22->1 22->1 22->16 22->16 25->1 25->20 26->1 26->1 26->21 26->21 26->27 26->36 26->60 27->1 27->1 27->21 27->21 30->1 30->20 30->25 31->1 31->1 31->26 31->26 31->32 31->41 31->65 32->1 32->1 32->26 32->26 35->1 35->20 35->25 35->30 38->1 38->20 38->25 38->30 38->35 43->1 43->20 43->25 43->30 43->35 43->38 44->1 44->20 44->25 44->30 44->35 44->38 44->43 44->45 45->1 45->20 45->25 45->30 45->35 45->38 45->43 46->15 46->20 46->47 46->50 48->19 48->25 48->49 48->53 51->24 51->30 51->52 51->56 54->29 54->35 54->55 54->59 57->34 57->38 57->58 57->62 60->37 60->43 60->61 60->67 63->40 63->44 63->64 63->68 65->42 65->45 65->66 65->69
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) char if_oppse ( char x ) { if ( occur [ 'A' - 'A' ] && oops [ x - 'A' ] [ 'A' - 'A' ] || occur [ 'S' - 'A' ] && oops [ x - 'A' ] [ 'S' - 'A' ] || occur [ 'D' - 'A' ] && oops [ x - 'A' ] [ 'D' - 'A' ] || occur [ 'F' - 'A' ] && oops [ x - 'A' ] [ 'F' - 'A' ] || occur [ 'Q' - 'A' ] && oops [ x - 'A' ] [ 'Q' - 'A' ] || occur [ 'W' - 'A' ] && oops [ x - 'A' ] [ 'W' - 'A' ] || occur [ 'E' - 'A' ] && oops [ x - 'A' ] [ 'E' - 'A' ] || occur [ 'R' - 'A' ] && oops [ x - 'A' ] [ 'R' - 'A' ] ) return 1 ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment * c = argv [ 1 ]
<operator>.assignment wfile = fopen ( "\x70\x72\x6f\x67\x72\x61\x6d\x2e\x74\x78\x74\x0" , "w" )
srand srand ( ( unsigned ) time ( & t ) )
fprintf fprintf ( wfile , "%s" , c )
fclose fclose ( wfile )
<operator>.assignment rfile = fopen ( "program.txt" , "r" )
printf printf ( "\n" )
fclose fclose ( rfile )
RETURN return 0 ; return 0 ;
<operator>.lessThan argc < 2
<operator>.equals wfile == NULL
<operator>.equals rfile == NULL
<operator>.notEquals ( ch = fgetc ( rfile ) ) != EOF
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
fopen fopen ( "\x70\x72\x6f\x67\x72\x61\x6d\x2e\x74\x78\x74\x0" , "w" )
printf printf ( "Error!" )
exit exit ( 1 )
<operator>.cast ( unsigned ) time ( & t )
fopen fopen ( "program.txt" , "r" )
printf printf ( "Error!" )
exit exit ( 1 )
printf printf ( "%c" , ch )
LITERAL 1 return 1 ;
time time ( & t )
<operator>.assignment ch = fgetc ( rfile )
fgetc fgetc ( rfile )
<operator>.indirectIndexAccess argv [ 1 ]
UNKNOWN unsigned unsigned
<operator>.addressOf & t
>>>PDG&34 0->2 0->3 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->30 2->13 3->1 3->4 4->7 5->14 7->8 9->15 12->1 13->1 13->1 13->4 13->5 13->6 13->7 13->8 13->9 13->10 13->11 13->12 13->14 13->15 13->16 13->18 13->19 13->22 13->23 13->28 13->29 13->30 13->31 13->32 13->33 14->7 14->15 14->20 14->21 15->24 15->25 15->30 16->1 16->16 16->26 16->29 16->30 17->12 18->1 19->5 19->5 23->9 23->9 27->18 28->6 28->22 29->16 29->26 30->11 30->16 30->29
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * argv [ ] ) { if ( argc < 2 ) return 1 ; char * c = argv [ 1 ] ; FILE * rfile , * wfile ; wfile = fopen ( "\x70\x72\x6f\x67\x72\x61\x6d\x2e\x74\x78\x74\x0" , "w" ) ; if ( wfile == NULL ) { printf ( "Error!" ) ; exit ( 1 ) ; } time_t t ; srand ( ( unsigned ) time ( & t ) ) ; fprintf ( wfile , "%s" , c ) ; fclose ( wfile ) ; rfile = fopen ( "program.txt" , "r" ) ; if ( rfile == NULL ) { printf ( "Error!" ) ; exit ( 1 ) ; } char ch ; while ( ( ch = fgetc ( rfile ) ) != EOF ) { printf ( "%c" , ch ) ; } printf ( "\n" ) ; fclose ( rfile ) ; return 0 ; }
>>>Func
METHOD checkIO
METHOD_RETURN void
fileread fileread ( & numdataset , DataSet )
printf printf ( "\x5c\x6e\x20\x2a\x2a\x2a\x20\x63\x68\x65\x63\x6b\x49\x4f\x20\x3a\x20\x52\x65\x61\x64\x44\x61\x74\x61\x73\x65\x74\x20\x3d\x20\x25\x64\x5c\x6e\x0" , numdataset )
filewrite filewrite ( numdataset , DataSet )
>>>PDG&5 0->2 0->3 0->4 2->1 2->1 2->3 2->4 2->4 3->1 3->4 4->1 4->1 4->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void checkIO ( ) { int numdataset ; TypeDataSet DataSet [ MAX_DATASET ] ; fileread ( & numdataset , DataSet ) ; printf ( "\x5c\x6e\x20\x2a\x2a\x2a\x20\x63\x68\x65\x63\x6b\x49\x4f\x20\x3a\x20\x52\x65\x61\x64\x44\x61\x74\x61\x73\x65\x74\x20\x3d\x20\x25\x64\x5c\x6e\x0" , numdataset ) ; filewrite ( numdataset , DataSet ) ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf ( "\x45\x6e\x74\x65\x72\x20\x6e\x61\x6d\x65\x20\x6f\x66\x20\x69\x6e\x70\x75\x74\x20\x66\x69\x6c\x65\x20\x3a\x20\x0" )
scanf scanf ( "%s" , fname )
<operator>.assignment fp = fopen ( fname , "r" )
<operator>.assignment fp2 = fopen ( "output" , "w" )
<operator>.assignment no = 0
RETURN return 0 ; return 0 ;
IDENTIFIER fp if (fp)
LITERAL 0 return 0 ;
fopen fopen ( fname , "r" )
fopen fopen ( "output" , "w" )
<operator>.assignment t = getno ( fp )
<operator>.logicalAnd fp && ! feof ( fp ) && no < t
getno getno ( fp )
<operator>.assignment com [ 3 ] = { '-'   '-'   '-' }
<operator>.assignment opp [ 2 ] = { '-'   '-' }
<operator>.assignment c = getno ( fp )
<operator>.assignment d = getno ( fp )
<operator>.assignment n = getno ( fp )
<operator>.assignment pos = 0
<operator>.assignment i = 0
fprintf fprintf ( fp2 , "Case #%d: [" , ++ no )
getc getc ( fp )
<operator>.logicalAnd fp && ! feof ( fp )
<operator>.lessThan no < t
<operator>.notEquals c != 0
<operator>.notEquals d != 0
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < pos - 1
<operator>.postIncrement i ++
fprintf fprintf ( fp2 , "%c, " , nlist [ i ] )
<operator>.greaterThan pos > 0
<operator>.logicalNot ! feof ( fp )
<operator>.arrayInitializer { '-'   '-'   '-' }
<operator>.arrayInitializer { '-'   '-' }
getno getno ( fp )
<operator>.assignment com [ 0 ] = getc ( fp )
<operator>.assignment com [ 1 ] = getc ( fp )
<operator>.assignment com [ 2 ] = getc ( fp )
getc getc ( fp )
getno getno ( fp )
<operator>.assignment opp [ 0 ] = getc ( fp )
<operator>.assignment opp [ 1 ] = getc ( fp )
getc getc ( fp )
getno getno ( fp )
<operator>.preIncrement ++ no
<operator>.assignment i = 0
<operator>.assignment list [ i ] = getc ( fp )
<operator>.assignment i = 0
fprintf fprintf ( fp2 , "%c]\n" , nlist [ i ] )
feof feof ( fp )
<operator>.notEquals i != 0
<operator>.subtraction pos - 1
fprintf fprintf ( fp2 , "]\n" )
getc getc ( fp )
getc getc ( fp )
getc getc ( fp )
getc getc ( fp )
getc getc ( fp )
getc getc ( fp )
<operator>.assignment mod = 0
<operator>.greaterThan c > 0
<operator>.logicalAnd d > 0 && mod != 1
<operator>.equals mod == 0
<operator>.assignment nlist [ pos ++ ] = list [ i ]
<operator>.assignment nlist [ pos ++ ] = list [ i ]
<operator>.logicalOr ( list [ i ] == com [ 0 ] && nlist [ pos - 1 ] == com [ 1 ] ) || ( list [ i ] == com [ 1 ] && nlist [ pos - 1 ] == com [ 0 ] )
<operator>.greaterThan d > 0
<operator>.notEquals mod != 1
<operator>.equals list [ i ] == opp [ 0 ]
<operator>.expressionList nlist [ pos - 1 ] = com [ 2 ]   mod = 1
<operator>.postIncrement pos ++
<operator>.logicalAnd list [ i ] == com [ 0 ] && nlist [ pos - 1 ] == com [ 1 ]
<operator>.logicalAnd list [ i ] == com [ 1 ] && nlist [ pos - 1 ] == com [ 0 ]
<operator>.notEquals find ( nlist , pos , opp [ 1 ] ) != - 1
<operator>.postIncrement pos ++
<operator>.equals list [ i ] == com [ 0 ]
<operator>.equals nlist [ pos - 1 ] == com [ 1 ]
<operator>.equals list [ i ] == com [ 1 ]
<operator>.equals nlist [ pos - 1 ] == com [ 0 ]
<operator>.assignment nlist [ pos - 1 ] = com [ 2 ]
<operator>.assignment mod = 1
<operator>.expressionList pos = 0   mod = 2
<operator>.equals list [ i ] == opp [ 1 ]
find find ( nlist , pos , opp [ 1 ] )
<operator>.minus - 1
<operator>.subtraction pos - 1
<operator>.subtraction pos - 1
<operator>.subtraction pos - 1
<operator>.assignment pos = 0
<operator>.assignment mod = 2
<operator>.notEquals find ( nlist , pos , opp [ 0 ] ) != - 1
<operator>.expressionList pos = 0   mod = 2
find find ( nlist , pos , opp [ 0 ] )
<operator>.minus - 1
<operator>.assignment pos = 0
<operator>.assignment mod = 2
<operator>.indirectIndexAccess nlist [ i ]
<operator>.indirectIndexAccess com [ 0 ]
<operator>.indirectIndexAccess com [ 1 ]
<operator>.indirectIndexAccess com [ 2 ]
<operator>.indirectIndexAccess opp [ 0 ]
<operator>.indirectIndexAccess opp [ 1 ]
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess nlist [ i ]
<operator>.indirectIndexAccess nlist [ pos ++ ]
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess nlist [ pos ++ ]
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess opp [ 0 ]
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess com [ 0 ]
<operator>.indirectIndexAccess nlist [ pos - 1 ]
<operator>.indirectIndexAccess com [ 1 ]
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess com [ 1 ]
<operator>.indirectIndexAccess nlist [ pos - 1 ]
<operator>.indirectIndexAccess com [ 0 ]
<operator>.indirectIndexAccess nlist [ pos - 1 ]
<operator>.indirectIndexAccess com [ 2 ]
<operator>.indirectIndexAccess opp [ 1 ]
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess opp [ 1 ]
<operator>.indirectIndexAccess opp [ 0 ]
>>>PDG&127 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->14 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->41 0->42 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->65 0->69 0->70 0->72 0->73 0->77 0->83 0->84 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->94 0->95 0->96 0->97 0->98 2->1 3->10 4->1 4->1 4->1 4->14 5->1 5->1 5->1 5->22 6->1 6->1 6->25 6->47 7->1 9->7 10->1 10->4 10->4 11->5 11->5 12->1 12->1 12->1 12->25 13->1 13->1 13->1 13->13 13->15 13->16 13->17 13->18 13->19 13->20 13->21 13->22 13->23 13->24 13->26 13->27 13->28 13->30 13->33 13->34 13->35 13->36 13->37 13->42 13->46 13->47 13->48 13->50 13->52 13->54 14->12 14->24 14->52 15->1 15->1 15->1 15->72 15->78 15->79 15->80 15->81 15->82 16->1 16->1 16->1 16->71 16->85 16->86 16->95 17->1 17->26 18->1 18->27 19->1 19->1 19->28 20->1 20->54 20->73 20->77 20->86 20->88 20->89 20->90 20->95 22->1 22->1 22->32 22->51 22->55 23->24 23->52 24->1 24->1 24->13 24->13 24->25 24->37 25->1 25->1 25->13 25->13 25->47 26->1 26->1 26->38 26->39 26->40 26->41 26->56 26->57 26->58 26->63 26->100 26->101 26->102 27->1 27->1 27->43 27->44 27->45 27->59 27->60 27->69 27->103 27->104 28->1 28->1 28->28 28->29 28->49 28->53 28->53 28->61 28->105 29->1 29->28 30->1 30->1 30->1 30->30 30->31 30->31 30->32 30->54 30->99 31->1 31->30 32->1 32->1 32->51 32->51 32->55 32->86 32->95 33->1 33->1 33->51 33->55 33->106 34->1 34->24 35->15 36->16 37->17 37->42 37->56 38->1 38->1 38->78 39->1 39->1 39->79 39->80 40->1 40->1 40->72 40->82 41->42 42->18 42->46 42->59 43->1 43->1 43->71 44->1 44->1 44->85 44->86 45->46 46->19 46->23 46->61 47->1 47->22 47->25 48->28 49->1 49->1 49->66 49->67 49->71 49->78 50->1 50->30 51->1 51->1 51->1 51->22 51->32 51->86 51->95 52->24 52->34 53->1 53->29 53->62 53->63 53->64 53->65 53->66 53->69 53->73 53->107 53->108 54->30 54->30 54->33 55->1 55->1 55->22 56->38 56->57 57->39 57->58 58->40 58->41 59->43 59->60 60->44 60->45 61->23 61->49 62->1 62->65 62->70 63->1 63->1 63->68 63->74 63->78 63->113 63->114 64->1 64->1 64->1 64->71 64->111 64->112 65->1 65->1 65->67 65->77 65->109 65->110 66->1 66->1 66->1 66->86 66->95 67->1 67->1 67->1 67->86 67->95 68->1 68->1 68->1 68->72 68->82 68->83 68->90 68->121 68->122 69->1 69->64 69->64 69->70 70->64 70->64 70->65 71->1 71->1 71->1 71->67 71->76 71->85 71->85 71->86 71->87 71->95 71->123 71->124 71->125 72->1 72->1 72->1 73->54 73->77 73->86 73->88 73->89 73->90 73->95 74->1 74->1 74->68 74->68 74->75 74->80 74->117 74->118 75->1 75->1 75->68 75->68 76->1 76->1 76->1 76->84 76->91 76->92 77->54 77->73 77->86 77->88 77->89 77->90 77->95 78->1 78->1 78->67 78->71 78->74 78->74 78->79 78->80 78->81 78->88 78->115 78->116 79->1 79->1 79->74 79->74 79->80 79->81 79->86 79->95 80->1 80->1 80->67 80->71 80->75 80->75 80->79 80->81 80->89 80->119 80->120 81->1 81->1 81->75 81->75 81->78 81->79 81->86 81->95 82->1 82->1 82->72 82->79 82->81 82->86 82->95 83->65 83->70 83->72 84->1 84->1 84->1 85->1 85->1 85->1 85->67 85->86 85->93 85->95 85->96 85->126 86->1 86->1 86->32 86->51 86->54 86->73 86->76 86->76 86->76 86->77 86->79 86->81 86->85 86->88 86->89 86->90 86->95 86->95 87->76 88->54 88->73 88->77 88->86 88->89 88->90 88->95 89->54 89->73 89->77 89->86 89->88 89->90 89->95 90->54 90->73 90->77 90->86 90->88 90->89 90->95 91->54 91->73 91->77 91->84 91->86 91->88 91->89 91->90 91->95 92->65 92->84 93->1 93->1 93->1 93->94 93->97 93->98 94->1 94->1 94->1 95->1 95->1 95->32 95->51 95->54 95->71 95->73 95->77 95->79 95->81 95->86 95->86 95->88 95->89 95->90 95->93 95->93 95->93 96->93 97->54 97->73 97->77 97->86 97->88 97->89 97->90 97->94 97->95 98->65 98->94
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { FILE * fp , * fp2 ; char fname [ 20 ] ; printf ( "\x45\x6e\x74\x65\x72\x20\x6e\x61\x6d\x65\x20\x6f\x66\x20\x69\x6e\x70\x75\x74\x20\x66\x69\x6c\x65\x20\x3a\x20\x0" ) ; scanf ( "%s" , fname ) ; fp = fopen ( fname , "r" ) ; fp2 = fopen ( "output" , "w" ) ; int no = 0 ; if ( fp ) { int t ; t = getno ( fp ) ; while ( fp && ! feof ( fp ) && no < t ) { int c , d , n ; char com [ 3 ] = { '-' , '-' , '-' } , opp [ 2 ] = { '-' , '-' } ; c = getno ( fp ) ; if ( c != 0 ) { com [ 0 ] = getc ( fp ) ; com [ 1 ] = getc ( fp ) ; com [ 2 ] = getc ( fp ) ; getc ( fp ) ; } d = getno ( fp ) ; if ( d != 0 ) { opp [ 0 ] = getc ( fp ) ; opp [ 1 ] = getc ( fp ) ; getc ( fp ) ; } n = getno ( fp ) ; char list [ n ] , nlist [ n ] ; int pos = 0 , i = 0 ; fprintf ( fp2 , "Case #%d: [" , ++ no ) ; for ( i = 0 ; i < n ; i ++ ) { list [ i ] = getc ( fp ) ; if ( i != 0 ) { int mod = 0 ; if ( c > 0 ) if ( ( list [ i ] == com [ 0 ] && nlist [ pos - 1 ] == com [ 1 ] ) || ( list [ i ] == com [ 1 ] && nlist [ pos - 1 ] == com [ 0 ] ) ) nlist [ pos - 1 ] = com [ 2 ] , mod = 1 ; if ( d > 0 && mod != 1 ) if ( list [ i ] == opp [ 0 ] ) { if ( find ( nlist , pos , opp [ 1 ] ) != - 1 ) pos = 0 , mod = 2 ; } else if ( list [ i ] == opp [ 1 ] ) { if ( find ( nlist , pos , opp [ 0 ] ) != - 1 ) pos = 0 , mod = 2 ; } if ( mod == 0 ) nlist [ pos ++ ] = list [ i ] ; } else nlist [ pos ++ ] = list [ i ] ; } for ( i = 0 ; i < pos - 1 ; i ++ ) fprintf ( fp2 , "%c, " , nlist [ i ] ) ; if ( pos > 0 ) fprintf ( fp2 , "%c]\n" , nlist [ i ] ) ; else fprintf ( fp2 , "]\n" ) ; getc ( fp ) ; } } return 0 ; }
>>>Func
METHOD read_string
METHOD_RETURN char*
PARAM void
<operator>.assignment s [ strcspn ( s , "\r\n" ) ] = 0
RETURN return strdup ( s ) ; return strdup ( s ) ;
<operator>.logicalNot ! fgets ( s , 1000 , stdin )
strdup strdup ( s )
perror perror ( "\x66\x67\x65\x74\x73\x0" )
exit exit ( - 1 )
fgets fgets ( s , 1000 , stdin )
strcspn strcspn ( s , "\r\n" )
<operator>.minus - 1
>>>PDG&12 0->2 0->3 0->6 0->7 0->9 0->10 0->11 2->1 3->1 3->1 3->6 4->1 5->1 5->1 5->7 5->8 5->11 6->1 6->1 6->4 7->1 8->1 9->1 9->5 9->5 9->5 9->10 10->6 11->8
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) char * read_string ( void ) { char s [ 1000 ] ; if ( ! fgets ( s , 1000 , stdin ) ) { perror ( "\x66\x67\x65\x74\x73\x0" ) ; exit ( - 1 ) ; } s [ strcspn ( s , "\r\n" ) ] = 0 ; return strdup ( s ) ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & ntest )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan testno <= ntest
<operator>.postIncrement testno ++
LITERAL 0 return 0 ;
<operator>.assignment testno = 1
<operator>.assignment res = 0
scanf scanf ( "%lld%d%d" , & N , & PD , & PG )
printf printf ( "Case #%d: %s\n" , testno , res ? "Possible" : "Broken" )
<operator>.logicalOr PG == 0 || PG == 100
<operator>.conditional res ? "Possible" : "Broken"
<operator>.equals PG == 0
<operator>.equals PG == 100
<operator>.equals PD == PG
<operator>.assignment d = ( long long ) gcd ( PD , 100 )
<operator>.assignment res = 1
<operator>.greaterEqualsThan N >= ( long long ) 100 / d
<operator>.assignment res = 0
<operator>.cast ( long long ) gcd ( PD , 100 )
<operator>.assignment res = 1
gcd gcd ( PD , 100 )
<operator>.division ( long long ) 100 / d
<operator>.assignment res = 0
<operator>.cast ( long long ) 100
<operator>.addressOf & N
<operator>.addressOf & PD
<operator>.addressOf & PG
UNKNOWN long long long long
UNKNOWN long long long long
>>>PDG&31 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->21 0->22 0->23 0->24 0->25 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->10 4->11 4->12 4->13 4->26 4->27 4->28 5->1 5->4 6->3 7->1 7->4 8->1 9->1 9->1 9->1 9->18 10->1 10->1 10->5 11->1 11->1 11->1 11->15 11->16 11->18 11->20 11->22 11->23 11->25 11->29 11->30 12->1 13->1 13->11 13->11 13->14 13->14 13->15 14->1 14->11 14->11 14->13 14->15 15->1 15->1 15->1 15->13 15->17 15->19 15->22 16->1 16->1 16->23 17->1 18->1 18->1 18->1 18->9 18->21 18->24 19->1 20->1 21->1 22->1 22->15 22->16 22->16 22->20 22->20 23->1 23->1 23->18 23->18 24->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int ntest , testno ; scanf ( "\x25\x64\x0" , & ntest ) ; for ( testno = 1 ; testno <= ntest ; testno ++ ) { long long N ; int PD , PG ; int res = 0 ; scanf ( "%lld%d%d" , & N , & PD , & PG ) ; if ( PG == 0 || PG == 100 ) { if ( PD == PG ) { res = 1 ; } else { res = 0 ; } } else { long long d = ( long long ) gcd ( PD , 100 ) ; if ( N >= ( long long ) 100 / d ) { res = 1 ; } else { res = 0 ; } } printf ( "Case #%d: %s\n" , testno , res ? "Possible" : "Broken" ) ; } return 0 ; }
>>>Func
METHOD checkOppose
METHOD_RETURN int
<operator>.assignment i = 0
<operator>.assignment flag = 0
RETURN return flag ; return flag ;
<operator>.lessThan i < d
<operator>.preIncrement ++ i
IDENTIFIER flag return flag ;
<operator>.assignment fc = D [ i ] [ 0 ]
<operator>.assignment sc = D [ i ] [ 1 ]
<operator>.assignment fcFlag = scFlag = 0
<operator>.lessThan j < opc
<operator>.preIncrement ++ j
<operator>.logicalAnd fcFlag && scFlag
<operator>.assignment scFlag = 0
<operator>.assignment j = 0
<operator>.equals OP [ j ] == fc
<operator>.assignment flag = 1
<operator>.assignment opc = 0
<operator>.assignment fcFlag = 1
<operator>.equals OP [ j ] == sc
<operator>.assignment scFlag = 1
<operator>.indirectIndexAccess D [ i ] [ 0 ]
<operator>.indirectIndexAccess D [ i ] [ 1 ]
<operator>.indirectIndexAccess D [ i ]
<operator>.indirectIndexAccess D [ i ]
<operator>.indirectIndexAccess OP [ j ]
<operator>.indirectIndexAccess OP [ j ]
>>>PDG&28 0->2 0->3 0->5 0->6 0->7 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 2->1 2->5 3->1 3->1 3->7 4->1 5->1 5->1 5->1 5->6 5->8 5->9 5->10 5->11 5->13 5->14 5->15 5->22 5->23 5->24 5->25 6->1 6->5 7->4 8->1 8->1 8->1 8->16 9->1 9->1 9->1 9->20 10->1 10->1 10->13 11->1 11->1 11->1 11->11 11->12 11->12 11->16 11->26 12->1 12->11 13->1 13->1 13->1 13->5 13->6 13->17 13->18 14->10 14->13 15->1 15->11 16->1 16->1 16->1 16->19 16->20 16->20 16->27 17->1 17->1 17->7 18->1 18->1 19->1 19->13 20->1 20->1 20->1 20->16 20->21 21->1 21->13
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int checkOppose ( ) { int i = 0 , j , fcFlag , scFlag , flag = 0 ; char fc , sc ; for ( ; i < d ; ++ i ) { fc = D [ i ] [ 0 ] ; sc = D [ i ] [ 1 ] ; fcFlag = scFlag = 0 ; for ( j = 0 ; j < opc ; ++ j ) if ( OP [ j ] == fc ) fcFlag = 1 ; else if ( OP [ j ] == sc ) scFlag = 1 ; if ( fcFlag && scFlag ) { flag = 1 ; opc = 0 ; break ; } } return flag ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf ( "\x4e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x63\x6f\x69\x6e\x73\x3f\x20\x0" )
scanf scanf ( "%d" , & m )
<operator>.assignment * coin = ( int * ) malloc ( m * sizeof ( int ) )
printf printf ( "---- your requests --- \n" )
free free ( coin )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < m
<operator>.postIncrement i ++
LITERAL 1 while (1)
LITERAL 0 return 0 ;
<operator>.cast ( int * ) malloc ( m * sizeof ( int ) )
<operator>.assignment i = 0
printf printf ( "coin? " )
scanf scanf ( "%d" , & coin [ i ] )
printf printf ( "amount? exit(0) " )
scanf scanf ( "%d" , & n )
printf printf ( "%d\n"   ways ( n , coin , m ) )
malloc malloc ( m * sizeof ( int ) )
<operator>.logicalNot ! n
<operator>.multiplication m * sizeof ( int )
ways ways ( n , coin , m )
<operator>.sizeOf sizeof ( int )
<operator>.addressOf & coin [ i ]
<operator>.addressOf & n
<operator>.indirectIndexAccess coin [ i ]
>>>PDG&27 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->16 0->17 0->18 0->20 0->21 0->22 2->1 3->1 3->8 3->21 3->22 4->1 4->1 4->6 4->15 4->22 5->1 6->1 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->14 8->15 8->22 8->24 8->26 9->1 9->8 11->7 12->1 13->1 13->8 14->1 15->1 15->6 15->22 16->1 17->1 17->20 17->22 18->1 18->1 19->1 19->4 19->12 20->1 20->1 20->16 20->17 20->18 20->20 20->22 20->22 20->25 21->8 21->19 22->1 22->1 22->6 22->17 22->18 22->18 22->18 22->20 23->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { int m ; int t ; int n ; printf ( "\x4e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x63\x6f\x69\x6e\x73\x3f\x20\x0" ) ; scanf ( "%d" , & m ) ; int * coin = ( int * ) malloc ( m * sizeof ( int ) ) , i ; for ( i = 0 ; i < m ; i ++ ) { printf ( "coin? " ) ; scanf ( "%d" , & coin [ i ] ) ; } printf ( "---- your requests --- \n" ) ; while ( 1 ) { printf ( "amount? exit(0) " ) ; scanf ( "%d" , & n ) ; if ( ! n ) { break ; } printf ( "%d\n" , ways ( n , coin , m ) ) ; } free ( coin ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan iT < T
<operator>.postIncrement iT ++
LITERAL 0 return 0 ;
<operator>.assignment iT = 0
memset memset ( a   0   sizeof ( a ) )
memset memset ( b   0   sizeof ( b ) )
scanf scanf ( "%d" , & A )
scanf scanf ( "%d" , & B )
scanf scanf ( "%d" , & N )
scanf scanf ( "%s" , s )
<operator>.assignment nowc = 0
printf printf ( "Case #%d: [" , iT + 1 )
printf printf ( "]\n" )
<operator>.lessThan i < A
<operator>.postIncrement i ++
<operator>.lessThan i < B
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < nowc
<operator>.postIncrement i ++
<operator>.assignment i = 0
scanf scanf ( "%s" , s )
<operator>.assignment a [ s [ 0 ] ] [ s [ 1 ] ] = s [ 2 ]
<operator>.assignment a [ s [ 1 ] ] [ s [ 0 ] ] = s [ 2 ]
<operator>.assignment i = 0
scanf scanf ( "%s" , s )
<operator>.assignment b [ s [ 0 ] ] [ s [ 1 ] ] = 1
<operator>.assignment b [ s [ 1 ] ] [ s [ 0 ] ] = 1
<operator>.assignment i = 0
<operator>.assignment now [ nowc ] = s [ i ]
<operator>.postIncrement nowc ++
<operator>.addition iT + 1
<operator>.assignment i = 0
printf printf ( "%c" , now [ i ] )
<operator>.greaterThan nowc > 1
<operator>.lessThan j < nowc
<operator>.postIncrement j ++
IDENTIFIER i if (i)
<operator>.assignment now [ nowc - 2 ] = a [ now [ nowc - 1 ] ] [ now [ nowc - 2 ] ]
<operator>.postDecrement nowc --
<operator>.assignment j = 0
printf printf ( ", " )
<operator>.equals a [ now [ nowc - 1 ] ] [ now [ nowc - 2 ] ] == 0
<operator>.lessThan k < nowc
<operator>.postIncrement k ++
<operator>.equals nowc == 0
<operator>.assignment k = j
<operator>.subtraction nowc - 2
<operator>.subtraction nowc - 2
<operator>.assignment nowc = 0
<operator>.subtraction nowc - 2
<operator>.subtraction nowc - 1
<operator>.subtraction nowc - 1
<operator>.sizeOf sizeof ( a )
<operator>.sizeOf sizeof ( b )
<operator>.addressOf & A
<operator>.addressOf & B
<operator>.addressOf & N
<operator>.indirectIndexAccess a [ s [ 0 ] ] [ s [ 1 ] ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess a [ s [ 1 ] ] [ s [ 0 ] ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess b [ s [ 0 ] ] [ s [ 1 ] ]
<operator>.indirectIndexAccess b [ s [ 1 ] ] [ s [ 0 ] ]
<operator>.indirectIndexAccess now [ nowc ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess now [ i ]
<operator>.indirectIndexAccess a [ s [ 0 ] ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess a [ s [ 1 ] ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess b [ s [ 0 ] ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess b [ s [ 1 ] ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess now [ nowc - 2 ]
<operator>.indirectIndexAccess a [ now [ nowc - 1 ] ] [ now [ nowc - 2 ] ]
<operator>.indirectIndexAccess a [ now [ nowc - 1 ] ] [ now [ nowc - 2 ] ]
<operator>.indirectIndexAccess a [ now [ nowc - 1 ] ]
<operator>.indirectIndexAccess now [ nowc - 2 ]
<operator>.indirectIndexAccess a [ now [ nowc - 1 ] ]
<operator>.indirectIndexAccess now [ nowc - 2 ]
<operator>.indirectIndexAccess now [ nowc - 1 ]
<operator>.indirectIndexAccess b [ now [ j ] ] [ now [ k ] ]
<operator>.indirectIndexAccess now [ nowc - 1 ]
<operator>.indirectIndexAccess b [ now [ j ] ]
<operator>.indirectIndexAccess now [ k ]
<operator>.indirectIndexAccess now [ j ]
>>>PDG&97 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->15 4->16 4->17 4->19 4->21 4->23 4->25 4->29 4->33 4->36 4->36 4->37 4->58 4->59 4->60 4->61 4->62 5->1 5->4 6->3 7->1 7->4 8->1 8->1 9->1 9->1 10->1 10->17 11->1 11->19 12->1 12->21 13->1 13->26 13->30 13->34 14->1 14->23 14->35 15->1 15->1 16->1 17->1 17->1 17->10 17->17 17->18 17->18 17->26 17->27 17->28 17->63 17->64 17->65 17->66 17->72 17->73 17->74 17->75 17->80 17->81 18->1 18->17 19->1 19->1 19->11 19->19 19->20 19->20 19->30 19->31 19->32 19->67 19->68 19->76 19->77 19->78 19->79 19->82 19->83 20->1 20->19 21->1 21->1 21->12 21->21 21->22 21->22 21->34 21->35 21->39 21->40 21->45 21->69 21->70 22->1 22->21 23->1 23->1 23->1 23->23 23->24 23->24 23->38 23->46 23->71 24->1 24->23 25->17 26->13 26->27 26->28 26->30 27->1 27->1 28->1 28->1 28->1 29->19 30->13 31->1 31->1 32->1 32->1 33->21 34->1 34->1 34->1 35->1 35->39 37->1 37->23 38->1 38->1 39->1 39->40 39->47 39->55 39->57 39->57 39->86 39->89 39->90 39->93 40->1 40->1 40->23 40->35 40->41 40->48 40->48 40->50 40->51 40->51 41->1 41->40 43->1 43->1 43->1 44->1 44->39 45->1 45->40 46->1 47->1 47->1 47->39 47->43 47->43 47->44 47->52 47->53 47->56 47->84 47->85 47->87 47->88 47->91 48->1 48->1 48->49 48->50 48->92 48->94 48->95 48->96 49->1 49->48 50->1 50->23 50->35 50->40 50->40 50->41 51->1 51->1 51->48 52->56 53->44 54->1 54->50 55->40 55->52 56->53 57->55 92->48 92->49 92->54
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T , iT ; scanf ( "\x25\x64\x0" , & T ) ; static char a [ MAXN ] [ MAXN ] ; static char b [ MAXN ] [ MAXN ] ; static char s [ MAXN ] ; static char now [ MAXN ] ; int nowc ; for ( iT = 0 ; iT < T ; iT ++ ) { memset ( a , 0 , sizeof ( a ) ) ; memset ( b , 0 , sizeof ( b ) ) ; int A , B , N ; scanf ( "%d" , & A ) ; int i , j , k ; for ( i = 0 ; i < A ; i ++ ) { scanf ( "%s" , s ) ; a [ s [ 0 ] ] [ s [ 1 ] ] = s [ 2 ] ; a [ s [ 1 ] ] [ s [ 0 ] ] = s [ 2 ] ; } scanf ( "%d" , & B ) ; for ( i = 0 ; i < B ; i ++ ) { scanf ( "%s" , s ) ; b [ s [ 0 ] ] [ s [ 1 ] ] = 1 ; b [ s [ 1 ] ] [ s [ 0 ] ] = 1 ; } scanf ( "%d" , & N ) ; scanf ( "%s" , s ) ; nowc = 0 ; for ( i = 0 ; i < N ; i ++ ) { now [ nowc ] = s [ i ] ; nowc ++ ; while ( nowc > 1 ) { if ( a [ now [ nowc - 1 ] ] [ now [ nowc - 2 ] ] == 0 ) break ; now [ nowc - 2 ] = a [ now [ nowc - 1 ] ] [ now [ nowc - 2 ] ] ; nowc -- ; } for ( j = 0 ; j < nowc ; j ++ ) { for ( k = j ; k < nowc ; k ++ ) { if ( b [ now [ j ] ] [ now [ k ] ] ) { nowc = 0 ; break ; } } if ( nowc == 0 ) break ; } } printf ( "Case #%d: [" , iT + 1 ) ; for ( i = 0 ; i < nowc ; i ++ ) { if ( i ) printf ( ", " ) ; printf ( "%c" , now [ i ] ) ; } printf ( "]\n" ) ; } return 0 ; }
>>>Func
METHOD romanToInt
METHOD_RETURN int
PARAM char * s
<operator>.assignment romanToInt = 0
RETURN return romanToInt ; return romanToInt ;
<operator>.lessThan i < strlen ( s )
<operator>.postIncrement i ++
IDENTIFIER romanToInt return romanToInt ;
<operator>.assignment i = 0
strlen strlen ( s )
LITERAL 'I' <empty>
<operator>.assignmentPlus romanToInt += 1
LITERAL 'V' <empty>
<operator>.assignmentPlus romanToInt += 5
LITERAL 'X' <empty>
<operator>.assignmentPlus romanToInt += 10
LITERAL 'L' <empty>
<operator>.assignmentPlus romanToInt += 50
LITERAL 'C' <empty>
<operator>.assignmentPlus romanToInt += 100
LITERAL 'D' <empty>
<operator>.assignmentPlus romanToInt += 500
LITERAL 'M' <empty>
<operator>.assignmentPlus romanToInt += 1000
<operator>.lessThan i + 1 < strlen ( s )
<operator>.lessThan i + 1 < strlen ( s )
<operator>.lessThan i + 1 < strlen ( s )
<operator>.addition i + 1
strlen strlen ( s )
<operator>.logicalOr s [ i + 1 ] == 'V' || s [ i + 1 ] == 'X'
<operator>.addition i + 1
strlen strlen ( s )
<operator>.logicalOr s [ i + 1 ] == 'L' || s [ i + 1 ] == 'C'
<operator>.addition i + 1
strlen strlen ( s )
<operator>.logicalOr s [ i + 1 ] == 'D' || s [ i + 1 ] == 'M'
<operator>.assignmentMinus romanToInt -= 1
<operator>.assignmentMinus romanToInt -= 10
<operator>.assignmentMinus romanToInt -= 100
<operator>.equals s [ i + 1 ] == 'V'
<operator>.equals s [ i + 1 ] == 'X'
<operator>.equals s [ i + 1 ] == 'L'
<operator>.equals s [ i + 1 ] == 'C'
<operator>.equals s [ i + 1 ] == 'D'
<operator>.equals s [ i + 1 ] == 'M'
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i + 1 ]
<operator>.indirectIndexAccess s [ i + 1 ]
<operator>.indirectIndexAccess s [ i + 1 ]
<operator>.indirectIndexAccess s [ i + 1 ]
<operator>.indirectIndexAccess s [ i + 1 ]
<operator>.indirectIndexAccess s [ i + 1 ]
>>>PDG&58 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->31 0->33 0->34 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 2->9 3->1 3->1 3->7 3->11 3->13 3->15 3->17 3->19 3->21 3->23 3->36 3->37 3->38 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->24 5->25 5->26 5->27 5->30 5->33 5->45 5->46 5->47 5->48 5->49 5->50 5->51 6->1 6->5 7->4 8->1 8->5 9->1 9->5 9->28 9->31 9->34 11->1 11->1 11->7 11->13 11->15 11->17 11->19 11->21 11->23 11->36 11->37 11->38 13->1 13->1 13->7 13->11 13->15 13->17 13->19 13->21 13->23 13->36 13->37 13->38 15->1 15->1 15->7 15->11 15->13 15->17 15->19 15->21 15->23 15->36 15->37 15->38 17->1 17->1 17->7 17->11 17->13 17->15 17->19 17->21 17->23 17->36 17->37 17->38 19->1 19->1 19->7 19->11 19->13 19->15 19->17 19->21 19->23 19->36 19->37 19->38 21->1 21->1 21->7 21->11 21->13 21->15 21->17 21->19 21->23 21->36 21->37 21->38 23->1 23->1 23->7 23->11 23->13 23->15 23->17 23->19 23->21 23->36 23->37 23->38 24->1 24->1 24->11 24->29 24->39 24->45 24->52 25->1 25->1 25->15 25->32 25->41 25->47 25->54 26->1 26->1 26->19 26->35 26->43 26->49 26->56 28->9 28->24 28->39 28->40 29->1 29->1 29->1 29->11 29->36 31->9 31->25 31->41 31->42 32->1 32->1 32->1 32->15 32->37 34->9 34->26 34->43 34->44 35->1 35->1 35->1 35->19 35->38 36->1 36->1 36->7 36->11 36->13 36->15 36->17 36->19 36->21 36->23 36->37 36->38 37->1 37->1 37->7 37->11 37->13 37->15 37->17 37->19 37->21 37->23 37->36 37->38 38->1 38->1 38->7 38->11 38->13 38->15 38->17 38->19 38->21 38->23 38->36 38->37 39->1 39->9 39->28 39->29 39->29 39->31 39->34 39->40 39->40 39->41 39->43 39->46 39->53 40->1 40->9 40->28 40->29 40->29 40->31 40->34 40->39 40->41 40->43 41->1 41->9 41->28 41->31 41->32 41->32 41->34 41->39 41->42 41->42 41->43 41->48 41->55 42->1 42->9 42->28 42->31 42->32 42->32 42->34 42->39 42->41 42->43 43->1 43->9 43->28 43->31 43->34 43->35 43->35 43->39 43->41 43->44 43->44 43->50 43->57 44->1 44->9 44->28 44->31 44->34 44->35 44->35 44->39 44->41 44->43 51->13 51->17 51->21 51->23 51->24 51->25 51->26 51->27 51->28 51->30 51->31 51->33 51->34
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int romanToInt ( char * s ) { int romanToInt = 0 ; for ( int i = 0 ; i < strlen ( s ) ; i ++ ) { switch ( s [ i ] ) { case 'I' : if ( i + 1 < strlen ( s ) ) { if ( s [ i + 1 ] == 'V' || s [ i + 1 ] == 'X' ) { romanToInt -= 1 ; break ; } } romanToInt += 1 ; break ; case 'V' : romanToInt += 5 ; break ; case 'X' : if ( i + 1 < strlen ( s ) ) { if ( s [ i + 1 ] == 'L' || s [ i + 1 ] == 'C' ) { romanToInt -= 10 ; break ; } } romanToInt += 10 ; break ; case 'L' : romanToInt += 50 ; break ; case 'C' : if ( i + 1 < strlen ( s ) ) { if ( s [ i + 1 ] == 'D' || s [ i + 1 ] == 'M' ) { romanToInt -= 100 ; break ; } } romanToInt += 100 ; break ; case 'D' : romanToInt += 500 ; break ; case 'M' : romanToInt += 1000 ; break ; default : break ; } } return romanToInt ; }
>>>Func
METHOD rev_xstrcoll_version
METHOD_RETURN int
PARAM V a
PARAM V b
RETURN return cmp_version ( b , a ) ; return cmp_version ( b , a ) ;
cmp_version cmp_version ( b , a )
>>>PDG&6 0->2 0->3 0->5 2->5 3->5 4->1 5->1 5->1 5->1 5->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static int rev_xstrcoll_version ( V a , V b ) { return cmp_version ( b , a ) ; }
>>>Func
METHOD main
METHOD_RETURN void
clrscr clrscr ( )
getch getch ( )
<operator>.notEquals ch != 4
printf printf ( "\x5c\x6e\x20\x4d\x65\x6e\x75\x3a\x20\x5c\x6e\x0" )
printf printf ( "1:Create Linked List \n" )
printf printf ( "2:Delete Node \n" )
printf printf ( "3:Traverse \n" )
printf printf ( "4:Exit \n" )
printf printf ( "\nEnter your choice: " )
scanf scanf ( "%d" , & ch )
IDENTIFIER ch switch(ch)
LITERAL 1 <empty>
create create ( )
LITERAL 2 <empty>
printf printf ( "Enter the data value of the node to be deleted: " )
scanf scanf ( "%d" , & k )
deletenode deletenode ( k )
LITERAL 3 <empty>
traverse traverse ( )
LITERAL 4 <empty>
<operator>.addressOf & ch
<operator>.addressOf & k
>>>PDG&24 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 2->1 3->1 4->1 4->1 4->4 4->5 4->6 4->7 4->8 4->9 4->10 4->11 4->11 4->14 4->16 4->17 4->18 4->20 4->22 4->23 5->1 6->1 7->1 8->1 9->1 10->1 11->1 11->4 14->1 16->1 17->1 17->18 18->1 18->1 18->17 20->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void main ( ) { int x , k , ch ; clrscr ( ) ; do { printf ( "\x5c\x6e\x20\x4d\x65\x6e\x75\x3a\x20\x5c\x6e\x0" ) ; printf ( "1:Create Linked List \n" ) ; printf ( "2:Delete Node \n" ) ; printf ( "3:Traverse \n" ) ; printf ( "4:Exit \n" ) ; printf ( "\nEnter your choice: " ) ; scanf ( "%d" , & ch ) ; switch ( ch ) { case 1 : create ( ) ; break ; case 2 : printf ( "Enter the data value of the node to be deleted: " ) ; scanf ( "%d" , & k ) ; deletenode ( k ) ; break ; case 3 : traverse ( ) ; break ; case 4 : break ; } } while ( ch != 4 ) ; getch ( ) ; }
>>>Func
METHOD init_input_structure
METHOD_RETURN int
PARAM FILE * fp
RETURN return 0 ; return 0 ;
<operator>.notEquals fscanf ( fp , "\x25\x64\x0" , & n_test_case ) != 1
<operator>.lessThan i < n_test_case
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
printf printf ( "Cannot get # of test cases.\n" )
RETURN return - 1 ; return - 1 ;
<operator>.assignment i = 0
fscanf fscanf ( fp , "\x25\x64\x0" , & n_test_case )
<operator>.minus - 1
<operator>.lessThan init_test_case_input ( i , & fp ) < 0
printf printf ( "init_test_case_input failed (%d)." , i )
RETURN return - 1 ; return - 1 ;
init_test_case_input init_test_case_input ( i , & fp )
<operator>.minus - 1
<operator>.addressOf & fp
>>>PDG&19 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->16 0->17 2->11 3->1 4->1 4->1 4->5 4->8 4->9 4->10 4->12 5->3 5->13 5->16 5->16 5->18 6->5 7->3 8->1 9->1 10->5 11->1 11->1 11->4 11->4 11->4 11->5 11->16 12->1 12->9 13->5 13->6 13->14 13->15 13->17 15->1 16->6 16->13 16->13 16->14 17->15
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int init_input_structure ( FILE * fp ) { int i ; if ( fscanf ( fp , "\x25\x64\x0" , & n_test_case ) != 1 ) { printf ( "Cannot get # of test cases.\n" ) ; return - 1 ; } for ( i = 0 ; i < n_test_case ; i ++ ) { if ( init_test_case_input ( i , & fp ) < 0 ) { printf ( "init_test_case_input failed (%d)." , i ) ; return - 1 ; } } return 0 ; }
>>>Func
METHOD calculateScore
METHOD_RETURN int
PARAM int mat [ 10 ] [ 10 ]
PARAM int line
PARAM int column
<operator>.assignment c = 0
<operator>.assignment b = 0
<operator>.assignment e = 0
<operator>.assignment d = 0
RETURN return 0 ; return 0 ;
<operator>.equals mat [ line ] [ column ] == 10
LITERAL 0 return 0 ;
<operator>.assignment mat [ line ] [ column ] = 50
RETURN return 2 ; return 2 ;
LITERAL 2 return 2 ;
<operator>.equals mat [ line ] [ column ] == 20
<operator>.equals mat [ line + 1 ] [ column ] == 20
<operator>.equals mat [ line - 1 ] [ column ] == 20
<operator>.equals mat [ line ] [ column + 1 ] == 20
<operator>.equals mat [ line ] [ column - 1 ] == 20
<operator>.equals b == 1
<operator>.equals c == 1
<operator>.equals d == 1
<operator>.equals e == 1
<operator>.assignment b = 1
<operator>.assignment c = 1
<operator>.assignment d = 1
<operator>.assignment e = 1
<operator>.equals mat [ line ] [ column ] == 30
<operator>.equals mat [ line + 1 ] [ column ] == 20
<operator>.equals mat [ line - 1 ] [ column ] == 20
<operator>.equals mat [ line ] [ column + 1 ] == 20
<operator>.equals mat [ line ] [ column - 1 ] == 20
<operator>.addition column + 1
<operator>.subtraction column - 1
<operator>.assignment mat [ line ] [ column ] = 50
<operator>.assignment mat [ line + 1 ] [ column ] = 50
RETURN return 4 ; return 4 ;
<operator>.assignment mat [ line ] [ column ] = 50
<operator>.assignment mat [ line - 1 ] [ column ] = 50
RETURN return 4 ; return 4 ;
<operator>.assignment mat [ line ] [ column ] = 50
<operator>.assignment mat [ line ] [ column + 1 ] = 50
RETURN return 4 ; return 4 ;
<operator>.assignment mat [ line ] [ column ] = 50
<operator>.assignment mat [ line ] [ column - 1 ] = 50
RETURN return 4 ; return 4 ;
<operator>.equals mat [ line + 1 ] [ column ] == 30
<operator>.equals mat [ line - 1 ] [ column ] == 30
<operator>.equals mat [ line ] [ column + 1 ] == 30
<operator>.equals mat [ line ] [ column - 1 ] == 30
<operator>.logicalAnd b == 1 && c == 1
<operator>.addition line + 1
<operator>.subtraction line - 1
LITERAL 4 return 4 ;
RETURN return 0 ; return 0 ;
LITERAL 4 return 4 ;
RETURN return 0 ; return 0 ;
LITERAL 4 return 4 ;
RETURN return 0 ; return 0 ;
LITERAL 4 return 4 ;
RETURN return 0 ; return 0 ;
<operator>.assignment b = 1
<operator>.assignment c = 1
<operator>.assignment d = 1
<operator>.assignment e = 1
LITERAL 0 return 0 ;
LITERAL 0 return 0 ;
<operator>.addition column + 1
LITERAL 0 return 0 ;
<operator>.subtraction column - 1
LITERAL 0 return 0 ;
<operator>.equals b == 1
<operator>.equals c == 1
<operator>.logicalAnd mat [ line + 1 ] [ column ] == 30 && mat [ line - 1 ] [ column ] == 30
<operator>.addition line + 1
<operator>.subtraction line - 1
<operator>.addition column + 1
<operator>.subtraction column - 1
<operator>.addition column + 1
<operator>.subtraction column - 1
<operator>.assignment mat [ line ] [ column ] = 50
<operator>.assignment mat [ line + 1 ] [ column ] = 50
<operator>.assignment mat [ line - 1 ] [ column ] = 50
RETURN return 7 ; return 7 ;
<operator>.logicalAnd d == 1 && e == 1
<operator>.addition line + 1
<operator>.subtraction line - 1
<operator>.addition line + 1
<operator>.subtraction line - 1
<operator>.equals mat [ line + 1 ] [ column ] == 30
<operator>.equals mat [ line - 1 ] [ column ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.equals d == 1
<operator>.equals e == 1
<operator>.logicalAnd mat [ line ] [ column + 1 ] == 30 && mat [ line ] [ column - 1 ] == 30
<operator>.assignment mat [ line ] [ column ] = 50
<operator>.assignment mat [ line ] [ column - 1 ] = 50
<operator>.assignment mat [ line ] [ column + 1 ] = 50
RETURN return 7 ; return 7 ;
<operator>.equals d == 1
<operator>.addition line + 1
<operator>.subtraction line - 1
<operator>.addition line + 1
<operator>.subtraction line - 1
<operator>.equals mat [ line ] [ column + 1 ] == 30
<operator>.equals mat [ line ] [ column - 1 ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.logicalAnd mat [ line ] [ column + 1 ] == 30 && mat [ line ] [ column + 2 ] == 30
<operator>.addition column + 1
<operator>.subtraction column - 1
<operator>.subtraction column - 1
<operator>.addition column + 1
<operator>.assignment mat [ line ] [ column ] = 50
<operator>.assignment mat [ line ] [ column + 1 ] = 50
<operator>.assignment mat [ line ] [ column + 2 ] = 50
RETURN return 7 ; return 7 ;
<operator>.equals e == 1
<operator>.equals mat [ line ] [ column + 1 ] == 30
<operator>.equals mat [ line ] [ column + 2 ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.logicalAnd mat [ line ] [ column - 1 ] == 30 && mat [ line ] [ column - 2 ] == 30
<operator>.addition column + 1
<operator>.addition column + 2
<operator>.addition column + 1
<operator>.addition column + 2
<operator>.assignment mat [ line ] [ column ] = 50
<operator>.assignment mat [ line ] [ column - 1 ] = 50
<operator>.assignment mat [ line ] [ column - 2 ] = 50
RETURN return 7 ; return 7 ;
<operator>.equals c == 1
<operator>.equals mat [ line ] [ column - 1 ] == 30
<operator>.equals mat [ line ] [ column - 2 ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.logicalAnd mat [ line - 1 ] [ column ] == 30 && mat [ line - 2 ] [ column ] == 30
<operator>.subtraction column - 1
<operator>.subtraction column - 2
<operator>.subtraction column - 1
<operator>.subtraction column - 2
<operator>.assignment mat [ line ] [ column ] = 50
<operator>.assignment mat [ line - 1 ] [ column ] = 50
<operator>.assignment mat [ line - 2 ] [ column ] = 50
RETURN return 7 ; return 7 ;
<operator>.equals b == 1
<operator>.equals mat [ line - 1 ] [ column ] == 30
<operator>.equals mat [ line - 2 ] [ column ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.logicalAnd mat [ line + 1 ] [ column ] == 30 && mat [ line + 2 ] [ column ] == 30
<operator>.assignment mat [ line ] [ column ] = 50
<operator>.assignment mat [ line + 1 ] [ column ] = 50
<operator>.assignment mat [ line + 2 ] [ column ] = 50
RETURN return 7 ; return 7 ;
<operator>.subtraction line - 1
<operator>.subtraction line - 2
<operator>.subtraction line - 1
<operator>.subtraction line - 2
<operator>.equals mat [ line + 1 ] [ column ] == 30
<operator>.equals mat [ line + 2 ] [ column ] == 30
LITERAL 7 return 7 ;
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.addition line + 1
<operator>.addition line + 2
<operator>.addition line + 1
<operator>.addition line + 2
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line + 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line - 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column + 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column - 1 ]
<operator>.indirectIndexAccess mat [ line + 1 ]
<operator>.indirectIndexAccess mat [ line - 1 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line + 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line - 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column + 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column - 1 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line + 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line + 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line - 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line - 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column + 1 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column - 1 ]
<operator>.indirectIndexAccess mat [ line + 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line - 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column + 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column - 1 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line + 1 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line - 1 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line + 1 ]
<operator>.indirectIndexAccess mat [ line - 1 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line + 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line - 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line + 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line - 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line + 1 ]
<operator>.indirectIndexAccess mat [ line - 1 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line + 1 ]
<operator>.indirectIndexAccess mat [ line - 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column + 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column - 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column - 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column + 1 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ] [ column + 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column + 2 ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column + 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column + 2 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ] [ column - 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column - 2 ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column - 1 ]
<operator>.indirectIndexAccess mat [ line ] [ column - 2 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line - 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line - 2 ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line - 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line - 2 ] [ column ]
<operator>.indirectIndexAccess mat [ line - 1 ]
<operator>.indirectIndexAccess mat [ line - 2 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line - 1 ]
<operator>.indirectIndexAccess mat [ line - 2 ]
<operator>.indirectIndexAccess mat [ line + 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line + 2 ] [ column ]
<operator>.indirectIndexAccess mat [ line ] [ column ]
<operator>.indirectIndexAccess mat [ line + 1 ] [ column ]
<operator>.indirectIndexAccess mat [ line + 2 ] [ column ]
<operator>.indirectIndexAccess mat [ line + 1 ]
<operator>.indirectIndexAccess mat [ line + 2 ]
<operator>.indirectIndexAccess mat [ line ]
<operator>.indirectIndexAccess mat [ line + 1 ]
<operator>.indirectIndexAccess mat [ line + 2 ]
>>>PDG&281 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->138 0->139 0->140 0->141 0->143 0->144 0->145 0->146 0->147 0->148 0->149 0->150 0->151 0->152 0->153 0->154 0->155 0->156 0->158 0->159 0->160 0->161 0->162 0->163 0->164 0->165 0->166 0->167 0->168 0->169 0->170 0->171 0->172 0->173 0->174 2->1 3->1 3->52 3->53 3->88 3->89 4->1 4->33 4->34 4->79 4->80 5->1 5->1 5->21 5->73 5->136 6->1 6->1 6->20 6->72 7->1 7->1 7->23 7->96 7->121 8->1 8->1 8->22 8->95 9->1 10->1 10->12 10->13 10->15 10->15 10->175 10->176 10->177 10->178 11->9 12->1 12->1 13->1 14->13 15->16 15->17 15->18 15->19 15->20 15->28 15->28 15->33 15->34 15->52 15->53 15->179 15->180 15->181 15->182 15->183 15->184 15->185 15->186 15->187 15->192 16->24 16->29 17->25 17->30 18->26 18->31 19->27 19->32 20->21 20->29 20->75 20->188 20->193 21->22 21->30 21->76 21->189 21->196 22->23 22->31 22->68 22->190 22->199 23->9 23->32 23->70 23->191 23->202 24->20 25->21 26->22 27->23 28->9 28->47 28->48 28->49 28->50 28->51 28->72 28->79 28->80 28->88 28->89 28->205 28->206 28->207 28->208 28->217 28->218 28->219 28->220 29->35 29->36 29->37 29->55 29->86 29->194 29->195 29->209 29->210 30->38 30->39 30->40 30->57 30->87 30->197 30->198 30->211 30->212 31->41 31->42 31->43 31->59 31->77 31->200 31->201 31->213 31->214 32->44 32->45 32->46 32->61 32->78 32->203 32->204 32->215 32->216 34->68 34->70 34->77 37->1 40->1 43->1 46->1 47->62 47->90 47->166 48->63 48->74 48->91 48->152 49->64 49->107 49->122 50->65 50->97 50->108 50->137 51->74 51->85 51->90 51->95 51->103 51->221 51->226 53->75 53->76 53->86 54->37 55->1 56->40 57->1 58->43 59->1 60->46 61->1 62->72 63->73 63->136 64->95 65->96 65->121 66->55 67->57 69->59 70->78 71->61 72->51 72->51 72->73 72->151 73->51 73->51 73->136 74->81 74->82 74->83 74->84 74->93 74->105 74->106 74->223 74->224 74->225 74->228 74->229 74->230 76->87 80->113 80->114 80->115 80->128 80->129 80->130 80->131 80->143 84->1 85->97 85->102 85->107 85->113 85->231 85->236 89->103 89->104 89->105 89->106 89->162 89->171 89->172 89->173 89->174 90->74 90->74 90->91 90->104 90->222 90->227 91->74 91->74 92->84 93->1 94->93 95->85 95->85 95->96 95->102 96->85 96->85 96->121 97->98 97->99 97->100 97->101 97->110 97->115 97->116 97->233 97->234 97->235 97->238 97->239 97->240 101->1 102->112 102->121 102->122 102->128 102->241 102->246 104->105 104->106 107->97 107->97 107->108 107->114 107->232 107->237 108->97 108->97 109->101 110->1 111->110 112->117 112->118 112->119 112->120 112->125 112->130 112->131 112->243 112->244 112->245 112->248 112->249 112->250 114->115 115->116 120->1 121->127 121->136 121->137 121->143 121->251 121->256 122->112 122->112 122->123 122->129 122->242 122->247 123->112 123->112 124->120 125->1 126->125 127->132 127->133 127->134 127->135 127->140 127->145 127->146 127->253 127->254 127->255 127->258 127->259 127->260 135->1 136->142 136->151 136->152 136->162 136->261 136->266 137->127 137->127 137->138 137->144 137->252 137->257 138->127 138->127 139->135 140->1 141->140 142->147 142->148 142->149 142->150 142->155 142->164 142->165 142->263 142->264 142->265 142->268 142->269 142->270 143->144 143->145 144->145 145->146 150->1 151->9 151->157 151->166 151->171 151->271 151->276 152->142 152->142 152->153 152->163 152->262 152->267 153->142 153->142 154->150 155->1 156->155 157->158 157->159 157->160 157->161 157->169 157->173 157->174 157->273 157->274 157->275 157->278 157->279 157->280 161->1 162->163 162->164 163->164 164->165 166->157 166->157 166->167 166->172 166->272 166->277 167->157 167->157 168->161 169->1 170->169
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int calculateScore ( int mat [ 10 ] [ 10 ] , int line , int column ) { int c = 0 , b = 0 , e = 0 , d = 0 ; if ( mat [ line ] [ column ] == 10 ) { mat [ line ] [ column ] = 50 ; return 2 ; } else if ( mat [ line ] [ column ] == 20 ) { if ( mat [ line + 1 ] [ column ] == 20 ) { b = 1 ; } if ( mat [ line - 1 ] [ column ] == 20 ) { c = 1 ; } if ( mat [ line ] [ column + 1 ] == 20 ) { d = 1 ; } if ( mat [ line ] [ column - 1 ] == 20 ) { e = 1 ; } if ( b == 1 ) { if ( mat [ line + 1 ] [ column ] == 20 ) { mat [ line ] [ column ] = 50 ; mat [ line + 1 ] [ column ] = 50 ; return 4 ; } else { return 0 ; } } if ( c == 1 ) { if ( mat [ line - 1 ] [ column ] == 20 ) { mat [ line ] [ column ] = 50 ; mat [ line - 1 ] [ column ] = 50 ; return 4 ; } else { return 0 ; } } if ( d == 1 ) { if ( mat [ line ] [ column + 1 ] == 20 ) { mat [ line ] [ column ] = 50 ; mat [ line ] [ column + 1 ] = 50 ; return 4 ; } else { return 0 ; } } if ( e == 1 ) { if ( mat [ line ] [ column - 1 ] == 20 ) { mat [ line ] [ column ] = 50 ; mat [ line ] [ column - 1 ] = 50 ; return 4 ; } else { return 0 ; } } } else if ( mat [ line ] [ column ] == 30 ) { if ( mat [ line + 1 ] [ column ] == 30 ) { b = 1 ; } if ( mat [ line - 1 ] [ column ] == 30 ) { c = 1 ; } if ( mat [ line ] [ column + 1 ] == 30 ) { d = 1 ; } if ( mat [ line ] [ column - 1 ] == 30 ) { e = 1 ; } if ( b == 1 && c == 1 ) { if ( mat [ line + 1 ] [ column ] == 30 && mat [ line - 1 ] [ column ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line + 1 ] [ column ] = 50 ; mat [ line - 1 ] [ column ] = 50 ; return 7 ; } else { return 0 ; } } else if ( d == 1 && e == 1 ) { if ( mat [ line ] [ column + 1 ] == 30 && mat [ line ] [ column - 1 ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line ] [ column - 1 ] = 50 ; mat [ line ] [ column + 1 ] = 50 ; return 7 ; } else { return 0 ; } } else if ( d == 1 ) { if ( mat [ line ] [ column + 1 ] == 30 && mat [ line ] [ column + 2 ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line ] [ column + 1 ] = 50 ; mat [ line ] [ column + 2 ] = 50 ; return 7 ; } else { return 0 ; } } else if ( e == 1 ) { if ( mat [ line ] [ column - 1 ] == 30 && mat [ line ] [ column - 2 ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line ] [ column - 1 ] = 50 ; mat [ line ] [ column - 2 ] = 50 ; return 7 ; } else { return 0 ; } } else if ( c == 1 ) { if ( mat [ line - 1 ] [ column ] == 30 && mat [ line - 2 ] [ column ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line - 1 ] [ column ] = 50 ; mat [ line - 2 ] [ column ] = 50 ; return 7 ; } else { return 0 ; } } else if ( b == 1 ) { if ( mat [ line + 1 ] [ column ] == 30 && mat [ line + 2 ] [ column ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line + 1 ] [ column ] = 50 ; mat [ line + 2 ] [ column ] = 50 ; return 7 ; } else { return 0 ; } } } return 0 ; }
>>>Func
METHOD display
METHOD_RETURN void
PARAM const int * arr
PARAM int n
printf printf ( "\n" )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
printf printf ( "\x25\x64\x20\x0" , arr [ i ] )
<operator>.indirectIndexAccess arr [ i ]
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 2->8 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->8 5->9 6->1 6->5 7->1 7->5 8->1 8->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void display ( const int * arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { printf ( "\x25\x64\x20\x0" , arr [ i ] ) ; } printf ( "\n" ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment sum = 0
<operator>.assignment * str = argv [ 1 ]
printf printf ( "\x53\x75\x6d\x20\x69\x73\x3a\x20\x25\x64\x5c\x6e\x0" , sum )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < argv [ 1 ] [ 0 ]
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.preIncrement ++ t
<operator>.assignment t = str
<operator>.assignmentPlus sum += * t
<operator>.indirectIndexAccess argv [ 1 ] [ 0 ]
<operator>.indirectIndexAccess argv [ 1 ]
<operator>.indirection * t
<operator>.indirection * t
>>>PDG&19 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 3->5 4->1 4->6 4->14 5->1 5->1 5->1 5->13 6->1 6->1 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->13 8->15 8->16 8->17 9->1 9->8 10->7 11->1 11->8 12->1 12->1 13->1 13->1 13->1 13->12 14->1 14->1 14->6 17->12 17->14 17->17 17->18
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * argv [ ] ) { int i , j ; int sum = 0 ; const char * str = argv [ 1 ] ; register const char * s , * t ; for ( i = 0 ; i < argv [ 1 ] [ 0 ] ; i ++ ) { for ( t = str ; * t ; ++ t ) { sum += * t ; } } printf ( "\x53\x75\x6d\x20\x69\x73\x3a\x20\x25\x64\x5c\x6e\x0" , sum ) ; return 0 ; }
>>>Func
METHOD get_indice
METHOD_RETURN int
PARAM void * a
<operator>.assignment * temp = ( char * ) a
RETURN return temp [ 0 ] - 'A' ; return temp [ 0 ] - 'A' ;
<operator>.subtraction temp [ 0 ] - 'A'
<operator>.cast ( char * ) a
>>>PDG&7 0->2 0->3 0->5 0->6 2->3 2->6 3->1 3->1 3->1 3->5 4->1 5->1 5->1 5->4 6->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int get_indice ( void * a ) { char * temp = ( char * ) a ; return temp [ 0 ] - 'A' ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & Tcases )
RETURN return 0 ; return 0 ;
<operator>.lessThan cases < Tcases
<operator>.postIncrement cases ++
LITERAL 0 return 0 ;
<operator>.assignment cases = 0
scanf scanf ( "%d " , & N )
printf printf ( "Case #%d:\n" , cases + 1 )
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.assignment i = 0
scanf scanf ( "%s" , input )
<operator>.assignment i = 0
<operator>.assignment wp [ i ] = 0.0
<operator>.assignment cnt = 0
<operator>.assignmentDivision wp [ i ] /= cnt
<operator>.assignment i = 0
<operator>.assignment owp [ i ] = 0.0
<operator>.assignment cnt = 0
<operator>.assignmentDivision owp [ i ] /= cnt
<operator>.assignment i = 0
<operator>.assignment oowp [ i ] = 0.0
<operator>.assignment cnt = 0
<operator>.assignmentDivision oowp [ i ] /= cnt
<operator>.addition cases + 1
<operator>.assignment i = 0
printf printf ( "%.10lf\n" , 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ] )
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment graph [ i ] [ j ] = input [ j ]
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.addition 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ]
<operator>.notEquals graph [ i ] [ j ] != '.'
<operator>.notEquals graph [ i ] [ j ] != '.'
<operator>.notEquals graph [ i ] [ j ] != '.'
<operator>.addition 0.25 * wp [ i ] + 0.5 * owp [ i ]
<operator>.multiplication 0.25 * oowp [ i ]
<operator>.preIncrement ++ cnt
<operator>.assignmentPlus wp [ i ] += graph [ i ] [ j ] == '1'
<operator>.assignment wpj = 0.0
<operator>.assignment cntj = 0
<operator>.preIncrement ++ cnt
<operator>.assignmentPlus owp [ i ] += wpj / cntj
<operator>.preIncrement ++ cnt
<operator>.assignmentPlus oowp [ i ] += owp [ j ]
<operator>.multiplication 0.25 * wp [ i ]
<operator>.multiplication 0.5 * owp [ i ]
<operator>.lessThan k < N
<operator>.postIncrement k ++
<operator>.equals graph [ i ] [ j ] == '1'
<operator>.assignment k = 0
<operator>.division wpj / cntj
<operator>.logicalAnd graph [ j ] [ k ] != '.' && k != i
<operator>.assignmentPlus wpj += graph [ j ] [ k ] == '1'
<operator>.preIncrement ++ cntj
<operator>.notEquals graph [ j ] [ k ] != '.'
<operator>.notEquals k != i
<operator>.equals graph [ j ] [ k ] == '1'
<operator>.addressOf & N
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess graph [ i ] [ j ]
<operator>.indirectIndexAccess input [ j ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess graph [ i ]
<operator>.indirectIndexAccess graph [ i ] [ j ]
<operator>.indirectIndexAccess graph [ i ] [ j ]
<operator>.indirectIndexAccess graph [ i ] [ j ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess graph [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess graph [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess graph [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess graph [ i ] [ j ]
<operator>.indirectIndexAccess graph [ i ]
<operator>.indirectIndexAccess graph [ j ] [ k ]
<operator>.indirectIndexAccess graph [ j ]
<operator>.indirectIndexAccess graph [ j ] [ k ]
<operator>.indirectIndexAccess graph [ j ]
>>>PDG&106 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->47 0->48 0->49 0->51 0->52 0->53 0->55 0->56 0->58 0->59 0->60 0->62 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->72 0->73 0->74 0->75 0->76 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->9 4->10 4->12 4->14 4->16 4->18 4->20 4->22 4->26 4->30 4->34 4->34 4->35 4->77 5->1 5->4 6->3 7->1 7->4 8->1 8->10 8->12 8->14 8->16 8->18 8->37 8->39 8->41 8->43 8->66 9->1 9->1 10->10 10->11 10->11 10->12 10->21 10->37 10->37 10->45 11->1 11->10 12->12 12->13 12->13 12->14 12->23 12->24 12->25 12->39 12->39 12->47 12->78 12->79 13->1 13->12 14->14 14->15 14->15 14->16 14->27 14->28 14->29 14->41 14->41 14->48 14->75 14->80 14->81 15->1 15->14 16->16 16->17 16->17 16->18 16->31 16->32 16->33 16->43 16->43 16->49 16->82 16->83 17->1 17->16 18->1 18->1 18->1 18->8 18->10 18->18 18->19 18->19 18->36 18->50 18->54 18->55 18->64 18->65 18->86 18->91 18->92 19->1 19->18 20->10 21->1 21->46 22->12 23->1 23->25 23->57 24->1 24->25 24->56 25->1 25->1 25->1 25->64 26->14 27->1 27->29 27->61 28->1 28->29 28->60 29->1 29->1 29->1 29->65 30->16 31->1 31->33 31->63 32->1 32->33 32->62 33->1 33->1 33->1 33->55 35->1 35->18 36->1 36->1 37->1 37->1 37->10 37->37 37->38 37->38 37->46 37->84 37->85 37->87 38->1 38->37 39->1 39->1 39->12 39->39 39->40 39->40 39->51 39->88 39->93 40->1 40->39 41->1 41->1 41->14 41->41 41->42 41->42 41->52 41->66 41->89 41->95 42->1 42->41 43->1 43->1 43->16 43->43 43->44 43->44 43->53 43->90 43->97 44->1 44->43 45->1 45->37 46->1 46->1 46->1 46->51 46->52 46->53 47->1 47->39 48->1 48->41 49->1 49->43 50->1 50->1 51->1 51->1 51->52 51->53 51->56 51->57 51->68 51->68 51->94 51->100 51->101 52->1 52->1 52->51 52->53 52->58 52->59 52->60 52->61 52->66 52->69 52->70 52->96 53->1 53->1 53->51 53->52 53->62 53->63 53->98 53->99 54->1 54->1 55->1 55->36 55->36 55->50 55->50 56->1 56->25 57->1 57->1 57->25 58->1 58->70 58->72 59->1 59->70 59->73 60->1 60->29 61->1 61->1 61->29 62->1 62->33 63->1 63->1 63->33 64->1 64->36 64->36 64->50 64->50 64->54 64->54 65->1 65->36 65->36 65->50 65->50 65->54 65->54 66->1 66->1 66->41 66->66 66->67 66->67 66->71 66->74 66->75 66->102 66->103 67->1 67->66 68->1 68->51 68->52 68->53 68->57 68->57 69->1 69->66 70->1 70->1 70->61 70->61 71->1 71->1 71->1 71->72 71->73 71->76 71->104 71->105 72->1 72->1 72->70 73->1 73->70 74->1 74->71 74->71 74->75 74->76 75->15 75->67 75->71 75->71 76->1 76->72 76->72 76->74
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int Tcases ; scanf ( "\x25\x64\x0" , & Tcases ) ; int cases ; for ( cases = 0 ; cases < Tcases ; cases ++ ) { scanf ( "%d " , & N ) ; int i , j , k ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%s" , input ) ; for ( j = 0 ; j < N ; j ++ ) { graph [ i ] [ j ] = input [ j ] ; } } for ( i = 0 ; i < N ; i ++ ) { wp [ i ] = 0.0 ; int cnt = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( graph [ i ] [ j ] != '.' ) { ++ cnt ; wp [ i ] += graph [ i ] [ j ] == '1' ; } } wp [ i ] /= cnt ; } for ( i = 0 ; i < N ; i ++ ) { owp [ i ] = 0.0 ; int cnt = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( graph [ i ] [ j ] != '.' ) { double wpj = 0.0 ; int cntj = 0 ; for ( k = 0 ; k < N ; k ++ ) { if ( graph [ j ] [ k ] != '.' && k != i ) { wpj += graph [ j ] [ k ] == '1' ; ++ cntj ; } } ++ cnt ; owp [ i ] += wpj / cntj ; } } owp [ i ] /= cnt ; } for ( i = 0 ; i < N ; i ++ ) { oowp [ i ] = 0.0 ; int cnt = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( graph [ i ] [ j ] != '.' ) { ++ cnt ; oowp [ i ] += owp [ j ] ; } } oowp [ i ] /= cnt ; } printf ( "Case #%d:\n" , cases + 1 ) ; for ( i = 0 ; i < N ; i ++ ) { printf ( "%.10lf\n" , 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ] ) ; } } return 0 ; }
>>>Func
METHOD elementList
METHOD_RETURN int
PARAM char data [ ]
PARAM int nd
PARAM char comb [ ] [ 4 ]
PARAM int nc
PARAM char opp [ ] [ 3 ]
PARAM int np
RETURN return 0 ; return 0 ;
<operator>.logicalAnd ( comb [ 0 ] [ 0 ] == 'T' ) && ( opp [ 0 ] [ 0 ] == 'T' )
LITERAL 0 return 0 ;
<operator>.equals comb [ 0 ] [ 0 ] == 'T'
<operator>.equals opp [ 0 ] [ 0 ] == 'T'
<operator>.lessEqualsThan i <= nd - 1
<operator>.postIncrement i ++
<operator>.assignment i = 1
<operator>.notEquals data [ i ] != '?'
<operator>.logicalAnd ( comb [ 0 ] [ 0 ] == 'T' ) && ( opp [ 0 ] [ 0 ] == 'F' )
<operator>.subtraction nd - 1
<operator>.assignment c = searchCombs ( comb , nc , data [ i ] , data [ i + 1 ] )
<operator>.notEquals c != 'Q'
<operator>.equals comb [ 0 ] [ 0 ] == 'T'
<operator>.equals opp [ 0 ] [ 0 ] == 'F'
<operator>.lessEqualsThan i <= nd - 1
<operator>.postIncrement i ++
searchCombs searchCombs ( comb , nc , data [ i ] , data [ i + 1 ] )
<operator>.assignment data [ i ] = '?'
<operator>.assignment data [ i + 1 ] = c
<operator>.assignment i = 1
<operator>.notEquals data [ i ] != '?'
<operator>.logicalAnd ( comb [ 0 ] [ 0 ] == 'F' ) && ( opp [ 0 ] [ 0 ] == 'T' )
<operator>.assignment c = searchOpps ( opp , np , data [ i + 1 ] )
<operator>.subtraction nd - 1
<operator>.assignment c = searchCombs ( comb , nc , data [ i ] , data [ i + 1 ] )
<operator>.addition i + 1
<operator>.notEquals c != 'X'
<operator>.notEquals c != 'Q'
<operator>.equals comb [ 0 ] [ 0 ] == 'F'
<operator>.equals opp [ 0 ] [ 0 ] == 'T'
<operator>.lessEqualsThan i <= nd
<operator>.postIncrement i ++
<operator>.addition i + 1
searchOpps searchOpps ( opp , np , data [ i + 1 ] )
<operator>.assignment pos = searchElem ( data , i + 1 , c )
searchCombs searchCombs ( comb , nc , data [ i ] , data [ i + 1 ] )
<operator>.assignment data [ i ] = '?'
<operator>.assignment data [ i + 1 ] = c
<operator>.assignment i = 2
<operator>.assignment c = searchOpps ( opp , np , data [ i ] )
<operator>.notEquals pos != - 1
<operator>.notEquals c != 'X'
<operator>.addition i + 1
searchElem searchElem ( data , i + 1 , c )
delete delete ( data , i + 1 )
<operator>.addition i + 1
searchOpps searchOpps ( opp , np , data [ i ] )
<operator>.assignment pos = searchElem ( data , i , c )
<operator>.addition i + 1
<operator>.minus - 1
<operator>.addition i + 1
<operator>.notEquals pos != - 1
<operator>.addition i + 1
searchElem searchElem ( data , i , c )
delete delete ( data , i )
<operator>.minus - 1
<operator>.indirectIndexAccess opp [ 0 ] [ 0 ]
<operator>.indirectIndexAccess opp [ 0 ]
<operator>.indirectIndexAccess data [ i ]
<operator>.indirectIndexAccess comb [ 0 ] [ 0 ]
<operator>.indirectIndexAccess opp [ 0 ] [ 0 ]
<operator>.indirectIndexAccess data [ i ]
<operator>.indirectIndexAccess data [ i + 1 ]
<operator>.indirectIndexAccess comb [ 0 ]
<operator>.indirectIndexAccess opp [ 0 ]
<operator>.indirectIndexAccess data [ i ]
<operator>.indirectIndexAccess data [ i + 1 ]
<operator>.indirectIndexAccess data [ i ]
<operator>.indirectIndexAccess comb [ 0 ] [ 0 ]
<operator>.indirectIndexAccess opp [ 0 ] [ 0 ]
<operator>.indirectIndexAccess data [ i + 1 ]
<operator>.indirectIndexAccess data [ i ]
<operator>.indirectIndexAccess data [ i + 1 ]
<operator>.indirectIndexAccess comb [ 0 ]
<operator>.indirectIndexAccess opp [ 0 ]
<operator>.indirectIndexAccess data [ i ]
<operator>.indirectIndexAccess data [ i + 1 ]
<operator>.indirectIndexAccess data [ i ]
>>>PDG&87 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->32 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 2->1 2->16 2->25 2->29 2->42 2->44 2->52 2->55 2->62 3->1 3->18 3->32 3->39 4->1 4->25 4->44 5->1 5->25 5->44 6->1 6->42 6->55 7->1 7->42 7->55 8->1 9->1 9->1 9->1 9->13 9->15 9->17 9->18 9->21 9->30 9->68 9->72 10->8 11->1 11->9 11->9 11->12 11->21 11->65 11->66 12->1 12->9 12->9 12->22 12->38 13->1 13->1 13->1 13->13 13->14 13->14 13->16 13->18 13->34 13->41 13->51 13->52 13->53 13->57 13->61 13->67 14->1 14->13 15->1 15->13 16->1 16->1 16->19 16->20 16->25 16->25 16->34 16->70 16->71 17->1 17->1 17->1 17->23 17->28 17->30 17->32 17->37 17->77 17->82 18->1 18->13 18->13 19->1 19->1 19->20 20->1 20->26 20->27 20->27 20->31 20->35 20->41 20->42 20->51 20->74 20->75 20->79 21->1 21->17 21->17 21->22 21->37 21->69 21->73 22->1 22->17 22->17 22->38 23->1 23->1 23->1 23->23 23->24 23->24 23->29 23->32 23->54 23->59 23->76 24->1 24->23 25->1 25->1 25->1 25->16 25->19 25->19 25->19 25->19 25->42 25->52 25->53 26->1 26->1 26->16 27->1 27->1 27->1 27->25 28->1 28->23 29->1 29->1 29->33 29->36 29->44 29->44 29->54 29->80 29->81 30->1 30->1 30->1 30->39 30->47 31->1 31->1 31->35 32->1 32->23 32->23 33->1 33->1 33->36 35->1 35->1 35->43 35->49 35->52 35->52 35->57 35->58 36->1 36->1 36->45 36->46 36->46 36->59 36->84 36->85 37->1 37->30 37->30 37->38 37->78 37->83 38->1 38->30 38->30 39->1 39->1 39->1 39->39 39->40 39->40 39->48 39->50 39->55 39->62 39->86 40->1 40->39 42->1 42->1 42->1 42->25 42->31 42->31 42->31 42->52 42->53 43->1 43->1 43->49 44->1 44->1 44->1 44->1 44->29 44->33 44->33 44->33 44->33 45->1 45->1 45->29 46->1 46->1 46->1 46->44 47->1 47->39 48->1 48->1 48->50 49->1 49->1 49->1 49->53 49->61 50->1 50->1 50->56 50->60 50->62 50->62 50->64 52->1 52->1 52->1 52->16 52->25 52->42 52->43 52->43 52->43 52->53 53->1 53->1 53->1 53->16 53->25 53->42 53->52 55->1 55->1 55->1 55->48 55->48 55->48 55->62 55->63 56->1 56->1 56->60 58->49 60->1 60->1 60->1 60->63 62->1 62->1 62->40 62->55 62->56 62->56 62->56 62->63 62->63 63->1 63->1 63->40 63->55 63->62 64->60
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int elementList ( char data [ ] , int nd , char comb [ ] [ 4 ] , int nc , char opp [ ] [ 3 ] , int np ) { int i , pos ; char c ; if ( ( comb [ 0 ] [ 0 ] == 'T' ) && ( opp [ 0 ] [ 0 ] == 'T' ) ) { for ( i = 1 ; i <= nd - 1 ; i ++ ) if ( data [ i ] != '?' ) { c = searchCombs ( comb , nc , data [ i ] , data [ i + 1 ] ) ; if ( c != 'Q' ) { data [ i ] = '?' ; data [ i + 1 ] = c ; } else { c = searchOpps ( opp , np , data [ i + 1 ] ) ; if ( c != 'X' ) { pos = searchElem ( data , i + 1 , c ) ; if ( pos != - 1 ) delete ( data , i + 1 ) ; } } } } else if ( ( comb [ 0 ] [ 0 ] == 'T' ) && ( opp [ 0 ] [ 0 ] == 'F' ) ) { for ( i = 1 ; i <= nd - 1 ; i ++ ) if ( data [ i ] != '?' ) { c = searchCombs ( comb , nc , data [ i ] , data [ i + 1 ] ) ; if ( c != 'Q' ) { data [ i ] = '?' ; data [ i + 1 ] = c ; } } } else if ( ( comb [ 0 ] [ 0 ] == 'F' ) && ( opp [ 0 ] [ 0 ] == 'T' ) ) { for ( i = 2 ; i <= nd ; i ++ ) { c = searchOpps ( opp , np , data [ i ] ) ; if ( c != 'X' ) { pos = searchElem ( data , i , c ) ; if ( pos != - 1 ) delete ( data , i ) ; } } } return 0 ; }
>>>Func
METHOD List_push
METHOD_RETURN L
PARAM L list
PARAM void * val
<operator>.assignment new_elem = ( L ) malloc ( sizeof ( L ) )
<operator>.assignment new_elem -> val = val
<operator>.assignment new_elem -> next = list
RETURN return new_elem ; return new_elem ;
IDENTIFIER new_elem return new_elem ;
<operator>.cast ( L ) malloc ( sizeof ( L ) )
<operator>.sizeOf sizeof ( L )
>>>PDG&11 0->2 0->3 0->5 0->6 0->8 2->6 3->5 4->1 4->1 4->1 4->8 5->1 5->1 5->1 6->1 6->1 6->1 7->1 8->7 9->1 10->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) L List_push ( L list , void * val ) { L new_elem = ( L ) malloc ( sizeof ( L ) ) ; new_elem -> val = val ; new_elem -> next = list ; return new_elem ; }
>>>Func
METHOD mult
METHOD_RETURN unsigned long int
PARAM unsigned long int m1
PARAM unsigned long int m2
PARAM unsigned long int M
<operator>.assignment max = ( 0xFFFFFFFF / m1 )
<operator>.lessThan m1 < m2
<operator>.lessEqualsThan m2 <= max
<operator>.assignment aux = m1
<operator>.assignment m1 = m2
<operator>.assignment m2 = aux
<operator>.division 0xFFFFFFFF / m1
RETURN return ( ( m1 * m2 ) % M ) ; return ( ( m1 * m2 ) % M ) ;
<operator>.modulo ( m1 * m2 ) % M
RETURN return ( ( ( ( m1 * max ) % M ) + mult ( m1 , m2 - max , M ) ) % M ) ; return ( ( ( ( m1 * max ) % M ) + mult ( m1 , m2 - max , M ) ) % M ) ;
<operator>.modulo ( ( ( m1 * max ) % M ) + mult ( m1 , m2 - max , M ) ) % M
<operator>.multiplication m1 * m2
<operator>.addition ( ( m1 * max ) % M ) + mult ( m1 , m2 - max , M )
<operator>.modulo ( m1 * max ) % M
mult mult ( m1 , m2 - max , M )
<operator>.multiplication m1 * max
<operator>.subtraction m2 - max
>>>PDG&22 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->15 0->16 0->18 0->19 0->20 0->21 2->6 3->6 4->13 4->18 5->1 5->1 5->7 6->1 6->7 6->8 6->8 6->9 6->9 6->10 6->11 7->1 7->1 7->12 7->13 7->14 7->15 7->16 7->16 7->17 7->18 7->19 7->20 7->20 7->21 7->21 8->1 8->10 9->1 9->11 10->1 10->1 10->7 11->5 11->5 11->16 11->20 12->1 13->1 13->1 13->1 13->12 14->1 15->14 16->1 16->1 16->13 16->13 18->15 18->15 18->17 18->17 18->19 19->15 19->15 19->15 19->17 19->17 19->17 20->18 20->18 20->19 20->21 21->19 21->19
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) unsigned long int mult ( unsigned long int m1 , unsigned long int m2 , unsigned long int M ) { unsigned long int aux , max ; if ( m1 < m2 ) { aux = m1 ; m1 = m2 ; m2 = aux ; } max = ( 0xFFFFFFFF / m1 ) ; if ( m2 <= max ) return ( ( m1 * m2 ) % M ) ; else return ( ( ( ( m1 * max ) % M ) + mult ( m1 , m2 - max , M ) ) % M ) ; }
>>>Func
METHOD fadvise
METHOD_RETURN void
PARAM FILE * fp
PARAM fadvice_t advice
IDENTIFIER fp if (fp)
fdadvise fdadvise ( fileno ( fp ) , 0 , 0 , advice )
fileno fileno ( fp )
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->6 3->5 5->1 5->1 5->1 6->1 6->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void fadvise ( FILE * fp , fadvice_t advice ) { if ( fp ) fdadvise ( fileno ( fp ) , 0 , 0 , advice ) ; }
>>>Func
METHOD search
METHOD_RETURN int
PARAM List * list
PARAM double value
search search ( list -> next , value )
<operator>.equals list == NULL
<operator>.equals list -> value == value
RETURN return 0 ; return 0 ;
RETURN return 1 ; return 1 ;
LITERAL 0 return 0 ;
LITERAL 1 return 1 ;
<operator>.indirectFieldAccess list -> next
<operator>.indirectFieldAccess list -> value
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER value value
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->5 3->1 3->6 5->1 5->1 5->1 5->6 5->7 5->12 5->14 6->4 6->4 6->8 6->11 6->13 7->1 8->1 9->7 10->8
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int search ( List * list , double value ) { if ( list == NULL ) return 0 ; if ( list -> value == value ) return 1 ; search ( list -> next , value ) ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
<operator>.lessThan tt < T
<operator>.postIncrement tt ++
<operator>.assignment tt = 0
scanf scanf ( "%d %d %d %d" , & L , & t , & N , & C )
<operator>.assignment tmp = t / 2
<operator>.assignment time = 0
qsort qsort ( ai   N   sizeof ( int ) , cmp )
printf printf ( "Case #%d: %d\n" , tt + 1 , time )
<operator>.lessThan c < C
<operator>.postIncrement c ++
scanf scanf ( "%d" , & ai [ c ] )
<operator>.lessThan c < N
<operator>.postIncrement c ++
<operator>.assignment ai [ c ] = ai [ c % C ]
<operator>.lessThan c < N
<operator>.postIncrement c ++
<operator>.lessThan c < L
<operator>.postIncrement c ++
<operator>.assignmentPlus time += ai [ c ]
<operator>.lessThan c < N
<operator>.postIncrement c ++
<operator>.assignmentPlus time += ai [ c ] * 2
<operator>.assignment c = 0
<operator>.division t / 2
<operator>.assignment c = 0
<operator>.sizeOf sizeof ( int )
<operator>.assignment c = 0
<operator>.addition tt + 1
<operator>.lessEqualsThan ai [ c ] <= tmp
<operator>.multiplication ai [ c ] * 2
<operator>.modulo c % C
<operator>.assignmentPlus time += ai [ c ] * 2
<operator>.assignmentMinus tmp -= ai [ c ]
<operator>.assignment ai [ c ] = 0
<operator>.assignmentPlus time += tmp * 2
<operator>.assignmentMinus ai [ c ] -= tmp
<operator>.assignment tmp = 0
<operator>.multiplication ai [ c ] * 2
<operator>.multiplication tmp * 2
<operator>.addressOf & L
<operator>.addressOf & t
<operator>.addressOf & N
<operator>.addressOf & C
<operator>.addressOf & ai [ c ]
<operator>.indirectIndexAccess ai [ c ]
<operator>.indirectIndexAccess ai [ c % C ]
<operator>.indirectIndexAccess ai [ c ]
<operator>.indirectIndexAccess ai [ c ]
<operator>.indirectIndexAccess ai [ c ]
<operator>.indirectIndexAccess ai [ c ]
<operator>.indirectIndexAccess ai [ c ]
<operator>.indirectIndexAccess ai [ c ]
<operator>.indirectIndexAccess ai [ c ]
<operator>.indirectIndexAccess ai [ c ]
>>>PDG&57 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 2->1 2->3 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->7 3->8 3->9 3->10 3->10 3->11 3->14 3->17 3->19 3->22 3->25 3->26 3->27 3->28 3->29 3->30 3->30 3->42 3->43 3->44 3->45 4->1 4->3 5->1 5->3 6->1 6->1 6->1 6->1 6->19 7->1 7->1 7->1 7->31 8->1 8->10 8->21 8->24 8->34 8->37 9->1 9->1 9->1 9->13 9->16 9->21 9->22 9->31 9->32 9->35 9->38 9->40 10->1 10->1 10->1 11->1 11->1 11->11 11->12 11->12 11->13 11->14 11->33 11->46 11->50 12->1 12->11 13->1 13->9 13->21 13->31 13->32 13->35 13->38 13->40 14->14 14->15 14->16 14->17 14->33 14->33 14->47 14->48 15->1 15->14 16->1 16->1 16->1 16->9 16->13 16->21 16->31 16->32 17->9 17->17 17->18 17->18 17->31 17->52 18->1 18->17 19->1 19->1 19->6 19->19 19->20 19->20 19->21 19->22 19->49 20->1 20->19 21->1 21->1 21->10 21->24 22->1 22->1 22->1 22->14 22->22 22->23 22->23 22->24 22->32 22->51 23->1 23->22 24->1 24->1 24->10 25->11 26->1 26->7 26->7 27->17 28->1 29->1 29->19 31->1 31->34 31->35 31->35 31->36 31->37 31->38 31->38 31->39 31->40 31->40 31->41 31->41 31->53 31->54 31->55 31->56 32->1 32->9 32->13 32->21 32->24 32->24 32->31 33->1 33->11 33->15 34->1 34->1 34->10 34->21 34->24 34->37 35->1 35->1 35->31 36->1 36->1 36->9 36->13 36->21 36->31 36->32 37->1 37->1 37->10 37->21 37->24 37->34 38->1 38->1 38->9 38->13 38->21 38->31 38->32 39->1 39->1 39->31 40->34 40->34 40->35 41->37 41->37 41->38
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T , tt , t , N , C , c , L , tmp , time ; int ai [ 1000010 ] ; scanf ( "\x25\x64\x0" , & T ) ; for ( tt = 0 ; tt < T ; tt ++ ) { scanf ( "%d %d %d %d" , & L , & t , & N , & C ) ; for ( c = 0 ; c < C ; c ++ ) scanf ( "%d" , & ai [ c ] ) ; for ( ; c < N ; c ++ ) ai [ c ] = ai [ c % C ] ; tmp = t / 2 ; time = 0 ; for ( c = 0 ; c < N ; c ++ ) { if ( ai [ c ] <= tmp ) { time += ai [ c ] * 2 ; tmp -= ai [ c ] ; ai [ c ] = 0 ; } else { time += tmp * 2 ; ai [ c ] -= tmp ; tmp = 0 ; } } qsort ( ai , N , sizeof ( int ) , cmp ) ; for ( c = 0 ; c < L ; c ++ ) time += ai [ c ] ; for ( ; c < N ; c ++ ) time += ai [ c ] * 2 ; printf ( "Case #%d: %d\n" , tt + 1 , time ) ; } }
>>>Func
METHOD cal_owp
METHOD_RETURN void
PARAM char A [ 100 ] [ 100 ]
PARAM int N
PARAM double OWP [ 100 ]
PARAM double wins [ 100 ]
PARAM double losts [ 100 ]
<operator>.assignment i = 0
<operator>.lessThan i < N
<operator>.assignment j = 0
<operator>.assignment avg = 0
<operator>.assignment c = 0
<operator>.assignment OWP [ i ] = ( double ) ( avg / c )
<operator>.postIncrement i ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.cast ( double ) ( avg / c )
<operator>.equals A [ i ] [ j ] == '0'
<operator>.division avg / c
<operator>.notEquals wins [ j ] != 0
<operator>.assignment avg = ( double ) ( ( wins [ j ] - 1 ) / ( wins [ j ] + losts [ j ] - 1 ) ) + avg
<operator>.postIncrement c ++
<operator>.equals A [ i ] [ j ] == '1'
<operator>.postIncrement c ++
<operator>.assignment avg = ( double ) ( ( wins [ j ] ) / ( wins [ j ] + losts [ j ] - 1 ) ) + avg
<operator>.postIncrement c ++
<operator>.addition ( double ) ( ( wins [ j ] - 1 ) / ( wins [ j ] + losts [ j ] - 1 ) ) + avg
<operator>.cast ( double ) ( ( wins [ j ] - 1 ) / ( wins [ j ] + losts [ j ] - 1 ) )
<operator>.addition ( double ) ( ( wins [ j ] ) / ( wins [ j ] + losts [ j ] - 1 ) ) + avg
<operator>.division ( wins [ j ] - 1 ) / ( wins [ j ] + losts [ j ] - 1 )
<operator>.cast ( double ) ( ( wins [ j ] ) / ( wins [ j ] + losts [ j ] - 1 ) )
<operator>.subtraction wins [ j ] - 1
<operator>.subtraction wins [ j ] + losts [ j ] - 1
<operator>.division ( wins [ j ] ) / ( wins [ j ] + losts [ j ] - 1 )
<operator>.addition wins [ j ] + losts [ j ]
<operator>.subtraction wins [ j ] + losts [ j ] - 1
<operator>.addition wins [ j ] + losts [ j ]
<operator>.indirectIndexAccess OWP [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess A [ i ] [ j ]
<operator>.indirectIndexAccess A [ i ]
<operator>.indirectIndexAccess wins [ j ]
<operator>.indirectIndexAccess A [ i ] [ j ]
<operator>.indirectIndexAccess A [ i ]
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess wins [ j ]
<operator>.indirectIndexAccess wins [ j ]
<operator>.indirectIndexAccess wins [ j ]
<operator>.indirectIndexAccess losts [ j ]
<operator>.indirectIndexAccess wins [ j ]
<operator>.indirectIndexAccess losts [ j ]
>>>PDG&52 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->31 0->32 0->35 2->1 3->8 4->1 5->1 5->19 5->31 5->32 5->33 5->34 5->35 5->36 6->1 6->32 6->34 6->35 6->36 7->1 7->8 8->1 8->1 8->1 8->8 8->9 8->10 8->11 8->12 8->13 8->13 8->14 8->14 8->16 8->18 8->37 8->38 9->14 10->18 10->20 10->24 10->26 10->28 11->18 11->21 11->23 11->25 13->1 13->8 14->8 14->14 14->15 14->15 14->17 14->39 14->40 15->14 17->19 17->22 17->22 17->41 17->42 17->43 18->12 18->12 18->16 18->16 19->20 19->21 19->23 19->26 19->27 19->29 19->31 19->31 19->32 19->33 19->34 19->35 19->36 19->44 19->46 19->48 19->49 20->18 20->24 20->26 20->28 21->18 21->23 21->25 22->17 22->24 22->25 22->28 22->30 22->33 22->35 22->36 22->45 22->47 22->50 22->51 23->18 23->21 23->25 24->18 24->20 24->26 24->28 25->18 25->21 25->23 29->20 29->20 29->26 29->26 29->27 29->27 31->19 31->29 31->29 31->32 31->33 31->34 31->35 31->36 32->29 32->29 33->19 33->24 33->24 33->28 33->28 33->30 33->30 33->35 33->36 35->33 35->33
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void cal_owp ( char A [ 100 ] [ 100 ] , int N , double OWP [ 100 ] , double wins [ 100 ] , double losts [ 100 ] ) { int i = 0 ; while ( i < N ) { int j = 0 ; double avg = 0 ; double c = 0 ; while ( j < N ) { if ( A [ i ] [ j ] == '0' ) { if ( wins [ j ] != 0 ) { avg = ( double ) ( ( wins [ j ] - 1 ) / ( wins [ j ] + losts [ j ] - 1 ) ) + avg ; c ++ ; } else { c ++ ; } } else if ( A [ i ] [ j ] == '1' ) { avg = ( double ) ( ( wins [ j ] ) / ( wins [ j ] + losts [ j ] - 1 ) ) + avg ; c ++ ; } j ++ ; } OWP [ i ] = ( double ) ( avg / c ) ; i ++ ; } }
>>>Func
METHOD rev_xstrcoll_df_version
METHOD_RETURN int
PARAM V a
PARAM V b
RETURN return dirfirst_check ( a , b , rev_xstrcoll_version ) ; return dirfirst_check ( a , b , rev_xstrcoll_version ) ;
dirfirst_check dirfirst_check ( a , b , rev_xstrcoll_version )
>>>PDG&6 0->2 0->3 0->5 2->5 3->5 4->1 5->1 5->1 5->1 5->1 5->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static int rev_xstrcoll_df_version ( V a , V b ) { return dirfirst_check ( a , b , rev_xstrcoll_version ) ; }
>>>Func
METHOD list_is_empty
METHOD_RETURN int
PARAM const list_t * head
RETURN return ( head -> next == head ) ; return ( head -> next == head ) ;
<operator>.equals head -> next == head
>>>PDG&5 0->2 0->4 2->4 3->1 4->1 4->1 4->1 4->3
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int list_is_empty ( const list_t * head ) { return ( head -> next == head ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment i = 0
<operator>.assignment j = 0
<operator>.assignment dex = 1
<operator>.assignment inputfile = fopen ( "\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x31\x32\x2e\x69\x6e\x0" , "r" )
fscanf fscanf ( inputfile , "%s" , buffer )
<operator>.assignment round = atoi ( buffer )
RETURN return 0 ; return 0 ;
<operator>.equals inputfile == NULL
<operator>.greaterThan round > 0
<operator>.postDecrement round --
LITERAL 0 return 0 ;
fopen fopen ( "\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x31\x32\x2e\x69\x6e\x0" , "r" )
printf printf ( "\nFile could not be opened.\n" )
exit exit ( 1 )
atoi atoi ( buffer )
fscanf fscanf ( inputfile , "%s" , buffer )
<operator>.assignment c = atoi ( buffer )
<operator>.assignment once = 0
printf printf ( "Case #%d: [" , dex )
printf printf ( "]\n" )
<operator>.postIncrement dex ++
<operator>.lessThan i < 12
<operator>.postIncrement i ++
<operator>.equals c == 0
<operator>.logicalAnd invoking [ n - 1 ] == combine [ 0 ] && invoking [ n - 2 ] == combine [ 1 ]
<operator>.lessThan i < n
<operator>.logicalAnd final [ i ] >= 'A' && final [ i ] <= 'Z'
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment buffer [ i ] = invoking [ i ] = final [ i ] = subfinal [ i ] = ' '
atoi atoi ( buffer )
fscanf fscanf ( inputfile , "%s" , buffer )
<operator>.assignment d = atoi ( buffer )
<operator>.assignment invoking [ n - 2 ] = combine [ 2 ]
<operator>.assignment invoking [ n - 1 ] = ' '
<operator>.assignment i = j = 0
<operator>.assignment bingo = 0
<operator>.assignment i = 0
<operator>.equals d == 0
fscanf fscanf ( inputfile , "%s" , combine )
fscanf fscanf ( inputfile , "%s" , buffer )
<operator>.assignment d = atoi ( buffer )
<operator>.equals invoking [ n - 1 ] == combine [ 0 ]
<operator>.equals invoking [ n - 2 ] == combine [ 1 ]
<operator>.logicalAnd invoking [ i ] == combine [ 0 ] && invoking [ i + 1 ] == combine [ 1 ]
<operator>.logicalAnd invoking [ i ] == combine [ 1 ] && invoking [ i + 1 ] == combine [ 0 ]
<operator>.equals bingo == 1
<operator>.greaterEqualsThan final [ i ] >= 'A'
<operator>.lessEqualsThan final [ i ] <= 'Z'
<operator>.logicalAnd final [ i + 1 ] >= 'A' && final [ i + 1 ] <= 'Z'
<operator>.assignment invoking [ i ] = final [ i ] = subfinal [ i ] = ' '
atoi atoi ( buffer )
fscanf fscanf ( inputfile , "%s" , buffer )
<operator>.assignment n = atoi ( buffer )
fscanf fscanf ( inputfile , "%s" , invoking )
<operator>.equals d == 0
<operator>.logicalAnd invoking [ n - 1 ] == combine [ 1 ] && invoking [ n - 2 ] == combine [ 0 ]
<operator>.assignment j = 0
<operator>.assignment bingo = 1
<operator>.assignment bingo = 1
<operator>.assignment final [ j ] = combine [ 2 ]
<operator>.assignment i = i + 2
<operator>.postIncrement j ++
printf printf ( "%c, " , final [ i ] )
<operator>.assignment final [ i ] = subfinal [ i ] = ' '
fscanf fscanf ( inputfile , "%s" , clear )
fscanf fscanf ( inputfile , "%s" , buffer )
<operator>.assignment n = atoi ( buffer )
fscanf fscanf ( inputfile , "%s" , invoking )
atoi atoi ( buffer )
fscanf fscanf ( inputfile , "%s" , buffer )
<operator>.assignment n = atoi ( buffer )
fscanf fscanf ( inputfile , "%s" , invoking )
<operator>.subtraction n - 1
<operator>.subtraction n - 2
<operator>.subtraction n - 2
<operator>.subtraction n - 1
<operator>.assignment invoking [ n - 2 ] = combine [ 2 ]
<operator>.assignment invoking [ n - 1 ] = ' '
<operator>.equals invoking [ i ] == combine [ 0 ]
<operator>.equals invoking [ i + 1 ] == combine [ 1 ]
<operator>.equals invoking [ i ] == combine [ 1 ]
<operator>.equals invoking [ i + 1 ] == combine [ 0 ]
<operator>.greaterEqualsThan final [ i + 1 ] >= 'A'
<operator>.lessEqualsThan final [ i + 1 ] <= 'Z'
printf printf ( "%c" , final [ i ] )
<operator>.assignment subfinal [ i ] = ' '
atoi atoi ( buffer )
fscanf fscanf ( inputfile , "%s" , clear )
fscanf fscanf ( inputfile , "%s" , buffer )
<operator>.assignment n = atoi ( buffer )
fscanf fscanf ( inputfile , "%s" , invoking )
<operator>.equals invoking [ n - 1 ] == combine [ 1 ]
<operator>.equals invoking [ n - 2 ] == combine [ 0 ]
<operator>.addition i + 2
<operator>.logicalAnd invoking [ i ] == clear [ 0 ] && once == 0
atoi atoi ( buffer )
atoi atoi ( buffer )
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.assignment x = i + 1
<operator>.addition i + 1
<operator>.addition i + 1
atoi atoi ( buffer )
<operator>.subtraction n - 1
<operator>.subtraction n - 2
<operator>.subtraction n - 2
<operator>.subtraction n - 1
<operator>.equals invoking [ i ] == clear [ 0 ]
<operator>.equals once == 0
<operator>.logicalAnd x < n && invoking [ x ] != clear [ 1 ]
<operator>.equals invoking [ x ] == clear [ 1 ]
<operator>.addition i + 1
<operator>.postIncrement x ++
<operator>.assignment i = x + 1
<operator>.assignment once = 1
<operator>.logicalAnd invoking [ i ] == clear [ 1 ] && once == 0
<operator>.lessThan x < n
<operator>.notEquals invoking [ x ] != clear [ 1 ]
<operator>.assignment final [ j ] = invoking [ i ]
<operator>.postIncrement i ++
<operator>.postIncrement j ++
<operator>.assignment x = i + 1
<operator>.addition x + 1
<operator>.equals invoking [ i ] == clear [ 1 ]
<operator>.equals once == 0
<operator>.logicalAnd x < n && invoking [ x ] != clear [ 0 ]
<operator>.equals invoking [ x ] == clear [ 0 ]
<operator>.assignment final [ j ] = invoking [ i ]
<operator>.postIncrement i ++
<operator>.postIncrement j ++
<operator>.addition i + 1
<operator>.postIncrement x ++
<operator>.assignment i = x + 1
<operator>.assignment once = 1
<operator>.lessThan x < n
<operator>.notEquals invoking [ x ] != clear [ 0 ]
<operator>.assignment final [ j ] = invoking [ i ]
<operator>.postIncrement i ++
<operator>.postIncrement j ++
<operator>.addition x + 1
<operator>.indirectIndexAccess buffer [ i ]
<operator>.indirectIndexAccess invoking [ n - 1 ]
<operator>.indirectIndexAccess combine [ 0 ]
<operator>.indirectIndexAccess invoking [ n - 2 ]
<operator>.indirectIndexAccess combine [ 1 ]
<operator>.indirectIndexAccess invoking [ n - 2 ]
<operator>.indirectIndexAccess combine [ 2 ]
<operator>.indirectIndexAccess invoking [ n - 1 ]
<operator>.indirectIndexAccess final [ i ]
<operator>.indirectIndexAccess final [ i ]
<operator>.indirectIndexAccess invoking [ i ]
<operator>.indirectIndexAccess final [ i ]
<operator>.indirectIndexAccess invoking [ i ]
<operator>.indirectIndexAccess combine [ 0 ]
<operator>.indirectIndexAccess invoking [ i + 1 ]
<operator>.indirectIndexAccess combine [ 1 ]
<operator>.indirectIndexAccess invoking [ i ]
<operator>.indirectIndexAccess combine [ 1 ]
<operator>.indirectIndexAccess invoking [ i + 1 ]
<operator>.indirectIndexAccess combine [ 0 ]
<operator>.indirectIndexAccess final [ j ]
<operator>.indirectIndexAccess combine [ 2 ]
<operator>.indirectIndexAccess final [ i + 1 ]
<operator>.indirectIndexAccess final [ i + 1 ]
<operator>.indirectIndexAccess final [ i ]
<operator>.indirectIndexAccess subfinal [ i ]
<operator>.indirectIndexAccess invoking [ n - 1 ]
<operator>.indirectIndexAccess combine [ 1 ]
<operator>.indirectIndexAccess invoking [ n - 2 ]
<operator>.indirectIndexAccess combine [ 0 ]
<operator>.indirectIndexAccess invoking [ n - 2 ]
<operator>.indirectIndexAccess combine [ 2 ]
<operator>.indirectIndexAccess invoking [ n - 1 ]
<operator>.indirectIndexAccess final [ i ]
<operator>.indirectIndexAccess invoking [ i ]
<operator>.indirectIndexAccess clear [ 0 ]
<operator>.indirectIndexAccess invoking [ x ]
<operator>.indirectIndexAccess clear [ 1 ]
<operator>.indirectIndexAccess invoking [ x ]
<operator>.indirectIndexAccess clear [ 1 ]
<operator>.indirectIndexAccess final [ j ]
<operator>.indirectIndexAccess invoking [ i ]
<operator>.indirectIndexAccess invoking [ i ]
<operator>.indirectIndexAccess clear [ 1 ]
<operator>.indirectIndexAccess invoking [ x ]
<operator>.indirectIndexAccess clear [ 0 ]
<operator>.indirectIndexAccess final [ j ]
<operator>.indirectIndexAccess invoking [ i ]
<operator>.indirectIndexAccess invoking [ x ]
<operator>.indirectIndexAccess clear [ 0 ]
<operator>.indirectIndexAccess final [ j ]
<operator>.indirectIndexAccess invoking [ i ]
>>>PDG&195 0->2 0->3 0->4 0->6 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->29 0->30 0->31 0->32 0->33 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->48 0->49 0->50 0->52 0->53 0->54 0->56 0->57 0->59 0->60 0->61 0->63 0->64 0->65 0->66 0->67 0->68 0->70 0->71 0->72 0->74 0->75 0->76 0->77 0->78 0->80 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->93 0->96 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->111 0->114 0->115 0->116 0->117 0->119 0->122 0->123 0->124 0->125 0->127 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->140 0->141 0->142 2->1 2->1 3->1 3->1 4->1 4->1 4->20 5->1 5->1 5->9 6->1 6->1 6->16 6->17 7->1 7->1 7->10 8->1 9->1 9->1 9->6 9->14 9->15 10->1 10->1 10->10 10->11 10->11 10->17 10->18 10->19 10->20 10->21 10->22 10->23 10->25 10->26 10->27 10->28 10->30 10->32 10->37 10->39 10->44 10->49 10->59 10->75 10->144 10->145 10->151 11->1 11->10 12->8 13->5 13->5 14->1 16->1 16->7 16->17 17->32 17->33 17->41 18->1 18->25 19->1 19->1 19->111 19->127 20->1 20->22 21->1 22->1 22->1 22->20 23->1 23->23 23->24 23->24 23->31 23->52 23->66 23->88 23->143 23->153 23->154 23->168 24->1 24->23 25->1 25->1 25->33 25->34 25->40 25->41 25->42 25->43 25->53 25->57 25->71 26->1 26->1 26->1 26->35 26->36 26->58 26->77 26->78 26->94 26->106 26->148 26->149 26->150 26->169 26->170 27->1 27->1 27->27 27->38 27->46 27->47 27->48 27->63 27->81 27->83 27->96 27->100 27->101 27->102 27->114 27->119 27->122 27->124 27->131 27->133 27->137 27->140 27->155 27->156 27->159 27->160 28->1 28->1 28->1 28->28 28->29 28->49 28->51 28->85 28->103 28->151 28->165 29->1 29->1 29->103 29->104 30->23 31->1 31->1 31->1 31->17 31->32 31->33 31->42 31->53 31->54 31->68 31->71 31->72 31->89 31->91 31->98 31->99 31->105 32->18 32->33 32->42 33->53 33->54 33->67 34->1 34->40 35->1 35->1 35->1 35->45 35->56 35->70 35->74 35->93 35->95 36->1 36->1 36->44 36->56 36->70 36->74 36->93 37->1 37->1 37->27 38->1 38->48 39->1 39->1 39->29 39->103 39->104 40->1 40->1 40->54 40->55 40->56 40->67 40->68 40->69 40->70 40->89 40->98 41->1 41->1 41->35 41->42 41->44 41->45 41->62 41->79 41->81 41->82 41->83 41->84 41->94 41->95 42->71 42->72 42->90 43->1 43->57 44->1 44->26 44->26 44->41 44->45 44->76 44->81 44->94 44->95 44->146 44->147 45->1 45->1 45->26 45->26 45->41 45->56 45->70 45->74 45->82 45->83 45->93 45->94 45->95 46->1 46->1 46->1 46->60 47->1 47->1 47->1 47->61 48->1 48->1 48->62 48->63 48->64 48->96 48->97 48->110 48->163 48->164 48->177 48->178 49->1 49->28 49->28 49->50 49->50 49->65 49->87 49->152 50->1 50->28 50->28 50->49 50->65 50->87 51->1 51->1 51->1 51->65 51->87 51->167 51->176 52->1 52->1 52->31 52->56 52->70 52->74 52->81 52->93 53->34 53->54 53->68 54->1 54->56 54->89 55->1 55->1 55->75 56->1 56->1 56->1 56->17 56->44 56->45 56->70 56->74 56->81 56->82 56->83 56->84 56->93 56->94 56->95 56->110 56->113 56->120 56->121 56->126 56->129 56->130 56->138 56->139 57->1 57->1 57->72 57->73 57->74 57->90 57->91 57->92 57->93 57->99 57->105 58->1 58->1 58->1 58->79 58->80 58->108 58->109 58->173 58->174 58->175 59->1 59->37 59->64 59->123 59->132 59->141 60->1 60->48 61->1 61->48 62->1 62->1 62->1 63->1 63->1 63->27 64->1 64->1 64->123 64->132 64->141 65->1 65->49 66->1 66->31 66->49 66->52 67->1 67->1 67->68 67->90 67->110 67->113 67->120 67->126 67->129 67->138 68->1 68->70 68->98 69->1 69->1 69->75 70->1 70->1 70->1 70->17 70->44 70->45 70->56 70->74 70->81 70->82 70->83 70->84 70->93 70->94 70->95 70->110 70->113 70->120 70->121 70->126 70->129 70->130 70->138 70->139 71->43 71->72 71->91 72->1 72->74 72->99 73->1 73->1 73->75 74->1 74->1 74->1 74->17 74->44 74->45 74->56 74->70 74->81 74->82 74->83 74->84 74->93 74->94 74->95 74->110 74->113 74->120 74->121 74->126 74->129 74->130 74->138 74->139 75->76 75->77 75->106 76->77 76->106 77->78 78->27 79->1 79->1 79->1 79->45 79->56 79->70 79->74 79->93 79->95 80->1 80->1 80->44 80->56 80->70 80->74 80->93 81->1 81->41 81->44 81->46 81->46 81->82 81->83 81->84 81->100 81->157 81->158 82->1 82->46 82->46 82->56 82->70 82->74 82->83 82->84 82->93 83->1 83->1 83->41 83->45 83->47 83->47 83->56 83->70 83->74 83->81 83->82 83->84 83->93 83->94 83->101 83->110 83->161 83->162 84->1 84->1 84->41 84->44 84->47 84->47 84->56 84->70 84->74 84->81 84->82 84->93 85->1 85->51 85->51 85->86 85->86 85->104 85->166 86->1 86->51 86->51 86->85 87->1 87->49 88->1 88->31 88->52 88->66 89->1 89->17 89->55 90->1 90->1 90->67 90->91 90->110 90->113 90->120 90->126 90->129 90->138 91->1 91->93 91->105 92->1 92->1 92->75 93->1 93->1 93->1 93->17 93->44 93->45 93->56 93->70 93->74 93->81 93->82 93->83 93->84 93->94 93->95 93->110 93->113 93->120 93->121 93->126 93->129 93->130 93->138 93->139 94->1 94->1 94->41 94->44 94->45 94->56 94->58 94->58 94->70 94->74 94->82 94->83 94->93 94->95 94->107 94->171 94->172 95->1 95->1 95->41 95->44 95->45 95->56 95->58 95->58 95->70 95->74 95->81 95->93 97->1 97->1 97->1 97->102 97->112 97->113 97->114 97->118 97->118 97->119 97->126 97->179 97->180 97->185 97->186 98->1 98->17 98->69 99->1 99->17 99->73 102->1 102->1 102->119 105->1 105->17 105->92 106->27 106->107 106->108 107->27 107->108 108->109 109->27 110->1 110->1 110->56 110->67 110->70 110->74 110->81 110->90 110->93 110->97 110->97 110->111 110->121 110->126 110->129 110->138 111->1 111->97 111->97 111->127 112->1 112->1 112->1 112->112 112->115 112->119 113->1 113->1 113->1 113->56 113->67 113->70 113->74 113->90 113->93 113->116 113->117 113->120 113->120 113->121 113->122 113->123 113->125 113->126 113->129 113->138 113->183 113->184 115->1 115->119 116->1 116->1 116->27 117->1 117->1 117->111 117->127 118->1 118->1 118->1 118->97 118->124 118->128 118->129 118->130 118->131 118->132 118->133 118->137 118->187 118->188 118->189 118->190 119->1 119->27 119->112 119->112 119->115 119->116 119->120 119->125 119->181 119->182 120->112 120->112 120->113 120->113 121->1 121->1 121->1 122->1 122->27 123->1 123->1 123->64 123->132 123->141 124->1 124->1 124->137 125->1 126->1 126->1 126->56 126->67 126->70 126->74 126->81 126->90 126->93 126->113 126->118 126->118 126->120 126->127 126->130 126->139 127->1 127->111 127->118 127->118 128->1 128->1 128->1 128->128 128->134 128->137 129->1 129->1 129->1 129->56 129->67 129->70 129->74 129->90 129->93 129->110 129->113 129->120 129->135 129->136 129->138 129->139 129->140 129->141 129->142 129->193 129->194 130->1 130->1 130->1 131->1 131->27 132->1 132->1 132->64 132->123 132->141 134->1 134->137 135->1 135->1 135->27 136->1 136->1 136->111 136->127 137->1 137->27 137->128 137->128 137->134 137->135 137->138 137->142 137->191 137->192 138->128 138->128 138->129 138->129 139->1 139->1 139->1 140->1 140->27 141->1 141->1 141->64 141->123 141->132 142->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { char buffer [ 12 ] ; char invoking [ 12 ] ; char combine [ 3 ] ; char clear [ 3 ] ; char subfinal [ 12 ] ; char final [ 12 ] ; int round ; int c , d , n ; int i = 0 ; int j = 0 ; int x ; int dex = 1 ; FILE * inputfile ; inputfile = fopen ( "\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x31\x32\x2e\x69\x6e\x0" , "r" ) ; if ( inputfile == NULL ) { printf ( "\nFile could not be opened.\n" ) ; exit ( 1 ) ; } fscanf ( inputfile , "%s" , buffer ) ; round = atoi ( buffer ) ; for ( ; round > 0 ; round -- ) { for ( i = 0 ; i < 12 ; i ++ ) { buffer [ i ] = invoking [ i ] = final [ i ] = subfinal [ i ] = ' ' ; } fscanf ( inputfile , "%s" , buffer ) ; c = atoi ( buffer ) ; if ( c == 0 ) { fscanf ( inputfile , "%s" , buffer ) ; d = atoi ( buffer ) ; if ( d == 0 ) { fscanf ( inputfile , "%s" , buffer ) ; n = atoi ( buffer ) ; fscanf ( inputfile , "%s" , invoking ) ; } else { fscanf ( inputfile , "%s" , clear ) ; fscanf ( inputfile , "%s" , buffer ) ; n = atoi ( buffer ) ; fscanf ( inputfile , "%s" , invoking ) ; } } else { fscanf ( inputfile , "%s" , combine ) ; fscanf ( inputfile , "%s" , buffer ) ; d = atoi ( buffer ) ; if ( d == 0 ) { fscanf ( inputfile , "%s" , buffer ) ; n = atoi ( buffer ) ; fscanf ( inputfile , "%s" , invoking ) ; } else { fscanf ( inputfile , "%s" , clear ) ; fscanf ( inputfile , "%s" , buffer ) ; n = atoi ( buffer ) ; fscanf ( inputfile , "%s" , invoking ) ; } } int once = 0 ; if ( invoking [ n - 1 ] == combine [ 0 ] && invoking [ n - 2 ] == combine [ 1 ] ) { invoking [ n - 2 ] = combine [ 2 ] ; invoking [ n - 1 ] = ' ' ; } else if ( invoking [ n - 1 ] == combine [ 1 ] && invoking [ n - 2 ] == combine [ 0 ] ) { invoking [ n - 2 ] = combine [ 2 ] ; invoking [ n - 1 ] = ' ' ; } for ( i = j = 0 ; i < n ; ) { int bingo = 0 ; if ( invoking [ i ] == combine [ 0 ] && invoking [ i + 1 ] == combine [ 1 ] ) { bingo = 1 ; } if ( invoking [ i ] == combine [ 1 ] && invoking [ i + 1 ] == combine [ 0 ] ) { bingo = 1 ; } if ( bingo == 1 ) { final [ j ] = combine [ 2 ] ; i = i + 2 ; j ++ ; } else { if ( invoking [ i ] == clear [ 0 ] && once == 0 ) { x = i + 1 ; for ( ; x < n && invoking [ x ] != clear [ 1 ] ; ) { x ++ ; } if ( invoking [ x ] == clear [ 1 ] ) { i = x + 1 ; once = 1 ; } else { final [ j ] = invoking [ i ] ; i ++ ; j ++ ; } } else if ( invoking [ i ] == clear [ 1 ] && once == 0 ) { x = i + 1 ; for ( ; x < n && invoking [ x ] != clear [ 0 ] ; ) { x ++ ; } if ( invoking [ x ] == clear [ 0 ] ) { i = x + 1 ; once = 1 ; } else { final [ j ] = invoking [ i ] ; i ++ ; j ++ ; } } else { final [ j ] = invoking [ i ] ; i ++ ; j ++ ; } } } printf ( "Case #%d: [" , dex ) ; for ( i = 0 ; final [ i ] >= 'A' && final [ i ] <= 'Z' ; i ++ ) { if ( final [ i + 1 ] >= 'A' && final [ i + 1 ] <= 'Z' ) { printf ( "%c, " , final [ i ] ) ; } else { printf ( "%c" , final [ i ] ) ; } } printf ( "]\n" ) ; dex ++ ; } return 0 ; }
>>>Func
METHOD fsqr
METHOD_RETURN double
PARAM double x
RETURN return x * x ; return x * x ;
<operator>.multiplication x * x
>>>PDG&5 0->2 0->4 2->4 3->1 4->1 4->1 4->3
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) inline static double fsqr ( double x ) { return x * x ; }
>>>Func
METHOD decideb
METHOD_RETURN int
PARAM int star
PARAM int par
PARAM int nob
PARAM int useb
<operator>.assignment max = - 1
<operator>.assignment max2 = - 1
<operator>.assignment max_in = - 1
RETURN return 0 ; return 0 ;
<operator>.logicalNot ! nob
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.greaterEqualsThan dist [ star ] * 2 - par >= max * 2
LITERAL 0 return 0 ;
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
RETURN return 0 ; return 0 ;
<operator>.assignment i = star + 1
<operator>.greaterThan dist [ i ] > max
<operator>.assignment i = star + 1
RETURN return 1 ; return 1 ;
LITERAL 0 return 0 ;
<operator>.assignment max = dist [ i ]
<operator>.assignment max_in = i
<operator>.equals i == max_in
<operator>.greaterThan dist [ i ] > max2
<operator>.subtraction dist [ star ] * 2 - par
<operator>.multiplication max * 2
LITERAL 1 return 1 ;
<operator>.addition star + 1
<operator>.addition star + 1
<operator>.assignment max2 = dist [ i ]
<operator>.multiplication dist [ star ] * 2
<operator>.equals useb == 0
<operator>.greaterEqualsThan dist [ star ] * 2 - par >= max2 * 2
RETURN return 1 ; return 1 ;
<operator>.subtraction dist [ star ] * 2 - par
<operator>.multiplication max2 * 2
LITERAL 1 return 1 ;
<operator>.multiplication dist [ star ] * 2
<operator>.indirectIndexAccess dist [ i ]
<operator>.indirectIndexAccess dist [ i ]
<operator>.indirectIndexAccess dist [ i ]
<operator>.indirectIndexAccess dist [ star ]
<operator>.indirectIndexAccess dist [ i ]
<operator>.indirectIndexAccess dist [ star ]
>>>PDG&50 0->2 0->3 0->4 0->5 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->36 0->37 0->39 0->40 0->41 0->42 0->43 2->1 2->21 2->23 2->33 2->34 3->1 3->30 4->10 5->1 5->37 6->1 6->1 6->22 6->31 7->1 7->1 7->29 7->41 8->1 8->1 8->1 8->28 9->1 10->1 10->1 10->11 10->13 10->15 10->20 10->21 10->23 10->30 10->31 10->33 10->34 10->36 10->47 11->11 11->12 11->12 11->13 11->22 11->27 11->44 12->11 13->13 13->14 13->28 13->28 14->13 15->24 15->37 16->9 17->6 18->7 19->8 20->1 21->11 22->26 22->26 22->27 22->29 22->31 22->45 23->13 24->1 25->20 26->22 26->31 27->28 28->14 28->29 28->46 29->35 29->35 29->41 29->48 30->15 30->15 30->40 31->15 31->15 32->24 35->29 35->41 36->30 36->30 36->43 37->9 37->38 37->40 37->41 37->43 37->49 38->9 38->39 39->1 40->38 40->38 41->38 41->38 42->39 43->40 43->40
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int decideb ( int star , int par , int nob , int useb ) { int i ; int max = - 1 ; int max2 = - 1 ; int max_in = - 1 ; if ( ! nob ) return 0 ; for ( i = star + 1 ; i < N ; i ++ ) if ( dist [ i ] > max ) { max = dist [ i ] ; max_in = i ; } for ( i = star + 1 ; i < N ; i ++ ) { if ( i == max_in ) continue ; if ( dist [ i ] > max2 ) max2 = dist [ i ] ; } if ( dist [ star ] * 2 - par >= max * 2 ) return 1 ; else if ( useb == 0 ) if ( dist [ star ] * 2 - par >= max2 * 2 ) return 1 ; return 0 ; }
>>>Func
METHOD avl_tree_rotate
METHOD_RETURN AVLTreeNode
PARAM AVLTree * tree
PARAM AVLTreeNode * node
PARAM AVLTreeNodeSide direction
<operator>.assignment new_root = node -> children [ 1 - direction ]
avl_tree_node_replace avl_tree_node_replace ( tree , node , new_root )
<operator>.assignment node -> children [ 1 - direction ] = new_root -> children [ direction ]
<operator>.assignment new_root -> children [ direction ] = node
<operator>.assignment node -> parent = new_root
avl_tree_update_height avl_tree_update_height ( new_root )
avl_tree_update_height avl_tree_update_height ( node )
RETURN return new_root ; return new_root ;
<operator>.notEquals node -> children [ 1 - direction ] != NULL
IDENTIFIER new_root return new_root ;
<operator>.assignment node -> children [ 1 - direction ] -> parent = node
<operator>.subtraction 1 - direction
<operator>.subtraction 1 - direction
<operator>.subtraction 1 - direction
<operator>.subtraction 1 - direction
<operator>.indirectFieldAccess node -> children [ 1 - direction ] -> parent
<operator>.indirectIndexAccess node -> children [ 1 - direction ]
FIELD_IDENTIFIER parent parent
<operator>.indirectFieldAccess node -> children
FIELD_IDENTIFIER children children
>>>PDG&25 0->2 0->3 0->4 0->6 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 0->18 0->19 2->6 3->6 4->16 5->1 5->6 6->1 6->1 6->8 6->9 6->10 6->11 6->15 7->1 7->13 8->1 8->1 9->1 9->1 10->1 10->1 10->14 11->1 11->1 12->1 13->1 13->1 13->1 13->15 13->19 13->20 13->21 13->22 13->23 13->24 14->12 15->1 15->1 16->17 17->18 18->1 18->19 19->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static AVLTreeNode * avl_tree_rotate ( AVLTree * tree , AVLTreeNode * node , AVLTreeNodeSide direction ) { AVLTreeNode * new_root ; new_root = node -> children [ 1 - direction ] ; avl_tree_node_replace ( tree , node , new_root ) ; node -> children [ 1 - direction ] = new_root -> children [ direction ] ; new_root -> children [ direction ] = node ; node -> parent = new_root ; if ( node -> children [ 1 - direction ] != NULL ) { node -> children [ 1 - direction ] -> parent = node ; } avl_tree_update_height ( new_root ) ; avl_tree_update_height ( node ) ; return new_root ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & t )
<operator>.assignment i = 1
RETURN return 0 ; return 0 ;
IDENTIFIER t while (t)
LITERAL 0 return 0 ;
memset memset ( res   0   sizeof ( res ) )
memset memset ( arrRep   0   sizeof ( arrRep ) )
memset memset ( arrOpp   0   sizeof ( arrOpp ) )
scanf scanf ( "%d" , & c )
scanf scanf ( "%d" , & d )
scanf scanf ( "%d" , & n )
scanf scanf ( "%c" , & ch )
<operator>.assignment pos = 0
printf printf ( "Case #%d: [" , i ++ )
printf printf ( "]" )
<operator>.preDecrement -- t
<operator>.lessThan j < c
<operator>.preIncrement ++ j
<operator>.lessThan j < d
<operator>.preIncrement ++ j
<operator>.lessThan j < n
<operator>.preIncrement ++ j
<operator>.lessThan j < pos
<operator>.preIncrement ++ j
IDENTIFIER t if (t)
<operator>.assignment j = 0
scanf scanf ( "%c" , & ch )
scanf scanf ( "%c%c%c" , & arrRep [ j ] [ 0 ] , & arrRep [ j ] [ 1 ] , & arrRep [ j ] [ 2 ] )
<operator>.assignment j = 0
scanf scanf ( "%c" , & ch )
scanf scanf ( "%c%c" , & arrOpp [ j ] [ 0 ] , & arrOpp [ j ] [ 1 ] )
<operator>.assignment j = 0
scanf scanf ( "%c" , & ch )
<operator>.postIncrement i ++
<operator>.assignment j = 0
printf printf ( "%c" , res [ j ] )
printf printf ( "\n" )
<operator>.notEquals pos != 0
<operator>.notEquals j + 1 != pos
<operator>.assignment flag = 1
printf printf ( ", " )
<operator>.lessThan k < c
<operator>.preIncrement ++ k
IDENTIFIER flag if (flag)
IDENTIFIER flag if (flag)
<operator>.assignment res [ pos ++ ] = ch
<operator>.addition j + 1
<operator>.assignment k = 0
<operator>.logicalOr ( ( arrRep [ k ] [ 0 ] == ch ) && ( arrRep [ k ] [ 1 ] == res [ pos - 1 ] ) ) || ( ( arrRep [ k ] [ 0 ] == res [ pos - 1 ] ) && ( arrRep [ k ] [ 1 ] == ch ) )
<operator>.assignment res [ pos ++ ] = ch
<operator>.assignment res [ pos - 1 ] = arrRep [ k ] [ 2 ]
<operator>.assignment flag = 0
<operator>.greaterEqualsThan k >= 0
<operator>.preDecrement -- k
<operator>.logicalAnd ( arrRep [ k ] [ 0 ] == ch ) && ( arrRep [ k ] [ 1 ] == res [ pos - 1 ] )
<operator>.logicalAnd ( arrRep [ k ] [ 0 ] == res [ pos - 1 ] ) && ( arrRep [ k ] [ 1 ] == ch )
<operator>.assignment k = pos - 1
<operator>.lessThan l < d
<operator>.preIncrement ++ l
<operator>.postIncrement pos ++
<operator>.equals arrRep [ k ] [ 0 ] == ch
<operator>.equals arrRep [ k ] [ 1 ] == res [ pos - 1 ]
<operator>.equals arrRep [ k ] [ 0 ] == res [ pos - 1 ]
<operator>.equals arrRep [ k ] [ 1 ] == ch
<operator>.assignment l = 0
<operator>.logicalOr ( ( arrOpp [ l ] [ 0 ] == ch ) && ( arrOpp [ l ] [ 1 ] == res [ k ] ) ) || ( ( arrOpp [ l ] [ 1 ] == ch ) && ( arrOpp [ l ] [ 0 ] == res [ k ] ) )
<operator>.postIncrement pos ++
<operator>.subtraction pos - 1
<operator>.subtraction pos - 1
memset memset ( res   0   sizeof ( res ) )
<operator>.assignment pos = 0
<operator>.assignment flag = 0
<operator>.subtraction pos - 1
<operator>.subtraction pos - 1
<operator>.logicalAnd ( arrOpp [ l ] [ 0 ] == ch ) && ( arrOpp [ l ] [ 1 ] == res [ k ] )
<operator>.logicalAnd ( arrOpp [ l ] [ 1 ] == ch ) && ( arrOpp [ l ] [ 0 ] == res [ k ] )
<operator>.equals arrOpp [ l ] [ 0 ] == ch
<operator>.equals arrOpp [ l ] [ 1 ] == res [ k ]
<operator>.equals arrOpp [ l ] [ 1 ] == ch
<operator>.equals arrOpp [ l ] [ 0 ] == res [ k ]
<operator>.addressOf & ch
<operator>.addressOf & arrRep [ j ] [ 0 ]
<operator>.addressOf & arrRep [ j ] [ 1 ]
<operator>.addressOf & arrRep [ j ] [ 2 ]
<operator>.addressOf & ch
<operator>.addressOf & arrOpp [ j ] [ 0 ]
<operator>.addressOf & arrOpp [ j ] [ 1 ]
<operator>.addressOf & ch
<operator>.indirectIndexAccess res [ j ]
<operator>.indirectIndexAccess arrRep [ j ] [ 0 ]
<operator>.indirectIndexAccess arrRep [ j ] [ 1 ]
<operator>.indirectIndexAccess arrRep [ j ] [ 2 ]
<operator>.indirectIndexAccess arrOpp [ j ] [ 0 ]
<operator>.indirectIndexAccess arrOpp [ j ] [ 1 ]
<operator>.indirectIndexAccess arrRep [ j ]
<operator>.indirectIndexAccess arrRep [ j ]
<operator>.indirectIndexAccess arrRep [ j ]
<operator>.indirectIndexAccess arrOpp [ j ]
<operator>.indirectIndexAccess arrOpp [ j ]
<operator>.indirectIndexAccess res [ pos ++ ]
<operator>.indirectIndexAccess res [ pos ++ ]
<operator>.indirectIndexAccess res [ pos - 1 ]
<operator>.indirectIndexAccess arrRep [ k ] [ 2 ]
<operator>.indirectIndexAccess arrRep [ k ] [ 0 ]
<operator>.indirectIndexAccess arrRep [ k ] [ 1 ]
<operator>.indirectIndexAccess res [ pos - 1 ]
<operator>.indirectIndexAccess arrRep [ k ] [ 0 ]
<operator>.indirectIndexAccess res [ pos - 1 ]
<operator>.indirectIndexAccess arrRep [ k ] [ 1 ]
<operator>.indirectIndexAccess arrRep [ k ]
<operator>.indirectIndexAccess arrRep [ k ]
<operator>.indirectIndexAccess arrRep [ k ]
<operator>.indirectIndexAccess arrRep [ k ]
<operator>.indirectIndexAccess arrRep [ k ]
<operator>.sizeOf sizeof ( res )
<operator>.indirectIndexAccess arrOpp [ l ] [ 0 ]
<operator>.indirectIndexAccess arrOpp [ l ] [ 1 ]
<operator>.indirectIndexAccess res [ k ]
<operator>.indirectIndexAccess arrOpp [ l ] [ 1 ]
<operator>.indirectIndexAccess arrOpp [ l ] [ 0 ]
<operator>.indirectIndexAccess res [ k ]
<operator>.indirectIndexAccess arrOpp [ l ]
<operator>.indirectIndexAccess arrOpp [ l ]
<operator>.indirectIndexAccess arrOpp [ l ]
<operator>.indirectIndexAccess arrOpp [ l ]
>>>PDG&127 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->31 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->53 0->54 0->55 0->59 0->60 0->61 0->62 0->65 0->66 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->78 0->80 2->1 2->17 3->1 3->1 3->35 4->1 6->4 7->1 7->1 7->37 7->63 7->64 7->79 7->81 8->1 8->1 9->1 9->1 10->1 10->18 10->43 11->1 11->20 11->59 12->1 12->22 13->1 13->28 13->31 13->34 13->47 13->51 13->62 13->78 14->1 14->24 14->39 15->1 15->1 16->1 17->1 17->1 18->1 18->1 18->10 18->18 18->19 18->19 18->28 18->29 18->43 18->82 18->83 18->84 18->85 18->91 18->92 18->93 18->96 18->97 18->98 19->1 19->18 20->1 20->1 20->11 20->20 20->21 20->21 20->31 20->32 20->59 20->86 20->87 20->88 20->94 20->95 20->99 20->100 21->1 21->20 22->1 22->1 22->12 22->22 22->23 22->23 22->34 22->39 22->89 23->1 23->22 24->1 24->1 24->1 24->24 24->25 24->25 24->37 24->40 24->40 24->40 24->48 24->48 24->90 25->1 25->24 27->18 28->13 28->31 28->34 28->47 28->51 28->62 28->78 29->1 29->1 29->1 30->20 31->13 31->34 31->47 31->51 31->62 31->78 32->1 32->1 33->22 34->1 34->13 34->28 34->31 34->47 34->51 34->62 34->65 34->78 34->80 35->1 35->15 36->1 36->24 37->1 37->1 37->7 37->71 38->1 39->1 39->24 39->41 39->43 39->47 39->49 39->51 39->54 39->58 39->61 39->61 39->68 39->68 39->69 39->70 39->70 39->74 39->75 39->101 39->102 40->1 40->1 40->24 40->42 41->1 41->1 42->1 43->1 43->1 43->1 43->10 43->18 43->43 43->44 43->44 43->50 43->56 43->62 43->105 43->112 44->1 44->43 47->1 47->1 47->1 47->7 47->71 49->1 49->43 50->1 50->1 50->1 50->52 50->53 50->69 50->103 50->104 50->111 51->1 51->1 51->1 51->7 51->71 52->1 52->1 52->1 52->7 52->63 52->64 52->71 53->1 53->1 54->1 54->1 54->54 54->55 54->55 54->59 54->66 55->1 55->54 56->1 56->1 56->50 56->50 56->57 56->64 56->75 56->108 56->109 56->114 57->1 57->1 57->50 57->50 58->1 58->1 58->54 59->1 59->1 59->1 59->11 59->20 59->59 59->60 59->60 59->67 59->76 59->78 59->117 59->123 60->1 60->59 61->24 61->39 62->1 62->1 62->13 62->28 62->31 62->34 62->47 62->51 62->56 62->56 62->63 62->64 62->65 62->74 62->78 62->106 62->107 62->113 63->1 63->1 63->7 63->56 63->56 63->64 63->65 63->71 64->1 64->1 64->7 64->57 64->57 64->62 64->63 64->65 64->71 64->110 64->115 65->1 65->1 65->13 65->28 65->31 65->34 65->47 65->51 65->57 65->57 65->62 65->63 65->78 66->1 66->59 67->1 67->1 67->1 67->71 67->72 67->73 67->116 68->24 68->39 69->24 69->39 69->68 69->70 69->74 69->75 70->24 70->39 70->58 70->58 70->68 71->1 71->1 71->37 71->63 71->64 71->79 71->81 72->1 72->24 72->39 72->68 73->1 73->1 74->24 74->39 74->68 74->69 74->70 74->75 75->24 75->39 75->68 75->69 75->70 75->74 76->1 76->1 76->67 76->67 76->77 76->80 76->120 76->125 77->1 77->1 77->67 77->67 78->1 78->1 78->13 78->28 78->31 78->34 78->47 78->51 78->62 78->76 78->76 78->79 78->80 78->81 78->118 78->119 78->124 79->1 79->1 79->7 79->71 79->76 79->76 79->80 79->81 80->1 80->1 80->13 80->28 80->31 80->34 80->47 80->51 80->62 80->77 80->77 80->78 80->79 80->81 80->121 80->122 80->126 81->1 81->1 81->7 81->71 81->77 81->77 81->78 81->79
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int t , c , d , n , i , j , k , pos , l , flag ; char ch , arrRep [ 1 ] [ 3 ] , arrOpp [ 1 ] [ 2 ] , res [ SIZE ] ; scanf ( "\x25\x64\x0" , & t ) ; i = 1 ; while ( t ) { memset ( res , 0 , sizeof ( res ) ) ; memset ( arrRep , 0 , sizeof ( arrRep ) ) ; memset ( arrOpp , 0 , sizeof ( arrOpp ) ) ; scanf ( "%d" , & c ) ; for ( j = 0 ; j < c ; ++ j ) { scanf ( "%c" , & ch ) ; scanf ( "%c%c%c" , & arrRep [ j ] [ 0 ] , & arrRep [ j ] [ 1 ] , & arrRep [ j ] [ 2 ] ) ; } scanf ( "%d" , & d ) ; for ( j = 0 ; j < d ; ++ j ) { scanf ( "%c" , & ch ) ; scanf ( "%c%c" , & arrOpp [ j ] [ 0 ] , & arrOpp [ j ] [ 1 ] ) ; } scanf ( "%d" , & n ) ; scanf ( "%c" , & ch ) ; pos = 0 ; for ( j = 0 ; j < n ; ++ j ) { scanf ( "%c" , & ch ) ; if ( pos != 0 ) { flag = 1 ; for ( k = 0 ; k < c ; ++ k ) if ( ( ( arrRep [ k ] [ 0 ] == ch ) && ( arrRep [ k ] [ 1 ] == res [ pos - 1 ] ) ) || ( ( arrRep [ k ] [ 0 ] == res [ pos - 1 ] ) && ( arrRep [ k ] [ 1 ] == ch ) ) ) { res [ pos - 1 ] = arrRep [ k ] [ 2 ] ; flag = 0 ; } if ( flag ) { for ( k = pos - 1 ; k >= 0 ; -- k ) for ( l = 0 ; l < d ; ++ l ) if ( ( ( arrOpp [ l ] [ 0 ] == ch ) && ( arrOpp [ l ] [ 1 ] == res [ k ] ) ) || ( ( arrOpp [ l ] [ 1 ] == ch ) && ( arrOpp [ l ] [ 0 ] == res [ k ] ) ) ) { memset ( res , 0 , sizeof ( res ) ) ; pos = 0 ; flag = 0 ; } } if ( flag ) res [ pos ++ ] = ch ; } else res [ pos ++ ] = ch ; } printf ( "Case #%d: [" , i ++ ) ; for ( j = 0 ; j < pos ; ++ j ) { printf ( "%c" , res [ j ] ) ; if ( j + 1 != pos ) printf ( ", " ) ; } printf ( "]" ) ; -- t ; if ( t ) printf ( "\n" ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment * p = fopen ( "\x61\x2e\x6f\x75\x74\x0" , "w" )
<operator>.assignment * in = fopen ( "a.in" , "r" )
<operator>.assignment c = 0
fscanf fscanf ( in , "%lld" , & T )
fclose fclose ( p )
fclose fclose ( in )
RETURN return 0 ; return 0 ;
<operator>.postDecrement T --
LITERAL 0 return 0 ;
fopen fopen ( "\x61\x2e\x6f\x75\x74\x0" , "w" )
fopen fopen ( "a.in" , "r" )
fscanf fscanf ( in , "%lld" , & N )
memset memset ( sched   0   sizeof ( sched ) )
memset memset ( wp   0   sizeof ( wp ) )
memset memset ( owp   0   sizeof ( owp ) )
memset memset ( oowp   0   sizeof ( oowp ) )
memset memset ( played   0   sizeof ( played ) )
memset memset ( won   0   sizeof ( won ) )
fprintf fprintf ( p , "Case #%lld:\n" , ++ c )
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.assignment i = 0
fscanf fscanf ( in , "%s" , sched [ i ] )
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment oplayed = 0
<operator>.assignment owon = 0
<operator>.assignment op = 0
printf printf ( "\n" )
<operator>.assignment i = 0
<operator>.assignment op = 0
<operator>.assignment oplayed = 0
<operator>.assignment oowp [ i ] = ( float ) op / ( float ) oplayed
<operator>.assignment i = 0
printf printf ( "%s |%d/%d=%f| %f\n" , sched [ i ] , won [ i ] , played [ i ] , wp [ i ] , owp [ i ] )
<operator>.preIncrement ++ c
<operator>.assignment i = 0
fprintf fprintf ( p , "%f\n" , 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ] )
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment wp [ i ] = ( float ) won [ i ] / ( float ) played [ i ]
<operator>.assignment j = 0
<operator>.assignment owp [ i ] = op / ( float ) oplayed
<operator>.assignment j = 0
<operator>.division ( float ) op / ( float ) oplayed
<operator>.addition 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ]
<operator>.notEquals sched [ i ] [ j ] != '.'
<operator>.notEquals sched [ i ] [ j ] != '.'
<operator>.notEquals sched [ i ] [ j ] != '.'
<operator>.cast ( float ) op
<operator>.cast ( float ) oplayed
<operator>.addition 0.25 * wp [ i ] + 0.5 * owp [ i ]
<operator>.multiplication 0.25 * oowp [ i ]
<operator>.postIncrement played [ i ] ++
<operator>.division ( float ) won [ i ] / ( float ) played [ i ]
<operator>.postIncrement oplayed ++
<operator>.assignmentPlus op += ( float ) owon / ( float ) ( played [ j ] - 1 )
printf printf ( "%d:%d: %c->%c: op=%lld/%d=%f\t"   i   j   'a' + i   'a' + j   owon   played [ j ] - 1   ( float ) owon / ( float ) ( played [ j ] - 1 ) )
<operator>.division op / ( float ) oplayed
<operator>.postIncrement oplayed ++
<operator>.assignmentPlus op += owp [ j ]
<operator>.multiplication 0.25 * wp [ i ]
<operator>.multiplication 0.5 * owp [ i ]
<operator>.equals sched [ i ] [ j ] == '1'
<operator>.cast ( float ) won [ i ]
<operator>.cast ( float ) played [ i ]
<operator>.equals sched [ i ] [ j ] == '1'
<operator>.cast ( float ) oplayed
<operator>.postIncrement won [ i ] ++
<operator>.assignment owon = won [ j ]
<operator>.division ( float ) owon / ( float ) ( played [ j ] - 1 )
<operator>.addition 'a' + i
<operator>.addition 'a' + j
<operator>.subtraction played [ j ] - 1
<operator>.division ( float ) owon / ( float ) ( played [ j ] - 1 )
<operator>.cast ( float ) owon
<operator>.cast ( float ) ( played [ j ] - 1 )
<operator>.cast ( float ) owon
<operator>.cast ( float ) ( played [ j ] - 1 )
<operator>.subtraction played [ j ] - 1
<operator>.subtraction played [ j ] - 1
<operator>.assignment owon = won [ j ] - 1
<operator>.subtraction won [ j ] - 1
<operator>.addressOf & N
<operator>.sizeOf sizeof ( sched )
<operator>.sizeOf sizeof ( wp )
<operator>.sizeOf sizeof ( owp )
<operator>.sizeOf sizeof ( oowp )
<operator>.sizeOf sizeof ( played )
<operator>.sizeOf sizeof ( won )
<operator>.indirectIndexAccess sched [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess sched [ i ]
<operator>.indirectIndexAccess won [ i ]
<operator>.indirectIndexAccess played [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
UNKNOWN float float
UNKNOWN float float
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess sched [ i ] [ j ]
<operator>.indirectIndexAccess sched [ i ] [ j ]
<operator>.indirectIndexAccess sched [ i ] [ j ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess sched [ i ]
<operator>.indirectIndexAccess played [ i ]
UNKNOWN float float
<operator>.indirectIndexAccess won [ i ]
UNKNOWN float float
<operator>.indirectIndexAccess played [ i ]
<operator>.indirectIndexAccess sched [ i ]
UNKNOWN float float
<operator>.indirectIndexAccess sched [ i ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess sched [ i ] [ j ]
<operator>.indirectIndexAccess sched [ i ] [ j ]
<operator>.indirectIndexAccess played [ j ]
<operator>.indirectIndexAccess sched [ i ]
<operator>.indirectIndexAccess won [ i ]
<operator>.indirectIndexAccess sched [ i ]
<operator>.indirectIndexAccess won [ j ]
UNKNOWN float float
UNKNOWN float float
UNKNOWN float float
UNKNOWN float float
<operator>.indirectIndexAccess won [ j ]
<operator>.indirectIndexAccess played [ j ]
<operator>.indirectIndexAccess played [ j ]
<operator>.indirectIndexAccess won [ j ]
>>>PDG&149 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->58 0->60 0->61 0->63 0->64 0->65 0->66 0->67 0->69 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->83 0->84 0->87 0->88 0->89 0->90 0->91 0->92 0->94 0->96 0->97 0->99 2->1 2->1 2->6 2->20 3->1 3->1 3->5 4->1 4->1 4->47 5->1 5->1 5->7 5->9 5->13 6->1 6->1 7->1 7->1 8->1 9->1 9->1 9->9 9->13 9->14 9->15 9->16 9->17 9->18 9->19 9->20 9->21 9->23 9->25 9->27 9->29 9->31 9->33 9->35 9->36 9->41 9->45 9->47 9->48 9->100 9->101 9->102 9->103 9->104 9->105 9->106 10->8 11->2 11->2 12->3 12->3 13->1 13->1 13->7 13->21 13->23 13->25 13->27 13->29 13->31 13->34 13->50 13->52 13->54 14->1 14->1 14->34 14->46 15->1 15->1 15->46 15->78 16->1 16->1 16->46 16->77 16->79 17->1 17->1 17->69 18->1 18->1 18->46 18->70 18->71 18->82 18->90 18->96 18->97 19->1 19->1 19->46 19->71 19->81 19->85 19->86 19->99 20->1 20->1 20->6 20->49 21->21 21->22 21->22 21->23 21->34 21->107 22->1 22->21 23->23 23->24 23->24 23->25 23->50 23->50 23->56 24->1 24->23 25->25 25->26 25->26 25->27 25->37 25->38 25->39 25->40 25->52 25->52 25->58 25->74 25->88 26->1 26->25 27->27 27->28 27->28 27->29 27->42 27->43 27->44 27->54 27->54 27->60 27->61 27->66 27->67 27->108 27->116 27->117 28->1 28->27 29->29 29->30 29->30 29->31 29->46 29->109 29->110 29->111 29->112 29->113 30->1 30->29 31->1 31->1 31->1 31->13 31->21 31->31 31->32 31->32 31->49 31->62 31->68 31->69 31->78 31->79 31->118 31->122 31->123 32->1 32->31 33->21 34->1 34->1 34->7 34->13 34->14 34->46 35->23 36->25 37->1 37->1 37->72 37->75 37->84 38->1 38->1 38->74 38->87 38->91 38->92 38->94 39->1 39->1 39->73 39->75 40->1 41->27 42->1 42->61 42->66 42->77 43->1 43->61 43->67 43->76 44->1 44->1 44->1 44->17 44->69 45->29 46->1 46->1 46->1 46->1 46->1 46->1 46->14 46->15 46->16 46->18 46->19 46->34 46->70 46->71 46->71 46->78 46->79 46->81 46->82 46->85 47->1 47->20 48->1 48->31 49->1 49->1 49->6 49->20 50->1 50->1 50->23 50->50 50->51 50->51 50->57 50->63 50->71 50->81 50->82 50->114 50->119 50->124 50->126 50->127 50->128 50->129 51->1 51->50 52->1 52->1 52->25 52->52 52->53 52->53 52->59 52->64 52->74 52->75 52->84 52->89 52->115 52->120 52->130 52->131 53->1 53->52 54->1 54->1 54->27 54->54 54->55 54->55 54->65 54->121 54->132 55->1 55->54 56->1 56->50 57->1 57->1 57->1 57->15 57->46 57->78 58->1 58->52 59->1 59->1 59->1 59->16 59->46 59->79 60->1 60->54 61->1 61->1 61->44 61->44 62->1 62->1 63->1 63->1 63->34 63->46 63->64 63->65 63->70 63->80 63->80 63->125 63->134 63->137 64->1 64->1 64->34 64->46 64->63 64->65 64->72 64->73 64->74 64->83 64->83 64->87 64->88 64->89 64->90 64->91 64->92 64->93 64->94 64->95 64->96 64->97 64->135 64->136 64->139 64->141 64->142 64->143 64->144 64->146 64->147 65->1 65->1 65->34 65->46 65->63 65->64 65->76 65->77 65->133 66->1 67->1 68->1 68->1 69->1 69->17 69->49 69->49 69->62 69->62 70->1 70->18 70->46 70->71 70->82 71->1 71->1 71->57 71->57 72->1 72->75 72->84 73->1 73->75 74->1 74->1 74->1 74->1 74->1 74->1 74->26 74->53 74->87 74->88 74->91 74->92 74->94 75->1 75->1 75->59 75->59 75->73 76->1 76->61 76->67 77->1 77->1 77->61 77->66 78->1 78->15 78->46 78->49 78->49 78->62 78->62 78->68 78->68 79->1 79->16 79->46 79->49 79->49 79->62 79->62 79->68 79->68 80->1 80->1 80->34 80->46 80->63 80->64 80->65 80->85 80->138 81->1 82->1 83->1 83->1 83->34 83->46 83->63 83->64 83->65 83->86 83->140 83->145 84->1 85->1 85->19 85->46 85->71 85->81 86->1 86->1 86->74 86->87 86->91 86->92 86->94 87->73 87->73 90->74 90->74 90->97 91->1 91->1 91->74 91->74 96->87 96->87 96->90 96->93 96->93 97->1 97->18 97->74 97->74 97->91 97->91 97->95 97->95 97->96 98->1 98->1 98->74 98->87 98->91 98->92 98->94 99->1 99->19 99->86 99->98 99->98 145->98 145->99 145->148
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { FILE * p = fopen ( "\x61\x2e\x6f\x75\x74\x0" , "w" ) ; FILE * in = fopen ( "a.in" , "r" ) ; long long int T , c = 0 , N ; int i , j ; long long int oplayed , owon ; float op ; fscanf ( in , "%lld" , & T ) ; while ( T -- ) { fscanf ( in , "%lld" , & N ) ; memset ( sched , 0 , sizeof ( sched ) ) ; memset ( wp , 0 , sizeof ( wp ) ) ; memset ( owp , 0 , sizeof ( owp ) ) ; memset ( oowp , 0 , sizeof ( oowp ) ) ; memset ( played , 0 , sizeof ( played ) ) ; memset ( won , 0 , sizeof ( won ) ) ; for ( i = 0 ; i < N ; i ++ ) { fscanf ( in , "%s" , sched [ i ] ) ; } for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( sched [ i ] [ j ] != '.' ) { played [ i ] ++ ; if ( sched [ i ] [ j ] == '1' ) { won [ i ] ++ ; } } wp [ i ] = ( float ) won [ i ] / ( float ) played [ i ] ; } } for ( i = 0 ; i < N ; i ++ ) { oplayed = 0 ; owon = 0 ; op = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( sched [ i ] [ j ] != '.' ) { oplayed ++ ; if ( sched [ i ] [ j ] == '1' ) { owon = won [ j ] ; } else { if ( won [ j ] ) owon = won [ j ] - 1 ; } op += ( float ) owon / ( float ) ( played [ j ] - 1 ) ; printf ( "%d:%d: %c->%c: op=%lld/%d=%f\t" , i , j , 'a' + i , 'a' + j , owon , played [ j ] - 1 , ( float ) owon / ( float ) ( played [ j ] - 1 ) ) ; } owp [ i ] = op / ( float ) oplayed ; } printf ( "\n" ) ; } for ( i = 0 ; i < N ; i ++ ) { op = 0 ; oplayed = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( sched [ i ] [ j ] != '.' ) { oplayed ++ ; op += owp [ j ] ; } } oowp [ i ] = ( float ) op / ( float ) oplayed ; } for ( i = 0 ; i < N ; i ++ ) { printf ( "%s |%d/%d=%f| %f\n" , sched [ i ] , won [ i ] , played [ i ] , wp [ i ] , owp [ i ] ) ; } fprintf ( p , "Case #%lld:\n" , ++ c ) ; for ( i = 0 ; i < N ; i ++ ) { fprintf ( p , "%f\n" , 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ] ) ; } } fclose ( p ) ; fclose ( in ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
<operator>.assignment caseNo = 0
<operator>.assignment * fp = fopen ( IN_PATH , "\x72\x0" )
<operator>.assignment * out = fopen ( OUT_PATH , "w" )
fscanf fscanf ( fp , "%d\n" , & T )
fclose fclose ( out )
fclose fclose ( fp )
RETURN return 0 ; return 0 ;
<operator>.logicalNot ! fp
<operator>.logicalNot ! out
<operator>.lessThan caseNo ++ < T
LITERAL 0 return 0 ;
fopen fopen ( IN_PATH , "\x72\x0" )
RETURN return - 1 ; return - 1 ;
fopen fopen ( OUT_PATH , "w" )
RETURN return - 2 ; return - 2 ;
memset memset ( ( void * ) & lookup   0   sizeof ( lookup ) )
fscanf fscanf ( fp , "%d" , & C )
fscanf fscanf ( fp , "%d" , & D )
fscanf fscanf ( fp , "%d " , & N )
fscanf fscanf ( fp , "%s" , list )
<operator>.assignment w = 0
<operator>.assignment r = 0
<operator>.assignment N = strlen ( list )
fprintf fprintf ( out , "Case #%d: [" , caseNo )
fprintf fprintf ( out , "]\n" )
<operator>.minus - 1
<operator>.minus - 2
<operator>.postIncrement caseNo ++
<operator>.greaterThan C -- > 0
<operator>.greaterThan D -- > 0
<operator>.lessThan r ++ < N
<operator>.greaterThan N > 0
<operator>.cast ( void * ) & lookup
fscanf fscanf ( fp , " %c%c%c" , & base1 , & base2 , & nonbase )
<operator>.assignment base1i = index ( base1 )
<operator>.assignment base2i = index ( base2 )
<operator>.assignment lookup [ base1i ] . combine [ base2i ] = nonbase
<operator>.assignment lookup [ base2i ] . combine [ base1i ] = nonbase
fscanf fscanf ( fp , " %c%c" , & base1 , & base2 )
<operator>.assignment base1i = index ( base1 )
<operator>.assignment base2i = index ( base2 )
<operator>.assignment lookup [ base1i ] . oppose [ base2i ] = 1
<operator>.assignment lookup [ base2i ] . oppose [ base1i ] = 1
<operator>.assignment write = index ( list [ w ] )
<operator>.assignment read = index ( list [ r ] )
strlen strlen ( list )
fprintf fprintf ( out , "%c" , list [ 0 ] )
<operator>.postDecrement C --
<operator>.postDecrement D --
<operator>.postIncrement r ++
<operator>.notEquals lookup [ read ] . combine [ write ] != '\0'
<operator>.lessThan i < N
<operator>.postIncrement i ++
fprintf fprintf ( out , ", %c" , list [ i ] )
index index ( base1 )
index index ( base2 )
index index ( base1 )
index index ( base2 )
index index ( list [ w ] )
index index ( list [ r ] )
<operator>.assignment list [ w ] = lookup [ read ] . combine [ write ]
<operator>.assignment i = 1
<operator>.greaterEqualsThan i >= 0
<operator>.postDecrement i --
<operator>.lessThan i < 0
<operator>.assignment i = w
<operator>.assignment list [ ++ w ] = list [ r ]
<operator>.assignment list [ ( w = 0 ) ] = list [ ++ r ]
index index ( list [ i ] )
<operator>.preIncrement ++ w
<operator>.assignment w = 0
<operator>.preIncrement ++ r
<operator>.addressOf & T
<operator>.sizeOf sizeof ( lookup )
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
UNKNOWN void * void *
<operator>.addressOf & lookup
<operator>.addressOf & base1
<operator>.addressOf & base2
<operator>.addressOf & nonbase
<operator>.indirectIndexAccess lookup [ base1i ] . combine [ base2i ]
<operator>.indirectIndexAccess lookup [ base2i ] . combine [ base1i ]
<operator>.addressOf & base1
<operator>.addressOf & base2
<operator>.indirectIndexAccess lookup [ base1i ] . oppose [ base2i ]
<operator>.indirectIndexAccess lookup [ base2i ] . oppose [ base1i ]
<operator>.indirectIndexAccess list [ 0 ]
<operator>.fieldAccess lookup [ base1i ] . combine
<operator>.fieldAccess lookup [ base2i ] . combine
<operator>.fieldAccess lookup [ base1i ] . oppose
<operator>.fieldAccess lookup [ base2i ] . oppose
<operator>.indirectIndexAccess list [ w ]
<operator>.indirectIndexAccess list [ r ]
<operator>.indirectIndexAccess lookup [ read ] . combine [ write ]
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess lookup [ base1i ]
FIELD_IDENTIFIER combine combine
<operator>.indirectIndexAccess lookup [ base2i ]
FIELD_IDENTIFIER combine combine
<operator>.indirectIndexAccess lookup [ base1i ]
FIELD_IDENTIFIER oppose oppose
<operator>.indirectIndexAccess lookup [ base2i ]
FIELD_IDENTIFIER oppose oppose
<operator>.fieldAccess lookup [ read ] . combine
<operator>.indirectIndexAccess list [ w ]
<operator>.indirectIndexAccess lookup [ read ] . combine [ write ]
<operator>.indirectIndexAccess lookup [ read ]
FIELD_IDENTIFIER combine combine
<operator>.fieldAccess lookup [ read ] . combine
<operator>.indirectIndexAccess lookup [ read ]
FIELD_IDENTIFIER combine combine
<operator>.indirectIndexAccess lookup [ read ] . oppose [ index ( list [ i ] ) ]
<operator>.fieldAccess lookup [ read ] . oppose
<operator>.indirectIndexAccess list [ ++ w ]
<operator>.indirectIndexAccess list [ r ]
<operator>.indirectIndexAccess lookup [ read ]
FIELD_IDENTIFIER oppose oppose
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess list [ ( w = 0 ) ]
<operator>.indirectIndexAccess list [ ++ r ]
>>>PDG&125 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->39 0->40 0->41 0->44 0->45 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->64 0->65 0->66 0->67 0->68 0->72 0->73 0->74 2->1 3->1 3->1 3->30 4->1 4->1 4->10 5->11 6->8 6->12 6->19 9->1 10->1 10->1 10->5 10->6 10->11 10->15 10->16 10->28 11->6 11->7 11->7 11->8 11->9 11->12 11->17 11->26 11->29 11->30 11->75 12->12 12->18 12->19 12->20 12->21 12->22 12->23 12->24 12->25 12->26 12->27 12->30 12->31 12->32 12->33 12->34 12->35 12->48 12->50 12->51 12->52 12->76 12->77 12->78 12->79 12->80 12->81 13->9 14->1 14->4 14->4 15->1 16->1 16->5 16->5 17->1 19->20 19->36 19->50 20->21 20->41 20->51 21->22 21->33 21->34 21->54 22->8 22->19 22->48 22->61 22->62 22->69 22->70 22->71 23->68 23->72 24->52 25->34 26->27 26->30 26->49 27->7 27->26 28->1 28->15 29->17 30->12 30->26 31->31 31->36 31->37 31->38 31->39 31->40 31->50 31->57 31->58 31->82 31->83 31->84 31->85 31->86 31->92 31->93 31->100 31->101 31->102 31->103 32->32 32->41 32->42 32->43 32->44 32->45 32->51 32->59 32->60 32->87 32->88 32->89 32->90 32->94 32->95 32->104 32->105 32->106 32->107 33->33 33->46 33->47 33->52 33->53 33->61 33->62 33->96 33->97 33->98 33->108 33->111 33->112 34->21 34->33 34->49 34->54 34->54 34->64 34->91 36->20 36->39 36->40 36->41 36->41 36->57 36->58 36->59 36->60 41->21 41->36 41->36 41->57 41->58 41->59 41->60 48->22 48->25 48->49 48->56 49->22 49->27 49->48 49->56 50->19 50->31 51->20 51->32 52->33 52->74 53->63 53->63 53->65 53->67 53->68 53->109 53->110 53->113 53->114 53->115 54->21 54->33 54->54 54->55 54->55 54->56 54->99 55->54 56->22 56->27 56->48 56->71 57->36 57->37 57->41 57->59 58->36 58->38 58->41 58->60 59->36 59->41 59->42 59->57 60->36 60->41 60->43 60->58 61->22 61->46 61->48 62->22 62->47 62->48 62->69 63->22 63->48 63->61 64->54 65->66 65->67 65->71 65->116 65->117 65->120 65->121 65->122 66->65 67->69 67->72 67->118 67->119 68->65 69->22 69->48 70->22 70->48 71->22 71->48 71->56 72->68 73->68 73->72 74->52 116->65 116->66 116->70 116->73 116->74 116->123 116->124
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( void ) { int T , C , D , N , i , caseNo = 0 , base1i , base2i ; char base1 , base2 , nonbase , list [ 102 ] ; FILE * fp = fopen ( IN_PATH , "\x72\x0" ) ; if ( ! fp ) return - 1 ; FILE * out = fopen ( OUT_PATH , "w" ) ; if ( ! out ) return - 2 ; fscanf ( fp , "%d\n" , & T ) ; while ( caseNo ++ < T ) { letter lookup [ 9 ] ; memset ( ( void * ) & lookup , 0 , sizeof ( lookup ) ) ; fscanf ( fp , "%d" , & C ) ; while ( C -- > 0 ) { fscanf ( fp , " %c%c%c" , & base1 , & base2 , & nonbase ) ; base1i = index ( base1 ) ; base2i = index ( base2 ) ; lookup [ base1i ] . combine [ base2i ] = nonbase ; lookup [ base2i ] . combine [ base1i ] = nonbase ; } fscanf ( fp , "%d" , & D ) ; while ( D -- > 0 ) { fscanf ( fp , " %c%c" , & base1 , & base2 ) ; base1i = index ( base1 ) ; base2i = index ( base2 ) ; lookup [ base1i ] . oppose [ base2i ] = 1 ; lookup [ base2i ] . oppose [ base1i ] = 1 ; } fscanf ( fp , "%d " , & N ) ; fscanf ( fp , "%s" , list ) ; int w = 0 , write ; int r = 0 , read ; while ( r ++ < N ) { write = index ( list [ w ] ) ; read = index ( list [ r ] ) ; if ( lookup [ read ] . combine [ write ] != '\0' ) { list [ w ] = lookup [ read ] . combine [ write ] ; } else { for ( i = w ; i >= 0 ; i -- ) if ( lookup [ read ] . oppose [ index ( list [ i ] ) ] ) { list [ ( w = 0 ) ] = list [ ++ r ] ; break ; } if ( i < 0 ) { list [ ++ w ] = list [ r ] ; } } } N = strlen ( list ) ; fprintf ( out , "Case #%d: [" , caseNo ) ; if ( N > 0 ) { fprintf ( out , "%c" , list [ 0 ] ) ; for ( i = 1 ; i < N ; i ++ ) fprintf ( out , ", %c" , list [ i ] ) ; } fprintf ( out , "]\n" ) ; } fclose ( out ) ; fclose ( fp ) ; return 0 ; }
>>>Func
METHOD getCopyCArray
METHOD_RETURN CArray
PARAM CArray * arr
<operator>.assignment * array = ( CArray * ) malloc ( sizeof ( CArray ) )
<operator>.assignment array -> array = ( int * ) malloc ( sizeof ( int ) * arr -> size )
<operator>.assignment array -> size = arr -> size
RETURN return array ; return array ;
<operator>.lessThan i < arr -> size
<operator>.postIncrement i ++
IDENTIFIER array return array ;
<operator>.cast ( CArray * ) malloc ( sizeof ( CArray ) )
<operator>.cast ( int * ) malloc ( sizeof ( int ) * arr -> size )
<operator>.assignment i = 0
<operator>.assignment array -> array [ i ] = arr -> array [ i ]
malloc malloc ( sizeof ( int ) * arr -> size )
<operator>.sizeOf sizeof ( CArray )
<operator>.multiplication sizeof ( int ) * arr -> size
<operator>.sizeOf sizeof ( int )
<operator>.indirectFieldAccess arr -> size
FIELD_IDENTIFIER size size
<operator>.indirectIndexAccess array -> array [ i ]
<operator>.indirectIndexAccess arr -> array [ i ]
<operator>.indirectFieldAccess array -> array
<operator>.indirectFieldAccess arr -> array
FIELD_IDENTIFIER array array
FIELD_IDENTIFIER array array
>>>PDG&26 0->2 0->7 0->8 0->9 0->12 2->1 3->1 3->1 3->1 3->9 4->1 4->1 4->1 5->1 5->1 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->13 7->18 7->19 7->20 7->21 7->22 7->23 7->24 7->25 8->1 8->7 9->6 10->1 11->1 12->1 12->7 13->1 13->1 13->1 14->1 14->4 14->11 15->1 16->5 16->7 16->14 17->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) CArray * getCopyCArray ( CArray * arr ) { CArray * array = ( CArray * ) malloc ( sizeof ( CArray ) ) ; array -> array = ( int * ) malloc ( sizeof ( int ) * arr -> size ) ; array -> size = arr -> size ; int i ; for ( i = 0 ; i < arr -> size ; i ++ ) { array -> array [ i ] = arr -> array [ i ] ; } return array ; }
>>>Func
METHOD checkConversion
METHOD_RETURN int
<operator>.assignment i = 0
<operator>.assignment flag = 0
<operator>.assignment fc = OP [ opc - 1 ]
<operator>.assignment sc = OP [ opc - 2 ]
RETURN return flag ; return flag ;
<operator>.lessThan i < c
<operator>.preIncrement ++ i
IDENTIFIER flag return flag ;
<operator>.subtraction opc - 1
<operator>.subtraction opc - 2
<operator>.logicalOr ( fc == C [ i ] [ 0 ] && sc == C [ i ] [ 1 ] ) || ( fc == C [ i ] [ 1 ] && sc == C [ i ] [ 0 ] )
<operator>.assignment flag = 1
<operator>.preDecrement -- opc
<operator>.assignment OP [ opc - 1 ] = C [ i ] [ 2 ]
<operator>.assignment OP [ opc ] = '\0'
<operator>.logicalAnd fc == C [ i ] [ 0 ] && sc == C [ i ] [ 1 ]
<operator>.logicalAnd fc == C [ i ] [ 1 ] && sc == C [ i ] [ 0 ]
<operator>.equals fc == C [ i ] [ 0 ]
<operator>.equals sc == C [ i ] [ 1 ]
<operator>.equals fc == C [ i ] [ 1 ]
<operator>.equals sc == C [ i ] [ 0 ]
<operator>.subtraction opc - 1
<operator>.indirectIndexAccess OP [ opc - 1 ]
<operator>.indirectIndexAccess C [ i ] [ 2 ]
<operator>.indirectIndexAccess OP [ opc ]
<operator>.indirectIndexAccess C [ i ] [ 0 ]
<operator>.indirectIndexAccess C [ i ] [ 1 ]
<operator>.indirectIndexAccess C [ i ] [ 1 ]
<operator>.indirectIndexAccess C [ i ] [ 0 ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
<operator>.indirectIndexAccess C [ i ]
>>>PDG&36 0->2 0->3 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->16 0->19 0->20 0->21 0->22 0->23 2->1 2->7 3->1 3->1 3->9 4->1 4->1 4->1 4->19 5->1 5->1 5->1 5->20 5->22 6->1 7->1 7->1 7->1 7->8 7->12 7->17 7->19 7->27 7->32 8->1 8->7 9->6 10->11 11->1 11->14 12->1 12->1 12->1 12->7 12->8 12->13 12->14 12->15 12->16 12->23 12->24 12->25 12->26 12->31 13->1 13->1 13->9 14->1 14->23 15->1 15->1 15->1 16->1 16->1 17->1 17->1 17->12 17->12 17->18 17->21 17->29 17->34 18->1 18->1 18->12 18->12 19->1 19->1 19->17 19->17 19->20 19->21 19->22 19->28 19->33 20->1 20->1 20->17 20->17 20->21 20->22 21->1 21->1 21->18 21->18 21->19 21->20 21->22 21->30 21->35 22->1 22->1 22->18 22->18 22->19 22->20 23->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int checkConversion ( ) { int i = 0 , flag = 0 ; char fc = OP [ opc - 1 ] , sc = OP [ opc - 2 ] ; for ( ; i < c ; ++ i ) { if ( ( fc == C [ i ] [ 0 ] && sc == C [ i ] [ 1 ] ) || ( fc == C [ i ] [ 1 ] && sc == C [ i ] [ 0 ] ) ) { flag = 1 ; -- opc ; OP [ opc - 1 ] = C [ i ] [ 2 ] ; OP [ opc ] = '\0' ; break ; } } return flag ; }
>>>Func
METHOD alloc_test_realloc
METHOD_RETURN void*
PARAM void * ptr
PARAM size_t bytes
<operator>.assignment new_ptr = alloc_test_malloc ( bytes )
RETURN return new_ptr ; return new_ptr ;
<operator>.equals new_ptr == NULL
<operator>.notEquals ptr != NULL
IDENTIFIER new_ptr return new_ptr ;
alloc_test_malloc alloc_test_malloc ( bytes )
RETURN return NULL ; return NULL ;
<operator>.assignment header = alloc_test_get_header ( ptr )
<operator>.assignment bytes_to_copy = header -> bytes
memcpy memcpy ( new_ptr , ptr , bytes_to_copy )
alloc_test_free alloc_test_free ( ptr )
IDENTIFIER NULL return NULL ;
<operator>.greaterThan bytes_to_copy > bytes
alloc_test_get_header alloc_test_get_header ( ptr )
<operator>.assignment bytes_to_copy = bytes
<operator>.indirectFieldAccess header -> bytes
FIELD_IDENTIFIER bytes bytes
>>>PDG&21 0->2 0->3 0->6 0->7 0->8 0->9 0->13 0->14 0->15 0->16 0->17 0->18 2->1 2->7 3->9 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->5 6->7 6->7 6->8 6->10 6->13 6->15 7->11 7->12 7->13 7->14 7->16 7->17 7->17 7->19 7->20 8->5 9->1 9->4 9->16 10->1 12->16 13->8 13->14 15->10 16->13 16->18 16->18 17->11 17->13 18->13
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void * alloc_test_realloc ( void * ptr , size_t bytes ) { BlockHeader * header ; void * new_ptr ; size_t bytes_to_copy ; new_ptr = alloc_test_malloc ( bytes ) ; if ( new_ptr == NULL ) { return NULL ; } if ( ptr != NULL ) { header = alloc_test_get_header ( ptr ) ; bytes_to_copy = header -> bytes ; if ( bytes_to_copy > bytes ) { bytes_to_copy = bytes ; } memcpy ( new_ptr , ptr , bytes_to_copy ) ; alloc_test_free ( ptr ) ; } return new_ptr ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment testcases = 0
<operator>.assignment i = 0
<operator>.assignment j = 0
scanf scanf ( "\x25\x64\x0" , & testcases )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < testcases
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
scanf scanf ( "%d %d %d %d" , & L , & t , & N , & C )
<operator>.assignment totaltime = 0
insertsort insertsort ( distssort , C )
<operator>.assignment l = 1
<operator>.assignment max = 0
<operator>.assignment specialdistsave = specialdist
<operator>.assignment totaltime = t
<operator>.assignmentPlus totaltime += specialdistsave
printf printf ( "Case #%d: %.0f\n" , i + 1 , totaltime )
<operator>.lessThan j < C
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.greaterThan L > 0
<operator>.lessThan j < C
<operator>.postIncrement j ++
<operator>.assignment j = 0
scanf scanf ( "%d" , & dists [ j ] )
<operator>.assignment distssort [ j ] = dists [ j ]
<operator>.assignment distcounts [ j ] = 0
<operator>.assignment j = 0
<operator>.assignment max = distssort [ C - l ]
<operator>.postIncrement l ++
<operator>.assignment m = 0
<operator>.assignment j = 0
<operator>.assignmentPlus totaltime += ( distcounts [ j ] * dists [ j ] ) * 2
<operator>.addition i + 1
<operator>.logicalAnd ( ( totaltime + ( dists [ j % C ] * 2 ) ) > t ) && ( totaltime < t )
<operator>.greaterThan l > C
<operator>.greaterThan specialdist > max
<operator>.notEquals dists [ m ] != max
<operator>.lessThan L < distcounts [ m ]
<operator>.assignment specialdist = ( totaltime + ( dists [ j % C ] * 2 ) - t )
<operator>.assignmentPlus totaltime += dists [ j % C ] * 2
<operator>.assignment specialdistsave = specialdist / 2
<operator>.assignment specialdist = 0
<operator>.assignment L = L - 1
<operator>.postIncrement m ++
<operator>.assignment distcounts [ m ] = ( float ) ( distcounts [ m ] - ( float ) L / 2 )
<operator>.assignment L = 0
<operator>.multiplication ( distcounts [ j ] * dists [ j ] ) * 2
<operator>.greaterThan ( totaltime + ( dists [ j % C ] * 2 ) ) > t
<operator>.lessThan totaltime < t
<operator>.subtraction C - l
<operator>.assignment L = L - distcounts [ m ]
<operator>.assignment distcounts [ m ] = distcounts [ m ] / 2
<operator>.multiplication distcounts [ j ] * dists [ j ]
<operator>.addition totaltime + ( dists [ j % C ] * 2 )
<operator>.subtraction totaltime + ( dists [ j % C ] * 2 ) - t
<operator>.multiplication dists [ j % C ] * 2
<operator>.lessThan totaltime < t
<operator>.division specialdist / 2
<operator>.subtraction L - 1
<operator>.cast ( float ) ( distcounts [ m ] - ( float ) L / 2 )
<operator>.multiplication dists [ j % C ] * 2
<operator>.addition totaltime + ( dists [ j % C ] * 2 )
<operator>.assignmentPlus totaltime += dists [ j % C ] * 2
<operator>.subtraction distcounts [ m ] - ( float ) L / 2
<operator>.subtraction L - distcounts [ m ]
<operator>.division distcounts [ m ] / 2
<operator>.multiplication dists [ j % C ] * 2
<operator>.modulo j % C
<operator>.assignmentPlus totaltime += dists [ j % C ] * 2
<operator>.postIncrement distcounts [ j % C ] ++
<operator>.division ( float ) L / 2
<operator>.modulo j % C
<operator>.multiplication dists [ j % C ] * 2
<operator>.cast ( float ) L
<operator>.modulo j % C
<operator>.multiplication dists [ j % C ] * 2
<operator>.modulo j % C
<operator>.modulo j % C
<operator>.modulo j % C
<operator>.addressOf & L
<operator>.addressOf & t
<operator>.addressOf & N
<operator>.addressOf & C
<operator>.addressOf & dists [ j ]
<operator>.indirectIndexAccess distssort [ j ]
<operator>.indirectIndexAccess dists [ j ]
<operator>.indirectIndexAccess distcounts [ j ]
<operator>.indirectIndexAccess distssort [ C - l ]
<operator>.indirectIndexAccess dists [ j ]
<operator>.indirectIndexAccess dists [ m ]
<operator>.indirectIndexAccess distcounts [ m ]
<operator>.indirectIndexAccess distcounts [ m ]
<operator>.indirectIndexAccess distcounts [ j ]
<operator>.indirectIndexAccess dists [ j ]
<operator>.indirectIndexAccess dists [ j % C ]
UNKNOWN float float
<operator>.indirectIndexAccess distcounts [ m ]
<operator>.indirectIndexAccess dists [ j % C ]
<operator>.indirectIndexAccess distcounts [ m ]
<operator>.indirectIndexAccess distcounts [ m ]
<operator>.indirectIndexAccess distcounts [ m ]
<operator>.indirectIndexAccess dists [ j % C ]
<operator>.indirectIndexAccess dists [ j % C ]
<operator>.indirectIndexAccess distcounts [ j % C ]
UNKNOWN float float
<operator>.indirectIndexAccess dists [ j % C ]
>>>PDG&113 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->41 0->42 0->43 0->44 0->46 0->48 0->50 0->52 0->53 0->54 0->55 0->56 0->60 0->61 0->62 0->63 0->64 0->65 0->67 0->68 0->69 0->71 0->72 0->73 0->74 0->75 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 2->1 3->1 4->1 4->7 4->9 6->1 6->1 7->1 7->9 8->1 9->1 9->1 9->1 9->9 9->10 9->10 9->13 9->14 9->15 9->16 9->17 9->18 9->19 9->20 9->21 9->21 9->22 9->24 9->26 9->27 9->29 9->33 9->37 9->39 9->39 9->86 9->87 9->88 9->89 10->1 10->9 11->8 12->1 12->9 13->1 13->1 13->1 13->1 13->26 13->44 13->65 13->71 13->77 13->80 14->1 14->46 14->54 14->55 14->60 14->61 14->63 14->68 15->1 15->1 15->27 15->34 15->41 15->78 16->1 16->1 16->41 17->1 17->1 18->1 18->1 18->20 19->1 19->1 19->20 19->38 20->1 20->1 20->21 21->1 21->1 21->1 22->15 22->22 22->23 22->23 22->30 22->31 22->32 22->90 22->91 22->92 22->93 22->95 23->1 23->22 24->1 24->1 24->24 24->25 24->40 24->54 24->60 24->67 24->78 24->78 24->104 25->1 25->24 26->1 26->1 26->13 26->41 26->44 26->65 27->1 27->1 27->1 27->22 27->27 27->28 27->28 27->38 27->53 27->59 27->99 27->100 28->1 28->27 29->22 30->1 30->31 30->59 31->1 31->1 31->1 31->15 32->1 32->1 32->59 33->24 34->1 34->1 34->42 35->1 35->1 35->41 36->1 36->1 36->50 37->1 37->27 38->1 38->1 38->20 40->1 40->1 40->1 40->45 40->46 40->61 40->62 40->63 40->68 40->73 40->74 40->81 40->101 40->108 41->1 41->1 41->26 41->27 41->34 41->42 41->56 41->56 41->56 41->94 42->1 42->1 42->1 42->18 42->35 42->36 42->43 42->43 42->44 42->47 42->48 42->49 42->64 42->64 42->65 42->96 42->97 43->1 43->1 43->1 43->43 43->50 43->96 44->1 44->51 44->52 44->57 44->58 44->66 44->70 44->70 44->71 44->71 44->71 44->72 44->77 44->77 44->80 44->80 44->98 44->102 44->103 44->105 44->106 44->107 44->111 45->1 45->1 45->18 45->42 46->1 46->1 46->54 46->55 46->60 46->61 46->63 46->68 47->1 47->1 47->20 48->1 48->1 48->18 48->42 49->1 49->1 49->26 50->1 50->1 51->1 51->1 51->1 51->44 52->1 52->26 53->1 53->38 53->38 54->1 54->40 54->40 54->55 54->55 54->61 54->63 55->40 55->40 55->46 55->61 55->61 55->63 55->63 55->68 56->1 56->27 56->35 56->41 56->41 57->1 57->1 57->26 58->1 58->1 58->1 58->44 59->1 59->1 59->30 59->31 59->53 59->53 61->1 61->19 61->45 61->45 61->54 62->1 62->46 62->46 62->67 63->1 63->19 63->40 63->54 63->69 63->69 63->75 63->75 63->76 63->79 63->82 63->83 63->84 63->85 63->109 63->110 63->112 64->47 64->47 65->49 65->49 66->1 67->54 67->54 67->60 67->60 67->73 67->79 67->82 69->1 69->1 69->46 69->54 69->55 69->60 69->61 69->63 69->68 70->1 70->51 70->51 70->66 70->66 71->57 71->57 71->72 72->58 72->58 73->61 73->61 73->62 73->68 73->68 74->25 74->27 74->41 74->78 75->1 75->1 75->46 75->54 75->55 75->60 75->61 75->63 75->68 76->1 76->1 77->1 77->70 77->70 78->81 78->81 78->83 78->83 78->85 78->85 79->1 79->67 79->69 79->69 81->74 81->74 82->1 82->67 82->75 82->75 83->25 83->27 83->41 83->78 84->25 84->27 84->41 84->78 85->84 85->84
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( int argc , char * argv [ ] ) { int testcases = 0 ; int L , t , N , C ; int i = 0 ; int j = 0 ; scanf ( "\x25\x64\x0" , & testcases ) ; for ( i = 0 ; i < testcases ; i ++ ) { scanf ( "%d %d %d %d" , & L , & t , & N , & C ) ; float totaltime = 0 ; int dists [ C ] ; int distssort [ C ] ; int specialdist ; float distcounts [ C ] ; int specialdistsave ; for ( j = 0 ; j < C ; j ++ ) { scanf ( "%d" , & dists [ j ] ) ; distssort [ j ] = dists [ j ] ; distcounts [ j ] = 0 ; } insertsort ( distssort , C ) ; for ( j = 0 ; j < N ; j ++ ) { if ( ( ( totaltime + ( dists [ j % C ] * 2 ) ) > t ) && ( totaltime < t ) ) { specialdist = ( totaltime + ( dists [ j % C ] * 2 ) - t ) ; totaltime += dists [ j % C ] * 2 ; } else if ( totaltime < t ) { totaltime += dists [ j % C ] * 2 ; } else { totaltime += dists [ j % C ] * 2 ; distcounts [ j % C ] ++ ; } } int l = 1 ; int max = 0 ; specialdistsave = specialdist ; while ( L > 0 ) { if ( l > C ) { break ; } max = distssort [ C - l ] ; if ( specialdist > max ) { specialdistsave = specialdist / 2 ; specialdist = 0 ; L = L - 1 ; continue ; } l ++ ; int m = 0 ; while ( dists [ m ] != max ) { m ++ ; } if ( L < distcounts [ m ] ) { distcounts [ m ] = ( float ) ( distcounts [ m ] - ( float ) L / 2 ) ; L = 0 ; } else { L = L - distcounts [ m ] ; distcounts [ m ] = distcounts [ m ] / 2 ; } } totaltime = t ; for ( j = 0 ; j < C ; j ++ ) { totaltime += ( distcounts [ j ] * dists [ j ] ) * 2 ; } totaltime += specialdistsave ; printf ( "Case #%d: %.0f\n" , i + 1 , totaltime ) ; } return 0 ; }
>>>Func
METHOD gcd
METHOD_RETURN int
PARAM int a
PARAM int b
<operator>.equals b == 0
RETURN return a ; return a ;
IDENTIFIER a return a ;
RETURN return gcd ( b , a % b ) ; return gcd ( b , a % b ) ;
gcd gcd ( b , a % b )
<operator>.modulo a % b
>>>PDG&10 0->2 0->3 0->4 0->6 0->8 0->9 2->1 2->6 2->9 3->4 4->1 4->1 4->5 4->7 4->8 4->9 4->9 5->1 6->5 7->1 8->7 9->8 9->8
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } else { return gcd ( b , a % b ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
GETINT GETINT ( T )
GETBR GETBR ( )
RETURN return 0 ; return 0 ;
<operator>.lessThan dd < T
<operator>.postIncrement dd ++
LITERAL 0 return 0 ;
<operator>.assignment dd = 0
GETINT GETINT ( C )
GETBR GETBR ( )
GETINT GETINT ( D )
GETBR GETBR ( )
GETINT GETINT ( N )
GETBR GETBR ( )
GETLINE GETLINE ( elem )
<operator>.assignment r = 0
<operator>.assignment res [ r ++ ] = elem [ 0 ]
<operator>.assignment res [ r ] = '\0'
fprintf fprintf ( stdout , "\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x5b\x0" , dd + 1 )
fprintf fprintf ( stdout , "]\n" )
<operator>.lessThan j < C
<operator>.postIncrement j ++
<operator>.lessThan j < D
<operator>.postIncrement j ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < r
<operator>.postIncrement i ++
<operator>.assignment j = 0
GETLINE GETLINE ( tmp )
<operator>.assignment listC [ j ] = convert ( tmp [ 0 ] ) | convert ( tmp [ 1 ] )
<operator>.assignment nonBase [ j ] = tmp [ 2 ]
<operator>.assignment j = 0
GETLINE GETLINE ( tmp )
<operator>.assignment listD [ j ] = convert ( tmp [ 0 ] ) | convert ( tmp [ 1 ] )
<operator>.assignment i = 1
<operator>.assignment res [ r ++ ] = elem [ i ]
<operator>.assignment s = convert ( res [ r - 1 ] )
<operator>.assignment e = convert ( res [ r - 2 ] )
<operator>.addition dd + 1
<operator>.assignment i = 0
fprintf fprintf ( stdout , "%c" , res [ i ] )
<operator>.postIncrement r ++
cando cando ( listC , C , e | s , & t )
<operator>.notEquals i != 0
<operator>.or convert ( tmp [ 0 ] ) | convert ( tmp [ 1 ] )
<operator>.or convert ( tmp [ 0 ] ) | convert ( tmp [ 1 ] )
convert convert ( res [ r - 1 ] )
convert convert ( res [ r - 2 ] )
<operator>.assignmentMinus r -= 2
<operator>.assignment res [ r ++ ] = nonBase [ t ]
fprintf fprintf ( stdout , ", " )
convert convert ( tmp [ 0 ] )
convert convert ( tmp [ 1 ] )
convert convert ( tmp [ 0 ] )
convert convert ( tmp [ 1 ] )
<operator>.postIncrement r ++
<operator>.or e | s
<operator>.assignment s = convert ( res [ r - 1 ] )
<operator>.subtraction r - 1
<operator>.subtraction r - 2
<operator>.lessThan j < r
<operator>.postIncrement j ++
<operator>.postIncrement r ++
convert convert ( res [ r - 1 ] )
<operator>.assignment j = 0
<operator>.assignment e = convert ( res [ j ] )
cando cando ( listD , D , e | s , 0 )
<operator>.subtraction r - 1
convert convert ( res [ j ] )
<operator>.assignment r = 0
<operator>.or e | s
<operator>.indirectIndexAccess res [ r ++ ]
<operator>.indirectIndexAccess elem [ 0 ]
<operator>.indirectIndexAccess res [ r ]
<operator>.indirectIndexAccess listC [ j ]
<operator>.indirectIndexAccess nonBase [ j ]
<operator>.indirectIndexAccess tmp [ 2 ]
<operator>.indirectIndexAccess listD [ j ]
<operator>.indirectIndexAccess res [ r ++ ]
<operator>.indirectIndexAccess elem [ i ]
<operator>.indirectIndexAccess res [ i ]
<operator>.indirectIndexAccess res [ r - 1 ]
<operator>.indirectIndexAccess res [ r - 2 ]
<operator>.addressOf & t
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess res [ r ++ ]
<operator>.indirectIndexAccess nonBase [ t ]
<operator>.indirectIndexAccess res [ r - 1 ]
<operator>.indirectIndexAccess res [ j ]
>>>PDG&95 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->34 0->35 0->37 0->41 0->42 0->43 0->44 0->45 0->46 0->51 0->53 0->58 0->59 0->61 0->62 0->63 0->64 0->65 0->67 0->69 0->70 0->72 0->73 2->1 3->1 3->6 4->1 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->20 6->20 6->21 6->22 6->24 6->26 6->28 6->30 6->34 6->37 6->41 6->41 6->42 6->44 6->74 6->75 6->76 7->1 7->6 8->5 9->1 9->6 10->1 10->22 12->1 12->24 14->1 14->26 15->1 16->1 16->1 16->18 16->38 17->1 17->44 18->1 18->1 18->1 19->1 19->1 20->1 20->1 20->21 20->43 20->53 21->1 21->1 21->20 22->1 22->1 22->10 22->22 22->23 22->23 22->31 22->32 22->33 22->45 22->47 22->54 22->55 22->77 22->78 22->79 22->87 22->88 23->1 23->22 24->1 24->1 24->1 24->12 24->24 24->25 24->25 24->35 24->36 24->48 24->56 24->57 24->69 24->80 24->89 24->90 25->1 25->24 26->1 26->1 26->14 26->26 26->27 26->27 26->38 26->39 26->40 26->45 26->49 26->50 26->58 26->59 26->61 26->62 26->81 26->82 26->84 26->85 26->86 27->1 27->26 28->1 28->1 28->1 28->28 28->29 28->43 28->46 28->46 28->83 29->1 29->28 30->22 31->1 31->1 31->33 31->35 31->54 31->55 32->1 32->1 32->1 32->45 33->1 33->1 33->1 34->1 34->24 35->1 35->1 35->31 35->56 35->57 36->1 36->1 36->1 36->69 37->1 37->26 38->1 38->1 38->1 39->1 39->1 39->59 40->1 40->1 40->59 42->1 42->28 43->1 43->1 43->21 43->53 44->28 44->58 45->1 45->1 45->1 45->1 45->1 45->10 45->51 45->52 45->60 45->63 45->65 45->66 45->67 45->70 45->91 45->92 45->93 46->1 46->29 46->53 47->1 47->1 47->32 47->32 48->1 48->1 48->36 48->36 49->1 49->39 49->66 50->1 50->40 51->1 51->65 52->1 52->1 52->1 53->1 53->43 54->1 54->31 54->35 54->47 54->56 55->1 55->31 55->35 55->47 55->57 56->1 56->31 56->35 56->48 56->54 57->1 57->31 57->35 57->48 57->55 58->61 59->1 59->1 59->45 59->45 60->1 60->1 60->1 60->73 61->62 62->51 62->70 63->1 63->1 63->28 63->58 63->64 63->68 63->69 63->71 63->73 63->94 64->1 64->63 65->28 65->58 66->1 66->49 66->60 67->1 67->63 68->1 68->1 68->73 69->1 69->1 69->1 69->1 69->12 69->63 69->64 69->72 70->63 71->1 71->68 72->1 72->28 72->58 73->1 73->1 73->69 73->69
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( void ) { int T ; char nonBase [ 36 ] ; char tmp [ 4 ] ; int listC [ 36 ] ; int listD [ 28 ] ; char elem [ 100 ] ; char res [ 100 ] ; int r ; int C ; int D ; int N ; int i ; int j ; int dd ; int t ; int s ; int e ; GETINT ( T ) ; GETBR ( ) ; for ( dd = 0 ; dd < T ; dd ++ ) { GETINT ( C ) ; GETBR ( ) ; for ( j = 0 ; j < C ; j ++ ) { GETLINE ( tmp ) ; listC [ j ] = convert ( tmp [ 0 ] ) | convert ( tmp [ 1 ] ) ; nonBase [ j ] = tmp [ 2 ] ; } GETINT ( D ) ; GETBR ( ) ; for ( j = 0 ; j < D ; j ++ ) { GETLINE ( tmp ) ; listD [ j ] = convert ( tmp [ 0 ] ) | convert ( tmp [ 1 ] ) ; } GETINT ( N ) ; GETBR ( ) ; GETLINE ( elem ) ; r = 0 ; res [ r ++ ] = elem [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { res [ r ++ ] = elem [ i ] ; s = convert ( res [ r - 1 ] ) ; e = convert ( res [ r - 2 ] ) ; if ( cando ( listC , C , e | s , & t ) ) { r -= 2 ; res [ r ++ ] = nonBase [ t ] ; } else { s = convert ( res [ r - 1 ] ) ; for ( j = 0 ; j < r ; j ++ ) { e = convert ( res [ j ] ) ; if ( cando ( listD , D , e | s , 0 ) ) { r = 0 ; break ; } } } } res [ r ] = '\0' ; fprintf ( stdout , "\x43\x61\x73\x65\x20\x23\x25\x64\x3a\x20\x5b\x0" , dd + 1 ) ; for ( i = 0 ; i < r ; i ++ ) { if ( i != 0 ) fprintf ( stdout , ", " ) ; fprintf ( stdout , "%c" , res [ i ] ) ; } fprintf ( stdout , "]\n" ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
fgets fgets ( lBuf   sizeof ( lBuf ) , stdin )
<operator>.assignment T = atoi ( lBuf )
<operator>.lessThan i < T
<operator>.postIncrement i ++
atoi atoi ( lBuf )
<operator>.assignment i = 0
<operator>.assignment * p = lBuf
fgets fgets ( lBuf   sizeof ( lBuf ) , stdin )
<operator>.assignment p = strtok ( p , "\x20\x0" )
<operator>.assignment Cn = atoi ( p )
<operator>.assignment p = strtok ( NULL , " " )
<operator>.assignment Dn = atoi ( p )
<operator>.assignment p = strtok ( NULL , " " )
<operator>.assignment Nn = atoi ( p )
<operator>.assignment p = strtok ( NULL , " " )
<operator>.assignment l = 0
printf printf ( "Case #%d: [" , i + 1 )
printf printf ( "]\n" )
<operator>.lessThan j < Cn
<operator>.postIncrement j ++
<operator>.lessThan j < Dn
<operator>.postIncrement j ++
<operator>.lessThan j < Nn
<operator>.postIncrement j ++
<operator>.lessThan k < l
<operator>.postIncrement k ++
strtok strtok ( p , "\x20\x0" )
atoi atoi ( p )
<operator>.assignment j = 0
<operator>.assignment p = strtok ( NULL , " " )
<operator>.assignment C [ j * 3 ] = p [ 0 ]
<operator>.assignment C [ j * 3 + 1 ] = p [ 1 ]
<operator>.assignment C [ j * 3 + 2 ] = p [ 2 ]
strtok strtok ( NULL , " " )
atoi atoi ( p )
<operator>.assignment j = 0
<operator>.assignment p = strtok ( NULL , " " )
<operator>.assignment D [ j * 2 ] = p [ 0 ]
<operator>.assignment D [ j * 2 + 1 ] = p [ 1 ]
strtok strtok ( NULL , " " )
atoi atoi ( p )
strtok strtok ( NULL , " " )
<operator>.assignment j = 0
<operator>.assignment N [ l ++ ] = p [ j ]
<operator>.addition i + 1
<operator>.assignment k = 0
<operator>.greaterThan l > 1
<operator>.equals k == l - 1
strtok strtok ( NULL , " " )
strtok strtok ( NULL , " " )
printf printf ( "%c" , N [ k ] )
<operator>.multiplication j * 3
<operator>.addition j * 3 + 1
<operator>.addition j * 3 + 2
<operator>.multiplication j * 2
<operator>.addition j * 2 + 1
<operator>.postIncrement l ++
<operator>.lessThan k < Cn
<operator>.postIncrement k ++
<operator>.logicalAnd k < Dn && l > 1
<operator>.postIncrement k ++
<operator>.subtraction l - 1
printf printf ( "%c, " , N [ k ] )
<operator>.multiplication j * 3
<operator>.multiplication j * 3
<operator>.multiplication j * 2
<operator>.assignment k = 0
<operator>.assignment k = 0
<operator>.assignment f1 = 0
<operator>.assignment f2 = 0
<operator>.lessThan m < l - 1
<operator>.postIncrement m ++
<operator>.lessThan k < Dn
<operator>.greaterThan l > 1
<operator>.lessThan m < l
<operator>.postIncrement m ++
<operator>.assignment m = 0
<operator>.assignment m = 0
<operator>.subtraction l - 1
<operator>.logicalOr ( N [ m ] == C [ k * 3 ] && N [ m + 1 ] == C [ k * 3 + 1 ] ) || ( N [ m ] == C [ k * 3 + 1 ] && N [ m + 1 ] == C [ k * 3 ] )
<operator>.equals N [ m ] == D [ k * 2 ]
<operator>.logicalAnd f1 && f2
<operator>.assignment N [ m ] = C [ k * 3 + 2 ]
<operator>.postDecrement l --
memmove memmove ( & N [ m + 1 ] , & N [ m + 2 ] , l - m - 1 )
<operator>.assignment f1 = 1
<operator>.assignment l = 0
<operator>.logicalAnd N [ m ] == C [ k * 3 ] && N [ m + 1 ] == C [ k * 3 + 1 ]
<operator>.logicalAnd N [ m ] == C [ k * 3 + 1 ] && N [ m + 1 ] == C [ k * 3 ]
<operator>.equals N [ m ] == C [ k * 3 ]
<operator>.equals N [ m + 1 ] == C [ k * 3 + 1 ]
<operator>.equals N [ m ] == C [ k * 3 + 1 ]
<operator>.equals N [ m + 1 ] == C [ k * 3 ]
<operator>.subtraction l - m - 1
<operator>.multiplication k * 2
<operator>.equals N [ m ] == D [ k * 2 + 1 ]
<operator>.addition k * 3 + 2
<operator>.subtraction l - m
<operator>.assignment f2 = 2
<operator>.multiplication k * 3
<operator>.addition m + 1
<operator>.addition k * 3 + 1
<operator>.addition k * 3 + 1
<operator>.addition m + 1
<operator>.multiplication k * 3
<operator>.multiplication k * 3
<operator>.addition m + 1
<operator>.addition m + 2
<operator>.multiplication k * 3
<operator>.multiplication k * 3
<operator>.addition k * 2 + 1
<operator>.multiplication k * 2
<operator>.sizeOf sizeof ( lBuf )
<operator>.indirectIndexAccess C [ j * 3 ]
<operator>.indirectIndexAccess p [ 0 ]
<operator>.indirectIndexAccess C [ j * 3 + 1 ]
<operator>.indirectIndexAccess p [ 1 ]
<operator>.indirectIndexAccess C [ j * 3 + 2 ]
<operator>.indirectIndexAccess p [ 2 ]
<operator>.indirectIndexAccess D [ j * 2 ]
<operator>.indirectIndexAccess p [ 0 ]
<operator>.indirectIndexAccess D [ j * 2 + 1 ]
<operator>.indirectIndexAccess p [ 1 ]
<operator>.indirectIndexAccess N [ l ++ ]
<operator>.indirectIndexAccess p [ j ]
<operator>.indirectIndexAccess N [ k ]
<operator>.indirectIndexAccess N [ k ]
<operator>.indirectIndexAccess N [ m ]
<operator>.indirectIndexAccess D [ k * 2 ]
<operator>.indirectIndexAccess N [ m ]
<operator>.indirectIndexAccess C [ k * 3 + 2 ]
<operator>.addressOf & N [ m + 1 ]
<operator>.addressOf & N [ m + 2 ]
<operator>.indirectIndexAccess N [ m ]
<operator>.indirectIndexAccess C [ k * 3 ]
<operator>.indirectIndexAccess N [ m + 1 ]
<operator>.indirectIndexAccess C [ k * 3 + 1 ]
<operator>.indirectIndexAccess N [ m ]
<operator>.indirectIndexAccess C [ k * 3 + 1 ]
<operator>.indirectIndexAccess N [ m + 1 ]
<operator>.indirectIndexAccess C [ k * 3 ]
<operator>.indirectIndexAccess N [ m + 1 ]
<operator>.indirectIndexAccess N [ m + 2 ]
<operator>.indirectIndexAccess N [ m ]
<operator>.indirectIndexAccess D [ k * 2 + 1 ]
>>>PDG&148 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->36 0->37 0->38 0->42 0->43 0->44 0->45 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->84 0->86 0->88 0->89 0->96 0->97 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->114 2->1 3->1 3->1 3->7 3->10 4->1 4->1 4->5 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->17 5->18 5->19 5->19 5->20 5->21 5->23 5->25 5->27 5->29 5->30 5->31 5->36 5->37 5->38 5->42 5->43 5->44 5->45 5->47 5->47 5->48 5->115 6->1 6->5 7->1 7->4 7->9 8->1 8->5 9->29 10->9 11->30 12->21 13->37 14->23 15->43 16->25 17->29 17->30 17->37 17->43 17->46 18->27 18->59 21->21 21->22 21->32 21->33 21->34 21->35 21->51 21->54 21->54 21->55 21->56 21->60 21->66 21->67 21->116 21->117 21->118 21->119 21->120 21->121 22->21 23->23 23->24 23->39 23->40 23->41 23->52 23->57 23->57 23->58 23->68 23->75 23->122 23->123 23->124 23->125 24->23 25->25 25->26 25->26 25->46 25->49 25->59 25->126 25->127 26->25 27->27 27->28 27->50 27->50 27->64 27->64 28->27 29->11 29->11 30->12 31->21 32->29 32->30 32->33 32->34 32->35 32->37 32->40 32->41 32->43 36->13 36->13 36->42 36->52 37->14 38->23 39->29 39->30 39->37 39->40 39->41 39->43 42->15 42->15 42->44 43->16 44->17 44->17 44->36 44->51 45->25 48->27 49->27 49->59 49->60 49->62 49->62 49->69 49->70 49->75 49->76 49->77 49->81 50->28 50->53 50->65 50->128 50->129 51->32 51->32 51->36 52->39 52->39 52->42 53->65 54->66 57->68 59->49 60->60 60->61 60->61 60->73 60->79 60->81 60->102 61->60 62->62 62->63 62->71 62->72 62->75 62->77 62->80 63->75 64->27 64->50 64->50 65->53 66->55 66->55 66->67 67->22 67->56 67->56 68->24 68->58 68->58 69->60 70->75 71->84 72->84 73->73 73->74 73->74 73->81 73->82 73->90 73->92 73->100 73->102 73->103 73->106 73->109 73->110 73->136 73->137 74->73 75->62 75->62 75->63 75->76 75->97 76->27 76->59 76->62 76->62 76->77 77->27 77->59 77->76 77->77 77->78 77->78 77->83 77->84 77->97 77->130 77->131 78->77 79->73 80->77 81->27 81->59 81->73 81->73 81->76 81->77 81->86 82->85 82->86 82->87 82->96 82->99 82->100 82->108 82->109 82->110 82->132 82->133 82->134 82->135 82->144 82->145 83->88 83->92 83->98 83->98 83->113 83->114 83->146 83->147 84->89 85->83 85->92 86->100 87->93 87->95 88->84 89->77 90->82 90->82 90->91 90->94 90->105 90->112 90->140 90->141 91->82 91->82 92->83 92->90 92->90 92->93 92->94 92->95 92->103 92->104 92->111 92->138 92->139 93->87 93->90 93->90 93->94 93->95 94->83 94->91 94->91 94->92 94->93 94->95 94->106 94->107 94->142 94->143 95->87 95->91 95->91 95->92 95->93 96->87 96->87 97->63 97->114 98->83 98->92 98->101 100->74 100->81 100->96 100->96 101->84 102->61 102->108 102->111 102->112 107->61 107->102 107->108 108->61 108->99 108->99 108->102 111->61 111->102 111->104 111->104 111->108 111->112 112->61 112->102 112->105 112->105 112->107 112->108 114->63 114->97 114->113 114->113
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( void ) { int T ; int i , j , k , m ; int l ; int Cn , Dn , Nn ; int lPos , rPos ; fgets ( lBuf , sizeof ( lBuf ) , stdin ) ; T = atoi ( lBuf ) ; for ( i = 0 ; i < T ; i ++ ) { char * p = lBuf ; fgets ( lBuf , sizeof ( lBuf ) , stdin ) ; p = strtok ( p , "\x20\x0" ) ; Cn = atoi ( p ) ; for ( j = 0 ; j < Cn ; j ++ ) { p = strtok ( NULL , " " ) ; C [ j * 3 ] = p [ 0 ] ; C [ j * 3 + 1 ] = p [ 1 ] ; C [ j * 3 + 2 ] = p [ 2 ] ; } p = strtok ( NULL , " " ) ; Dn = atoi ( p ) ; for ( j = 0 ; j < Dn ; j ++ ) { p = strtok ( NULL , " " ) ; D [ j * 2 ] = p [ 0 ] ; D [ j * 2 + 1 ] = p [ 1 ] ; } p = strtok ( NULL , " " ) ; Nn = atoi ( p ) ; p = strtok ( NULL , " " ) ; l = 0 ; for ( j = 0 ; j < Nn ; j ++ ) { N [ l ++ ] = p [ j ] ; if ( l > 1 ) { for ( k = 0 ; k < Cn ; k ++ ) { for ( m = 0 ; m < l - 1 ; m ++ ) { if ( ( N [ m ] == C [ k * 3 ] && N [ m + 1 ] == C [ k * 3 + 1 ] ) || ( N [ m ] == C [ k * 3 + 1 ] && N [ m + 1 ] == C [ k * 3 ] ) ) { N [ m ] = C [ k * 3 + 2 ] ; l -- ; memmove ( & N [ m + 1 ] , & N [ m + 2 ] , l - m - 1 ) ; } } } for ( k = 0 ; k < Dn && l > 1 ; k ++ ) { int f1 = 0 ; int f2 = 0 ; for ( m = 0 ; m < l ; m ++ ) { if ( N [ m ] == D [ k * 2 ] ) { f1 = 1 ; } else if ( N [ m ] == D [ k * 2 + 1 ] ) { f2 = 2 ; } if ( f1 && f2 ) { l = 0 ; } } } } } printf ( "Case #%d: [" , i + 1 ) ; for ( k = 0 ; k < l ; k ++ ) { if ( k == l - 1 ) { printf ( "%c" , N [ k ] ) ; } else { printf ( "%c, " , N [ k ] ) ; } } printf ( "]\n" ) ; } }
>>>Func
METHOD stackmanipulate
METHOD_RETURN void
PARAM char ch
<operator>.assignment flag = 0
<operator>.equals top == - 1
<operator>.assignment stack [ ++ top ] = ch
<operator>.minus - 1
<operator>.notEquals table [ ch - 65 ] [ stack [ top ] - 65 ] != '\0'
<operator>.equals flag == 0
<operator>.preIncrement ++ top
<operator>.postDecrement top --
stackmanipulate stackmanipulate ( table [ stack [ top + 1 ] - 65 ] [ ch - 65 ] )
<operator>.assignment flag = 1
<operator>.assignment stack [ ++ top ] = ch
<operator>.subtraction stack [ top ] - 65
<operator>.greaterThan dangerous [ ch - 65 ] > 0
<operator>.subtraction ch - 65
<operator>.subtraction ch - 65
<operator>.preIncrement ++ top
<operator>.subtraction stack [ top + 1 ] - 65
<operator>.lessEqualsThan j <= top
<operator>.postIncrement j ++
<operator>.subtraction ch - 65
<operator>.assignment j = 0
<operator>.addition top + 1
<operator>.lessThan i < dangerous [ ch - 65 ]
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.equals stack [ j ] == reducecouples [ ch - 65 ] [ i ]
<operator>.assignment top = - 1
<operator>.assignment flag = 1
<operator>.subtraction ch - 65
<operator>.minus - 1
<operator>.subtraction ch - 65
<operator>.indirectIndexAccess stack [ ++ top ]
<operator>.indirectIndexAccess table [ ch - 65 ] [ stack [ top ] - 65 ]
<operator>.indirectIndexAccess table [ ch - 65 ]
<operator>.indirectIndexAccess table [ stack [ top + 1 ] - 65 ] [ ch - 65 ]
<operator>.indirectIndexAccess stack [ ++ top ]
<operator>.indirectIndexAccess stack [ top ]
<operator>.indirectIndexAccess table [ stack [ top + 1 ] - 65 ]
<operator>.indirectIndexAccess dangerous [ ch - 65 ]
<operator>.indirectIndexAccess stack [ top + 1 ]
<operator>.indirectIndexAccess dangerous [ ch - 65 ]
<operator>.indirectIndexAccess stack [ j ]
<operator>.indirectIndexAccess reducecouples [ ch - 65 ] [ i ]
<operator>.indirectIndexAccess reducecouples [ ch - 65 ]
>>>PDG&47 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->30 0->31 0->32 0->33 2->5 2->16 3->1 3->1 3->8 4->1 4->1 4->5 4->7 4->8 4->9 4->9 4->10 4->14 4->16 4->18 4->20 4->34 4->35 4->36 4->39 5->1 5->1 5->1 6->4 7->10 7->11 7->12 7->15 7->17 7->19 7->22 7->24 7->37 7->40 7->41 7->42 8->13 8->18 8->38 9->1 10->18 10->24 12->8 15->20 15->23 15->25 16->17 16->22 17->13 20->18 20->20 20->21 20->21 20->25 20->27 20->31 20->43 21->20 22->13 22->31 23->20 25->26 25->28 25->33 25->44 25->45 25->46 26->25 27->25 28->25 28->26 28->29 28->30 28->31 28->32 28->43 29->20 30->8 31->13 31->33 32->29 33->13 33->31
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void stackmanipulate ( char ch ) { int j , i , flag = 0 ; if ( top == - 1 ) stack [ ++ top ] = ch ; else { if ( table [ ch - 65 ] [ stack [ top ] - 65 ] != '\0' ) { top -- ; stackmanipulate ( table [ stack [ top + 1 ] - 65 ] [ ch - 65 ] ) ; flag = 1 ; } else if ( dangerous [ ch - 65 ] > 0 ) { for ( j = 0 ; j <= top ; j ++ ) { for ( i = 0 ; i < dangerous [ ch - 65 ] ; i ++ ) if ( stack [ j ] == reducecouples [ ch - 65 ] [ i ] ) { top = - 1 ; flag = 1 ; break ; } } } if ( flag == 0 ) { stack [ ++ top ] = ch ; } } }
>>>Func
METHOD cmp_atime
METHOD_RETURN int
PARAM struct fileinfo const * a
PARAM struct fileinfo const * b
PARAM int ( * cmp ) ( char const * , char const * )
<operator>.assignment diff = timespec_cmp ( get_stat_atime ( & b -> stat )   get_stat_atime ( & a -> stat ) )
RETURN return diff ? diff : cmp ( a -> name , b -> name ) ; return diff ? diff : cmp ( a -> name , b -> name ) ;
<operator>.conditional diff ? diff : cmp ( a -> name , b -> name )
timespec_cmp timespec_cmp ( get_stat_atime ( & b -> stat )   get_stat_atime ( & a -> stat ) )
get_stat_atime get_stat_atime ( & b -> stat )
get_stat_atime get_stat_atime ( & a -> stat )
cmp cmp ( a -> name , b -> name )
>>>PDG&12 0->2 0->3 0->4 0->7 2->1 3->1 4->1 5->1 5->1 5->7 6->1 7->1 7->1 7->1 7->6 8->1 8->1 8->5 8->5 9->1 9->8 10->1 10->8 11->1 11->1 11->7 11->7
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static int cmp_atime ( struct fileinfo const * a , struct fileinfo const * b , int ( * cmp ) ( char const * , char const * ) ) { int diff = timespec_cmp ( get_stat_atime ( & b -> stat ) , get_stat_atime ( & a -> stat ) ) ; return diff ? diff : cmp ( a -> name , b -> name ) ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
printf printf ( "Case #%d: " , i + 1 )
solveCase solveCase ( )
<operator>.addition i + 1
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->8 4->9 4->10 4->10 5->1 5->4 6->3 7->1 7->4 8->1 8->1 9->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T , i ; scanf ( "\x25\x64\x0" , & T ) ; for ( i = 0 ; i < T ; i ++ ) { printf ( "Case #%d: " , i + 1 ) ; solveCase ( ) ; } return 0 ; }
>>>Func
METHOD test_3d_classes
METHOD_RETURN void
PARAM double * const * data
PARAM int N
<operator>.assignment R = 0.1
<operator>.assignment num_classes = 4
<operator>.assignment centres [ ] [ 3 ] = { { .5   .5   .5 }   { .5   - .5   - .5 }   { - .5   .5   .5 }   { - .5   - .5 - .5 } }
IDENTIFIER ndif <empty>
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.arrayInitializer { { .5   .5   .5 }   { .5   - .5   - .5 }   { - .5   .5   .5 }   { - .5   - .5 - .5 } }
<operator>.arrayInitializer { .5   .5   .5 }
<operator>.arrayInitializer { .5   - .5   - .5 }
<operator>.arrayInitializer { - .5   .5   .5 }
<operator>.arrayInitializer { - .5   - .5 - .5 }
<operator>.minus - .5
<operator>.minus - .5
<operator>.minus - .5
<operator>.minus - .5
<operator>.subtraction - .5 - .5
<operator>.minus - .5
>>>PDG&21 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 2->1 3->8 4->1 4->1 5->1 5->1 6->1 6->1 6->1 8->1 8->1 8->9 9->1 9->1 10->1 10->1 10->1 10->1 10->6 10->6 10->6 10->6 11->10 12->10 12->10 13->10 13->10 14->1 14->1 14->10 14->10 15->12 16->12 17->13 18->14 19->14 19->14 20->19
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void test_3d_classes ( double * const * data , int N ) { const double R = 0.1 ; int i ; const int num_classes = 4 ; const double centres [ ] [ 3 ] = { { .5 , .5 , .5 } , { .5 , - .5 , - .5 } , { - .5 , .5 , .5 } , { - .5 , - .5 - .5 } } ; def _OPENMP ndif for ( i <missing ')'> = 0 ; i < N ; i ++ ) { int class = rand ( ) % num_classes ; data [ i ] [ 0 ] = _random ( centres [ class ] [ 0 ] - R , centres [ class ] [ 0 ] + R ) ; data [ i ] [ 1 ] = _random ( centres [ class ] [ 1 ] - R , centres [ class ] [ 1 ] + R ) ; data [ i ] [ 2 ] = _random ( centres [ class ] [ 2 ] - R , centres [ class ] [ 2 ] + R ) ; } }
>>>Func
METHOD absld
METHOD_RETURN long double
PARAM long double val
RETURN return val < 0 ? - val : val ; return val < 0 ? - val : val ;
<operator>.conditional val < 0 ? - val : val
<operator>.lessThan val < 0
<operator>.minus - val
>>>PDG&7 0->2 0->4 0->5 0->6 2->5 3->1 4->1 4->1 4->1 4->1 4->3 5->4 5->6 5->6 6->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static inline long double absld ( long double val ) { return val < 0 ? - val : val ; }
>>>Func
METHOD init_opposed
METHOD_RETURN void
PARAM int len
PARAM char s [ ] [ 4 ]
<operator>.lessThan i < len
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment elem [ IDX ( s [ i ] [ 0 ] ) ] . opposed_elem = IDX ( s [ i ] [ 1 ] )
<operator>.assignment elem [ IDX ( s [ i ] [ 1 ] ) ] . opposed_elem = IDX ( s [ i ] [ 0 ] )
IDX IDX ( s [ i ] [ 1 ] )
IDX IDX ( s [ i ] [ 0 ] )
IDX IDX ( s [ i ] [ 0 ] )
IDX IDX ( s [ i ] [ 1 ] )
<operator>.fieldAccess elem [ IDX ( s [ i ] [ 0 ] ) ] . opposed_elem
<operator>.fieldAccess elem [ IDX ( s [ i ] [ 1 ] ) ] . opposed_elem
<operator>.indirectIndexAccess elem [ IDX ( s [ i ] [ 0 ] ) ]
FIELD_IDENTIFIER opposed_elem opposed_elem
<operator>.indirectIndexAccess s [ i ] [ 1 ]
<operator>.indirectIndexAccess elem [ IDX ( s [ i ] [ 1 ] ) ]
FIELD_IDENTIFIER opposed_elem opposed_elem
<operator>.indirectIndexAccess s [ i ] [ 0 ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i ] [ 0 ]
<operator>.indirectIndexAccess s [ i ] [ 1 ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i ]
>>>PDG&27 0->2 0->3 0->4 0->5 0->6 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->7 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->18 4->19 4->20 4->21 4->22 4->23 4->24 4->25 4->26 5->1 5->4 6->1 6->4 9->7 9->12 10->8 10->11 11->10 12->9
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void init_opposed ( int len , char s [ ] [ 4 ] ) { int i ; for ( i = 0 ; i < len ; i ++ ) { elem [ IDX ( s [ i ] [ 0 ] ) ] . opposed_elem = IDX ( s [ i ] [ 1 ] ) ; elem [ IDX ( s [ i ] [ 1 ] ) ] . opposed_elem = IDX ( s [ i ] [ 0 ] ) ; } }
>>>Func
METHOD oSerach
METHOD_RETURN int
PARAM char * eList
PARAM char * newElement
PARAM struct opposed * oList
PARAM int D
RETURN return 0 ; return 0 ;
<operator>.notEquals eList [ i ] != '\0'
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.lessThan j < D
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.logicalOr ( eList [ i ] == oList [ j ] . a && * newElement == oList [ j ] . b ) || ( eList [ i ] == oList [ j ] . b && * newElement == oList [ j ] . a )
RETURN return 1 ; return 1 ;
<operator>.logicalAnd eList [ i ] == oList [ j ] . a && * newElement == oList [ j ] . b
<operator>.logicalAnd eList [ i ] == oList [ j ] . b && * newElement == oList [ j ] . a
LITERAL 1 return 1 ;
<operator>.equals eList [ i ] == oList [ j ] . a
<operator>.equals * newElement == oList [ j ] . b
<operator>.equals eList [ i ] == oList [ j ] . b
<operator>.equals * newElement == oList [ j ] . a
<operator>.indirectIndexAccess eList [ i ]
<operator>.indirectIndexAccess eList [ i ]
<operator>.fieldAccess oList [ j ] . a
<operator>.indirection * newElement
<operator>.fieldAccess oList [ j ] . b
<operator>.indirectIndexAccess eList [ i ]
<operator>.fieldAccess oList [ j ] . b
<operator>.indirection * newElement
<operator>.fieldAccess oList [ j ] . a
<operator>.indirectIndexAccess oList [ j ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess oList [ j ]
FIELD_IDENTIFIER b b
<operator>.indirectIndexAccess oList [ j ]
FIELD_IDENTIFIER b b
<operator>.indirectIndexAccess oList [ j ]
FIELD_IDENTIFIER a a
>>>PDG&40 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->18 2->1 2->7 2->19 2->21 3->1 4->1 5->11 6->1 7->1 7->6 7->11 7->13 7->19 8->1 8->1 9->6 10->1 10->1 10->8 11->1 11->1 11->1 11->7 11->8 11->12 11->14 11->16 11->19 11->23 11->24 11->25 11->32 11->33 12->1 12->11 13->1 13->11 14->1 14->1 14->1 14->11 14->12 14->15 15->1 16->1 16->1 16->14 16->14 16->17 16->21 16->28 16->29 16->36 16->37 17->1 17->1 17->14 17->14 18->15 19->1 19->1 19->7 19->16 19->16 19->20 19->21 19->22 19->26 19->27 19->34 19->35 20->1 20->1 20->16 20->16 20->21 20->22 21->1 21->1 21->7 21->17 21->17 21->19 21->22 21->30 21->31 21->38 21->39 22->1 22->1 22->17 22->17 22->20
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int oSerach ( char * eList , char * newElement , struct opposed * oList , int D ) { int i , j ; for ( i = 0 ; eList [ i ] != '\0' ; i ++ ) { for ( j = 0 ; j < D ; j ++ ) { if ( ( eList [ i ] == oList [ j ] . a && * newElement == oList [ j ] . b ) || ( eList [ i ] == oList [ j ] . b && * newElement == oList [ j ] . a ) ) { return 1 ; } } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessThan cases < t
<operator>.postIncrement cases ++
LITERAL 0 return 0 ;
<operator>.assignment cases = 0
<operator>.assignment top = - 1
scanf scanf ( "%d" , & c )
scanf scanf ( "%d" , & d )
scanf scanf ( "%d" , & n )
scanf scanf ( "%c" , & sp )
<operator>.assignment res [ ++ top ] = str [ 0 ]
printf printf ( "\n" )
<operator>.notEquals c != 0
<operator>.notEquals d != 0
<operator>.lessThan i < n
<operator>.postIncrement i ++
scanf scanf ( "%c" , & str [ i ] )
<operator>.notEquals c != 0
<operator>.notEquals d != 0
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan top < 0
<operator>.minus - 1
scanf scanf ( "%c" , & sp )
scanf scanf ( "%c" , & sp )
<operator>.assignment i = 0
<operator>.assignment com1 = com [ 0 ]
<operator>.assignment com2 = com [ 1 ]
<operator>.assignment opp1 = opp [ 0 ]
<operator>.assignment opp2 = opp [ 1 ]
<operator>.assignment i = 1
<operator>.assignment res [ ++ top ] = str [ i ]
printf printf ( "Case #%d: []" , cases + 1 )
<operator>.lessThan i < 3
<operator>.postIncrement i ++
scanf scanf ( "%c" , & com [ i ] )
<operator>.lessThan i < 2
<operator>.postIncrement i ++
scanf scanf ( "%c" , & opp [ i ] )
<operator>.preIncrement ++ top
<operator>.greaterThan top > 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.addition cases + 1
<operator>.equals top == 0
<operator>.preIncrement ++ top
<operator>.notEquals c != 0
<operator>.notEquals d != 0
printf printf ( "Case #%d: [%c]" , cases + 1 , res [ 0 ] )
<operator>.assignment ind1 = - 1
<operator>.assignment ind2 = - 1
<operator>.logicalOr ( res [ top ] == com1 && res [ top - 1 ] == com2 ) || ( res [ top ] == com2 && res [ top - 1 ] == com1 )
<operator>.lessEqualsThan j <= top
<operator>.postIncrement j ++
<operator>.logicalAnd ind1 >= 0 && ind2 >= 0
<operator>.addition cases + 1
<operator>.greaterThan top > 0
<operator>.assignment res [ -- top ] = com [ 2 ]
<operator>.minus - 1
<operator>.minus - 1
<operator>.assignment j = 0
printf printf ( "Case #%d: [%c" , cases + 1 , res [ 0 ] )
printf printf ( "]" )
<operator>.logicalAnd res [ top ] == com1 && res [ top - 1 ] == com2
<operator>.logicalAnd res [ top ] == com2 && res [ top - 1 ] == com1
<operator>.logicalAnd res [ j ] == opp1 && ind1 == - 1
<operator>.greaterEqualsThan ind1 >= 0
<operator>.greaterEqualsThan ind2 >= 0
<operator>.lessThan ind1 < ind2
<operator>.lessEqualsThan i <= top
<operator>.postIncrement i ++
printf printf ( ", %c" , res [ i ] )
<operator>.equals res [ top ] == com1
<operator>.equals res [ top - 1 ] == com2
<operator>.equals res [ top ] == com2
<operator>.equals res [ top - 1 ] == com1
<operator>.assignment ind1 = j
<operator>.assignment top = - 1
<operator>.addition cases + 1
<operator>.assignment i = 1
<operator>.preDecrement -- top
<operator>.equals res [ j ] == opp1
<operator>.equals ind1 == - 1
<operator>.subtraction top - 1
<operator>.subtraction top - 1
<operator>.minus - 1
<operator>.logicalAnd res [ j ] == opp2 && ind2 == - 1
<operator>.minus - 1
<operator>.lessThan ind2 < ind1
<operator>.assignment ind2 = j
<operator>.assignment top = - 1
<operator>.equals res [ j ] == opp2
<operator>.equals ind2 == - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.addressOf & sp
<operator>.indirectIndexAccess res [ ++ top ]
<operator>.indirectIndexAccess str [ 0 ]
<operator>.addressOf & str [ i ]
<operator>.addressOf & sp
<operator>.addressOf & sp
<operator>.indirectIndexAccess str [ i ]
<operator>.indirectIndexAccess com [ 0 ]
<operator>.indirectIndexAccess com [ 1 ]
<operator>.indirectIndexAccess opp [ 0 ]
<operator>.indirectIndexAccess opp [ 1 ]
<operator>.indirectIndexAccess res [ ++ top ]
<operator>.indirectIndexAccess str [ i ]
<operator>.addressOf & com [ i ]
<operator>.addressOf & opp [ i ]
<operator>.indirectIndexAccess com [ i ]
<operator>.indirectIndexAccess opp [ i ]
<operator>.indirectIndexAccess res [ 0 ]
<operator>.indirectIndexAccess res [ -- top ]
<operator>.indirectIndexAccess com [ 2 ]
<operator>.indirectIndexAccess res [ 0 ]
<operator>.indirectIndexAccess res [ top ]
<operator>.indirectIndexAccess res [ top - 1 ]
<operator>.indirectIndexAccess res [ top ]
<operator>.indirectIndexAccess res [ top - 1 ]
<operator>.indirectIndexAccess res [ i ]
<operator>.indirectIndexAccess res [ j ]
<operator>.indirectIndexAccess res [ j ]
>>>PDG&129 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->33 0->35 0->36 0->37 0->39 0->40 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->55 0->56 0->58 0->59 0->61 0->62 0->63 0->64 0->65 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->90 0->91 0->92 0->94 0->95 0->96 0->97 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->20 4->21 4->22 4->24 4->25 4->28 4->33 4->35 4->42 4->46 4->51 4->58 4->64 4->81 4->98 4->99 4->100 4->101 4->102 4->103 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->42 9->1 9->15 9->20 9->49 10->1 10->16 10->21 10->50 11->1 11->17 11->22 12->1 12->26 12->27 13->1 13->1 13->1 14->1 15->20 15->26 15->36 15->44 15->105 16->21 16->27 16->39 16->45 16->106 17->17 17->18 17->18 17->19 17->22 17->104 17->107 18->1 18->17 19->1 19->34 20->1 20->1 20->9 20->15 20->29 20->30 20->49 20->108 20->109 21->1 21->1 21->10 21->16 21->31 21->32 21->50 21->110 21->111 22->1 22->1 22->1 22->11 22->17 22->22 22->23 22->23 22->34 22->43 22->48 22->112 22->113 23->1 23->22 24->1 24->1 24->35 24->46 24->47 24->47 25->8 26->12 26->27 27->12 28->1 28->17 29->1 29->1 29->1 29->75 30->1 30->1 30->1 30->76 30->77 31->1 31->1 31->1 31->84 32->1 32->1 32->1 32->94 33->1 33->22 34->1 34->1 34->1 35->1 35->1 36->1 36->36 36->37 36->37 36->38 36->114 36->116 37->1 37->36 38->1 39->1 39->39 39->40 39->40 39->41 39->115 39->117 40->1 40->39 41->1 42->24 42->48 43->1 43->24 43->48 43->49 43->50 43->55 43->83 43->86 43->87 44->36 45->39 47->1 47->1 47->51 47->58 47->59 47->59 47->118 48->43 49->1 49->1 49->9 49->15 49->54 49->66 49->75 49->122 50->1 50->1 50->10 50->16 50->52 50->53 50->55 50->57 50->61 50->62 50->63 50->69 51->1 51->1 51->1 51->64 52->1 52->69 52->85 53->1 53->1 53->1 53->70 53->71 53->95 54->1 54->1 54->1 54->60 54->83 54->119 54->120 55->1 55->1 55->24 55->48 55->55 55->56 55->56 55->68 55->79 55->84 55->92 55->127 56->1 56->55 57->1 57->1 57->1 57->71 59->1 59->1 59->64 59->65 59->72 59->72 59->81 59->82 59->121 60->1 60->1 60->1 61->52 62->53 63->1 63->55 64->1 64->1 64->1 64->51 65->1 66->1 66->1 66->54 66->54 66->67 66->77 66->124 67->1 67->1 67->54 67->54 68->1 68->1 68->1 68->79 68->89 68->94 68->128 69->1 69->57 69->57 69->70 69->71 70->1 70->57 70->57 70->71 71->1 71->1 71->1 71->80 71->90 71->91 71->91 71->91 72->1 72->1 72->1 72->72 72->73 72->73 72->74 72->126 73->1 73->72 74->1 74->1 75->1 75->1 75->66 75->66 75->76 75->77 75->78 75->86 75->123 76->1 76->1 76->66 76->66 76->77 76->78 77->1 77->1 77->67 77->67 77->75 77->76 77->78 77->87 77->125 78->1 78->1 78->67 78->67 78->75 78->76 79->1 79->69 79->85 80->1 80->1 80->24 80->48 82->1 82->72 83->24 83->48 83->55 84->1 84->1 84->68 84->68 84->85 84->88 84->94 85->1 85->68 85->68 85->69 86->24 86->48 86->55 86->83 86->87 87->24 87->48 87->55 87->83 88->85 89->1 89->1 89->1 89->92 90->80 91->1 91->1 91->1 91->93 91->97 92->1 92->1 92->70 92->71 92->95 93->1 93->1 93->24 93->48 94->1 94->1 94->84 94->89 94->89 94->95 94->96 95->1 95->1 95->70 95->71 95->89 95->89 96->95 97->93
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int cases , t , i , c , d , n , top , ind1 , ind2 , j ; char com [ 3 ] , opp [ 2 ] , str [ 10 ] , sp , res [ 10 ] ; char com1 , com2 , opp1 , opp2 ; scanf ( "\x25\x64\x0" , & t ) ; for ( cases = 0 ; cases < t ; cases ++ ) { top = - 1 ; scanf ( "%d" , & c ) ; if ( c != 0 ) { scanf ( "%c" , & sp ) ; for ( i = 0 ; i < 3 ; i ++ ) scanf ( "%c" , & com [ i ] ) ; } scanf ( "%d" , & d ) ; if ( d != 0 ) { scanf ( "%c" , & sp ) ; for ( i = 0 ; i < 2 ; i ++ ) scanf ( "%c" , & opp [ i ] ) ; } scanf ( "%d" , & n ) ; scanf ( "%c" , & sp ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%c" , & str [ i ] ) ; res [ ++ top ] = str [ 0 ] ; if ( c != 0 ) { com1 = com [ 0 ] ; com2 = com [ 1 ] ; } if ( d != 0 ) { opp1 = opp [ 0 ] ; opp2 = opp [ 1 ] ; } for ( i = 1 ; i < n ; i ++ ) { res [ ++ top ] = str [ i ] ; if ( top > 0 ) { if ( c != 0 ) { if ( ( res [ top ] == com1 && res [ top - 1 ] == com2 ) || ( res [ top ] == com2 && res [ top - 1 ] == com1 ) ) { res [ -- top ] = com [ 2 ] ; } } if ( d != 0 ) { ind1 = - 1 ; ind2 = - 1 ; for ( j = 0 ; j <= top ; j ++ ) { if ( res [ j ] == opp1 && ind1 == - 1 ) ind1 = j ; else if ( res [ j ] == opp2 && ind2 == - 1 ) ind2 = j ; } if ( ind1 >= 0 && ind2 >= 0 ) { if ( ind1 < ind2 ) top = - 1 ; else if ( ind2 < ind1 ) top = - 1 ; } } } } if ( top < 0 ) printf ( "Case #%d: []" , cases + 1 ) ; else if ( top == 0 ) printf ( "Case #%d: [%c]" , cases + 1 , res [ 0 ] ) ; else if ( top > 0 ) { printf ( "Case #%d: [%c" , cases + 1 , res [ 0 ] ) ; for ( i = 1 ; i <= top ; i ++ ) printf ( ", %c" , res [ i ] ) ; printf ( "]" ) ; } printf ( "\n" ) ; } return 0 ; }
>>>Func
METHOD find_opposer_list
METHOD_RETURN int
PARAM int i1
PARAM int i2
PARAM char * str
<operator>.assignment i = 0
RETURN return - 1 ; return - 1 ;
<operator>.greaterEqualsThan i >= i1
<operator>.postDecrement i --
<operator>.minus - 1
<operator>.assignment i = i2 - 1
find_opposer find_opposer ( str [ i2 ] , str [ i ] )
<operator>.subtraction i2 - 1
RETURN return i ; return i ;
IDENTIFIER i return i ;
<operator>.indirectIndexAccess str [ i2 ]
<operator>.indirectIndexAccess str [ i ]
>>>PDG&17 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->12 0->14 2->7 3->12 4->1 4->11 5->1 6->1 7->1 7->1 7->1 7->6 7->8 7->9 7->11 7->14 7->15 7->16 8->1 8->7 9->6 10->1 10->1 10->7 11->1 11->1 11->1 11->7 11->8 11->13 12->1 12->10 12->10 13->1 14->13
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int find_opposer_list ( int i1 , int i2 , char * str ) { int i = 0 ; for ( i = i2 - 1 ; i >= i1 ; i -- ) { if ( find_opposer ( str [ i2 ] , str [ i ] ) ) return i ; } return - 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment inp = fopen ( "\x2e\x2f\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e\x0" , "rb" )
<operator>.assignment out = fopen ( "./output.txt" , "w" )
<operator>.assignment testCount = 0
<operator>.assignment * inputString = NULL
fscanf fscanf ( inp , "%d" , & testCases )
RETURN return ( EXIT_SUCCESS ) ; return ( EXIT_SUCCESS ) ;
IDENTIFIER testCases while (testCases)
IDENTIFIER EXIT_SUCCESS return ( EXIT_SUCCESS ) ;
fopen fopen ( "\x2e\x2f\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e\x0" , "rb" )
fopen fopen ( "./output.txt" , "w" )
<operator>.assignment * combination = NULL
fscanf fscanf ( inp , "%d" , & C )
fgetc fgetc ( inp )
<operator>.assignment * oppose = NULL
fscanf fscanf ( inp , "%d" , & D )
fgetc fgetc ( inp )
fscanf fscanf ( inp , "%d" , & N )
fgetc fgetc ( inp )
<operator>.assignment inputString = ( char * ) calloc ( N + 1 , 1 )
fscanf fscanf ( inp , "%s" , inputString )
<operator>.assignment outIndex = 0
fprintf fprintf ( out , "Case #%d: [" , ++ testCount )
fprintf fprintf ( out , "]\n" )
<operator>.postDecrement testCases --
IDENTIFIER C if (C)
IDENTIFIER D if (D)
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < outIndex
<operator>.postIncrement i ++
IDENTIFIER combination if (combination)
IDENTIFIER oppose if (oppose)
IDENTIFIER inputString if (inputString)
<operator>.assignment combination = ( combinationList * ) calloc ( 26   sizeof ( combinationList ) )
<operator>.assignment oppose = ( opposeList * ) calloc ( 26   sizeof ( opposeList ) )
<operator>.cast ( char * ) calloc ( N + 1 , 1 )
<operator>.assignment i = 0
<operator>.assignment outString [ outIndex ] = inputString [ i ]
<operator>.postIncrement outIndex ++
<operator>.preIncrement ++ testCount
<operator>.assignment i = 0
fprintf fprintf ( out , "%c" , outString [ i ] )
free free ( combination )
free free ( oppose )
free free ( inputString )
IDENTIFIER C while (C)
IDENTIFIER D while (D)
calloc calloc ( N + 1 , 1 )
<operator>.logicalNot ! outIndex
IDENTIFIER combination if (combination)
IDENTIFIER oppose if (oppose)
<operator>.notEquals i != outIndex - 1
<operator>.cast ( combinationList * ) calloc ( 26   sizeof ( combinationList ) )
fgetc fgetc ( inp )
fscanf fscanf ( inp , "%s" , ch )
<operator>.postIncrement combination [ ch [ 0 ] - 'A' ] . noOfRows ++
<operator>.assignment combination [ ch [ 0 ] - 'A' ] . list [ combination [ ch [ 0 ] - 'A' ] . noOfRows - 1 ] [ 0 ] = ch [ 1 ] - 'A'
<operator>.assignment combination [ ch [ 0 ] - 'A' ] . list [ combination [ ch [ 0 ] - 'A' ] . noOfRows - 1 ] [ 1 ] = ch [ 2 ] - 'A'
<operator>.postIncrement combination [ ch [ 1 ] - 'A' ] . noOfRows ++
<operator>.assignment combination [ ch [ 1 ] - 'A' ] . list [ combination [ ch [ 1 ] - 'A' ] . noOfRows - 1 ] [ 0 ] = ch [ 0 ] - 'A'
<operator>.assignment combination [ ch [ 1 ] - 'A' ] . list [ combination [ ch [ 1 ] - 'A' ] . noOfRows - 1 ] [ 1 ] = ch [ 2 ] - 'A'
<operator>.postDecrement C --
<operator>.cast ( opposeList * ) calloc ( 26   sizeof ( opposeList ) )
fgetc fgetc ( inp )
fscanf fscanf ( inp , "%s" , ch )
<operator>.assignment oppose [ ch [ 0 ] - 'A' ] . enable = - 1
<operator>.assignment oppose [ ch [ 0 ] - 'A' ] . opposer = ch [ 1 ] - 'A'
<operator>.assignment oppose [ ch [ 1 ] - 'A' ] . enable = - 1
<operator>.assignment oppose [ ch [ 1 ] - 'A' ] . opposer = ch [ 0 ] - 'A'
<operator>.postDecrement D --
<operator>.addition N + 1
<operator>.postIncrement outIndex ++
fprintf fprintf ( out , ", " )
calloc calloc ( 26   sizeof ( combinationList ) )
<operator>.notEquals combination [ ch [ 0 ] - 'A' ] . enable != - 1
<operator>.notEquals combination [ ch [ 1 ] - 'A' ] . enable != - 1
calloc calloc ( 26   sizeof ( opposeList ) )
<operator>.equals combination [ outString [ outIndex ] - 'A' ] . enable == - 1
<operator>.equals oppose [ outString [ outIndex ] - 'A' ] . enable == - 1
<operator>.subtraction outIndex - 1
<operator>.sizeOf sizeof ( combinationList )
<operator>.assignment combination [ ch [ 0 ] - 'A' ] . enable = - 1
<operator>.assignment combination [ ch [ 0 ] - 'A' ] . noOfRows = 0
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.subtraction ch [ 2 ] - 'A'
<operator>.assignment combination [ ch [ 1 ] - 'A' ] . enable = - 1
<operator>.assignment combination [ ch [ 1 ] - 'A' ] . noOfRows = 0
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction ch [ 2 ] - 'A'
<operator>.sizeOf sizeof ( opposeList )
<operator>.minus - 1
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.minus - 1
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.assignment ch = oppose [ outString [ outIndex ] - 'A' ] . opposer + 'A'
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.lessThan j < combination [ outString [ outIndex ] - 'A' ] . noOfRows
<operator>.postIncrement j ++
<operator>.minus - 1
<operator>.greaterEqualsThan j >= 0
<operator>.postDecrement j --
<operator>.minus - 1
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction combination [ ch [ 0 ] - 'A' ] . noOfRows - 1
<operator>.subtraction combination [ ch [ 0 ] - 'A' ] . noOfRows - 1
<operator>.minus - 1
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.subtraction combination [ ch [ 1 ] - 'A' ] . noOfRows - 1
<operator>.subtraction combination [ ch [ 1 ] - 'A' ] . noOfRows - 1
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.assignment j = 0
<operator>.addition oppose [ outString [ outIndex ] - 'A' ] . opposer + 'A'
<operator>.assignment j = outIndex - 1
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.subtraction outString [ outIndex ] - 'A'
<operator>.equals combination [ outString [ outIndex ] - 'A' ] . list [ j ] [ 0 ] == ( outString [ outIndex - 1 ] - 'A' )
<operator>.subtraction outString [ outIndex ] - 'A'
<operator>.equals outString [ j ] == ch
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.postDecrement outIndex --
<operator>.assignment outString [ outIndex ] = combination [ outString [ outIndex ] - 'A' ] . list [ j ] [ 1 ] + 'A'
<operator>.subtraction outIndex - 1
<operator>.assignment outIndex = - 1
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction ch [ 0 ] - 'A'
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.subtraction ch [ 1 ] - 'A'
<operator>.subtraction outString [ outIndex ] - 'A'
<operator>.subtraction outString [ outIndex - 1 ] - 'A'
IDENTIFIER outIndex if (outIndex)
<operator>.subtraction outString [ outIndex ] - 'A'
<operator>.addition combination [ outString [ outIndex ] - 'A' ] . list [ j ] [ 1 ] + 'A'
<operator>.minus - 1
<operator>.subtraction outIndex - 1
<operator>.subtraction outString [ outIndex ] - 'A'
<operator>.subtraction outString [ outIndex ] - 'A'
<operator>.indirectIndexAccess outString [ outIndex ]
<operator>.indirectIndexAccess inputString [ i ]
<operator>.indirectIndexAccess outString [ i ]
<operator>.fieldAccess combination [ outString [ outIndex ] - 'A' ] . enable
<operator>.fieldAccess oppose [ outString [ outIndex ] - 'A' ] . enable
<operator>.fieldAccess combination [ ch [ 0 ] - 'A' ] . enable
<operator>.fieldAccess combination [ ch [ 0 ] - 'A' ] . noOfRows
<operator>.fieldAccess combination [ ch [ 1 ] - 'A' ] . enable
<operator>.fieldAccess combination [ ch [ 1 ] - 'A' ] . noOfRows
<operator>.indirectIndexAccess combination [ outString [ outIndex ] - 'A' ]
FIELD_IDENTIFIER enable enable
<operator>.indirectIndexAccess oppose [ outString [ outIndex ] - 'A' ]
FIELD_IDENTIFIER enable enable
<operator>.indirectIndexAccess combination [ ch [ 0 ] - 'A' ]
FIELD_IDENTIFIER enable enable
<operator>.indirectIndexAccess combination [ ch [ 0 ] - 'A' ]
FIELD_IDENTIFIER noOfRows noOfRows
<operator>.indirectIndexAccess combination [ ch [ 1 ] - 'A' ]
FIELD_IDENTIFIER enable enable
<operator>.indirectIndexAccess combination [ ch [ 1 ] - 'A' ]
FIELD_IDENTIFIER noOfRows noOfRows
<operator>.fieldAccess combination [ outString [ outIndex ] - 'A' ] . noOfRows
<operator>.fieldAccess oppose [ outString [ outIndex ] - 'A' ] . opposer
<operator>.indirectIndexAccess outString [ outIndex ]
<operator>.indirectIndexAccess combination [ outString [ outIndex ] - 'A' ]
FIELD_IDENTIFIER noOfRows noOfRows
<operator>.indirectIndexAccess outString [ outIndex ]
<operator>.indirectIndexAccess oppose [ outString [ outIndex ] - 'A' ]
FIELD_IDENTIFIER opposer opposer
<operator>.indirectIndexAccess ch [ 0 ]
<operator>.indirectIndexAccess ch [ 0 ]
<operator>.indirectIndexAccess ch [ 1 ]
<operator>.indirectIndexAccess ch [ 1 ]
<operator>.indirectIndexAccess combination [ outString [ outIndex ] - 'A' ] . list [ j ] [ 0 ]
<operator>.indirectIndexAccess outString [ j ]
<operator>.indirectIndexAccess outString [ outIndex ]
<operator>.indirectIndexAccess combination [ outString [ outIndex ] - 'A' ] . list [ j ]
<operator>.indirectIndexAccess outString [ outIndex - 1 ]
<operator>.indirectIndexAccess outString [ outIndex ]
<operator>.indirectIndexAccess outString [ outIndex ]
<operator>.fieldAccess combination [ outString [ outIndex ] - 'A' ] . list
<operator>.indirectIndexAccess combination [ outString [ outIndex ] - 'A' ] . list [ j ] [ 1 ]
<operator>.indirectIndexAccess combination [ outString [ outIndex ] - 'A' ]
FIELD_IDENTIFIER list list
<operator>.indirectIndexAccess combination [ outString [ outIndex ] - 'A' ] . list [ j ]
<operator>.fieldAccess combination [ outString [ outIndex ] - 'A' ] . list
<operator>.indirectIndexAccess outString [ outIndex ]
<operator>.indirectIndexAccess combination [ outString [ outIndex ] - 'A' ]
FIELD_IDENTIFIER list list
<operator>.indirectIndexAccess outString [ outIndex ]
>>>PDG&203 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->65 0->66 0->67 0->68 0->73 0->74 0->75 0->76 0->77 0->80 0->83 0->86 0->87 0->88 0->90 0->91 0->92 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->122 0->123 0->124 0->126 0->127 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->138 0->140 0->141 0->142 0->143 0->144 0->145 0->146 0->147 0->148 0->149 0->150 0->151 0->152 2->1 3->1 4->1 4->1 4->8 5->1 5->1 5->1 5->25 6->1 6->1 6->43 7->1 7->1 7->1 8->1 8->1 8->1 8->15 8->27 9->1 11->9 12->4 12->4 13->5 13->5 14->1 14->1 14->46 15->1 15->1 15->16 15->57 15->65 16->18 17->1 17->1 17->1 17->47 18->1 18->1 18->19 18->67 18->73 19->20 20->1 20->1 20->21 20->22 20->30 20->39 20->51 20->74 21->1 21->23 22->1 22->1 22->23 23->1 23->1 23->1 23->15 23->41 23->48 24->1 24->32 24->52 25->1 25->1 25->26 25->45 26->1 26->1 26->25 27->1 27->1 30->1 30->1 30->20 30->22 30->30 30->31 30->31 30->39 30->41 30->51 30->52 30->74 30->153 30->154 31->1 31->30 32->1 32->1 32->1 32->32 32->33 32->45 32->55 32->55 32->83 32->83 32->155 33->1 33->32 37->1 37->1 37->1 37->46 38->1 38->1 38->1 38->47 39->1 40->30 41->1 41->1 41->1 41->124 41->126 42->1 42->32 42->52 43->1 43->25 44->1 44->32 45->1 45->1 45->26 45->76 46->1 47->1 48->1 51->1 52->1 52->42 52->42 52->75 52->75 52->81 52->82 52->101 52->104 52->124 52->126 52->138 52->150 52->156 52->157 52->162 52->163 52->164 52->165 52->176 52->179 55->1 55->1 55->33 55->76 56->1 57->58 58->1 58->1 58->16 58->57 58->68 58->87 58->88 58->91 58->92 58->108 58->112 58->122 58->123 58->128 58->129 58->130 58->131 58->132 58->133 58->134 58->135 58->140 58->141 58->142 58->143 59->1 59->109 60->1 60->1 61->1 61->1 62->1 62->113 63->1 63->1 63->1 64->1 64->1 64->1 65->1 65->1 65->15 66->1 67->68 68->1 68->1 68->19 68->58 68->67 68->95 68->97 68->115 68->116 68->117 68->118 69->1 69->1 70->1 70->1 71->1 71->1 71->1 72->1 72->1 72->1 73->1 73->1 73->18 75->1 75->32 75->52 76->1 76->26 76->45 78->1 78->1 78->85 78->86 78->107 78->128 78->129 78->158 78->159 78->166 78->167 78->168 78->169 78->182 78->183 79->1 79->1 79->1 79->89 79->90 79->111 79->132 79->133 79->160 79->161 79->170 79->171 79->172 79->173 79->184 79->185 81->1 81->1 81->102 81->119 81->144 81->174 81->177 81->178 81->188 82->1 82->1 82->98 82->105 82->120 82->121 82->138 82->147 82->175 82->180 82->181 82->192 83->32 83->55 83->55 84->1 85->1 85->1 86->1 86->59 87->60 87->60 87->123 88->61 88->61 88->92 89->1 89->1 89->1 90->1 90->62 91->1 91->58 91->63 91->63 91->68 91->115 91->122 91->127 92->1 92->58 92->64 92->64 92->68 92->88 92->127 93->1 94->69 95->70 95->70 95->117 96->71 97->1 97->58 97->68 97->72 97->72 97->115 97->122 97->127 98->1 98->1 98->1 98->58 98->68 98->127 99->78 100->79 101->81 102->1 102->1 102->103 102->125 102->145 102->150 102->151 102->186 102->189 102->190 102->193 102->195 102->196 102->199 103->1 103->102 104->82 105->1 105->1 105->106 105->127 105->187 106->1 106->105 107->85 108->130 109->110 110->1 111->89 112->134 113->114 114->1 115->116 116->97 117->118 118->1 118->58 118->68 118->87 118->95 118->127 119->1 119->102 121->1 121->1 121->105 122->108 122->128 123->112 123->132 124->1 124->126 124->144 125->1 125->1 125->1 125->81 125->101 125->102 125->103 125->124 125->136 125->137 125->144 125->148 125->152 125->156 125->162 125->163 125->174 125->176 125->177 125->178 125->188 125->191 125->194 125->197 125->198 125->200 125->201 125->202 126->1 126->147 127->1 127->1 127->1 127->58 127->68 127->105 127->106 127->139 127->149 128->129 129->108 130->140 131->141 132->133 133->112 134->142 135->143 136->1 136->42 136->138 136->150 137->1 137->1 137->1 137->124 137->126 137->144 138->42 138->121 138->121 139->1 139->1 139->42 140->131 141->91 142->135 143->1 143->58 143->68 143->87 143->95 143->127 144->1 144->126 144->151 145->1 145->125 145->125 147->1 148->1 149->139 150->42 150->136 150->138 151->144 151->152
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( int argc , char * * argv ) { FILE * inp , * out ; inp = fopen ( "\x2e\x2f\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e\x0" , "rb" ) ; out = fopen ( "./output.txt" , "w" ) ; int testCases , C , D , N , testCount = 0 ; char * inputString = NULL ; fscanf ( inp , "%d" , & testCases ) ; while ( testCases ) { combinationList * combination = NULL ; fscanf ( inp , "%d" , & C ) ; if ( C ) { combination = ( combinationList * ) calloc ( 26 , sizeof ( combinationList ) ) ; while ( C ) { char ch [ 4 ] ; fgetc ( inp ) ; fscanf ( inp , "%s" , ch ) ; if ( combination [ ch [ 0 ] - 'A' ] . enable != - 1 ) { combination [ ch [ 0 ] - 'A' ] . enable = - 1 ; combination [ ch [ 0 ] - 'A' ] . noOfRows = 0 ; } combination [ ch [ 0 ] - 'A' ] . noOfRows ++ ; combination [ ch [ 0 ] - 'A' ] . list [ combination [ ch [ 0 ] - 'A' ] . noOfRows - 1 ] [ 0 ] = ch [ 1 ] - 'A' ; combination [ ch [ 0 ] - 'A' ] . list [ combination [ ch [ 0 ] - 'A' ] . noOfRows - 1 ] [ 1 ] = ch [ 2 ] - 'A' ; if ( combination [ ch [ 1 ] - 'A' ] . enable != - 1 ) { combination [ ch [ 1 ] - 'A' ] . enable = - 1 ; combination [ ch [ 1 ] - 'A' ] . noOfRows = 0 ; } combination [ ch [ 1 ] - 'A' ] . noOfRows ++ ; combination [ ch [ 1 ] - 'A' ] . list [ combination [ ch [ 1 ] - 'A' ] . noOfRows - 1 ] [ 0 ] = ch [ 0 ] - 'A' ; combination [ ch [ 1 ] - 'A' ] . list [ combination [ ch [ 1 ] - 'A' ] . noOfRows - 1 ] [ 1 ] = ch [ 2 ] - 'A' ; C -- ; } } fgetc ( inp ) ; opposeList * oppose = NULL ; fscanf ( inp , "%d" , & D ) ; if ( D ) { oppose = ( opposeList * ) calloc ( 26 , sizeof ( opposeList ) ) ; while ( D ) { char ch [ 3 ] ; fgetc ( inp ) ; fscanf ( inp , "%s" , ch ) ; oppose [ ch [ 0 ] - 'A' ] . enable = - 1 ; oppose [ ch [ 0 ] - 'A' ] . opposer = ch [ 1 ] - 'A' ; oppose [ ch [ 1 ] - 'A' ] . enable = - 1 ; oppose [ ch [ 1 ] - 'A' ] . opposer = ch [ 0 ] - 'A' ; D -- ; } } fgetc ( inp ) ; fscanf ( inp , "%d" , & N ) ; fgetc ( inp ) ; inputString = ( char * ) calloc ( N + 1 , 1 ) ; fscanf ( inp , "%s" , inputString ) ; char outString [ N ] ; int outIndex = 0 ; for ( int i = 0 ; i < N ; i ++ ) { outString [ outIndex ] = inputString [ i ] ; if ( ! outIndex ) { outIndex ++ ; continue ; } comb : if ( combination ) { if ( combination [ outString [ outIndex ] - 'A' ] . enable == - 1 ) { for ( int j = 0 ; j < combination [ outString [ outIndex ] - 'A' ] . noOfRows ; j ++ ) { if ( combination [ outString [ outIndex ] - 'A' ] . list [ j ] [ 0 ] == ( outString [ outIndex - 1 ] - 'A' ) ) { outIndex -- ; outString [ outIndex ] = combination [ outString [ outIndex ] - 'A' ] . list [ j ] [ 1 ] + 'A' ; if ( outIndex ) goto comb ; } } } } if ( oppose ) { if ( oppose [ outString [ outIndex ] - 'A' ] . enable == - 1 ) { char ch = oppose [ outString [ outIndex ] - 'A' ] . opposer + 'A' ; for ( int j = outIndex - 1 ; j >= 0 ; j -- ) { if ( outString [ j ] == ch ) { outIndex = - 1 ; break ; } } } } outIndex ++ ; } fprintf ( out , "Case #%d: [" , ++ testCount ) ; for ( int i = 0 ; i < outIndex ; i ++ ) { fprintf ( out , "%c" , outString [ i ] ) ; if ( i != outIndex - 1 ) fprintf ( out , ", " ) ; } fprintf ( out , "]\n" ) ; testCases -- ; if ( combination ) free ( combination ) ; if ( oppose ) free ( oppose ) ; if ( inputString ) free ( inputString ) ; } return ( EXIT_SUCCESS ) ; }
>>>Func
METHOD compare
METHOD_RETURN int
PARAM void * a
PARAM void * b
<operator>.assignment elem1 = * ( int * ) a
<operator>.assignment elem2 = * ( int * ) b
RETURN return elem2 - elem1 ; return elem2 - elem1 ;
<operator>.subtraction elem2 - elem1
<operator>.cast ( int * ) a
<operator>.cast ( int * ) b
>>>PDG&10 0->2 0->3 0->7 0->8 0->9 2->8 3->9 4->1 4->1 4->7 5->1 5->1 5->7 6->1 7->1 7->1 7->1 7->6 8->1 9->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int compare ( void * a , void * b ) { int elem1 = * ( int * ) a ; int elem2 = * ( int * ) b ; return elem2 - elem1 ; }
>>>Func
METHOD gcd
METHOD_RETURN int
PARAM int a
PARAM int b
RETURN return gcd ( b , a % b ) ; return gcd ( b , a % b ) ;
<operator>.equals b == 0
gcd gcd ( b , a % b )
RETURN return a ; return a ;
IDENTIFIER a return a ;
<operator>.modulo a % b
>>>PDG&10 0->2 0->3 0->5 0->6 0->8 0->9 2->1 2->8 2->9 3->5 4->1 5->1 5->1 5->4 5->6 5->7 5->9 5->9 6->4 7->1 8->7 9->6 9->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
>>>Func
METHOD ParseInput
METHOD_RETURN int
PARAM char * pcszFileName
<operator>.assignment fp = fopen ( pcszFileName , "\x72\x0" )
fscanf fscanf ( fp , "%d " , & T )
<operator>.assignment fout = fopen ( OUT_FILE_NAME , "w" )
fclose fclose ( fp )
fclose fclose ( fout )
RETURN return 0 ; return 0 ;
<operator>.equals NULL == pcszFileName
<operator>.equals NULL == fp
<operator>.equals NULL == fout
<operator>.lessEqualsThan i <= T
<operator>.preIncrement ++ i
LITERAL 0 return 0 ;
RETURN return - 1 ; return - 1 ;
fopen fopen ( pcszFileName , "\x72\x0" )
printf printf ( "\nAccess denied file: %s" , pcszFileName )
RETURN return - 1 ; return - 1 ;
fopen fopen ( OUT_FILE_NAME , "w" )
printf printf ( "\nCannot create new file." )
RETURN return - 1 ; return - 1 ;
<operator>.assignment i = 1
<operator>.assignment max = 0
fscanf fscanf ( fp , "%lld %lld %lld %lld" , & L , & t , & n , & c )
<operator>.assignment aIndex = n % c
fprintf fprintf ( fout , "Case #%d: " , i )
<operator>.assignment time = 0
<operator>.assignment BoosterUsed = L
<operator>.assignment CheckFlag = 0
fprintf fprintf ( fout , "%lld\n" , time )
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.lessThan k < N
<operator>.preIncrement ++ k
<operator>.assignment stars [ k ] [ 0 ] = stars [ k ] [ 1 ] = 0
<operator>.lessThan j < c
<operator>.preIncrement ++ j
<operator>.equals aIndex == 0
<operator>.lessThan j < aIndex
<operator>.preIncrement ++ j
<operator>.lessThan k < n
<operator>.expressionList ++ k   j = ( j + 1 ) % c
<operator>.lessThan k < n
<operator>.preIncrement ++ k
<operator>.assignment k = 0
<operator>.assignment j = 0
fscanf fscanf ( fp , "%d " , & a [ j ] )
<operator>.modulo n % c
<operator>.assignment aIndex = c
<operator>.assignment j = 0
<operator>.expressionList k = 0   j = 0
<operator>.assignment stars [ k ] [ 0 ] = a [ j ]
<operator>.assignment k = 0
<operator>.assignment stars [ k ] [ 1 ] = 0
<operator>.greaterThan a [ j ] > max
<operator>.preIncrement ++ k
<operator>.assignment j = ( j + 1 ) % c
<operator>.equals max == a [ j ]
<operator>.logicalAnd ( time >= t || t <= stars [ k ] [ 0 ] ) && BoosterUsed != 0
<operator>.assignment max = a [ j ]
<operator>.assignment k = 0
<operator>.assignment j = 0
<operator>.modulo ( j + 1 ) % c
<operator>.assignment stars [ k ] [ 1 ] = 1
<operator>.addition j + 1
<operator>.logicalOr time >= t || t <= stars [ k ] [ 0 ]
<operator>.notEquals BoosterUsed != 0
<operator>.equals CheckFlag == 0
<operator>.assignmentPlus time += ( stars [ k ] [ 0 ] * 2 )
<operator>.greaterEqualsThan time >= t
<operator>.lessEqualsThan t <= stars [ k ] [ 0 ]
<operator>.assignment CheckFlag = 1
<operator>.postDecrement BoosterUsed --
<operator>.assignment nextI = k + c
<operator>.lessEqualsThan t <= stars [ k ] [ 0 ]
<operator>.multiplication stars [ k ] [ 0 ] * 2
<operator>.assignmentPlus time += t
<operator>.assignmentPlus time += ( stars [ k ] [ 0 ] - ( t / 2 ) )
<operator>.addition k + c
<operator>.equals k == nextI
<operator>.assignmentPlus time += stars [ k ] [ 0 ]
<operator>.postDecrement BoosterUsed --
<operator>.subtraction stars [ k ] [ 0 ] - ( t / 2 )
<operator>.lessEqualsThan t <= stars [ k ] [ 0 ]
<operator>.assignmentPlus time += ( stars [ k ] [ 0 ] * 2 )
<operator>.division t / 2
<operator>.assignmentPlus time += t
<operator>.assignmentPlus time += ( stars [ k ] [ 0 ] - ( t / 2 ) )
<operator>.assignmentPlus time += stars [ k ] [ 0 ]
<operator>.multiplication stars [ k ] [ 0 ] * 2
<operator>.subtraction stars [ k ] [ 0 ] - ( t / 2 )
<operator>.division t / 2
<operator>.addressOf & T
<operator>.addressOf & L
<operator>.addressOf & t
<operator>.addressOf & n
<operator>.addressOf & c
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess stars [ k ] [ 1 ]
<operator>.addressOf & a [ j ]
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess stars [ k ] [ 1 ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess stars [ k ] [ 0 ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess stars [ k ]
<operator>.indirectIndexAccess stars [ k ]
>>>PDG&131 0->2 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->19 0->20 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->59 0->62 0->63 0->64 0->65 0->66 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->93 2->9 3->10 4->6 4->12 4->24 5->11 8->1 9->1 9->1 9->1 9->3 9->10 9->10 9->15 9->16 9->16 9->31 10->4 10->4 10->5 10->11 10->11 10->17 10->18 10->19 10->32 10->94 11->6 11->7 11->7 11->8 11->12 11->20 11->21 11->22 11->26 11->33 12->12 12->13 12->23 12->24 12->25 12->26 12->26 12->27 12->28 12->29 12->30 12->34 12->37 12->39 12->40 12->42 12->44 12->46 12->47 12->49 12->51 12->52 12->54 12->62 12->63 12->95 12->96 12->97 12->98 13->12 14->8 15->1 16->3 16->3 16->17 18->1 19->1 19->5 19->5 21->1 22->12 23->56 23->59 24->6 24->28 24->37 24->42 24->44 24->48 24->49 24->49 24->50 24->64 24->71 24->72 24->75 24->76 24->78 24->80 24->85 24->87 24->88 24->93 25->39 26->13 26->30 27->30 27->71 28->68 28->74 28->83 29->69 30->7 30->26 31->1 31->15 32->18 33->21 34->1 34->34 34->35 34->35 34->36 34->55 34->99 34->100 34->101 34->105 35->34 36->72 36->76 36->77 36->85 36->91 37->37 37->38 37->38 37->48 37->49 37->102 37->106 38->37 39->40 39->50 40->40 40->41 40->41 40->56 40->107 41->40 42->42 42->43 42->44 42->53 42->57 42->57 42->58 42->59 42->64 42->66 42->103 42->104 42->108 42->109 44->24 44->44 44->45 44->45 44->49 44->60 44->67 44->71 44->75 44->80 44->81 45->44 46->34 47->37 48->6 48->24 48->53 48->56 48->59 48->61 49->24 49->25 49->25 49->37 49->42 49->50 49->64 49->75 49->80 50->40 51->40 53->72 53->76 53->77 53->85 53->91 54->44 55->36 56->48 56->53 56->59 56->59 56->61 56->61 56->110 57->42 57->43 58->43 58->64 58->66 59->48 59->53 59->56 59->65 59->111 59->112 60->69 60->70 60->77 60->115 60->117 61->56 61->59 62->42 62->52 63->52 63->64 63->66 64->24 64->37 64->43 64->43 64->58 64->58 64->75 64->80 67->60 67->60 67->68 68->60 68->60 68->74 68->83 69->73 69->74 69->75 69->76 69->80 69->81 69->116 69->118 70->30 70->71 71->24 71->67 71->67 71->70 71->72 71->72 71->76 71->78 71->82 71->85 71->86 71->88 71->90 71->113 71->114 72->24 72->67 72->67 72->71 72->76 72->76 72->77 72->85 72->85 72->91 73->69 74->68 74->83 75->81 76->24 76->67 76->71 76->72 76->77 76->78 76->78 76->79 76->82 76->82 76->84 76->84 76->85 76->87 76->87 76->91 76->119 76->120 76->121 76->122 77->70 77->70 77->72 77->76 77->85 77->91 78->79 79->30 79->71 81->45 81->83 81->85 81->86 81->91 81->123 81->124 81->125 81->128 82->30 82->71 83->68 83->74 84->72 84->76 84->77 84->79 84->79 84->85 84->91 85->24 85->67 85->71 85->72 85->76 85->77 85->88 85->88 85->89 85->90 85->90 85->91 85->92 85->92 85->93 85->93 85->126 85->127 85->129 85->130 86->30 86->71 87->24 87->71 87->84 87->84 88->89 89->30 89->71 90->30 90->71 91->72 91->76 91->77 91->85 91->86 91->86 92->72 92->76 92->77 92->85 92->89 92->89 92->91 93->24 93->71 93->92 93->92
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int ParseInput ( char * pcszFileName ) { int T ; int i , j , k ; FILE * fp ; long int max ; long long int L , t , c , BoosterUsed , time , aIndex ; if ( NULL == pcszFileName ) return - 1 ; fp = fopen ( pcszFileName , "\x72\x0" ) ; if ( NULL == fp ) { printf ( "\nAccess denied file: %s" , pcszFileName ) ; return - 1 ; } fscanf ( fp , "%d " , & T ) ; fout = fopen ( OUT_FILE_NAME , "w" ) ; if ( NULL == fout ) { printf ( "\nCannot create new file." ) ; return - 1 ; } for ( i = 1 ; i <= T ; ++ i ) { max = 0 ; for ( k = 0 ; k < N ; ++ k ) stars [ k ] [ 0 ] = stars [ k ] [ 1 ] = 0 ; fscanf ( fp , "%lld %lld %lld %lld" , & L , & t , & n , & c ) ; for ( j = 0 ; j < c ; ++ j ) { fscanf ( fp , "%d " , & a [ j ] ) ; } aIndex = n % c ; if ( aIndex == 0 ) aIndex = c ; for ( j = 0 ; j < aIndex ; ++ j ) { if ( a [ j ] > max ) max = a [ j ] ; } for ( k = 0 , j = 0 ; k < n ; ++ k , j = ( j + 1 ) % c ) { stars [ k ] [ 0 ] = a [ j ] ; if ( max == a [ j ] ) stars [ k ] [ 1 ] = 1 ; } fprintf ( fout , "Case #%d: " , i ) ; time = 0 ; BoosterUsed = L ; int CheckFlag = 0 ; int nextI ; for ( k = 0 ; k < n ; ++ k ) { if ( ( time >= t || t <= stars [ k ] [ 0 ] ) && BoosterUsed != 0 ) { if ( CheckFlag == 0 ) { CheckFlag = 1 ; if ( t <= stars [ k ] [ 0 ] ) { time += t ; time += ( stars [ k ] [ 0 ] - ( t / 2 ) ) ; } else { time += stars [ k ] [ 0 ] ; } BoosterUsed -- ; nextI = k + c ; } else { if ( k == nextI ) { if ( t <= stars [ k ] [ 0 ] ) { time += t ; time += ( stars [ k ] [ 0 ] - ( t / 2 ) ) ; } else { time += stars [ k ] [ 0 ] ; } BoosterUsed -- ; } else { time += ( stars [ k ] [ 0 ] * 2 ) ; } } } else { time += ( stars [ k ] [ 0 ] * 2 ) ; } } fprintf ( fout , "%lld\n" , time ) ; } fclose ( fp ) ; fclose ( fout ) ; return 0 ; }
>>>Func
METHOD kohonen_get_min_1d
METHOD_RETURN void
PARAM double const * X
PARAM int N
PARAM double * val
PARAM int * idx
<operator>.assignment val [ 0 ] = INFINITY
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.lessThan X [ i ] < val [ 0 ]
<operator>.assignment idx [ 0 ] = i
<operator>.assignment val [ 0 ] = X [ i ]
<operator>.indirectIndexAccess X [ i ]
<operator>.indirectIndexAccess val [ 0 ]
<operator>.indirectIndexAccess idx [ 0 ]
<operator>.indirectIndexAccess val [ 0 ]
<operator>.indirectIndexAccess X [ i ]
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 2->1 2->10 2->12 3->7 4->1 4->10 5->1 6->1 6->1 6->1 6->10 7->1 7->1 7->1 7->7 7->8 7->8 7->10 7->11 7->13 7->14 8->1 8->7 9->1 9->7 10->11 10->12 10->12 10->15 10->16 10->17 12->10
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void kohonen_get_min_1d ( double const * X , int N , double * val , int * idx ) { val [ 0 ] = INFINITY ; for ( int i = 0 ; i < N ; i ++ ) { if ( X [ i ] < val [ 0 ] ) { idx [ 0 ] = i ; val [ 0 ] = X [ i ] ; } } }
>>>Func
METHOD comput
METHOD_RETURN void
PARAM int n
memset memset ( valid   0   sizeof ( valid ) )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment owp [ i ] = ( LD ) 0
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment oowp [ i ] = 0
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment ans [ i ] = ( ( LD ) 0.25 ) * wp [ i ] + ( ( LD ) 0.5 ) * owp [ i ] + ( ( LD ) 0.25 ) * oowp [ i ]
<operator>.assignment i = 0
<operator>.assignment sucess = 0
<operator>.assignment total = 0
<operator>.assignment wp [ i ] = ( LD ) sucess / ( LD ) total
<operator>.assignment i = 0
<operator>.assignment k = 0
<operator>.assignment temp = 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment temp = 0
<operator>.assignment oowp [ i ] = oowp [ i ] / ( LD ) temp
<operator>.assignment i = 0
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.cast ( LD ) 0
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.equals temp == 0
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.addition ( ( LD ) 0.25 ) * wp [ i ] + ( ( LD ) 0.5 ) * owp [ i ] + ( ( LD ) 0.25 ) * oowp [ i ]
<operator>.assignment j = 0
<operator>.division ( LD ) sucess / ( LD ) total
<operator>.assignment i = 0
<operator>.assignment i = 0
printf printf ( "\x6f\x77\x70\x20\x25\x64\x5c\x6e\x0" , k )
<operator>.assignment owp [ k ] = 0
<operator>.assignment j = 0
<operator>.division oowp [ i ] / ( LD ) temp
<operator>.addition ( ( LD ) 0.25 ) * wp [ i ] + ( ( LD ) 0.5 ) * owp [ i ]
<operator>.multiplication ( ( LD ) 0.25 ) * oowp [ i ]
<operator>.notEquals matr [ i ] [ j ] != '.'
<operator>.equals matr [ i ] [ j ] == '1'
<operator>.cast ( LD ) sucess
<operator>.cast ( LD ) total
<operator>.notEquals k != i
<operator>.postIncrement temp ++
<operator>.assignmentPlus owp [ k ] += wp1 [ i ]
<operator>.assignment owp [ k ] = owp [ k ] / ( LD ) temp
<operator>.postIncrement temp ++
<operator>.assignmentPlus oowp [ i ] += owp [ j ]
<operator>.cast ( LD ) temp
<operator>.multiplication ( ( LD ) 0.25 ) * wp [ i ]
<operator>.multiplication ( ( LD ) 0.5 ) * owp [ i ]
<operator>.cast ( LD ) 0.25
<operator>.postIncrement total ++
<operator>.assignment valid [ i ] [ j ] = 1
<operator>.postIncrement sucess ++
<operator>.assignment sucess = 0
<operator>.assignment total = 0
<operator>.assignment wp1 [ i ] = ( LD ) sucess / ( LD ) total
<operator>.cast ( LD ) 0.25
<operator>.cast ( LD ) 0.5
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.division owp [ k ] / ( LD ) temp
<operator>.assignment j = 0
<operator>.division ( LD ) sucess / ( LD ) total
<operator>.cast ( LD ) temp
<operator>.logicalAnd k != j && matr [ i ] [ j ] != '.'
<operator>.logicalAnd k != j && matr [ i ] [ j ] == '1'
<operator>.cast ( LD ) sucess
<operator>.cast ( LD ) total
<operator>.postIncrement total ++
<operator>.postIncrement sucess ++
<operator>.notEquals k != j
<operator>.notEquals matr [ i ] [ j ] != '.'
<operator>.notEquals k != j
<operator>.equals matr [ i ] [ j ] == '1'
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess ans [ i ]
<operator>.indirectIndexAccess wp [ i ]
UNKNOWN LD LD
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess valid [ k ] [ i ]
<operator>.indirectIndexAccess valid [ i ] [ j ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
UNKNOWN LD LD
UNKNOWN LD LD
<operator>.indirectIndexAccess valid [ k ]
<operator>.indirectIndexAccess owp [ k ]
<operator>.indirectIndexAccess valid [ i ]
UNKNOWN LD LD
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
UNKNOWN LD LD
<operator>.indirectIndexAccess matr [ i ] [ j ]
<operator>.indirectIndexAccess matr [ i ] [ j ]
<operator>.indirectIndexAccess owp [ k ]
<operator>.indirectIndexAccess wp1 [ i ]
<operator>.indirectIndexAccess owp [ k ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess owp [ j ]
UNKNOWN LD LD
UNKNOWN LD LD
<operator>.indirectIndexAccess matr [ i ]
<operator>.indirectIndexAccess valid [ i ] [ j ]
<operator>.indirectIndexAccess matr [ i ]
<operator>.indirectIndexAccess wp1 [ i ]
<operator>.indirectIndexAccess owp [ k ]
<operator>.indirectIndexAccess valid [ i ]
UNKNOWN LD LD
UNKNOWN LD LD
UNKNOWN LD LD
<operator>.indirectIndexAccess matr [ i ] [ j ]
<operator>.indirectIndexAccess matr [ i ] [ j ]
<operator>.indirectIndexAccess matr [ i ]
<operator>.indirectIndexAccess matr [ i ]
>>>PDG&131 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 2->4 3->1 3->1 4->4 4->5 4->5 4->6 4->20 4->21 4->22 4->31 4->31 4->42 4->43 4->54 4->55 4->93 4->100 4->101 5->1 5->4 6->6 6->7 6->7 6->8 6->9 6->33 6->90 6->94 7->1 7->6 8->64 9->1 9->1 9->9 9->10 9->10 9->11 9->25 9->34 9->34 9->36 9->38 9->44 9->45 9->46 9->56 10->1 10->9 11->11 11->12 11->12 11->13 11->14 11->91 12->1 12->11 13->49 13->51 13->61 14->14 14->15 14->15 14->16 14->28 14->29 14->39 14->39 14->48 14->49 14->62 14->95 14->98 14->105 15->1 15->14 16->1 16->1 16->1 16->16 16->17 16->17 16->18 16->41 16->50 16->51 16->63 16->64 16->65 16->72 16->73 16->92 16->99 16->106 16->107 16->108 16->116 16->117 17->1 17->16 19->4 20->43 20->54 20->68 21->43 21->55 21->66 22->63 23->6 24->1 24->9 25->38 25->57 26->11 27->14 28->49 28->60 28->62 29->49 29->51 29->61 30->1 30->16 31->4 31->31 31->32 31->32 31->52 31->53 31->109 31->110 31->118 31->120 32->31 34->34 34->35 34->36 34->56 34->56 34->74 35->34 36->9 36->36 36->37 36->37 36->96 36->102 37->36 38->46 38->47 38->59 38->76 38->76 38->79 38->79 38->103 38->113 38->122 38->124 39->14 39->39 39->40 39->40 39->97 39->104 40->39 42->31 43->22 43->22 44->34 45->36 46->10 47->58 47->76 48->39 49->29 49->29 51->18 51->18 51->41 51->41 52->53 52->66 52->67 52->80 52->119 52->123 53->52 53->68 53->81 53->87 53->89 56->10 56->35 56->46 56->69 56->70 56->71 56->74 56->77 56->78 56->82 56->83 56->86 56->121 56->125 56->126 57->38 58->76 59->58 59->76 60->49 60->62 61->49 63->18 63->18 63->41 63->41 63->50 63->50 64->18 64->18 64->41 64->41 64->50 64->50 66->43 66->55 68->43 68->54 69->78 69->82 69->85 70->78 70->83 70->84 71->58 74->34 74->74 74->75 74->80 74->81 74->86 74->86 74->88 75->74 76->59 76->59 77->74 78->71 78->71 80->84 81->85 84->78 84->83 85->78 85->82 86->80 86->80 86->87 86->88 86->88 86->127 86->129 87->80 87->80 87->89 88->10 88->46 88->56 88->75 88->81 88->81 88->86 88->89 88->128 88->130 89->81 89->81 89->87 96->57 96->58 96->111 96->112 97->60 97->61 97->114 97->115
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void comput ( int n ) { memset ( valid , 0 , sizeof ( valid ) ) ; int i , j , sucess , total ; for ( i = 0 ; i < n ; i ++ ) { sucess = 0 ; total = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( matr [ i ] [ j ] != '.' ) { total ++ ; valid [ i ] [ j ] = 1 ; } if ( matr [ i ] [ j ] == '1' ) sucess ++ ; } wp [ i ] = ( LD ) sucess / ( LD ) total ; } LD wp1 [ N ] ; for ( i = 0 ; i < n ; i ++ ) owp [ i ] = ( LD ) 0 ; int k ; for ( k = 0 ; k < n ; k ++ ) { for ( i = 0 ; i < n ; i ++ ) { if ( k != i ) { sucess = 0 ; total = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( k != j && matr [ i ] [ j ] != '.' ) total ++ ; if ( k != j && matr [ i ] [ j ] == '1' ) sucess ++ ; } wp1 [ i ] = ( LD ) sucess / ( LD ) total ; } } int temp = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( valid [ k ] [ i ] ) { temp ++ ; owp [ k ] += wp1 [ i ] ; } if ( temp == 0 ) { printf ( "\x6f\x77\x70\x20\x25\x64\x5c\x6e\x0" , k ) ; owp [ k ] = 0 ; } else owp [ k ] = owp [ k ] / ( LD ) temp ; } for ( i = 0 ; i < n ; i ++ ) oowp [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { int temp = 0 ; for ( j = 0 ; j < n ; j ++ ) if ( valid [ i ] [ j ] ) { temp ++ ; oowp [ i ] += owp [ j ] ; } oowp [ i ] = oowp [ i ] / ( LD ) temp ; } for ( i = 0 ; i < n ; i ++ ) ans [ i ] = ( ( LD ) 0.25 ) * wp [ i ] + ( ( LD ) 0.5 ) * owp [ i ] + ( ( LD ) 0.25 ) * oowp [ i ] ; }
>>>Func
METHOD arraylist_clear
METHOD_RETURN void
PARAM ArrayList * arraylist
<operator>.assignment arraylist -> length = 0
>>>PDG&4 0->2 0->3 2->1 3->1 3->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void arraylist_clear ( ArrayList * arraylist ) { arraylist -> length = 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment * fi = fopen ( "\x43\x3a\x5c\x5c\x63\x6a\x69\x6e\x70\x75\x74\x73\x5c\x5c\x65\x6c\x65\x6d\x5c\x5c\x73\x6d\x61\x6c\x6c\x32\x2e\x69\x6e\x0" , "r" )
<operator>.assignment * fo = fopen ( "C:\\cjinputs\\elem\\small.txt" , "w" )
<operator>.assignment * line = xmalloc ( LINE_MAX )
<operator>.assignment total_inputs = atoi ( line )
RETURN return 0 ; return 0 ;
<operator>.logicalOr fi == 0 || fo == 0
<operator>.equals fgets ( line , LINE_MAX , fi ) == 0
<operator>.lessThan counter < total_inputs
<operator>.postIncrement counter ++
LITERAL 0 return 0 ;
fopen fopen ( "\x43\x3a\x5c\x5c\x63\x6a\x69\x6e\x70\x75\x74\x73\x5c\x5c\x65\x6c\x65\x6d\x5c\x5c\x73\x6d\x61\x6c\x6c\x32\x2e\x69\x6e\x0" , "r" )
fopen fopen ( "C:\\cjinputs\\elem\\small.txt" , "w" )
eout eout ( "Could not open file(s)" )
xmalloc xmalloc ( LINE_MAX )
eout eout ( "Input error" )
atoi atoi ( line )
<operator>.assignment counter = 0
printf printf ( "\nNew Read\n" )
<operator>.assignment n_com = atoi ( strtok ( line , " " ) )
<operator>.assignment * tempc = xmalloc ( 4 )
free free ( tempc )
<operator>.assignment n_opp = atoi ( strtok ( 0 , " " ) )
<operator>.assignment * tempo = xmalloc ( 3 )
free free ( tempo )
<operator>.assignment n_elm = atoi ( strtok ( 0 , " " ) )
<operator>.assignment * input = xmalloc ( n_elm + 1 )
strcpy strcpy ( input   strtok ( 0 , " " ) )
<operator>.assignment out_ptr = 0
<operator>.assignment * output = xmalloc ( n_elm + 1 )
printf printf ( "Output string is: %s\n" , output )
<operator>.assignment * f_output = xmalloc ( LINE_MAX )
fputs fputs ( f_output , fo )
free free ( f_output )
<operator>.equals fi == 0
<operator>.equals fo == 0
fgets fgets ( line , LINE_MAX , fi )
<operator>.equals fgets ( line , LINE_MAX , fi ) == 0
<operator>.lessThan i < n_com
<operator>.postIncrement i ++
<operator>.lessThan i < n_opp
<operator>.postIncrement i ++
<operator>.lessThan i < n_elm
<operator>.postIncrement i ++
<operator>.equals out_ptr == 0
eout eout ( "Input error" )
atoi atoi ( strtok ( line , " " ) )
xmalloc xmalloc ( 4 )
<operator>.assignment i = 0
strcpy strcpy ( tempc   strtok ( 0 , " " ) )
<operator>.assignment com1 [ i ] = * tempc
<operator>.assignment com2 [ i ] = * ( tempc + 1 )
<operator>.assignment comO [ i ] = * ( tempc + 2 )
atoi atoi ( strtok ( 0 , " " ) )
xmalloc xmalloc ( 3 )
<operator>.assignment i = 0
strcpy strcpy ( tempo   strtok ( 0 , " " ) )
<operator>.assignment opp1 [ i ] = * tempo
<operator>.assignment opp2 [ i ] = * ( tempo + 1 )
atoi atoi ( strtok ( 0 , " " ) )
xmalloc xmalloc ( n_elm + 1 )
strtok strtok ( 0 , " " )
xmalloc xmalloc ( n_elm + 1 )
<operator>.assignment i = 0
<operator>.assignment c = * ( input + i )
printf printf ( "\nInput is %c\n" , c )
<operator>.assignment * ( output + ( out_ptr ++ ) ) = c
<operator>.assignment * ( output + out_ptr ) = '\0'
printf printf ( "I = %d: Output string is: %s\n" , i , output )
xmalloc xmalloc ( LINE_MAX )
sprintf sprintf ( f_output , "Case #%d: []\n" , counter + 1 )
fgets fgets ( line , LINE_MAX , fi )
strtok strtok ( line , " " )
strtok strtok ( 0 , " " )
strtok strtok ( 0 , " " )
<operator>.addition n_elm + 1
<operator>.addition n_elm + 1
<operator>.greaterThan out_ptr > 1
<operator>.logicalAnd out_ptr > 1 && c != ( char ) 0
sprintf sprintf ( f_output , "Case #%d: [" , counter + 1 )
<operator>.assignment * temp = xmalloc ( LINE_MAX )
sprintf sprintf ( temp , "%c]\n" , output [ i ] )
strcat strcat ( f_output , temp )
free free ( temp )
strtok strtok ( 0 , " " )
strtok strtok ( 0 , " " )
<operator>.addition counter + 1
<operator>.lessThan i < out_ptr - 1
<operator>.postIncrement i ++
<operator>.addition tempc + 1
<operator>.addition tempc + 2
<operator>.addition tempo + 1
<operator>.addition input + i
<operator>.addition output + ( out_ptr ++ )
<operator>.notEquals ( x = arr_cont ( com1 , n_com , c ) ) != - 1
<operator>.greaterThan out_ptr > 1
<operator>.notEquals c != ( char ) 0
<operator>.greaterThan n_opp > 0
<operator>.addition output + out_ptr
<operator>.addition counter + 1
xmalloc xmalloc ( LINE_MAX )
<operator>.assignment i = 0
sprintf sprintf ( temp , "%c, " , output [ i ] )
strcat strcat ( f_output , temp )
<operator>.postIncrement out_ptr ++
<operator>.cast ( char ) 0
<operator>.subtraction out_ptr - 1
<operator>.assignment x = arr_cont ( com1 , n_com , c )
<operator>.minus - 1
<operator>.equals * ( output + out_ptr - 2 ) == com2 [ x ]
<operator>.notEquals ( x = arr_cont ( opp1 , n_opp , c ) ) != - 1
arr_cont arr_cont ( com1 , n_com , c )
<operator>.assignment * ( output + ( out_ptr -- ) - 2 ) = comO [ x ]
<operator>.assignment c = ( char ) 0
printf printf ( "  pair found\n" )
<operator>.notEquals ( x = arr_cont ( com2 , n_com , c ) ) != - 1
<operator>.assignment x = arr_cont ( opp1 , n_opp , c )
<operator>.minus - 1
<operator>.notEquals arr_cont ( output , out_ptr , opp2 [ x ] ) != - 1
<operator>.subtraction output + out_ptr - 2
<operator>.cast ( char ) 0
<operator>.assignment x = arr_cont ( com2 , n_com , c )
<operator>.minus - 1
<operator>.equals * ( output + out_ptr - 2 ) == com1 [ x ]
arr_cont arr_cont ( opp1 , n_opp , c )
<operator>.assignment out_ptr = 0
printf printf ( "  opp found: %c & %c. string was %s. len was %d\n" , opp1 [ x ] , opp2 [ x ] , output , out_ptr )
<operator>.notEquals ( x = arr_cont ( opp2 , n_opp , c ) ) != - 1
<operator>.addition output + out_ptr
<operator>.subtraction output + ( out_ptr -- ) - 2
arr_cont arr_cont ( com2 , n_com , c )
<operator>.assignment * ( output + ( out_ptr -- ) - 2 ) = comO [ x ]
<operator>.assignment c = ( char ) 0
printf printf ( "  pair found\n" )
arr_cont arr_cont ( output , out_ptr , opp2 [ x ] )
<operator>.minus - 1
<operator>.addition output + ( out_ptr -- )
<operator>.assignment x = arr_cont ( opp2 , n_opp , c )
<operator>.minus - 1
<operator>.notEquals arr_cont ( output , out_ptr , opp1 [ x ] ) != - 1
<operator>.postDecrement out_ptr --
<operator>.subtraction output + out_ptr - 2
<operator>.cast ( char ) 0
arr_cont arr_cont ( opp2 , n_opp , c )
<operator>.assignment out_ptr = 0
printf printf ( "  opp found: %c & %c. string was %s. len was %d\n" , opp1 [ x ] , opp2 [ x ] , output , out_ptr )
<operator>.addition output + out_ptr
<operator>.subtraction output + ( out_ptr -- ) - 2
arr_cont arr_cont ( output , out_ptr , opp1 [ x ] )
<operator>.minus - 1
<operator>.addition output + ( out_ptr -- )
<operator>.postDecrement out_ptr --
<operator>.indirectIndexAccess com1 [ i ]
<operator>.indirection * tempc
<operator>.indirectIndexAccess com2 [ i ]
<operator>.indirection * ( tempc + 1 )
<operator>.indirectIndexAccess comO [ i ]
<operator>.indirection * ( tempc + 2 )
<operator>.indirectIndexAccess opp1 [ i ]
<operator>.indirection * tempo
<operator>.indirectIndexAccess opp2 [ i ]
<operator>.indirection * ( tempo + 1 )
<operator>.indirection * ( input + i )
<operator>.indirection * ( output + ( out_ptr ++ ) )
<operator>.indirection * ( output + out_ptr )
<operator>.indirectIndexAccess output [ i ]
UNKNOWN char char
<operator>.indirectIndexAccess output [ i ]
<operator>.indirection * ( output + out_ptr - 2 )
<operator>.indirectIndexAccess com2 [ x ]
<operator>.indirection * ( output + ( out_ptr -- ) - 2 )
<operator>.indirectIndexAccess comO [ x ]
UNKNOWN char char
<operator>.indirection * ( output + out_ptr - 2 )
<operator>.indirectIndexAccess com1 [ x ]
<operator>.indirectIndexAccess opp2 [ x ]
<operator>.indirectIndexAccess opp1 [ x ]
<operator>.indirectIndexAccess opp2 [ x ]
<operator>.indirection * ( output + ( out_ptr -- ) - 2 )
<operator>.indirectIndexAccess comO [ x ]
UNKNOWN char char
<operator>.indirectIndexAccess opp1 [ x ]
<operator>.indirectIndexAccess opp1 [ x ]
<operator>.indirectIndexAccess opp2 [ x ]
>>>PDG&185 0->6 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->22 0->25 0->28 0->29 0->31 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->48 0->49 0->50 0->55 0->56 0->57 0->61 0->62 0->63 0->64 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->80 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->109 0->112 0->114 0->115 0->118 0->120 0->121 0->123 0->125 0->126 0->127 0->129 0->130 0->131 0->133 0->134 0->135 0->136 0->137 0->139 0->141 0->142 0->143 0->144 0->145 0->146 0->147 0->148 0->149 0->150 0->151 0->152 2->1 2->1 2->35 3->1 3->1 3->1 3->33 3->36 4->1 4->1 4->37 5->1 5->1 5->9 6->1 7->1 7->1 7->1 7->14 8->1 8->1 8->16 9->1 9->1 9->1 9->9 9->10 9->10 9->19 9->20 9->21 9->22 9->23 9->24 9->25 9->26 9->27 9->28 9->29 9->30 9->31 9->32 9->33 9->34 9->38 9->39 9->41 9->43 9->45 9->47 9->48 9->49 9->54 9->55 9->56 9->60 9->61 9->62 9->63 9->64 9->70 9->71 9->72 9->73 9->74 9->75 9->76 9->77 9->80 9->87 9->100 10->1 10->9 11->6 12->2 12->2 13->3 13->3 14->1 15->4 15->37 16->1 17->1 17->5 17->72 18->1 18->9 19->1 20->1 20->1 20->39 21->1 21->1 21->22 21->50 22->1 23->1 23->41 24->1 24->1 24->25 24->57 25->1 26->1 26->1 26->43 26->61 26->63 26->76 26->77 27->1 27->28 28->1 28->1 28->1 28->93 29->1 29->45 29->105 30->1 30->1 30->31 30->69 30->94 30->99 30->120 30->129 30->130 30->135 30->137 30->142 30->147 30->148 30->149 30->151 31->1 31->1 31->82 31->103 32->1 32->1 32->71 32->80 33->1 33->1 33->34 34->1 35->7 35->7 35->36 35->37 36->1 36->7 36->7 36->33 37->1 37->1 37->8 37->8 37->8 37->17 37->72 37->72 38->1 38->1 38->46 39->1 39->1 39->39 39->40 39->40 39->50 39->51 39->52 39->53 39->85 39->90 39->91 39->112 39->153 39->154 39->155 39->156 39->157 39->158 40->1 40->39 41->1 41->1 41->41 41->42 41->42 41->57 41->58 41->59 41->86 41->92 41->98 41->159 41->160 41->161 41->162 42->1 42->41 43->1 43->1 43->1 43->43 43->44 43->65 43->66 43->67 43->68 43->69 43->69 43->78 43->79 43->93 43->93 43->94 43->96 43->99 43->105 43->163 43->164 43->165 44->1 44->43 45->1 45->1 45->71 45->80 45->81 45->82 45->83 45->84 45->87 45->88 45->100 45->101 45->102 45->107 45->107 45->166 46->1 47->1 47->20 48->21 49->39 50->1 50->22 50->90 50->91 51->1 51->1 51->1 51->112 52->1 52->1 52->1 52->131 53->1 53->1 53->1 54->23 55->24 56->41 57->1 57->25 57->92 58->1 58->1 58->1 58->125 59->1 59->1 59->1 59->144 60->26 61->27 62->28 62->28 63->1 63->30 64->1 64->43 65->1 65->1 65->66 66->1 66->67 66->97 66->112 66->125 67->1 67->1 67->1 68->1 68->1 68->120 68->142 69->1 69->31 69->44 69->94 69->99 69->120 69->129 69->130 69->135 69->137 69->142 69->147 69->148 69->149 69->151 70->1 70->32 70->72 70->101 71->1 71->1 71->33 72->1 72->38 72->38 72->38 72->70 72->73 73->1 73->47 73->47 73->72 74->54 74->54 75->60 75->60 78->95 78->96 78->108 78->109 78->112 78->120 78->129 78->141 78->142 78->147 78->152 79->1 79->1 79->1 79->98 80->1 80->1 80->83 80->104 81->1 81->1 81->82 81->103 82->1 82->1 82->31 82->69 82->83 82->94 82->99 82->103 82->120 82->127 82->129 82->130 82->135 82->137 82->142 82->146 82->147 82->148 82->149 82->151 83->1 83->33 83->84 84->1 85->50 85->50 86->57 86->57 88->1 88->1 88->1 88->88 88->89 88->89 88->103 88->104 88->107 88->168 89->1 89->88 93->1 94->1 95->1 95->1 95->1 95->110 95->116 95->120 95->122 95->123 95->129 95->131 95->169 95->170 96->45 96->79 96->79 96->97 96->99 96->105 96->106 96->135 96->149 96->167 97->1 97->1 97->79 97->79 97->125 98->1 98->1 98->111 98->117 98->118 98->125 98->125 101->1 101->72 101->81 102->1 102->88 103->1 103->82 103->104 104->82 104->83 104->103 105->78 105->94 107->1 107->88 107->88 108->1 108->1 108->95 109->95 110->1 110->1 110->1 110->113 110->114 110->115 110->121 110->130 110->131 110->137 110->141 110->171 110->172 110->173 111->1 111->1 111->119 111->128 111->135 111->136 111->138 111->139 111->144 111->176 112->1 112->1 112->1 112->95 112->95 112->95 112->97 112->108 112->108 112->108 112->124 112->125 112->131 112->131 113->1 113->1 113->1 114->1 114->1 114->1 114->97 114->125 115->1 116->1 116->1 116->1 116->124 116->142 116->147 116->174 116->175 117->1 117->1 117->111 118->111 119->1 119->1 119->1 119->126 119->127 119->177 119->178 122->1 122->1 122->116 123->116 124->1 124->1 124->1 124->112 124->132 124->133 124->134 124->143 124->148 124->151 124->152 124->179 124->180 124->181 125->1 125->1 125->1 125->98 125->111 125->111 125->111 125->117 125->117 125->117 125->127 125->144 125->144 125->146 125->149 126->1 126->127 127->1 127->1 127->1 127->45 127->69 127->99 127->99 127->105 127->125 127->135 127->144 127->146 127->149 128->1 128->1 128->1 128->140 128->149 128->150 128->182 130->1 131->1 131->1 131->1 131->97 131->110 131->112 131->116 131->116 131->116 131->122 131->122 131->122 131->125 132->1 132->1 132->1 133->1 133->1 133->1 133->97 133->125 134->1 135->1 135->45 135->69 135->99 135->99 135->105 135->119 135->119 135->119 135->127 135->127 135->144 135->146 136->119 137->1 138->1 138->1 138->128 139->128 140->1 140->1 140->1 140->145 140->146 140->183 140->184 141->96 141->130 141->137 144->1 144->1 144->1 144->98 144->127 144->128 144->128 144->128 144->135 144->138 144->138 144->138 144->146 145->1 145->146 146->1 146->1 146->1 146->45 146->69 146->99 146->99 146->105 146->125 146->127 146->135 146->144 146->149 148->1 149->1 149->45 149->69 149->99 149->99 149->105 149->125 149->127 149->140 149->140 149->140 149->146 149->146 150->140 151->1 152->96 152->148 152->151
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { FILE * fi = fopen ( "\x43\x3a\x5c\x5c\x63\x6a\x69\x6e\x70\x75\x74\x73\x5c\x5c\x65\x6c\x65\x6d\x5c\x5c\x73\x6d\x61\x6c\x6c\x32\x2e\x69\x6e\x0" , "r" ) ; FILE * fo = fopen ( "C:\\cjinputs\\elem\\small.txt" , "w" ) ; if ( fi == 0 || fo == 0 ) eout ( "Could not open file(s)" ) ; char * line = xmalloc ( LINE_MAX ) ; if ( fgets ( line , LINE_MAX , fi ) == 0 ) eout ( "Input error" ) ; int total_inputs = atoi ( line ) ; int counter ; for ( counter = 0 ; counter < total_inputs ; counter ++ ) { if ( fgets ( line , LINE_MAX , fi ) == 0 ) eout ( "Input error" ) ; printf ( "\nNew Read\n" ) ; int i ; int n_com = atoi ( strtok ( line , " " ) ) ; char com1 [ n_com ] ; char com2 [ n_com ] ; char comO [ n_com ] ; char * tempc = xmalloc ( 4 ) ; for ( i = 0 ; i < n_com ; i ++ ) { strcpy ( tempc , strtok ( 0 , " " ) ) ; com1 [ i ] = * tempc ; com2 [ i ] = * ( tempc + 1 ) ; comO [ i ] = * ( tempc + 2 ) ; } free ( tempc ) ; int n_opp = atoi ( strtok ( 0 , " " ) ) ; char opp1 [ n_opp ] ; char opp2 [ n_opp ] ; char * tempo = xmalloc ( 3 ) ; for ( i = 0 ; i < n_opp ; i ++ ) { strcpy ( tempo , strtok ( 0 , " " ) ) ; opp1 [ i ] = * tempo ; opp2 [ i ] = * ( tempo + 1 ) ; } free ( tempo ) ; int n_elm = atoi ( strtok ( 0 , " " ) ) ; char * input = xmalloc ( n_elm + 1 ) ; strcpy ( input , strtok ( 0 , " " ) ) ; int out_ptr = 0 ; char * output = xmalloc ( n_elm + 1 ) ; for ( i = 0 ; i < n_elm ; i ++ ) { char c = * ( input + i ) ; printf ( "\nInput is %c\n" , c ) ; * ( output + ( out_ptr ++ ) ) = c ; int x ; if ( out_ptr > 1 ) { if ( ( x = arr_cont ( com1 , n_com , c ) ) != - 1 ) { if ( * ( output + out_ptr - 2 ) == com2 [ x ] ) { * ( output + ( out_ptr -- ) - 2 ) = comO [ x ] ; c = ( char ) 0 ; printf ( "  pair found\n" ) ; } else { } } else if ( ( x = arr_cont ( com2 , n_com , c ) ) != - 1 ) { if ( * ( output + out_ptr - 2 ) == com1 [ x ] ) { * ( output + ( out_ptr -- ) - 2 ) = comO [ x ] ; c = ( char ) 0 ; printf ( "  pair found\n" ) ; } else { } } } if ( out_ptr > 1 && c != ( char ) 0 ) { if ( n_opp > 0 ) { if ( ( x = arr_cont ( opp1 , n_opp , c ) ) != - 1 ) { if ( arr_cont ( output , out_ptr , opp2 [ x ] ) != - 1 ) { out_ptr = 0 ; printf ( "  opp found: %c & %c. string was %s. len was %d\n" , opp1 [ x ] , opp2 [ x ] , output , out_ptr ) ; } } else if ( ( x = arr_cont ( opp2 , n_opp , c ) ) != - 1 ) { if ( arr_cont ( output , out_ptr , opp1 [ x ] ) != - 1 ) { out_ptr = 0 ; printf ( "  opp found: %c & %c. string was %s. len was %d\n" , opp1 [ x ] , opp2 [ x ] , output , out_ptr ) ; } } } } * ( output + out_ptr ) = '\0' ; printf ( "I = %d: Output string is: %s\n" , i , output ) ; } printf ( "Output string is: %s\n" , output ) ; char * f_output = xmalloc ( LINE_MAX ) ; if ( out_ptr == 0 ) { sprintf ( f_output , "Case #%d: []\n" , counter + 1 ) ; } else { sprintf ( f_output , "Case #%d: [" , counter + 1 ) ; char * temp = xmalloc ( LINE_MAX ) ; for ( i = 0 ; i < out_ptr - 1 ; i ++ ) { sprintf ( temp , "%c, " , output [ i ] ) ; strcat ( f_output , temp ) ; } sprintf ( temp , "%c]\n" , output [ i ] ) ; strcat ( f_output , temp ) ; free ( temp ) ; } fputs ( f_output , fo ) ; free ( f_output ) ; } return 0 ; }
>>>Func
METHOD ecrit_fichier
METHOD_RETURN void
PARAM char * texte
fprintf fprintf ( fichier_cible , "%s" , texte )
<operator>.equals fichier_cible == NULL
fprintf fprintf ( stderr , "\x50\x42\x5c\x6e\x0" )
exit exit ( 1 )
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->3 3->1 3->1 3->1 4->1 4->1 4->3 4->5 4->6 5->1 5->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void ecrit_fichier ( char * texte ) { if ( fichier_cible == NULL ) { fprintf ( stderr , "\x50\x42\x5c\x6e\x0" ) ; exit ( 1 ) ; } fprintf ( fichier_cible , "%s" , texte ) ; }
>>>Func
METHOD merge
METHOD_RETURN void
<operator>.assignment * temp1 = head1
<operator>.assignment * temp2 = head2
<operator>.assignment * holder1 = NULL
<operator>.assignment * holder2 = NULL
<operator>.logicalAnd temp1 != NULL && temp2 != NULL
<operator>.assignment holder1 = temp1 -> next
<operator>.assignment temp1 -> next = temp2
<operator>.assignment temp1 = holder1
<operator>.assignment temp2 = holder2
<operator>.notEquals temp1 != NULL
<operator>.notEquals temp2 != NULL
<operator>.notEquals holder1 != NULL
<operator>.assignment holder2 = temp2 -> next
<operator>.assignment temp2 -> next = holder1
<operator>.indirectFieldAccess temp1 -> next
<operator>.indirectFieldAccess temp1 -> next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess temp2 -> next
<operator>.indirectFieldAccess temp2 -> next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
>>>PDG&24 0->2 0->3 0->4 0->5 0->8 0->9 0->10 0->11 0->12 0->13 0->15 2->1 2->1 2->11 3->1 3->1 3->1 3->8 3->12 4->1 4->1 5->1 5->1 5->10 6->1 6->1 6->1 6->6 6->7 6->8 6->9 6->10 6->11 6->13 6->16 6->17 6->18 6->19 7->1 7->13 8->1 8->1 8->7 9->1 9->1 9->11 10->1 10->1 10->1 10->8 10->12 11->1 11->1 11->6 11->6 11->12 11->12 11->13 12->1 12->1 12->6 12->6 12->8 12->13 13->1 13->9 13->11 13->14 13->15 13->15 13->20 13->21 13->22 13->23 14->1 14->10 15->1 15->1 15->14
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void merge ( ) { struct node * temp1 = head1 ; struct node * temp2 = head2 ; struct node * holder1 = NULL ; struct node * holder2 = NULL ; while ( temp1 != NULL && temp2 != NULL ) { holder1 = temp1 -> next ; temp1 -> next = temp2 ; if ( holder1 != NULL ) { holder2 = temp2 -> next ; temp2 -> next = holder1 ; } temp1 = holder1 ; temp2 = holder2 ; } }
>>>Func
METHOD work
METHOD_RETURN void
PARAM int num
initial initial ( )
fscanf fscanf ( fin , "\x25\x64\x0" , & C )
fscanf fscanf ( fin , "%d" , & D )
fscanf fscanf ( fin , "%d %s" , & N , temp )
fprintf fprintf ( fout , "Case #%d: [" , num )
<operator>.lessThan i < C
<operator>.preIncrement ++ i
<operator>.lessThan i < D
<operator>.preIncrement ++ i
<operator>.lessThan i < N
<operator>.preIncrement ++ i
<operator>.lessThan i < top
<operator>.preIncrement ++ i
<operator>.notEquals top != - 1
<operator>.assignment i = 0
fscanf fscanf ( fin , "%s" , temp )
<operator>.assignment map [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ] = temp [ 2 ] - 'A'
<operator>.assignment map [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ] = temp [ 2 ] - 'A'
<operator>.assignment i = 0
fscanf fscanf ( fin , "%s" , temp )
<operator>.assignment flush [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ] = 1
<operator>.assignment flush [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ] = 1
<operator>.assignment i = 0
<operator>.assignment stack [ ++ top ] = temp [ i ]
<operator>.postIncrement inStack [ stack [ top ] - 'A' ] ++
<operator>.assignment i = 0
fprintf fprintf ( fout , "%c, " , stack [ i ] )
fprintf fprintf ( fout , "%c]\n" , stack [ top ] )
<operator>.greaterThan top > 0
<operator>.minus - 1
fprintf fprintf ( fout , "]\n" )
<operator>.subtraction temp [ 2 ] - 'A'
<operator>.subtraction temp [ 2 ] - 'A'
reduce reduce ( )
doFlush doFlush ( )
<operator>.subtraction temp [ 1 ] - 'A'
<operator>.subtraction temp [ 0 ] - 'A'
<operator>.subtraction temp [ 1 ] - 'A'
<operator>.subtraction temp [ 0 ] - 'A'
<operator>.preIncrement ++ top
<operator>.subtraction stack [ top ] - 'A'
<operator>.subtraction temp [ 0 ] - 'A'
<operator>.subtraction temp [ 1 ] - 'A'
<operator>.subtraction temp [ 0 ] - 'A'
<operator>.subtraction temp [ 1 ] - 'A'
<operator>.indirectIndexAccess map [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ]
<operator>.indirectIndexAccess map [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ]
<operator>.indirectIndexAccess flush [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ]
<operator>.indirectIndexAccess flush [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ]
<operator>.indirectIndexAccess stack [ ++ top ]
<operator>.indirectIndexAccess temp [ i ]
<operator>.indirectIndexAccess inStack [ stack [ top ] - 'A' ]
<operator>.indirectIndexAccess stack [ i ]
<operator>.indirectIndexAccess stack [ top ]
<operator>.indirectIndexAccess map [ temp [ 0 ] - 'A' ]
<operator>.indirectIndexAccess temp [ 2 ]
<operator>.indirectIndexAccess map [ temp [ 1 ] - 'A' ]
<operator>.indirectIndexAccess temp [ 2 ]
<operator>.indirectIndexAccess flush [ temp [ 0 ] - 'A' ]
<operator>.indirectIndexAccess flush [ temp [ 1 ] - 'A' ]
<operator>.indirectIndexAccess temp [ 1 ]
<operator>.indirectIndexAccess temp [ 0 ]
<operator>.indirectIndexAccess temp [ 1 ]
<operator>.indirectIndexAccess temp [ 0 ]
<operator>.indirectIndexAccess stack [ top ]
<operator>.indirectIndexAccess temp [ 0 ]
<operator>.indirectIndexAccess temp [ 1 ]
<operator>.indirectIndexAccess temp [ 0 ]
<operator>.indirectIndexAccess temp [ 1 ]
>>>PDG&72 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->21 0->22 0->23 0->24 0->25 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 2->7 3->1 4->1 4->1 4->5 4->8 4->18 5->1 5->1 5->6 5->10 5->22 6->1 6->1 6->1 6->1 6->12 6->26 7->1 7->1 7->29 7->30 7->33 8->1 8->1 8->8 8->9 8->9 8->18 8->19 8->20 8->34 8->35 8->38 8->39 8->44 8->45 8->48 8->49 8->57 8->58 8->59 8->60 8->63 8->64 8->68 8->69 9->1 9->8 10->1 10->1 10->10 10->11 10->11 10->22 10->23 10->24 10->40 10->41 10->46 10->47 10->50 10->51 10->61 10->62 10->65 10->66 10->70 10->71 11->1 11->10 12->1 12->1 12->12 12->13 12->13 12->26 12->27 12->31 12->42 12->43 12->52 12->53 12->54 12->67 13->1 13->12 14->1 14->1 14->14 14->15 14->15 14->16 14->29 14->55 15->1 15->14 16->1 16->1 16->1 16->30 16->33 16->56 17->8 18->1 18->5 18->6 18->22 18->34 18->35 18->38 18->39 18->44 18->45 19->1 19->1 20->1 20->1 20->1 21->10 22->1 22->6 22->6 22->40 22->41 22->46 22->47 23->1 23->1 24->1 24->1 25->12 26->1 26->1 26->1 27->1 27->1 28->1 28->14 29->1 29->1 29->30 29->33 30->1 30->1 30->1 31->1 31->14 31->36 31->37 31->42 32->16 34->19 34->19 34->35 35->1 35->6 35->18 35->20 35->20 35->22 35->34 36->1 37->1 38->45 39->1 39->6 39->18 39->22 39->44 39->46 40->47 41->1 41->6 41->22 41->46 42->31 43->30 44->39 45->1 45->6 45->18 45->22 45->38 45->40 46->41 47->1 47->6 47->22 47->40
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  void work ( int num ) { int i , j ; char temp [ 200 ] ; initial ( ) ; fscanf ( fin , "\x25\x64\x0" , & C ) ; for ( i = 0 ; i < C ; ++ i ) { fscanf ( fin , "%s" , temp ) ; map [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ] = temp [ 2 ] - 'A' ; map [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ] = temp [ 2 ] - 'A' ; } fscanf ( fin , "%d" , & D ) ; for ( i = 0 ; i < D ; ++ i ) { fscanf ( fin , "%s" , temp ) ; flush [ temp [ 0 ] - 'A' ] [ temp [ 1 ] - 'A' ] = 1 ; flush [ temp [ 1 ] - 'A' ] [ temp [ 0 ] - 'A' ] = 1 ; } fscanf ( fin , "%d %s" , & N , temp ) ; for ( i = 0 ; i < N ; ++ i ) { stack [ ++ top ] = temp [ i ] ; inStack [ stack [ top ] - 'A' ] ++ ; if ( top > 0 ) { reduce ( ) ; doFlush ( ) ; } } fprintf ( fout , "Case #%d: [" , num ) ; for ( i = 0 ; i < top ; ++ i ) { fprintf ( fout , "%c, " , stack [ i ] ) ; } if ( top != - 1 ) fprintf ( fout , "%c]\n" , stack [ top ] ) ; else fprintf ( fout , "]\n" ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment ii = 0
<operator>.assignment input = fopen ( "\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x32\x2e\x69\x6e\x0" , "r" )
<operator>.assignment output = fopen ( "test.out" , "w+" )
fscanf fscanf ( input , " %ld\n" , & cases )
fclose fclose ( input )
fclose fclose ( output )
RETURN return 0 ; return 0 ;
<operator>.lessThan ii ++ < cases
LITERAL 0 return 0 ;
fopen fopen ( "\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x32\x2e\x69\x6e\x0" , "r" )
fopen fopen ( "test.out" , "w+" )
<operator>.assignment CommonFactor = 1
fscanf fscanf ( input , " %ld %ld %ld" , & n , & d , & g )
<operator>.assignment WinMost = g
<operator>.assignment LoseMost = 100 - g
<operator>.assignment WinMin = d
<operator>.assignment LoseMin = 100 / CommonFactor - d
<operator>.postIncrement ii ++
<operator>.lessThan i < 2
<operator>.postIncrement i ++
<operator>.lessThan i < 2
<operator>.postIncrement i ++
<operator>.greaterThan LoseMin + WinMin > n
<operator>.subtraction 100 - g
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.subtraction 100 / CommonFactor - d
fprintf fprintf ( output , "Case #%ld: Broken\n" , ii )
<operator>.equals ( d % 2 ) == 0
<operator>.equals ( d % 5 ) == 0
<operator>.division 100 / CommonFactor
<operator>.addition LoseMin + WinMin
<operator>.assignment d = d / 2
<operator>.assignmentMultiplication CommonFactor *= 2
<operator>.assignment d = d / 5
<operator>.assignmentMultiplication CommonFactor *= 5
<operator>.logicalOr ( ( WinMost == 0 ) && ( WinMin > 0 ) ) || ( ( LoseMost == 0 ) && ( LoseMin > 0 ) )
<operator>.modulo d % 2
<operator>.modulo d % 5
fprintf fprintf ( output , "Case #%ld: Broken\n" , ii )
<operator>.division d / 2
<operator>.division d / 5
<operator>.logicalAnd ( WinMost == 0 ) && ( WinMin > 0 )
<operator>.logicalAnd ( LoseMost == 0 ) && ( LoseMin > 0 )
fprintf fprintf ( output , "Case #%ld: Possible\n" , ii )
<operator>.equals WinMost == 0
<operator>.greaterThan WinMin > 0
<operator>.equals LoseMost == 0
<operator>.greaterThan LoseMin > 0
<operator>.addressOf & n
<operator>.addressOf & d
<operator>.addressOf & g
>>>PDG&54 0->2 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->37 0->39 0->40 0->41 0->42 0->43 0->46 0->47 0->48 0->49 0->50 2->1 2->19 3->1 3->1 3->5 4->1 4->1 4->7 4->29 4->41 4->46 5->1 5->1 5->6 5->9 5->14 6->1 6->1 7->1 7->1 8->1 9->1 9->1 9->1 9->9 9->13 9->14 9->15 9->16 9->17 9->18 9->19 9->20 9->22 9->24 9->25 9->26 9->27 9->28 9->32 9->33 9->51 9->52 9->53 10->8 11->3 11->3 12->4 12->4 13->1 13->32 13->35 13->37 14->1 14->1 14->1 14->1 14->6 14->15 14->17 14->24 14->25 14->28 14->39 14->40 14->42 14->43 15->1 15->1 15->47 16->1 16->1 16->1 16->49 17->1 17->24 17->33 17->48 18->1 18->1 18->24 18->33 18->50 19->1 19->9 19->29 19->41 19->46 20->21 20->30 20->39 21->1 21->20 22->1 22->1 22->23 22->31 22->40 23->1 23->22 24->1 24->1 24->1 24->14 24->29 24->38 24->44 24->47 25->1 25->14 25->15 25->16 25->16 26->20 27->1 27->22 28->1 28->1 28->14 28->17 28->18 28->18 28->39 28->40 29->1 29->7 29->19 29->41 29->46 30->1 30->1 30->20 30->21 30->34 30->35 30->42 31->1 31->1 31->22 31->23 31->36 31->37 31->43 32->1 32->28 32->28 33->1 33->1 34->1 34->1 34->17 34->28 34->39 34->40 35->1 35->32 35->37 36->1 36->1 36->17 36->28 36->40 37->1 37->32 38->1 38->1 38->1 38->41 38->46 39->17 39->28 39->30 39->30 39->40 39->42 40->17 40->28 40->31 40->31 40->43 41->1 41->7 41->19 41->29 41->46 42->34 42->34 43->36 43->36 44->1 44->1 44->38 44->38 44->45 44->49 45->1 45->1 45->38 45->38 46->1 46->7 46->19 46->29 46->41 47->1 47->44 47->44 47->48 48->1 48->44 48->44 49->1 49->45 49->45 49->50 50->1 50->45 50->45
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { FILE * input , * output ; long int cases , ii = 0 ; input = fopen ( "\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x32\x2e\x69\x6e\x0" , "r" ) ; output = fopen ( "test.out" , "w+" ) ; fscanf ( input , " %ld\n" , & cases ) ; while ( ii ++ < cases ) { long int n , d , g , i ; long int WinMost , LoseMost , WinMin , LoseMin , CommonFactor = 1 ; fscanf ( input , " %ld %ld %ld" , & n , & d , & g ) ; WinMost = g ; LoseMost = 100 - g ; for ( i = 0 ; i < 2 ; i ++ ) { if ( ( d % 2 ) == 0 ) { d = d / 2 ; CommonFactor *= 2 ; } else { break ; } } for ( i = 0 ; i < 2 ; i ++ ) { if ( ( d % 5 ) == 0 ) { d = d / 5 ; CommonFactor *= 5 ; } else { break ; } } WinMin = d ; LoseMin = 100 / CommonFactor - d ; if ( LoseMin + WinMin > n ) { fprintf ( output , "Case #%ld: Broken\n" , ii ) ; } else { if ( ( ( WinMost == 0 ) && ( WinMin > 0 ) ) || ( ( LoseMost == 0 ) && ( LoseMin > 0 ) ) ) { fprintf ( output , "Case #%ld: Broken\n" , ii ) ; } else { fprintf ( output , "Case #%ld: Possible\n" , ii ) ; } } } fclose ( input ) ; fclose ( output ) ; return 0 ; }
>>>Func
METHOD ctest
METHOD_RETURN char
PARAM char a
PARAM char b
RETURN return '@' ; return '@' ;
<operator>.lessThan i < c
<operator>.postIncrement i ++
LITERAL '@' return '@' ;
<operator>.assignment i = 0
<operator>.logicalOr ( a == combine [ i ] [ 0 ] && b == combine [ i ] [ 1 ] ) || ( a == combine [ i ] [ 1 ] && b == combine [ i ] [ 0 ] )
RETURN return combine [ i ] [ 2 ] ; return combine [ i ] [ 2 ] ;
<operator>.logicalAnd a == combine [ i ] [ 0 ] && b == combine [ i ] [ 1 ]
<operator>.logicalAnd a == combine [ i ] [ 1 ] && b == combine [ i ] [ 0 ]
<operator>.equals a == combine [ i ] [ 0 ]
<operator>.equals b == combine [ i ] [ 1 ]
<operator>.equals a == combine [ i ] [ 1 ]
<operator>.equals b == combine [ i ] [ 0 ]
<operator>.indirectIndexAccess combine [ i ] [ 2 ]
<operator>.indirectIndexAccess combine [ i ] [ 0 ]
<operator>.indirectIndexAccess combine [ i ] [ 1 ]
<operator>.indirectIndexAccess combine [ i ] [ 1 ]
<operator>.indirectIndexAccess combine [ i ] [ 0 ]
<operator>.indirectIndexAccess combine [ i ]
<operator>.indirectIndexAccess combine [ i ]
<operator>.indirectIndexAccess combine [ i ]
<operator>.indirectIndexAccess combine [ i ]
<operator>.indirectIndexAccess combine [ i ]
>>>PDG&27 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->13 0->14 0->15 0->16 2->13 3->1 3->14 3->16 4->1 5->1 5->1 5->1 5->4 5->6 5->9 5->11 5->13 5->18 5->23 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->1 9->5 9->6 9->10 9->17 9->22 10->1 11->1 11->1 11->9 11->9 11->12 11->15 11->20 11->25 12->1 12->1 12->9 12->9 13->1 13->1 13->11 13->11 13->14 13->15 13->16 13->19 13->24 14->1 14->1 14->11 14->11 14->15 14->16 15->1 15->1 15->12 15->12 15->13 15->14 15->16 15->21 15->26 16->1 16->1 16->12 16->12 16->13 16->14
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) char ctest ( char a , char b ) { int i ; for ( i = 0 ; i < c ; i ++ ) { if ( ( a == combine [ i ] [ 0 ] && b == combine [ i ] [ 1 ] ) || ( a == combine [ i ] [ 1 ] && b == combine [ i ] [ 0 ] ) ) { return combine [ i ] [ 2 ] ; } } return '@' ; }
>>>Func
METHOD JSHash
METHOD_RETURN unsigned int
PARAM char * str
PARAM unsigned int len
<operator>.assignment hash = 1315423911
<operator>.assignment i = 0
RETURN return hash ; return hash ;
<operator>.lessThan i < len
<operator>.expressionList str ++   i ++
IDENTIFIER hash return hash ;
<operator>.assignment i = 0
<operators>.assignmentXor hash ^= ( ( hash << 5 ) + ( * str ) + ( hash >> 2 ) )
<operator>.postIncrement str ++
<operator>.postIncrement i ++
<operator>.addition ( hash << 5 ) + ( * str ) + ( hash >> 2 )
<operator>.addition ( hash << 5 ) + ( * str )
<operator>.arithmeticShiftRight hash >> 2
<operator>.shiftLeft hash << 5
<operator>.indirection * str
>>>PDG&19 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->11 0->12 0->13 0->16 0->17 2->1 2->12 3->7 4->1 4->1 4->9 4->17 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->13 7->13 7->14 7->15 7->16 7->17 7->18 8->1 8->1 8->1 9->6 10->1 10->7 11->1 11->1 11->9 11->17 12->1 12->8 13->7 13->8 14->1 14->1 15->1 15->1 16->11 16->11 16->14 16->14 17->11 17->11 17->14 17->14 17->15 17->15 17->16
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) unsigned int JSHash ( char * str , unsigned int len ) { unsigned int hash = 1315423911 ; unsigned int i = 0 ; for ( i = 0 ; i < len ; str ++ , i ++ ) { hash ^= ( ( hash << 5 ) + ( * str ) + ( hash >> 2 ) ) ; } return hash ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & testcases )
<operator>.lessThan x < testcases
<operator>.postIncrement x ++
<operator>.assignment x = 0
scanf scanf ( "%d" , & subcase )
str_cmp str_cmp ( fstr , subcase )
scanf scanf ( "%d" , & the )
str_cmp str_cmp ( sstr , the )
scanf scanf ( "%d" , & an )
scanf scanf ( "%s" , tstr )
<operator>.assignment k = 0
<operator>.assignment fostr [ 0 ] = tstr [ 0 ]
<operator>.assignment fostr [ k + 1 ] = '\0'
printf printf ( "Case #%d: [" , x + 1 )
printf printf ( "%s" , fostr + k )
printf printf ( "]\n" )
<operator>.lessThan i < subcase
<operator>.postIncrement i ++
<operator>.lessThan i < the
<operator>.postIncrement i ++
<operator>.lessThan i < an
<operator>.postIncrement i ++
<operator>.lessThan i < k
<operator>.postIncrement i ++
printf printf ( "%c, " , fostr [ i ] )
<operator>.assignment i = 0
scanf scanf ( "%s" , fstr [ i ] )
<operator>.assignment maximum = MAX ( fstr [ i ] [ 0 ] , fstr [ i ] [ 1 ] )
<operator>.assignment minimum = MIN ( fstr [ i ] [ 0 ] , fstr [ i ] [ 1 ] )
<operator>.assignment fstr [ i ] [ 0 ] = minimum
<operator>.assignment fstr [ i ] [ 1 ] = maximum
<operator>.assignment fstr [ i ] [ 3 ] = '\0'
<operator>.assignment i = 0
scanf scanf ( "%s" , sstr [ i ] )
<operator>.assignment maximum = MAX ( sstr [ i ] [ 0 ] , sstr [ i ] [ 1 ] )
<operator>.assignment minimum = MIN ( sstr [ i ] [ 0 ] , sstr [ i ] [ 1 ] )
<operator>.assignment sstr [ i ] [ 0 ] = minimum
<operator>.assignment sstr [ i ] [ 1 ] = maximum
<operator>.assignment sstr [ i ] [ 2 ] = '\0'
<operator>.assignment i = 1
<operator>.assignment option = 0
<operator>.assignment maximum = MAX ( fostr [ k ] , tstr [ i ] )
<operator>.assignment minimum = MIN ( fostr [ k ] , tstr [ i ] )
<operator>.assignment fostr [ k + 1 ] = '\0'
<operator>.addition x + 1
<operator>.assignment i = 0
<operator>.addition fostr + k
<operator>.lessThan j < subcase
<operator>.postIncrement j ++
<operator>.equals option == 0
<operator>.equals option == 0
<operator>.addition k + 1
MAX MAX ( fstr [ i ] [ 0 ] , fstr [ i ] [ 1 ] )
MIN MIN ( fstr [ i ] [ 0 ] , fstr [ i ] [ 1 ] )
MAX MAX ( sstr [ i ] [ 0 ] , sstr [ i ] [ 1 ] )
MIN MIN ( sstr [ i ] [ 0 ] , sstr [ i ] [ 1 ] )
MAX MAX ( fostr [ k ] , tstr [ i ] )
MIN MIN ( fostr [ k ] , tstr [ i ] )
<operator>.assignment j = 0
<operator>.assignment fostr [ ++ k ] = tstr [ i ]
<operator>.equals minimum == fstr [ j ] [ 0 ]
<operator>.lessThan j < the
<operator>.postIncrement j ++
<operator>.addition k + 1
<operator>.assignment j = 0
<operator>.assignment temp = strrchr ( sstr [ j ] , tstr [ i ] )
<operator>.equals maximum == fstr [ j ] [ 1 ]
<operator>.notEquals temp != NULL
<operator>.preIncrement ++ k
<operator>.assignment fostr [ k ] = fstr [ j ] [ 2 ]
<operator>.assignment option = 1
<operator>.greaterThan minimum > fstr [ j ] [ 0 ]
strrchr strrchr ( sstr [ j ] , tstr [ i ] )
<operator>.lessEqualsThan l <= k
<operator>.postIncrement l ++
<operator>.equals option == - 1
<operator>.greaterThan maximum > fstr [ j ] [ 1 ]
<operator>.assignment l = 0
<operator>.equals sstr [ j ] [ sstr [ j ] - temp + 1 ] == fostr [ l ]
<operator>.minus - 1
<operator>.assignment k = 0
<operator>.assignment fostr [ k ] = tstr [ i + 1 ]
<operator>.postIncrement i ++
<operator>.assignment option = - 1
<operator>.addition sstr [ j ] - temp + 1
<operator>.minus - 1
<operator>.subtraction sstr [ j ] - temp
<operator>.addition i + 1
<operator>.addressOf & subcase
<operator>.addressOf & the
<operator>.addressOf & an
<operator>.indirectIndexAccess fostr [ 0 ]
<operator>.indirectIndexAccess tstr [ 0 ]
<operator>.indirectIndexAccess fostr [ k + 1 ]
<operator>.indirectIndexAccess fostr [ i ]
<operator>.indirectIndexAccess fstr [ i ]
<operator>.indirectIndexAccess fstr [ i ] [ 0 ]
<operator>.indirectIndexAccess fstr [ i ] [ 1 ]
<operator>.indirectIndexAccess fstr [ i ] [ 3 ]
<operator>.indirectIndexAccess sstr [ i ]
<operator>.indirectIndexAccess sstr [ i ] [ 0 ]
<operator>.indirectIndexAccess sstr [ i ] [ 1 ]
<operator>.indirectIndexAccess sstr [ i ] [ 2 ]
<operator>.indirectIndexAccess fostr [ k + 1 ]
<operator>.indirectIndexAccess fstr [ i ] [ 0 ]
<operator>.indirectIndexAccess fstr [ i ] [ 1 ]
<operator>.indirectIndexAccess fstr [ i ] [ 0 ]
<operator>.indirectIndexAccess fstr [ i ] [ 1 ]
<operator>.indirectIndexAccess fstr [ i ]
<operator>.indirectIndexAccess fstr [ i ]
<operator>.indirectIndexAccess fstr [ i ]
<operator>.indirectIndexAccess sstr [ i ] [ 0 ]
<operator>.indirectIndexAccess sstr [ i ] [ 1 ]
<operator>.indirectIndexAccess sstr [ i ] [ 0 ]
<operator>.indirectIndexAccess sstr [ i ] [ 1 ]
<operator>.indirectIndexAccess sstr [ i ]
<operator>.indirectIndexAccess sstr [ i ]
<operator>.indirectIndexAccess sstr [ i ]
<operator>.indirectIndexAccess fostr [ k ]
<operator>.indirectIndexAccess tstr [ i ]
<operator>.indirectIndexAccess fostr [ k ]
<operator>.indirectIndexAccess tstr [ i ]
<operator>.indirectIndexAccess fstr [ i ]
<operator>.indirectIndexAccess fstr [ i ]
<operator>.indirectIndexAccess fstr [ i ]
<operator>.indirectIndexAccess fstr [ i ]
<operator>.indirectIndexAccess sstr [ i ]
<operator>.indirectIndexAccess sstr [ i ]
<operator>.indirectIndexAccess sstr [ i ]
<operator>.indirectIndexAccess sstr [ i ]
<operator>.indirectIndexAccess fostr [ ++ k ]
<operator>.indirectIndexAccess tstr [ i ]
<operator>.indirectIndexAccess fstr [ j ] [ 0 ]
<operator>.indirectIndexAccess fstr [ j ]
<operator>.indirectIndexAccess fstr [ j ] [ 1 ]
<operator>.indirectIndexAccess sstr [ j ]
<operator>.indirectIndexAccess tstr [ i ]
<operator>.indirectIndexAccess fstr [ j ]
<operator>.indirectIndexAccess fostr [ k ]
<operator>.indirectIndexAccess fstr [ j ] [ 2 ]
<operator>.indirectIndexAccess fstr [ j ] [ 0 ]
<operator>.indirectIndexAccess fstr [ j ]
<operator>.indirectIndexAccess fstr [ j ]
<operator>.indirectIndexAccess fstr [ j ] [ 1 ]
<operator>.indirectIndexAccess fstr [ j ]
<operator>.indirectIndexAccess sstr [ j ] [ sstr [ j ] - temp + 1 ]
<operator>.indirectIndexAccess fostr [ l ]
<operator>.indirectIndexAccess sstr [ j ]
<operator>.indirectIndexAccess fostr [ k ]
<operator>.indirectIndexAccess tstr [ i + 1 ]
<operator>.indirectIndexAccess sstr [ j ]
>>>PDG&153 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->31 0->32 0->33 0->34 0->38 0->39 0->40 0->41 0->42 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->58 0->59 0->60 0->62 0->63 0->64 0->65 0->66 0->68 0->69 0->70 0->72 0->73 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->84 0->86 0->87 0->88 0->89 2->1 2->3 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->7 3->8 3->9 3->10 3->11 3->12 3->13 3->14 3->15 3->15 3->16 3->17 3->18 3->20 3->22 3->24 3->27 3->34 3->41 3->46 3->46 3->47 3->48 3->53 3->90 3->91 3->92 3->93 3->94 3->95 4->1 4->3 5->1 5->3 6->1 6->7 6->18 6->49 7->1 7->1 7->1 7->6 7->18 7->28 7->49 8->1 8->9 8->20 8->63 9->1 9->1 9->1 9->8 9->20 9->35 9->63 9->74 9->88 10->1 10->22 11->1 11->13 11->58 11->59 11->61 11->74 11->83 12->1 12->24 12->53 12->65 12->70 12->75 13->1 13->1 13->1 13->16 13->26 13->48 13->58 13->59 13->80 14->1 14->1 14->16 14->26 14->48 14->58 14->59 14->80 15->1 15->1 16->1 16->1 17->1 18->1 18->7 18->18 18->19 18->19 18->28 18->29 18->30 18->31 18->32 18->33 18->54 18->55 18->97 18->98 18->99 18->100 18->106 18->107 18->108 18->109 18->110 18->111 18->112 18->124 18->125 18->126 18->127 19->1 19->18 20->1 20->9 20->20 20->21 20->21 20->35 20->36 20->37 20->38 20->39 20->40 20->56 20->57 20->101 20->102 20->103 20->104 20->113 20->114 20->115 20->116 20->117 20->118 20->119 20->128 20->129 20->130 20->131 21->1 21->20 22->1 22->1 22->10 22->22 22->23 22->23 22->42 22->43 22->44 22->45 22->49 22->51 22->52 22->58 22->59 22->60 22->65 22->84 22->89 22->105 22->120 22->121 22->122 22->123 23->1 23->22 24->1 24->1 24->16 24->24 24->25 24->25 24->26 24->48 24->96 25->1 25->24 26->1 26->1 26->16 26->48 26->58 26->59 26->80 27->18 28->1 28->7 29->1 29->1 29->32 30->1 30->1 30->31 31->1 31->1 31->1 31->28 31->54 32->1 32->1 32->1 32->28 32->54 33->1 33->1 33->28 34->20 35->1 35->9 36->1 36->1 36->39 37->1 37->1 37->38 38->1 38->1 38->1 38->35 38->56 39->1 39->1 39->1 39->35 39->56 40->1 40->1 40->35 41->1 41->22 42->1 42->51 43->1 43->1 43->1 43->68 44->1 44->1 44->1 44->62 47->1 47->24 48->1 48->1 49->1 49->1 49->1 49->6 49->18 49->50 49->62 49->134 49->135 50->1 50->49 51->52 51->63 51->66 51->77 52->1 52->1 52->61 52->70 52->132 52->133 54->29 54->29 54->55 54->55 55->30 55->30 56->36 56->36 56->57 56->57 57->37 57->37 58->43 58->43 58->59 58->59 59->1 59->1 59->11 59->16 59->26 59->44 59->44 59->48 59->58 59->58 59->61 59->74 59->80 60->1 60->49 61->1 61->1 61->1 61->16 61->26 61->48 61->58 61->59 61->80 62->1 62->1 62->1 62->68 62->73 62->73 62->73 62->136 62->139 62->142 62->144 63->1 63->1 63->1 63->8 63->20 63->64 63->67 63->69 63->74 63->137 63->138 64->1 64->63 66->1 66->63 67->1 67->1 67->69 68->1 68->1 68->1 68->71 68->72 68->78 68->78 68->78 68->140 68->141 68->143 68->145 68->146 69->1 69->1 69->1 69->63 69->64 69->75 69->77 69->79 69->81 69->88 70->24 70->53 70->65 70->75 71->1 71->1 71->1 71->16 71->26 71->48 71->58 71->59 71->80 72->1 72->51 73->1 73->1 73->1 73->49 73->50 73->62 73->62 74->1 74->1 74->9 74->11 74->58 74->61 74->67 74->67 74->88 75->1 75->1 75->24 75->53 75->65 75->70 75->76 75->80 75->86 75->88 75->147 75->148 75->149 75->152 76->1 76->75 77->1 77->1 77->52 77->63 77->64 78->1 78->1 78->1 78->49 78->50 78->68 78->68 79->1 79->75 80->1 80->1 80->1 80->16 80->26 80->48 80->58 80->59 80->74 80->75 80->76 80->82 80->83 80->84 80->85 80->87 80->88 80->89 80->150 80->151 81->77 82->1 82->24 82->53 82->65 82->70 82->75 83->1 83->1 83->1 83->16 83->26 83->48 83->58 83->59 83->80 84->23 84->89 85->1 85->77 86->1 87->85 88->1 88->1 88->9 88->74 88->86 88->86
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int the , testcases , an , x , option ; char fstr [ 200 ] [ 4 ] , sstr [ 100 ] [ 4 ] ; scanf ( "\x25\x64\x0" , & testcases ) ; for ( x = 0 ; x < testcases ; x ++ ) { int subcase , i , j , k , l ; char tstr [ 150 ] , fostr [ 200 ] , minimum , maximum , * temp ; scanf ( "%d" , & subcase ) ; for ( i = 0 ; i < subcase ; i ++ ) { scanf ( "%s" , fstr [ i ] ) ; maximum = MAX ( fstr [ i ] [ 0 ] , fstr [ i ] [ 1 ] ) ; minimum = MIN ( fstr [ i ] [ 0 ] , fstr [ i ] [ 1 ] ) ; fstr [ i ] [ 0 ] = minimum ; fstr [ i ] [ 1 ] = maximum ; fstr [ i ] [ 3 ] = '\0' ; } str_cmp ( fstr , subcase ) ; scanf ( "%d" , & the ) ; for ( i = 0 ; i < the ; i ++ ) { scanf ( "%s" , sstr [ i ] ) ; maximum = MAX ( sstr [ i ] [ 0 ] , sstr [ i ] [ 1 ] ) ; minimum = MIN ( sstr [ i ] [ 0 ] , sstr [ i ] [ 1 ] ) ; sstr [ i ] [ 0 ] = minimum ; sstr [ i ] [ 1 ] = maximum ; sstr [ i ] [ 2 ] = '\0' ; } str_cmp ( sstr , the ) ; scanf ( "%d" , & an ) ; scanf ( "%s" , tstr ) ; k = 0 ; fostr [ 0 ] = tstr [ 0 ] ; for ( i = 1 ; i < an ; i ++ ) { option = 0 ; maximum = MAX ( fostr [ k ] , tstr [ i ] ) ; minimum = MIN ( fostr [ k ] , tstr [ i ] ) ; for ( j = 0 ; j < subcase ; j ++ ) { if ( minimum == fstr [ j ] [ 0 ] ) { if ( maximum == fstr [ j ] [ 1 ] ) { fostr [ k ] = fstr [ j ] [ 2 ] ; option = 1 ; break ; } else if ( maximum > fstr [ j ] [ 1 ] ) break ; } else if ( minimum > fstr [ j ] [ 0 ] ) break ; } if ( option == 0 ) { for ( j = 0 ; j < the ; j ++ ) { temp = strrchr ( sstr [ j ] , tstr [ i ] ) ; if ( temp != NULL ) { for ( l = 0 ; l <= k ; l ++ ) { if ( sstr [ j ] [ sstr [ j ] - temp + 1 ] == fostr [ l ] ) { k = 0 ; fostr [ k ] = tstr [ i + 1 ] ; i ++ ; option = - 1 ; break ; } } if ( option == - 1 ) break ; } } } if ( option == 0 ) fostr [ ++ k ] = tstr [ i ] ; fostr [ k + 1 ] = '\0' ; } fostr [ k + 1 ] = '\0' ; printf ( "Case #%d: [" , x + 1 ) ; for ( i = 0 ; i < k ; i ++ ) printf ( "%c, " , fostr [ i ] ) ; printf ( "%s" , fostr + k ) ; printf ( "]\n" ) ; } }
>>>Func
METHOD ParseInput
METHOD_RETURN int
PARAM char * pcszFileName
<operator>.assignment fp = fopen ( pcszFileName , "\x72\x0" )
fscanf fscanf ( fp , "%d " , & T )
<operator>.assignment fout = fopen ( "magica_out.txt" , "w" )
fclose fclose ( fp )
fclose fclose ( fout )
RETURN return 0 ; return 0 ;
<operator>.equals NULL == pcszFileName
<operator>.equals NULL == fp
<operator>.equals NULL == fout
<operator>.lessEqualsThan i <= T
<operator>.preIncrement ++ i
LITERAL 0 return 0 ;
RETURN return - 1 ; return - 1 ;
fopen fopen ( pcszFileName , "\x72\x0" )
printf printf ( "\nAccess denied file: %s" , pcszFileName )
RETURN return - 1 ; return - 1 ;
fopen fopen ( "magica_out.txt" , "w" )
printf printf ( "\nCannot create new file." )
RETURN return - 1 ; return - 1 ;
<operator>.assignment i = 1
fscanf fscanf ( fp , "%d " , & iPairs )
fscanf fscanf ( fp , "%d " , & iOpposites )
fscanf fscanf ( fp , "%d " , & iInputLength )
fscanf fscanf ( fp , "%s " , szInput )
<operator>.assignment iCntPairs = iPairs
<operator>.assignment iCntOpposites = iOpposites
fprintf fprintf ( fout , "Case #%d: " , i )
Process Process ( szInput )
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.greaterThan iPairs > C
<operator>.lessThan j < iPairs
<operator>.preIncrement ++ j
<operator>.greaterThan iOpposites > D
<operator>.lessThan j < iOpposites
<operator>.preIncrement ++ j
<operator>.greaterThan iInputLength > N
RETURN return - 1 ; return - 1 ;
<operator>.assignment j = 0
fscanf fscanf ( fp , "%s " , szPairs )
<operator>.assignment Pairs [ j ] [ 0 ] = szPairs [ 0 ]
<operator>.assignment Pairs [ j ] [ 1 ] = szPairs [ 1 ]
<operator>.assignment Pairs [ j ] [ 2 ] = szPairs [ 2 ]
RETURN return - 1 ; return - 1 ;
<operator>.assignment j = 0
fscanf fscanf ( fp , "%s " , szOpp )
<operator>.assignment Opposites [ j ] [ 0 ] = szOpp [ 0 ]
<operator>.assignment Opposites [ j ] [ 1 ] = szOpp [ 1 ]
RETURN return - 1 ; return - 1 ;
<operator>.minus - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.addressOf & T
<operator>.addressOf & iPairs
<operator>.addressOf & iOpposites
<operator>.addressOf & iInputLength
<operator>.indirectIndexAccess Pairs [ j ] [ 0 ]
<operator>.indirectIndexAccess szPairs [ 0 ]
<operator>.indirectIndexAccess Pairs [ j ] [ 1 ]
<operator>.indirectIndexAccess szPairs [ 1 ]
<operator>.indirectIndexAccess Pairs [ j ] [ 2 ]
<operator>.indirectIndexAccess szPairs [ 2 ]
<operator>.indirectIndexAccess Opposites [ j ] [ 0 ]
<operator>.indirectIndexAccess szOpp [ 0 ]
<operator>.indirectIndexAccess Opposites [ j ] [ 1 ]
<operator>.indirectIndexAccess szOpp [ 1 ]
<operator>.indirectIndexAccess Pairs [ j ]
<operator>.indirectIndexAccess Pairs [ j ]
<operator>.indirectIndexAccess Pairs [ j ]
<operator>.indirectIndexAccess Opposites [ j ]
<operator>.indirectIndexAccess Opposites [ j ]
>>>PDG&75 0->2 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->42 0->43 0->48 0->49 0->53 0->54 0->55 2->9 3->10 4->6 4->12 4->23 5->11 8->1 9->1 9->1 9->1 9->3 9->10 9->10 9->15 9->16 9->16 9->31 10->4 10->4 10->5 10->11 10->11 10->17 10->18 10->19 10->32 10->56 11->7 11->12 11->20 11->21 11->22 11->29 11->33 12->6 12->7 12->8 12->23 12->29 12->34 12->57 13->12 14->8 15->1 16->3 16->3 16->17 18->1 19->5 19->5 21->1 22->12 23->24 23->27 23->34 23->35 23->43 24->25 24->28 24->37 24->38 24->49 25->26 25->40 26->6 26->23 26->30 27->1 28->1 29->7 29->13 30->26 31->1 31->15 32->18 33->21 34->1 34->24 34->35 34->35 34->37 34->41 34->42 34->53 34->58 35->23 35->27 35->34 35->35 35->36 35->36 35->43 35->44 35->45 35->46 35->60 35->61 35->62 35->63 35->64 35->65 35->70 35->71 35->72 36->35 37->1 37->25 37->38 37->38 37->40 37->47 37->48 37->54 37->59 38->24 38->28 38->37 38->38 38->39 38->39 38->49 38->50 38->51 38->66 38->67 38->68 38->69 38->73 38->74 39->38 40->1 40->12 40->13 40->25 40->26 40->27 40->28 40->29 40->30 40->52 40->55 41->1 42->35 43->24 43->44 43->45 43->46 47->1 48->38 49->25 49->50 49->51 52->1 53->41 54->47 55->52
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int ParseInput ( char * pcszFileName ) { int T ; int n ; int i , j ; FILE * fp ; char szOpp [ 2 ] ; char szPairs [ 3 ] ; char szInput [ N ] ; int iPairs , iOpposites , iInputLength ; if ( NULL == pcszFileName ) return - 1 ; fp = fopen ( pcszFileName , "\x72\x0" ) ; if ( NULL == fp ) { printf ( "\nAccess denied file: %s" , pcszFileName ) ; return - 1 ; } fscanf ( fp , "%d " , & T ) ; fout = fopen ( "magica_out.txt" , "w" ) ; if ( NULL == fout ) { printf ( "\nCannot create new file." ) ; return - 1 ; } for ( i = 1 ; i <= T ; ++ i ) { fscanf ( fp , "%d " , & iPairs ) ; if ( iPairs > C ) return - 1 ; for ( j = 0 ; j < iPairs ; ++ j ) { fscanf ( fp , "%s " , szPairs ) ; Pairs [ j ] [ 0 ] = szPairs [ 0 ] ; Pairs [ j ] [ 1 ] = szPairs [ 1 ] ; Pairs [ j ] [ 2 ] = szPairs [ 2 ] ; } fscanf ( fp , "%d " , & iOpposites ) ; if ( iOpposites > D ) return - 1 ; for ( j = 0 ; j < iOpposites ; ++ j ) { fscanf ( fp , "%s " , szOpp ) ; Opposites [ j ] [ 0 ] = szOpp [ 0 ] ; Opposites [ j ] [ 1 ] = szOpp [ 1 ] ; } fscanf ( fp , "%d " , & iInputLength ) ; if ( iInputLength > N ) return - 1 ; fscanf ( fp , "%s " , szInput ) ; iCntPairs = iPairs ; iCntOpposites = iOpposites ; fprintf ( fout , "Case #%d: " , i ) ; Process ( szInput ) ; } fclose ( fp ) ; fclose ( fout ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment test = 1
scanf scanf ( "\x25\x64\x0" , & T )
<operator>.postDecrement T --
scanf scanf ( "%d " , & C )
memset memset ( combines , 0 , 27 * 27 )
memset memset ( opposed , 0 , 27 * 27 )
memset memset ( hasOpposed , 0 , 27 )
memset memset ( curOpposed , 0 , 27 )
scanf scanf ( "%d " , & D )
scanf scanf ( "%d " , & N )
scanf scanf ( "%s" , input )
printf printf ( "Case #%d: [" , test ++ )
printf printf ( "]\n" )
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < j
<operator>.postIncrement i ++
<operator>.multiplication 27 * 27
<operator>.multiplication 27 * 27
<operator>.assignment i = 0
scanf scanf ( "%s" , tmp )
<operator>.assignmentMinus tmp [ 0 ] -= 'A'
<operator>.assignmentMinus tmp [ 1 ] -= 'A'
<operator>.assignmentMinus tmp [ 2 ] -= 'A'
<operator>.assignment combines [ tmp [ 0 ] ] [ tmp [ 1 ] ] = combines [ tmp [ 1 ] ] [ tmp [ 0 ] ] = tmp [ 2 ]
<operator>.assignment i = 0
scanf scanf ( "%s" , tmp )
<operator>.assignmentMinus tmp [ 0 ] -= 'A'
<operator>.assignmentMinus tmp [ 1 ] -= 'A'
<operator>.assignment opposed [ tmp [ 0 ] ] [ tmp [ 1 ] ] = opposed [ tmp [ 1 ] ] [ tmp [ 0 ] ] = 1
<operator>.assignment hasOpposed [ tmp [ 0 ] ] = hasOpposed [ tmp [ 1 ] ] = 1
<operator>.expressionList i = 0   j = 0
<operator>.assignment curr = output [ j ] = ( input [ i ] - 'A' )
<operator>.assignment prev = curr
<operator>.postIncrement j ++
<operator>.postIncrement test ++
<operator>.assignment i = 0
printf printf ( "%c" , output [ i ] + 'A' )
<operator>.greaterThan j > 0
<operator>.logicalAnd j > 0 && hasOpposed [ curr ]
<operator>.logicalAnd j >= 0 && hasOpposed [ curr ]
<operator>.greaterThan i > 0
<operator>.assignment combines [ tmp [ 1 ] ] [ tmp [ 0 ] ] = tmp [ 2 ]
<operator>.assignment opposed [ tmp [ 1 ] ] [ tmp [ 0 ] ] = 1
<operator>.assignment hasOpposed [ tmp [ 1 ] ] = 1
<operator>.assignment i = 0
<operator>.assignment j = 0
<operator>.assignment output [ j ] = ( input [ i ] - 'A' )
<operator>.postIncrement curOpposed [ curr ] ++
printf printf ( ", " )
<operator>.addition output [ i ] + 'A'
<operator>.subtraction input [ i ] - 'A'
<operator>.greaterThan j > 0
<operator>.lessThan k < 27
<operator>.postIncrement k ++
<operator>.greaterEqualsThan j >= 0
<operator>.assignment curr = output [ j - 1 ] = combines [ prev ] [ curr ]
<operator>.postDecrement j --
<operator>.assignment k = 0
<operator>.greaterThan curOpposed [ prev ] > 0
<operator>.logicalAnd curOpposed [ k ] && opposed [ k ] [ curr ]
<operator>.postDecrement curOpposed [ prev ] --
<operator>.assignment output [ j - 1 ] = combines [ prev ] [ curr ]
memset memset ( curOpposed , 0 , 27 )
<operator>.assignment j = - 1
<operator>.subtraction j - 1
<operator>.minus - 1
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess tmp [ 2 ]
<operator>.indirectIndexAccess combines [ tmp [ 0 ] ] [ tmp [ 1 ] ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess opposed [ tmp [ 0 ] ] [ tmp [ 1 ] ]
<operator>.indirectIndexAccess hasOpposed [ tmp [ 0 ] ]
<operator>.indirectIndexAccess combines [ tmp [ 0 ] ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess combines [ tmp [ 1 ] ] [ tmp [ 0 ] ]
<operator>.indirectIndexAccess tmp [ 2 ]
<operator>.indirectIndexAccess opposed [ tmp [ 0 ] ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess opposed [ tmp [ 1 ] ] [ tmp [ 0 ] ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess hasOpposed [ tmp [ 1 ] ]
<operator>.indirectIndexAccess output [ j ]
<operator>.indirectIndexAccess hasOpposed [ curr ]
<operator>.indirectIndexAccess hasOpposed [ curr ]
<operator>.indirectIndexAccess output [ i ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess combines [ tmp [ 1 ] ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess opposed [ tmp [ 1 ] ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess input [ i ]
<operator>.indirectIndexAccess combines [ prev ] [ curr ]
<operator>.indirectIndexAccess curOpposed [ curr ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess combines [ prev ]
<operator>.indirectIndexAccess curOpposed [ prev ]
<operator>.indirectIndexAccess output [ j - 1 ]
<operator>.indirectIndexAccess combines [ prev ] [ curr ]
<operator>.indirectIndexAccess curOpposed [ k ]
<operator>.indirectIndexAccess opposed [ k ] [ curr ]
<operator>.indirectIndexAccess curOpposed [ prev ]
<operator>.indirectIndexAccess combines [ prev ]
<operator>.indirectIndexAccess opposed [ k ]
>>>PDG&118 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->41 0->42 0->43 0->44 0->47 0->49 0->50 0->51 0->52 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->63 0->64 0->65 0->69 0->71 0->72 2->1 2->1 2->41 3->1 3->4 4->1 4->1 4->4 4->5 4->6 4->7 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->17 4->19 4->21 4->23 4->24 4->25 4->31 4->37 4->41 4->42 4->51 4->52 4->73 4->74 4->75 5->1 5->15 6->1 6->1 7->1 7->1 7->1 8->1 8->1 8->45 8->46 9->1 9->1 9->54 9->65 9->66 9->67 9->69 10->1 10->17 11->1 11->19 12->1 12->57 13->1 13->1 14->1 15->1 15->1 15->5 15->15 15->16 15->16 15->26 15->27 15->28 15->29 15->30 15->48 15->76 15->77 15->78 15->79 15->84 15->85 15->86 15->87 15->97 15->98 15->99 15->107 16->1 16->15 17->1 17->1 17->10 17->17 17->18 17->18 17->32 17->33 17->34 17->35 17->36 17->49 17->50 17->80 17->81 17->82 17->83 17->88 17->89 17->90 17->91 17->92 17->100 17->101 17->102 17->103 17->108 18->1 18->17 19->1 19->1 19->11 19->19 19->20 19->20 19->38 19->39 19->40 19->44 19->45 19->46 19->53 19->57 19->58 19->61 19->93 19->104 20->1 20->19 21->1 21->1 21->1 21->21 21->22 21->43 21->47 21->47 21->56 21->96 22->1 22->21 23->6 24->7 25->15 26->1 26->27 26->28 26->29 26->30 26->32 26->48 27->1 27->1 27->26 27->32 27->33 28->1 28->1 28->26 28->32 28->34 29->1 29->26 29->30 29->32 29->48 30->1 30->1 30->1 31->17 32->1 32->26 32->33 32->34 33->1 33->1 33->26 33->27 33->32 34->1 34->1 34->26 34->28 34->32 35->1 35->1 35->1 36->1 36->1 36->1 36->8 37->1 37->1 38->1 38->1 38->39 39->1 39->1 39->1 40->1 40->21 40->44 41->1 41->13 42->1 42->21 43->1 43->1 44->58 44->71 44->105 44->109 45->1 45->1 45->46 45->59 45->64 46->1 46->1 46->1 46->8 46->45 46->54 46->106 47->1 47->22 47->55 48->1 48->1 48->30 49->1 49->35 50->1 50->8 50->36 51->19 51->37 52->21 52->37 52->44 53->1 53->1 53->38 54->1 54->1 54->9 54->69 55->1 56->1 57->1 57->12 57->38 57->38 57->53 57->53 58->45 58->45 58->61 58->94 59->1 59->1 59->60 59->66 59->113 60->1 60->59 61->40 61->46 61->46 61->95 62->1 62->1 62->39 63->1 63->58 64->1 64->59 65->1 65->1 65->9 65->67 65->67 65->69 65->115 66->1 66->1 66->1 66->9 66->59 66->60 66->69 66->69 66->70 66->72 67->1 67->1 67->9 67->65 67->69 68->1 68->1 68->62 69->1 69->1 69->9 69->54 69->65 69->66 69->67 70->1 70->1 70->61 71->63 72->70 105->62 105->63 105->65 105->68 105->71 105->110 105->111 105->112 105->116 113->114 113->117
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { char combines [ 27 ] [ 27 ] , opposed [ 27 ] [ 27 ] , hasOpposed [ 27 ] , hasRevOpposed [ 27 ] , input [ 101 ] , output [ 101 ] , tmp [ 4 ] , curr , prev , curOpposed [ 27 ] , k ; int T , C , D , N , i , j , test = 1 ; scanf ( "\x25\x64\x0" , & T ) ; while ( T -- ) { scanf ( "%d " , & C ) ; memset ( combines , 0 , 27 * 27 ) ; memset ( opposed , 0 , 27 * 27 ) ; memset ( hasOpposed , 0 , 27 ) ; memset ( curOpposed , 0 , 27 ) ; for ( i = 0 ; i < C ; i ++ ) { scanf ( "%s" , tmp ) ; tmp [ 0 ] -= 'A' ; tmp [ 1 ] -= 'A' ; tmp [ 2 ] -= 'A' ; combines [ tmp [ 0 ] ] [ tmp [ 1 ] ] = combines [ tmp [ 1 ] ] [ tmp [ 0 ] ] = tmp [ 2 ] ; } scanf ( "%d " , & D ) ; for ( i = 0 ; i < D ; i ++ ) { scanf ( "%s" , tmp ) ; tmp [ 0 ] -= 'A' ; tmp [ 1 ] -= 'A' ; opposed [ tmp [ 0 ] ] [ tmp [ 1 ] ] = opposed [ tmp [ 1 ] ] [ tmp [ 0 ] ] = 1 ; hasOpposed [ tmp [ 0 ] ] = hasOpposed [ tmp [ 1 ] ] = 1 ; } scanf ( "%d " , & N ) ; scanf ( "%s" , input ) ; for ( i = 0 , j = 0 ; i < N ; i ++ ) { curr = output [ j ] = ( input [ i ] - 'A' ) ; if ( j > 0 ) { if ( combines [ prev ] [ curr ] ) { if ( curOpposed [ prev ] > 0 ) curOpposed [ prev ] -- ; curr = output [ j - 1 ] = combines [ prev ] [ curr ] ; j -- ; } } if ( j > 0 && hasOpposed [ curr ] ) { for ( k = 0 ; k < 27 ; k ++ ) { if ( curOpposed [ k ] && opposed [ k ] [ curr ] ) { memset ( curOpposed , 0 , 27 ) ; j = - 1 ; break ; } } } if ( j >= 0 && hasOpposed [ curr ] ) curOpposed [ curr ] ++ ; prev = curr ; j ++ ; } printf ( "Case #%d: [" , test ++ ) ; for ( i = 0 ; i < j ; i ++ ) { if ( i > 0 ) printf ( ", " ) ; printf ( "%c" , output [ i ] + 'A' ) ; } printf ( "]\n" ) ; } }
>>>Func
METHOD clearAll
METHOD_RETURN void
<operator>.lessThan i < 8
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment clear [ i ] = 0
<operator>.lessThan j < 8
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment opp [ i ] [ j ] = 0
<operator>.assignment comb [ i ] [ j ] = '-'
<operator>.indirectIndexAccess clear [ i ]
<operator>.indirectIndexAccess opp [ i ] [ j ]
<operator>.indirectIndexAccess comb [ i ] [ j ]
<operator>.indirectIndexAccess opp [ i ]
<operator>.indirectIndexAccess comb [ i ]
>>>PDG&16 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 2->2 2->3 2->3 2->5 2->6 2->8 2->11 3->1 3->2 4->1 4->2 5->1 5->1 6->1 6->1 6->6 6->7 6->7 6->9 6->10 6->12 6->13 6->14 6->15 7->1 7->6 8->1 8->6 9->1 9->1 10->1 10->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void clearAll ( ) { int i , j ; for ( i = 0 ; i < 8 ; i ++ ) { clear [ i ] = 0 ; for ( j = 0 ; j < 8 ; j ++ ) { opp [ i ] [ j ] = 0 ; comb [ i ] [ j ] = '-' ; } } }
>>>Func
METHOD check_sorted
METHOD_RETURN bool
PARAM int * a
PARAM int n
RETURN return true ; return true ;
<operator>.greaterEqualsThan -- n >= 1
IDENTIFIER true return true ;
<operator>.preDecrement -- n
<operator>.lessThan a [ n ] < a [ n - 1 ]
RETURN return false ; return false ;
IDENTIFIER false return false ;
<operator>.subtraction n - 1
<operator>.indirectIndexAccess a [ n ]
<operator>.indirectIndexAccess a [ n - 1 ]
>>>PDG&14 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 2->1 2->8 3->7 4->1 5->1 5->1 5->4 5->8 5->11 5->12 5->13 6->4 7->5 7->11 8->1 8->1 8->1 8->5 8->7 8->9 9->1 10->9 11->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) bool check_sorted ( int * a , int n ) { while ( -- n >= 1 ) { if ( a [ n ] < a [ n - 1 ] ) return false ; } return true ; }
>>>Func
METHOD BucketSort
METHOD_RETURN void
PARAM int arr [ ]
<operator>.assignment buckets = ( struct Node * * ) malloc ( sizeof ( struct Node * ) * NBUCKET )
printf printf ( "--------------\n" )
printf printf ( "Buckets after sorted\n" )
free free ( buckets )
RETURN return ; return ;
<operator>.lessThan i < NBUCKET
<operator>.preIncrement ++ i
<operator>.lessThan i < NARRAY
<operator>.preIncrement ++ i
<operator>.lessThan i < NBUCKET
<operator>.postIncrement i ++
<operator>.lessThan i < NBUCKET
<operator>.preIncrement ++ i
<operator>.lessThan i < NBUCKET
<operator>.postIncrement i ++
<operator>.lessThan i < NBUCKET
<operator>.preIncrement ++ i
<operator>.lessThan i < NBUCKET
<operator>.preIncrement ++ i
<operator>.cast ( struct Node * * ) malloc ( sizeof ( struct Node * ) * NBUCKET )
<operator>.assignment i = 0
<operator>.assignment buckets [ i ] = NULL
<operator>.assignment i = 0
<operator>.assignment pos = getBucketIndex ( arr [ i ] )
<operator>.assignment current = ( struct Node * ) malloc ( sizeof ( struct Node ) )
<operator>.assignment current -> data = arr [ i ]
<operator>.assignment current -> next = buckets [ pos ]
<operator>.assignment buckets [ pos ] = current
<operator>.assignment i = 0
printBuckets printBuckets ( buckets [ i ] )
printf printf ( "\n" )
<operator>.assignment i = 0
<operator>.assignment buckets [ i ] = InsertionSort ( buckets [ i ] )
<operator>.assignment i = 0
printf printf ( "Bucket[\"%d\"] : " , i )
printBuckets printBuckets ( buckets [ i ] )
printf printf ( "\n" )
<operator>.expressionList j = 0   i = 0
<operator>.assignment node = buckets [ i ]
<operator>.assignment i = 0
<operator>.assignment node = buckets [ i ]
malloc malloc ( sizeof ( struct Node * ) * NBUCKET )
IDENTIFIER node while (node)
IDENTIFIER node while (node)
<operator>.multiplication sizeof ( struct Node * ) * NBUCKET
getBucketIndex getBucketIndex ( arr [ i ] )
<operator>.cast ( struct Node * ) malloc ( sizeof ( struct Node ) )
InsertionSort InsertionSort ( buckets [ i ] )
<operator>.assignment j = 0
<operator>.assignment i = 0
assert assert ( j < NARRAY )
<operator>.assignment arr [ j ++ ] = node -> data
<operator>.assignment node = node -> next
<operator>.assignment tmp = node
<operator>.assignment node = node -> next
free free ( tmp )
<operator>.sizeOf sizeof ( struct Node * )
<operator>.sizeOf sizeof ( struct Node )
<operator>.lessThan j < NARRAY
<operator>.postIncrement j ++
UNKNOWN printf ( "\x42\x75\x63\x6b\x65\x74\x5b\x5c\x0"%d\"] : " , i ) ; printf ( "\x42\x75\x63\x6b\x65\x74\x5b\x5c\x0"%d\"] : " , i ) ;
<operator>.indirectIndexAccess buckets [ i ]
<operator>.indirectFieldAccess current -> data
<operator>.indirectIndexAccess arr [ i ]
<operator>.indirectFieldAccess current -> next
<operator>.indirectIndexAccess buckets [ pos ]
<operator>.indirectIndexAccess buckets [ pos ]
<operator>.indirectIndexAccess buckets [ i ]
<operator>.indirectIndexAccess buckets [ i ]
<operator>.indirectIndexAccess buckets [ i ]
<operator>.indirectIndexAccess buckets [ i ]
<operator>.indirectIndexAccess buckets [ i ]
<operator>.indirectIndexAccess arr [ i ]
UNKNOWN struct Node * struct Node *
malloc malloc ( sizeof ( struct Node ) )
FIELD_IDENTIFIER data data
FIELD_IDENTIFIER next next
<operator>.indirectIndexAccess buckets [ i ]
<operator>.indirectIndexAccess arr [ j ++ ]
<operator>.indirectFieldAccess node -> data
<operator>.indirectFieldAccess node -> next
<operator>.indirectFieldAccess node -> next
FIELD_IDENTIFIER data data
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
>>>PDG&88 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->24 0->25 0->30 0->31 0->33 0->34 0->36 0->37 0->39 0->40 0->42 0->45 0->46 0->47 0->51 0->52 0->56 0->58 0->61 0->62 2->1 2->28 2->48 3->1 3->1 3->6 3->29 3->32 3->38 3->41 3->43 3->50 4->1 5->1 6->1 7->1 8->8 8->9 8->9 8->12 8->24 8->64 9->1 9->8 10->1 10->1 10->10 10->11 10->11 10->26 10->27 10->28 10->29 10->30 10->48 10->49 10->60 10->61 10->65 10->66 10->67 10->68 10->69 10->75 10->76 10->77 10->78 10->79 11->1 11->10 12->12 12->13 12->13 12->14 12->32 12->33 12->63 12->70 13->1 13->12 14->14 14->15 14->15 14->16 14->35 14->50 14->71 14->80 15->1 15->14 16->16 16->17 16->18 16->37 16->37 16->38 16->39 16->72 17->1 17->16 18->18 18->19 18->19 18->20 18->41 18->53 18->54 18->55 18->61 18->62 18->73 18->81 18->82 18->83 18->85 18->86 19->1 19->18 20->1 20->1 20->1 20->20 20->21 20->21 20->43 20->56 20->57 20->58 20->74 20->84 20->87 21->1 21->20 22->1 23->8 24->1 24->1 24->1 24->6 24->32 24->38 24->41 24->43 24->50 25->10 26->1 26->1 26->1 27->1 27->1 27->30 28->1 28->1 28->1 29->1 29->1 30->1 30->1 30->1 30->6 30->29 31->12 32->1 32->1 32->6 32->38 32->41 32->43 32->50 33->1 34->14 35->1 35->1 35->1 35->6 35->38 35->41 35->43 35->50 36->16 37->1 37->17 38->1 38->1 38->6 38->41 38->43 39->1 40->1 40->1 41->1 41->1 41->1 42->1 42->20 43->1 43->1 43->1 43->56 44->1 44->3 44->22 47->8 47->44 48->26 48->28 49->1 50->35 51->1 51->40 51->61 52->18 52->40 53->1 53->1 54->1 54->1 54->1 55->1 55->1 55->1 56->1 56->58 57->1 57->1 57->1 57->56 58->1 59->1 60->1 61->1 61->53 61->53 61->62 62->1 62->61
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void BucketSort ( int arr [ ] ) { int i , j ; struct Node * * buckets ; buckets = ( struct Node * * ) malloc ( sizeof ( struct Node * ) * NBUCKET ) ; for ( i = 0 ; i < NBUCKET ; ++ i ) { buckets [ i ] = NULL ; } for ( i = 0 ; i < NARRAY ; ++ i ) { struct Node * current ; int pos = getBucketIndex ( arr [ i ] ) ; current = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; current -> data = arr [ i ] ; current -> next = buckets [ pos ] ; buckets [ pos ] = current ; } for ( i = 0 ; i < NBUCKET ; i ++ ) { printf ( "\x42\x75\x63\x6b\x65\x74\x5b\x5c\x0"%d\"] : " , i ) ; printBuckets ( buckets [ i ] ) ; printf ( "\n" ) ; } for ( i = 0 ; i < NBUCKET ; ++ i ) { buckets [ i ] = InsertionSort ( buckets [ i ] ) ; } printf ( "--------------\n" ) ; printf ( "Buckets after sorted\n" ) ; for ( i = 0 ; i < NBUCKET ; i ++ ) { printf ( "Bucket[\"%d\"] : " , i ) ; printBuckets ( buckets [ i ] ) ; printf ( "\n" ) ; } for ( j = 0 , i = 0 ; i < NBUCKET ; ++ i ) { struct Node * node ; node = buckets [ i ] ; while ( node ) { assert ( j < NARRAY ) ; arr [ j ++ ] = node -> data ; node = node -> next ; } } for ( i = 0 ; i < NBUCKET ; ++ i ) { struct Node * node ; node = buckets [ i ] ; while ( node ) { struct Node * tmp ; tmp = node ; node = node -> next ; free ( tmp ) ; } } free ( buckets ) ; return ; }
>>>Func
METHOD binary_heap_insert
METHOD_RETURN int
PARAM BinaryHeap * heap
PARAM BinaryHeapValue value
<operator>.assignment index = heap -> num_values
<operator>.preIncrement ++ heap -> num_values
<operator>.assignment heap -> values [ index ] = value
RETURN return 1 ; return 1 ;
<operator>.greaterEqualsThan heap -> num_values >= heap -> alloced_size
<operator>.greaterThan index > 0
LITERAL 1 return 1 ;
<operator>.assignment new_size = heap -> alloced_size * 2
<operator>.assignment new_values = realloc ( heap -> values   sizeof ( BinaryHeapValue ) * new_size )
<operator>.assignment heap -> alloced_size = new_size
<operator>.assignment heap -> values = new_values
<operator>.assignment parent = ( index - 1 ) / 2
<operator>.equals new_values == NULL
<operator>.lessThan binary_heap_cmp ( heap , heap -> values [ parent ] , value ) < 0
<operator>.multiplication heap -> alloced_size * 2
realloc realloc ( heap -> values   sizeof ( BinaryHeapValue ) * new_size )
RETURN return 0 ; return 0 ;
<operator>.division ( index - 1 ) / 2
<operator>.multiplication sizeof ( BinaryHeapValue ) * new_size
LITERAL 0 return 0 ;
<operator>.subtraction index - 1
binary_heap_cmp binary_heap_cmp ( heap , heap -> values [ parent ] , value )
<operator>.assignment heap -> values [ index ] = heap -> values [ parent ]
<operator>.assignment index = parent
<operator>.sizeOf sizeof ( BinaryHeapValue )
<operator>.indirectFieldAccess heap -> num_values
<operator>.indirectFieldAccess heap -> num_values
<operator>.indirectIndexAccess heap -> values [ index ]
FIELD_IDENTIFIER num_values num_values
FIELD_IDENTIFIER num_values num_values
<operator>.indirectFieldAccess heap -> values
<operator>.indirectFieldAccess heap -> alloced_size
<operator>.indirectFieldAccess heap -> values
FIELD_IDENTIFIER values values
<operator>.indirectFieldAccess heap -> alloced_size
<operator>.indirectFieldAccess heap -> values
FIELD_IDENTIFIER alloced_size alloced_size
FIELD_IDENTIFIER values values
FIELD_IDENTIFIER alloced_size alloced_size
FIELD_IDENTIFIER values values
<operator>.indirectIndexAccess heap -> values [ parent ]
<operator>.indirectFieldAccess heap -> values
<operator>.indirectIndexAccess heap -> values [ index ]
<operator>.indirectIndexAccess heap -> values [ parent ]
FIELD_IDENTIFIER values values
<operator>.indirectFieldAccess heap -> values
<operator>.indirectFieldAccess heap -> values
FIELD_IDENTIFIER values values
FIELD_IDENTIFIER values values
>>>PDG&53 0->2 0->3 0->6 0->7 0->9 0->10 0->13 0->14 0->16 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->27 2->1 2->25 3->1 3->6 3->25 4->9 7->1 8->1 8->1 8->4 8->4 8->5 8->5 8->6 8->7 8->9 8->11 8->12 8->16 8->18 8->18 8->19 8->22 8->28 8->29 8->30 8->31 8->32 8->33 8->34 8->37 8->38 8->39 8->42 8->43 9->15 9->17 9->21 9->24 9->24 9->25 9->44 9->45 9->48 10->7 11->1 11->1 11->22 12->1 12->1 12->16 15->27 16->1 16->1 16->1 16->4 16->5 16->6 16->7 16->9 16->13 16->14 16->14 16->20 16->29 16->30 16->31 16->32 16->33 16->34 16->35 16->36 16->37 16->40 16->41 17->9 17->26 17->27 17->46 17->47 17->49 17->50 17->51 17->52 18->1 18->11 18->11 19->1 19->1 19->12 19->12 20->1 21->15 21->15 22->1 22->13 22->19 23->20 24->21 24->21 25->6 25->17 25->17 25->17 25->26 27->9 28->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int binary_heap_insert ( BinaryHeap * heap , BinaryHeapValue value ) { BinaryHeapValue * new_values ; unsigned int index ; unsigned int new_size ; unsigned int parent ; if ( heap -> num_values >= heap -> alloced_size ) { new_size = heap -> alloced_size * 2 ; new_values = realloc ( heap -> values , sizeof ( BinaryHeapValue ) * new_size ) ; if ( new_values == NULL ) { return 0 ; } heap -> alloced_size = new_size ; heap -> values = new_values ; } index = heap -> num_values ; ++ heap -> num_values ; while ( index > 0 ) { parent = ( index - 1 ) / 2 ; if ( binary_heap_cmp ( heap , heap -> values [ parent ] , value ) < 0 ) { break ; } else { heap -> values [ index ] = heap -> values [ parent ] ; index = parent ; } } heap -> values [ index ] = value ; return 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment pFile = fopen ( "\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x36\x2e\x69\x6e\x0" , "r" )
<operator>.assignment pOutFile = fopen ( "B-small-attempt6.out" , "w" )
<operator>.assignment loop = 1
fscanf fscanf ( pFile , "%d" , & case_num )
fclose fclose ( pFile )
fclose fclose ( pOutFile )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan loop <= case_num
LITERAL 0 return 0 ;
fopen fopen ( "\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x36\x2e\x69\x6e\x0" , "r" )
fopen fopen ( "B-small-attempt6.out" , "w" )
memset memset ( combine_table   0   3000 * sizeof ( int ) )
memset memset ( opponent_table   0   3000 * sizeof ( int ) )
memset memset ( occurence_table   0   26 * sizeof ( int ) )
fscanf fscanf ( pFile , "%d" , & combine_num )
fscanf fscanf ( pFile , "%d" , & opponent_num )
fscanf fscanf ( pFile , "%d" , & invoke_num )
<operator>.assignment * invoke = ( char * ) malloc ( sizeof ( char ) * ( invoke_num + 1 ) )
fscanf fscanf ( pFile , "%s" , invoke )
fprintf fprintf ( pOutFile , "Case #%d: [" , loop )
fprintf fprintf ( pOutFile , "]\n" )
free free ( invoke )
<operator>.postIncrement loop ++
<operator>.notEquals combine_num != 0
<operator>.notEquals opponent_num != 0
<operator>.lessThan i < invoke_num
<operator>.postIncrement i ++
<operator>.lessThan i < invoke_num
<operator>.postIncrement i ++
<operator>.multiplication 3000 * sizeof ( int )
<operator>.multiplication 3000 * sizeof ( int )
<operator>.multiplication 26 * sizeof ( int )
<operator>.cast ( char * ) malloc ( sizeof ( char ) * ( invoke_num + 1 ) )
<operator>.assignment i = 0
<operator>.postIncrement occurence_table [ invoke [ i ] - 65 ] ++
<operator>.assignment i = 0
<operator>.sizeOf sizeof ( int )
<operator>.lessThan i < combine_num
<operator>.postIncrement i ++
<operator>.lessThan i < opponent_num
<operator>.postIncrement i ++
malloc malloc ( sizeof ( char ) * ( invoke_num + 1 ) )
<operator>.greaterEqualsThan j >= 0
<operator>.postDecrement j --
<operator>.logicalAnd invoke [ j ] > 0 && combine_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ] > 0
<operator>.greaterEqualsThan j >= 0
<operator>.postDecrement j --
<operator>.notEquals invoke [ i ] != 0
<operator>.assignment i = 0
fscanf fscanf ( pFile , "%s" , combine )
<operator>.assignment combine_table [ ( combine [ 0 ] - 65 ) * 100 + combine [ 1 ] - 65 ] = combine [ 2 ]
<operator>.assignment combine_table [ ( combine [ 1 ] - 65 ) * 100 + combine [ 0 ] - 65 ] = combine [ 2 ]
<operator>.assignment i = 0
fscanf fscanf ( pFile , "%s" , opponent )
<operator>.assignment opponent_table [ ( opponent [ 0 ] - 65 ) * 100 + opponent [ 1 ] - 65 ] = - 1
<operator>.assignment opponent_table [ ( opponent [ 1 ] - 65 ) * 100 + opponent [ 0 ] - 65 ] = - 1
<operator>.multiplication sizeof ( char ) * ( invoke_num + 1 )
<operator>.assignment j = i - 1
<operator>.notEquals invoke [ j ] != 0
<operator>.assignment invoke [ i ] = combine_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ]
<operator>.assignment invoke [ j ] = 0
<operator>.postDecrement occurence_table [ invoke [ j ] - 65 ] --
<operator>.postDecrement occurence_table [ invoke [ i ] - 65 ] --
<operator>.assignment j = i - 1
fprintf fprintf ( pOutFile , "%c" , invoke [ i ] )
<operator>.assignment flag = 0
<operator>.sizeOf sizeof ( char )
<operator>.addition invoke_num + 1
<operator>.subtraction invoke [ i ] - 65
<operator>.greaterThan invoke [ j ] > 0
<operator>.greaterThan combine_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ] > 0
<operator>.logicalAnd invoke [ j ] > 0 && opponent_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ] < 0
<operator>.lessThan k < invoke_num
<operator>.postIncrement k ++
<operator>.logicalAnd i < invoke_num - 1 && flag == 1
<operator>.assignment flag = 0
<operator>.minus - 1
<operator>.minus - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.assignment invoke [ i ] = 0
<operator>.assignment k = i + 1
<operator>.notEquals invoke [ k ] != 0
fprintf fprintf ( pOutFile , ", " )
<operator>.lessThan k < invoke_num
<operator>.postIncrement k ++
<operator>.equals flag == 0
<operator>.subtraction ( combine [ 0 ] - 65 ) * 100 + combine [ 1 ] - 65
<operator>.subtraction ( combine [ 1 ] - 65 ) * 100 + combine [ 0 ] - 65
<operator>.subtraction ( opponent [ 0 ] - 65 ) * 100 + opponent [ 1 ] - 65
<operator>.subtraction ( opponent [ 1 ] - 65 ) * 100 + opponent [ 0 ] - 65
<operator>.subtraction ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65
<operator>.subtraction ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65
<operator>.subtraction invoke [ j ] - 65
<operator>.subtraction invoke [ i ] - 65
<operator>.greaterThan invoke [ j ] > 0
<operator>.lessThan opponent_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ] < 0
<operator>.lessEqualsThan k <= i
<operator>.postIncrement k ++
<operator>.assignment flag = 1
<operator>.lessThan i < invoke_num - 1
<operator>.equals flag == 1
<operator>.assignment k = i
<operator>.notEquals invoke [ k ] != 0
<operator>.addition ( combine [ 0 ] - 65 ) * 100 + combine [ 1 ]
<operator>.addition ( combine [ 1 ] - 65 ) * 100 + combine [ 0 ]
<operator>.addition ( opponent [ 0 ] - 65 ) * 100 + opponent [ 1 ]
<operator>.addition ( opponent [ 1 ] - 65 ) * 100 + opponent [ 0 ]
<operator>.addition ( invoke [ j ] - 65 ) * 100 + invoke [ i ]
<operator>.addition ( invoke [ j ] - 65 ) * 100 + invoke [ i ]
<operator>.assignment k = 0
<operator>.addition i + 1
<operator>.subtraction invoke_num - 1
<operator>.assignment flag = 1
<operator>.multiplication ( combine [ 0 ] - 65 ) * 100
<operator>.multiplication ( combine [ 1 ] - 65 ) * 100
<operator>.multiplication ( opponent [ 0 ] - 65 ) * 100
<operator>.multiplication ( opponent [ 1 ] - 65 ) * 100
<operator>.multiplication ( invoke [ j ] - 65 ) * 100
<operator>.multiplication ( invoke [ j ] - 65 ) * 100
<operator>.subtraction ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65
<operator>.notEquals invoke [ k ] != 0
<operator>.subtraction combine [ 0 ] - 65
<operator>.subtraction combine [ 1 ] - 65
<operator>.subtraction opponent [ 0 ] - 65
<operator>.subtraction opponent [ 1 ] - 65
<operator>.subtraction invoke [ j ] - 65
<operator>.subtraction invoke [ j ] - 65
<operator>.addition ( invoke [ j ] - 65 ) * 100 + invoke [ i ]
<operator>.postDecrement occurence_table [ invoke [ k ] - 65 ] --
<operator>.assignment invoke [ k ] = 0
<operator>.multiplication ( invoke [ j ] - 65 ) * 100
<operator>.subtraction invoke [ j ] - 65
<operator>.subtraction invoke [ k ] - 65
<operator>.addressOf & combine_num
<operator>.addressOf & opponent_num
<operator>.addressOf & invoke_num
<operator>.sizeOf sizeof ( int )
<operator>.sizeOf sizeof ( int )
UNKNOWN char * char *
<operator>.indirectIndexAccess occurence_table [ invoke [ i ] - 65 ]
<operator>.indirectIndexAccess invoke [ i ]
<operator>.indirectIndexAccess combine_table [ ( combine [ 0 ] - 65 ) * 100 + combine [ 1 ] - 65 ]
<operator>.indirectIndexAccess combine [ 2 ]
<operator>.indirectIndexAccess combine_table [ ( combine [ 1 ] - 65 ) * 100 + combine [ 0 ] - 65 ]
<operator>.indirectIndexAccess combine [ 2 ]
<operator>.indirectIndexAccess opponent_table [ ( opponent [ 0 ] - 65 ) * 100 + opponent [ 1 ] - 65 ]
<operator>.indirectIndexAccess opponent_table [ ( opponent [ 1 ] - 65 ) * 100 + opponent [ 0 ] - 65 ]
<operator>.indirectIndexAccess invoke [ i ]
<operator>.indirectIndexAccess invoke [ j ]
<operator>.indirectIndexAccess invoke [ j ]
<operator>.indirectIndexAccess combine_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ]
<operator>.indirectIndexAccess invoke [ i ]
<operator>.indirectIndexAccess combine_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ]
<operator>.indirectIndexAccess invoke [ j ]
<operator>.indirectIndexAccess occurence_table [ invoke [ j ] - 65 ]
<operator>.indirectIndexAccess occurence_table [ invoke [ i ] - 65 ]
<operator>.indirectIndexAccess invoke [ i ]
<operator>.indirectIndexAccess invoke [ j ]
<operator>.indirectIndexAccess invoke [ i ]
<operator>.indirectIndexAccess invoke [ j ]
<operator>.indirectIndexAccess opponent_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ]
<operator>.indirectIndexAccess invoke [ i ]
<operator>.indirectIndexAccess invoke [ k ]
<operator>.indirectIndexAccess combine [ 1 ]
<operator>.indirectIndexAccess combine [ 0 ]
<operator>.indirectIndexAccess opponent [ 1 ]
<operator>.indirectIndexAccess opponent [ 0 ]
<operator>.indirectIndexAccess invoke [ i ]
<operator>.indirectIndexAccess invoke [ i ]
<operator>.indirectIndexAccess invoke [ k ]
<operator>.indirectIndexAccess combine [ 0 ]
<operator>.indirectIndexAccess combine [ 1 ]
<operator>.indirectIndexAccess opponent [ 0 ]
<operator>.indirectIndexAccess opponent [ 1 ]
<operator>.indirectIndexAccess invoke [ j ]
<operator>.indirectIndexAccess invoke [ j ]
<operator>.indirectIndexAccess invoke [ i ]
<operator>.indirectIndexAccess invoke [ k ]
<operator>.indirectIndexAccess occurence_table [ invoke [ k ] - 65 ]
<operator>.indirectIndexAccess invoke [ k ]
<operator>.indirectIndexAccess invoke [ j ]
<operator>.indirectIndexAccess invoke [ k ]
>>>PDG&185 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->37 0->39 0->40 0->41 0->42 0->44 0->45 0->47 0->48 0->49 0->50 0->51 0->54 0->55 0->58 0->60 0->62 0->66 0->67 0->69 0->70 0->71 0->72 0->74 0->75 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->112 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->127 0->128 0->129 0->132 0->133 0->134 0->135 2->1 2->1 2->5 3->1 3->1 3->7 3->21 4->1 4->9 5->1 5->1 5->6 5->9 5->16 6->1 6->1 7->1 7->1 8->1 9->1 9->1 9->1 9->9 9->13 9->14 9->15 9->16 9->17 9->18 9->19 9->20 9->21 9->21 9->22 9->23 9->24 9->25 9->26 9->27 9->29 9->31 9->32 9->33 9->34 9->35 9->37 9->38 9->43 9->58 9->68 9->69 9->136 9->137 9->138 9->139 9->140 9->141 10->8 11->2 11->2 12->3 12->3 13->1 13->1 13->61 13->72 14->1 14->1 14->1 14->98 15->1 15->1 15->1 15->36 15->63 15->64 15->131 16->1 16->1 16->17 16->25 16->39 16->51 17->1 17->1 17->18 17->26 17->41 17->55 18->1 18->1 18->20 18->27 18->29 18->58 18->69 18->74 18->86 18->114 19->1 19->1 19->20 20->1 20->6 20->16 20->23 20->49 20->60 20->66 20->70 20->71 20->84 20->93 20->94 20->95 20->96 20->97 20->105 20->110 20->111 20->122 20->123 20->128 20->129 20->130 20->134 20->135 21->1 21->22 21->24 21->66 22->1 22->7 22->21 23->1 24->1 24->9 25->1 25->1 25->16 25->39 25->39 25->50 26->1 26->1 26->17 26->41 26->41 26->54 27->27 27->28 27->29 27->36 27->44 27->46 27->59 27->70 27->71 27->80 27->80 27->142 27->150 27->152 28->1 28->27 29->1 29->1 29->1 29->18 29->27 29->30 29->49 29->58 29->69 29->74 29->83 29->86 29->102 29->104 29->113 29->143 30->1 30->29 31->13 32->14 33->15 34->1 35->27 36->1 36->1 36->15 36->64 37->1 37->29 38->1 39->1 39->1 39->16 39->25 39->39 39->40 39->40 39->51 39->52 39->53 39->89 39->90 39->106 39->107 39->116 39->117 39->124 39->125 39->144 39->145 39->146 39->147 39->166 39->167 39->173 39->174 40->1 40->39 41->1 41->1 41->17 41->26 41->41 41->42 41->42 41->55 41->56 41->57 41->78 41->79 41->91 41->92 41->108 41->109 41->118 41->119 41->126 41->127 41->148 41->149 41->168 41->169 41->175 41->176 42->1 42->41 43->1 43->19 43->34 44->1 44->1 44->45 44->60 44->151 45->1 45->44 46->1 46->1 46->1 46->47 46->61 46->62 46->63 46->64 46->65 46->81 46->94 46->95 46->96 46->111 46->121 46->129 46->154 46->155 46->156 46->157 46->158 46->160 46->161 46->171 46->178 47->1 47->1 47->48 47->73 47->97 47->162 48->1 48->47 49->1 49->1 49->20 49->23 49->29 49->30 49->66 49->66 49->67 49->70 49->74 49->76 49->77 49->83 49->86 49->88 49->102 49->104 49->113 49->114 49->159 50->39 51->1 51->1 51->17 51->52 51->53 51->89 51->90 51->106 51->107 51->124 51->125 52->1 52->1 52->13 53->1 53->1 53->1 53->13 54->41 55->1 55->1 55->18 55->91 55->92 55->108 55->109 55->126 55->127 56->1 56->1 56->14 57->1 57->1 57->1 57->14 58->1 58->43 59->1 59->1 59->44 60->1 60->44 60->45 60->71 61->1 61->1 61->96 62->1 62->95 63->1 63->1 63->15 64->1 64->1 64->15 64->36 65->1 65->1 65->47 66->1 66->1 66->20 66->22 66->23 66->49 66->70 66->85 67->1 67->1 67->103 68->1 70->1 70->20 70->23 70->49 70->93 70->94 70->110 70->111 70->122 70->130 71->1 71->20 71->23 71->46 71->46 71->60 71->72 71->93 71->97 71->110 71->120 71->128 71->128 71->129 71->153 71->170 71->177 72->1 72->13 72->46 72->46 72->61 73->1 73->1 73->1 73->47 73->48 73->82 73->99 73->112 73->164 74->1 74->1 74->74 74->75 74->75 74->84 74->114 74->165 75->1 75->74 76->1 76->1 76->1 76->85 77->1 77->88 78->56 79->57 80->28 80->59 80->59 80->81 81->28 81->65 81->65 81->99 82->1 82->1 82->20 82->23 82->49 82->70 83->1 83->1 83->74 84->1 84->1 84->20 84->23 84->101 84->105 84->123 85->1 85->22 85->66 86->1 86->1 86->1 86->18 86->27 86->29 86->58 86->69 86->86 86->87 86->87 86->105 86->172 87->1 87->86 88->1 88->1 88->29 88->30 89->1 90->1 91->1 92->1 93->1 94->1 95->1 95->20 95->23 95->60 95->71 96->1 96->20 96->23 96->49 96->70 97->1 97->20 97->23 97->60 97->71 97->73 97->73 97->98 97->122 97->130 97->133 97->134 97->134 97->163 97->179 97->183 98->1 98->14 98->73 98->73 99->1 99->1 99->28 99->99 99->100 99->100 99->123 99->180 100->1 100->99 101->1 101->1 101->103 102->1 102->30 102->76 102->76 102->103 103->1 103->76 103->76 104->1 104->1 104->86 105->1 105->1 105->20 105->23 105->84 105->115 105->123 106->1 107->1 107->1 108->1 109->1 109->1 110->1 110->1 111->1 112->1 112->99 114->29 114->102 114->102 115->1 115->88 116->1 116->89 116->89 116->106 116->106 117->1 117->90 117->90 117->107 117->107 118->1 118->91 118->91 118->108 118->108 119->1 119->92 119->92 119->109 119->109 120->1 120->93 120->93 120->110 120->110 121->94 121->94 121->111 121->111 122->1 123->1 123->1 123->20 123->23 123->84 123->105 123->131 123->132 123->135 123->135 123->181 123->182 123->184 124->51 124->90 124->107 124->116 124->116 125->1 125->51 125->89 125->106 125->117 125->117 126->55 126->92 126->109 126->118 126->118 127->1 127->55 127->91 127->108 127->119 127->119 128->1 128->20 128->23 128->60 128->71 128->97 128->120 128->120 128->129 129->121 129->121 130->1 130->1 131->1 131->1 131->15 132->1 132->1 132->20 132->23 132->84 132->105 132->123 133->1 133->122 133->122 133->130 133->130 134->1 134->20 134->23 134->60 134->71 134->97 134->133 134->133
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { FILE * pFile ; FILE * pOutFile ; pFile = fopen ( "\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x36\x2e\x69\x6e\x0" , "r" ) ; pOutFile = fopen ( "B-small-attempt6.out" , "w" ) ; int case_num ; int loop ; loop = 1 ; fscanf ( pFile , "%d" , & case_num ) ; while ( loop <= case_num ) { int combine_table [ 3000 ] ; int opponent_table [ 3000 ] ; int occurence_table [ 26 ] ; memset ( combine_table , 0 , 3000 * sizeof ( int ) ) ; memset ( opponent_table , 0 , 3000 * sizeof ( int ) ) ; memset ( occurence_table , 0 , 26 * sizeof ( int ) ) ; int i ; int combine_num ; fscanf ( pFile , "%d" , & combine_num ) ; if ( combine_num != 0 ) { for ( i = 0 ; i < combine_num ; i ++ ) { char combine [ 4 ] ; fscanf ( pFile , "%s" , combine ) ; combine_table [ ( combine [ 0 ] - 65 ) * 100 + combine [ 1 ] - 65 ] = combine [ 2 ] ; combine_table [ ( combine [ 1 ] - 65 ) * 100 + combine [ 0 ] - 65 ] = combine [ 2 ] ; } } int opponent_num ; fscanf ( pFile , "%d" , & opponent_num ) ; if ( opponent_num != 0 ) { for ( i = 0 ; i < opponent_num ; i ++ ) { char opponent [ 3 ] ; fscanf ( pFile , "%s" , opponent ) ; opponent_table [ ( opponent [ 0 ] - 65 ) * 100 + opponent [ 1 ] - 65 ] = - 1 ; opponent_table [ ( opponent [ 1 ] - 65 ) * 100 + opponent [ 0 ] - 65 ] = - 1 ; } } int invoke_num ; fscanf ( pFile , "%d" , & invoke_num ) ; char * invoke = ( char * ) malloc ( sizeof ( char ) * ( invoke_num + 1 ) ) ; fscanf ( pFile , "%s" , invoke ) ; for ( i = 0 ; i < invoke_num ; i ++ ) { occurence_table [ invoke [ i ] - 65 ] ++ ; int j ; for ( j = i - 1 ; j >= 0 ; j -- ) if ( invoke [ j ] != 0 ) { break ; } if ( invoke [ j ] > 0 && combine_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ] > 0 ) { invoke [ i ] = combine_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ] ; invoke [ j ] = 0 ; occurence_table [ invoke [ j ] - 65 ] -- ; occurence_table [ invoke [ i ] - 65 ] -- ; continue ; } for ( j = i - 1 ; j >= 0 ; j -- ) { if ( invoke [ j ] > 0 && opponent_table [ ( invoke [ j ] - 65 ) * 100 + invoke [ i ] - 65 ] < 0 ) { invoke [ i ] = 0 ; int k ; for ( k = 0 ; k <= i ; k ++ ) { if ( invoke [ k ] != 0 ) { occurence_table [ invoke [ k ] - 65 ] -- ; invoke [ k ] = 0 ; } } break ; } } } fprintf ( pOutFile , "Case #%d: [" , loop ) ; for ( i = 0 ; i < invoke_num ; i ++ ) { if ( invoke [ i ] != 0 ) { fprintf ( pOutFile , "%c" , invoke [ i ] ) ; int k ; int flag ; flag = 0 ; for ( k = i + 1 ; k < invoke_num ; k ++ ) if ( invoke [ k ] != 0 ) flag = 1 ; if ( i < invoke_num - 1 && flag == 1 ) fprintf ( pOutFile , ", " ) ; } else { int k ; int flag ; flag = 0 ; for ( k = i ; k < invoke_num ; k ++ ) if ( invoke [ k ] != 0 ) flag = 1 ; if ( flag == 0 ) break ; } } fprintf ( pOutFile , "]\n" ) ; free ( invoke ) ; loop ++ ; } fclose ( pFile ) ; fclose ( pOutFile ) ; return 0 ; }
>>>Func
METHOD DeInitData
METHOD_RETURN void
fclose fclose ( staticFd )
>>>PDG&3 0->2 2->1 2->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void DeInitData ( ) { fclose ( staticFd ) ; }
>>>Func
METHOD max
METHOD_RETURN int
PARAM int a
PARAM int b
RETURN return a > b ? a : b ; return a > b ? a : b ;
<operator>.conditional a > b ? a : b
<operator>.greaterThan a > b
>>>PDG&7 0->2 0->3 0->5 0->6 2->6 3->6 4->1 5->1 5->1 5->1 5->1 5->4 6->5 6->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int max ( int a , int b ) { return a > b ? a : b ; }
>>>Func
METHOD midpoint_euler
METHOD_RETURN double
PARAM double dx
PARAM double x0
PARAM double x_max
PARAM double * y
PARAM char save_to_file
<operator>.assignment * fp = NULL
<operator>.assignment t1 = clock ( )
<operator>.assignment x = x0
<operator>.assignment t2 = clock ( )
RETURN return ( double ) ( t2 - t1 ) / CLOCKS_PER_SEC ; return ( double ) ( t2 - t1 ) / CLOCKS_PER_SEC ;
IDENTIFIER save_to_file if (save_to_file)
<operator>.lessEqualsThan x <= x_max
<operator>.logicalAnd save_to_file && fp
<operator>.division ( double ) ( t2 - t1 ) / CLOCKS_PER_SEC
<operator>.assignment fp = fopen ( "\x6d\x69\x64\x70\x6f\x69\x6e\x74\x5f\x65\x75\x6c\x65\x72\x2e\x63\x73\x76\x0" , "w+" )
midpoint_euler_step midpoint_euler_step ( dx , & x , y , dy )
<operator>.assignmentPlus x += dx
fclose fclose ( fp )
<operator>.equals fp == NULL
<operator>.logicalAnd save_to_file && fp
<operator>.cast ( double ) ( t2 - t1 )
fopen fopen ( "\x6d\x69\x64\x70\x6f\x69\x6e\x74\x5f\x65\x75\x6c\x65\x72\x2e\x63\x73\x76\x0" , "w+" )
perror perror ( "Error! " )
RETURN return - 1 ; return - 1 ;
fprintf fprintf ( fp , "%.4g,%.4g,%.4g\n" , x , y [ 0 ] , y [ 1 ] )
<operator>.subtraction t2 - t1
<operator>.minus - 1
clock clock ( )
clock clock ( )
<operator>.addressOf & x
UNKNOWN double double
<operator>.indirectIndexAccess y [ 0 ]
<operator>.indirectIndexAccess y [ 1 ]
>>>PDG&35 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->23 0->24 0->26 0->27 0->28 2->1 2->17 3->1 3->9 4->1 4->13 5->1 5->17 5->26 6->1 6->21 7->1 7->21 8->27 9->17 9->18 9->26 10->27 11->1 13->13 13->17 13->17 13->18 13->18 13->21 13->26 13->31 14->19 14->19 15->1 15->11 16->1 16->1 16->20 17->13 17->18 17->18 17->26 17->26 18->13 20->1 20->1 20->1 20->8 20->9 20->10 20->11 20->13 20->14 20->15 20->17 20->18 20->21 20->21 20->22 20->24 20->25 20->27 20->28 20->29 20->30 20->31 20->32 21->14 21->14 21->26 21->26 21->33 21->34 23->16 23->16 24->1 25->1 26->14 26->17 26->17 26->17 26->18 26->21 27->15 27->15 27->22 27->22 28->1 28->25
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) double midpoint_euler ( double dx , double x0 , double x_max , double * y , char save_to_file ) { double dy [ order ] ; FILE * fp = NULL ; if ( save_to_file ) { fp = fopen ( "\x6d\x69\x64\x70\x6f\x69\x6e\x74\x5f\x65\x75\x6c\x65\x72\x2e\x63\x73\x76\x0" , "w+" ) ; if ( fp == NULL ) { perror ( "Error! " ) ; return - 1 ; } } clock_t t1 = clock ( ) ; double x = x0 ; do { if ( save_to_file && fp ) fprintf ( fp , "%.4g,%.4g,%.4g\n" , x , y [ 0 ] , y [ 1 ] ) ; midpoint_euler_step ( dx , & x , y , dy ) ; x += dx ; } while ( x <= x_max ) ; clock_t t2 = clock ( ) ; if ( save_to_file && fp ) fclose ( fp ) ; return ( double ) ( t2 - t1 ) / CLOCKS_PER_SEC ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment * fin = fopen ( "\x43\x3a\x5c\x5c\x63\x6a\x69\x6e\x70\x75\x74\x73\x5c\x5c\x70\x73\x65\x75\x64\x5c\x5c\x73\x6d\x61\x6c\x6c\x31\x2e\x69\x6e\x0" , "r" )
<operator>.assignment * fo = fopen ( "C:\\cjinputs\\pseud\\small.txt" , "w" )
<operator>.assignment * line = xm ( LINE_MAX )
<operator>.assignment total_inputs = atoi ( line )
<operator>.lessThan fv ( counter , total_inputs ) <missing
RETURN return 0 ; return 0 ;
<operator>.logicalOr fin == 0 || fo == 0
<operator>.equals read == 0
LITERAL 0 return 0 ;
fopen fopen ( "\x43\x3a\x5c\x5c\x63\x6a\x69\x6e\x70\x75\x74\x73\x5c\x5c\x70\x73\x65\x75\x64\x5c\x5c\x73\x6d\x61\x6c\x6c\x31\x2e\x69\x6e\x0" , "r" )
fopen fopen ( "C:\\cjinputs\\pseud\\small.txt" , "w" )
eo eo ( "Could not open file(s)" )
xm xm ( LINE_MAX )
eo eo ( "Input error" )
atoi atoi ( line )
fv fv ( counter , total_inputs )
<operator>.equals fin == 0
<operator>.equals fo == 0
>>>PDG&20 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 2->1 2->1 2->18 3->1 3->1 3->1 3->19 4->1 4->1 4->16 5->1 5->1 5->17 6->1 6->1 6->1 7->1 8->1 8->1 8->1 8->13 9->1 9->1 9->15 10->7 11->2 11->2 12->3 12->3 13->1 14->1 14->4 15->1 16->1 16->5 17->1 17->1 17->6 17->6 18->1 18->8 18->8 18->19 19->1 19->8 19->8
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { FILE * fin = fopen ( "\x43\x3a\x5c\x5c\x63\x6a\x69\x6e\x70\x75\x74\x73\x5c\x5c\x70\x73\x65\x75\x64\x5c\x5c\x73\x6d\x61\x6c\x6c\x31\x2e\x69\x6e\x0" , "r" ) ; FILE * fo = fopen ( "C:\\cjinputs\\pseud\\small.txt" , "w" ) ; if ( fin == 0 || fo == 0 ) eo ( "Could not open file(s)" ) ; char * line = xm ( LINE_MAX ) ; if ( read == 0 ) eo ( "Input error" ) ; int total_inputs = atoi ( line ) ; int counter ; fv ( counter , total_inputs ) <missing ';'> { if ( read == 0 ) eo ( "Input error" ) ; int h = atoi ( line ) ; int hc [ 81 ] ; int hs [ 81 ] ; int ht [ 81 ] ; int hp [ 81 ] ; int dc [ 81 ] ; int ds [ 81 ] ; int dt [ 81 ] ; fi ( 81 ) <missing ';'> { hc [ i ] = 0 ; hs [ i ] = 0 ; ht [ i ] = 0 ; hp [ i ] = 0 ; dc [ i ] = 0 ; ds [ i ] = 0 ; dt [ i ] = 0 ; } fi <missing ';'> ( <missing ';'> h ) { if ( read == 0 ) eo ( "Input error" ) ; hc [ i ] = atoi ( strtok ( line , " " ) ) ; hs [ i ] = atoi ( strtok ( 0 , " " ) ) ; ht [ i ] = atoi ( strtok ( 0 , " " ) ) ; } if ( read == 0 ) eo ( "Input error" ) ; int d = atoi ( line ) ; fi <missing ';'> ( <missing ';'> d ) { if ( read == 0 ) eo ( "Input error" ) ; dc [ d - i - 1 ] = atoi ( strtok ( line , " " ) ) ; ds [ d - i - 1 ] = atoi ( strtok ( 0 , " " ) ) ; dt [ d - i - 1 ] = atoi ( strtok ( 0 , " " ) ) ; } int s = 0 ; int t = 1 ; while ( t > 0 ) { int cp = 0 ; fi <missing ';'> ( <missing ';'> h ) { if ( ht [ i ] > 0 && hp [ i ] != 1 ) { cp = 1 ; hp [ i ] = 1 ; t += ht [ i ] ; s += hs [ i ] ; fv ( j , hc [ i ] ) <missing ';'> { if ( d <= 0 ) break ; d -- ; hc [ h ] = dc [ d - j ] ; hs [ h ] = ds [ d - j ] ; ht [ h ] = dt [ d - j ] ; h ++ ; } break ; } } int top = 0 , topi = 0 ; if ( cp == 0 ) { fi <missing ';'> ( <missing ';'> h ) { if ( hs [ i ] > top && hp [ i ] != 1 ) { top = hs [ i ] ; topi = i ; } } if ( top > 0 ) { hp [ topi ] = 1 ; s += top ; fv ( j , hc [ topi ] ) <missing ';'> { if ( d <= 0 ) break ; d -- ; hc [ h ] = dc [ d - j ] ; hs [ h ] = ds [ d - j ] ; ht [ h ] = dt [ d - j ] ; h ++ ; } } else { fi <missing ';'> ( <missing ';'> h ) { if ( hc [ i ] > top && hp [ i ] != 1 ) { top = hc [ i ] ; topi = i ; } } if ( top > 0 ) { hp [ topi ] = 1 ; s += hs [ topi ] ; fv ( j , hc [ topi ] ) <missing ';'> { if ( d <= 0 ) break ; d -- ; hc [ h ] = dc [ d - j ] ; hs [ h ] = ds [ d - j ] ; ht [ h ] = dt [ d - j ] ; h ++ ; } } else { fi <missing ';'> ( <missing ';'> h ) { if ( hp [ i ] != 1 ) { hp [ topi ] = 1 ; s += hs [ topi ] ; fv ( j , hc [ topi ] ) <missing ';'> { if ( d <= 0 ) break ; d -- ; hc [ h ] = dc [ d - j ] ; hs [ h ] = ds [ d - j ] ; ht [ h ] = dt [ d - j ] ; h ++ ; } break ; } } } } } t -- ; } int output = s ; char * f_output = xm ( LINE_MAX ) ; sprintf ( f_output , "Case #%d: %d\n" , counter + 1 , output ) ; write ; free ( f_output ) ; } return 0 ; }
>>>Func
METHOD search_D
METHOD_RETURN int
PARAM char * tab
PARAM char * tab_N
PARAM int lenght
PARAM int i
PARAM int * signet_0
PARAM int * signet_1
RETURN return 0 ; return 0 ;
<operator>.lessThan j < lenght
<operator>.postIncrement j ++
LITERAL 0 return 0 ;
<operator>.assignment j = * signet_0 + * signet_1 + 2
<operator>.equals tab_N [ i ] == tab [ j * 2 ]
<operator>.equals tab_N [ i ] == tab [ j * 2 + 1 ]
<operator>.addition * signet_0 + * signet_1 + 2
<operator>.assignment * signet_0 = j * 2
<operator>.assignment * signet_1 = - 1
RETURN return 1 ; return 1 ;
<operator>.assignment * signet_0 = - 1
<operator>.assignment * signet_1 = j * 2 + 1
RETURN return 1 ; return 1 ;
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
<operator>.multiplication j * 2
<operator>.multiplication j * 2
<operator>.minus - 1
<operator>.addition j * 2 + 1
<operator>.minus - 1
<operator>.addition j * 2 + 1
<operator>.multiplication j * 2
<operator>.multiplication j * 2
<operator>.indirectIndexAccess tab_N [ i ]
<operator>.indirectIndexAccess tab [ j * 2 ]
<operator>.indirectIndexAccess tab_N [ i ]
<operator>.indirectIndexAccess tab [ j * 2 + 1 ]
<operator>.indirection * signet_0
<operator>.indirection * signet_1
<operator>.indirection * signet_0
<operator>.indirection * signet_1
>>>PDG&40 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->15 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->1 2->13 2->14 3->1 3->13 3->14 4->9 5->1 6->1 7->1 8->1 9->1 9->1 9->8 9->13 9->24 9->24 9->32 9->33 10->1 10->9 11->8 12->1 12->1 12->9 13->1 13->1 13->1 13->14 13->14 13->16 13->17 13->18 13->25 13->26 13->27 13->30 13->34 13->35 13->36 13->37 14->1 14->1 14->9 14->10 14->13 14->19 14->20 14->21 14->28 14->29 14->31 14->38 14->39 15->1 16->1 16->1 16->1 17->1 17->1 17->1 18->1 21->1 22->18 23->21 24->25 24->30 25->1 25->16 25->16 26->17 28->19 30->10 30->27 30->27 30->31 31->20 31->20 31->29 31->29
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int search_D ( char * tab , char * tab_N , int lenght , int i , int * signet_0 , int * signet_1 ) { for ( int j = * signet_0 + * signet_1 + 2 ; j < lenght ; j ++ ) { if ( tab_N [ i ] == tab [ j * 2 ] ) { * signet_0 = j * 2 ; * signet_1 = - 1 ; return 1 ; } if ( tab_N [ i ] == tab [ j * 2 + 1 ] ) { * signet_0 = - 1 ; * signet_1 = j * 2 + 1 ; return 1 ; } } return 0 ; }
>>>Func
METHOD cmp
METHOD_RETURN int
PARAM const void * a
PARAM const void * b
<operator>.assignment c = * ( struct Walk * ) a
<operator>.assignment d = * ( struct Walk * ) b
RETURN return 0 ; return 0 ;
<operator>.greaterThan c . w > d . w
<operator>.lessThan c . w < d . w
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
RETURN return - 1 ; return - 1 ;
<operator>.cast ( struct Walk * ) a
<operator>.cast ( struct Walk * ) b
LITERAL 1 return 1 ;
<operator>.minus - 1
<operator>.fieldAccess c . w
<operator>.fieldAccess d . w
FIELD_IDENTIFIER w w
FIELD_IDENTIFIER w w
>>>PDG&20 0->2 0->3 0->6 0->9 0->10 0->12 0->13 0->14 0->15 2->12 3->13 4->1 4->1 4->1 4->7 4->8 5->1 5->1 5->1 5->7 5->8 6->1 7->1 7->1 7->1 7->8 7->8 7->8 7->10 7->16 7->17 7->18 7->19 8->6 8->11 8->15 9->6 10->1 11->1 12->1 13->1 14->10 15->11
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int cmp ( const void * a , const void * b ) { struct Walk c = * ( struct Walk * ) a ; struct Walk d = * ( struct Walk * ) b ; if ( c . w > d . w ) return 1 ; if ( c . w < d . w ) return - 1 ; return 0 ; }
>>>Func
METHOD APHash
METHOD_RETURN unsigned int
PARAM char * str
PARAM unsigned int len
<operator>.assignment hash = 0xAAAAAAAA
<operator>.assignment i = 0
RETURN return hash ; return hash ;
<operator>.lessThan i < len
<operator>.expressionList str ++   i ++
IDENTIFIER hash return hash ;
<operator>.assignment i = 0
<operators>.assignmentXor hash ^= ( ( i & 1 ) == 0 ) ? ( ( hash << 7 ) ^ ( * str ) * ( hash >> 3 ) ) : ( ~ ( ( hash << 11 ) + ( * str ) ^ ( hash >> 5 ) ) )
<operator>.postIncrement str ++
<operator>.postIncrement i ++
<operator>.conditional ( ( i & 1 ) == 0 ) ? ( ( hash << 7 ) ^ ( * str ) * ( hash >> 3 ) ) : ( ~ ( ( hash << 11 ) + ( * str ) ^ ( hash >> 5 ) ) )
<operator>.equals ( i & 1 ) == 0
<operator>.xor ( hash << 7 ) ^ ( * str ) * ( hash >> 3 )
<operator>.not ~ ( ( hash << 11 ) + ( * str ) ^ ( hash >> 5 ) )
<operator>.and i & 1
<operator>.shiftLeft hash << 7
<operator>.multiplication ( * str ) * ( hash >> 3 )
<operator>.xor ( hash << 11 ) + ( * str ) ^ ( hash >> 5 )
<operator>.arithmeticShiftRight hash >> 3
<operator>.addition ( hash << 11 ) + ( * str )
<operator>.arithmeticShiftRight hash >> 5
<operator>.shiftLeft hash << 11
<operator>.indirection * str
<operator>.indirection * str
>>>PDG&28 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->11 0->12 0->13 0->15 0->18 0->19 0->22 0->24 0->25 2->1 2->12 3->7 4->1 4->1 4->9 4->19 4->25 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->13 7->14 7->15 7->18 7->18 8->1 8->1 8->1 9->6 10->1 10->7 11->1 11->1 11->9 11->19 11->25 12->1 12->8 13->7 13->8 14->1 14->1 14->1 15->1 15->16 15->17 15->19 15->20 15->21 15->22 15->23 15->24 15->25 15->26 15->27 16->1 16->1 16->11 16->11 16->14 16->14 17->1 17->11 17->14 18->13 18->15 18->15 19->16 19->16 19->22 20->1 20->1 20->12 20->16 20->16 20->21 20->23 21->1 21->1 21->17 21->17 22->11 22->20 22->20 23->1 23->1 24->11 24->21 24->21 25->21 25->21 25->23 25->23 25->24
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) unsigned int APHash ( char * str , unsigned int len ) { unsigned int hash = 0xAAAAAAAA ; unsigned int i = 0 ; for ( i = 0 ; i < len ; str ++ , i ++ ) { hash ^= ( ( i & 1 ) == 0 ) ? ( ( hash << 7 ) ^ ( * str ) * ( hash >> 3 ) ) : ( ~ ( ( hash << 11 ) + ( * str ) ^ ( hash >> 5 ) ) ) ; } return hash ; }
>>>Func
METHOD djb2
METHOD_RETURN uint64_t
PARAM const char * s
<operator>.assignment hash = 5381
<operator>.assignment i = 0
RETURN return hash ; return hash ;
<operator>.notEquals s [ i ] != '\0'
IDENTIFIER hash return hash ;
<operator>.assignment hash = ( ( hash << 5 ) + hash ) + s [ i ]
<operator>.postIncrement i ++
<operator>.addition ( ( hash << 5 ) + hash ) + s [ i ]
<operator>.addition ( hash << 5 ) + hash
<operator>.shiftLeft hash << 5
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i ]
>>>PDG&15 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 2->6 2->8 2->10 3->1 3->1 3->7 3->12 4->1 4->1 4->9 5->1 6->1 6->1 6->6 6->8 6->8 6->9 6->10 6->10 6->11 6->12 6->13 6->14 7->5 8->1 8->1 8->1 8->7 8->12 9->1 9->1 10->1 11->1 12->8 12->8 12->10 12->10 12->11 12->11
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) uint64_t djb2 ( const char * s ) { uint64_t hash = 5381 ; size_t i = 0 ; while ( s [ i ] != '\0' ) { hash = ( ( hash << 5 ) + hash ) + s [ i ] ; i ++ ; } return hash ; }
>>>Func
METHOD private_list_of_elements_t_append
METHOD_RETURN void
PARAM struct list_of_elements_t * this
PARAM char vv
PARAM struct modifiers_t * modifiers
assert assert ( this != NULL )
assert assert ( modifiers != NULL )
<operator>.assignment * new_element = create_element ( vv )
<operator>.postIncrement this -> base_count [ numerate ( vv ) ] ++
<operator>.notEquals this -> last_base != NULL
found_opposition this -> found_opposition ( this , vv , modifiers )
<operator>.equals this -> tail == NULL
<operator>.notEquals this != NULL
<operator>.notEquals modifiers != NULL
<operator>.assignment aa = numerate ( vv )
<operator>.assignment bb = numerate ( this -> last_base -> character )
empty this -> empty ( this )
RETURN return ; return ;
create_element create_element ( vv )
assert assert ( this -> head == NULL )
assert assert ( this -> penultimate == NULL )
<operator>.assignment this -> last_base = this -> head = this -> tail = new_element
<operator>.notEquals modifiers -> combine_matrix [ aa ] [ bb ] != '-'
<operator>.assignment this -> penultimate = this -> tail
<operator>.assignment this -> last_base = this -> tail = this -> tail -> next = new_element
numerate numerate ( vv )
numerate numerate ( vv )
numerate numerate ( this -> last_base -> character )
<operator>.assignment * new_element = create_element ( modifiers -> combine_matrix [ aa ] [ bb ] )
<operator>.postDecrement this -> base_count [ bb ] --
<operator>.assignment this -> tail = new_element
<operator>.assignment this -> last_base = NULL
RETURN return ; return ;
<operator>.equals this -> head == NULL
<operator>.equals this -> penultimate == NULL
<operator>.assignment this -> head = this -> tail = new_element
<operator>.notEquals this -> penultimate != NULL
<operator>.assignment this -> tail = new_element
<operator>.assignment this -> tail = this -> tail -> next = new_element
create_element create_element ( modifiers -> combine_matrix [ aa ] [ bb ] )
<operator>.assignment this -> penultimate -> next = new_element
<operator>.assignment this -> tail -> next = new_element
<operator>.assignment this -> head = new_element
<operator>.indirectIndexAccess this -> base_count [ numerate ( vv ) ]
<operator>.indirectFieldAccess this -> found_opposition
<operator>.indirectFieldAccess this -> tail
<operator>.indirectFieldAccess this -> base_count
FIELD_IDENTIFIER found_opposition found_opposition
<operator>.indirectFieldAccess this -> empty
FIELD_IDENTIFIER tail tail
<operator>.indirectFieldAccess this -> last_base
FIELD_IDENTIFIER base_count base_count
<operator>.indirectFieldAccess this -> last_base -> character
<operator>.indirectIndexAccess modifiers -> combine_matrix [ aa ] [ bb ]
FIELD_IDENTIFIER empty empty
<operator>.indirectFieldAccess this -> head
<operator>.indirectFieldAccess this -> penultimate
FIELD_IDENTIFIER last_base last_base
<operator>.indirectFieldAccess this -> head
<operator>.indirectFieldAccess this -> penultimate
<operator>.indirectFieldAccess this -> tail
<operator>.indirectFieldAccess this -> last_base
<operator>.indirectFieldAccess this -> last_base
FIELD_IDENTIFIER character character
<operator>.indirectIndexAccess modifiers -> combine_matrix [ aa ]
<operator>.indirectIndexAccess this -> base_count [ bb ]
<operator>.indirectFieldAccess this -> tail
<operator>.indirectFieldAccess this -> last_base
FIELD_IDENTIFIER head head
FIELD_IDENTIFIER penultimate penultimate
FIELD_IDENTIFIER head head
<operator>.indirectFieldAccess this -> tail
FIELD_IDENTIFIER penultimate penultimate
FIELD_IDENTIFIER tail tail
FIELD_IDENTIFIER last_base last_base
<operator>.indirectFieldAccess this -> tail
FIELD_IDENTIFIER last_base last_base
<operator>.indirectFieldAccess modifiers -> combine_matrix
<operator>.indirectIndexAccess modifiers -> combine_matrix [ aa ] [ bb ]
<operator>.indirectFieldAccess this -> base_count
FIELD_IDENTIFIER tail tail
FIELD_IDENTIFIER last_base last_base
<operator>.indirectFieldAccess this -> penultimate
FIELD_IDENTIFIER tail tail
FIELD_IDENTIFIER tail tail
<operator>.indirectFieldAccess this -> tail -> next
FIELD_IDENTIFIER combine_matrix combine_matrix
<operator>.indirectIndexAccess modifiers -> combine_matrix [ aa ]
FIELD_IDENTIFIER base_count base_count
FIELD_IDENTIFIER penultimate penultimate
<operator>.indirectFieldAccess this -> penultimate -> next
<operator>.indirectFieldAccess this -> tail
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess modifiers -> combine_matrix
<operator>.indirectFieldAccess this -> penultimate
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess this -> head
FIELD_IDENTIFIER tail tail
FIELD_IDENTIFIER combine_matrix combine_matrix
FIELD_IDENTIFIER penultimate penultimate
FIELD_IDENTIFIER head head
>>>PDG&101 0->2 0->3 0->4 0->9 0->10 0->11 0->12 0->13 0->16 0->17 0->18 0->21 0->22 0->24 0->25 0->26 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->42 2->12 3->10 3->26 4->13 5->1 5->1 6->1 6->1 7->21 7->24 7->35 7->37 7->38 7->41 9->1 9->10 9->11 9->14 9->15 9->22 9->26 9->27 9->31 9->36 9->44 9->47 9->52 9->53 9->62 9->63 9->64 9->76 9->77 9->86 10->7 10->8 10->11 10->16 10->16 10->17 10->18 10->18 10->25 10->43 10->45 10->46 10->48 10->49 10->51 10->54 11->19 11->20 11->21 11->23 11->23 11->24 11->33 11->33 11->34 11->35 11->37 11->38 11->41 11->50 11->55 11->56 11->57 11->58 11->59 11->60 11->61 11->68 11->69 11->70 11->71 11->72 11->73 11->74 11->75 11->83 11->84 11->85 11->91 11->92 11->97 12->1 12->5 12->5 12->10 12->13 13->1 13->6 13->6 13->9 13->10 14->1 14->1 14->1 15->1 15->1 15->1 17->1 18->7 18->25 22->1 22->10 22->28 22->29 22->30 22->31 22->32 22->36 22->39 22->39 22->44 22->47 22->65 22->66 22->67 22->78 22->79 22->80 22->81 22->82 22->87 22->88 22->89 22->93 22->98 26->1 26->10 26->14 27->1 27->15 28->1 28->1 28->30 28->40 28->42 29->1 29->1 30->1 30->1 31->1 31->1 32->1 33->19 33->19 33->34 34->20 34->20 35->21 36->1 36->1 36->1 36->40 36->42 36->90 36->94 36->95 36->96 36->99 36->100 37->21 37->35 38->24 39->1 39->28 40->1 40->1 40->1 41->24 41->38 42->1 42->1 42->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static void private_list_of_elements_t_append ( struct list_of_elements_t * this , char vv , struct modifiers_t * modifiers ) { assert ( this != NULL ) ; assert ( modifiers != NULL ) ; if ( this -> last_base != NULL ) { const uintmax_t aa = numerate ( vv ) ; const uintmax_t bb = numerate ( this -> last_base -> character ) ; if ( modifiers -> combine_matrix [ aa ] [ bb ] != '-' ) { struct element_t * new_element = create_element ( modifiers -> combine_matrix [ aa ] [ bb ] ) ; this -> base_count [ bb ] -- ; this -> tail = new_element ; this -> last_base = NULL ; if ( this -> penultimate != NULL ) { this -> penultimate -> next = new_element ; } else { this -> head = new_element ; } return ; } } if ( this -> found_opposition ( this , vv , modifiers ) ) { this -> empty ( this ) ; return ; } struct element_t * new_element = create_element ( vv ) ; if ( this -> tail == NULL ) { assert ( this -> head == NULL ) ; assert ( this -> penultimate == NULL ) ; this -> last_base = this -> head = this -> tail = new_element ; } else { this -> penultimate = this -> tail ; this -> last_base = this -> tail = this -> tail -> next = new_element ; } this -> base_count [ numerate ( vv ) ] ++ ; }
>>>Func
METHOD isPalindrome
METHOD_RETURN bool
PARAM char * s
<operator>.assignment start = 0
<operator>.assignment end = strlen ( s ) - 1
RETURN return 1 ; return 1 ;
<operator>.lessThan start < end
LITERAL 1 return 1 ;
<operator>.subtraction strlen ( s ) - 1
strlen strlen ( s )
<operator>.logicalAnd ! isalpha ( s [ start ] ) && ! isalnum ( s [ start ] )
<operator>.postIncrement start ++
<operator>.logicalNot ! isalpha ( s [ start ] )
<operator>.logicalNot ! isalnum ( s [ start ] )
isalpha isalpha ( s [ start ] )
isalnum isalnum ( s [ start ] )
<operator>.logicalAnd ! isalpha ( s [ end ] ) && ! isalnum ( s [ end ] )
<operator>.postDecrement end --
<operator>.logicalNot ! isalpha ( s [ end ] )
<operator>.logicalNot ! isalnum ( s [ end ] )
<operator>.assignment c1 = tolower ( s [ start ] )
<operator>.assignment c2 = tolower ( s [ end ] )
<operator>.postIncrement start ++
<operator>.postDecrement end --
isalpha isalpha ( s [ end ] )
isalnum isalnum ( s [ end ] )
<operator>.notEquals c1 != c2
tolower tolower ( s [ start ] )
tolower tolower ( s [ end ] )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.indirectIndexAccess s [ start ]
<operator>.indirectIndexAccess s [ start ]
<operator>.indirectIndexAccess s [ end ]
<operator>.indirectIndexAccess s [ end ]
<operator>.indirectIndexAccess s [ start ]
<operator>.indirectIndexAccess s [ end ]
>>>PDG&37 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->11 0->17 0->22 0->23 0->26 0->29 0->30 2->9 3->1 3->6 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->5 6->10 6->11 6->12 6->14 6->17 6->22 6->23 6->31 7->5 8->1 8->4 8->4 9->1 9->8 9->14 9->15 9->24 9->25 9->27 9->28 10->1 10->1 10->1 10->6 10->11 10->16 10->18 10->24 10->33 11->1 11->6 12->1 12->10 12->13 12->15 12->32 13->1 13->10 14->12 14->15 14->27 15->13 15->14 15->27 16->1 16->1 16->1 16->6 16->17 16->20 16->21 16->26 16->27 16->28 16->35 16->36 17->1 17->6 18->1 18->16 18->19 18->25 18->34 19->1 19->16 20->1 20->1 20->26 21->1 21->1 21->26 22->1 22->6 23->1 23->6 24->18 24->25 24->28 25->19 25->24 25->28 26->1 26->1 26->1 26->6 26->22 26->23 26->29 27->1 27->14 27->20 28->1 28->21 28->24 29->1 30->29
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) bool isPalindrome ( char * s ) { int start = 0 , end = strlen ( s ) - 1 ; while ( start < end ) { if ( ! isalpha ( s [ start ] ) && ! isalnum ( s [ start ] ) ) { start ++ ; } else if ( ! isalpha ( s [ end ] ) && ! isalnum ( s [ end ] ) ) { end -- ; } else { char c1 = tolower ( s [ start ] ) ; char c2 = tolower ( s [ end ] ) ; if ( c1 != c2 ) return 0 ; start ++ ; end -- ; } } return 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= T
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 1
printf printf ( "Case #%d: [" , t )
memset memset ( qq   0   sizeof ( qq ) )
scanf scanf ( "%d" , & C )
<operator>.assignment di = 0
scanf scanf ( "%d" , & D )
<operator>.assignment cc [ 0 ] = 0
<operator>.assignment ri = 0
<operator>.assignment b = - 1
scanf scanf ( "%d %s" , & N , s )
printf printf ( "]\n" )
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < ri
<operator>.postIncrement j ++
<operator>.assignment i = 0
<operator>.assignment e = scanf ( "%3s" , s )
assert assert ( e == 1 )
<operator>.assignment a = baseIndex ( s [ 0 ] )
<operator>.assignment b = baseIndex ( s [ 1 ] )
<operator>.assignment c = baseIndex ( s [ 2 ] )
assert assert ( a >= 0 )
assert assert ( b >= 0 )
assert assert ( c < 0 )
assert assert ( qq [ a ] [ b ] == 0 )
assert assert ( qq [ b ] [ a ] == 0 )
<operator>.assignment qq [ a ] [ b ] = s [ 2 ]
<operator>.assignment qq [ b ] [ a ] = s [ 2 ]
<operator>.assignment i = 0
<operator>.assignment e = scanf ( "%2s" , s )
assert assert ( e == 1 )
<operator>.assignment a = baseIndex ( s [ 0 ] )
<operator>.assignment b = baseIndex ( s [ 1 ] )
assert assert ( a >= 0 )
assert assert ( b >= 0 )
assert assert ( a != b )
<operator>.assignment dd [ di ] = ( 1 << a ) | ( 1 << b )
<operator>.postIncrement di ++
<operator>.minus - 1
<operator>.assignment j = 0
<operator>.assignment a = baseIndex ( s [ j ] )
assert assert ( a >= 0 )
<operator>.assignment rr [ ri ] = s [ j ]
<operator>.postIncrement ri ++
<operator>.assignment b = a
<operator>.assignment cc [ ri ] = cc [ ri - 1 ] | ( 1 << a )
<operator>.assignment j = 0
printf printf ( "%c" , rr [ j ] )
<operator>.logicalAnd b >= 0 && qq [ a ] [ b ] != 0
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.greaterThan j > 0
scanf scanf ( "%3s" , s )
<operator>.equals e == 1
baseIndex baseIndex ( s [ 0 ] )
baseIndex baseIndex ( s [ 1 ] )
baseIndex baseIndex ( s [ 2 ] )
<operator>.greaterEqualsThan a >= 0
<operator>.greaterEqualsThan b >= 0
<operator>.lessThan c < 0
<operator>.equals qq [ a ] [ b ] == 0
<operator>.equals qq [ b ] [ a ] == 0
scanf scanf ( "%2s" , s )
<operator>.equals e == 1
baseIndex baseIndex ( s [ 0 ] )
baseIndex baseIndex ( s [ 1 ] )
<operator>.greaterEqualsThan a >= 0
<operator>.greaterEqualsThan b >= 0
<operator>.notEquals a != b
<operator>.or ( 1 << a ) | ( 1 << b )
baseIndex baseIndex ( s [ j ] )
<operator>.greaterEqualsThan a >= 0
<operator>.assignment rr [ ri - 1 ] = qq [ a ] [ b ]
<operator>.assignment b = - 1
<operator>.assignment cc [ ri ] = cc [ ri - 1 ]
<operator>.or cc [ ri - 1 ] | ( 1 << a )
<operator>.assignment i = 0
assert assert ( dd [ i ] != 0 )
fputs fputs ( ", " , stdout )
<operator>.shiftLeft 1 << a
<operator>.shiftLeft 1 << b
<operator>.greaterEqualsThan b >= 0
<operator>.notEquals qq [ a ] [ b ] != 0
<operator>.shiftLeft 1 << a
<operator>.equals ( cc [ ri ] & dd [ i ] ) == dd [ i ]
<operator>.minus - 1
<operator>.subtraction ri - 1
<operator>.notEquals dd [ i ] != 0
<operator>.assignment ri = 0
<operator>.assignment b = - 1
<operator>.subtraction ri - 1
<operator>.subtraction ri - 1
<operator>.and cc [ ri ] & dd [ i ]
<operator>.minus - 1
<operator>.sizeOf sizeof ( qq )
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.indirectIndexAccess cc [ 0 ]
<operator>.addressOf & N
<operator>.indirectIndexAccess qq [ a ] [ b ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess qq [ b ] [ a ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess dd [ di ]
<operator>.indirectIndexAccess rr [ ri ]
<operator>.indirectIndexAccess s [ j ]
<operator>.indirectIndexAccess cc [ ri ]
<operator>.indirectIndexAccess rr [ j ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess qq [ a ] [ b ]
<operator>.indirectIndexAccess qq [ b ] [ a ]
<operator>.indirectIndexAccess qq [ a ]
<operator>.indirectIndexAccess qq [ b ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess s [ j ]
<operator>.indirectIndexAccess cc [ ri - 1 ]
<operator>.indirectIndexAccess qq [ a ]
<operator>.indirectIndexAccess qq [ b ]
<operator>.indirectIndexAccess qq [ a ] [ b ]
<operator>.indirectIndexAccess rr [ ri - 1 ]
<operator>.indirectIndexAccess qq [ a ] [ b ]
<operator>.indirectIndexAccess cc [ ri ]
<operator>.indirectIndexAccess cc [ ri - 1 ]
<operator>.indirectIndexAccess qq [ a ]
<operator>.indirectIndexAccess qq [ a ]
<operator>.indirectIndexAccess dd [ i ]
<operator>.indirectIndexAccess dd [ i ]
<operator>.indirectIndexAccess cc [ ri ]
<operator>.indirectIndexAccess dd [ i ]
>>>PDG&143 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->39 0->48 0->49 0->50 0->54 0->55 0->57 0->58 0->60 0->61 0->62 0->63 0->64 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->77 0->78 0->79 0->82 0->87 0->89 0->90 0->91 0->92 0->93 0->94 0->96 0->97 0->98 0->99 0->101 0->102 0->104 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->18 4->20 4->22 4->24 4->26 4->39 4->49 4->50 4->57 4->105 4->106 4->107 4->108 4->109 5->1 5->4 6->3 7->1 7->4 8->1 8->5 9->1 9->1 10->1 10->18 11->1 11->1 11->48 12->1 12->20 12->60 13->1 13->1 14->1 14->24 14->54 14->101 15->1 15->1 15->1 15->92 16->1 16->1 16->22 17->1 18->1 18->1 18->10 18->18 18->19 18->19 18->27 18->28 18->29 18->30 18->31 18->32 18->33 18->34 18->35 18->36 18->37 18->38 18->63 18->64 18->65 18->66 18->67 18->68 18->69 18->70 18->71 18->72 18->110 18->111 18->112 18->113 18->119 18->120 18->121 18->122 18->123 18->124 18->125 18->130 18->131 19->1 19->18 20->1 20->1 20->1 20->12 20->20 20->21 20->21 20->40 20->41 20->42 20->43 20->44 20->45 20->46 20->47 20->48 20->60 20->73 20->74 20->75 20->76 20->77 20->78 20->79 20->80 20->90 20->91 20->114 20->126 20->127 21->1 21->20 22->1 22->1 22->16 22->22 22->23 22->23 22->51 22->52 22->59 22->81 22->82 22->92 22->128 23->1 23->22 24->1 24->1 24->1 24->24 24->25 24->58 24->62 24->62 24->118 25->1 25->24 26->18 27->1 27->64 28->1 28->1 29->1 29->1 29->68 30->1 30->1 30->69 31->1 31->1 31->70 32->1 32->1 33->1 33->1 34->1 34->1 35->1 35->1 36->1 36->1 37->1 37->1 37->71 37->83 37->93 38->1 38->1 38->1 38->72 39->1 39->20 40->1 40->74 41->1 41->1 42->1 42->1 42->77 43->1 43->1 43->78 44->1 44->1 45->1 45->1 46->1 46->1 47->1 47->1 47->1 48->1 48->1 49->15 50->22 51->1 51->1 51->82 52->1 52->1 53->1 53->1 53->1 54->1 54->97 55->1 55->1 55->92 56->1 56->1 56->1 56->103 57->1 57->24 58->1 58->1 59->1 59->1 59->1 59->53 59->54 59->55 59->56 59->60 59->83 59->84 59->85 59->86 59->87 59->94 59->96 59->97 59->101 59->102 59->115 59->116 59->117 59->129 59->133 59->134 59->135 59->136 59->138 60->1 60->1 60->1 60->12 60->20 60->61 60->88 60->95 60->98 60->103 60->139 60->140 60->141 60->142 61->1 61->60 62->1 62->25 62->89 63->27 63->37 63->38 63->65 63->66 63->67 63->73 64->1 64->28 64->28 65->1 65->29 65->63 65->73 65->75 66->1 66->30 66->63 66->73 66->76 67->31 67->37 67->38 67->63 67->73 68->1 68->32 68->32 69->33 69->33 70->1 70->34 70->34 71->35 71->35 72->36 72->36 73->40 73->75 73->76 74->1 74->41 74->41 75->1 75->42 75->63 75->65 75->73 76->1 76->43 76->63 76->66 76->73 77->44 77->44 77->79 78->45 78->45 78->79 79->46 79->46 79->90 79->91 80->1 80->1 80->47 80->47 81->1 81->51 81->53 81->63 81->73 82->1 82->52 82->52 82->55 82->94 83->1 83->1 83->1 84->1 84->1 84->1 84->92 85->1 85->1 85->1 86->1 86->1 86->56 86->56 86->85 87->1 87->60 88->1 88->1 89->1 89->1 90->1 90->80 90->80 91->80 91->80 92->59 92->59 92->93 92->132 92->137 93->1 93->59 93->59 93->71 93->83 94->1 94->86 94->86 95->1 95->1 95->1 95->60 95->61 95->98 95->99 95->100 95->104 96->84 97->24 97->54 97->101 98->88 98->88 98->103 99->1 99->24 99->54 99->101 100->1 100->1 100->1 100->92 101->102 102->24 102->54 102->101 103->1 103->95 103->95 104->100
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T , t ; scanf ( "\x25\x64\x0" , & T ) ; for ( t = 1 ; t <= T ; t ++ ) { int C , D , N ; int i , j ; char s [ 101 ] ; int a , b , c ; int dd [ 28 ] ; int di ; char qq [ 8 ] [ 8 ] ; char rr [ 100 ] ; int cc [ 101 ] ; int ri ; int e ; printf ( "Case #%d: [" , t ) ; memset ( qq , 0 , sizeof ( qq ) ) ; scanf ( "%d" , & C ) ; for ( i = 0 ; i < C ; i ++ ) { e = scanf ( "%3s" , s ) ; assert ( e == 1 ) ; a = baseIndex ( s [ 0 ] ) ; b = baseIndex ( s [ 1 ] ) ; c = baseIndex ( s [ 2 ] ) ; assert ( a >= 0 ) ; assert ( b >= 0 ) ; assert ( c < 0 ) ; assert ( qq [ a ] [ b ] == 0 ) ; assert ( qq [ b ] [ a ] == 0 ) ; qq [ a ] [ b ] = s [ 2 ] ; qq [ b ] [ a ] = s [ 2 ] ; } di = 0 ; scanf ( "%d" , & D ) ; for ( i = 0 ; i < D ; i ++ ) { e = scanf ( "%2s" , s ) ; assert ( e == 1 ) ; a = baseIndex ( s [ 0 ] ) ; b = baseIndex ( s [ 1 ] ) ; assert ( a >= 0 ) ; assert ( b >= 0 ) ; assert ( a != b ) ; dd [ di ] = ( 1 << a ) | ( 1 << b ) ; di ++ ; } cc [ 0 ] = 0 ; ri = 0 ; b = - 1 ; scanf ( "%d %s" , & N , s ) ; for ( j = 0 ; j < N ; j ++ ) { a = baseIndex ( s [ j ] ) ; assert ( a >= 0 ) ; if ( b >= 0 && qq [ a ] [ b ] != 0 ) { rr [ ri - 1 ] = qq [ a ] [ b ] ; b = - 1 ; cc [ ri ] = cc [ ri - 1 ] ; continue ; } rr [ ri ] = s [ j ] ; ri ++ ; b = a ; cc [ ri ] = cc [ ri - 1 ] | ( 1 << a ) ; for ( i = 0 ; i < D ; i ++ ) { assert ( dd [ i ] != 0 ) ; if ( ( cc [ ri ] & dd [ i ] ) == dd [ i ] ) { ri = 0 ; b = - 1 ; break ; } } } for ( j = 0 ; j < ri ; j ++ ) { if ( j > 0 ) { fputs ( ", " , stdout ) ; } printf ( "%c" , rr [ j ] ) ; } printf ( "]\n" ) ; } return 0 ; }
>>>Func
METHOD works
METHOD_RETURN int
PARAM int amo
<operator>.assignment numCh = 0
RETURN return TRUE ; return TRUE ;
<operator>.equals amo == 0
<operator>.equals numCards == 0
<operator>.equals amo == 1
<operator>.lessThan i < numCards
<operator>.postIncrement i ++
<operator>.lessThan i < numCh
<operator>.postIncrement i ++
IDENTIFIER TRUE return TRUE ;
RETURN return TRUE ; return TRUE ;
RETURN return FALSE ; return FALSE ;
RETURN return TRUE ; return TRUE ;
<operator>.assignment i = 0
<operator>.assignment found = FALSE
<operator>.assignment i = 0
<operator>.assignment found = FALSE
IDENTIFIER TRUE return TRUE ;
IDENTIFIER FALSE return FALSE ;
IDENTIFIER TRUE return TRUE ;
<operator>.logicalAnd j < numCh && ! found
<operator>.postIncrement j ++
<operator>.logicalNot ! found
<operator>.lessThan chains [ i ] [ 1 ] < amo
<operator>.assignment j = 0
<operator>.assignment chains [ numCh ] [ 0 ] = cards [ i ]
<operator>.assignment chains [ numCh ] [ 1 ] = 1
<operator>.postIncrement numCh ++
<operator>.lessThan j < numCh
<operator>.logicalNot ! found
<operator>.logicalAnd chains [ j ] [ 0 ] == cards [ i ] - 1 && chains [ j ] [ 1 ] < amo
<operator>.logicalAnd j < i && ! found
<operator>.postIncrement j ++
<operator>.logicalNot ! found
<operator>.assignment chains [ j ] [ 0 ] = cards [ i ]
<operator>.postIncrement chains [ j ] [ 1 ] ++
<operator>.assignment found = TRUE
<operator>.assignment j = 0
RETURN return FALSE ; return FALSE ;
<operator>.equals chains [ j ] [ 0 ] == cards [ i ] - 1
<operator>.lessThan chains [ j ] [ 1 ] < amo
<operator>.lessThan j < i
<operator>.logicalNot ! found
<operator>.equals chains [ j ] [ 0 ] == chains [ i ] [ 0 ] - chains [ i ] [ 1 ]
IDENTIFIER FALSE return FALSE ;
<operator>.subtraction cards [ i ] - 1
<operator>.assignment chains [ j ] [ 0 ] = chains [ i ] [ 0 ]
<operator>.assignment found = TRUE
<operator>.subtraction chains [ i ] [ 0 ] - chains [ i ] [ 1 ]
<operator>.indirectIndexAccess chains [ i ] [ 1 ]
<operator>.indirectIndexAccess chains [ numCh ] [ 0 ]
<operator>.indirectIndexAccess cards [ i ]
<operator>.indirectIndexAccess chains [ numCh ] [ 1 ]
<operator>.indirectIndexAccess chains [ i ]
<operator>.indirectIndexAccess chains [ numCh ]
<operator>.indirectIndexAccess chains [ numCh ]
<operator>.indirectIndexAccess chains [ j ] [ 0 ]
<operator>.indirectIndexAccess chains [ j ] [ 1 ]
<operator>.indirectIndexAccess chains [ j ] [ 0 ]
<operator>.indirectIndexAccess cards [ i ]
<operator>.indirectIndexAccess chains [ j ] [ 1 ]
<operator>.indirectIndexAccess chains [ j ]
<operator>.indirectIndexAccess cards [ i ]
<operator>.indirectIndexAccess chains [ j ]
<operator>.indirectIndexAccess chains [ j ]
<operator>.indirectIndexAccess chains [ j ]
<operator>.indirectIndexAccess chains [ j ] [ 0 ]
<operator>.indirectIndexAccess chains [ j ]
<operator>.indirectIndexAccess chains [ i ] [ 0 ]
<operator>.indirectIndexAccess chains [ i ] [ 1 ]
<operator>.indirectIndexAccess chains [ j ] [ 0 ]
<operator>.indirectIndexAccess chains [ i ] [ 0 ]
<operator>.indirectIndexAccess chains [ i ]
<operator>.indirectIndexAccess chains [ i ]
<operator>.indirectIndexAccess chains [ j ]
<operator>.indirectIndexAccess chains [ i ]
>>>PDG&79 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->35 0->36 0->39 0->40 0->43 0->44 0->45 0->47 0->48 0->50 2->5 3->10 3->31 4->1 5->1 5->1 5->6 5->7 5->13 6->7 6->8 6->14 7->3 7->8 7->10 7->15 7->16 7->18 7->26 7->43 8->8 8->9 8->9 8->17 8->23 8->25 8->27 8->31 9->8 10->4 10->11 10->19 10->26 10->44 10->52 10->56 11->10 12->4 13->1 14->1 15->1 16->8 17->25 17->32 18->10 19->36 19->45 20->13 21->14 22->15 23->23 23->24 23->31 23->33 23->42 23->48 23->59 23->64 23->65 24->31 25->23 25->28 25->29 25->30 25->34 25->53 25->54 25->55 25->57 25->58 26->10 26->11 26->34 26->36 26->40 26->44 26->51 27->31 30->10 30->31 31->10 31->23 31->23 31->24 31->30 31->32 32->23 32->25 33->37 33->38 33->39 33->61 33->62 33->63 33->67 33->68 34->34 34->35 34->44 34->46 34->51 34->69 34->70 34->71 34->72 34->75 34->76 35->44 36->10 36->11 36->34 36->41 37->42 37->46 38->43 39->25 39->32 40->44 41->1 42->33 42->33 42->43 42->46 42->60 42->66 43->26 43->33 43->33 43->38 44->11 44->34 44->34 44->35 44->45 45->34 45->36 46->49 46->50 46->73 46->74 46->77 46->78 47->41 48->28 48->37 48->42 48->42 49->46 50->36 50->45 51->26 51->46 51->46 51->49
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int works ( int amo ) { if ( amo == 0 ) { return TRUE ; } if ( numCards == 0 ) { return FALSE ; } if ( amo == 1 ) { return TRUE ; } numCh = 0 ; int place ; int i , j ; int found ; for ( i = 0 ; i < numCards ; i ++ ) { found = FALSE ; for ( j = 0 ; j < numCh && ! found ; j ++ ) { if ( chains [ j ] [ 0 ] == cards [ i ] - 1 && chains [ j ] [ 1 ] < amo ) { chains [ j ] [ 0 ] = cards [ i ] ; chains [ j ] [ 1 ] ++ ; found = TRUE ; } } if ( ! found ) { chains [ numCh ] [ 0 ] = cards [ i ] ; chains [ numCh ] [ 1 ] = 1 ; numCh ++ ; } } for ( i = 0 ; i < numCh ; i ++ ) { found = FALSE ; if ( chains [ i ] [ 1 ] < amo ) { for ( j = 0 ; j < i && ! found ; j ++ ) { if ( chains [ j ] [ 0 ] == chains [ i ] [ 0 ] - chains [ i ] [ 1 ] ) { chains [ j ] [ 0 ] = chains [ i ] [ 0 ] ; found = TRUE ; } } if ( ! found ) { return FALSE ; } } } return TRUE ; }
>>>Func
METHOD sort
METHOD_RETURN void
PARAM double x [ ]
PARAM int len
RETURN return ; return ;
<operator>.lessEqualsThan k <= len - 2
<operator>.postIncrement k ++
<operator>.assignment k = 0
<operator>.assignment m = k
<operator>.assignment hold = x [ m ]
<operator>.assignment x [ m ] = x [ k ]
<operator>.assignment x [ k ] = hold
<operator>.subtraction len - 2
<operator>.lessEqualsThan j <= len - 1
<operator>.postIncrement j ++
<operator>.assignment j = k + 1
<operator>.greaterThan x [ j ] > x [ m ]
<operator>.subtraction len - 1
<operator>.assignment m = j
<operator>.addition k + 1
<operator>.indirectIndexAccess x [ m ]
<operator>.indirectIndexAccess x [ m ]
<operator>.indirectIndexAccess x [ k ]
<operator>.indirectIndexAccess x [ k ]
<operator>.indirectIndexAccess x [ j ]
<operator>.indirectIndexAccess x [ m ]
>>>PDG&26 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->19 2->1 2->9 2->10 2->16 3->12 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->8 5->8 5->9 5->10 5->11 5->12 5->13 5->15 5->15 5->17 5->19 5->19 5->20 5->21 5->22 5->23 6->1 6->5 7->1 7->5 8->1 8->1 9->1 9->11 10->1 10->1 10->9 10->16 11->1 11->1 11->1 11->10 12->1 12->5 12->5 12->17 13->1 13->1 13->1 13->13 13->14 13->14 13->16 13->17 13->18 13->24 13->25 14->1 14->13 15->1 15->1 15->13 16->1 16->1 16->9 16->18 17->12 17->13 17->13 18->1 18->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void sort ( double x [ ] , int len ) { int k , j , m ; double hold ; for ( k = 0 ; k <= len - 2 ; k ++ ) { m = k ; for ( j = k + 1 ; j <= len - 1 ; j ++ ) if ( x [ j ] > x [ m ] ) m = j ; hold = x [ m ] ; x [ m ] = x [ k ] ; x [ k ] = hold ; } return ; }
>>>Func
METHOD usage
METHOD_RETURN void
PARAM int status
exit exit ( status )
<operator>.notEquals status != EXIT_SUCCESS
emit_try_help emit_try_help ( )
fputs fputs ( HELP_OPTION_DESCRIPTION , stdout )
fputs fputs ( VERSION_OPTION_DESCRIPTION , stdout )
emit_ancillary_info emit_ancillary_info ( PROGRAM_NAME )
UNKNOWN printf ( _ ( "\\012Usage: %s FILE1 FILE2\n\\012or:  %s OPTION\n"\x20\x29\x20\x2c\x20\x70\x72\x6f\x67\x72\x61\x6d\x5f\x6e\x61\x6d\x65\x20\x2c\x20\x70\x72\x6f\x67\x72\x61\x6d\x5f\x6e\x61\x6d\x65\x20\x29\x20\x3b\x20\x66\x70\x75\x74\x73\x20\x28\x20\x5f\x20\x28\x20\x0"Call the link function to create a link named FILE2\\012to an existing FILE1.\n\n" ) , stdout ) ; printf ( _ ( "\\012Usage: %s FILE1 FILE2\n\\012or:  %s OPTION\n"\x20\x29\x20\x2c\x20\x70\x72\x6f\x67\x72\x61\x6d\x5f\x6e\x61\x6d\x65\x20\x2c\x20\x70\x72\x6f\x67\x72\x61\x6d\x5f\x6e\x61\x6d\x65\x20\x29\x20\x3b\x20\x66\x70\x75\x74\x73\x20\x28\x20\x5f\x20\x28\x20\x0"Call the link function to create a link named FILE2\\012to an existing FILE1.\n\n" ) , stdout ) ;
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->4 3->1 4->1 4->1 4->3 4->5 4->6 4->7 4->8 4->9 5->1 6->1 6->1 6->7 7->1 7->1 7->1 8->1 8->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void usage ( int status ) { if ( status != EXIT_SUCCESS ) emit_try_help ( ) ; else { printf ( _ ( "\ Usage: %s FILE1 FILE2\n\ or:  %s OPTION\n"\x20\x29\x20\x2c\x20\x70\x72\x6f\x67\x72\x61\x6d\x5f\x6e\x61\x6d\x65\x20\x2c\x20\x70\x72\x6f\x67\x72\x61\x6d\x5f\x6e\x61\x6d\x65\x20\x29\x20\x3b\x20\x66\x70\x75\x74\x73\x20\x28\x20\x5f\x20\x28\x20\x0"Call the link function to create a link named FILE2\ to an existing FILE1.\n\n" ) , stdout ) ; fputs ( HELP_OPTION_DESCRIPTION , stdout ) ; fputs ( VERSION_OPTION_DESCRIPTION , stdout ) ; emit_ancillary_info ( PROGRAM_NAME ) ; } exit ( status ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
scanf scanf ( "\x20\x25\x64\x0" , & N )
RETURN return 0 ; return 0 ;
<operator>.lessThan n < N
<operator>.postIncrement n ++
LITERAL 0 return 0 ;
<operator>.assignment n = 0
scanf scanf ( " %d %d" , & M , & V )
<operator>.assignment k = ( M - 1 ) / 2
<operator>.assignment min = 10000
<operator>.lessThan i < ( M - 1 ) / 2
<operator>.postIncrement i ++
<operator>.lessThan j < ( M + 1 ) / 2
<operator>.postIncrement j ++
<operator>.lessThan bit < 1 << k
<operator>.postIncrement bit ++
<operator>.equals min == 10000
<operator>.assignment i = 0
scanf scanf ( " %d %d" , & G , & C )
<operator>.assignment node [ i ] . v = G
<operator>.assignment node [ i ] . f = C
<operator>.assignment j = 0
scanf scanf ( " %d" , & I )
<operator>.assignment node [ i ] . v = I
<operator>.assignment node [ i ] . f = LEAF
<operator>.postIncrement i ++
<operator>.division ( M - 1 ) / 2
<operator>.assignment bit = 0
<operator>.assignment c = 0
<operator>.assignment ret = search ( 0 )
printf printf ( "Case #%d: IMPOSSIBLE\n" , n + 1 )
<operator>.division ( M - 1 ) / 2
<operator>.division ( M + 1 ) / 2
<operator>.subtraction M - 1
<operator>.shiftLeft 1 << k
<operator>.lessThan i < M
<operator>.postIncrement i ++
<operator>.lessThan i < k
<operator>.postIncrement i ++
<operator>.equals ret == V
printf printf ( "Case #%d: %d\n" , n + 1 , min )
<operator>.subtraction M - 1
<operator>.addition M + 1
<operator>.assignment i = 0
<operator>.assignment node_tmp [ i ] . v = node [ i ] . v
<operator>.assignment node_tmp [ i ] . f = node [ i ] . f
<operator>.assignment i = 0
search search ( 0 )
<operator>.addition n + 1
<operator>.logicalAnd node [ i ] . f == YES && ( bit & ( 1 << i ) )
<operator>.lessThan c < min
<operator>.addition n + 1
<operator>.assignment node_tmp [ i ] . v = node [ i ] . v ^ 1
<operator>.postIncrement c ++
<operator>.assignment min = c
<operator>.equals node [ i ] . f == YES
<operator>.and bit & ( 1 << i )
<operator>.shiftLeft 1 << i
<operator>.xor node [ i ] . v ^ 1
<operator>.addressOf & M
<operator>.addressOf & V
<operator>.addressOf & G
<operator>.addressOf & C
<operator>.fieldAccess node [ i ] . v
<operator>.fieldAccess node [ i ] . f
<operator>.addressOf & I
<operator>.fieldAccess node [ i ] . v
<operator>.fieldAccess node [ i ] . f
<operator>.indirectIndexAccess node [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess node [ i ]
FIELD_IDENTIFIER f f
<operator>.indirectIndexAccess node [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess node [ i ]
FIELD_IDENTIFIER f f
<operator>.fieldAccess node_tmp [ i ] . v
<operator>.fieldAccess node [ i ] . v
<operator>.fieldAccess node_tmp [ i ] . f
<operator>.fieldAccess node [ i ] . f
<operator>.indirectIndexAccess node_tmp [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess node [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess node_tmp [ i ]
FIELD_IDENTIFIER f f
<operator>.indirectIndexAccess node [ i ]
FIELD_IDENTIFIER f f
<operator>.fieldAccess node [ i ] . f
<operator>.fieldAccess node_tmp [ i ] . v
<operator>.indirectIndexAccess node [ i ]
FIELD_IDENTIFIER f f
<operator>.indirectIndexAccess node_tmp [ i ]
FIELD_IDENTIFIER v v
<operator>.fieldAccess node [ i ] . v
<operator>.indirectIndexAccess node [ i ]
FIELD_IDENTIFIER v v
>>>PDG&99 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->48 0->49 0->50 0->52 0->53 0->55 0->56 0->57 0->58 0->59 0->60 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->10 5->11 5->12 5->14 5->16 5->18 5->19 5->23 5->28 5->29 5->32 5->33 5->34 5->35 5->36 5->42 5->43 5->44 5->50 5->53 5->61 5->62 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->34 9->35 9->37 9->43 9->44 10->1 10->1 10->36 11->1 11->18 11->52 12->1 12->1 12->12 12->13 12->13 12->20 12->21 12->22 12->27 12->33 12->43 12->63 12->64 12->65 12->66 12->70 12->71 12->72 12->73 13->1 13->12 14->1 14->1 14->1 14->14 14->15 14->15 14->24 14->25 14->26 14->27 14->34 14->44 14->67 14->68 14->69 14->74 14->75 14->76 14->77 15->1 15->14 16->1 16->1 16->1 16->16 16->17 16->17 16->30 16->31 16->36 16->37 16->39 16->41 16->45 16->48 16->49 16->58 17->1 17->16 18->1 18->1 18->32 18->42 18->42 18->50 18->53 19->1 19->12 20->1 20->1 20->21 21->1 21->1 22->1 22->1 23->1 23->14 24->1 24->25 25->1 25->1 26->1 26->1 27->1 27->1 28->1 28->10 28->10 29->1 29->16 30->1 30->1 30->52 30->55 31->1 31->1 31->41 32->1 32->1 33->12 33->12 34->1 34->14 34->14 35->1 35->9 35->28 35->28 35->37 35->43 36->1 36->16 36->16 36->39 37->1 37->1 37->9 37->37 37->38 37->38 37->43 37->46 37->47 37->78 37->79 37->80 37->81 37->82 37->83 37->84 37->85 37->86 37->87 37->88 37->89 38->1 38->37 39->1 39->1 39->36 39->39 39->40 39->40 39->51 39->57 39->59 39->90 39->92 39->93 40->1 40->39 41->1 41->1 41->1 41->52 42->1 42->1 42->1 43->33 43->33 43->34 43->35 43->44 45->37 46->1 47->1 48->1 48->39 49->31 51->1 51->1 51->1 51->54 51->55 51->60 51->91 51->94 51->95 51->96 51->97 51->98 52->1 52->1 52->18 52->56 52->56 54->1 54->1 55->1 55->1 55->52 56->1 56->1 56->18 56->52 57->1 57->51 57->51 57->58 57->59 58->1 58->17 58->51 58->51 59->40 59->58 59->58 60->54 60->54
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( void ) { int N , G , C , M , I , V ; int n , i , j , c , k , min , bit , ret ; scanf ( "\x20\x25\x64\x0" , & N ) ; for ( n = 0 ; n < N ; n ++ ) { scanf ( " %d %d" , & M , & V ) ; for ( i = 0 ; i < ( M - 1 ) / 2 ; i ++ ) { scanf ( " %d %d" , & G , & C ) ; node [ i ] . v = G ; node [ i ] . f = C ; } for ( j = 0 ; j < ( M + 1 ) / 2 ; j ++ ) { scanf ( " %d" , & I ) ; node [ i ] . v = I ; node [ i ] . f = LEAF ; i ++ ; } k = ( M - 1 ) / 2 ; min = 10000 ; for ( bit = 0 ; bit < 1 << k ; bit ++ ) { for ( i = 0 ; i < M ; i ++ ) { node_tmp [ i ] . v = node [ i ] . v ; node_tmp [ i ] . f = node [ i ] . f ; } c = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( node [ i ] . f == YES && ( bit & ( 1 << i ) ) ) { node_tmp [ i ] . v = node [ i ] . v ^ 1 ; c ++ ; } } ret = search ( 0 ) ; if ( ret == V ) { if ( c < min ) { min = c ; } } } if ( min == 10000 ) { printf ( "Case #%d: IMPOSSIBLE\n" , n + 1 ) ; } else { printf ( "Case #%d: %d\n" , n + 1 , min ) ; } } return 0 ; }
>>>Func
METHOD bSTIteratorHasNext
METHOD_RETURN bool
PARAM BSTIterator * obj
printf printf ( "\x20\x48\x65\x72\x65\x20\x0" )
RETURN return ( obj -> values [ obj -> CurrentIndex ] == INT_MAX ) ? false : true ; return ( obj -> values [ obj -> CurrentIndex ] == INT_MAX ) ? false : true ;
<operator>.logicalNot ! obj -> NumberOfNodes
<operator>.conditional ( obj -> values [ obj -> CurrentIndex ] == INT_MAX ) ? false : true
RETURN return false ; return false ;
IDENTIFIER false return false ;
<operator>.equals obj -> values [ obj -> CurrentIndex ] == INT_MAX
<operator>.indirectIndexAccess obj -> values [ obj -> CurrentIndex ]
<operator>.indirectFieldAccess obj -> values
<operator>.indirectFieldAccess obj -> CurrentIndex
FIELD_IDENTIFIER values values
FIELD_IDENTIFIER CurrentIndex CurrentIndex
>>>PDG&15 0->2 0->3 0->6 0->7 0->8 0->9 2->1 4->1 5->1 5->1 5->3 5->4 5->6 5->7 5->9 5->10 5->11 5->12 5->13 5->14 6->1 6->4 7->1 8->7 9->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) bool bSTIteratorHasNext ( BSTIterator * obj ) { if ( ! obj -> NumberOfNodes ) { return false ; } printf ( "\x20\x48\x65\x72\x65\x20\x0" ) ; return ( obj -> values [ obj -> CurrentIndex ] == INT_MAX ) ? false : true ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment * fp = fopen ( argv [ 1 ] , "\x72\x0" )
<operator>.assignment * line = NULL
<operator>.assignment len = 0
<operator>.assignment read = getline ( & line , & len , fp )
<operator>.assignment total = atoi ( line )
free free ( line )
fclose fclose ( fp )
RETURN return 0 ; return 0 ;
<operator>.equals fp == NULL
<operator>.logicalAnd total >= 1 && total <= 100
<operator>.lessThan j < total
<operator>.preIncrement ++ j
LITERAL 0 return 0 ;
fopen fopen ( argv [ 1 ] , "\x72\x0" )
exit exit ( 1 )
getline getline ( & line , & len , fp )
atoi atoi ( line )
<operator>.assignment j = 0
<operator>.assignment comb [ 4 ] = { 0 }
<operator>.assignment opp [ 3 ] = { 0 }
<operator>.assignment num [ 101 ] = { 0 }
<operator>.assignment result [ 303 ] = { 0 }
<operator>.assignment totalbits = 0
getline getline ( & line , & len , fp )
sscanf sscanf ( line , "%d %n" , & combine , & retbits )
<operator>.assignmentPlus totalbits += retbits
sscanf sscanf ( line + totalbits , "%d %n" , & opposed , & retbits )
<operator>.assignmentPlus totalbits += retbits
sscanf sscanf ( line + totalbits , "%d %n" , & numb , & retbits )
<operator>.assignmentPlus totalbits += retbits
<operator>.assignment pos = 0
printf printf ( "Case #%d: [%s]\n" , j + 1 , result )
<operator>.greaterEqualsThan total >= 1
<operator>.lessEqualsThan total <= 100
free free ( line )
fclose fclose ( fp )
exit exit ( 1 )
<operator>.notEquals combine != 0
<operator>.notEquals opposed != 0
<operator>.notEquals numb != 0
<operator>.lessThan i < numb - 1
<operator>.preIncrement ++ i
<operator>.equals i == numb - 1
<operator>.equals result [ strlen ( result ) - 2 ] == ' '
<operator>.arrayInitializer { 0 }
<operator>.arrayInitializer { 0 }
<operator>.arrayInitializer { 0 }
<operator>.arrayInitializer { 0 }
sscanf sscanf ( line + totalbits , "%s %n" , comb , & retbits )
<operator>.assignmentPlus totalbits += retbits
<operator>.addition line + totalbits
sscanf sscanf ( line + totalbits , "%s %n" , opp , & retbits )
<operator>.assignmentPlus totalbits += retbits
<operator>.addition line + totalbits
sscanf sscanf ( line + totalbits , "%s %n" , num , & retbits )
<operator>.assignmentPlus totalbits += retbits
<operator>.assignment i = 0
<operator>.assignment result [ pos ++ ] = num [ i ]
memcpy memcpy ( & result [ pos ++ ] , "," , 1 )
memcpy memcpy ( & result [ pos ++ ] , " " , 1 )
<operator>.assignment result [ pos ] = num [ i ]
<operator>.assignment result [ strlen ( result ) - 2 ] = '\0'
<operator>.addition j + 1
<operator>.subtraction numb - 1
<operator>.logicalOr ( num [ i ] == comb [ 0 ] && num [ i + 1 ] == comb [ 1 ] ) || ( num [ i ] == comb [ 1 ] && num [ i + 1 ] == comb [ 0 ] )
<operator>.equals num [ i ] == opp [ 0 ]
<operator>.equals num [ i ] == opp [ 1 ]
<operator>.subtraction numb - 1
<operator>.addition line + totalbits
<operator>.addition line + totalbits
<operator>.addition line + totalbits
<operator>.assignment result [ pos ++ ] = comb [ 2 ]
memcpy memcpy ( & result [ pos ++ ] , "," , 1 )
memcpy memcpy ( & result [ pos ++ ] , " " , 1 )
<operator>.preIncrement ++ i
<operator>.assignment tag = 0
<operator>.assignment tag = 0
<operator>.subtraction strlen ( result ) - 2
<operator>.logicalAnd num [ i ] == comb [ 0 ] && num [ i + 1 ] == comb [ 1 ]
<operator>.logicalAnd num [ i ] == comb [ 1 ] && num [ i + 1 ] == comb [ 0 ]
<operator>.lessThan k < numb
<operator>.preIncrement ++ k
<operator>.equals tag == 0
<operator>.lessThan k < numb
<operator>.preIncrement ++ k
<operator>.equals tag == 0
<operator>.postIncrement pos ++
strlen strlen ( result )
<operator>.subtraction strlen ( result ) - 2
<operator>.equals num [ i ] == comb [ 0 ]
<operator>.equals num [ i + 1 ] == comb [ 1 ]
<operator>.equals num [ i ] == comb [ 1 ]
<operator>.equals num [ i + 1 ] == comb [ 0 ]
<operator>.assignment k = i + 1
<operator>.equals num [ k ] == opp [ 1 ]
<operator>.assignment result [ pos ++ ] = num [ i ]
memcpy memcpy ( & result [ pos ++ ] , "," , 1 )
memcpy memcpy ( & result [ pos ++ ] , " " , 1 )
<operator>.assignment k = i + 1
<operator>.equals num [ k ] == opp [ 0 ]
<operator>.assignment result [ pos ++ ] = num [ i ]
memcpy memcpy ( & result [ pos ++ ] , "," , 1 )
memcpy memcpy ( & result [ pos ++ ] , " " , 1 )
<operator>.postIncrement pos ++
<operator>.postIncrement pos ++
strlen strlen ( result )
<operator>.postIncrement pos ++
<operator>.assignment tag = 1
<operator>.assignment tag = 1
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.postIncrement pos ++
<operator>.postIncrement pos ++
<operator>.addition i + 1
<operator>.logicalOr ( num [ k - 1 ] == comb [ 0 ] && num [ k ] == comb [ 1 ] ) || ( num [ k - 1 ] == comb [ 1 ] && num [ k ] == comb [ 0 ] )
<operator>.addition i + 1
<operator>.logicalOr ( num [ k - 1 ] == comb [ 0 ] && num [ k ] == comb [ 1 ] ) || ( num [ k - 1 ] == comb [ 1 ] && num [ k ] == comb [ 0 ] )
<operator>.assignment result [ pos ++ ] = num [ i ]
memcpy memcpy ( & result [ pos ++ ] , "," , 1 )
memcpy memcpy ( & result [ pos ++ ] , " " , 1 )
<operator>.postIncrement pos ++
<operator>.assignment result [ pos ++ ] = num [ i ]
memcpy memcpy ( & result [ pos ++ ] , "," , 1 )
memcpy memcpy ( & result [ pos ++ ] , " " , 1 )
<operator>.postIncrement pos ++
<operator>.logicalAnd num [ k - 1 ] == comb [ 0 ] && num [ k ] == comb [ 1 ]
<operator>.logicalAnd num [ k - 1 ] == comb [ 1 ] && num [ k ] == comb [ 0 ]
<operator>.assignment i = k
<operator>.postIncrement pos ++
<operator>.postIncrement pos ++
<operator>.logicalAnd num [ k - 1 ] == comb [ 0 ] && num [ k ] == comb [ 1 ]
<operator>.logicalAnd num [ k - 1 ] == comb [ 1 ] && num [ k ] == comb [ 0 ]
<operator>.assignment i = k
<operator>.postIncrement pos ++
<operator>.postIncrement pos ++
<operator>.equals num [ k - 1 ] == comb [ 0 ]
<operator>.equals num [ k ] == comb [ 1 ]
<operator>.equals num [ k - 1 ] == comb [ 1 ]
<operator>.equals num [ k ] == comb [ 0 ]
<operator>.equals num [ k - 1 ] == comb [ 0 ]
<operator>.equals num [ k ] == comb [ 1 ]
<operator>.equals num [ k - 1 ] == comb [ 1 ]
<operator>.equals num [ k ] == comb [ 0 ]
<operator>.postIncrement pos ++
<operator>.postIncrement pos ++
<operator>.subtraction k - 1
<operator>.subtraction k - 1
<operator>.postIncrement pos ++
<operator>.postIncrement pos ++
<operator>.subtraction k - 1
<operator>.subtraction k - 1
<operator>.postIncrement pos ++
<operator>.postIncrement pos ++
<operator>.addressOf & line
<operator>.addressOf & len
<operator>.addressOf & combine
<operator>.addressOf & retbits
<operator>.addressOf & opposed
<operator>.addressOf & retbits
<operator>.addressOf & numb
<operator>.addressOf & retbits
<operator>.indirectIndexAccess result [ strlen ( result ) - 2 ]
<operator>.addressOf & retbits
<operator>.addressOf & retbits
<operator>.addressOf & retbits
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess num [ i ]
<operator>.addressOf & result [ pos ++ ]
<operator>.addressOf & result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ]
<operator>.indirectIndexAccess num [ i ]
<operator>.indirectIndexAccess result [ strlen ( result ) - 2 ]
<operator>.indirectIndexAccess num [ i ]
<operator>.indirectIndexAccess opp [ 0 ]
<operator>.indirectIndexAccess num [ i ]
<operator>.indirectIndexAccess opp [ 1 ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess comb [ 2 ]
<operator>.addressOf & result [ pos ++ ]
<operator>.addressOf & result [ pos ++ ]
<operator>.indirectIndexAccess num [ i ]
<operator>.indirectIndexAccess comb [ 0 ]
<operator>.indirectIndexAccess num [ i + 1 ]
<operator>.indirectIndexAccess comb [ 1 ]
<operator>.indirectIndexAccess num [ i ]
<operator>.indirectIndexAccess comb [ 1 ]
<operator>.indirectIndexAccess num [ i + 1 ]
<operator>.indirectIndexAccess comb [ 0 ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess num [ k ]
<operator>.indirectIndexAccess opp [ 1 ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess num [ i ]
<operator>.addressOf & result [ pos ++ ]
<operator>.addressOf & result [ pos ++ ]
<operator>.indirectIndexAccess num [ k ]
<operator>.indirectIndexAccess opp [ 0 ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess num [ i ]
<operator>.addressOf & result [ pos ++ ]
<operator>.addressOf & result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess num [ i ]
<operator>.addressOf & result [ pos ++ ]
<operator>.addressOf & result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess num [ i ]
<operator>.addressOf & result [ pos ++ ]
<operator>.addressOf & result [ pos ++ ]
<operator>.indirectIndexAccess num [ k - 1 ]
<operator>.indirectIndexAccess comb [ 0 ]
<operator>.indirectIndexAccess num [ k ]
<operator>.indirectIndexAccess comb [ 1 ]
<operator>.indirectIndexAccess num [ k - 1 ]
<operator>.indirectIndexAccess comb [ 1 ]
<operator>.indirectIndexAccess num [ k ]
<operator>.indirectIndexAccess comb [ 0 ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess num [ k - 1 ]
<operator>.indirectIndexAccess comb [ 0 ]
<operator>.indirectIndexAccess num [ k ]
<operator>.indirectIndexAccess comb [ 1 ]
<operator>.indirectIndexAccess num [ k - 1 ]
<operator>.indirectIndexAccess comb [ 1 ]
<operator>.indirectIndexAccess num [ k ]
<operator>.indirectIndexAccess comb [ 0 ]
<operator>.indirectIndexAccess result [ pos ++ ]
<operator>.indirectIndexAccess result [ pos ++ ]
>>>PDG&240 0->2 0->3 0->5 0->6 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->62 0->63 0->65 0->66 0->67 0->71 0->72 0->73 0->74 0->76 0->77 0->78 0->79 0->80 0->81 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->97 0->100 0->101 0->102 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->114 0->115 0->116 0->117 0->119 0->122 0->123 0->124 0->126 0->127 0->128 0->131 0->132 0->133 0->136 0->137 0->138 0->147 0->148 0->149 0->150 0->151 0->152 0->153 0->154 0->155 0->156 2->1 3->1 3->17 4->1 4->1 4->12 5->1 5->1 5->19 5->20 6->1 6->1 6->19 6->27 7->1 7->1 7->1 8->1 8->1 8->36 9->1 10->1 10->1 11->1 12->1 12->5 12->18 12->19 13->1 13->1 13->1 14->1 14->1 14->1 14->14 14->15 14->15 14->22 14->23 14->24 14->25 14->26 14->27 14->28 14->29 14->30 14->31 14->32 14->33 14->34 14->35 14->35 14->41 14->42 14->43 14->44 14->46 14->47 14->48 14->49 14->50 14->51 14->54 14->57 14->60 14->66 14->66 14->67 14->71 14->81 14->91 14->157 14->158 14->159 14->160 14->161 14->162 14->163 14->164 14->165 15->1 15->14 16->11 17->1 17->4 17->4 19->1 19->1 19->7 19->7 19->7 19->9 19->20 19->27 19->27 19->28 19->38 19->39 20->8 20->38 21->1 21->14 22->1 22->1 22->52 22->75 22->93 22->94 22->95 22->96 22->139 22->140 22->141 22->142 22->143 22->144 22->145 22->146 23->1 23->1 23->55 23->69 23->70 23->98 23->103 24->1 24->1 24->58 24->61 24->64 24->69 24->70 24->93 24->94 24->95 24->96 24->98 24->99 24->103 24->104 24->121 24->125 24->139 24->140 24->141 24->142 24->143 24->144 24->145 24->146 25->1 25->1 25->35 25->62 25->63 25->76 25->77 25->91 25->100 25->101 25->105 25->106 25->109 25->122 25->123 25->126 25->127 26->1 26->29 27->1 27->1 27->1 27->9 27->10 27->28 27->30 27->32 27->52 27->54 27->55 27->57 27->58 27->72 27->73 27->74 28->1 28->1 28->9 28->27 28->29 28->30 28->30 28->31 28->32 28->32 28->33 28->41 28->52 28->52 28->53 28->54 28->55 28->55 28->56 28->57 28->58 28->58 28->59 28->72 28->73 28->74 29->30 29->31 29->52 29->53 29->54 29->72 30->1 30->1 30->28 30->29 30->31 30->32 30->33 30->42 30->55 30->56 30->58 30->59 31->32 31->33 31->55 31->56 31->57 31->73 32->1 32->1 32->1 32->1 32->28 32->29 32->33 32->43 32->58 32->59 32->67 32->71 32->84 32->87 33->1 33->1 33->1 33->58 33->59 33->74 34->1 34->1 34->90 34->110 34->124 34->128 34->147 34->148 35->1 35->1 35->1 36->13 36->13 36->14 36->37 36->37 37->13 37->13 37->14 38->9 38->27 38->28 39->10 39->27 41->1 41->1 41->28 41->52 41->53 41->72 41->166 42->1 42->1 42->30 42->55 42->56 42->73 42->167 43->1 43->58 43->59 43->67 43->74 43->168 44->1 44->44 44->45 44->45 44->46 44->67 44->68 44->78 44->82 44->93 44->97 44->102 44->113 44->114 44->117 44->119 44->186 44->187 45->1 45->44 46->1 46->1 46->1 46->64 46->173 46->174 47->1 47->1 47->35 47->65 47->91 47->92 47->109 47->109 47->175 48->22 49->23 50->24 51->25 52->1 52->1 52->28 52->29 52->30 52->31 52->32 52->33 52->53 52->55 52->56 52->58 52->59 52->75 52->93 52->94 52->95 52->96 52->139 52->140 52->141 52->142 52->143 52->144 52->145 52->146 53->30 53->31 53->54 55->1 55->1 55->28 55->29 55->32 55->33 55->56 55->58 55->59 55->69 55->70 55->98 55->103 56->32 56->33 56->57 58->1 58->1 58->1 58->1 58->28 58->29 58->59 58->61 58->64 58->69 58->70 58->93 58->94 58->95 58->96 58->98 58->99 58->103 58->104 58->121 58->125 58->139 58->140 58->141 58->142 58->143 58->144 58->145 58->146 59->1 59->1 59->1 60->1 60->44 61->1 61->1 61->1 61->35 61->62 61->63 61->91 61->109 62->1 62->35 62->63 62->91 62->109 63->1 63->1 63->35 63->62 63->76 63->77 63->91 63->100 63->101 63->105 63->106 63->109 63->122 63->123 63->126 63->127 64->1 64->1 64->1 64->35 64->91 64->109 65->1 65->1 65->35 65->47 65->91 67->44 67->44 67->71 67->84 67->87 68->1 68->1 68->1 68->69 68->75 68->76 68->77 68->78 68->110 68->115 68->116 68->176 68->177 68->182 68->183 68->184 68->185 68->194 68->195 69->1 69->1 69->1 69->55 69->58 69->64 69->70 69->70 69->79 69->84 69->86 69->93 69->97 69->99 69->103 69->117 69->121 69->178 69->179 70->1 70->1 70->1 70->55 70->58 70->61 70->61 70->62 70->63 70->64 70->80 70->87 70->89 70->90 70->93 70->98 70->102 70->104 70->107 70->108 70->119 70->125 70->169 70->170 70->171 70->172 70->180 70->181 71->1 71->32 71->43 71->46 71->46 75->1 75->1 75->1 75->35 75->76 75->77 75->91 75->109 76->1 76->35 76->77 76->91 76->109 77->1 77->1 77->35 77->62 77->63 77->76 77->91 77->100 77->101 77->105 77->106 77->109 77->122 77->123 77->126 77->127 78->45 79->1 79->86 80->1 80->89 81->1 82->1 82->1 82->68 82->68 82->83 82->95 82->190 82->191 83->1 83->1 83->68 83->68 84->1 84->1 84->67 84->85 84->98 84->149 84->196 84->197 85->1 85->84 86->1 86->1 86->99 86->100 86->101 86->124 86->132 86->133 86->198 86->199 86->200 86->201 86->208 86->209 87->1 87->1 87->67 87->88 87->103 87->153 87->202 87->203 88->1 88->87 89->1 89->1 89->104 89->105 89->106 89->128 89->137 89->138 89->204 89->205 89->206 89->207 89->210 89->211 90->107 91->35 91->47 91->81 91->109 92->1 93->1 93->1 93->52 93->58 93->64 93->69 93->82 93->82 93->94 93->95 93->96 93->113 93->139 93->143 93->188 93->189 94->1 94->1 94->52 94->58 94->82 94->82 94->95 94->96 94->140 94->141 94->144 94->145 95->1 95->1 95->52 95->58 95->64 95->69 95->83 95->83 95->93 95->94 95->96 95->114 95->140 95->141 95->144 95->145 95->192 95->193 96->1 96->1 96->52 96->58 96->83 96->83 96->93 96->94 96->139 96->143 97->1 97->1 97->84 98->1 98->1 98->1 98->55 98->58 98->70 98->84 98->85 98->103 98->111 98->118 98->129 98->139 98->140 98->142 98->149 98->220 98->221 99->1 99->1 99->1 99->35 99->91 99->100 99->101 99->109 100->1 100->35 100->91 100->101 100->109 101->1 101->1 101->35 101->62 101->63 101->76 101->77 101->91 101->100 101->105 101->106 101->109 101->122 101->123 101->126 101->127 102->1 102->1 102->87 103->1 103->1 103->1 103->55 103->58 103->69 103->87 103->88 103->98 103->112 103->120 103->134 103->143 103->144 103->146 103->153 103->230 103->231 104->1 104->1 104->1 104->35 104->91 104->105 104->106 104->109 105->1 105->35 105->91 105->106 105->109 106->1 106->1 106->35 106->62 106->63 106->76 106->77 106->91 106->100 106->101 106->105 106->109 106->122 106->123 106->126 106->127 107->108 108->1 108->90 108->110 108->124 108->128 108->147 108->148 109->35 109->92 110->115 111->1 111->86 112->1 112->89 115->116 116->1 116->90 116->110 116->124 116->128 116->147 116->148 118->1 118->1 118->1 118->120 118->121 118->122 118->123 118->131 118->147 118->151 118->152 118->212 118->213 118->214 118->215 118->228 118->229 120->1 120->1 120->1 120->118 120->125 120->126 120->127 120->136 120->148 120->155 120->156 120->216 120->217 120->218 120->219 120->238 120->239 121->1 121->1 121->1 121->35 121->91 121->109 121->122 121->123 122->1 122->35 122->91 122->109 122->123 123->1 123->1 123->35 123->62 123->63 123->76 123->77 123->91 123->100 123->101 123->105 123->106 123->109 123->122 123->126 123->127 124->132 125->1 125->1 125->1 125->35 125->91 125->109 125->126 125->127 126->1 126->35 126->91 126->109 126->127 127->1 127->1 127->35 127->62 127->63 127->76 127->77 127->91 127->100 127->101 127->105 127->106 127->109 127->122 127->123 127->126 128->137 129->1 129->1 129->118 129->118 129->130 129->134 129->141 129->150 129->224 129->225 130->1 130->1 130->118 130->118 130->135 131->1 131->1 131->45 132->133 133->1 133->90 133->110 133->124 133->128 133->147 133->148 134->1 134->1 134->120 134->120 134->129 134->135 134->145 134->154 134->234 134->235 135->1 135->1 135->120 135->120 135->130 136->1 136->1 136->45 137->138 138->1 138->90 138->110 138->124 138->128 138->147 138->148 139->1 139->1 139->52 139->58 139->93 139->129 139->129 139->140 139->141 139->142 139->143 139->222 139->223 140->1 140->1 140->52 140->58 140->94 140->95 140->98 140->103 140->129 140->129 140->141 140->142 140->144 140->145 141->1 141->1 141->52 141->58 141->94 141->95 141->130 141->130 141->139 141->140 141->142 141->143 141->144 141->145 141->226 141->227 142->1 142->1 142->52 142->58 142->93 142->98 142->103 142->130 142->130 143->1 143->1 143->52 143->58 143->93 143->134 143->134 143->139 143->144 143->145 143->146 143->232 143->233 144->1 144->1 144->52 144->58 144->94 144->95 144->98 144->103 144->134 144->134 144->140 144->141 144->145 144->146 145->1 145->1 145->52 145->58 145->94 145->95 145->135 145->135 145->139 145->140 145->141 145->143 145->144 145->146 145->236 145->237 146->1 146->1 146->52 146->58 146->93 146->98 146->103 146->135 146->135 147->151 148->155 149->1 149->131 149->150 150->1 150->131 151->152 152->1 152->90 152->110 152->124 152->128 152->147 152->148 153->1 153->136 153->154 154->1 154->136 155->156 156->1 156->90 156->110 156->124 156->128 156->147 156->148
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( int argc , char * * argv ) { FILE * fp = fopen ( argv [ 1 ] , "\x72\x0" ) ; if ( fp == NULL ) { exit ( 1 ) ; } char * line = NULL ; size_t len = 0 ; ssize_t read ; read = getline ( & line , & len , fp ) ; int total = atoi ( line ) ; if ( total >= 1 && total <= 100 ) ; else { free ( line ) ; fclose ( fp ) ; exit ( 1 ) ; } int j ; for ( j = 0 ; j < total ; ++ j ) { int combine , opposed , numb ; char comb [ 4 ] = { 0 } , opp [ 3 ] = { 0 } , num [ 101 ] = { 0 } , result [ 303 ] = { 0 } ; int retbits , totalbits = 0 ; getline ( & line , & len , fp ) ; sscanf ( line , "%d %n" , & combine , & retbits ) ; totalbits += retbits ; if ( combine != 0 ) { sscanf ( line + totalbits , "%s %n" , comb , & retbits ) ; totalbits += retbits ; } sscanf ( line + totalbits , "%d %n" , & opposed , & retbits ) ; totalbits += retbits ; if ( opposed != 0 ) { sscanf ( line + totalbits , "%s %n" , opp , & retbits ) ; totalbits += retbits ; } sscanf ( line + totalbits , "%d %n" , & numb , & retbits ) ; totalbits += retbits ; if ( numb != 0 ) { sscanf ( line + totalbits , "%s %n" , num , & retbits ) ; totalbits += retbits ; } int i , pos = 0 ; for ( i = 0 ; i < numb - 1 ; ++ i ) { if ( ( num [ i ] == comb [ 0 ] && num [ i + 1 ] == comb [ 1 ] ) || ( num [ i ] == comb [ 1 ] && num [ i + 1 ] == comb [ 0 ] ) ) { result [ pos ++ ] = comb [ 2 ] ; memcpy ( & result [ pos ++ ] , "," , 1 ) ; memcpy ( & result [ pos ++ ] , " " , 1 ) ; ++ i ; continue ; } if ( num [ i ] == opp [ 0 ] ) { int k , tag = 0 ; for ( k = i + 1 ; k < numb ; ++ k ) if ( num [ k ] == opp [ 1 ] ) { if ( ( num [ k - 1 ] == comb [ 0 ] && num [ k ] == comb [ 1 ] ) || ( num [ k - 1 ] == comb [ 1 ] && num [ k ] == comb [ 0 ] ) ) { result [ pos ++ ] = num [ i ] ; memcpy ( & result [ pos ++ ] , "," , 1 ) ; memcpy ( & result [ pos ++ ] , " " , 1 ) ; } else i = k ; tag = 1 ; break ; } if ( tag == 0 ) { result [ pos ++ ] = num [ i ] ; memcpy ( & result [ pos ++ ] , "," , 1 ) ; memcpy ( & result [ pos ++ ] , " " , 1 ) ; } continue ; } if ( num [ i ] == opp [ 1 ] ) { int k , tag = 0 ; for ( k = i + 1 ; k < numb ; ++ k ) if ( num [ k ] == opp [ 0 ] ) { if ( ( num [ k - 1 ] == comb [ 0 ] && num [ k ] == comb [ 1 ] ) || ( num [ k - 1 ] == comb [ 1 ] && num [ k ] == comb [ 0 ] ) ) { result [ pos ++ ] = num [ i ] ; memcpy ( & result [ pos ++ ] , "," , 1 ) ; memcpy ( & result [ pos ++ ] , " " , 1 ) ; } else i = k ; tag = 1 ; break ; } if ( tag == 0 ) { result [ pos ++ ] = num [ i ] ; memcpy ( & result [ pos ++ ] , "," , 1 ) ; memcpy ( & result [ pos ++ ] , " " , 1 ) ; } continue ; } result [ pos ++ ] = num [ i ] ; memcpy ( & result [ pos ++ ] , "," , 1 ) ; memcpy ( & result [ pos ++ ] , " " , 1 ) ; } if ( i == numb - 1 ) result [ pos ] = num [ i ] ; if ( result [ strlen ( result ) - 2 ] == ',' ) result [ strlen ( result ) - 2 ] = '\0' ; printf ( "Case #%d: [%s]\n" , j + 1 , result ) ; } free ( line ) ; fclose ( fp ) ; return 0 ; }
>>>Func
METHOD expld
METHOD_RETURN long double
PARAM long double val
PARAM unsigned int base
PARAM unsigned int * x
<operator>.assignment power = 0
RETURN return val ; return val ;
<operator>.logicalAnd val >= - LDBL_MAX && val <= LDBL_MAX
IDENTIFIER x if (x)
IDENTIFIER val return val ;
<operator>.assignment * x = power
<operator>.greaterEqualsThan val >= - LDBL_MAX
<operator>.lessEqualsThan val <= LDBL_MAX
<operator>.greaterEqualsThan absld ( val ) >= base
<operator>.minus - LDBL_MAX
<operator>.preIncrement ++ power
<operator>.assignmentDivision val /= base
absld absld ( val )
>>>PDG&18 0->2 0->3 0->4 0->5 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->11 3->1 3->13 4->1 5->1 5->1 5->10 5->15 6->1 7->1 7->1 7->1 7->13 7->17 9->6 10->1 10->1 10->1 11->1 11->1 11->7 11->7 11->9 11->12 11->12 11->17 12->1 12->1 12->7 12->7 12->9 12->17 13->1 13->1 13->1 13->13 13->15 13->16 13->16 13->17 14->1 14->11 14->12 15->1 15->1 15->10 16->1 16->17 17->1 17->9 17->13 17->16
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static long double expld ( long double val , unsigned int base , unsigned int * x ) { unsigned int power = 0 ; if ( val >= - LDBL_MAX && val <= LDBL_MAX ) { while ( absld ( val ) >= base ) { ++ power ; val /= base ; } } if ( x ) * x = power ; return val ; }
>>>Func
METHOD come_back_len
METHOD_RETURN void
PARAM int * idx
PARAM int len
<operator>.assignmentMinus * idx -= len
<operator>.lessThan * idx < 1
<operator>.assignment * idx = 1
<operator>.indirection * idx
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 2->1 3->4 4->1 4->1 4->5 5->1 5->6 5->7 6->1 6->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void come_back_len ( int * idx , int len ) { * idx -= len ; if ( * idx < 1 ) * idx = 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x5c\x6e\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= T
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 1
<operator>.assignment idx = 0
scanf scanf ( "%d " , & C )
scanf scanf ( "%d " , & D )
scanf scanf ( "%d " , & N )
printf printf ( "Case #%d: [" , t )
<operator>.lessThan c < C
<operator>.postIncrement c ++
scanf scanf ( "%s " , cmb [ c ] )
<operator>.lessThan d < D
<operator>.postIncrement d ++
scanf scanf ( "%s " , opp [ d ] )
<operator>.lessThan n < N
<operator>.postIncrement n ++
IDENTIFIER idx if (idx)
<operator>.assignment c = 0
<operator>.assignment d = 0
<operator>.assignment n = 0
scanf scanf ( "%c" , & e )
<operator>.assignment list [ idx ++ ] = e
printf printf ( "%c]\n" , list [ idx - 1 ] )
<operator>.logicalNot ! idx
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < C
<operator>.lessThan i < D
<operator>.postIncrement i ++
<operator>.lessThan i < D
<operator>.lessThan i < idx - 1
<operator>.postIncrement i ++
printf printf ( "%c, " , list [ i ] )
printf printf ( "]\n" )
<operator>.assignment list [ idx ++ ] = e
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.logicalAnd cmb [ i ] [ 0 ] == e && list [ idx - 1 ] == cmb [ i ] [ 1 ]
<operator>.logicalAnd cmb [ i ] [ 1 ] == e && list [ idx - 1 ] == cmb [ i ] [ 0 ]
<operator>.equals opp [ i ] [ 0 ] == e
<operator>.equals opp [ i ] [ 1 ] == e
<operator>.lessThan i < idx
<operator>.postIncrement i ++
<operator>.logicalNot ! idx
<operator>.postIncrement idx ++
<operator>.subtraction idx - 1
<operator>.subtraction idx - 1
<operator>.assignment list [ idx - 1 ] = cmb [ i ] [ 2 ]
<operator>.assignment list [ idx - 1 ] = cmb [ i ] [ 2 ]
<operator>.assignment e1 = opp [ i ] [ 1 ]
<operator>.assignment e1 = opp [ i ] [ 0 ]
<operator>.assignment i = 0
<operator>.postIncrement idx ++
<operator>.equals cmb [ i ] [ 0 ] == e
<operator>.equals list [ idx - 1 ] == cmb [ i ] [ 1 ]
<operator>.equals cmb [ i ] [ 1 ] == e
<operator>.equals list [ idx - 1 ] == cmb [ i ] [ 0 ]
<operator>.equals list [ i ] == e1
<operator>.assignment idx = 0
<operator>.subtraction idx - 1
<operator>.subtraction idx - 1
<operator>.subtraction idx - 1
<operator>.subtraction idx - 1
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.indirectIndexAccess cmb [ c ]
<operator>.indirectIndexAccess opp [ d ]
<operator>.addressOf & e
<operator>.indirectIndexAccess list [ idx ++ ]
<operator>.indirectIndexAccess list [ idx - 1 ]
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess list [ idx ++ ]
<operator>.indirectIndexAccess opp [ i ] [ 0 ]
<operator>.indirectIndexAccess opp [ i ] [ 1 ]
<operator>.indirectIndexAccess cmb [ i ] [ 0 ]
<operator>.indirectIndexAccess list [ idx - 1 ]
<operator>.indirectIndexAccess cmb [ i ] [ 1 ]
<operator>.indirectIndexAccess list [ idx - 1 ]
<operator>.indirectIndexAccess cmb [ i ] [ 2 ]
<operator>.indirectIndexAccess cmb [ i ] [ 1 ]
<operator>.indirectIndexAccess list [ idx - 1 ]
<operator>.indirectIndexAccess cmb [ i ] [ 0 ]
<operator>.indirectIndexAccess list [ idx - 1 ]
<operator>.indirectIndexAccess cmb [ i ] [ 2 ]
<operator>.indirectIndexAccess opp [ i ]
<operator>.indirectIndexAccess opp [ i ] [ 1 ]
<operator>.indirectIndexAccess opp [ i ]
<operator>.indirectIndexAccess opp [ i ] [ 0 ]
<operator>.indirectIndexAccess cmb [ i ]
<operator>.indirectIndexAccess cmb [ i ]
<operator>.indirectIndexAccess cmb [ i ]
<operator>.indirectIndexAccess cmb [ i ]
<operator>.indirectIndexAccess cmb [ i ]
<operator>.indirectIndexAccess cmb [ i ]
<operator>.indirectIndexAccess opp [ i ]
<operator>.indirectIndexAccess opp [ i ]
<operator>.indirectIndexAccess list [ i ]
>>>PDG&104 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->57 0->58 0->59 0->61 0->63 0->64 0->65 0->66 0->67 0->68 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->16 4->19 4->22 4->23 4->24 4->27 4->35 4->38 4->42 4->51 4->52 4->69 4->70 4->71 4->76 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->28 8->51 9->1 9->13 9->29 9->31 10->1 10->16 10->32 10->34 11->1 11->19 12->1 12->5 13->1 13->1 13->1 13->9 13->13 13->14 13->14 13->15 13->29 13->72 14->1 14->13 15->1 16->1 16->1 16->1 16->10 16->16 16->17 16->17 16->18 16->32 16->73 17->1 17->16 18->1 19->1 19->1 19->1 19->11 19->19 19->20 19->20 19->25 19->28 19->74 20->1 20->19 22->1 22->13 23->1 23->16 24->1 24->19 25->1 25->26 25->39 25->45 25->46 25->59 25->61 26->1 26->1 26->1 27->1 27->1 27->60 27->62 28->1 28->1 28->29 28->31 28->39 28->40 28->47 28->50 28->51 28->58 28->58 28->65 28->66 28->67 28->68 28->78 29->30 29->31 29->31 29->43 29->59 29->81 29->95 30->1 30->29 31->1 31->1 31->1 31->9 31->13 31->29 31->32 31->34 31->41 32->33 32->34 32->34 32->45 32->79 32->91 33->1 33->32 34->1 34->1 34->1 34->10 34->16 34->26 34->32 34->47 34->49 34->50 34->57 34->75 35->1 35->1 35->35 35->36 35->36 35->37 35->51 35->77 36->1 36->35 37->1 37->1 37->63 38->1 39->1 39->1 39->1 40->1 40->29 41->1 41->32 42->1 42->35 43->1 43->1 43->1 43->44 43->53 43->61 43->66 43->84 43->85 43->86 43->97 43->98 44->1 44->1 44->1 44->29 44->30 44->54 44->68 44->89 44->90 44->100 45->1 45->1 45->1 45->25 45->26 45->39 45->46 45->46 45->55 45->56 45->59 45->80 45->92 45->93 45->101 46->1 46->1 46->1 46->25 46->26 46->32 46->33 46->39 46->45 46->55 46->56 46->59 46->94 46->102 47->1 47->1 47->48 47->49 47->63 47->103 48->1 48->47 49->1 49->1 49->26 49->28 49->50 49->50 49->51 49->75 50->1 50->28 50->51 51->35 51->35 51->52 52->1 53->1 53->1 53->1 53->27 53->60 53->62 54->1 54->1 54->1 54->27 54->60 54->62 55->1 55->1 55->1 55->63 56->1 56->1 56->1 56->63 57->1 57->47 58->1 58->28 58->51 59->1 59->1 59->25 59->26 59->39 59->43 59->43 59->45 59->60 59->61 59->62 59->65 59->82 59->83 59->96 60->1 60->1 60->27 60->43 60->43 60->61 60->62 61->1 61->1 61->25 61->26 61->39 61->44 61->44 61->45 61->59 61->60 61->62 61->67 61->87 61->88 61->99 62->1 62->1 62->27 62->44 62->44 62->59 62->60 63->1 63->1 63->1 63->37 63->47 63->48 63->64 64->1 64->49 65->1 65->28 65->47 65->50 65->51 65->66 65->67 65->68 66->1 66->28 66->47 66->50 66->51 67->1 67->28 67->47 67->50 67->51 67->65 67->66 67->68 68->1 68->28 68->47 68->50 68->51
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T , C , D , N , t , c , d , n ; char cmb [ 36 ] [ 4 ] , opp [ 28 ] [ 4 ] ; char list [ 100 ] , e , e1 ; int idx , i ; scanf ( "\x25\x64\x5c\x6e\x0" , & T ) ; for ( t = 1 ; t <= T ; t ++ ) { idx = 0 ; scanf ( "%d " , & C ) ; for ( c = 0 ; c < C ; c ++ ) scanf ( "%s " , cmb [ c ] ) ; scanf ( "%d " , & D ) ; for ( d = 0 ; d < D ; d ++ ) scanf ( "%s " , opp [ d ] ) ; scanf ( "%d " , & N ) ; for ( n = 0 ; n < N ; n ++ ) { scanf ( "%c" , & e ) ; if ( ! idx ) { list [ idx ++ ] = e ; continue ; } for ( i = 0 ; i < C ; i ++ ) { if ( cmb [ i ] [ 0 ] == e && list [ idx - 1 ] == cmb [ i ] [ 1 ] ) { list [ idx - 1 ] = cmb [ i ] [ 2 ] ; break ; } if ( cmb [ i ] [ 1 ] == e && list [ idx - 1 ] == cmb [ i ] [ 0 ] ) { list [ idx - 1 ] = cmb [ i ] [ 2 ] ; break ; } } if ( i < C ) continue ; for ( i = 0 ; i < D ; i ++ ) { if ( opp [ i ] [ 0 ] == e ) { e1 = opp [ i ] [ 1 ] ; break ; } if ( opp [ i ] [ 1 ] == e ) { e1 = opp [ i ] [ 0 ] ; break ; } } if ( i < D ) { for ( i = 0 ; i < idx ; i ++ ) { if ( list [ i ] == e1 ) { idx = 0 ; break ; } } if ( ! idx ) continue ; } list [ idx ++ ] = e ; } printf ( "Case #%d: [" , t ) ; if ( idx ) { for ( i = 0 ; i < idx - 1 ; i ++ ) printf ( "%c, " , list [ i ] ) ; printf ( "%c]\n" , list [ idx - 1 ] ) ; } else printf ( "]\n" ) ; } return 0 ; }
>>>Func
METHOD avl_tree_new
METHOD_RETURN AVLTree
PARAM AVLTreeCompareFunc compare_func
<operator>.assignment new_tree = ( AVLTree * ) malloc ( sizeof ( AVLTree ) )
<operator>.assignment new_tree -> root_node = NULL
<operator>.assignment new_tree -> compare_func = compare_func
<operator>.assignment new_tree -> num_nodes = 0
RETURN return new_tree ; return new_tree ;
<operator>.equals new_tree == NULL
IDENTIFIER new_tree return new_tree ;
<operator>.cast ( AVLTree * ) malloc ( sizeof ( AVLTree ) )
RETURN return NULL ; return NULL ;
IDENTIFIER NULL return NULL ;
<operator>.sizeOf sizeof ( AVLTree )
<operator>.indirectFieldAccess new_tree -> root_node
<operator>.indirectFieldAccess new_tree -> compare_func
<operator>.indirectFieldAccess new_tree -> num_nodes
FIELD_IDENTIFIER root_node root_node
FIELD_IDENTIFIER compare_func compare_func
FIELD_IDENTIFIER num_nodes num_nodes
>>>PDG&20 0->2 0->4 0->5 0->6 0->8 0->9 0->12 2->1 2->5 3->1 3->1 3->8 7->1 8->1 8->1 8->1 8->4 8->4 8->5 8->6 8->7 8->9 8->11 8->12 8->14 8->15 8->16 8->17 8->18 8->19 9->7 10->1 11->1 12->11 13->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) AVLTree * avl_tree_new ( AVLTreeCompareFunc compare_func ) { AVLTree * new_tree ; new_tree = ( AVLTree * ) malloc ( sizeof ( AVLTree ) ) ; if ( new_tree == NULL ) { return NULL ; } new_tree -> root_node = NULL ; new_tree -> compare_func = compare_func ; new_tree -> num_nodes = 0 ; return new_tree ; }
>>>Func
METHOD does_exist
METHOD_RETURN int
PARAM darray * * a
PARAM void * e
RETURN return 0 ; return 0 ;
<operator>.lessThan i < ( * a ) -> d_len
<operator>.preIncrement ++ i
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.logicalNot ! memcmp ( ( * a ) -> data + i * ( ( * a ) -> d_size )   e   ( * a ) -> d_size )
RETURN return 1 ; return 1 ;
memcmp memcmp ( ( * a ) -> data + i * ( ( * a ) -> d_size )   e   ( * a ) -> d_size )
LITERAL 1 return 1 ;
<operator>.addition ( * a ) -> data + i * ( ( * a ) -> d_size )
<operator>.multiplication i * ( ( * a ) -> d_size )
<operator>.indirectFieldAccess ( * a ) -> d_len
<operator>.indirection * a
FIELD_IDENTIFIER d_len d_len
<operator>.indirectFieldAccess ( * a ) -> d_size
<operator>.indirectFieldAccess ( * a ) -> data
<operator>.indirection * a
FIELD_IDENTIFIER d_size d_size
<operator>.indirection * a
FIELD_IDENTIFIER data data
<operator>.indirectFieldAccess ( * a ) -> d_size
<operator>.indirection * a
FIELD_IDENTIFIER d_size d_size
>>>PDG&27 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->14 2->1 3->11 4->1 5->1 5->1 5->4 5->9 5->11 5->13 5->14 5->14 5->18 5->19 5->20 5->21 5->22 5->23 5->24 5->25 5->26 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->5 9->6 9->10 9->15 9->16 9->17 10->1 11->1 11->1 11->1 11->9 11->9 11->9 11->14 12->10 13->1 13->1 14->1 14->6 14->11 14->11 14->13 14->13
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) inline int does_exist ( darray * * a , void * e ) { int i ; for ( i = 0 ; i < ( * a ) -> d_len ; ++ i ) { if ( ! memcmp ( ( * a ) -> data + i * ( ( * a ) -> d_size ) , e , ( * a ) -> d_size ) ) return 1 ; } return 0 ; }
>>>Func
METHOD max
METHOD_RETURN int
PARAM int a
PARAM int b
RETURN return a >= b ? a : b ; return a >= b ? a : b ;
<operator>.conditional a >= b ? a : b
<operator>.greaterEqualsThan a >= b
>>>PDG&7 0->2 0->3 0->5 0->6 2->6 3->6 4->1 5->1 5->1 5->1 5->1 5->4 6->5 6->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int max ( int a , int b ) { return a >= b ? a : b ; }
>>>Func
METHOD calculate_oowp
METHOD_RETURN long double
PARAM int i
PARAM int n
PARAM int * * matrix
PARAM long double * owp
<operator>.assignment played = 0
<operator>.assignment oowp = 0.0
RETURN return ( oowp ) / ( ( long double ) played ) ; return ( oowp ) / ( ( long double ) played ) ;
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.division ( oowp ) / ( ( long double ) played )
<operator>.assignment j = 0
<operator>.notEquals matrix [ i ] [ j ] != - 1
<operator>.cast ( long double ) played
<operator>.postIncrement played ++
<operator>.assignmentPlus oowp += owp [ j ]
<operator>.minus - 1
<operator>.indirectIndexAccess matrix [ i ] [ j ]
<operator>.indirectIndexAccess matrix [ i ]
<operator>.indirectIndexAccess owp [ j ]
>>>PDG&21 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 2->1 3->9 4->1 5->1 5->16 6->1 6->11 6->14 6->15 7->1 7->11 7->16 8->1 9->1 9->1 9->1 9->9 9->10 9->10 9->13 9->17 9->18 9->19 10->1 10->9 11->1 11->1 11->1 11->8 12->1 12->9 13->1 13->1 13->1 13->15 13->16 13->20 14->1 15->1 15->11 15->14 16->1 16->1 16->11 17->13
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) long double calculate_oowp ( int i , int n , int * * matrix , long double * owp ) { int j ; int played = 0 ; long double oowp = 0.0 ; for ( j = 0 ; j < n ; j ++ ) { if ( matrix [ i ] [ j ] != - 1 ) { played ++ ; oowp += owp [ j ] ; } } return ( oowp ) / ( ( long double ) played ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char const * argv [ ]
<operator>.assignment head = { . start = start_num   . end = end_num   . next = NULL }
printf printf ( "Level %d\t" , levels )
print print ( & head )
free_memory free_memory ( head . next )
RETURN return 0 ; return 0 ;
<operator>.lessThan argc < 2
<operator>.logicalOr start_num < 0 || end_num < 0 || levels < 0
<operator>.lessThan i < levels
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
printf printf ( "\x45\x6e\x74\x65\x72\x20\x33\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3a\x20\x73\x74\x61\x72\x74\x5f\x6e\x75\x6d\x20\x5c\x74\x20\x65\x6e\x64\x5f\x6e\x75\x6d\x20\x5c\x74\x20\x6c\x65\x76\x65\x6c\x73\x5c\x6e\x0" )
scanf scanf ( "%d %d %d" , & start_num , & end_num , & levels )
fprintf fprintf ( stderr , "All numbers must be positive\n" )
RETURN return - 1 ; return - 1 ;
<operator>.arrayInitializer { . start = start_num   . end = end_num   . next = NULL }
<operator>.assignment i = 0
printf printf ( "Level %d\t" , i )
print print ( & head )
propagate propagate ( & head )
printf printf ( "\n" )
<operator>.assignment start_num = atoi ( argv [ 1 ] )
<operator>.assignment end_num = atoi ( argv [ 2 ] )
<operator>.assignment levels = atoi ( argv [ 3 ] )
<operator>.logicalOr start_num < 0 || end_num < 0
<operator>.lessThan levels < 0
<operator>.minus - 1
<operator>.assignment . start = start_num
<operator>.assignment . end = end_num
<operator>.assignment . next = NULL
<operator>.lessThan start_num < 0
<operator>.lessThan end_num < 0
atoi atoi ( argv [ 1 ] )
atoi atoi ( argv [ 2 ] )
atoi atoi ( argv [ 3 ] )
<operator>.addressOf & head
<operator>.fieldAccess head . next
FIELD_IDENTIFIER next next
<operator>.addressOf & start_num
<operator>.addressOf & end_num
<operator>.addressOf & levels
<operator>.addressOf & head
<operator>.addressOf & head
<operator>.indirectIndexAccess argv [ 1 ]
<operator>.indirectIndexAccess argv [ 2 ]
<operator>.indirectIndexAccess argv [ 3 ]
>>>PDG&49 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->28 0->29 0->30 0->31 0->32 0->33 0->34 2->9 3->1 3->35 3->36 3->37 4->6 4->7 4->21 4->22 8->1 9->1 9->1 9->14 9->15 9->24 9->25 9->26 9->35 9->36 9->37 9->41 9->42 9->43 9->46 9->47 9->48 10->1 10->1 10->1 10->4 10->5 10->6 10->7 10->8 10->11 10->16 10->17 10->18 10->19 10->29 10->30 10->31 10->32 10->38 10->39 10->40 11->5 11->11 11->12 11->20 11->20 11->21 11->22 11->23 11->44 11->45 12->11 13->8 14->1 15->1 15->1 15->1 15->30 15->33 16->1 16->1 17->1 18->4 18->4 19->11 20->12 21->6 21->7 21->22 22->6 22->7 22->21 24->1 24->1 24->33 25->1 25->1 25->1 25->31 25->34 26->1 26->1 26->1 26->11 26->28 27->1 27->1 27->10 27->10 27->28 28->1 28->10 28->10 28->11 29->1 29->17 30->1 30->18 31->1 31->18 32->1 32->18 33->1 33->27 33->27 33->30 33->34 34->1 34->27 34->27 34->31 35->1 35->24 36->1 36->25 37->1 37->26
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char const * argv [ ] ) { int start_num , end_num , levels ; if ( argc < 2 ) { printf ( "\x45\x6e\x74\x65\x72\x20\x33\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3a\x20\x73\x74\x61\x72\x74\x5f\x6e\x75\x6d\x20\x5c\x74\x20\x65\x6e\x64\x5f\x6e\x75\x6d\x20\x5c\x74\x20\x6c\x65\x76\x65\x6c\x73\x5c\x6e\x0" ) ; scanf ( "%d %d %d" , & start_num , & end_num , & levels ) ; } else { start_num = atoi ( argv [ 1 ] ) ; end_num = atoi ( argv [ 2 ] ) ; levels = atoi ( argv [ 3 ] ) ; } if ( start_num < 0 || end_num < 0 || levels < 0 ) { fprintf ( stderr , "All numbers must be positive\n" ) ; return - 1 ; } CantorSet head = { . start = start_num , . end = end_num , . next = NULL } ; for ( int i = 0 ; i < levels ; i ++ ) { printf ( "Level %d\t" , i ) ; print ( & head ) ; propagate ( & head ) ; printf ( "\n" ) ; } printf ( "Level %d\t" , levels ) ; print ( & head ) ; free_memory ( head . next ) ; return 0 ; }
>>>Func
METHOD clear_element_list
METHOD_RETURN void
PARAM char output [ ]
<operator>.notEquals * output != '\0'
<operator>.preIncrement ++ output
<operator>.assignment * output = FILLER
<operator>.indirection * output
<operator>.indirection * output
>>>PDG&8 0->2 0->3 0->4 0->5 2->1 2->4 3->1 3->1 3->3 3->4 3->5 3->6 3->7 5->1 5->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void clear_element_list ( char output [ ] ) { for ( ; * output != '\0' ; ++ output ) { * output = FILLER ; } }
>>>Func
METHOD string_nocase_hash
METHOD_RETURN unsigned int
PARAM void * string
<operator>.assignment result = 5381
<operator>.assignment p = ( unsigned char * ) string
RETURN return result ; return result ;
<operator>.notEquals * p != '\0'
IDENTIFIER result return result ;
<operator>.cast ( unsigned char * ) string
<operator>.assignment result = ( result << 5 ) + result + ( unsigned int ) tolower ( * p )
<operator>.preIncrement ++ p
<operator>.addition ( result << 5 ) + result + ( unsigned int ) tolower ( * p )
<operator>.addition ( result << 5 ) + result
<operator>.cast ( unsigned int ) tolower ( * p )
<operator>.shiftLeft result << 5
tolower tolower ( * p )
<operator>.indirection * p
UNKNOWN unsigned int unsigned int
<operator>.indirection * p
>>>PDG&19 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 2->4 2->8 3->1 3->1 3->7 3->14 4->1 4->1 4->1 4->10 5->1 6->1 6->1 6->6 6->9 6->10 6->11 6->12 6->13 6->14 6->15 6->15 6->16 6->17 6->18 7->5 8->1 9->1 9->1 9->1 9->7 9->14 10->1 10->1 11->1 11->1 12->1 13->1 14->9 14->9 14->11 14->11 14->12 14->12 15->6 15->9 15->10 15->11 15->13
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) unsigned int string_nocase_hash ( void * string ) { unsigned int result = 5381 ; unsigned char * p ; p = ( unsigned char * ) string ; while ( * p != '\0' ) { result = ( result << 5 ) + result + ( unsigned int ) tolower ( * p ) ; ++ p ; } return result ; }
>>>Func
METHOD add_excluded_fs_type
METHOD_RETURN void
PARAM char const * fstype
<operator>.assignment fsp = xmalloc ( sizeof * fsp )
<operator>.assignment fsp -> fs_name = ( char * ) fstype
<operator>.assignment fsp -> fs_next = fs_exclude_list
<operator>.assignment fs_exclude_list = fsp
<operator>.cast ( char * ) fstype
<operator>.sizeOf sizeof * fsp
>>>PDG&9 0->2 0->4 0->5 0->6 0->7 2->4 2->7 3->1 3->1 3->6 4->1 4->1 4->1 5->1 5->1 6->1 6->1 6->1 7->1 8->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static void add_excluded_fs_type ( char const * fstype ) { struct fs_type_list * fsp ; fsp = xmalloc ( sizeof * fsp ) ; fsp -> fs_name = ( char * ) fstype ; fsp -> fs_next = fs_exclude_list ; fs_exclude_list = fsp ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan z <= t
<operator>.postIncrement z ++
LITERAL 0 return 0 ;
<operator>.assignment z = 1
scanf scanf ( "%d" , & n )
printf printf ( "Case #%d:\n" , z )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
scanf scanf ( "%s" , s [ i ] )
<operator>.assignment win [ i ] = los [ i ] = 0
<operator>.assignment i = 0
<operator>.assignment wp [ i ] = win [ i ] * 1.0 / ( win [ i ] + los [ i ] )
<operator>.assignment i = 0
<operator>.assignment sum = 0
<operator>.assignment owp [ i ] = sum / ( win [ i ] + los [ i ] )
<operator>.assignment i = 0
<operator>.assignment sum = 0
<operator>.assignment oowp [ i ] = sum / ( win [ i ] + los [ i ] )
<operator>.assignment i = 0
printf printf ( "%.16lf\n" , wp [ i ] / 4 + owp [ i ] / 2 + oowp [ i ] / 4 )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment los [ i ] = 0
<operator>.assignment j = i + 1
<operator>.division win [ i ] * 1.0 / ( win [ i ] + los [ i ] )
<operator>.assignment j = 0
<operator>.division sum / ( win [ i ] + los [ i ] )
<operator>.assignment j = 0
<operator>.division sum / ( win [ i ] + los [ i ] )
<operator>.addition wp [ i ] / 4 + owp [ i ] / 2 + oowp [ i ] / 4
<operator>.equals s [ i ] [ j ] == '1'
<operator>.multiplication win [ i ] * 1.0
<operator>.addition win [ i ] + los [ i ]
<operator>.equals s [ i ] [ j ] == '1'
<operator>.addition win [ i ] + los [ i ]
<operator>.notEquals s [ i ] [ j ] != '.'
<operator>.addition win [ i ] + los [ i ]
<operator>.addition wp [ i ] / 4 + owp [ i ] / 2
<operator>.division oowp [ i ] / 4
<operator>.addition i + 1
<operator>.postIncrement win [ i ] ++
<operator>.postIncrement los [ j ] ++
<operator>.assignmentPlus sum += win [ j ] * 1.0 / ( win [ j ] + los [ j ] - 1 )
<operator>.assignmentPlus sum += owp [ j ]
<operator>.division wp [ i ] / 4
<operator>.division owp [ i ] / 2
<operator>.equals s [ i ] [ j ] == '0'
<operator>.division win [ j ] * 1.0 / ( win [ j ] + los [ j ] - 1 )
<operator>.equals s [ i ] [ j ] == '0'
<operator>.postIncrement los [ i ] ++
<operator>.postIncrement win [ j ] ++
<operator>.multiplication win [ j ] * 1.0
<operator>.subtraction win [ j ] + los [ j ] - 1
<operator>.assignmentPlus sum += ( win [ j ] - 1 ) * 1.0 / ( win [ j ] + los [ j ] - 1 )
<operator>.addition win [ j ] + los [ j ]
<operator>.division ( win [ j ] - 1 ) * 1.0 / ( win [ j ] + los [ j ] - 1 )
<operator>.multiplication ( win [ j ] - 1 ) * 1.0
<operator>.subtraction win [ j ] + los [ j ] - 1
<operator>.subtraction win [ j ] - 1
<operator>.addition win [ j ] + los [ j ]
<operator>.addressOf & n
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess win [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess los [ i ]
<operator>.indirectIndexAccess win [ i ]
<operator>.indirectIndexAccess win [ i ]
<operator>.indirectIndexAccess los [ i ]
<operator>.indirectIndexAccess win [ i ]
<operator>.indirectIndexAccess los [ i ]
<operator>.indirectIndexAccess win [ i ]
<operator>.indirectIndexAccess los [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess s [ i ] [ j ]
<operator>.indirectIndexAccess s [ i ] [ j ]
<operator>.indirectIndexAccess s [ i ] [ j ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess win [ i ]
<operator>.indirectIndexAccess los [ j ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess s [ i ] [ j ]
<operator>.indirectIndexAccess win [ j ]
<operator>.indirectIndexAccess s [ i ] [ j ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess los [ i ]
<operator>.indirectIndexAccess win [ j ]
<operator>.indirectIndexAccess win [ j ]
<operator>.indirectIndexAccess los [ j ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess win [ j ]
<operator>.indirectIndexAccess win [ j ]
<operator>.indirectIndexAccess los [ j ]
>>>PDG&115 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->25 0->26 0->28 0->29 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->42 0->43 0->44 0->45 0->47 0->48 0->50 0->52 0->55 0->56 0->59 0->60 0->61 0->62 0->63 0->65 0->68 0->69 0->70 0->73 0->74 0->75 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->9 4->10 4->12 4->14 4->16 4->18 4->20 4->23 4->25 4->28 4->31 4->77 5->1 5->4 6->3 7->1 7->4 8->1 8->10 8->12 8->14 8->16 8->18 8->33 8->35 8->37 9->1 9->5 10->10 10->11 10->11 10->12 10->21 10->22 10->39 10->78 10->79 10->83 11->1 11->10 12->12 12->13 12->13 12->14 12->24 12->33 12->33 12->40 12->40 12->41 12->48 12->49 12->56 12->56 12->80 12->84 12->85 12->86 13->1 13->12 14->14 14->15 14->15 14->16 14->26 14->27 14->35 14->35 14->42 14->43 14->51 14->81 14->87 14->88 15->1 15->14 16->16 16->17 16->17 16->18 16->29 16->30 16->37 16->37 16->44 16->45 16->53 16->82 16->89 16->90 17->1 17->16 18->1 18->1 18->1 18->8 18->10 18->18 18->19 18->19 18->32 18->46 18->54 18->55 18->61 18->62 18->91 18->95 18->96 19->1 19->18 20->10 21->1 22->1 22->1 22->1 22->43 22->45 22->48 22->51 22->53 22->57 23->12 24->1 24->1 24->1 24->61 25->14 26->1 26->43 26->59 26->70 27->1 27->1 27->1 27->62 28->16 29->1 29->45 29->60 30->1 30->1 30->1 30->55 31->1 31->18 32->1 32->1 33->1 33->1 33->12 33->33 33->34 33->34 33->47 33->92 33->97 34->1 34->33 35->1 35->1 35->14 35->35 35->36 35->36 35->50 35->93 35->100 36->1 36->35 37->1 37->1 37->16 37->37 37->38 37->38 37->52 37->94 37->101 38->1 38->37 39->1 39->22 39->41 39->43 39->45 39->49 39->51 39->53 39->66 40->1 40->1 40->33 41->1 41->1 41->24 41->24 42->1 42->35 43->1 43->1 43->27 43->27 44->1 44->37 45->1 45->1 45->30 45->30 46->1 46->1 47->1 47->1 47->21 47->50 47->52 47->57 47->58 47->63 47->63 47->98 47->99 47->103 47->106 48->41 48->41 48->43 48->45 48->49 48->51 48->53 48->57 49->1 49->1 50->1 50->1 50->21 50->47 50->52 50->59 50->64 50->65 50->65 50->68 50->69 50->71 50->104 50->105 50->109 50->110 50->111 51->1 51->1 52->1 52->1 52->21 52->47 52->50 52->60 52->102 53->1 53->1 54->1 54->1 55->1 55->32 55->32 55->46 55->46 57->1 57->48 58->1 58->1 58->69 58->71 58->74 58->76 59->1 59->1 59->43 59->70 60->1 60->1 60->45 61->1 61->32 61->32 61->46 61->46 61->54 61->54 62->1 62->32 62->32 62->46 62->46 62->54 62->54 63->1 63->1 63->21 63->47 63->50 63->52 63->66 63->67 63->107 63->108 64->1 64->1 64->59 64->59 65->1 65->1 65->21 65->47 65->50 65->52 65->70 65->72 65->73 65->74 65->75 65->76 65->112 65->113 65->114 66->1 66->41 66->49 67->1 67->1 67->68 67->75 68->64 68->64 68->67 68->69 68->71 68->75 69->1 69->64 69->64 70->1 70->1 70->43 70->59 71->1 71->1 72->1 72->1 72->70 72->70 73->1 73->72 73->72 74->1 74->72 74->72 75->67 75->68 75->73 75->73 75->74 75->76 76->1 76->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int t , z , win [ 100 ] , los [ 100 ] , i , j , n ; double wp [ 100 ] , owp [ 100 ] , oowp [ 100 ] ; char s [ 101 ] [ 101 ] ; scanf ( "\x25\x64\x0" , & t ) ; for ( z = 1 ; z <= t ; z ++ ) { scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%s" , s [ i ] ) ; win [ i ] = los [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( s [ i ] [ j ] == '1' ) { win [ i ] ++ ; los [ j ] ++ ; } else if ( s [ i ] [ j ] == '0' ) { los [ i ] ++ ; win [ j ] ++ ; } } wp [ i ] = win [ i ] * 1.0 / ( win [ i ] + los [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( s [ i ] [ j ] == '1' ) { sum += win [ j ] * 1.0 / ( win [ j ] + los [ j ] - 1 ) ; } else if ( s [ i ] [ j ] == '0' ) { sum += ( win [ j ] - 1 ) * 1.0 / ( win [ j ] + los [ j ] - 1 ) ; } } owp [ i ] = sum / ( win [ i ] + los [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( s [ i ] [ j ] != '.' ) { sum += owp [ j ] ; } } oowp [ i ] = sum / ( win [ i ] + los [ i ] ) ; } printf ( "Case #%d:\n" , z ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( "%.16lf\n" , wp [ i ] / 4 + owp [ i ] / 2 + oowp [ i ] / 4 ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & N )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan caseN <= N
<operator>.postIncrement caseN ++
LITERAL 0 return 0 ;
<operator>.assignment caseN = 1
scanf scanf ( "%d" , & ncomb )
scanf scanf ( "%d" , & ndest )
scanf scanf ( "%d" , & len )
scanf scanf ( "%s" , s )
<operator>.assignment top = 0
printf printf ( "Case #%d: [" , caseN )
printf printf ( "]\n" )
<operator>.lessThan i < ncomb
<operator>.postIncrement i ++
scanf scanf ( "%s" , comb [ i ] )
<operator>.lessThan i < ndest
<operator>.postIncrement i ++
scanf scanf ( "%s" , dest [ i ] )
<operator>.lessThan i < len
<operator>.postIncrement i ++
<operator>.lessThan i < top
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment st [ top ++ ] = s [ i ]
<operator>.assignment got = 1
<operator>.assignment i = 0
printf printf ( "%c" , st [ i ] )
IDENTIFIER got while (got)
<operator>.notEquals i != 0
<operator>.assignment got = 0
memset memset ( seen   0   sizeof ( seen ) )
printf printf ( ", " )
<operator>.postIncrement top ++
<operator>.lessEqualsThan top <= 1
<operator>.lessThan j < ncomb
<operator>.postIncrement j ++
IDENTIFIER got if (got)
<operator>.lessThan j < top
<operator>.postIncrement j ++
<operator>.assignment seen [ st [ j ] - 'A' ] = 1
<operator>.lessThan j < ndest
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.logicalOr ( st [ top - 1 ] == comb [ j ] [ 0 ] && st [ top - 2 ] == comb [ j ] [ 1 ] ) || ( st [ top - 1 ] == comb [ j ] [ 1 ] && st [ top - 2 ] == comb [ j ] [ 0 ] )
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.logicalAnd seen [ dest [ j ] [ 0 ] - 'A' ] && seen [ dest [ j ] [ 1 ] - 'A' ]
<operator>.postDecrement top --
<operator>.postDecrement top --
<operator>.assignment st [ top ++ ] = comb [ j ] [ 2 ]
<operator>.assignment got = 1
<operator>.assignment top = 0
<operator>.assignment got = 1
<operator>.logicalAnd st [ top - 1 ] == comb [ j ] [ 0 ] && st [ top - 2 ] == comb [ j ] [ 1 ]
<operator>.logicalAnd st [ top - 1 ] == comb [ j ] [ 1 ] && st [ top - 2 ] == comb [ j ] [ 0 ]
<operator>.subtraction st [ j ] - 'A'
<operator>.equals st [ top - 1 ] == comb [ j ] [ 0 ]
<operator>.equals st [ top - 2 ] == comb [ j ] [ 1 ]
<operator>.equals st [ top - 1 ] == comb [ j ] [ 1 ]
<operator>.equals st [ top - 2 ] == comb [ j ] [ 0 ]
<operator>.subtraction dest [ j ] [ 0 ] - 'A'
<operator>.subtraction dest [ j ] [ 1 ] - 'A'
<operator>.postIncrement top ++
<operator>.subtraction top - 1
<operator>.subtraction top - 2
<operator>.subtraction top - 1
<operator>.subtraction top - 2
<operator>.addressOf & ncomb
<operator>.addressOf & ndest
<operator>.addressOf & len
<operator>.indirectIndexAccess comb [ i ]
<operator>.indirectIndexAccess dest [ i ]
<operator>.indirectIndexAccess st [ top ++ ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess st [ i ]
<operator>.sizeOf sizeof ( seen )
<operator>.indirectIndexAccess seen [ st [ j ] - 'A' ]
<operator>.indirectIndexAccess seen [ dest [ j ] [ 0 ] - 'A' ]
<operator>.indirectIndexAccess seen [ dest [ j ] [ 1 ] - 'A' ]
<operator>.indirectIndexAccess st [ top ++ ]
<operator>.indirectIndexAccess comb [ j ] [ 2 ]
<operator>.indirectIndexAccess st [ j ]
<operator>.indirectIndexAccess st [ top - 1 ]
<operator>.indirectIndexAccess comb [ j ] [ 0 ]
<operator>.indirectIndexAccess st [ top - 2 ]
<operator>.indirectIndexAccess comb [ j ] [ 1 ]
<operator>.indirectIndexAccess st [ top - 1 ]
<operator>.indirectIndexAccess comb [ j ] [ 1 ]
<operator>.indirectIndexAccess st [ top - 2 ]
<operator>.indirectIndexAccess comb [ j ] [ 0 ]
<operator>.indirectIndexAccess comb [ j ]
<operator>.indirectIndexAccess dest [ j ] [ 0 ]
<operator>.indirectIndexAccess dest [ j ] [ 1 ]
<operator>.indirectIndexAccess comb [ j ]
<operator>.indirectIndexAccess comb [ j ]
<operator>.indirectIndexAccess comb [ j ]
<operator>.indirectIndexAccess comb [ j ]
<operator>.indirectIndexAccess dest [ j ]
<operator>.indirectIndexAccess dest [ j ]
>>>PDG&104 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->49 0->50 0->52 0->53 0->55 0->56 0->57 0->60 0->65 0->66 0->67 0->68 0->69 0->70 0->71 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->13 4->14 4->15 4->18 4->21 4->23 4->25 4->26 4->27 4->30 4->72 4->73 4->74 5->1 5->4 6->3 7->1 7->4 8->1 8->15 8->39 9->1 9->18 9->45 10->1 10->21 11->1 11->28 12->1 12->23 12->37 13->1 13->5 14->1 15->1 15->1 15->8 15->15 15->16 15->16 15->17 15->39 15->75 16->1 16->15 17->1 18->1 18->1 18->9 18->18 18->19 18->19 18->20 18->45 18->76 19->1 19->18 20->1 21->1 21->1 21->10 21->21 21->22 21->22 21->28 21->29 21->34 21->37 21->38 21->77 21->78 22->1 22->21 23->1 23->1 23->1 23->23 23->24 23->31 23->33 23->33 23->79 24->1 24->23 25->15 26->18 27->21 28->1 28->1 28->1 29->1 29->1 30->1 30->23 31->1 31->1 33->1 33->24 33->36 34->1 34->1 35->1 35->1 35->51 36->1 37->23 37->38 38->1 38->23 38->34 38->35 38->37 38->38 38->39 38->42 38->42 38->45 38->47 38->49 38->50 38->68 38->80 39->1 39->1 39->1 39->8 39->15 39->40 39->48 39->58 39->61 39->68 39->87 39->88 39->98 40->1 40->39 42->1 42->23 42->37 42->38 42->42 42->43 42->43 42->44 42->60 42->81 42->86 43->1 43->42 44->1 44->1 44->35 45->1 45->1 45->1 45->9 45->18 45->46 45->51 45->65 45->82 45->96 45->102 46->1 46->45 47->1 47->39 48->1 48->1 48->1 48->39 48->40 48->52 48->53 48->54 48->55 48->67 48->84 48->85 48->95 49->42 50->1 50->45 51->1 51->1 51->1 51->35 51->35 51->45 51->46 51->56 51->57 52->53 53->1 53->67 54->1 54->1 54->1 55->1 55->1 56->1 56->23 56->37 56->38 57->1 57->1 58->1 58->1 58->48 58->48 58->59 58->63 58->70 58->91 58->92 58->100 59->1 59->1 59->48 59->48 60->1 61->1 61->1 61->58 61->58 61->62 61->63 61->64 61->69 61->89 61->90 61->99 62->1 62->1 62->58 62->58 62->63 62->64 63->1 63->1 63->59 63->59 63->61 63->62 63->64 63->71 63->93 63->94 63->101 64->1 64->1 64->59 64->59 64->61 64->62 65->1 66->1 67->23 67->37 67->38 67->42 68->23 68->37 68->38 68->42 68->52 68->69 68->70 69->23 69->37 69->38 69->42 69->52 69->68 69->70 70->23 70->37 70->38 70->42 70->52 70->68 70->71 71->23 71->37 71->38 71->42 71->52 71->68 82->66 82->83 82->97 82->103
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int caseN ; int N ; int i , j ; int len ; char s [ 1000 ] ; char comb [ 100 ] [ 4 ] ; char dest [ 100 ] [ 3 ] ; char st [ 1000 ] ; int ncomb , ndest ; int top , got ; int seen [ 26 ] ; scanf ( "\x25\x64\x0" , & N ) ; for ( caseN = 1 ; caseN <= N ; caseN ++ ) { scanf ( "%d" , & ncomb ) ; for ( i = 0 ; i < ncomb ; i ++ ) scanf ( "%s" , comb [ i ] ) ; scanf ( "%d" , & ndest ) ; for ( i = 0 ; i < ndest ; i ++ ) scanf ( "%s" , dest [ i ] ) ; scanf ( "%d" , & len ) ; scanf ( "%s" , s ) ; top = 0 ; for ( i = 0 ; i < len ; i ++ ) { st [ top ++ ] = s [ i ] ; got = 1 ; while ( got ) { got = 0 ; if ( top <= 1 ) break ; for ( j = 0 ; j < ncomb ; j ++ ) if ( ( st [ top - 1 ] == comb [ j ] [ 0 ] && st [ top - 2 ] == comb [ j ] [ 1 ] ) || ( st [ top - 1 ] == comb [ j ] [ 1 ] && st [ top - 2 ] == comb [ j ] [ 0 ] ) ) { top -- ; top -- ; st [ top ++ ] = comb [ j ] [ 2 ] ; got = 1 ; break ; } if ( got ) continue ; memset ( seen , 0 , sizeof ( seen ) ) ; for ( j = 0 ; j < top ; j ++ ) seen [ st [ j ] - 'A' ] = 1 ; for ( j = 0 ; j < ndest ; j ++ ) if ( seen [ dest [ j ] [ 0 ] - 'A' ] && seen [ dest [ j ] [ 1 ] - 'A' ] ) { top = 0 ; got = 1 ; break ; } } } printf ( "Case #%d: [" , caseN ) ; for ( i = 0 ; i < top ; i ++ ) { if ( i != 0 ) printf ( ", " ) ; printf ( "%c" , st [ i ] ) ; } printf ( "]\n" ) ; } return 0 ; }
>>>Func
METHOD calculate_owp
METHOD_RETURN long double
PARAM int i
PARAM int n
PARAM int * * matrix
<operator>.assignment played = 0
<operator>.assignment owp = 0.0
RETURN return ( owp ) / ( ( long double ) played ) ; return ( owp ) / ( ( long double ) played ) ;
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.division ( owp ) / ( ( long double ) played )
<operator>.assignment j = 0
<operator>.notEquals matrix [ i ] [ j ] != - 1
<operator>.cast ( long double ) played
<operator>.postIncrement played ++
<operator>.assignmentPlus owp += calculate_owp_aux ( j , i , n , matrix )
<operator>.minus - 1
calculate_owp_aux calculate_owp_aux ( j , i , n , matrix )
<operator>.indirectIndexAccess matrix [ i ] [ j ]
<operator>.indirectIndexAccess matrix [ i ]
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 2->1 2->17 3->8 4->1 4->17 5->1 5->10 5->13 5->14 6->1 6->10 6->15 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->12 8->16 8->17 8->17 8->18 8->19 9->1 9->8 10->1 10->1 10->1 10->7 11->1 11->8 12->1 12->1 12->1 12->14 12->15 12->17 13->1 14->1 14->10 14->13 15->1 15->1 15->10 16->12 17->1 17->1 17->8 17->9 17->15 17->15 17->15 17->15
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) long double calculate_owp ( int i , int n , int * * matrix ) { int j ; int played = 0 ; long double owp = 0.0 ; for ( j = 0 ; j < n ; j ++ ) { if ( matrix [ i ] [ j ] != - 1 ) { played ++ ; owp += calculate_owp_aux ( j , i , n , matrix ) ; } } return ( owp ) / ( ( long double ) played ) ; }
>>>Func
METHOD get
METHOD_RETURN void*
PARAM dynamic_array_t * da
PARAM const unsigned index
RETURN return da -> items [ index ] ; return da -> items [ index ] ;
<operator>.logicalNot ! contains ( da -> size , index )
RETURN return INDEX_OUT_OF_BOUNDS ; return INDEX_OUT_OF_BOUNDS ;
contains contains ( da -> size , index )
IDENTIFIER INDEX_OUT_OF_BOUNDS return INDEX_OUT_OF_BOUNDS ;
<operator>.indirectIndexAccess da -> items [ index ]
<operator>.indirectFieldAccess da -> items
FIELD_IDENTIFIER items items
>>>PDG&12 0->2 0->3 0->4 0->6 0->7 0->8 2->1 3->7 4->1 5->1 5->1 5->4 5->6 5->9 5->10 5->11 6->1 7->1 7->1 7->5 7->5 8->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void * get ( dynamic_array_t * da , const unsigned index ) { if ( ! contains ( da -> size , index ) ) return INDEX_OUT_OF_BOUNDS ; return da -> items [ index ] ; }
>>>Func
METHOD list_iter_has_more
METHOD_RETURN int
PARAM ListIterator * iter
<operator>.logicalOr iter -> current == NULL || iter -> current != * iter -> prev_next
RETURN return * iter -> prev_next != NULL ; return * iter -> prev_next != NULL ;
<operator>.equals iter -> current == NULL
<operator>.notEquals iter -> current != * iter -> prev_next
<operator>.notEquals * iter -> prev_next != NULL
RETURN return iter -> current -> next != NULL ; return iter -> current -> next != NULL ;
<operator>.notEquals iter -> current -> next != NULL
<operator>.indirectFieldAccess iter -> current
<operator>.indirection * iter -> prev_next
FIELD_IDENTIFIER current current
<operator>.indirectFieldAccess iter -> prev_next
<operator>.indirection * iter -> prev_next
FIELD_IDENTIFIER prev_next prev_next
<operator>.indirectFieldAccess iter -> prev_next
<operator>.indirectFieldAccess iter -> current -> next
FIELD_IDENTIFIER prev_next prev_next
<operator>.indirectFieldAccess iter -> current
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER current current
>>>PDG&22 0->2 0->5 0->7 0->9 2->1 3->1 3->1 3->1 3->4 3->7 3->8 3->9 3->14 3->16 3->17 3->18 3->19 3->20 3->21 4->1 5->1 5->3 5->3 5->6 5->6 5->7 5->9 5->10 5->11 5->12 5->13 5->15 6->1 6->3 6->3 6->7 7->1 7->1 7->1 7->4 8->1 9->8
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int list_iter_has_more ( ListIterator * iter ) { if ( iter -> current == NULL || iter -> current != * iter -> prev_next ) { return * iter -> prev_next != NULL ; } else { return iter -> current -> next != NULL ; } }
>>>Func
METHOD findMaxCArray
METHOD_RETURN int
PARAM CArray * array
<operator>.assignment max = array -> array [ 0 ]
RETURN return max ; return max ;
<operator>.lessThan i < array -> size
<operator>.postIncrement i ++
IDENTIFIER max return max ;
<operator>.assignment i = 1
<operator>.greaterThan array -> array [ i ] > max
<operator>.assignment max = array -> array [ i ]
<operator>.indirectFieldAccess array -> size
FIELD_IDENTIFIER size size
<operator>.indirectIndexAccess array -> array [ i ]
<operator>.indirectFieldAccess array -> array
<operator>.indirectIndexAccess array -> array [ i ]
FIELD_IDENTIFIER array array
<operator>.indirectFieldAccess array -> array
FIELD_IDENTIFIER array array
>>>PDG&19 0->2 0->5 0->6 0->7 0->8 0->9 2->1 3->1 3->1 3->1 3->7 3->9 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->11 5->12 5->13 5->14 5->16 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->1 9->7 9->10 9->10 9->15 9->17 9->18 10->1 10->1 10->1 10->7 10->9
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int findMaxCArray ( CArray * array ) { int i ; int max = array -> array [ 0 ] ; for ( i = 1 ; i < array -> size ; i ++ ) { if ( array -> array [ i ] > max ) { max = array -> array [ i ] ; } } return max ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
<operator>.assignment mask [ 26 ] = { 8   0   0   2   32   1   0   0   0   0   0   0   0   0   0   0   128   16   4   0   0   0   64   0   0   0 }
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return ( 0 ) ; return ( 0 ) ;
<operator>.lessEqualsThan iT <= T
<operator>.preIncrement ++ iT
LITERAL 0 return ( 0 ) ;
<operator>.arrayInitializer { 8   0   0   2   32   1   0   0   0   0   0   0   0   0   0   0   128   16   4   0   0   0   64   0   0   0 }
<operator>.assignment iT = 1
printf printf ( "DEBUG: T: %d, iT:%d\n" , T , iT )
memset memset ( combine_rules , NO_CHAR , 676 )
scanf scanf ( "%d" , & C )
memset memset ( opposed_rules , 0 , 26 )
scanf scanf ( "%d" , & D )
<operator>.assignment cur_bad_list = 0
scanf scanf ( "%d" , & N )
scanf scanf ( "%s" , invoke_list )
<operator>.assignment nElements = 0
printf printf ( "Case #%d: " , iT )
print_array print_array ( element_list , nElements )
printf printf ( "\n" )
printf printf ( "DEBUG: T: %d, iT:%d\n" , T , iT )
<operator>.lessEqualsThan iC <= C
<operator>.preIncrement ++ iC
<operator>.lessEqualsThan iD <= D
<operator>.preIncrement ++ iD
<operator>.lessEqualsThan iN <= N
<operator>.preIncrement ++ iN
<operator>.assignment iC = 1
scanf scanf ( "%s" , combination )
<operator>.assignment combine_rules [ hash ( combination [ 0 ] , combination [ 1 ] ) ] = combination [ 2 ]
<operator>.assignment iD = 1
scanf scanf ( "%s" , opposed )
<operators>.assignmentAnd opposed_rules [ opposed [ 0 ] ] &= mask [ opposed [ 1 ] ]
<operators>.assignmentAnd opposed_rules [ opposed [ 1 ] ] &= mask [ opposed [ 0 ] ]
<operator>.assignment iN = 1
printf printf ( "DEBUG: T: %d, iT:%d\n" , T , iT )
<operator>.assignment cur_element = invoke_list [ iN - 1 ]
<operator>.lessThan combination [ 0 ] < combination [ 1 ]
<operator>.equals 0 == nElements
<operator>.assignment swap_temp = combination [ 1 ]
<operator>.assignment combination [ 1 ] = combination [ 0 ]
<operator>.assignment combination [ 0 ] = swap_temp
<operator>.assignment element_list [ 0 ] = cur_element
<operator>.preIncrement ++ nElements
hash hash ( combination [ 0 ] , combination [ 1 ] )
<operator>.subtraction iN - 1
<operator>.assignment combine_output = combine_rules [ hash ( element_list [ nElements - 1 ] , cur_element ) ]
<operator>.notEquals NO_CHAR != combine_output
<operator>.assignment element_list [ nElements - 1 ] = combine_output
hash hash ( element_list [ nElements - 1 ] , cur_element )
<operator>.and 0 != mask [ cur_element ] & cur_bad_list
<operator>.subtraction nElements - 1
<operator>.subtraction nElements - 1
<operator>.assignment nElements = 0
<operator>.assignment cur_bad_list = 0
<operator>.notEquals 0 != mask [ cur_element ]
<operator>.assignment element_list [ nElements ] = cur_element
<operator>.preIncrement ++ nElements
<operators>.assignmentAnd cur_bad_list &= mask [ cur_element ]
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.indirectIndexAccess combine_rules [ hash ( combination [ 0 ] , combination [ 1 ] ) ]
<operator>.indirectIndexAccess combination [ 2 ]
<operator>.indirectIndexAccess opposed_rules [ opposed [ 0 ] ]
<operator>.indirectIndexAccess mask [ opposed [ 1 ] ]
<operator>.indirectIndexAccess opposed_rules [ opposed [ 1 ] ]
<operator>.indirectIndexAccess mask [ opposed [ 0 ] ]
<operator>.indirectIndexAccess invoke_list [ iN - 1 ]
<operator>.indirectIndexAccess combination [ 0 ]
<operator>.indirectIndexAccess combination [ 1 ]
<operator>.indirectIndexAccess opposed [ 0 ]
<operator>.indirectIndexAccess opposed [ 1 ]
<operator>.indirectIndexAccess opposed [ 1 ]
<operator>.indirectIndexAccess opposed [ 0 ]
<operator>.indirectIndexAccess combination [ 1 ]
<operator>.indirectIndexAccess combination [ 1 ]
<operator>.indirectIndexAccess combination [ 0 ]
<operator>.indirectIndexAccess combination [ 0 ]
<operator>.indirectIndexAccess combination [ 0 ]
<operator>.indirectIndexAccess combination [ 1 ]
<operator>.indirectIndexAccess element_list [ 0 ]
<operator>.indirectIndexAccess combine_rules [ hash ( element_list [ nElements - 1 ] , cur_element ) ]
<operator>.indirectIndexAccess element_list [ nElements - 1 ]
<operator>.indirectIndexAccess element_list [ nElements - 1 ]
<operator>.indirectIndexAccess mask [ cur_element ]
<operator>.indirectIndexAccess element_list [ nElements ]
<operator>.indirectIndexAccess mask [ cur_element ]
>>>PDG&91 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->34 0->37 0->38 0->41 0->44 0->45 0->46 0->48 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 2->1 3->1 3->1 3->1 3->35 3->36 3->58 3->61 4->1 4->6 4->11 4->23 4->38 5->1 6->1 6->1 6->1 6->6 6->7 6->11 6->11 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->20 6->21 6->22 6->23 6->24 6->26 6->28 6->30 6->33 6->37 6->62 6->63 6->64 7->1 7->6 8->5 9->3 9->3 9->3 9->3 9->3 9->3 9->3 9->3 9->3 10->1 10->6 11->20 11->23 11->38 11->38 12->1 12->1 12->1 12->49 12->50 13->1 13->24 14->1 14->1 14->35 14->36 15->1 15->26 16->1 16->1 16->53 17->1 17->28 18->1 18->39 19->1 19->21 19->41 20->1 20->23 21->1 21->1 21->1 21->52 22->1 23->1 23->6 23->7 24->1 24->1 24->1 24->13 24->24 24->25 24->25 24->31 24->32 24->40 24->47 24->65 24->66 24->72 24->73 24->82 24->83 25->1 25->24 26->1 26->1 26->1 26->15 26->26 26->27 26->27 26->34 26->35 26->36 26->67 26->68 26->69 26->70 26->74 26->75 26->76 26->77 27->1 27->26 28->1 28->1 28->1 28->17 28->28 28->29 28->38 28->39 28->41 28->48 28->48 28->71 29->1 29->28 30->1 30->24 31->1 31->32 31->40 31->42 31->43 31->47 32->1 32->1 32->1 32->12 33->1 33->26 34->1 35->1 35->1 35->14 36->1 36->1 36->14 37->1 37->28 38->20 38->23 39->1 39->1 39->45 39->52 40->1 40->42 40->42 40->43 40->43 40->44 40->47 40->47 40->78 40->79 40->80 40->81 41->1 41->45 41->46 41->46 41->49 41->50 41->52 41->54 41->54 41->84 41->85 41->86 42->1 42->44 43->1 43->47 44->1 44->1 44->47 45->1 45->1 45->1 45->21 46->1 46->21 46->41 47->1 47->1 47->31 47->31 47->40 47->40 48->29 49->1 49->1 49->50 50->1 50->1 50->1 50->12 50->51 50->51 50->53 50->55 50->58 50->87 50->88 51->1 51->1 51->1 51->21 51->52 52->1 52->1 52->21 52->59 53->1 53->1 53->56 53->57 53->59 53->60 53->61 53->61 53->89 53->90 54->55 54->60 55->21 55->41 56->1 56->21 56->41 57->1 57->1 57->53 58->1 58->53 58->53 58->61 59->1 59->1 59->1 59->21 60->1 60->21 60->41 61->1 61->1 61->53
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( void ) { short T , iT ; short C , iC ; short D , iD ; short N , iN ; char element_list [ MAX_N ] ; short nElements ; char combine_rules [ 676 ] ; char combination [ 4 ] ; int opposed_rules [ 26 ] ; char opposed [ 3 ] ; short cur_bad_list ; int mask [ 26 ] = { 8 , 0 , 0 , 2 , 32 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 128 , 16 , 4 , 0 , 0 , 0 , 64 , 0 , 0 , 0 } ; char invoke_list [ MAX_N ] ; char cur_element ; char combine_output ; char swap_temp ; scanf ( "\x25\x64\x0" , & T ) ; for ( iT = 1 ; iT <= T ; ++ iT ) { printf ( "DEBUG: T: %d, iT:%d\n" , T , iT ) ; memset ( combine_rules , NO_CHAR , 676 ) ; scanf ( "%d" , & C ) ; for ( iC = 1 ; iC <= C ; ++ iC ) { scanf ( "%s" , combination ) ; if ( combination [ 0 ] < combination [ 1 ] ) { swap_temp = combination [ 1 ] ; combination [ 1 ] = combination [ 0 ] ; combination [ 0 ] = swap_temp ; } combine_rules [ hash ( combination [ 0 ] , combination [ 1 ] ) ] = combination [ 2 ] ; } memset ( opposed_rules , 0 , 26 ) ; scanf ( "%d" , & D ) ; for ( iD = 1 ; iD <= D ; ++ iD ) { scanf ( "%s" , opposed ) ; opposed_rules [ opposed [ 0 ] ] &= mask [ opposed [ 1 ] ] ; opposed_rules [ opposed [ 1 ] ] &= mask [ opposed [ 0 ] ] ; } cur_bad_list = 0 ; scanf ( "%d" , & N ) ; scanf ( "%s" , invoke_list ) ; nElements = 0 ; for ( iN = 1 ; iN <= N ; ++ iN ) { printf ( "DEBUG: T: %d, iT:%d\n" , T , iT ) ; cur_element = invoke_list [ iN - 1 ] ; if ( 0 == nElements ) { element_list [ 0 ] = cur_element ; ++ nElements ; } else { combine_output = combine_rules [ hash ( element_list [ nElements - 1 ] , cur_element ) ] ; if ( NO_CHAR != combine_output ) { element_list [ nElements - 1 ] = combine_output ; } else { if ( 0 != mask [ cur_element ] & cur_bad_list ) { nElements = 0 ; cur_bad_list = 0 ; } else { element_list [ nElements ] = cur_element ; ++ nElements ; cur_bad_list &= mask [ cur_element ] ; } } } } printf ( "Case #%d: " , iT ) ; print_array ( element_list , nElements ) ; printf ( "\n" ) ; printf ( "DEBUG: T: %d, iT:%d\n" , T , iT ) ; } return ( 0 ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment cs = 0
RETURN return 0 ; return 0 ;
<operator>.postDecrement N --
LITERAL 0 return 0 ;
scanf scanf ( "\x25\x64\x0" , & N )
scanf scanf ( "%d %lld %d %d\n" , & L , & T , & n , & c )
<operator>.assignment a [ 0 ] = 0
<operator>.assignment s = n
sort sort ( b , b + n - s )
printf printf ( "Case #%d: %lld\n" , ++ cs , a [ n ] )
<operator>.lessThan i < c
<operator>.postIncrement i ++
scanf scanf ( "%d" , & cc [ i ] )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment a [ i + 1 ] = cc [ i % c ] * 2
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.logicalAnd i < L && n - s - 1 - i >= 0
<operator>.postIncrement i ++
<operator>.assignmentMinus a [ n ] -= b [ n - s - 1 - i ]
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment i = 1
<operator>.assignmentPlus a [ i ] += a [ i - 1 ]
<operator>.assignment i = s
<operator>.lessThan a [ i ] < T
<operator>.subtraction b + n - s
<operator>.assignment i = 0
<operator>.preIncrement ++ cs
<operator>.multiplication cc [ i % c ] * 2
<operator>.logicalAnd a [ i ] > T && i - 1 < s
<operator>.assignment b [ i - s ] = ( a [ i + 1 ] - T ) / 2
<operator>.addition b + n
<operator>.lessThan i < L
<operator>.greaterEqualsThan n - s - 1 - i >= 0
<operator>.addition i + 1
<operator>.assignment s = i - 1
<operator>.assignment b [ i - s ] = ( a [ i + 1 ] - a [ i ] ) / 2
<operator>.subtraction n - s - 1 - i
<operator>.subtraction n - s - 1 - i
<operator>.modulo i % c
<operator>.subtraction i - 1
<operator>.greaterThan a [ i ] > T
<operator>.lessThan i - 1 < s
<operator>.division ( a [ i + 1 ] - T ) / 2
<operator>.subtraction n - s - 1
<operator>.subtraction n - s - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - s
<operator>.subtraction a [ i + 1 ] - T
<operator>.division ( a [ i + 1 ] - a [ i ] ) / 2
<operator>.subtraction n - s
<operator>.subtraction n - s
<operator>.subtraction i - s
<operator>.subtraction a [ i + 1 ] - a [ i ]
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.addressOf & L
<operator>.addressOf & T
<operator>.addressOf & n
<operator>.addressOf & c
<operator>.indirectIndexAccess a [ 0 ]
<operator>.indirectIndexAccess a [ n ]
<operator>.addressOf & cc [ i ]
<operator>.indirectIndexAccess a [ i + 1 ]
<operator>.indirectIndexAccess a [ n ]
<operator>.indirectIndexAccess b [ n - s - 1 - i ]
<operator>.indirectIndexAccess cc [ i ]
<operator>.indirectIndexAccess cc [ i % c ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess a [ i - 1 ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess b [ i - s ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess b [ i - s ]
<operator>.indirectIndexAccess a [ i + 1 ]
<operator>.indirectIndexAccess a [ i + 1 ]
<operator>.indirectIndexAccess a [ i ]
>>>PDG&84 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->18 0->19 0->20 0->21 0->23 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->37 0->38 0->39 0->40 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->61 0->62 2->1 2->1 2->33 3->1 4->1 4->1 4->4 4->7 4->8 4->9 4->10 4->11 4->12 4->15 4->18 4->20 4->22 4->25 4->26 4->27 4->29 4->31 4->32 4->33 4->37 4->38 4->63 4->64 4->65 4->66 4->67 4->68 5->3 6->1 6->4 7->1 7->1 7->1 7->1 7->38 8->1 8->1 9->1 9->29 9->31 9->48 9->54 9->59 10->1 10->1 10->1 10->24 10->31 10->37 11->1 11->1 11->1 11->24 12->1 12->1 12->12 12->13 12->13 12->14 12->45 12->69 12->73 13->1 13->12 14->1 15->9 15->15 15->16 15->17 15->18 15->34 15->40 15->40 15->45 15->45 15->70 15->74 16->1 16->15 17->1 17->1 17->1 17->55 17->60 18->1 18->18 18->19 18->20 18->28 18->35 18->46 18->46 18->47 18->75 18->76 18->79 19->1 19->18 20->1 20->15 20->20 20->21 20->30 20->31 20->37 20->54 20->57 20->58 20->59 20->77 21->1 21->20 22->1 22->1 22->1 22->22 22->23 22->24 22->38 22->44 22->51 22->58 22->71 22->72 23->1 23->38 24->1 24->1 24->11 25->12 26->15 27->1 27->18 28->1 28->1 28->47 29->1 29->20 30->1 30->1 30->1 30->28 30->36 30->42 30->47 30->49 30->54 30->55 30->55 30->56 30->59 30->60 30->60 30->61 30->62 30->78 30->80 30->81 30->82 30->83 31->1 31->1 31->10 31->10 31->57 31->58 32->1 32->38 33->1 33->11 34->1 34->17 34->17 35->1 35->1 35->1 35->41 35->53 36->1 36->1 36->1 36->10 36->31 36->37 37->1 38->1 38->1 38->7 38->22 38->22 38->39 38->43 38->43 38->44 38->50 38->57 39->1 39->22 39->22 41->1 41->1 41->29 41->31 41->48 41->54 41->59 42->1 42->1 42->1 42->10 42->31 42->37 43->1 43->1 43->39 43->39 43->44 44->1 44->23 45->1 45->12 45->16 46->19 46->52 46->53 47->1 47->1 47->28 47->30 47->30 47->35 47->35 47->48 47->52 48->1 48->29 48->31 48->35 48->35 48->54 48->59 49->1 49->36 49->36 50->1 50->43 50->43 51->1 51->44 51->44 52->19 52->48 52->48 52->53 53->19 53->41 53->41 54->21 54->31 54->59 54->61 55->1 55->1 55->30 55->47 55->49 55->49 55->60 56->1 56->42 56->42 57->1 57->1 57->15 57->50 57->50 57->58 57->58 58->1 58->1 58->15 58->51 58->51 58->57 58->57 59->21 59->31 59->54 59->62 60->1 60->1 60->28 60->30 60->55 60->56 60->56
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int N , cs = 0 ; for ( scanf ( "\x25\x64\x0" , & N ) ; N -- ; ) { scanf ( "%d %lld %d %d\n" , & L , & T , & n , & c ) ; for ( int i = 0 ; i < c ; i ++ ) scanf ( "%d" , & cc [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) a [ i + 1 ] = cc [ i % c ] * 2 ; a [ 0 ] = 0 ; s = n ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] += a [ i - 1 ] ; if ( a [ i ] > T && i - 1 < s ) s = i - 1 ; } for ( int i = s ; i < n ; i ++ ) if ( a [ i ] < T ) b [ i - s ] = ( a [ i + 1 ] - T ) / 2 ; else b [ i - s ] = ( a [ i + 1 ] - a [ i ] ) / 2 ; sort ( b , b + n - s ) ; for ( int i = 0 ; i < L && n - s - 1 - i >= 0 ; i ++ ) a [ n ] -= b [ n - s - 1 - i ] ; printf ( "Case #%d: %lld\n" , ++ cs , a [ n ] ) ; } return 0 ; }
>>>Func
METHOD solve1
METHOD_RETURN int
<operator>.assignment nlen = 0
RETURN return 0 ; return 0 ;
<operator>.lessThan step < n
<operator>.postIncrement step ++
LITERAL 0 return 0 ;
<operator>.assignment step = 1
<operator>.lessThan i + step < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.addition i + step
<operator>.equals tab1 [ s [ i ] - 'A' ] [ s [ i + step ] - 'A' ] == 1
<operator>.assignment str [ nlen ] = '\0'
<operator>.assignment n = nlen
strcpy strcpy ( s , str )
RETURN return 1 ; return 1 ;
<operator>.lessThan j < i
<operator>.postIncrement j ++
<operator>.assignment str [ nlen ++ ] = s [ j ]
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment str [ nlen ++ ] = s [ j ]
LITERAL 1 return 1 ;
<operator>.subtraction s [ i + step ] - 'A'
<operator>.assignment j = 0
<operator>.assignment j = i + step + 1
<operator>.subtraction s [ i ] - 'A'
<operator>.addition i + step
<operator>.postIncrement nlen ++
<operator>.addition i + step + 1
<operator>.postIncrement nlen ++
<operator>.addition i + step
<operator>.indirectIndexAccess tab1 [ s [ i ] - 'A' ] [ s [ i + step ] - 'A' ]
<operator>.indirectIndexAccess tab1 [ s [ i ] - 'A' ]
<operator>.indirectIndexAccess str [ nlen ]
<operator>.indirectIndexAccess s [ i + step ]
<operator>.indirectIndexAccess str [ nlen ++ ]
<operator>.indirectIndexAccess s [ j ]
<operator>.indirectIndexAccess str [ nlen ++ ]
<operator>.indirectIndexAccess s [ j ]
<operator>.indirectIndexAccess s [ i ]
>>>PDG&42 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 2->1 2->14 2->29 2->31 3->1 4->1 4->3 4->5 4->8 4->8 4->8 4->10 4->11 4->11 5->1 5->4 6->3 7->1 7->4 8->1 8->4 8->4 8->5 8->12 8->20 8->24 8->27 8->28 8->33 8->34 8->36 8->41 9->1 9->8 9->11 9->17 9->28 10->1 10->8 10->9 10->11 10->17 10->28 12->1 12->1 12->8 12->9 12->11 12->13 12->14 12->15 12->16 12->17 12->20 12->25 12->26 12->30 12->32 12->35 13->1 13->1 13->15 14->1 14->1 14->1 15->1 15->1 15->1 16->1 17->1 17->17 17->18 17->18 17->19 17->26 17->29 17->30 17->32 17->37 17->38 18->1 18->17 19->1 19->1 19->1 19->15 20->1 20->1 20->20 20->21 20->21 20->22 20->31 20->39 20->40 21->1 21->20 22->1 22->1 22->1 22->15 23->16 24->1 24->15 25->1 25->17 26->1 26->1 26->20 27->1 27->15 29->14 29->31 30->1 31->14 32->1 32->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int solve1 ( ) { int nlen = 0 ; int i ; int step ; char str [ 110 ] ; int j ; for ( step = 1 ; step < n ; step ++ ) { for ( i = 0 ; i + step < n ; i ++ ) { if ( tab1 [ s [ i ] - 'A' ] [ s [ i + step ] - 'A' ] == 1 ) { for ( j = 0 ; j < i ; j ++ ) str [ nlen ++ ] = s [ j ] ; for ( j = i + step + 1 ; j < n ; j ++ ) str [ nlen ++ ] = s [ j ] ; str [ nlen ] = '\0' ; n = nlen ; strcpy ( s , str ) ; return 1 ; } } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment * fp = fopen ( argv [ 1 ] , "\x72\x0" )
<operator>.assignment ntests = 0
fscanf fscanf ( fp , "%d\n" , & ntests )
<operator>.lessThan printf <missing
<operator>.greaterThan ';'> ( "Number of tests: %d\n" , ntests )
IDENTIFIER ndif <empty>
<operator>.lessEqualsThan i <= ntests
<operator>.preIncrement ++ i
fopen fopen ( argv [ 1 ] , "\x72\x0" )
<operator>.bracketedPrimary ( "Number of tests: %d\n" , ntests )
<operator>.assignment i = 1
init_case init_case ( )
read_case read_case ( fp )
solve solve ( i )
<operator>.expressionList "Number of tests: %d\n"   ntests
>>>PDG&19 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 2->1 3->1 3->12 4->1 4->1 4->6 5->1 5->6 5->18 6->1 6->1 6->1 6->10 6->16 6->18 7->1 7->1 7->1 8->1 8->1 10->1 10->1 10->1 10->10 10->11 10->15 10->16 10->17 10->17 11->1 11->10 12->1 12->4 12->4 13->1 13->8 14->1 14->10 17->11 18->10 18->13 18->13
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * * argv ) { FILE * fp = fopen ( argv [ 1 ] , "\x72\x0" ) ; int ntests = 0 , i ; fscanf ( fp , "%d\n" , & ntests ) ; def S_DEBUG printf <missing ';'> ( "Number of tests: %d\n" , ntests ) ; ndif for ( i = 1 ; i <= ntests ; ++ i ) { init_case ( ) ; read_case ( fp ) ; solve ( i ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment stk = Stack_init ( )
Stack_push Stack_push ( stk   ( int * ) 1 )
Stack_push Stack_push ( stk   ( int * ) 2 )
Stack_push Stack_push ( stk   ( int * ) 3 )
Stack_push Stack_push ( stk   ( int * ) 4 )
printf printf ( "\x53\x69\x7a\x65\x3a\x20\x25\x64\x5c\x6e\x0"   Stack_size ( stk ) )
Stack_print Stack_print ( stk )
Stack_pop Stack_pop ( stk )
printf printf ( "Stack after popping: \n" )
Stack_print Stack_print ( stk )
Stack_pop Stack_pop ( stk )
printf printf ( "Stack after popping: \n" )
Stack_print Stack_print ( stk )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.cast ( int * ) 1
<operator>.cast ( int * ) 2
<operator>.cast ( int * ) 3
<operator>.cast ( int * ) 4
Stack_size Stack_size ( stk )
>>>PDG&22 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 2->1 2->1 2->3 3->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1 6->21 7->1 7->1 8->9 9->11 11->12 12->1 12->14 13->1 14->1 14->1 15->1 16->15 21->7 21->8
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { Stack_T stk ; stk = Stack_init ( ) ; Stack_push ( stk , ( int * ) 1 ) ; Stack_push ( stk , ( int * ) 2 ) ; Stack_push ( stk , ( int * ) 3 ) ; Stack_push ( stk , ( int * ) 4 ) ; printf ( "\x53\x69\x7a\x65\x3a\x20\x25\x64\x5c\x6e\x0" , Stack_size ( stk ) ) ; Stack_print ( stk ) ; Stack_pop ( stk ) ; printf ( "Stack after popping: \n" ) ; Stack_print ( stk ) ; Stack_pop ( stk ) ; printf ( "Stack after popping: \n" ) ; Stack_print ( stk ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment fp_in = fopen ( argv [ 1 ] , "\x72\x0" )
<operator>.assignment fp_out = fopen ( argv [ 2 ] , "w" )
fscanf fscanf ( fp_in , "%d " , & T )
fclose fclose ( fp_in )
fclose fclose ( fp_out )
RETURN return 0 ; return 0 ;
<operator>.equals fp_in == NULL
<operator>.equals fp_out == NULL
<operator>.lessThan i < T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
fopen fopen ( argv [ 1 ] , "\x72\x0" )
perror perror ( argv [ 1 ] )
exit exit ( 1 )
fopen fopen ( argv [ 2 ] , "w" )
perror perror ( argv [ 2 ] )
exit exit ( 1 )
<operator>.assignment i = 0
<operator>.assignment time = 0
<operator>.assignment compb = 0
<operator>.assignment bo = 0
<operator>.assignment onb = 0
<operator>.assignment useb = 0
fscanf fscanf ( fp_in , "%d %d %d %d " , & L , & t , & N , & C )
fprintf fprintf ( fp_out , "Case #%d: %d\n" , i + 1 , time )
<operator>.lessThan j < C
<operator>.postIncrement j ++
fscanf fscanf ( fp_in , "%d " , dist_g + j )
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment dist [ j ] = dist_g [ j % C ]
<operator>.assignment timeb [ j ] = t
<operator>.assignment j = 0
<operator>.assignment onb = decideb ( j , 0 , compb - useb , useb )
<operator>.assignment onb = 0
<operator>.addition i + 1
<operator>.addition dist_g + j
<operator>.lessThan bo < L
IDENTIFIER onb if (onb)
<operator>.lessEqualsThan k <= dist [ j ] * 2
<operator>.postIncrement k ++
<operator>.postIncrement bo ++
decideb decideb ( j , 0 , compb - useb , useb )
<operator>.postIncrement useb ++
<operator>.assignment k = 1
<operator>.modulo j % C
<operator>.subtraction compb - useb
<operator>.multiplication dist [ j ] * 2
<operator>.logicalAnd onb && k % 2
<operator>.postIncrement time ++
<operator>.modulo k % 2
<operator>.lessThan m < bo
<operator>.postIncrement m ++
<operator>.assignment m = compb
<operator>.postDecrement timeb [ m ] --
<operator>.logicalNot ! onb
<operator>.equals timeb [ m ] == 0
<operator>.postIncrement time ++
<operator>.postIncrement compb ++
<operator>.lessThan m < bo
<operator>.postIncrement m ++
<operator>.assignment m = compb
<operator>.postDecrement timeb [ m ] --
<operator>.equals timeb [ m ] == 0
<operator>.postIncrement compb ++
<operator>.assignment onb = decideb ( j , k , compb - useb , useb )
IDENTIFIER onb if (onb)
decideb decideb ( j , k , compb - useb , useb )
<operator>.postIncrement useb ++
<operator>.subtraction compb - useb
<operator>.indirectIndexAccess argv [ 1 ]
<operator>.indirectIndexAccess argv [ 2 ]
<operator>.addressOf & L
<operator>.addressOf & t
<operator>.addressOf & N
<operator>.addressOf & C
<operator>.indirectIndexAccess dist [ j ]
<operator>.indirectIndexAccess dist_g [ j % C ]
<operator>.indirectIndexAccess timeb [ j ]
<operator>.indirectIndexAccess dist [ j ]
<operator>.indirectIndexAccess timeb [ m ]
<operator>.indirectIndexAccess timeb [ m ]
<operator>.indirectIndexAccess timeb [ m ]
<operator>.indirectIndexAccess timeb [ m ]
>>>PDG&92 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->71 0->72 0->74 0->75 0->76 0->77 2->1 3->1 3->15 3->16 3->18 3->19 4->1 4->1 4->10 5->1 5->1 5->11 6->1 6->1 6->7 6->12 6->27 7->1 7->1 8->1 8->1 9->1 10->1 10->6 10->11 10->16 10->17 10->78 11->1 11->1 11->8 11->19 11->20 11->28 11->79 12->1 12->1 12->1 12->12 12->13 12->13 12->22 12->23 12->24 12->25 12->26 12->27 12->28 12->28 12->29 12->32 12->34 12->36 12->37 12->40 12->43 12->43 12->80 12->81 12->82 12->83 13->1 13->12 14->9 15->1 15->4 15->4 15->16 16->1 16->1 18->1 18->5 18->5 18->19 19->1 19->1 21->1 21->12 22->1 22->28 22->57 22->65 23->1 23->1 23->54 24->1 24->1 24->45 25->1 25->1 26->1 26->1 26->54 27->1 27->1 27->1 27->1 27->1 27->7 27->29 27->31 27->32 27->34 27->39 27->45 27->53 28->1 28->1 28->1 28->8 29->1 29->1 29->27 29->29 29->30 29->30 29->31 29->31 29->44 29->44 29->53 30->1 30->29 31->1 31->1 31->7 31->27 32->32 32->33 32->34 32->38 32->39 32->53 32->53 32->84 32->85 32->86 33->1 33->32 34->1 34->1 34->1 34->27 34->32 34->34 34->35 34->41 34->42 34->45 34->47 34->50 34->50 34->51 34->52 34->54 34->55 34->87 35->1 35->34 36->29 37->32 38->1 38->1 38->1 38->55 39->1 39->1 39->1 40->1 40->34 41->1 41->1 41->56 42->1 42->1 44->1 45->1 45->1 45->1 45->27 45->49 45->49 45->59 45->67 47->1 47->1 47->1 47->47 47->48 47->48 47->55 47->56 47->58 47->58 47->75 47->87 48->1 48->47 49->1 49->1 49->45 49->59 49->67 50->1 50->1 50->35 50->41 50->41 50->41 50->41 50->51 50->54 50->75 50->77 51->1 51->1 51->54 51->77 52->1 52->47 53->1 53->27 53->29 53->33 54->1 54->50 54->50 54->61 54->66 54->69 54->72 55->1 55->47 55->47 56->1 56->1 56->57 56->59 56->61 56->63 56->63 57->1 57->28 57->65 58->48 58->56 58->56 58->75 59->1 59->1 59->1 59->45 59->59 59->60 59->60 59->62 59->64 59->67 59->88 59->89 60->1 60->59 61->1 61->1 61->59 62->1 62->64 63->1 63->56 63->65 63->67 63->69 64->1 64->1 64->62 64->66 64->70 65->1 65->28 65->57 66->1 66->1 66->54 66->61 66->69 66->72 67->1 67->1 67->1 67->45 67->59 67->67 67->68 67->68 67->70 67->71 67->90 67->91 68->1 68->67 69->1 69->1 69->67 70->1 70->71 71->1 71->1 71->62 71->70 71->72 71->73 71->75 71->76 71->77 72->1 72->77 73->1 73->1 73->56 75->1 75->1 75->35 75->48 75->54 75->73 75->73 75->73 75->73 75->76 75->77 76->1 76->1 76->54 76->77 77->1 77->54 77->61 77->66 77->69 77->72 77->75 77->75
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( int argc , char * * argv ) { FILE * fp_in , * fp_out ; int i , j , k , m ; int T ; int time ; int compb ; int useb ; int bo ; char onb ; fp_in = fopen ( argv [ 1 ] , "\x72\x0" ) ; if ( fp_in == NULL ) { perror ( argv [ 1 ] ) ; exit ( 1 ) ; } fp_out = fopen ( argv [ 2 ] , "w" ) ; if ( fp_out == NULL ) { perror ( argv [ 2 ] ) ; exit ( 1 ) ; } fscanf ( fp_in , "%d " , & T ) ; for ( i = 0 ; i < T ; i ++ ) { time = 0 ; compb = 0 ; bo = 0 ; onb = 0 ; useb = 0 ; fscanf ( fp_in , "%d %d %d %d " , & L , & t , & N , & C ) ; for ( j = 0 ; j < C ; j ++ ) fscanf ( fp_in , "%d " , dist_g + j ) ; for ( j = 0 ; j < N ; j ++ ) { dist [ j ] = dist_g [ j % C ] ; timeb [ j ] = t ; } for ( j = 0 ; j < N ; j ++ ) { if ( bo < L ) bo ++ ; onb = decideb ( j , 0 , compb - useb , useb ) ; if ( onb ) useb ++ ; for ( k = 1 ; k <= dist [ j ] * 2 ; k ++ ) { if ( onb && k % 2 ) { time ++ ; for ( m = compb ; m < bo ; m ++ ) { timeb [ m ] -- ; if ( timeb [ m ] == 0 ) { compb ++ ; } } } else if ( ! onb ) { time ++ ; for ( m = compb ; m < bo ; m ++ ) { timeb [ m ] -- ; if ( timeb [ m ] == 0 ) { compb ++ ; onb = decideb ( j , k , compb - useb , useb ) ; if ( onb ) useb ++ ; } } } } onb = 0 ; } fprintf ( fp_out , "Case #%d: %d\n" , i + 1 , time ) ; } fclose ( fp_in ) ; fclose ( fp_out ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment sum = 0
printf printf ( "\x53\x75\x6d\x20\x69\x73\x3a\x20\x25\x64\x5c\x6e\x0" , sum )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < argc
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.assignmentPlus sum += i
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->7 3->1 4->1 4->5 4->11 5->1 5->1 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->11 7->11 8->1 8->7 9->6 10->1 10->7 11->1 11->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * argv [ ] ) { int i ; int sum = 0 ; for ( i = 0 ; i < argc ; i ++ ) { sum += i ; } printf ( "\x53\x75\x6d\x20\x69\x73\x3a\x20\x25\x64\x5c\x6e\x0" , sum ) ; return 0 ; }
>>>Func
METHOD calcAr
METHOD_RETURN double
PARAM double place
<operator>.assignment area = place * 2000.0
<operator>.assignment dy = ( lowerP [ i ] . y - lowerP [ i - 1 ] . y ) / ( lowerP [ i ] . x - lowerP [ i - 1 ] . x )
<operator>.assignment y = lowerP [ i - 1 ] . y + ( dy * ( place - lowerP [ i - 1 ] . x ) )
<operator>.assignment h = max ( lowerP [ i - 1 ] . y , y ) + 1000.0
<operator>.assignmentMinus area -= h * ( place - lowerP [ i - 1 ] . x )
<operator>.assignmentPlus area += 0.5 * ( ( place - lowerP [ i - 1 ] . x ) * ( absF ( lowerP [ i - 1 ] . y - y ) ) )
<operator>.assignment dy = ( upperP [ i ] . y - upperP [ i - 1 ] . y ) / ( upperP [ i ] . x - upperP [ i - 1 ] . x )
<operator>.assignment y = upperP [ i - 1 ] . y + ( dy * ( place - upperP [ i - 1 ] . x ) )
<operator>.assignment h = 1000.0 - min ( upperP [ i - 1 ] . y , y )
<operator>.assignmentMinus area -= h * ( place - upperP [ i - 1 ] . x )
<operator>.assignmentPlus area += 0.5 * ( ( place - upperP [ i - 1 ] . x ) * ( absF ( upperP [ i - 1 ] . y - y ) ) )
RETURN return area ; return area ;
<operator>.lessThan lowerP [ i ] . x < place
<operator>.postIncrement i ++
<operator>.lessThan upperP [ i ] . x < place
<operator>.postIncrement i ++
IDENTIFIER area return area ;
<operator>.multiplication place * 2000.0
<operator>.assignment i = 1
<operator>.assignment h = max ( lowerP [ i - 1 ] . y , lowerP [ i ] . y ) + 1000.0
<operator>.assignmentMinus area -= h * ( lowerP [ i ] . x - lowerP [ i - 1 ] . x )
<operator>.assignmentPlus area += 0.5 * ( ( lowerP [ i ] . x - lowerP [ i - 1 ] . x ) * ( absF ( lowerP [ i - 1 ] . y - lowerP [ i ] . y ) ) )
<operator>.division ( lowerP [ i ] . y - lowerP [ i - 1 ] . y ) / ( lowerP [ i ] . x - lowerP [ i - 1 ] . x )
<operator>.addition lowerP [ i - 1 ] . y + ( dy * ( place - lowerP [ i - 1 ] . x ) )
<operator>.addition max ( lowerP [ i - 1 ] . y , y ) + 1000.0
<operator>.multiplication h * ( place - lowerP [ i - 1 ] . x )
<operator>.multiplication 0.5 * ( ( place - lowerP [ i - 1 ] . x ) * ( absF ( lowerP [ i - 1 ] . y - y ) ) )
<operator>.assignment i = 1
<operator>.assignment h = 1000.0 - min ( upperP [ i - 1 ] . y , upperP [ i ] . y )
<operator>.assignmentMinus area -= h * ( upperP [ i ] . x - upperP [ i - 1 ] . x )
<operator>.assignmentPlus area += 0.5 * ( ( upperP [ i ] . x - upperP [ i - 1 ] . x ) * ( absF ( upperP [ i - 1 ] . y - upperP [ i ] . y ) ) )
<operator>.division ( upperP [ i ] . y - upperP [ i - 1 ] . y ) / ( upperP [ i ] . x - upperP [ i - 1 ] . x )
<operator>.addition upperP [ i - 1 ] . y + ( dy * ( place - upperP [ i - 1 ] . x ) )
<operator>.subtraction 1000.0 - min ( upperP [ i - 1 ] . y , y )
<operator>.multiplication h * ( place - upperP [ i - 1 ] . x )
<operator>.multiplication 0.5 * ( ( place - upperP [ i - 1 ] . x ) * ( absF ( upperP [ i - 1 ] . y - y ) ) )
<operator>.subtraction lowerP [ i ] . y - lowerP [ i - 1 ] . y
<operator>.subtraction lowerP [ i ] . x - lowerP [ i - 1 ] . x
<operator>.multiplication dy * ( place - lowerP [ i - 1 ] . x )
max max ( lowerP [ i - 1 ] . y , y )
<operator>.subtraction place - lowerP [ i - 1 ] . x
<operator>.multiplication ( place - lowerP [ i - 1 ] . x ) * ( absF ( lowerP [ i - 1 ] . y - y ) )
<operator>.subtraction upperP [ i ] . y - upperP [ i - 1 ] . y
<operator>.subtraction upperP [ i ] . x - upperP [ i - 1 ] . x
<operator>.multiplication dy * ( place - upperP [ i - 1 ] . x )
min min ( upperP [ i - 1 ] . y , y )
<operator>.subtraction place - upperP [ i - 1 ] . x
<operator>.multiplication ( place - upperP [ i - 1 ] . x ) * ( absF ( upperP [ i - 1 ] . y - y ) )
<operator>.addition max ( lowerP [ i - 1 ] . y , lowerP [ i ] . y ) + 1000.0
<operator>.multiplication h * ( lowerP [ i ] . x - lowerP [ i - 1 ] . x )
<operator>.multiplication 0.5 * ( ( lowerP [ i ] . x - lowerP [ i - 1 ] . x ) * ( absF ( lowerP [ i - 1 ] . y - lowerP [ i ] . y ) ) )
<operator>.subtraction place - lowerP [ i - 1 ] . x
<operator>.subtraction place - lowerP [ i - 1 ] . x
absF absF ( lowerP [ i - 1 ] . y - y )
<operator>.subtraction 1000.0 - min ( upperP [ i - 1 ] . y , upperP [ i ] . y )
<operator>.multiplication h * ( upperP [ i ] . x - upperP [ i - 1 ] . x )
<operator>.multiplication 0.5 * ( ( upperP [ i ] . x - upperP [ i - 1 ] . x ) * ( absF ( upperP [ i - 1 ] . y - upperP [ i ] . y ) ) )
<operator>.subtraction place - upperP [ i - 1 ] . x
<operator>.subtraction place - upperP [ i - 1 ] . x
absF absF ( upperP [ i - 1 ] . y - y )
max max ( lowerP [ i - 1 ] . y , lowerP [ i ] . y )
<operator>.subtraction lowerP [ i ] . x - lowerP [ i - 1 ] . x
<operator>.multiplication ( lowerP [ i ] . x - lowerP [ i - 1 ] . x ) * ( absF ( lowerP [ i - 1 ] . y - lowerP [ i ] . y ) )
<operator>.subtraction i - 1
<operator>.subtraction lowerP [ i - 1 ] . y - y
min min ( upperP [ i - 1 ] . y , upperP [ i ] . y )
<operator>.subtraction upperP [ i ] . x - upperP [ i - 1 ] . x
<operator>.multiplication ( upperP [ i ] . x - upperP [ i - 1 ] . x ) * ( absF ( upperP [ i - 1 ] . y - upperP [ i ] . y ) )
<operator>.subtraction i - 1
<operator>.subtraction upperP [ i - 1 ] . y - y
<operator>.subtraction lowerP [ i ] . x - lowerP [ i - 1 ] . x
absF absF ( lowerP [ i - 1 ] . y - lowerP [ i ] . y )
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction upperP [ i ] . x - upperP [ i - 1 ] . x
absF absF ( upperP [ i - 1 ] . y - upperP [ i ] . y )
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction lowerP [ i - 1 ] . y - lowerP [ i ] . y
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction upperP [ i - 1 ] . y - upperP [ i ] . y
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.subtraction i - 1
<operator>.fieldAccess lowerP [ i ] . x
<operator>.fieldAccess upperP [ i ] . x
<operator>.indirectIndexAccess lowerP [ i ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess upperP [ i ]
FIELD_IDENTIFIER x x
<operator>.fieldAccess lowerP [ i - 1 ] . y
<operator>.fieldAccess lowerP [ i ] . y
<operator>.fieldAccess lowerP [ i ] . x
<operator>.fieldAccess lowerP [ i - 1 ] . x
<operator>.fieldAccess upperP [ i - 1 ] . y
<operator>.fieldAccess upperP [ i ] . y
<operator>.fieldAccess upperP [ i ] . x
<operator>.fieldAccess upperP [ i - 1 ] . x
<operator>.indirectIndexAccess lowerP [ i - 1 ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess lowerP [ i ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess lowerP [ i ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess lowerP [ i - 1 ]
FIELD_IDENTIFIER x x
<operator>.fieldAccess lowerP [ i ] . x
<operator>.fieldAccess lowerP [ i - 1 ] . x
<operator>.indirectIndexAccess upperP [ i - 1 ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess upperP [ i ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess upperP [ i ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess upperP [ i - 1 ]
FIELD_IDENTIFIER x x
<operator>.fieldAccess upperP [ i ] . x
<operator>.fieldAccess upperP [ i - 1 ] . x
<operator>.indirectIndexAccess lowerP [ i ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess lowerP [ i - 1 ]
FIELD_IDENTIFIER x x
<operator>.fieldAccess lowerP [ i - 1 ] . y
<operator>.fieldAccess lowerP [ i ] . y
<operator>.indirectIndexAccess upperP [ i ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess upperP [ i - 1 ]
FIELD_IDENTIFIER x x
<operator>.fieldAccess upperP [ i - 1 ] . y
<operator>.fieldAccess upperP [ i ] . y
<operator>.indirectIndexAccess lowerP [ i - 1 ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess lowerP [ i ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess upperP [ i - 1 ]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess upperP [ i ]
FIELD_IDENTIFIER y y
>>>PDG&155 0->2 0->6 0->7 0->8 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->27 0->28 0->29 0->30 0->32 0->33 0->36 0->37 0->38 0->41 0->42 0->43 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->57 0->58 0->59 0->60 0->61 0->66 0->67 0->71 0->72 0->75 0->76 0->77 0->78 0->81 0->82 0->83 0->84 0->86 0->87 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 2->20 3->1 3->1 3->7 3->23 4->1 4->1 4->41 5->1 5->1 5->42 6->1 6->1 6->28 7->1 7->1 7->8 8->1 8->1 8->12 8->32 9->1 9->1 9->47 10->1 10->1 10->48 11->1 11->1 11->37 12->1 12->1 12->13 13->1 13->1 13->1 13->19 14->1 15->1 15->15 15->16 15->22 15->23 15->24 15->51 15->52 15->53 15->54 15->63 15->64 15->65 15->73 15->74 15->85 15->91 15->92 15->97 15->99 15->101 15->103 15->104 15->107 15->108 15->109 15->110 15->115 15->116 15->117 15->118 15->119 15->120 15->121 15->122 15->123 15->124 15->135 15->136 15->137 15->138 15->139 15->140 15->147 15->148 15->149 15->150 16->1 16->75 16->91 17->1 17->17 17->18 17->31 17->32 17->33 17->57 17->58 17->59 17->60 17->68 17->69 17->70 17->79 17->80 17->88 17->94 17->95 17->98 17->100 17->102 17->105 17->106 17->111 17->112 17->113 17->114 17->125 17->126 17->127 17->128 17->129 17->130 17->131 17->132 17->133 17->134 17->141 17->142 17->143 17->144 17->145 17->146 17->151 17->152 17->153 17->154 18->1 18->81 18->94 19->14 20->3 20->3 20->15 21->75 21->91 22->1 22->1 22->52 23->1 23->1 23->24 24->1 24->1 24->7 24->23 25->1 25->1 25->4 25->4 26->1 27->1 28->7 28->7 29->1 29->8 29->8 30->1 30->81 30->94 31->1 31->1 31->58 32->1 32->1 32->33 33->1 33->1 33->12 33->32 34->1 34->1 34->9 34->9 35->1 36->1 36->11 36->11 37->1 37->12 37->12 38->1 38->13 38->13 39->25 39->25 40->25 40->25 41->5 41->5 41->26 41->26 42->6 42->6 42->27 42->27 42->67 43->28 43->28 43->55 44->1 44->1 44->29 44->29 45->34 45->34 46->34 46->34 47->1 47->10 47->10 47->35 47->35 48->36 48->36 48->72 49->37 49->37 49->61 50->1 50->1 50->38 50->38 51->1 52->23 52->23 53->1 53->24 53->24 54->41 54->41 54->43 55->17 55->44 55->44 56->1 56->44 57->1 57->31 57->31 58->32 58->32 59->1 59->33 59->33 60->47 60->47 60->49 61->1 61->50 61->50 62->1 62->50 63->22 63->22 63->51 63->51 64->52 64->52 65->1 65->53 65->53 66->86 67->56 67->56 68->57 68->57 69->58 69->58 70->1 70->59 70->59 71->89 72->1 72->1 72->62 72->62 73->65 73->65 74->1 74->65 75->76 76->66 77->78 78->87 79->70 79->70 80->1 80->70 81->82 82->71 83->84 84->90 85->74 85->74 86->77 87->93 88->80 88->80 89->83 90->96 91->92 92->97 94->95 95->98 96->1 97->99 98->100 99->16 100->18
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) double calcAr ( double place ) { int i ; double area = place * 2000.0 ; double h ; for ( i = 1 ; lowerP [ i ] . x < place ; i ++ ) { h = max ( lowerP [ i - 1 ] . y , lowerP [ i ] . y ) + 1000.0 ; area -= h * ( lowerP [ i ] . x - lowerP [ i - 1 ] . x ) ; area += 0.5 * ( ( lowerP [ i ] . x - lowerP [ i - 1 ] . x ) * ( absF ( lowerP [ i - 1 ] . y - lowerP [ i ] . y ) ) ) ; } double dy = ( lowerP [ i ] . y - lowerP [ i - 1 ] . y ) / ( lowerP [ i ] . x - lowerP [ i - 1 ] . x ) ; double y = lowerP [ i - 1 ] . y + ( dy * ( place - lowerP [ i - 1 ] . x ) ) ; h = max ( lowerP [ i - 1 ] . y , y ) + 1000.0 ; area -= h * ( place - lowerP [ i - 1 ] . x ) ; area += 0.5 * ( ( place - lowerP [ i - 1 ] . x ) * ( absF ( lowerP [ i - 1 ] . y - y ) ) ) ; for ( i = 1 ; upperP [ i ] . x < place ; i ++ ) { h = 1000.0 - min ( upperP [ i - 1 ] . y , upperP [ i ] . y ) ; area -= h * ( upperP [ i ] . x - upperP [ i - 1 ] . x ) ; area += 0.5 * ( ( upperP [ i ] . x - upperP [ i - 1 ] . x ) * ( absF ( upperP [ i - 1 ] . y - upperP [ i ] . y ) ) ) ; } dy = ( upperP [ i ] . y - upperP [ i - 1 ] . y ) / ( upperP [ i ] . x - upperP [ i - 1 ] . x ) ; y = upperP [ i - 1 ] . y + ( dy * ( place - upperP [ i - 1 ] . x ) ) ; h = 1000.0 - min ( upperP [ i - 1 ] . y , y ) ; area -= h * ( place - upperP [ i - 1 ] . x ) ; area += 0.5 * ( ( place - upperP [ i - 1 ] . x ) * ( absF ( upperP [ i - 1 ] . y - y ) ) ) ; return area ; }
>>>Func
METHOD main
METHOD_RETURN ANY
scanf scanf ( "\x25\x64\x0" , & t )
<operator>.assignment N = t + 1
<operator>.greaterThan t > 0
<operator>.postDecrement t --
<operator>.addition t + 1
<operator>.assignment ans = 0.0
scanf scanf ( "%d" , & n )
getchar getchar ( )
printf printf ( "Case #%d:\n" , N - t )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
getchar getchar ( )
<operator>.assignment i = 0
<operator>.assignment a = b = 0.0
<operator>.assignment wp [ i ] = a / b
<operator>.assignment total [ i ] = b
<operator>.assignment i = 0
<operator>.assignment c = 0
<operator>.assignment owp [ i ] = 0.0
<operator>.assignment owp [ i ] = owp [ i ] / c
<operator>.subtraction N - t
<operator>.assignment i = 0
<operator>.assignment oowp [ i ] = 0.0
<operator>.assignment c = 0
<operator>.assignment oowp [ i ] = oowp [ i ] / c
<operator>.assignment ans = ( 0.25 * wp [ i ] ) + ( 0.5 * owp [ i ] ) + ( 0.25 * oowp [ i ] )
printf printf ( "%lf\n" , ans )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment j = 0
scanf scanf ( "%c" , & M [ i ] [ j ] )
<operator>.assignment b = 0.0
<operator>.assignment j = 0
<operator>.division a / b
<operator>.assignment j = 0
<operator>.division owp [ i ] / c
<operator>.assignment j = 0
<operator>.division oowp [ i ] / c
<operator>.addition ( 0.25 * wp [ i ] ) + ( 0.5 * owp [ i ] ) + ( 0.25 * oowp [ i ] )
<operator>.equals M [ i ] [ j ] == '.'
<operator>.notEquals M [ i ] [ j ] != '.'
<operator>.notEquals M [ i ] [ j ] != '.'
<operator>.addition ( 0.25 * wp [ i ] ) + ( 0.5 * owp [ i ] )
<operator>.multiplication 0.25 * oowp [ i ]
<operator>.postIncrement c ++
<operator>.assignment owp [ i ] = owp [ i ] + ( ( wp [ j ] * total [ j ] ) - ( int ) ( M [ j ] [ i ] - '0' ) ) / ( total [ j ] - 1 )
<operator>.postIncrement c ++
<operator>.assignment oowp [ i ] = oowp [ i ] + owp [ j ]
<operator>.multiplication 0.25 * wp [ i ]
<operator>.multiplication 0.5 * owp [ i ]
<operator>.postIncrement b ++
<operator>.equals M [ i ] [ j ] == '1'
<operator>.addition owp [ i ] + ( ( wp [ j ] * total [ j ] ) - ( int ) ( M [ j ] [ i ] - '0' ) ) / ( total [ j ] - 1 )
<operator>.addition oowp [ i ] + owp [ j ]
<operator>.postIncrement a ++
<operator>.division ( ( wp [ j ] * total [ j ] ) - ( int ) ( M [ j ] [ i ] - '0' ) ) / ( total [ j ] - 1 )
<operator>.subtraction ( wp [ j ] * total [ j ] ) - ( int ) ( M [ j ] [ i ] - '0' )
<operator>.subtraction total [ j ] - 1
<operator>.multiplication wp [ j ] * total [ j ]
<operator>.cast ( int ) ( M [ j ] [ i ] - '0' )
<operator>.subtraction M [ j ] [ i ] - '0'
<operator>.addressOf & n
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess total [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.addressOf & M [ i ] [ j ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess M [ i ] [ j ]
<operator>.indirectIndexAccess M [ i ] [ j ]
<operator>.indirectIndexAccess M [ i ] [ j ]
<operator>.indirectIndexAccess M [ i ] [ j ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess M [ i ]
<operator>.indirectIndexAccess M [ i ]
<operator>.indirectIndexAccess M [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess M [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess M [ i ] [ j ]
<operator>.indirectIndexAccess M [ i ]
<operator>.indirectIndexAccess total [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess total [ j ]
UNKNOWN int int
<operator>.indirectIndexAccess M [ j ] [ i ]
<operator>.indirectIndexAccess M [ j ]
>>>PDG&110 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->54 0->55 0->56 0->58 0->59 0->61 0->63 0->64 0->65 0->66 0->69 0->72 0->75 2->1 2->3 2->4 2->5 2->6 2->29 3->1 3->1 3->1 3->29 4->1 4->1 4->4 4->5 4->7 4->8 4->9 4->10 4->11 4->13 4->15 4->17 4->19 4->21 4->25 4->29 4->29 4->30 4->76 5->1 5->4 7->1 7->1 8->1 8->11 8->13 8->15 8->17 8->36 8->38 8->40 8->42 9->1 10->1 10->1 11->11 11->12 11->12 11->13 11->20 11->36 11->36 11->44 12->1 12->11 13->13 13->14 13->14 13->15 13->22 13->23 13->24 13->38 13->38 13->46 13->47 13->48 13->77 13->78 14->1 14->13 15->15 15->16 15->16 15->17 15->26 15->27 15->28 15->40 15->40 15->49 15->50 15->79 15->80 15->83 16->1 16->15 17->1 17->1 17->1 17->8 17->11 17->17 17->18 17->18 17->31 17->32 17->33 17->34 17->35 17->42 17->42 17->51 17->52 17->53 17->57 17->58 17->63 17->64 17->81 17->82 17->84 17->86 17->91 17->92 18->1 18->17 19->11 20->1 21->13 22->1 22->1 22->48 22->69 23->1 23->1 23->1 23->63 24->1 24->1 24->1 25->15 26->1 26->50 26->59 27->1 27->50 27->60 27->67 28->1 28->1 28->1 28->64 29->1 29->5 29->10 29->10 30->1 30->17 31->1 31->52 31->62 31->68 32->1 32->52 32->61 33->1 33->1 33->58 34->1 34->1 34->35 35->1 35->1 36->1 36->1 36->11 36->36 36->37 36->37 36->45 36->85 36->87 36->93 37->1 37->36 38->1 38->1 38->13 38->38 38->39 38->39 38->54 38->88 38->94 39->1 39->38 40->1 40->1 40->15 40->40 40->41 40->41 40->55 40->89 40->95 41->1 41->40 42->1 42->1 42->17 42->42 42->43 42->43 42->56 42->90 42->97 43->1 43->42 44->1 44->36 45->1 45->54 45->55 45->56 45->66 46->22 46->48 46->65 47->1 47->38 48->1 48->23 48->23 48->24 49->1 49->40 50->1 50->28 50->28 51->1 51->42 52->1 52->33 52->33 53->1 53->1 54->1 54->1 54->45 54->55 54->56 54->65 54->66 54->66 54->102 54->103 55->1 55->1 55->45 55->54 55->56 55->59 55->60 55->67 55->70 55->71 55->72 55->73 55->74 55->75 55->96 55->99 55->104 55->105 55->106 55->107 55->108 55->109 56->1 56->1 56->45 56->54 56->55 56->61 56->62 56->68 56->98 56->100 56->101 57->1 57->1 58->1 58->34 58->34 58->53 58->53 59->1 59->50 60->1 60->1 60->50 60->67 61->1 61->52 62->1 62->1 62->52 62->68 63->1 63->34 63->34 63->53 63->53 63->57 63->57 64->1 64->34 64->34 64->53 64->53 64->57 64->57 65->1 65->48 66->1 66->1 66->45 66->54 66->55 66->56 66->69 67->1 68->1 69->1 69->48 70->1 70->1 70->60 70->60 70->67 70->67 71->1 71->1 71->70 71->70 72->1 72->70 72->70 72->73 73->1 73->71 73->71 73->72 74->1 75->1 75->71 75->71 75->74 75->74
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  main ( ) { int n , t ; int i , j ; char M [ 100 ] [ 100 ] ; scanf ( "\x25\x64\x0" , & t ) ; int N = t + 1 ; for ( ; t > 0 ; t -- ) { double wp [ 100 ] , ans = 0.0 ; static double owp [ 100 ] , oowp [ 100 ] ; int total [ 100 ] ; scanf ( "%d" , & n ) ; getchar ( ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { scanf ( "%c" , & M [ i ] [ j ] ) ; } getchar ( ) ; } double a , b ; for ( i = 0 ; i < n ; i ++ ) { a = b = 0.0 ; for ( j = 0 ; j < n ; j ++ ) { if ( M [ i ] [ j ] == '.' ) continue ; else { if ( M [ i ] [ j ] == '1' ) { a ++ ; } b ++ ; } } wp [ i ] = a / b ; total [ i ] = b ; } int c ; for ( i = 0 ; i < n ; i ++ ) { c = 0 ; owp [ i ] = 0.0 ; for ( j = 0 ; j < n ; j ++ ) { if ( M [ i ] [ j ] != '.' ) { c ++ ; owp [ i ] = owp [ i ] + ( ( wp [ j ] * total [ j ] ) - ( int ) ( M [ j ] [ i ] - '0' ) ) / ( total [ j ] - 1 ) ; } } owp [ i ] = owp [ i ] / c ; } printf ( "Case #%d:\n" , N - t ) ; for ( i = 0 ; i < n ; i ++ ) { oowp [ i ] = 0.0 ; c = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( M [ i ] [ j ] != '.' ) { c ++ ; oowp [ i ] = oowp [ i ] + owp [ j ] ; } } oowp [ i ] = oowp [ i ] / c ; ans = ( 0.25 * wp [ i ] ) + ( 0.5 * owp [ i ] ) + ( 0.25 * oowp [ i ] ) ; printf ( "%lf\n" , ans ) ; } } }
>>>Func
METHOD ac
METHOD_RETURN int
PARAM int * arr
PARAM int len
PARAM int val
<operator>.lessThan fi ( len ) <missing
RETURN return ( - 1 ) ; return ( - 1 ) ;
<operator>.minus - 1
fi fi ( len )
>>>PDG&9 0->2 0->3 0->4 0->5 0->7 0->8 2->1 3->8 4->1 5->1 5->1 5->1 6->1 7->1 7->6 8->1 8->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int ac ( int * arr , int len , int val ) { fi ( len ) <missing ';'> if ( val == arr [ i ] ) return ( val ) ; return ( - 1 ) ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & Tcases )
RETURN return 0 ; return 0 ;
<operator>.notEquals cases != Tcases
<operator>.postIncrement cases ++
LITERAL 0 return 0 ;
<operator>.assignment cases = 0
scanf scanf ( "%d %d %d %lf %d" , & X , & S , & R , & T , & N )
qsort qsort ( segs   N   sizeof ( struct seg ) , segs_cmp )
<operator>.assignment former = 0
<operator>.assignment cnt = 0
qsort qsort ( lines   cnt   sizeof ( struct seg ) , segs_cmp )
<operator>.assignment time = 0.0
<operator>.assignmentMinus R -= S
printf printf ( "Case #%d: %.10lf\n" , cases + 1 , time )
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.notEquals former != X
<operator>.logicalAnd i < cnt && T > 1e-10
<operator>.postIncrement i ++
<operator>.lessThan i < cnt
<operator>.postIncrement i ++
<operator>.assignment i = 0
scanf scanf ( "%d %d %d" , & segs [ i ] . v , & segs [ i ] . cnt , & segs [ i ] . spd )
<operator>.assignment i = 0
<operator>.assignment lines [ cnt ] . v = segs [ i ] . spd + S
<operator>.assignment lines [ cnt ] . cnt = segs [ i ] . cnt - segs [ i ] . v
<operator>.preIncrement ++ cnt
<operator>.assignment former = segs [ i ] . cnt
<operator>.assignment lines [ cnt ] . v = S
<operator>.assignment lines [ cnt ] . cnt = X - former
<operator>.preIncrement ++ cnt
<operator>.sizeOf sizeof ( struct seg )
<operator>.assignment i = 0
<operator>.assignment w = lines [ i ] . cnt / ( double ) ( lines [ i ] . v + R )
<operator>.assignmentPlus time += lines [ i ] . cnt / ( double ) lines [ i ] . v
<operator>.addition cases + 1
<operator>.notEquals segs [ i ] . v != former
<operator>.lessThan i < cnt
<operator>.greaterThan T > 1e-10
<operator>.logicalOr w < T || fabs ( w - T ) < 1e-10
<operator>.assignment lines [ cnt ] . v = S
<operator>.assignment lines [ cnt ] . cnt = segs [ i ] . v - former
<operator>.preIncrement ++ cnt
<operator>.addition segs [ i ] . spd + S
<operator>.subtraction segs [ i ] . cnt - segs [ i ] . v
<operator>.subtraction X - former
<operator>.division lines [ i ] . cnt / ( double ) ( lines [ i ] . v + R )
<operator>.assignmentMinus T -= w
<operator>.assignmentPlus time += w
<operator>.division lines [ i ] . cnt / ( double ) lines [ i ] . v
<operator>.cast ( double ) ( lines [ i ] . v + R )
<operator>.lessThan w < T
<operator>.lessThan fabs ( w - T ) < 1e-10
<operator>.assignmentPlus time += T
<operator>.assignmentPlus time += ( lines [ i ] . cnt - T * ( lines [ i ] . v + R ) ) / ( double ) ( lines [ i ] . v )
<operator>.assignment T = 0.0
<operator>.subtraction segs [ i ] . v - former
<operator>.addition lines [ i ] . v + R
fabs fabs ( w - T )
<operator>.subtraction w - T
<operator>.division ( lines [ i ] . cnt - T * ( lines [ i ] . v + R ) ) / ( double ) ( lines [ i ] . v )
<operator>.subtraction lines [ i ] . cnt - T * ( lines [ i ] . v + R )
<operator>.multiplication T * ( lines [ i ] . v + R )
<operator>.addition lines [ i ] . v + R
<operator>.addressOf & X
<operator>.addressOf & S
<operator>.addressOf & R
<operator>.addressOf & T
<operator>.addressOf & N
<operator>.sizeOf sizeof ( struct seg )
<operator>.addressOf & segs [ i ] . v
<operator>.addressOf & segs [ i ] . cnt
<operator>.addressOf & segs [ i ] . spd
<operator>.fieldAccess lines [ cnt ] . v
<operator>.fieldAccess lines [ cnt ] . cnt
<operator>.fieldAccess segs [ i ] . cnt
<operator>.fieldAccess lines [ cnt ] . v
<operator>.fieldAccess lines [ cnt ] . cnt
<operator>.fieldAccess segs [ i ] . v
<operator>.fieldAccess segs [ i ] . cnt
<operator>.fieldAccess segs [ i ] . spd
<operator>.fieldAccess segs [ i ] . v
<operator>.indirectIndexAccess lines [ cnt ]
FIELD_IDENTIFIER v v
<operator>.fieldAccess segs [ i ] . spd
<operator>.indirectIndexAccess lines [ cnt ]
FIELD_IDENTIFIER cnt cnt
<operator>.fieldAccess segs [ i ] . cnt
<operator>.fieldAccess segs [ i ] . v
<operator>.indirectIndexAccess segs [ i ]
FIELD_IDENTIFIER cnt cnt
<operator>.indirectIndexAccess lines [ cnt ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess lines [ cnt ]
FIELD_IDENTIFIER cnt cnt
<operator>.fieldAccess lines [ i ] . cnt
<operator>.fieldAccess lines [ i ] . cnt
<operator>.cast ( double ) lines [ i ] . v
<operator>.indirectIndexAccess segs [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess segs [ i ]
FIELD_IDENTIFIER cnt cnt
<operator>.indirectIndexAccess segs [ i ]
FIELD_IDENTIFIER spd spd
<operator>.indirectIndexAccess segs [ i ]
FIELD_IDENTIFIER v v
<operator>.fieldAccess lines [ cnt ] . v
<operator>.fieldAccess lines [ cnt ] . cnt
<operator>.indirectIndexAccess segs [ i ]
FIELD_IDENTIFIER spd spd
<operator>.indirectIndexAccess segs [ i ]
FIELD_IDENTIFIER cnt cnt
<operator>.indirectIndexAccess segs [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess lines [ i ]
FIELD_IDENTIFIER cnt cnt
UNKNOWN double double
<operator>.indirectIndexAccess lines [ i ]
FIELD_IDENTIFIER cnt cnt
UNKNOWN double double
<operator>.fieldAccess lines [ i ] . v
<operator>.indirectIndexAccess lines [ cnt ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess lines [ cnt ]
FIELD_IDENTIFIER cnt cnt
<operator>.fieldAccess segs [ i ] . v
<operator>.fieldAccess lines [ i ] . v
<operator>.indirectIndexAccess lines [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess segs [ i ]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess lines [ i ]
FIELD_IDENTIFIER v v
<operator>.cast ( double ) ( lines [ i ] . v )
<operator>.fieldAccess lines [ i ] . cnt
UNKNOWN double double
<operator>.fieldAccess lines [ i ] . v
<operator>.indirectIndexAccess lines [ i ]
FIELD_IDENTIFIER cnt cnt
<operator>.indirectIndexAccess lines [ i ]
FIELD_IDENTIFIER v v
<operator>.fieldAccess lines [ i ] . v
<operator>.indirectIndexAccess lines [ i ]
FIELD_IDENTIFIER v v
>>>PDG&148 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->27 0->28 0->30 0->32 0->34 0->36 0->38 0->39 0->40 0->41 0->42 0->44 0->46 0->47 0->49 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->63 0->66 0->67 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->15 4->16 4->18 4->20 4->21 4->23 4->25 4->27 4->35 4->36 4->39 4->39 4->41 4->68 4->69 4->70 4->71 4->72 4->73 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->1 8->1 8->20 8->49 9->1 9->1 9->12 9->18 10->1 10->20 10->40 11->1 11->12 11->30 11->34 11->46 12->1 12->1 12->1 12->9 12->41 13->1 13->15 13->38 13->52 13->57 14->1 14->1 14->1 14->50 14->54 14->61 15->1 15->1 15->1 16->9 16->16 16->17 16->17 16->26 16->74 16->75 16->76 16->82 16->83 16->84 16->102 16->103 16->104 16->105 16->106 16->107 17->1 17->16 18->1 18->1 18->16 18->18 18->19 18->19 18->28 18->29 18->30 18->31 18->40 18->47 18->48 18->77 18->78 18->79 18->85 18->86 18->87 18->88 18->89 18->90 18->91 18->92 18->93 18->94 18->108 18->109 18->112 18->113 18->114 18->115 18->116 18->117 19->1 19->18 20->1 20->1 20->1 20->8 20->32 20->33 20->34 20->49 20->49 20->49 20->80 20->81 20->95 20->96 20->97 20->98 21->1 21->1 21->21 21->22 21->37 21->41 21->43 21->50 21->54 21->55 21->61 21->99 21->118 21->119 21->120 21->130 21->135 21->136 22->1 22->41 23->1 23->1 23->1 23->23 23->24 23->24 23->38 23->53 23->100 23->101 23->121 23->122 23->123 23->124 23->131 23->132 24->1 24->23 25->16 26->1 26->1 26->1 26->40 26->48 26->60 27->18 28->1 28->1 29->1 29->1 30->1 30->12 30->34 30->46 31->1 31->20 31->40 32->1 33->1 33->1 34->1 34->12 35->1 36->1 36->41 37->1 37->1 37->55 38->1 38->1 38->15 40->1 40->44 40->45 40->46 40->48 40->60 40->60 40->60 40->110 40->111 40->125 40->126 40->127 40->128 40->129 40->133 40->134 41->21 41->21 41->22 41->23 41->23 41->42 42->1 42->21 42->21 42->55 43->1 43->1 43->1 43->51 43->52 43->57 43->58 43->59 43->64 43->65 43->66 43->67 43->137 43->138 43->139 43->140 43->141 43->142 43->143 43->144 43->145 43->146 43->147 44->1 45->1 45->1 46->30 48->29 48->29 48->31 49->1 49->1 49->8 49->20 49->33 49->33 50->1 50->37 50->37 50->65 51->1 51->1 51->42 51->55 52->1 52->1 52->15 52->38 52->57 53->1 53->38 53->38 54->1 55->1 55->43 55->43 55->51 55->51 55->52 55->56 55->57 55->62 55->63 55->63 55->63 55->66 56->1 56->43 56->43 57->1 57->58 58->1 58->1 58->15 58->38 58->52 58->57 59->1 59->1 59->42 59->55 60->45 60->45 60->48 61->1 62->1 63->1 63->51 63->51 63->52 63->56 63->56 63->57 63->62 63->62 63->66 64->1 64->1 64->58 64->58 65->1 65->64 65->64 66->1 66->65 66->65 67->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int Tcases ; scanf ( "\x25\x64\x0" , & Tcases ) ; int cases ; for ( cases = 0 ; cases != Tcases ; cases ++ ) { scanf ( "%d %d %d %lf %d" , & X , & S , & R , & T , & N ) ; int i ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d %d %d" , & segs [ i ] . v , & segs [ i ] . cnt , & segs [ i ] . spd ) ; } qsort ( segs , N , sizeof ( struct seg ) , segs_cmp ) ; int former = 0 ; int cnt = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( segs [ i ] . v != former ) { lines [ cnt ] . v = S ; lines [ cnt ] . cnt = segs [ i ] . v - former ; ++ cnt ; } lines [ cnt ] . v = segs [ i ] . spd + S ; lines [ cnt ] . cnt = segs [ i ] . cnt - segs [ i ] . v ; ++ cnt ; former = segs [ i ] . cnt ; } if ( former != X ) { lines [ cnt ] . v = S ; lines [ cnt ] . cnt = X - former ; ++ cnt ; } qsort ( lines , cnt , sizeof ( struct seg ) , segs_cmp ) ; double time = 0.0 ; R -= S ; for ( i = 0 ; i < cnt && T > 1e-10 ; i ++ ) { double w = lines [ i ] . cnt / ( double ) ( lines [ i ] . v + R ) ; if ( w < T || fabs ( w - T ) < 1e-10 ) { T -= w ; time += w ; } else { time += T ; time += ( lines [ i ] . cnt - T * ( lines [ i ] . v + R ) ) / ( double ) ( lines [ i ] . v ) ; T = 0.0 ; } } for ( ; i < cnt ; i ++ ) { time += lines [ i ] . cnt / ( double ) lines [ i ] . v ; } printf ( "Case #%d: %.10lf\n" , cases + 1 , time ) ; } return 0 ; }
>>>Func
METHOD isP
METHOD_RETURN int
PARAM unsigned long long x
RETURN return 1 ; return 1 ;
IDENTIFIER x for (n = 0 ;x;n ++)
<operator>.postIncrement n ++
<operator>.lessThan i < ( n + 1 ) / 2
<operator>.postIncrement i ++
LITERAL 1 return 1 ;
<operator>.assignment n = 0
<operator>.assignment v [ n ] = x % 10
<operator>.assignmentDivision x /= 10
<operator>.assignment i = 0
<operator>.division ( n + 1 ) / 2
<operator>.notEquals v [ i ] != v [ n - i - 1 ]
<operator>.modulo x % 10
<operator>.addition n + 1
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.subtraction n - i - 1
<operator>.subtraction n - i
<operator>.indirectIndexAccess v [ i ]
<operator>.indirectIndexAccess v [ n - i - 1 ]
>>>PDG&23 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 2->1 2->15 3->1 5->1 5->13 5->16 5->20 6->1 6->1 6->3 6->14 6->19 6->20 6->20 6->21 6->22 7->1 7->6 8->3 9->1 9->5 9->13 9->16 9->20 10->1 10->1 10->1 11->1 11->1 11->15 12->1 12->6 13->1 13->6 13->6 14->1 14->1 14->1 14->6 14->7 14->13 14->16 14->17 15->10 15->10 15->11 17->1 18->17 19->1 20->1 20->1 20->7 20->13 20->16 20->19 20->19
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int isP ( unsigned long long x ) { char v [ 14 ] , i , n ; for ( n = 0 ; x ; n ++ ) { v [ n ] = x % 10 ; x /= 10 ; } for ( i = 0 ; i < ( n + 1 ) / 2 ; i ++ ) { if ( v [ i ] != v [ n - i - 1 ] ) { return 0 ; } } return 1 ; }
>>>Func
METHOD search
METHOD_RETURN int
PARAM int * nums
PARAM int numsSize
PARAM int target
<operator>.assignment * ret = bsearch ( & target   nums   numsSize   sizeof ( int ) , cmpint )
IDENTIFIER ret if (ret)
bsearch bsearch ( & target   nums   numsSize   sizeof ( int ) , cmpint )
RETURN return ( ret - nums ) ; return ( ret - nums ) ;
<operator>.sizeOf sizeof ( int )
<operator>.subtraction ret - nums
RETURN return - 1 ; return - 1 ;
<operator>.minus - 1
>>>PDG&13 0->2 0->3 0->4 0->6 0->7 0->10 0->12 2->7 3->7 4->1 4->7 5->1 5->1 5->10 7->1 7->1 7->1 7->5 7->5 7->5 7->5 7->10 8->1 9->1 10->1 10->1 10->1 10->8 11->1 12->11
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int search ( int * nums , int numsSize , int target ) { int * ret = bsearch ( & target , nums , numsSize , sizeof ( int ) , cmpint ) ; if ( ret ) return ( ret - nums ) ; else return - 1 ; }
>>>Func
METHOD findKthLargest
METHOD_RETURN int
PARAM int * nums
PARAM int numsSize
PARAM int k
qsort qsort ( nums   numsSize   sizeof ( int ) , cmpval )
RETURN return nums [ k - 1 ] ; return nums [ k - 1 ] ;
<operator>.sizeOf sizeof ( int )
<operator>.subtraction k - 1
>>>PDG&9 0->2 0->3 0->4 0->5 0->8 2->5 3->5 4->8 5->1 5->1 5->1 5->1 6->1 7->1 8->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int findKthLargest ( int * nums , int numsSize , int k ) { qsort ( nums , numsSize , sizeof ( int ) , cmpval ) ; return nums [ k - 1 ] ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
<operator>.lessEqualsThan T_index <= T
<operator>.postIncrement T_index ++
<operator>.assignment T_index = 1
printf printf ( "Case #%d: " , T_index )
<operator>.assignment path = 0
<operator>.assignment k_time = 0
<operator>.assignment total = 0
<operator>.assignment t_tmp = 0
<operator>.assignment start_value = - 1
scanf scanf ( "%d %d %d %d" , & L , & t , & N , & C )
printf printf ( "%d\n" , total )
<operator>.lessThan i < C
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < L
<operator>.postIncrement i ++
<operator>.minus - 1
<operator>.assignment i = 0
scanf scanf ( "%d " , & dis [ i ] )
<operator>.assignmentPlus path += dis [ i ]
<operator>.assignment i = 0
<operator>.assignment dis_t [ i ] = dis [ i % C ]
<operator>.assignmentPlus total += ( dis_t [ i ] * 2 )
<operator>.assignment i = start_value
<operator>.assignment i = 0
<operator>.logicalAnd total >= t && start_value == - 1
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan start_value + i < N
<operator>.multiplication dis_t [ i ] * 2
<operator>.assignment start = i
<operator>.assignment start_value = ( total - t ) / 2
<operator>.assignment dis_t [ i ] = start_value
<operator>.assignment start_value = i
<operator>.assignment j = i + 1
<operator>.assignmentMinus total -= dis_t [ start_value + i ]
<operator>.modulo i % C
<operator>.greaterEqualsThan total >= t
<operator>.equals start_value == - 1
<operator>.lessThan dis_t [ i ] < dis_t [ j ]
<operator>.addition start_value + i
<operator>.minus - 1
<operator>.division ( total - t ) / 2
<operator>.addition i + 1
<operator>.assignment tmp = dis_t [ i ]
<operator>.assignment dis_t [ i ] = dis_t [ j ]
<operator>.assignment dis_t [ j ] = tmp
<operator>.subtraction total - t
<operator>.addition start_value + i
<operator>.addressOf & L
<operator>.addressOf & t
<operator>.addressOf & N
<operator>.addressOf & C
<operator>.addressOf & dis [ i ]
<operator>.indirectIndexAccess dis [ i ]
<operator>.indirectIndexAccess dis_t [ i ]
<operator>.indirectIndexAccess dis [ i % C ]
<operator>.indirectIndexAccess dis [ i ]
<operator>.indirectIndexAccess dis_t [ i ]
<operator>.indirectIndexAccess dis_t [ i ]
<operator>.indirectIndexAccess dis_t [ start_value + i ]
<operator>.indirectIndexAccess dis_t [ i ]
<operator>.indirectIndexAccess dis_t [ j ]
<operator>.indirectIndexAccess dis_t [ i ]
<operator>.indirectIndexAccess dis_t [ i ]
<operator>.indirectIndexAccess dis_t [ j ]
<operator>.indirectIndexAccess dis_t [ j ]
>>>PDG&73 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->28 0->29 0->30 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->49 0->52 0->53 0->54 2->1 2->3 3->1 3->1 3->1 3->3 3->4 3->6 3->6 3->7 3->8 3->9 3->10 3->11 3->12 3->13 3->14 3->16 3->18 3->20 3->22 3->23 3->26 3->29 3->30 3->55 3->56 3->57 3->58 4->1 4->3 5->1 5->3 6->1 6->4 7->1 7->1 7->25 8->1 8->1 9->1 9->13 9->28 9->41 10->1 10->1 11->1 11->1 11->29 11->34 11->44 11->46 12->1 12->1 12->1 12->1 12->20 13->1 13->1 14->1 14->1 14->14 14->15 14->15 14->24 14->25 14->42 14->59 14->60 14->63 15->1 15->14 16->16 16->17 16->18 16->27 16->28 16->31 16->35 16->42 16->42 16->43 16->61 16->62 16->64 17->1 17->16 18->1 18->1 18->16 18->18 18->19 18->19 18->32 18->32 18->34 18->40 18->40 18->49 18->49 19->1 19->18 20->1 20->1 20->1 20->12 20->20 20->21 20->21 20->34 20->34 20->46 20->46 20->54 21->1 21->20 22->11 23->14 24->1 24->25 25->1 25->1 25->1 26->16 27->1 27->1 27->35 28->1 28->1 28->43 29->1 29->1 29->18 30->1 30->20 31->1 31->1 31->1 31->36 31->37 31->38 31->39 31->48 31->53 31->65 32->1 32->1 32->18 32->32 32->33 32->33 32->45 32->67 32->68 33->1 33->32 34->1 34->1 34->1 34->16 34->41 34->54 34->66 35->1 35->28 35->28 35->45 36->1 36->1 37->1 37->1 37->38 38->1 38->1 38->45 39->1 39->29 39->34 39->44 39->46 40->1 40->1 40->32 41->1 41->1 41->13 42->1 42->14 42->17 42->36 42->39 43->1 43->13 43->28 43->31 43->31 43->41 43->44 43->47 43->53 43->53 44->1 44->29 44->31 44->31 44->34 44->46 45->1 45->1 45->1 45->50 45->50 45->51 45->51 45->52 45->69 45->70 45->71 45->72 46->1 47->44 48->1 48->37 48->37 50->1 50->52 51->1 51->1 51->45 52->1 52->1 52->1 52->45 53->1 53->13 53->28 53->41 53->43 53->48 53->48 54->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T , T_index ; int i , j , index ; int L , t , N , C , path , k_time , r , total , t_tmp , start , start_value , tmp ; scanf ( "\x25\x64\x0" , & T ) ; for ( T_index = 1 ; T_index <= T ; T_index ++ ) { printf ( "Case #%d: " , T_index ) ; path = 0 ; k_time = 0 ; total = 0 ; t_tmp = 0 ; start_value = - 1 ; scanf ( "%d %d %d %d" , & L , & t , & N , & C ) ; for ( i = 0 ; i < C ; i ++ ) { scanf ( "%d " , & dis [ i ] ) ; path += dis [ i ] ; } for ( i = 0 ; i < N ; i ++ ) { dis_t [ i ] = dis [ i % C ] ; total += ( dis_t [ i ] * 2 ) ; if ( total >= t && start_value == - 1 ) { start = i ; start_value = ( total - t ) / 2 ; dis_t [ i ] = start_value ; start_value = i ; } } for ( i = start_value ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( dis_t [ i ] < dis_t [ j ] ) { tmp = dis_t [ i ] ; dis_t [ i ] = dis_t [ j ] ; dis_t [ j ] = tmp ; } } } for ( i = 0 ; i < L ; i ++ ) { if ( start_value + i < N ) { total -= dis_t [ start_value + i ] ; } } printf ( "%d\n" , total ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment * in = stdin
FGETS FGETS ( buf , 4096 , in )
sscanf sscanf ( buf , "\x25\x64\x0" , & T )
<operator>.lessThan REP ( c , T ) <missing
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
REP REP ( c , T )
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 3->1 4->1 4->1 4->5 5->1 5->1 5->6 6->1 6->1 6->1 6->10 7->1 7->1 7->1 8->1 9->8 10->1 10->1 10->7 10->7
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( int argc , char * argv [ ] ) { char buf [ 4096 ] ; FILE * in = stdin ; int T ; FGETS ( buf , 4096 , in ) ; sscanf ( buf , "\x25\x64\x0" , & T ) ; REP ( c , T ) <missing ';'> { int N ; char line [ 101 ] [ 101 ] ; double wp [ 101 ] [ 101 ] , owp [ 101 ] [ 101 ] ; FGETS ( buf , 255 , in ) ; sscanf ( buf , "%d" , & N ) ; REP ( i , N ) <missing ';'> { FGETS ( line [ i ] , 255 , in ) ; } REP ( i , N ) <missing ';'> REP ( j , N ) <missing ';'> wp [ i ] [ j ] = owp [ i ] [ j ] = 0.0 ; REP ( i , N ) <missing ';'> { REP ( j , N ) <missing ';'> { double win = 0 , tot = 0 ; REP ( k , N ) <missing ';'> { if ( j == k ) continue ; if ( line [ i ] [ k ] == '.' ) continue ; if ( line [ i ] [ k ] == '1' ) win ++ ; tot ++ ; } wp [ i ] [ j ] = win / tot ; } } double WP [ 101 ] ; double OWP [ 101 ] ; double OOWP [ 101 ] ; REP ( i , N ) <missing ';'> WP [ i ] = OWP [ i ] = OOWP [ i ] = 0 ; REP ( i , N ) <missing ';'> { double win = 0 , tot = 0 ; REP ( j , N ) <missing ';'> { if ( line [ i ] [ j ] == '.' ) continue ; if ( line [ i ] [ j ] == '1' ) win ++ ; tot ++ ; } WP [ i ] = win / tot ; } REP ( i , N ) <missing ';'> { double sum = 0.0 , count = 0 ; REP ( j , N ) <missing ';'> { if ( line [ i ] [ j ] == '.' ) continue ; sum += wp [ j ] [ i ] ; count ++ ; } OWP [ i ] = sum / count ; } REP ( i , N ) <missing ';'> { double sum = 0.0 , count = 0 ; REP ( j , N ) <missing ';'> { if ( line [ i ] [ j ] == '.' ) continue ; sum += OWP [ j ] ; count ++ ; } OOWP [ i ] = sum / count ; } printf ( "Case #%d: " , c + 1 ) ; printf ( "\n" ) ; REP ( i , N ) <missing ';'> { printf ( "%.10lf\n" , 0.25 * WP [ i ] + 0.5 * OWP [ i ] + 0.25 * OOWP [ i ] ) ; } } return 0 ; }
>>>Func
METHOD run_test
METHOD_RETURN void
PARAM int test
init init ( )
<operator>.assignment conversions = 0
scanf scanf ( "\x25\x64\x0" , & conversions )
getchar getchar ( )
<operator>.assignment oppose = 0
scanf scanf ( "%d" , & oppose )
getchar getchar ( )
<operator>.assignment oppose_rule_count = oppose
<operator>.assignment input_size = 0
scanf scanf ( "%d" , & input_size )
getchar getchar ( )
printf printf ( "Case #%d: [" , test )
<operator>.lessThan i < conversions
<operator>.preIncrement ++ i
<operator>.lessThan i < oppose
<operator>.preIncrement ++ i
<operator>.greaterThan input_size > 0
<operator>.equals stack_cur == 0
<operator>.assignment i = 0
<operator>.assignment base_first = getchar ( )
<operator>.assignment base_second = getchar ( )
<operator>.assignment elm_third = getchar ( )
getchar getchar ( )
<operator>.assignment base_first = base_to_idx ( base_first )
<operator>.assignment base_second = base_to_idx ( base_second )
<operator>.assignment convert_rules [ base_first ] [ base_second ] = elm_third
<operator>.assignment convert_rules [ base_second ] [ base_first ] = elm_third
<operator>.assignment i = 0
<operator>.assignment base_first = getchar ( )
<operator>.assignment base_second = getchar ( )
getchar getchar ( )
<operator>.assignment base_first = base_to_idx ( base_first )
<operator>.assignment base_second = base_to_idx ( base_second )
<operator>.assignment oppose_rules [ i ] = ( 0x01 << base_first ) | ( 0x01 << base_second )
<operator>.assignment input = getchar ( )
<operator>.assignment stack [ stack_cur ] = input
<operator>.preIncrement ++ stack_cur
<operator>.preDecrement -- input_size
<operator>.assignment base_first = base_to_idx ( input )
<operator>.preIncrement ++ contains [ base_first ]
printf printf ( "]\n" )
<operator>.greaterThan stack_cur > 1
printf printf ( "%c" , stack [ 0 ] )
printf printf ( "]\n" )
base_to_idx base_to_idx ( base_first )
base_to_idx base_to_idx ( base_second )
base_to_idx base_to_idx ( base_first )
base_to_idx base_to_idx ( base_second )
<operator>.or ( 0x01 << base_first ) | ( 0x01 << base_second )
base_to_idx base_to_idx ( input )
<operator>.assignment base_second = base_to_idx ( stack [ stack_cur - 2 ] )
<operator>.assignment stack_bitmask = contain_bitmask ( )
<operator>.lessThan i < stack_cur
<operator>.preIncrement ++ i
printf printf ( ", %c" , stack [ i ] )
<operator>.shiftLeft 0x01 << base_first
<operator>.shiftLeft 0x01 << base_second
<operator>.logicalAnd base_first != - 1 && base_second != - 1
<operator>.lessThan i < oppose_rule_count
<operator>.preIncrement ++ i
<operator>.assignment i = 1
base_to_idx base_to_idx ( stack [ stack_cur - 2 ] )
<operator>.assignment i = 0
<operator>.notEquals base_first != - 1
<operator>.notEquals base_second != - 1
<operator>.notEquals convert_rules [ base_first ] [ base_second ] != 0
<operator>.equals ( oppose_rules [ i ] & stack_bitmask ) == oppose_rules [ i ]
<operator>.subtraction stack_cur - 2
<operator>.minus - 1
<operator>.minus - 1
<operator>.preDecrement -- contains [ base_first ]
<operator>.preDecrement -- contains [ base_second ]
<operator>.preDecrement -- stack_cur
<operator>.assignment stack [ stack_cur - 1 ] = convert_rules [ base_first ] [ base_second ]
<operator>.assignment stack_cur = 0
<operator>.assignment l = 0
<operator>.and oppose_rules [ i ] & stack_bitmask
<operator>.lessThan l < 8
<operator>.preIncrement ++ l
<operator>.assignment contains [ l ] = 0
<operator>.assignment l = 0
<operator>.subtraction stack_cur - 1
getchar getchar ( )
getchar getchar ( )
getchar getchar ( )
<operator>.indirectIndexAccess convert_rules [ base_first ] [ base_second ]
<operator>.indirectIndexAccess convert_rules [ base_second ] [ base_first ]
getchar getchar ( )
getchar getchar ( )
<operator>.indirectIndexAccess oppose_rules [ i ]
getchar getchar ( )
<operator>.indirectIndexAccess stack [ stack_cur ]
<operator>.indirectIndexAccess contains [ base_first ]
<operator>.indirectIndexAccess convert_rules [ base_first ]
<operator>.indirectIndexAccess convert_rules [ base_second ]
<operator>.indirectIndexAccess stack [ 0 ]
contain_bitmask contain_bitmask ( )
<operator>.indirectIndexAccess stack [ i ]
<operator>.indirectIndexAccess stack [ stack_cur - 2 ]
<operator>.indirectIndexAccess convert_rules [ base_first ] [ base_second ]
<operator>.indirectIndexAccess oppose_rules [ i ]
<operator>.indirectIndexAccess convert_rules [ base_first ]
<operator>.indirectIndexAccess contains [ base_first ]
<operator>.indirectIndexAccess contains [ base_second ]
<operator>.indirectIndexAccess stack [ stack_cur - 1 ]
<operator>.indirectIndexAccess convert_rules [ base_first ] [ base_second ]
<operator>.indirectIndexAccess oppose_rules [ i ]
<operator>.indirectIndexAccess convert_rules [ base_first ]
<operator>.indirectIndexAccess contains [ l ]
>>>PDG&112 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->28 0->29 0->30 0->31 0->32 0->33 0->37 0->38 0->39 0->40 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->52 0->54 0->55 0->56 0->57 0->58 0->59 0->61 0->62 0->63 0->65 0->66 0->67 0->68 0->70 0->71 0->72 0->75 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 2->14 3->1 4->1 4->5 4->15 5->1 5->15 7->1 7->8 7->17 8->1 8->10 8->17 10->1 10->1 10->1 10->61 11->1 11->12 11->19 12->1 12->19 12->40 13->1 14->1 14->1 15->1 15->1 15->15 15->16 15->16 15->22 15->23 15->24 15->25 15->26 15->27 15->28 15->29 15->47 15->48 15->85 15->86 15->87 15->88 15->89 15->96 15->97 16->1 16->15 17->1 17->1 17->10 17->17 17->18 17->18 17->31 17->32 17->33 17->34 17->35 17->36 17->49 17->50 17->51 17->58 17->59 17->90 17->91 17->92 18->1 18->17 19->1 19->1 19->19 19->37 19->38 19->39 19->40 19->40 19->41 19->42 19->44 19->52 19->93 19->94 19->95 20->1 20->1 20->43 20->45 20->46 20->55 20->55 20->63 20->98 21->15 22->1 22->47 23->1 23->48 24->1 24->28 24->29 26->1 26->1 26->1 27->1 27->1 27->1 28->1 28->1 28->68 29->1 29->1 29->1 30->1 30->17 31->1 31->49 32->1 32->50 34->1 34->1 34->58 35->1 35->1 35->59 36->1 36->1 36->1 36->79 37->1 37->1 37->38 37->52 38->1 38->1 39->1 39->44 40->1 40->19 41->1 41->1 41->1 41->66 42->1 42->1 42->73 43->1 44->1 44->20 44->39 44->53 44->54 44->60 44->61 44->64 44->65 44->66 44->70 44->70 44->71 44->99 44->101 47->26 48->27 49->34 50->35 51->1 51->1 51->36 51->36 52->1 52->41 53->1 53->1 53->1 53->67 54->1 54->1 54->1 54->79 55->55 55->56 55->56 55->57 55->100 56->55 58->1 58->51 58->51 59->1 59->51 59->51 60->1 60->1 60->1 60->68 60->102 60->104 61->1 61->1 61->1 61->61 61->62 61->62 61->69 61->79 61->103 61->109 62->1 62->61 63->55 64->1 64->53 65->1 65->61 66->1 66->1 66->60 66->60 66->67 66->72 67->1 67->1 67->60 67->60 68->1 68->1 68->73 68->74 68->75 68->76 68->76 68->84 68->105 68->106 68->107 68->108 68->110 69->1 69->1 69->1 69->77 69->78 69->79 69->80 69->83 70->20 70->39 70->75 71->66 72->67 73->1 73->1 73->42 74->1 74->1 75->1 75->84 76->1 76->1 76->1 77->1 77->20 77->39 79->1 79->69 79->69 80->1 80->1 80->80 80->81 80->81 80->82 80->111 81->1 81->80 82->1 82->1 83->1 83->80 84->20 84->39
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  void run_test ( int test ) { init ( ) ; int conversions = 0 ; scanf ( "\x25\x64\x0" , & conversions ) ; getchar ( ) ; char base_first , base_second , elm_third ; int i ; for ( i = 0 ; i < conversions ; ++ i ) { base_first = getchar ( ) ; base_second = getchar ( ) ; elm_third = getchar ( ) ; getchar ( ) ; base_first = base_to_idx ( base_first ) ; base_second = base_to_idx ( base_second ) ; convert_rules [ base_first ] [ base_second ] = elm_third ; convert_rules [ base_second ] [ base_first ] = elm_third ; } int oppose = 0 ; scanf ( "%d" , & oppose ) ; getchar ( ) ; for ( i = 0 ; i < oppose ; ++ i ) { base_first = getchar ( ) ; base_second = getchar ( ) ; getchar ( ) ; base_first = base_to_idx ( base_first ) ; base_second = base_to_idx ( base_second ) ; oppose_rules [ i ] = ( 0x01 << base_first ) | ( 0x01 << base_second ) ; } oppose_rule_count = oppose ; int input_size = 0 ; scanf ( "%d" , & input_size ) ; getchar ( ) ; char input ; int stack_bitmask ; while ( input_size > 0 ) { input = getchar ( ) ; stack [ stack_cur ] = input ; ++ stack_cur ; -- input_size ; base_first = base_to_idx ( input ) ; ++ contains [ base_first ] ; if ( stack_cur > 1 ) { base_second = base_to_idx ( stack [ stack_cur - 2 ] ) ; if ( base_first != - 1 && base_second != - 1 ) { if ( convert_rules [ base_first ] [ base_second ] != 0 ) { -- contains [ base_first ] ; -- contains [ base_second ] ; -- stack_cur ; stack [ stack_cur - 1 ] = convert_rules [ base_first ] [ base_second ] ; } } stack_bitmask = contain_bitmask ( ) ; for ( i = 0 ; i < oppose_rule_count ; ++ i ) { if ( ( oppose_rules [ i ] & stack_bitmask ) == oppose_rules [ i ] ) { stack_cur = 0 ; int l = 0 ; for ( l = 0 ; l < 8 ; ++ l ) contains [ l ] = 0 ; } } } } printf ( "Case #%d: [" , test ) ; if ( stack_cur == 0 ) printf ( "]\n" ) ; else { printf ( "%c" , stack [ 0 ] ) ; for ( i = 1 ; i < stack_cur ; ++ i ) printf ( ", %c" , stack [ i ] ) ; printf ( "]\n" ) ; } }
>>>Func
METHOD team_rpi
METHOD_RETURN void
PARAM char grid [ 100 ] [ 101 ]
PARAM int n
PARAM int team
<operator>.assignment wp = calc_wp ( grid , n , team , - 1 )
<operator>.assignment owp = calc_owp ( grid , n , team , - 1 )
<operator>.assignment oowp_total = 0
<operator>.assignment opponents = 0
<operator>.assignment oowp = oowp_total / opponents
printf printf ( "\x25\x66\x20\x0" , 0.25 * wp + 0.5 * owp + 0.25 * oowp )
<operator>.notEquals i != n
<operator>.preIncrement ++ i
calc_wp calc_wp ( grid , n , team , - 1 )
calc_owp calc_owp ( grid , n , team , - 1 )
<operator>.assignment i = 0
<operator>.division oowp_total / opponents
<operator>.addition 0.25 * wp + 0.5 * owp + 0.25 * oowp
<operator>.minus - 1
<operator>.minus - 1
<operator>.notEquals grid [ team ] [ i ] != '.'
<operator>.addition 0.25 * wp + 0.5 * owp
<operator>.multiplication 0.25 * oowp
<operator>.assignmentPlus oowp_total += calc_owp ( grid , n , i , - 1 )
<operator>.preIncrement ++ opponents
<operator>.multiplication 0.25 * wp
<operator>.multiplication 0.5 * owp
calc_owp calc_owp ( grid , n , i , - 1 )
<operator>.minus - 1
<operator>.indirectIndexAccess grid [ team ] [ i ]
<operator>.indirectIndexAccess grid [ team ]
>>>PDG&31 0->2 0->3 0->4 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 2->13 3->13 4->13 5->1 5->1 5->25 6->1 6->1 6->26 7->1 7->16 7->23 8->1 8->16 8->24 9->1 9->1 9->22 10->1 10->1 11->1 11->1 11->1 11->11 11->12 11->12 11->20 11->27 11->27 11->29 11->30 12->1 12->11 13->5 13->5 13->5 13->5 13->14 13->14 13->14 14->1 14->1 14->1 14->6 14->6 14->6 14->6 14->11 14->27 15->1 15->11 16->1 16->1 16->9 16->9 17->1 17->1 18->13 19->14 20->1 20->1 20->23 20->24 20->27 20->28 21->1 21->1 22->1 22->10 22->10 22->17 22->17 23->1 23->1 23->16 24->1 24->16 25->1 25->10 25->10 25->17 25->17 25->21 25->21 26->1 26->10 26->10 26->17 26->17 26->21 26->21 27->1 27->1 27->11 27->12 27->23 27->23 27->23 27->23 28->27
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void team_rpi ( char grid [ 100 ] [ 101 ] , int n , int team ) { double wp = calc_wp ( grid , n , team , - 1 ) ; double owp = calc_owp ( grid , n , team , - 1 ) ; double oowp_total = 0 ; int opponents = 0 ; for ( int i = 0 ; i != n ; ++ i ) { if ( grid [ team ] [ i ] != '.' ) { oowp_total += calc_owp ( grid , n , i , - 1 ) ; ++ opponents ; } } double oowp = oowp_total / opponents ; printf ( "\x25\x66\x20\x0" , 0.25 * wp + 0.5 * owp + 0.25 * oowp ) ; }
>>>Func
METHOD fill
METHOD_RETURN void
PARAM int m
<operator>.postDecrement end --
<operator>.lessEqualsThan i <= end - 1
<operator>.postIncrement i ++
<operator>.assignment i = m
<operator>.assignment list [ i ] = list [ i + 1 ]
<operator>.subtraction end - 1
<operator>.addition i + 1
<operator>.indirectIndexAccess list [ i ]
<operator>.indirectIndexAccess list [ i + 1 ]
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->8 0->9 2->6 3->1 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->7 4->8 4->9 4->9 4->10 4->11 5->1 5->4 6->1 6->1 6->4 7->1 7->1 7->1 8->3 8->4 8->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void fill ( int m ) { int i ; for ( i = m ; i <= end - 1 ; i ++ ) { list [ i ] = list [ i + 1 ] ; } end -- ; }
>>>Func
METHOD get_info
METHOD_RETURN info
PARAM point p
<operator>.assignment f . row = p . x / 2
<operator>.assignment f . col = p . y / 2
<operator>.assignment f . sn = p . x % 2
<operator>.assignment f . ew = p . y % 2
RETURN return f ; return f ;
IDENTIFIER f return f ;
<operator>.division p . x / 2
<operator>.division p . y / 2
<operator>.modulo p . x % 2
<operator>.modulo p . y % 2
>>>PDG&13 0->2 0->8 0->9 0->10 0->11 0->12 2->1 2->9 2->10 2->11 2->12 3->1 3->1 3->1 3->8 4->1 4->1 4->1 4->8 5->1 5->1 5->1 5->8 6->1 6->1 6->1 6->8 7->1 8->7 9->3 9->3 9->11 10->4 10->4 10->12 11->1 11->5 11->5 12->1 12->6 12->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) info get_info ( point p ) { info f ; f . row = p . x / 2 ; f . col = p . y / 2 ; f . sn = p . x % 2 ; f . ew = p . y % 2 ; return f ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment c = 0
<operator>.assignment m = ( int ) argv [ argc - 1 ] [ 0 ]
<operator>.expressionList l = 0   u = argc - 2
RETURN return 0 ; return 0 ;
<operator>.lessThan argc < 12
<operator>.lessThan i < argc - 1
<operator>.postIncrement i ++
<operator>.lessEqualsThan l <= u
<operator>.equals c == 0
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
<operator>.assignment i = 1
<operator>.assignment a [ i - 1 ] = argv [ i ] [ 0 ]
<operator>.assignment l = 0
<operator>.assignment u = argc - 2
<operator>.assignment mid = ( l + u ) / 2
printf printf ( "\x54\x68\x65\x20\x6e\x75\x6d\x62\x65\x72\x20\x69\x73\x20\x6e\x6f\x74\x20\x66\x6f\x75\x6e\x64\x2e\x5c\x6e\x0" )
LITERAL 1 return 1 ;
<operator>.subtraction argc - 1
<operator>.subtraction argc - 2
<operator>.equals m == a [ mid ]
printf printf ( "The number is found.\n" )
<operator>.division ( l + u ) / 2
<operator>.assignment c = 1
<operator>.subtraction i - 1
<operator>.subtraction argc - 1
<operator>.addition l + u
<operator>.lessThan m < a [ mid ]
<operator>.assignment u = mid - 1
<operator>.assignment l = mid + 1
<operator>.subtraction mid - 1
<operator>.addition mid + 1
<operator>.cast ( int ) argv [ argc - 1 ] [ 0 ]
UNKNOWN int int
<operator>.indirectIndexAccess argv [ argc - 1 ] [ 0 ]
<operator>.indirectIndexAccess a [ i - 1 ]
<operator>.indirectIndexAccess argv [ i ] [ 0 ]
<operator>.indirectIndexAccess argv [ argc - 1 ]
<operator>.indirectIndexAccess argv [ i ]
<operator>.indirectIndexAccess a [ mid ]
<operator>.indirectIndexAccess a [ mid ]
>>>PDG&45 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->34 0->35 2->8 3->1 4->12 5->24 7->1 8->1 8->1 8->4 8->5 8->6 8->7 8->9 8->11 8->12 8->14 8->15 8->17 8->18 8->22 8->22 8->23 8->29 8->36 8->37 8->38 8->41 9->9 9->10 9->16 9->22 9->28 9->28 9->39 9->40 9->42 10->9 11->19 11->24 11->26 11->26 11->26 11->30 11->30 11->30 11->43 12->20 12->25 13->7 14->1 15->9 17->6 17->11 18->6 18->11 19->33 19->34 19->35 21->14 22->9 22->9 22->29 23->6 23->6 23->18 23->18 24->11 24->27 24->31 24->31 24->31 24->44 26->19 26->19 27->12 28->10 29->23 31->24 31->24 31->32 31->33 31->34 31->35 32->11 33->11 34->32 34->32
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * argv [ ] ) { if ( argc < 12 ) return 1 ; int a [ 10 ] , i , m , c = 0 , l , u , mid ; for ( i = 1 ; i < argc - 1 ; i ++ ) { a [ i - 1 ] = argv [ i ] [ 0 ] ; } m = ( int ) argv [ argc - 1 ] [ 0 ] ; l = 0 , u = argc - 2 ; while ( l <= u ) { mid = ( l + u ) / 2 ; if ( m == a [ mid ] ) { c = 1 ; break ; } else if ( m < a [ mid ] ) { u = mid - 1 ; } else l = mid + 1 ; } if ( c == 0 ) printf ( "\x54\x68\x65\x20\x6e\x75\x6d\x62\x65\x72\x20\x69\x73\x20\x6e\x6f\x74\x20\x66\x6f\x75\x6e\x64\x2e\x5c\x6e\x0" ) ; else printf ( "The number is found.\n" ) ; return 0 ; }
>>>Func
METHOD arraylist_sort_internal
METHOD_RETURN void
PARAM ArrayListValue * list_data
PARAM unsigned int list_length
PARAM ArrayListCompareFunc compare_func
<operator>.assignment pivot = list_data [ list_length - 1 ]
<operator>.assignment list1_length = 0
<operator>.assignment list2_length = list_length - list1_length - 1
<operator>.assignment list_data [ list_length - 1 ] = list_data [ list1_length ]
<operator>.assignment list_data [ list1_length ] = pivot
arraylist_sort_internal arraylist_sort_internal ( list_data , list1_length , compare_func )
arraylist_sort_internal arraylist_sort_internal ( & list_data [ list1_length + 1 ] , list2_length , compare_func )
<operator>.lessEqualsThan list_length <= 1
<operator>.lessThan i < list_length - 1
<operator>.preIncrement ++ i
RETURN return ; return ;
<operator>.assignment i = 0
<operator>.subtraction list_length - list1_length - 1
<operator>.subtraction list_length - 1
<operator>.subtraction list_length - 1
<operator>.lessThan compare_func ( list_data [ i ] , pivot ) < 0
<operator>.subtraction list_length - list1_length
<operator>.subtraction list_length - 1
<operator>.assignment tmp = list_data [ i ]
<operator>.assignment list_data [ i ] = list_data [ list1_length ]
<operator>.assignment list_data [ list1_length ] = tmp
<operator>.preIncrement ++ list1_length
<operator>.addition list1_length + 1
compare_func compare_func ( list_data [ i ] , pivot )
<operator>.indirectIndexAccess list_data [ list_length - 1 ]
<operator>.indirectIndexAccess list_data [ list_length - 1 ]
<operator>.indirectIndexAccess list_data [ list1_length ]
<operator>.indirectIndexAccess list_data [ list1_length ]
<operator>.addressOf & list_data [ list1_length + 1 ]
<operator>.indirectIndexAccess list_data [ list1_length + 1 ]
<operator>.indirectIndexAccess list_data [ i ]
<operator>.indirectIndexAccess list_data [ i ]
<operator>.indirectIndexAccess list_data [ i ]
<operator>.indirectIndexAccess list_data [ list1_length ]
<operator>.indirectIndexAccess list_data [ list1_length ]
>>>PDG&40 0->2 0->3 0->4 0->6 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->25 0->26 0->27 0->28 2->1 2->5 2->8 2->10 2->23 2->24 2->28 3->12 4->1 4->10 5->9 5->28 6->21 6->26 7->11 8->10 9->10 10->11 10->11 10->27 12->1 12->1 12->5 12->6 12->7 12->8 12->9 12->10 12->11 12->13 12->15 12->16 12->17 12->18 12->18 12->19 12->21 12->22 12->27 12->29 12->30 12->31 12->32 12->33 12->34 13->13 13->14 13->14 13->19 13->20 13->28 13->35 14->13 15->1 16->13 17->7 17->7 18->19 19->13 19->13 19->21 20->23 20->24 20->25 20->26 20->36 20->37 20->38 20->39 21->10 21->17 21->17 21->22 23->25 24->10 24->28 25->8 25->24 26->21 28->9 28->10 28->20 28->20 28->23
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static void arraylist_sort_internal ( ArrayListValue * list_data , unsigned int list_length , ArrayListCompareFunc compare_func ) { ArrayListValue pivot ; ArrayListValue tmp ; unsigned int i ; unsigned int list1_length ; unsigned int list2_length ; if ( list_length <= 1 ) { return ; } pivot = list_data [ list_length - 1 ] ; list1_length = 0 ; for ( i = 0 ; i < list_length - 1 ; ++ i ) { if ( compare_func ( list_data [ i ] , pivot ) < 0 ) { tmp = list_data [ i ] ; list_data [ i ] = list_data [ list1_length ] ; list_data [ list1_length ] = tmp ; ++ list1_length ; } else { } } list2_length = list_length - list1_length - 1 ; list_data [ list_length - 1 ] = list_data [ list1_length ] ; list_data [ list1_length ] = pivot ; arraylist_sort_internal ( list_data , list1_length , compare_func ) ; arraylist_sort_internal ( & list_data [ list1_length + 1 ] , list2_length , compare_func ) ; }
>>>Func
METHOD create_list_of_elements_t
METHOD_RETURN struct list_of_elements_t
<operator>.assignment * new_list = malloc ( sizeof ( struct list_of_elements_t ) )
<operator>.assignment new_list -> head = NULL
<operator>.assignment new_list -> tail = NULL
<operator>.assignment new_list -> penultimate = NULL
<operator>.assignment new_list -> last_base = NULL
<operator>.assignment new_list -> append = ( * private_list_of_elements_t_append )
<operator>.assignment new_list -> found_opposition = ( * private_list_of_elements_t_found_opposition )
<operator>.assignment new_list -> empty = ( * private_list_of_elements_t_empty )
<operator>.assignment new_list -> output_csv = ( * private_list_of_elements_t_output_csv )
RETURN return new_list ; return new_list ;
<operator>.lessEqualsThan ii <= NUM_BASES
<operator>.postIncrement ii ++
IDENTIFIER new_list return new_list ;
<operator>.assignment ii = 1
<operator>.assignment new_list -> base_count [ ii - 1 ] = 0
<operator>.sizeOf sizeof ( struct list_of_elements_t )
<operator>.subtraction ii - 1
<operator>.indirectIndexAccess new_list -> base_count [ ii - 1 ]
<operator>.indirectFieldAccess new_list -> base_count
FIELD_IDENTIFIER base_count base_count
>>>PDG&22 0->3 0->4 0->5 0->6 0->12 0->13 0->14 0->15 0->16 0->18 2->1 2->1 2->1 2->14 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 6->1 7->1 7->1 7->1 8->1 8->1 8->1 9->1 9->1 9->1 10->1 10->1 10->1 11->1 12->1 12->1 12->1 12->12 12->13 12->16 12->18 12->18 12->19 12->20 12->21 13->1 13->12 14->11 15->1 15->12 16->1 16->1 17->1 18->13
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static struct list_of_elements_t * create_list_of_elements_t ( ) { struct list_of_elements_t * new_list = malloc ( sizeof ( struct list_of_elements_t ) ) ; for ( uintmax_t ii = 1 ; ii <= NUM_BASES ; ii ++ ) { new_list -> base_count [ ii - 1 ] = 0 ; } new_list -> head = NULL ; new_list -> tail = NULL ; new_list -> penultimate = NULL ; new_list -> last_base = NULL ; new_list -> append = ( * private_list_of_elements_t_append ) ; new_list -> found_opposition = ( * private_list_of_elements_t_found_opposition ) ; new_list -> empty = ( * private_list_of_elements_t_empty ) ; new_list -> output_csv = ( * private_list_of_elements_t_output_csv ) ; return new_list ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment a = 1
scanf scanf ( "\x25\x64\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan a <= t
LITERAL 0 return 0 ;
printf printf ( "Case #%d: " , a )
<operator>.assignment time = 0
<operator>.assignment j = 0
<operator>.assignment temp = 0
<operator>.assignment total = 0
<operator>.assignment flag = 0
scanf scanf ( "%lld%lld%lld%lld" , & l , & t , & n , & c )
printf printf ( "%lld\n" , total + t )
<operator>.postIncrement a ++
<operator>.lessThan i < c
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
<operator>.lessThan i < mark + 1 + l
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
<operator>.assignment i = 0
scanf scanf ( "%lld" , & arr [ i ] )
<operator>.assignment i = 0
<operator>.assignment time = time + arr [ j ] * 2
<operator>.postIncrement j ++
<operator>.assignment i = mark + 1
<operator>.assignment i = mark + 1
<operator>.assignment total = total + star [ i ]
<operator>.assignment total = total + star [ i ] * 2
<operator>.addition total + t
<operator>.equals j == c
<operator>.logicalAnd time >= t && flag == 0
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.addition mark + 1 + l
<operator>.assignment j = 0
<operator>.addition time + arr [ j ] * 2
<operator>.assignment flag = 1
<operator>.assignment star [ i ] = arr [ j ] - ( time - t ) / 2
<operator>.assignment star [ n ] = arr [ j ] - star [ i ]
<operator>.assignment mark = i
<operator>.addition mark + 1
<operator>.assignment j = mark + 1
<operator>.addition mark + 1
<operator>.addition mark + 1
<operator>.addition total + star [ i ]
<operator>.addition total + star [ i ] * 2
<operator>.multiplication arr [ j ] * 2
<operator>.greaterEqualsThan time >= t
<operator>.equals flag == 0
<operator>.assignment star [ i ] = arr [ j ]
<operator>.lessThan star [ j ] < star [ j + 1 ]
<operator>.multiplication star [ i ] * 2
<operator>.subtraction arr [ j ] - ( time - t ) / 2
<operator>.subtraction arr [ j ] - star [ i ]
<operator>.addition mark + 1
<operator>.assignment temp = star [ j ]
<operator>.assignment star [ j ] = star [ j + 1 ]
<operator>.assignment star [ j + 1 ] = temp
<operator>.division ( time - t ) / 2
<operator>.subtraction time - t
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.addition j + 1
<operator>.addressOf & l
<operator>.addressOf & t
<operator>.addressOf & n
<operator>.addressOf & c
<operator>.addressOf & arr [ i ]
<operator>.indirectIndexAccess arr [ i ]
<operator>.indirectIndexAccess star [ i ]
<operator>.indirectIndexAccess arr [ j ]
<operator>.indirectIndexAccess star [ i ]
<operator>.indirectIndexAccess star [ n ]
<operator>.indirectIndexAccess star [ i ]
<operator>.indirectIndexAccess arr [ j ]
<operator>.indirectIndexAccess arr [ j ]
<operator>.indirectIndexAccess star [ i ]
<operator>.indirectIndexAccess star [ i ]
<operator>.indirectIndexAccess arr [ j ]
<operator>.indirectIndexAccess star [ j ]
<operator>.indirectIndexAccess star [ j + 1 ]
<operator>.indirectIndexAccess star [ j ]
<operator>.indirectIndexAccess star [ j ]
<operator>.indirectIndexAccess star [ j + 1 ]
<operator>.indirectIndexAccess star [ j + 1 ]
>>>PDG&92 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->43 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->58 0->61 0->64 0->65 0->66 0->67 0->68 0->69 2->1 2->5 3->1 3->5 3->14 3->35 3->54 4->1 5->1 5->1 5->1 5->5 5->7 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->14 5->15 5->16 5->18 5->20 5->22 5->24 5->26 5->28 5->31 5->32 5->35 5->35 5->40 5->47 5->49 5->50 5->54 5->70 5->71 5->72 5->73 6->4 7->1 7->15 8->1 8->1 8->29 8->42 9->1 9->1 9->36 10->1 10->1 11->1 11->14 11->33 11->34 11->35 11->51 11->52 12->1 12->1 12->55 13->1 13->1 13->1 13->1 13->22 13->40 14->1 14->1 15->1 15->5 16->1 16->1 16->16 16->17 16->17 16->27 16->36 16->74 16->75 17->1 17->16 18->1 18->18 18->19 18->19 18->20 18->29 18->30 18->36 18->37 18->42 18->46 18->53 18->54 18->77 19->1 19->18 20->20 20->21 20->21 20->24 20->38 20->38 20->48 20->61 21->1 21->20 22->1 22->1 22->22 22->23 22->23 22->24 22->33 22->40 22->50 22->51 22->76 23->1 23->22 24->1 24->1 24->1 24->18 24->24 24->25 24->25 24->34 24->52 24->58 24->80 25->1 25->24 26->16 27->1 28->1 28->18 29->1 29->1 29->54 30->1 30->1 30->36 31->20 32->1 32->22 33->1 33->1 33->14 33->34 33->35 33->51 33->52 34->1 34->1 34->14 34->35 34->52 35->1 36->1 36->1 36->16 36->30 36->41 37->1 37->1 37->1 37->43 37->44 37->45 37->46 37->56 37->59 37->60 37->65 37->66 37->78 37->79 37->81 37->82 37->83 37->84 37->85 38->1 38->1 38->20 38->38 38->39 38->39 38->57 38->67 38->67 38->68 38->69 38->86 38->87 39->1 39->38 40->1 40->1 41->1 41->30 42->1 43->1 43->1 43->55 44->1 44->1 44->60 45->1 45->1 45->1 46->1 46->31 46->47 48->1 48->38 50->1 51->1 52->1 53->29 53->29 53->42 53->42 53->56 53->59 54->1 54->5 54->14 54->29 54->35 54->37 54->37 54->42 54->55 54->66 54->66 55->1 55->37 55->37 56->1 56->1 56->1 56->33 56->51 56->58 57->1 57->1 57->1 57->62 57->62 57->63 57->63 57->64 57->68 57->69 57->88 57->89 57->90 57->91 58->1 58->33 58->34 58->34 58->51 58->52 58->52 59->1 59->44 59->44 59->60 60->1 60->1 60->33 60->45 60->45 60->51 60->53 60->58 62->1 62->64 63->1 63->1 63->57 64->1 64->1 64->1 64->57 65->1 65->59 65->59 66->1 66->5 66->14 66->29 66->35 66->42 66->54 66->65 66->65
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int t , a = 1 ; scanf ( "\x25\x64\x0" , & t ) ; while ( a <= t ) { printf ( "Case #%d: " , a ) ; long long int l , t , n , c , time = 0 , i , j = 0 , mark , temp = 0 , total = 0 ; int flag = 0 ; scanf ( "%lld%lld%lld%lld" , & l , & t , & n , & c ) ; long long int arr [ c ] , star [ n + 2 ] ; for ( i = 0 ; i < c ; i ++ ) { scanf ( "%lld" , & arr [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { if ( j == c ) { j = 0 ; } time = time + arr [ j ] * 2 ; if ( time >= t && flag == 0 ) { flag = 1 ; star [ i ] = arr [ j ] - ( time - t ) / 2 ; star [ n ] = arr [ j ] - star [ i ] ; mark = i ; } else { star [ i ] = arr [ j ] ; } j ++ ; } for ( i = mark + 1 ; i <= n ; i ++ ) { for ( j = mark + 1 ; j < n ; j ++ ) { if ( star [ j ] < star [ j + 1 ] ) { temp = star [ j ] ; star [ j ] = star [ j + 1 ] ; star [ j + 1 ] = temp ; } } } for ( i = mark + 1 ; i < mark + 1 + l ; i ++ ) { total = total + star [ i ] ; } for ( ; i <= n ; i ++ ) { total = total + star [ i ] * 2 ; } printf ( "%lld\n" , total + t ) ; a ++ ; } return 0 ; }
>>>Func
METHOD size
METHOD_RETURN int
PARAM Heap * heap
RETURN return heap -> count ; return heap -> count ;
>>>PDG&4 0->2 0->3 2->1 3->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int size ( Heap * heap ) { return heap -> count ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
scanf scanf ( "\x25\x64\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
scanf scanf ( "%d" , & n )
printf printf ( "Case #%d:\n" , i )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
printf printf ( "%.8g\n"   ( 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ] ) )
<operator>.assignment j = 0
<operator>.assignment total [ j ] = 0
<operator>.assignment wap [ j ] = 0
scanf scanf ( "%s" , team [ j ] )
<operator>.assignment wp [ j ] = wap [ j ] / total [ j ]
<operator>.assignment j = 0
<operator>.assignment owp [ j ] = 0
<operator>.assignmentDivision owp [ j ] /= total [ j ]
<operator>.assignment j = 0
<operator>.assignment oowp [ j ] = 0
<operator>.assignmentDivision oowp [ j ] /= total [ j ]
<operator>.assignment j = 0
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.addition 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ]
<operator>.assignment k = 0
<operator>.division wap [ j ] / total [ j ]
<operator>.assignment k = 0
<operator>.assignment k = 0
<operator>.addition 0.25 * wp [ j ] + 0.5 * owp [ j ]
<operator>.multiplication 0.25 * oowp [ j ]
<operator>.equals k == j
<operator>.multiplication 0.25 * wp [ j ]
<operator>.multiplication 0.5 * owp [ j ]
LITERAL '.' <empty>
LITERAL '1' <empty>
<operator>.assignment wap [ j ] = wap [ j ] + 1
LITERAL '0' <empty>
<operator>.assignment total [ j ] = total [ j ] + 1
LITERAL '.' <empty>
LITERAL '1' <empty>
<operator>.assignmentPlus owp [ j ] += ( wap [ k ] - 1 ) / ( total [ k ] - 1 )
LITERAL '0' <empty>
<operator>.assignmentPlus owp [ j ] += ( wap [ k ] ) / ( total [ k ] - 1 )
LITERAL '.' <empty>
LITERAL '1' <empty>
LITERAL '0' <empty>
<operator>.assignmentPlus oowp [ j ] += owp [ k ]
<operator>.addition wap [ j ] + 1
<operator>.addition total [ j ] + 1
<operator>.division ( wap [ k ] - 1 ) / ( total [ k ] - 1 )
<operator>.division ( wap [ k ] ) / ( total [ k ] - 1 )
<operator>.subtraction wap [ k ] - 1
<operator>.subtraction total [ k ] - 1
<operator>.subtraction total [ k ] - 1
<operator>.addressOf & n
<operator>.indirectIndexAccess total [ j ]
<operator>.indirectIndexAccess wap [ j ]
<operator>.indirectIndexAccess team [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess total [ j ]
<operator>.indirectIndexAccess oowp [ j ]
<operator>.indirectIndexAccess oowp [ j ]
<operator>.indirectIndexAccess total [ j ]
<operator>.indirectIndexAccess wap [ j ]
<operator>.indirectIndexAccess total [ j ]
<operator>.indirectIndexAccess oowp [ j ]
<operator>.indirectIndexAccess team [ j ] [ k ]
<operator>.indirectIndexAccess team [ k ] [ j ]
<operator>.indirectIndexAccess team [ j ] [ k ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess team [ j ]
<operator>.indirectIndexAccess team [ k ]
<operator>.indirectIndexAccess team [ j ]
<operator>.indirectIndexAccess wap [ j ]
<operator>.indirectIndexAccess total [ j ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess oowp [ j ]
<operator>.indirectIndexAccess owp [ k ]
<operator>.indirectIndexAccess wap [ j ]
<operator>.indirectIndexAccess total [ j ]
<operator>.indirectIndexAccess wap [ k ]
<operator>.indirectIndexAccess wap [ k ]
<operator>.indirectIndexAccess total [ k ]
<operator>.indirectIndexAccess total [ k ]
>>>PDG&104 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->26 0->27 0->29 0->30 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->42 0->43 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->57 0->59 0->60 0->61 0->63 0->64 0->67 0->68 0->69 2->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->11 6->12 6->14 6->16 6->18 6->21 6->26 6->29 6->32 6->70 7->1 7->6 8->5 9->1 9->6 10->1 10->12 10->14 10->16 10->18 10->33 10->35 10->37 11->1 11->7 12->12 12->13 12->13 12->14 12->22 12->23 12->24 12->25 12->33 12->33 12->40 12->41 12->71 12->72 12->73 12->74 12->81 12->82 13->1 13->12 14->14 14->15 14->15 14->16 14->27 14->28 14->35 14->35 14->42 14->46 14->75 14->76 14->77 15->1 15->14 16->16 16->17 16->17 16->18 16->30 16->31 16->37 16->37 16->43 16->78 16->79 16->80 17->1 17->16 18->1 18->1 18->1 18->10 18->12 18->18 18->19 18->19 18->20 18->39 18->44 18->45 18->47 18->48 18->83 18->87 18->88 19->1 19->18 20->1 20->1 21->12 22->1 22->41 22->53 22->64 23->1 23->41 23->51 23->63 24->1 25->1 25->1 25->1 25->47 26->14 27->1 27->28 27->56 27->58 28->1 28->1 28->1 28->48 29->16 30->1 30->31 30->62 31->1 31->1 31->1 31->45 32->1 32->18 33->1 33->1 33->12 33->33 33->34 33->34 33->84 33->89 34->1 34->33 35->1 35->1 35->14 35->35 35->36 35->46 35->46 36->1 36->35 37->1 37->1 37->16 37->37 37->38 37->38 37->86 37->91 38->1 38->37 39->1 39->1 40->1 40->33 41->1 41->1 41->25 41->25 41->28 41->31 42->1 42->35 43->1 43->37 44->1 44->1 45->1 45->20 45->20 45->39 45->39 46->1 46->15 46->36 46->85 46->90 47->1 47->20 47->20 47->39 47->39 47->44 47->44 48->1 48->20 48->20 48->39 48->39 48->44 48->44 51->1 51->1 51->41 51->63 53->1 53->1 53->41 53->64 56->1 56->1 56->28 56->58 58->1 58->1 58->28 58->56 62->1 62->1 62->31 65->1 65->1 65->56 65->56 66->1 66->1 66->58 66->58 66->67 67->1 67->65 67->65 67->66 68->1 68->65 68->65 68->69 69->1 69->66 69->66 69->68 84->51 84->53 84->63 84->64 84->92 84->93 84->98 84->99 85->56 85->58 85->65 85->66 85->67 85->68 85->69 85->94 85->95 85->100 85->101 85->102 85->103 86->62 86->96 86->97
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( int argc , char * * argv ) { int t , i ; int n , j , k , l ; char team [ 101 ] [ 101 ] ; int total [ 101 ] ; double wp [ 101 ] ; double wap [ 101 ] ; double owp [ 101 ] ; double oowp [ 101 ] ; scanf ( "\x25\x64\x0" , & t ) ; for ( i = 1 ; i <= t ; i ++ ) { scanf ( "%d" , & n ) ; for ( j = 0 ; j < n ; j ++ ) { total [ j ] = 0 ; wap [ j ] = 0 ; scanf ( "%s" , team [ j ] ) ; for ( k = 0 ; k < n ; k ++ ) { switch ( team [ j ] [ k ] ) { case '.' : break ; case '1' : wap [ j ] = wap [ j ] + 1 ; case '0' : total [ j ] = total [ j ] + 1 ; break ; } } wp [ j ] = wap [ j ] / total [ j ] ; } for ( j = 0 ; j < n ; j ++ ) { owp [ j ] = 0 ; for ( k = 0 ; k < n ; k ++ ) { if ( k == j ) continue ; switch ( team [ k ] [ j ] ) { case '.' : break ; case '1' : owp [ j ] += ( wap [ k ] - 1 ) / ( total [ k ] - 1 ) ; break ; case '0' : owp [ j ] += ( wap [ k ] ) / ( total [ k ] - 1 ) ; break ; } } owp [ j ] /= total [ j ] ; } for ( j = 0 ; j < n ; j ++ ) { oowp [ j ] = 0 ; for ( k = 0 ; k < n ; k ++ ) { switch ( team [ j ] [ k ] ) { case '.' : break ; case '1' : case '0' : oowp [ j ] += owp [ k ] ; break ; } } oowp [ j ] /= total [ j ] ; } printf ( "Case #%d:\n" , i ) ; for ( j = 0 ; j < n ; j ++ ) printf ( "%.8g\n" , ( 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ] ) ) ; } return 0 ; }
>>>Func
METHOD createGraph
METHOD_RETURN struct Graph
PARAM int vertices
<operator>.assignment * graph = malloc ( sizeof ( struct Graph ) )
<operator>.assignment graph -> numVertices = vertices
<operator>.assignment graph -> adjLists = malloc ( vertices * sizeof ( struct node * ) )
<operator>.assignment graph -> visited = malloc ( vertices * sizeof ( int ) )
RETURN return graph ; return graph ;
<operator>.lessThan i < vertices
<operator>.postIncrement i ++
IDENTIFIER graph return graph ;
malloc malloc ( vertices * sizeof ( struct node * ) )
malloc malloc ( vertices * sizeof ( int ) )
<operator>.assignment i = 0
<operator>.assignment graph -> adjLists [ i ] = NULL
<operator>.assignment graph -> visited [ i ] = 0
<operator>.sizeOf sizeof ( struct Graph )
<operator>.multiplication vertices * sizeof ( struct node * )
<operator>.multiplication vertices * sizeof ( int )
<operator>.sizeOf sizeof ( struct node * )
<operator>.sizeOf sizeof ( int )
<operator>.indirectIndexAccess graph -> adjLists [ i ]
<operator>.indirectIndexAccess graph -> visited [ i ]
<operator>.indirectFieldAccess graph -> adjLists
<operator>.indirectFieldAccess graph -> visited
FIELD_IDENTIFIER adjLists adjLists
FIELD_IDENTIFIER visited visited
>>>PDG&27 0->2 0->4 0->8 0->9 0->10 0->13 0->14 0->15 0->17 0->18 2->4 2->17 3->1 3->1 3->1 3->10 4->1 4->1 5->1 5->1 5->1 6->1 6->1 6->1 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->14 8->15 8->21 8->22 8->23 8->24 8->25 8->26 9->1 9->8 10->7 11->1 11->5 12->1 12->6 13->1 13->8 14->1 14->1 14->1 15->1 15->1 16->1 17->11 17->18 18->8 18->12 19->1 20->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) struct Graph * createGraph ( int vertices ) { struct Graph * graph = malloc ( sizeof ( struct Graph ) ) ; graph -> numVertices = vertices ; graph -> adjLists = malloc ( vertices * sizeof ( struct node * ) ) ; graph -> visited = malloc ( vertices * sizeof ( int ) ) ; int i ; for ( i = 0 ; i < vertices ; i ++ ) { graph -> adjLists [ i ] = NULL ; graph -> visited [ i ] = 0 ; } return graph ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
scanf scanf ( "\x25\x64\x20\x0" , & T )
<operator>.postIncrement T ++
RETURN return 0 ; return 0 ;
<operator>.lessThan k < T
<operator>.postIncrement k ++
LITERAL 0 return 0 ;
<operator>.assignment k = 1
scanf scanf ( "%d " , & C )
scanf scanf ( "%d " , & D )
scanf scanf ( "%d " , & N )
<operator>.assignment nList [ 0 ] = '\0'
printf printf ( "Case #%d: [" , k )
printf printf ( "]\n" )
<operator>.lessThan i < C
<operator>.postIncrement i ++
scanf scanf ( "%s"   ( char * ) cList [ i ] )
<operator>.lessThan i < D
<operator>.postIncrement i ++
scanf scanf ( "%s "   ( char * ) dList )
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < size
<operator>.postIncrement i ++
printf printf ( "%c%s"   nList [ i ]   ( i == size - 1 ? "" : ", " ) )
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.expressionList i = 0   size = 0
scanf scanf ( "%c " , & spell )
<operator>.postIncrement size ++
<operator>.assignment nList [ size - 1 ] = spell
<operator>.assignment nList [ size ] = '\0'
<operator>.assignment i = 0
<operator>.cast ( char * ) cList [ i ]
<operator>.cast ( char * ) dList
<operator>.logicalAnd j < C && size > 0
<operator>.postIncrement j ++
<operator>.logicalAnd j < D && size > 0
<operator>.postIncrement j ++
<operator>.conditional i == size - 1 ? "" : "  "
<operator>.assignment i = 0
<operator>.assignment size = 0
<operator>.assignment j = 0
<operator>.logicalOr ( spell == cList [ j ] [ 0 ] && nList [ size - 1 ] == cList [ j ] [ 1 ] ) || ( spell == cList [ j ] [ 1 ] && nList [ size - 1 ] == cList [ j ] [ 0 ] )
<operator>.assignment j = 0
<operator>.logicalOr ( spell == dList [ j ] [ 1 ] && strchr ( nList , dList [ j ] [ 0 ] ) != NULL ) || ( spell == dList [ j ] [ 0 ] && strchr ( nList , dList [ j ] [ 1 ] ) != NULL )
<operator>.equals i == size - 1
<operator>.lessThan j < C
<operator>.greaterThan size > 0
<operator>.assignment nList [ size - 1 ] = cList [ j ] [ 2 ]
<operator>.lessThan j < D
<operator>.greaterThan size > 0
<operator>.assignment size = 0
<operator>.assignment nList [ 0 ] = '\0'
<operator>.subtraction size - 1
<operator>.subtraction size - 1
<operator>.logicalAnd spell == cList [ j ] [ 0 ] && nList [ size - 1 ] == cList [ j ] [ 1 ]
<operator>.logicalAnd spell == cList [ j ] [ 1 ] && nList [ size - 1 ] == cList [ j ] [ 0 ]
<operator>.logicalAnd spell == dList [ j ] [ 1 ] && strchr ( nList , dList [ j ] [ 0 ] ) != NULL
<operator>.logicalAnd spell == dList [ j ] [ 0 ] && strchr ( nList , dList [ j ] [ 1 ] ) != NULL
<operator>.equals spell == cList [ j ] [ 0 ]
<operator>.equals nList [ size - 1 ] == cList [ j ] [ 1 ]
<operator>.equals spell == cList [ j ] [ 1 ]
<operator>.equals nList [ size - 1 ] == cList [ j ] [ 0 ]
<operator>.equals spell == dList [ j ] [ 1 ]
<operator>.notEquals strchr ( nList , dList [ j ] [ 0 ] ) != NULL
<operator>.equals spell == dList [ j ] [ 0 ]
<operator>.notEquals strchr ( nList , dList [ j ] [ 1 ] ) != NULL
<operator>.subtraction size - 1
strchr strchr ( nList , dList [ j ] [ 0 ] )
strchr strchr ( nList , dList [ j ] [ 1 ] )
<operator>.subtraction size - 1
<operator>.subtraction size - 1
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.indirectIndexAccess nList [ 0 ]
<operator>.indirectIndexAccess nList [ i ]
UNKNOWN char * char *
<operator>.indirectIndexAccess cList [ i ]
UNKNOWN char * char *
<operator>.addressOf & spell
<operator>.indirectIndexAccess nList [ size - 1 ]
<operator>.indirectIndexAccess nList [ size ]
<operator>.indirectIndexAccess nList [ size - 1 ]
<operator>.indirectIndexAccess cList [ j ] [ 2 ]
<operator>.indirectIndexAccess nList [ 0 ]
<operator>.indirectIndexAccess cList [ j ] [ 0 ]
<operator>.indirectIndexAccess nList [ size - 1 ]
<operator>.indirectIndexAccess cList [ j ] [ 1 ]
<operator>.indirectIndexAccess cList [ j ] [ 1 ]
<operator>.indirectIndexAccess nList [ size - 1 ]
<operator>.indirectIndexAccess cList [ j ] [ 0 ]
<operator>.indirectIndexAccess cList [ j ]
<operator>.indirectIndexAccess dList [ j ] [ 1 ]
<operator>.indirectIndexAccess dList [ j ] [ 0 ]
<operator>.indirectIndexAccess cList [ j ]
<operator>.indirectIndexAccess cList [ j ]
<operator>.indirectIndexAccess cList [ j ]
<operator>.indirectIndexAccess cList [ j ]
<operator>.indirectIndexAccess dList [ j ]
<operator>.indirectIndexAccess dList [ j ] [ 0 ]
<operator>.indirectIndexAccess dList [ j ]
<operator>.indirectIndexAccess dList [ j ] [ 1 ]
<operator>.indirectIndexAccess dList [ j ]
<operator>.indirectIndexAccess dList [ j ]
>>>PDG&108 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->36 0->38 0->40 0->41 0->42 0->43 0->44 0->46 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->56 0->57 0->62 0->64 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 2->1 3->1 3->4 3->6 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->12 6->13 6->14 6->14 6->15 6->16 6->19 6->22 6->24 6->27 6->28 6->29 6->34 6->42 6->43 6->75 6->76 6->77 6->78 7->1 7->6 8->5 9->1 9->6 10->1 10->16 10->49 11->1 11->19 11->52 12->1 12->22 13->1 13->1 13->71 13->72 14->1 14->7 15->1 16->1 16->1 16->10 16->16 16->17 16->17 16->18 16->35 16->49 16->80 16->81 17->1 17->16 18->1 19->1 19->1 19->11 19->19 19->20 19->20 19->21 19->36 19->52 19->82 20->1 20->19 21->1 22->1 22->1 22->12 22->22 22->23 22->23 22->30 22->37 22->44 22->49 22->83 23->1 23->22 24->1 24->1 24->1 24->24 24->25 24->26 24->41 24->48 24->48 24->57 24->57 24->79 25->1 25->24 26->1 26->1 26->1 26->71 26->72 27->16 28->19 29->1 29->1 30->1 30->32 30->62 30->64 30->66 30->68 31->1 31->56 32->1 32->1 32->1 32->63 32->65 32->71 32->72 33->1 33->1 33->71 33->72 34->1 34->24 35->1 36->1 37->1 37->1 37->1 37->39 37->39 37->45 37->46 37->52 37->58 37->62 37->89 37->98 38->1 38->49 39->1 39->1 39->1 39->31 39->32 39->33 39->37 39->47 39->56 39->60 39->66 39->84 39->85 39->96 39->102 40->1 40->52 41->1 42->22 42->29 43->24 43->29 43->31 43->50 43->53 43->70 43->73 43->74 44->1 44->49 45->1 45->1 45->1 45->37 45->38 45->49 45->51 45->70 45->86 45->87 45->95 46->1 46->52 47->1 47->1 47->1 47->39 47->40 47->52 47->54 47->55 47->88 48->1 48->25 49->1 49->1 49->10 49->16 49->37 49->37 49->38 49->50 50->31 50->37 50->37 50->53 50->70 50->73 50->74 51->1 51->1 51->1 51->63 51->65 51->71 51->72 52->1 52->1 52->11 52->19 52->39 52->39 52->40 52->53 53->31 53->39 53->39 54->1 54->24 54->31 54->50 54->53 54->70 54->73 54->74 55->1 55->1 55->71 55->72 56->24 56->31 56->50 56->53 56->70 56->73 56->74 57->24 57->48 57->48 58->1 58->1 58->45 58->45 58->59 58->64 58->92 58->100 59->1 59->1 59->45 59->45 60->1 60->1 60->47 60->47 60->61 60->68 60->97 60->104 61->1 61->1 61->47 61->47 62->1 62->1 62->30 62->32 62->58 62->58 62->63 62->64 62->65 62->66 62->73 62->90 62->91 62->99 63->1 63->1 63->58 63->58 63->64 63->65 63->71 63->72 64->1 64->1 64->30 64->32 64->59 64->59 64->62 64->63 64->65 64->66 64->74 64->93 64->94 64->101 65->1 65->1 65->59 65->59 65->62 65->63 65->71 65->72 66->1 66->1 66->30 66->32 66->60 66->60 66->62 66->67 66->68 66->71 66->72 66->103 66->106 67->1 67->1 67->60 67->60 67->69 68->1 68->1 68->30 68->32 68->61 68->61 68->62 68->66 68->69 68->71 68->72 68->105 68->107 69->1 69->1 69->61 69->61 69->67 70->24 70->31 70->50 70->53 70->73 70->74 71->1 71->1 71->26 71->63 71->65 71->67 71->67 71->68 71->72 72->1 72->1 72->26 72->63 72->65 72->66 72->69 72->69 72->71 73->31 73->50 73->53 73->70 73->74 74->31 74->50 74->53 74->70 74->73
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( void ) { int C , D , N , T ; int i , j , k , size ; char cList [ 36 ] [ 4 ] , dList [ 28 ] [ 3 ] , nList [ 101 ] , spell ; scanf ( "\x25\x64\x20\x0" , & T ) ; T ++ ; for ( k = 1 ; k < T ; k ++ ) { scanf ( "%d " , & C ) ; for ( i = 0 ; i < C ; i ++ ) scanf ( "%s" , ( char * ) cList [ i ] ) ; scanf ( "%d " , & D ) ; for ( i = 0 ; i < D ; i ++ ) scanf ( "%s " , ( char * ) dList ) ; scanf ( "%d " , & N ) ; nList [ 0 ] = '\0' ; for ( i = 0 , size = 0 ; i < N ; i ++ ) { scanf ( "%c " , & spell ) ; for ( j = 0 ; j < C && size > 0 ; j ++ ) if ( ( spell == cList [ j ] [ 0 ] && nList [ size - 1 ] == cList [ j ] [ 1 ] ) || ( spell == cList [ j ] [ 1 ] && nList [ size - 1 ] == cList [ j ] [ 0 ] ) ) { nList [ size - 1 ] = cList [ j ] [ 2 ] ; goto end4 ; } for ( j = 0 ; j < D && size > 0 ; j ++ ) if ( ( spell == dList [ j ] [ 1 ] && strchr ( nList , dList [ j ] [ 0 ] ) != NULL ) || ( spell == dList [ j ] [ 0 ] && strchr ( nList , dList [ j ] [ 1 ] ) != NULL ) ) { size = 0 ; nList [ 0 ] = '\0' ; goto end4 ; } size ++ ; nList [ size - 1 ] = spell ; nList [ size ] = '\0' ; end4 : ; } printf ( "Case #%d: [" , k ) ; for ( i = 0 ; i < size ; i ++ ) printf ( "%c%s" , nList [ i ] , ( i == size - 1 ? "" : ", " ) ) ; printf ( "]\n" ) ; } return 0 ; }
>>>Func
METHOD avl_tree_subtree_height
METHOD_RETURN int
PARAM AVLTreeNode * node
<operator>.equals node == NULL
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
RETURN return node -> height ; return node -> height ;
<operator>.indirectFieldAccess node -> height
FIELD_IDENTIFIER height height
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 2->3 3->1 3->1 3->1 3->4 3->6 3->7 3->8 4->1 5->4 6->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int avl_tree_subtree_height ( AVLTreeNode * node ) { if ( node == NULL ) { return 0 ; } else { return node -> height ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment in = fopen ( "\x69\x6e\x76\x6f\x6b\x65\x2e\x69\x6e\x0" , "r" )
<operator>.assignment out = fopen ( "invoke.out" , "w" )
fscanf fscanf ( in , "%d\n" , & tests )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < tests
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
fopen fopen ( "\x69\x6e\x76\x6f\x6b\x65\x2e\x69\x6e\x0" , "r" )
fopen fopen ( "invoke.out" , "w" )
<operator>.assignment i = 0
init init ( )
fscanf fscanf ( in , "%d " , & rs )
fscanf fscanf ( in , "%d " , & os )
fscanf fscanf ( in , "%d " , & len )
fscanf fscanf ( in , "\n" )
<operator>.assignment list [ 1 ] = cs [ 0 ]
<operator>.assignment list [ 2 ] = cs [ 1 ]
<operator>.assignment start = 0
<operator>.assignment end = 2
<operator>.lessThan j < rs
<operator>.postIncrement j ++
<operator>.lessThan j < os
<operator>.postIncrement j ++
<operator>.lessThan j < len
<operator>.postIncrement j ++
<operator>.lessEqualsThan j <= len
<operator>.postIncrement j ++
<operator>.equals end == start + 1
<operator>.assignment j = 0
fscanf fscanf ( in , " " )
<operator>.assignment replace [ ctemp [ 0 ] - 'A' + 1 ] [ ctemp [ 1 ] - 'A' + 1 ] = ctemp [ 2 ]
<operator>.assignment replace [ ctemp [ 1 ] - 'A' + 1 ] [ ctemp [ 0 ] - 'A' + 1 ] = ctemp [ 2 ]
<operator>.assignment j = 0
fscanf fscanf ( in , " " )
<operator>.assignment oppose [ ctemp [ 0 ] - 'A' + 1 ] [ ctemp [ 1 ] - 'A' + 1 ] = 1
<operator>.assignment oppose [ ctemp [ 1 ] - 'A' + 1 ] [ ctemp [ 0 ] - 'A' + 1 ] = 1
<operator>.assignment j = 0
fscanf fscanf ( in , "%c" , & cs [ j ] )
<operator>.assignment j = 2
combine combine ( )
opposed opposed ( )
<operator>.assignment list [ ++ end ] = cs [ j ]
fprintf fprintf ( out , "Case #%d: []\n" , i + 1 )
<operator>.lessEqualsThan k <= 2
<operator>.postIncrement k ++
<operator>.lessEqualsThan k <= 1
<operator>.postIncrement k ++
<operator>.addition start + 1
<operator>.assignment k = 0
fscanf fscanf ( in , "%c" , & ctemp [ k ] )
<operator>.assignment k = 0
fscanf fscanf ( in , "%c" , & ctemp [ k ] )
<operator>.addition i + 1
<operator>.equals end - start == 2
<operator>.addition ctemp [ 1 ] - 'A' + 1
<operator>.addition ctemp [ 0 ] - 'A' + 1
<operator>.addition ctemp [ 1 ] - 'A' + 1
<operator>.addition ctemp [ 0 ] - 'A' + 1
<operator>.preIncrement ++ end
fprintf fprintf ( out , "Case #%d: [%c]\n" , i + 1 , list [ end - 1 ] )
<operator>.addition ctemp [ 0 ] - 'A' + 1
<operator>.subtraction ctemp [ 1 ] - 'A'
<operator>.addition ctemp [ 1 ] - 'A' + 1
<operator>.subtraction ctemp [ 0 ] - 'A'
<operator>.addition ctemp [ 0 ] - 'A' + 1
<operator>.subtraction ctemp [ 1 ] - 'A'
<operator>.addition ctemp [ 1 ] - 'A' + 1
<operator>.subtraction ctemp [ 0 ] - 'A'
<operator>.subtraction end - start
fprintf fprintf ( out , "Case #%d: [" , i + 1 )
fprintf fprintf ( out , "%c" , list [ end - 1 ] )
fprintf fprintf ( out , "]\n " )
<operator>.subtraction ctemp [ 0 ] - 'A'
<operator>.subtraction ctemp [ 1 ] - 'A'
<operator>.subtraction ctemp [ 0 ] - 'A'
<operator>.subtraction ctemp [ 1 ] - 'A'
<operator>.addition i + 1
<operator>.lessThan j < end - 1
<operator>.postIncrement j ++
<operator>.subtraction end - 1
<operator>.addition i + 1
<operator>.assignment j = start + 1
fprintf fprintf ( out , "%c," , list [ j ] )
<operator>.subtraction end - 1
<operator>.subtraction end - 1
<operator>.addition start + 1
<operator>.addressOf & rs
<operator>.addressOf & os
<operator>.addressOf & len
<operator>.indirectIndexAccess list [ 1 ]
<operator>.indirectIndexAccess cs [ 0 ]
<operator>.indirectIndexAccess list [ 2 ]
<operator>.indirectIndexAccess cs [ 1 ]
<operator>.indirectIndexAccess replace [ ctemp [ 0 ] - 'A' + 1 ] [ ctemp [ 1 ] - 'A' + 1 ]
<operator>.indirectIndexAccess ctemp [ 2 ]
<operator>.indirectIndexAccess replace [ ctemp [ 1 ] - 'A' + 1 ] [ ctemp [ 0 ] - 'A' + 1 ]
<operator>.indirectIndexAccess ctemp [ 2 ]
<operator>.indirectIndexAccess oppose [ ctemp [ 0 ] - 'A' + 1 ] [ ctemp [ 1 ] - 'A' + 1 ]
<operator>.indirectIndexAccess oppose [ ctemp [ 1 ] - 'A' + 1 ] [ ctemp [ 0 ] - 'A' + 1 ]
<operator>.addressOf & cs [ j ]
<operator>.indirectIndexAccess list [ ++ end ]
<operator>.indirectIndexAccess cs [ j ]
<operator>.indirectIndexAccess replace [ ctemp [ 0 ] - 'A' + 1 ]
<operator>.indirectIndexAccess replace [ ctemp [ 1 ] - 'A' + 1 ]
<operator>.indirectIndexAccess oppose [ ctemp [ 0 ] - 'A' + 1 ]
<operator>.indirectIndexAccess oppose [ ctemp [ 1 ] - 'A' + 1 ]
<operator>.indirectIndexAccess cs [ j ]
<operator>.addressOf & ctemp [ k ]
<operator>.addressOf & ctemp [ k ]
<operator>.indirectIndexAccess ctemp [ k ]
<operator>.indirectIndexAccess ctemp [ 1 ]
<operator>.indirectIndexAccess ctemp [ 0 ]
<operator>.indirectIndexAccess ctemp [ k ]
<operator>.indirectIndexAccess ctemp [ 1 ]
<operator>.indirectIndexAccess ctemp [ 0 ]
<operator>.indirectIndexAccess list [ end - 1 ]
<operator>.indirectIndexAccess ctemp [ 0 ]
<operator>.indirectIndexAccess ctemp [ 1 ]
<operator>.indirectIndexAccess ctemp [ 0 ]
<operator>.indirectIndexAccess ctemp [ 1 ]
<operator>.indirectIndexAccess list [ end - 1 ]
<operator>.indirectIndexAccess list [ j ]
>>>PDG&124 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 2->1 2->1 2->4 3->1 3->1 3->1 3->44 3->61 3->71 4->1 4->1 4->1 4->6 4->13 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->20 6->21 6->23 6->25 6->27 6->29 6->30 6->34 6->38 6->40 6->44 6->49 6->54 6->61 6->71 6->78 6->82 6->88 6->89 6->90 6->91 6->92 6->93 6->94 7->1 7->6 8->5 9->2 9->2 10->3 10->3 11->1 11->6 12->1 13->1 13->1 13->14 13->21 13->31 13->51 14->1 14->1 14->15 14->23 14->35 14->53 15->1 15->1 15->16 15->25 15->27 15->39 16->1 16->1 16->13 17->1 17->1 17->1 18->1 18->1 18->1 19->1 19->29 19->49 19->70 20->1 20->29 20->60 21->1 21->1 21->13 21->21 21->22 21->22 21->31 21->32 21->33 21->45 21->50 21->56 21->57 21->62 21->63 21->64 21->65 21->74 21->75 21->95 21->96 21->97 21->98 21->104 21->105 21->112 21->113 21->118 21->119 22->1 22->21 23->1 23->1 23->14 23->23 23->24 23->24 23->35 23->36 23->37 23->47 23->52 23->58 23->59 23->66 23->67 23->68 23->69 23->76 23->77 23->99 23->100 23->106 23->107 23->115 23->116 23->120 23->121 24->1 24->23 25->1 25->25 25->26 25->26 25->27 25->39 25->101 25->108 26->1 26->25 27->1 27->1 27->1 27->15 27->25 27->27 27->28 27->28 27->41 27->42 27->43 27->60 27->102 27->103 28->1 28->27 29->1 29->1 29->1 29->44 29->54 29->55 29->70 29->70 30->21 31->1 31->14 31->51 32->1 32->1 33->1 33->1 33->1 34->23 35->1 35->15 35->53 36->1 36->1 37->1 37->1 38->1 38->25 39->1 39->1 39->16 39->43 40->1 40->27 41->1 42->1 43->1 43->1 43->1 44->1 44->1 44->1 44->61 44->71 45->1 45->1 45->45 45->46 45->46 45->51 45->109 45->111 46->1 46->45 47->1 47->1 47->47 47->48 47->48 47->53 47->110 47->114 48->1 48->47 49->1 50->1 50->45 51->1 51->1 51->31 51->53 52->1 52->47 53->1 53->1 53->35 53->51 55->1 55->1 55->61 55->71 55->72 55->73 55->78 55->79 55->81 55->82 55->83 55->85 55->86 55->87 55->117 55->122 57->1 59->1 60->29 61->1 61->1 61->1 61->1 61->44 61->71 61->72 63->56 63->56 63->75 64->1 65->1 65->57 65->57 65->74 65->76 67->58 67->58 67->77 68->1 69->1 69->59 69->59 69->74 69->76 70->1 70->55 70->55 70->81 70->83 70->85 70->87 71->1 71->1 71->72 71->84 72->1 72->1 72->61 72->73 73->1 73->1 73->44 73->61 73->71 74->62 74->62 74->65 75->1 75->63 75->64 75->64 75->67 76->66 76->66 76->69 77->1 77->63 77->67 77->68 77->68 79->1 79->1 79->79 79->80 79->80 79->84 79->85 79->123 80->1 80->79 81->1 83->1 83->1 83->79 84->1 84->1 84->72 85->79 85->79 85->86 86->1 87->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { FILE * in , * out ; in = fopen ( "\x69\x6e\x76\x6f\x6b\x65\x2e\x69\x6e\x0" , "r" ) ; out = fopen ( "invoke.out" , "w" ) ; int i , j , k , tests , os , rs ; char cs [ 101 ] , ctemp [ 3 ] ; int len ; fscanf ( in , "%d\n" , & tests ) ; for ( i = 0 ; i < tests ; i ++ ) { init ( ) ; fscanf ( in , "%d " , & rs ) ; for ( j = 0 ; j < rs ; j ++ ) { for ( k = 0 ; k <= 2 ; k ++ ) { fscanf ( in , "%c" , & ctemp [ k ] ) ; } fscanf ( in , " " ) ; replace [ ctemp [ 0 ] - 'A' + 1 ] [ ctemp [ 1 ] - 'A' + 1 ] = ctemp [ 2 ] ; replace [ ctemp [ 1 ] - 'A' + 1 ] [ ctemp [ 0 ] - 'A' + 1 ] = ctemp [ 2 ] ; } fscanf ( in , "%d " , & os ) ; for ( j = 0 ; j < os ; j ++ ) { for ( k = 0 ; k <= 1 ; k ++ ) { fscanf ( in , "%c" , & ctemp [ k ] ) ; } fscanf ( in , " " ) ; oppose [ ctemp [ 0 ] - 'A' + 1 ] [ ctemp [ 1 ] - 'A' + 1 ] = 1 ; oppose [ ctemp [ 1 ] - 'A' + 1 ] [ ctemp [ 0 ] - 'A' + 1 ] = 1 ; } fscanf ( in , "%d " , & len ) ; for ( j = 0 ; j < len ; j ++ ) { fscanf ( in , "%c" , & cs [ j ] ) ; } fscanf ( in , "\n" ) ; list [ 1 ] = cs [ 0 ] ; list [ 2 ] = cs [ 1 ] ; start = 0 ; end = 2 ; for ( j = 2 ; j <= len ; j ++ ) { combine ( ) ; opposed ( ) ; list [ ++ end ] = cs [ j ] ; } if ( end == start + 1 ) { fprintf ( out , "Case #%d: []\n" , i + 1 ) ; } else if ( end - start == 2 ) { fprintf ( out , "Case #%d: [%c]\n" , i + 1 , list [ end - 1 ] ) ; } else { fprintf ( out , "Case #%d: [" , i + 1 ) ; for ( j = start + 1 ; j < end - 1 ; j ++ ) { fprintf ( out , "%c," , list [ j ] ) ; } fprintf ( out , "%c" , list [ end - 1 ] ) ; fprintf ( out , "]\n " ) ; } } return 0 ; }
>>>Func
METHOD hash_table_iter_next
METHOD_RETURN HashTablePair
PARAM HashTableIterator * iterator
<operator>.assignment pair = { NULL   NULL }
<operator>.assignment hash_table = iterator -> hash_table
<operator>.assignment current_entry = iterator -> next_entry
<operator>.assignment pair = current_entry -> pair
RETURN return pair ; return pair ;
<operator>.equals iterator -> next_entry == NULL
<operator>.notEquals current_entry -> next != NULL
IDENTIFIER pair return pair ;
<operator>.arrayInitializer { NULL   NULL }
RETURN return pair ; return pair ;
<operator>.assignment iterator -> next_entry = current_entry -> next
IDENTIFIER pair return pair ;
<operator>.assignment chain = iterator -> next_chain + 1
<operator>.assignment iterator -> next_entry = NULL
<operator>.assignment iterator -> next_chain = chain
<operator>.lessThan chain < hash_table -> table_size
<operator>.addition iterator -> next_chain + 1
<operator>.preIncrement ++ chain
<operator>.notEquals hash_table -> table [ chain ] != NULL
<operator>.assignment iterator -> next_entry = hash_table -> table [ chain ]
<operator>.indirectFieldAccess iterator -> next_entry
<operator>.indirectFieldAccess current_entry -> pair
FIELD_IDENTIFIER next_entry next_entry
FIELD_IDENTIFIER pair pair
<operator>.indirectFieldAccess current_entry -> next
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess iterator -> next_entry
<operator>.indirectFieldAccess current_entry -> next
FIELD_IDENTIFIER next_entry next_entry
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess iterator -> next_entry
<operator>.indirectFieldAccess iterator -> next_chain
<operator>.indirectFieldAccess iterator -> next_chain
FIELD_IDENTIFIER next_entry next_entry
<operator>.indirectFieldAccess hash_table -> table_size
FIELD_IDENTIFIER next_chain next_chain
FIELD_IDENTIFIER next_chain next_chain
FIELD_IDENTIFIER table_size table_size
<operator>.indirectIndexAccess hash_table -> table [ chain ]
<operator>.indirectFieldAccess hash_table -> table
<operator>.indirectFieldAccess iterator -> next_entry
<operator>.indirectIndexAccess hash_table -> table [ chain ]
FIELD_IDENTIFIER table table
FIELD_IDENTIFIER next_entry next_entry
<operator>.indirectFieldAccess hash_table -> table
FIELD_IDENTIFIER table table
>>>PDG&49 0->2 0->8 0->9 0->10 0->11 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 2->1 3->1 3->1 3->1 3->14 4->1 4->1 4->1 6->10 7->1 8->1 8->1 8->1 8->5 8->5 8->6 8->7 8->9 8->9 8->12 8->23 8->24 8->25 8->26 8->27 8->28 9->13 9->13 9->15 9->16 9->16 9->17 9->18 9->19 9->21 9->29 9->30 9->31 9->32 9->33 9->34 9->35 9->36 9->37 9->38 9->39 9->40 10->7 11->3 11->8 12->1 14->12 15->18 18->17 18->20 18->21 18->41 18->42 18->45 20->18 21->18 21->20 21->22 21->22 21->37 21->40 21->43 21->44 21->46 21->47 21->48
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) HashTablePair hash_table_iter_next ( HashTableIterator * iterator ) { HashTableEntry * current_entry ; HashTable * hash_table ; HashTablePair pair = { NULL , NULL } ; unsigned int chain ; hash_table = iterator -> hash_table ; if ( iterator -> next_entry == NULL ) { return pair ; } current_entry = iterator -> next_entry ; pair = current_entry -> pair ; if ( current_entry -> next != NULL ) { iterator -> next_entry = current_entry -> next ; } else { chain = iterator -> next_chain + 1 ; iterator -> next_entry = NULL ; while ( chain < hash_table -> table_size ) { if ( hash_table -> table [ chain ] != NULL ) { iterator -> next_entry = hash_table -> table [ chain ] ; break ; } ++ chain ; } iterator -> next_chain = chain ; } return pair ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
scanf scanf ( "\x25\x64\x0" , & N )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= N
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
scanf scanf ( "%ld%ld%ld%ld%ld%ld%ld%ld" , & n , & A , & B , & C , & D , & x0 , & y0 , & M )
<operator>.assignment tree [ 0 ] . x = x0
<operator>.assignment tree [ 0 ] . y = y0
printf printf ( "Case #%d: %ld\n"   i   cropTriangles ( tree , n ) )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment j = 1
<operator>.assignment tree [ j ] . x = ( mult ( tree [ j - 1 ] . x , A , M ) + B ) % M
<operator>.assignment tree [ j ] . y = ( mult ( tree [ j - 1 ] . y , C , M ) + D ) % M
cropTriangles cropTriangles ( tree , n )
<operator>.modulo ( mult ( tree [ j - 1 ] . x , A , M ) + B ) % M
<operator>.modulo ( mult ( tree [ j - 1 ] . y , C , M ) + D ) % M
<operator>.addition mult ( tree [ j - 1 ] . x , A , M ) + B
<operator>.addition mult ( tree [ j - 1 ] . y , C , M ) + D
mult mult ( tree [ j - 1 ] . x , A , M )
mult mult ( tree [ j - 1 ] . y , C , M )
<operator>.subtraction j - 1
<operator>.subtraction j - 1
<operator>.addressOf & n
<operator>.addressOf & A
<operator>.addressOf & B
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & x0
<operator>.addressOf & y0
<operator>.addressOf & M
<operator>.fieldAccess tree [ 0 ] . x
<operator>.fieldAccess tree [ 0 ] . y
<operator>.indirectIndexAccess tree [ 0 ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess tree [ 0 ]
FIELD_IDENTIFIER y y
<operator>.fieldAccess tree [ j ] . x
<operator>.fieldAccess tree [ j ] . y
<operator>.indirectIndexAccess tree [ j ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess tree [ j ]
FIELD_IDENTIFIER y y
<operator>.fieldAccess tree [ j - 1 ] . x
<operator>.fieldAccess tree [ j - 1 ] . y
<operator>.indirectIndexAccess tree [ j - 1 ]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess tree [ j - 1 ]
FIELD_IDENTIFIER y y
>>>PDG&53 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->9 5->10 5->11 5->12 5->12 5->13 5->15 5->18 5->27 5->28 5->29 5->30 5->31 5->32 5->33 5->34 5->35 5->36 5->37 5->38 5->39 5->40 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->1 9->1 9->1 9->1 9->1 9->1 9->13 9->18 10->1 10->1 11->1 11->1 12->1 12->1 12->6 13->1 13->1 13->13 13->14 13->16 13->17 13->18 13->19 13->20 13->21 13->22 13->23 13->24 13->25 13->25 13->26 13->41 13->42 13->43 13->44 13->45 13->46 13->47 13->48 13->49 13->50 13->51 13->52 14->1 14->13 15->1 15->13 16->1 16->1 17->1 17->1 18->1 18->1 18->9 18->12 18->12 18->13 19->1 19->16 19->16 19->24 20->1 20->1 20->17 20->17 20->23 21->1 21->1 22->1 22->1 23->1 23->19 23->19 23->19 23->21 23->21 23->21 24->1 24->20 24->20 24->20 24->22 24->22 24->22 25->26 26->14
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( void ) { int N ; unsigned long int n , A , B , C , D , x0 , y0 , M , j ; point tree [ 100000 ] ; int i ; scanf ( "\x25\x64\x0" , & N ) ; for ( i = 1 ; i <= N ; i ++ ) { scanf ( "%ld%ld%ld%ld%ld%ld%ld%ld" , & n , & A , & B , & C , & D , & x0 , & y0 , & M ) ; tree [ 0 ] . x = x0 ; tree [ 0 ] . y = y0 ; for ( j = 1 ; j < n ; j ++ ) { tree [ j ] . x = ( mult ( tree [ j - 1 ] . x , A , M ) + B ) % M ; tree [ j ] . y = ( mult ( tree [ j - 1 ] . y , C , M ) + D ) % M ; } printf ( "Case #%d: %ld\n" , i , cropTriangles ( tree , n ) ) ; } return 0 ; }
>>>Func
METHOD is_ancestor
METHOD_RETURN bool
PARAM const struct stat * sb
PARAM const struct dir_list * ancestors
RETURN return false ; return false ;
<operator>.notEquals ancestors != 0
IDENTIFIER false return false ;
<operator>.assignment ancestors = ancestors -> parent
<operator>.logicalAnd ancestors -> ino == sb -> st_ino && ancestors -> dev == sb -> st_dev
RETURN return true ; return true ;
<operator>.equals ancestors -> ino == sb -> st_ino
<operator>.equals ancestors -> dev == sb -> st_dev
IDENTIFIER true return true ;
<operator>.indirectFieldAccess ancestors -> parent
FIELD_IDENTIFIER parent parent
<operator>.indirectFieldAccess ancestors -> ino
<operator>.indirectFieldAccess sb -> st_ino
<operator>.indirectFieldAccess ancestors -> dev
<operator>.indirectFieldAccess sb -> st_dev
FIELD_IDENTIFIER ino ino
FIELD_IDENTIFIER st_ino st_ino
FIELD_IDENTIFIER dev dev
FIELD_IDENTIFIER st_dev st_dev
>>>PDG&23 0->2 0->3 0->4 0->5 0->6 0->9 0->12 2->1 3->5 4->1 5->1 5->1 5->4 5->8 5->10 5->15 5->16 5->19 5->20 6->4 8->1 8->1 8->1 8->5 8->7 8->9 8->13 8->14 9->1 10->1 10->1 10->8 10->8 10->11 10->17 10->18 10->21 10->22 11->1 11->1 11->8 11->8 12->9
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) ndif ATTRIBUTE_PURE static bool is_ancestor ( const struct stat * sb , const struct dir_list * ancestors ) { while ( ancestors != 0 ) { if ( ancestors -> ino == sb -> st_ino && ancestors -> dev == sb -> st_dev ) return true ; ancestors = ancestors -> parent ; } return false ; }
>>>Func
METHOD push
METHOD_RETURN void
PARAM struct Node * * head_ref
PARAM int new_data
<operator>.assignment * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) )
<operator>.assignment new_node -> data = new_data
<operator>.assignment new_node -> next = ( * head_ref )
<operator>.assignment ( * head_ref ) = new_node
<operator>.cast ( struct Node * ) malloc ( sizeof ( struct Node ) )
<operator>.sizeOf sizeof ( struct Node )
>>>PDG&10 0->2 0->3 0->5 0->7 2->1 3->5 4->1 4->1 4->7 5->1 5->1 5->1 6->1 6->1 7->1 7->1 7->1 8->1 9->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }
>>>Func
METHOD isBase
METHOD_RETURN int
PARAM char c
IDENTIFIER c switch(c)
LITERAL 'Q' <empty>
RETURN return 1 ; return 1 ;
LITERAL 'W' <empty>
RETURN return 1 ; return 1 ;
LITERAL 'E' <empty>
RETURN return 1 ; return 1 ;
LITERAL 'R' <empty>
RETURN return 1 ; return 1 ;
LITERAL 'A' <empty>
RETURN return 1 ; return 1 ;
LITERAL 'S' <empty>
RETURN return 1 ; return 1 ;
LITERAL 'D' <empty>
RETURN return 1 ; return 1 ;
LITERAL 'F' <empty>
RETURN return 1 ; return 1 ;
RETURN return 0 ; return 0 ;
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
LITERAL 1 return 1 ;
LITERAL 0 return 0 ;
>>>PDG&30 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 2->1 5->1 7->1 9->1 11->1 13->1 15->1 17->1 19->1 20->1 21->5 22->7 23->9 24->11 25->13 26->15 27->17 28->19 29->20
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int isBase ( char c ) { switch ( c ) { case 'Q' : return 1 ; case 'W' : return 1 ; case 'E' : return 1 ; case 'R' : return 1 ; case 'A' : return 1 ; case 'S' : return 1 ; case 'D' : return 1 ; case 'F' : return 1 ; default : return 0 ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan x <= t
<operator>.postIncrement x ++
LITERAL 0 return 0 ;
<operator>.assignment x = 1
scanf scanf ( "%d" , & n )
printf printf ( "Case #%d:\n" , x )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
scanf scanf ( "%s" , table [ i ] )
<operator>.assignment i = 0
<operator>.assignment win = total = 0
<operator>.assignment wins [ i ] = win
<operator>.assignment totals [ i ] = total
<operator>.assignment wps [ i ] = ( float ) win / ( float ) total
<operator>.assignment i = 0
<operator>.assignment sum = 0
<operator>.assignment len = 0
<operator>.assignment owps [ i ] = sum / len
<operator>.assignment i = 0
<operator>.assignment sum = 0
<operator>.assignment len = 0
<operator>.assignment oowps [ i ] = sum / len
<operator>.assignment i = 0
<operator>.assignment rpi = 0.25 * wps [ i ] + 0.50 * owps [ i ] + 0.25 * oowps [ i ]
printf printf ( "%.8f\n" , rpi )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment total = 0
<operator>.assignment j = 0
<operator>.division ( float ) win / ( float ) total
<operator>.assignment j = 0
<operator>.division sum / len
<operator>.assignment j = 0
<operator>.division sum / len
<operator>.addition 0.25 * wps [ i ] + 0.50 * owps [ i ] + 0.25 * oowps [ i ]
<operator>.equals table [ i ] [ j ] == 0x31
<operator>.equals table [ i ] [ j ] == 0x30
<operator>.cast ( float ) win
<operator>.cast ( float ) total
<operator>.logicalOr table [ i ] [ j ] == 0x30 || table [ i ] [ j ] == 0x31
<operator>.logicalOr table [ i ] [ j ] == 0x30 || table [ i ] [ j ] == 0x31
<operator>.addition 0.25 * wps [ i ] + 0.50 * owps [ i ]
<operator>.multiplication 0.25 * oowps [ i ]
<operator>.postIncrement win ++
<operator>.postIncrement total ++
<operator>.postIncrement total ++
<operator>.postIncrement len ++
<operator>.assignmentPlus sum += owps [ j ]
<operator>.postIncrement len ++
<operator>.multiplication 0.25 * wps [ i ]
<operator>.multiplication 0.50 * owps [ i ]
<operator>.equals table [ i ] [ j ] == 0x30
<operator>.equals table [ i ] [ j ] == 0x31
<operator>.equals table [ j ] [ i ] == 0x31
<operator>.equals table [ i ] [ j ] == 0x30
<operator>.equals table [ i ] [ j ] == 0x31
<operator>.assignment wp = ( float ) ( wins [ j ] - 1 ) / ( float ) ( totals [ j ] - 1 )
<operator>.assignmentPlus sum += wp
<operator>.assignment wp = ( float ) ( wins [ j ] ) / ( float ) ( totals [ j ] - 1 )
<operator>.assignmentPlus sum += wp
<operator>.division ( float ) ( wins [ j ] - 1 ) / ( float ) ( totals [ j ] - 1 )
<operator>.cast ( float ) ( wins [ j ] - 1 )
<operator>.cast ( float ) ( totals [ j ] - 1 )
<operator>.division ( float ) ( wins [ j ] ) / ( float ) ( totals [ j ] - 1 )
<operator>.subtraction wins [ j ] - 1
<operator>.subtraction totals [ j ] - 1
<operator>.cast ( float ) ( wins [ j ] )
<operator>.cast ( float ) ( totals [ j ] - 1 )
<operator>.subtraction totals [ j ] - 1
<operator>.addressOf & n
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess wins [ i ]
<operator>.indirectIndexAccess totals [ i ]
<operator>.indirectIndexAccess wps [ i ]
<operator>.indirectIndexAccess owps [ i ]
<operator>.indirectIndexAccess oowps [ i ]
UNKNOWN float float
UNKNOWN float float
<operator>.indirectIndexAccess oowps [ i ]
<operator>.indirectIndexAccess table [ i ] [ j ]
<operator>.indirectIndexAccess table [ i ] [ j ]
<operator>.indirectIndexAccess wps [ i ]
<operator>.indirectIndexAccess owps [ i ]
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess table [ i ] [ j ]
<operator>.indirectIndexAccess table [ i ] [ j ]
<operator>.indirectIndexAccess table [ i ] [ j ]
<operator>.indirectIndexAccess table [ i ] [ j ]
<operator>.indirectIndexAccess owps [ j ]
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess table [ j ] [ i ]
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess table [ j ]
UNKNOWN float float
UNKNOWN float float
<operator>.indirectIndexAccess wins [ j ]
<operator>.indirectIndexAccess totals [ j ]
UNKNOWN float float
<operator>.indirectIndexAccess wins [ j ]
UNKNOWN float float
<operator>.indirectIndexAccess totals [ j ]
>>>PDG&121 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->27 0->28 0->29 0->31 0->32 0->33 0->35 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->74 0->76 0->81 0->82 0->85 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->9 4->10 4->12 4->14 4->16 4->18 4->20 4->22 4->27 4->31 4->35 4->86 5->1 5->4 6->3 7->1 7->4 8->1 8->10 8->12 8->14 8->16 8->18 8->38 8->40 8->42 9->1 9->5 10->10 10->11 10->11 10->12 10->21 10->87 11->1 11->10 12->12 12->13 12->13 12->14 12->23 12->24 12->25 12->26 12->38 12->38 12->44 12->45 12->46 12->54 12->55 12->88 12->89 12->90 12->93 12->94 13->1 13->12 14->14 14->15 14->15 14->16 14->28 14->29 14->30 14->40 14->40 14->47 14->48 14->91 15->1 15->14 16->16 16->17 16->17 16->18 16->32 16->33 16->34 16->42 16->42 16->49 16->50 16->92 17->1 17->16 18->1 18->1 18->1 18->8 18->10 18->18 18->19 18->19 18->36 18->37 18->51 18->58 18->59 18->66 18->67 18->95 18->98 18->99 19->1 19->18 20->10 21->1 22->12 23->1 23->1 23->24 23->46 23->54 23->60 24->1 24->1 25->1 25->1 26->1 26->1 26->1 26->66 27->14 28->1 28->48 28->74 28->76 29->1 29->48 29->63 30->1 30->1 30->1 30->67 31->16 32->1 32->50 32->64 33->1 33->50 33->65 34->1 34->1 34->1 34->59 35->1 35->18 36->1 36->1 36->37 37->1 37->1 38->1 38->1 38->12 38->38 38->39 38->39 38->52 38->53 38->96 38->97 38->100 38->101 39->1 39->38 40->1 40->1 40->14 40->40 40->41 40->41 40->56 40->68 40->102 40->107 41->1 41->40 42->1 42->1 42->16 42->42 42->43 42->43 42->57 42->71 42->104 42->110 43->1 43->42 44->23 44->25 44->46 44->55 44->61 44->62 45->1 45->38 46->1 46->1 46->26 46->26 47->1 47->40 48->1 48->1 48->30 48->30 49->1 49->42 50->1 50->1 50->34 50->34 51->1 51->1 52->1 52->53 52->56 52->57 52->60 52->61 53->1 53->1 53->21 53->52 53->62 53->68 53->71 54->1 55->1 56->1 56->1 56->1 56->57 56->63 56->70 56->109 56->112 57->1 57->1 57->1 57->56 57->64 57->65 57->106 58->1 58->1 59->1 59->36 59->36 59->51 59->51 60->1 60->24 60->46 60->54 61->1 61->25 61->46 61->55 61->62 62->1 62->25 62->46 62->55 62->61 63->1 63->48 64->1 64->1 64->50 65->1 65->50 66->1 66->36 66->36 66->51 66->51 66->58 66->58 67->1 67->36 67->36 67->51 67->51 67->58 67->58 68->1 68->21 68->52 68->56 68->56 68->69 68->69 68->71 68->103 68->108 69->1 69->21 69->52 69->56 69->56 69->68 69->71 70->1 70->1 70->73 70->74 70->75 70->76 70->77 70->78 70->79 70->80 70->81 70->82 70->83 70->84 70->85 70->113 70->114 70->115 70->116 70->117 70->118 70->119 70->120 71->1 71->21 71->52 71->57 71->57 71->68 71->72 71->72 71->105 71->111 72->1 72->21 72->52 72->57 72->57 72->68 72->71 73->1 73->1 73->74 74->1 74->1 74->48 74->76 75->1 75->1 75->76 76->1 76->1 76->48 76->74 77->1 77->1 77->73 77->73 78->1 79->1 80->1 80->1 80->75 80->75 81->1 81->77 81->77 81->78 81->78 81->80 81->83 82->1 82->77 82->77 82->79 82->79 82->85 83->1 84->1 85->1 85->80 85->80 85->82 85->84 85->84
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int n , x , y , t , i , j , len ; int total , win ; int wins [ LEN ] , totals [ LEN ] ; float owps [ LEN ] , wps [ LEN ] , oowps [ LEN ] , wps2 [ LEN ] ; float wp , owp , oowp , sum , sum2 , rpi ; char table [ LEN ] [ LEN + 1 ] ; int op [ LEN ] [ LEN ] ; scanf ( "\x25\x64\x0" , & t ) ; for ( x = 1 ; x <= t ; x ++ ) { scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%s" , table [ i ] ) ; } printf ( "Case #%d:\n" , x ) ; for ( i = 0 ; i < n ; i ++ ) { win = total = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( table [ i ] [ j ] == 0x31 ) { win ++ ; total ++ ; } if ( table [ i ] [ j ] == 0x30 ) { total ++ ; } } wins [ i ] = win ; totals [ i ] = total ; wps [ i ] = ( float ) win / ( float ) total ; } for ( i = 0 ; i < n ; i ++ ) { sum = 0 ; len = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( table [ i ] [ j ] == 0x30 || table [ i ] [ j ] == 0x31 ) { if ( table [ j ] [ i ] == 0x31 ) { wp = ( float ) ( wins [ j ] - 1 ) / ( float ) ( totals [ j ] - 1 ) ; sum += wp ; } else { wp = ( float ) ( wins [ j ] ) / ( float ) ( totals [ j ] - 1 ) ; sum += wp ; } len ++ ; } } owps [ i ] = sum / len ; } for ( i = 0 ; i < n ; i ++ ) { sum = 0 ; len = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( table [ i ] [ j ] == 0x30 || table [ i ] [ j ] == 0x31 ) { sum += owps [ j ] ; len ++ ; } } oowps [ i ] = sum / len ; } for ( i = 0 ; i < n ; i ++ ) { rpi = 0.25 * wps [ i ] + 0.50 * owps [ i ] + 0.25 * oowps [ i ] ; printf ( "%.8f\n" , rpi ) ; } } return 0 ; }
>>>Func
METHOD hasCycle
METHOD_RETURN bool
PARAM struct ListNode * head
<operator>.assignment * fast = head
<operator>.assignment * slow = head
RETURN return false ; return false ;
<operator>.logicalAnd slow && fast && fast -> next
IDENTIFIER false return false ;
<operator>.assignment fast = fast -> next -> next
<operator>.assignment slow = slow -> next
<operator>.logicalAnd slow && fast
<operator>.equals fast == slow
RETURN return true ; return true ;
IDENTIFIER true return true ;
<operator>.indirectFieldAccess fast -> next
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess fast -> next -> next
<operator>.indirectFieldAccess slow -> next
<operator>.indirectFieldAccess fast -> next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
>>>PDG&22 0->2 0->3 0->4 0->5 0->7 0->10 0->11 0->12 0->13 2->3 2->4 3->1 3->10 4->1 4->1 4->10 5->1 6->1 6->1 6->1 6->5 6->8 6->9 6->11 6->16 6->17 6->18 6->19 6->20 6->21 7->5 8->1 8->1 8->11 9->1 9->1 9->11 10->6 10->6 10->14 10->15 11->1 11->1 11->1 11->6 11->10 11->10 11->10 11->12 12->1 13->12
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) bool hasCycle ( struct ListNode * head ) { struct ListNode * fast = head , * slow = head ; while ( slow && fast && fast -> next ) { fast = fast -> next -> next ; slow = slow -> next ; if ( fast == slow ) return true ; } return false ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
<operator>.lessThan i < T
<operator>.postIncrement i ++
<operator>.assignment i = 0
scanf scanf ( "%d\n" , & n )
printf printf ( "Case #%d:\n" , i + 1 )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment j = 0
gets gets ( arr [ j ] )
<operator>.assignment score = 0
<operator>.assignment count = 0
<operator>.assignment nummatch [ j ] = count
<operator>.assignment tscore [ j ] = score
<operator>.assignment j = 0
<operator>.assignment count = 0
<operator>.assignment avwp = 0
<operator>.assignment owp [ j ] = avwp / count
<operator>.assignment j = 0
<operator>.assignment sum = 0
<operator>.assignment count = 0
<operator>.addition i + 1
<operator>.assignment j = 0
printf printf ( "%f\n" , 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ] )
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.greaterThan nummatch [ j ] > 0
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.lessThan k < n
<operator>.postIncrement k ++
<operator>.greaterThan count > 0
<operator>.assignment k = 0
<operator>.assignment wp [ j ] = tscore [ j ] / nummatch [ j ]
<operator>.assignment k = 0
<operator>.division avwp / count
<operator>.assignment k = 0
<operator>.assignment oowp [ j ] = sum / count
<operator>.addition 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ]
<operator>.equals arr [ j ] [ k ] == '.'
<operator>.equals arr [ j ] [ k ] == '1'
<operator>.assignment wp [ j ] = 0
<operator>.equals k == j
<operator>.equals j == k
<operator>.assignment oowp [ j ] = 0
<operator>.addition 0.25 * wp [ j ] + 0.5 * owp [ j ]
<operator>.multiplication 0.25 * oowp [ j ]
<operator>.assignmentPlus score += 1.0
<operator>.division tscore [ j ] / nummatch [ j ]
<operator>.division sum / count
<operator>.multiplication 0.25 * wp [ j ]
<operator>.multiplication 0.5 * owp [ j ]
<operator>.postIncrement count ++
<operator>.notEquals arr [ k ] [ j ] != '.'
<operator>.notEquals arr [ j ] [ k ] != '.'
<operator>.assignment test = tscore [ k ] - ( arr [ k ] [ j ] - '0' )
<operator>.postIncrement count ++
<operator>.assignmentPlus sum += owp [ k ]
<operator>.postIncrement count ++
<operator>.greaterThan nummatch [ k ] > 1
<operator>.subtraction tscore [ k ] - ( arr [ k ] [ j ] - '0' )
<operator>.assignmentPlus avwp += test / ( float ) ( nummatch [ k ] - 1 )
<operator>.subtraction arr [ k ] [ j ] - '0'
<operator>.division test / ( float ) ( nummatch [ k ] - 1 )
<operator>.cast ( float ) ( nummatch [ k ] - 1 )
<operator>.subtraction nummatch [ k ] - 1
<operator>.addressOf & n
<operator>.indirectIndexAccess arr [ j ]
<operator>.indirectIndexAccess nummatch [ j ]
<operator>.indirectIndexAccess tscore [ j ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess nummatch [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess oowp [ j ]
<operator>.indirectIndexAccess oowp [ j ]
<operator>.indirectIndexAccess arr [ j ] [ k ]
<operator>.indirectIndexAccess arr [ j ] [ k ]
<operator>.indirectIndexAccess tscore [ j ]
<operator>.indirectIndexAccess nummatch [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess oowp [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess arr [ j ]
<operator>.indirectIndexAccess arr [ j ]
<operator>.indirectIndexAccess arr [ k ] [ j ]
<operator>.indirectIndexAccess arr [ j ] [ k ]
<operator>.indirectIndexAccess arr [ k ]
<operator>.indirectIndexAccess arr [ j ]
<operator>.indirectIndexAccess owp [ k ]
<operator>.indirectIndexAccess tscore [ k ]
<operator>.indirectIndexAccess nummatch [ k ]
<operator>.indirectIndexAccess arr [ k ] [ j ]
<operator>.indirectIndexAccess arr [ k ]
UNKNOWN float float
<operator>.indirectIndexAccess nummatch [ k ]
>>>PDG&104 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->42 0->43 0->44 0->47 0->48 0->49 0->50 0->51 0->52 0->54 0->55 0->57 0->58 0->59 0->60 0->61 0->62 0->64 0->65 0->66 0->67 0->69 0->70 0->71 0->73 2->1 2->3 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->7 3->7 3->8 3->10 3->12 3->14 3->16 3->22 3->26 3->29 3->29 3->30 3->74 4->1 4->3 5->1 5->3 6->1 6->8 6->10 6->12 6->14 6->32 6->35 6->37 7->1 7->1 8->8 8->9 8->9 8->10 8->17 8->18 8->19 8->20 8->21 8->32 8->32 8->34 8->40 8->75 8->76 8->77 8->79 9->1 9->8 10->10 10->11 10->11 10->12 10->23 10->24 10->25 10->35 10->35 10->42 10->43 10->50 10->78 11->1 11->10 12->12 12->13 12->13 12->14 12->27 12->28 12->37 12->37 12->39 12->44 12->51 13->1 13->12 14->1 14->1 14->1 14->6 14->8 14->14 14->15 14->15 14->31 14->46 14->53 14->54 14->58 14->59 14->82 14->89 14->90 15->1 15->14 16->8 17->1 17->1 18->1 18->21 18->55 19->1 19->20 19->60 20->1 20->1 20->34 21->1 21->1 21->1 21->56 22->10 23->1 23->43 23->64 24->1 24->43 24->69 25->1 25->1 25->1 25->59 26->12 27->1 27->1 27->57 27->65 28->1 28->39 28->66 30->1 30->14 31->1 31->1 32->1 32->1 32->8 32->32 32->33 32->33 32->47 32->83 32->91 33->1 33->32 34->1 34->1 34->41 34->49 34->56 34->56 34->80 34->85 34->86 34->87 35->1 35->1 35->10 35->35 35->36 35->50 35->50 36->1 36->35 37->1 37->1 37->12 37->37 37->38 37->51 37->51 38->1 38->37 39->1 39->1 39->45 39->52 39->57 39->57 39->81 39->88 40->1 40->32 41->1 41->1 41->1 41->58 42->1 42->35 43->1 43->1 43->25 43->25 44->1 44->37 45->1 45->1 45->1 45->54 46->1 46->1 47->1 47->1 47->17 47->48 47->48 47->60 47->62 47->84 47->92 48->1 48->1 48->17 48->47 48->55 48->62 49->1 49->1 49->58 50->1 50->11 50->36 50->61 50->93 50->95 51->1 51->13 51->38 51->62 51->94 51->96 52->1 52->1 52->54 53->1 53->1 54->1 54->31 54->31 54->46 54->46 55->1 55->21 56->1 56->1 56->41 56->41 57->1 57->1 57->45 57->45 58->1 58->31 58->31 58->46 58->46 58->53 58->53 59->1 59->31 59->31 59->46 59->46 59->53 59->53 60->1 60->20 61->1 61->1 61->63 61->64 61->67 61->68 61->70 61->70 61->98 61->99 61->100 61->101 62->1 62->1 62->17 62->47 62->65 62->66 62->97 63->1 63->1 63->1 63->71 64->1 64->43 65->1 65->1 65->1 65->57 66->1 66->39 67->1 67->1 67->69 67->71 67->72 67->73 67->73 67->102 67->103 68->1 68->1 68->63 68->63 69->1 69->1 69->43 70->1 70->61 70->68 70->68 71->1 71->1 71->69 71->69 72->1 73->1 73->67 73->71 73->71 73->72 73->72
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int i , T , n , j , k , score , count , test ; char arr [ 100 ] [ 101 ] ; int nummatch [ 100 ] ; float tscore [ 100 ] , avwp ; float wp [ 100 ] ; float owp [ 100 ] ; float oowp [ 100 ] ; float sum ; scanf ( "\x25\x64\x0" , & T ) ; for ( i = 0 ; i < T ; i ++ ) { scanf ( "%d\n" , & n ) ; for ( j = 0 ; j < n ; j ++ ) { gets ( arr [ j ] ) ; score = 0 ; count = 0 ; for ( k = 0 ; k < n ; k ++ ) { if ( arr [ j ] [ k ] == '.' ) continue ; else count ++ ; if ( arr [ j ] [ k ] == '1' ) { score += 1.0 ; } } nummatch [ j ] = count ; tscore [ j ] = score ; if ( nummatch [ j ] > 0 ) wp [ j ] = tscore [ j ] / nummatch [ j ] ; else wp [ j ] = 0 ; } for ( j = 0 ; j < n ; j ++ ) { count = 0 ; avwp = 0 ; for ( k = 0 ; k < n ; k ++ ) { if ( k == j ) continue ; else { if ( arr [ k ] [ j ] != '.' ) { test = tscore [ k ] - ( arr [ k ] [ j ] - '0' ) ; if ( nummatch [ k ] > 1 ) avwp += test / ( float ) ( nummatch [ k ] - 1 ) ; count ++ ; } } } owp [ j ] = avwp / count ; } for ( j = 0 ; j < n ; j ++ ) { sum = 0 ; count = 0 ; for ( k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; else { if ( arr [ j ] [ k ] != '.' ) { sum += owp [ k ] ; count ++ ; } else continue ; } } if ( count > 0 ) oowp [ j ] = sum / count ; else oowp [ j ] = 0 ; } printf ( "Case #%d:\n" , i + 1 ) ; for ( j = 0 ; j < n ; j ++ ) { printf ( "%f\n" , 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ] ) ; } } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment EXAMPLE_LENGTH = 8
<operator>.assignment EXAMPLE [ ] = { 18   2   15   4   30   0   11   12 }
<operator>.assignment * RESULT = NULL
longestSub longestSub ( EXAMPLE , EXAMPLE_LENGTH , & RESULT , & RESULT_LENGTH )
printf printf ( "\x4c\x6f\x6e\x67\x65\x73\x74\x20\x53\x75\x62\x20\x53\x65\x71\x75\x65\x6e\x63\x65\x20\x6c\x65\x6e\x67\x74\x68\x3a\x20\x25\x64\x20\x61\x6e\x64\x20\x69\x74\x27\x73\x3a\x5c\x6e\x0" , RESULT_LENGTH )
printf printf ( "\n" )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < RESULT_LENGTH
<operator>.postIncrement i ++
printf printf ( "%d " , RESULT [ i ] )
LITERAL 0 return 0 ;
<operator>.arrayInitializer { 18   2   15   4   30   0   11   12 }
<operator>.assignment i = 0
<operator>.indirectIndexAccess RESULT [ i ]
>>>PDG&16 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 2->5 3->1 3->1 3->5 4->1 4->1 4->1 4->5 4->11 5->1 5->1 5->1 5->1 5->1 5->6 5->9 6->1 6->9 7->1 8->1 9->1 9->1 9->1 9->9 9->10 9->10 9->11 9->15 10->1 10->9 11->1 11->1 12->8 13->3 13->3 13->3 13->3 13->3 13->3 13->3 13->3 14->1 14->9
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { int EXAMPLE_LENGTH = 8 ; int EXAMPLE [ ] = { 18 , 2 , 15 , 4 , 30 , 0 , 11 , 12 } ; int * RESULT = NULL ; int RESULT_LENGTH , i ; longestSub ( EXAMPLE , EXAMPLE_LENGTH , & RESULT , & RESULT_LENGTH ) ; printf ( "\x4c\x6f\x6e\x67\x65\x73\x74\x20\x53\x75\x62\x20\x53\x65\x71\x75\x65\x6e\x63\x65\x20\x6c\x65\x6e\x67\x74\x68\x3a\x20\x25\x64\x20\x61\x6e\x64\x20\x69\x74\x27\x73\x3a\x5c\x6e\x0" , RESULT_LENGTH ) ; for ( i = 0 ; i < RESULT_LENGTH ; i ++ ) printf ( "%d " , RESULT [ i ] ) ; printf ( "\n" ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment array [ 'Q' - 'A' ] = 0
<operator>.assignment array [ 'W' - 'A' ] = 1
<operator>.assignment array [ 'E' - 'A' ] = 2
<operator>.assignment array [ 'R' - 'A' ] = 3
<operator>.assignment array [ 'A' - 'A' ] = 4
<operator>.assignment array [ 'S' - 'A' ] = 5
<operator>.assignment array [ 'D' - 'A' ] = 6
<operator>.assignment array [ 'F' - 'A' ] = 7
scanf scanf ( "\x25\x64\x0" , & testCases )
<operator>.lessThan i < 26
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= testCases
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment array [ i ] = - 1
<operator>.assignment i = 1
scanf scanf ( "%d" , & c )
scanf scanf ( "%d" , & d )
scanf scanf ( "%d" , & lenString )
scanf scanf ( "%s" , inputString )
<operator>.assignment pos = 0
printf printf ( "Case #%d: [" , i )
printf printf ( "]\n" )
<operator>.subtraction 'Q' - 'A'
<operator>.subtraction 'W' - 'A'
<operator>.subtraction 'E' - 'A'
<operator>.subtraction 'R' - 'A'
<operator>.subtraction 'A' - 'A'
<operator>.subtraction 'S' - 'A'
<operator>.subtraction 'D' - 'A'
<operator>.subtraction 'F' - 'A'
<operator>.lessThan j < c
<operator>.postIncrement j ++
<operator>.lessThan j < d
<operator>.postIncrement j ++
<operator>.lessThan j < lenString
<operator>.postIncrement j ++
<operator>.greaterThan pos > 0
<operator>.lessThan j < pos
<operator>.postIncrement j ++
<operator>.lessThan j < 8
<operator>.postIncrement j ++
<operator>.minus - 1
<operator>.assignment j = 0
scanf scanf ( "%s" , seq )
<operator>.assignment combine [ array [ seq [ 0 ] - 'A' ] ] [ array [ seq [ 1 ] - 'A' ] ] = seq [ 2 ]
<operator>.assignment combine [ array [ seq [ 1 ] - 'A' ] ] [ array [ seq [ 0 ] - 'A' ] ] = seq [ 2 ]
<operator>.assignment j = 0
scanf scanf ( "%s" , seq )
<operator>.assignment destruct [ array [ seq [ 0 ] - 'A' ] ] [ array [ seq [ 1 ] - 'A' ] ] = 1
<operator>.assignment destruct [ array [ seq [ 1 ] - 'A' ] ] [ array [ seq [ 0 ] - 'A' ] ] = 1
<operator>.assignment j = 0
<operator>.assignment flag = 1
printf printf ( "%c" , outputString [ 0 ] )
<operator>.assignment j = 1
printf printf ( ", %c" , outputString [ j ] )
<operator>.assignment j = 0
<operator>.logicalAnd pos > 0 && array [ outputString [ pos - 1 ] - 'A' ] != - 1
<operator>.lessThan k < pos
<operator>.postIncrement k ++
IDENTIFIER flag if (flag)
<operator>.lessThan k < 8
<operator>.postIncrement k ++
<operator>.assignment k = 0
<operator>.assignment outputString [ pos ++ ] = inputString [ j ]
<operator>.assignment k = 0
<operator>.assignment combine [ j ] [ k ] = 0
<operator>.assignment destruct [ j ] [ k ] = 0
<operator>.greaterThan pos > 0
<operator>.notEquals array [ outputString [ pos - 1 ] - 'A' ] != - 1
<operator>.assignment temp = combine [ array [ outputString [ pos - 1 ] - 'A' ] ] [ array [ inputString [ j ] - 'A' ] ]
<operator>.notEquals array [ outputString [ k ] - 'A' ] != - 1
<operator>.subtraction seq [ 1 ] - 'A'
<operator>.subtraction seq [ 0 ] - 'A'
<operator>.subtraction seq [ 1 ] - 'A'
<operator>.subtraction seq [ 0 ] - 'A'
<operator>.minus - 1
<operator>.assignment outputString [ pos - 1 ] = temp
<operator>.subtraction seq [ 0 ] - 'A'
<operator>.subtraction seq [ 1 ] - 'A'
<operator>.subtraction seq [ 0 ] - 'A'
<operator>.subtraction seq [ 1 ] - 'A'
<operator>.subtraction outputString [ pos - 1 ] - 'A'
<operator>.minus - 1
<operator>.postIncrement pos ++
<operator>.subtraction outputString [ k ] - 'A'
<operator>.assignment pos = 0
<operator>.assignment flag = 0
<operator>.subtraction pos - 1
<operator>.subtraction inputString [ j ] - 'A'
<operator>.subtraction pos - 1
<operator>.subtraction outputString [ pos - 1 ] - 'A'
<operator>.subtraction inputString [ j ] - 'A'
<operator>.subtraction outputString [ k ] - 'A'
<operator>.subtraction pos - 1
<operator>.indirectIndexAccess array [ i ]
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & lenString
<operator>.indirectIndexAccess combine [ array [ seq [ 0 ] - 'A' ] ] [ array [ seq [ 1 ] - 'A' ] ]
<operator>.indirectIndexAccess seq [ 2 ]
<operator>.indirectIndexAccess combine [ array [ seq [ 1 ] - 'A' ] ] [ array [ seq [ 0 ] - 'A' ] ]
<operator>.indirectIndexAccess seq [ 2 ]
<operator>.indirectIndexAccess destruct [ array [ seq [ 0 ] - 'A' ] ] [ array [ seq [ 1 ] - 'A' ] ]
<operator>.indirectIndexAccess destruct [ array [ seq [ 1 ] - 'A' ] ] [ array [ seq [ 0 ] - 'A' ] ]
<operator>.indirectIndexAccess outputString [ 0 ]
<operator>.indirectIndexAccess outputString [ j ]
<operator>.indirectIndexAccess combine [ array [ seq [ 0 ] - 'A' ] ]
<operator>.indirectIndexAccess array [ seq [ 1 ] - 'A' ]
<operator>.indirectIndexAccess combine [ array [ seq [ 1 ] - 'A' ] ]
<operator>.indirectIndexAccess array [ seq [ 0 ] - 'A' ]
<operator>.indirectIndexAccess destruct [ array [ seq [ 0 ] - 'A' ] ]
<operator>.indirectIndexAccess array [ seq [ 1 ] - 'A' ]
<operator>.indirectIndexAccess destruct [ array [ seq [ 1 ] - 'A' ] ]
<operator>.indirectIndexAccess array [ seq [ 0 ] - 'A' ]
<operator>.indirectIndexAccess array [ seq [ 0 ] - 'A' ]
<operator>.indirectIndexAccess array [ seq [ 1 ] - 'A' ]
<operator>.indirectIndexAccess array [ seq [ 0 ] - 'A' ]
<operator>.indirectIndexAccess array [ seq [ 1 ] - 'A' ]
<operator>.indirectIndexAccess array [ outputString [ pos - 1 ] - 'A' ]
<operator>.indirectIndexAccess outputString [ pos ++ ]
<operator>.indirectIndexAccess inputString [ j ]
<operator>.indirectIndexAccess combine [ j ] [ k ]
<operator>.indirectIndexAccess destruct [ j ] [ k ]
<operator>.indirectIndexAccess seq [ 1 ]
<operator>.indirectIndexAccess seq [ 0 ]
<operator>.indirectIndexAccess seq [ 1 ]
<operator>.indirectIndexAccess seq [ 0 ]
<operator>.indirectIndexAccess combine [ array [ outputString [ pos - 1 ] - 'A' ] ] [ array [ inputString [ j ] - 'A' ] ]
<operator>.indirectIndexAccess array [ outputString [ k ] - 'A' ]
<operator>.indirectIndexAccess combine [ j ]
<operator>.indirectIndexAccess destruct [ j ]
<operator>.indirectIndexAccess seq [ 0 ]
<operator>.indirectIndexAccess seq [ 1 ]
<operator>.indirectIndexAccess seq [ 0 ]
<operator>.indirectIndexAccess seq [ 1 ]
<operator>.indirectIndexAccess outputString [ pos - 1 ]
<operator>.indirectIndexAccess combine [ array [ outputString [ pos - 1 ] - 'A' ] ]
<operator>.indirectIndexAccess array [ inputString [ j ] - 'A' ]
<operator>.indirectIndexAccess outputString [ pos - 1 ]
<operator>.indirectIndexAccess destruct [ array [ outputString [ k ] - 'A' ] ] [ array [ inputString [ j ] - 'A' ] ]
<operator>.indirectIndexAccess array [ outputString [ pos - 1 ] - 'A' ]
<operator>.indirectIndexAccess outputString [ k ]
<operator>.indirectIndexAccess destruct [ array [ outputString [ k ] - 'A' ] ]
<operator>.indirectIndexAccess array [ inputString [ j ] - 'A' ]
<operator>.indirectIndexAccess inputString [ j ]
<operator>.indirectIndexAccess array [ outputString [ k ] - 'A' ]
<operator>.indirectIndexAccess outputString [ pos - 1 ]
<operator>.indirectIndexAccess inputString [ j ]
<operator>.indirectIndexAccess outputString [ k ]
>>>PDG&152 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->60 0->61 0->62 0->63 0->64 0->65 0->67 0->68 0->69 0->70 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 2->1 2->1 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 9->1 9->1 10->1 10->13 11->1 11->11 11->12 11->12 11->16 11->44 11->97 12->1 12->11 13->1 13->1 13->1 13->13 13->14 13->18 13->19 13->20 13->21 13->22 13->23 13->23 13->24 13->33 13->35 13->37 13->39 13->40 13->42 13->45 13->49 13->53 13->56 13->58 13->98 13->99 13->100 14->1 14->13 15->1 15->11 16->1 16->1 16->1 17->1 17->13 18->1 18->33 19->1 19->35 20->1 20->37 21->1 21->66 21->91 21->94 22->1 22->39 22->70 23->1 23->14 24->1 33->1 33->1 33->18 33->33 33->34 33->34 33->46 33->47 33->48 33->74 33->75 33->80 33->81 33->101 33->102 33->103 33->104 33->109 33->110 33->111 33->112 33->117 33->118 33->126 33->127 33->134 33->135 34->1 34->33 35->1 35->1 35->19 35->35 35->36 35->36 35->50 35->51 35->52 35->76 35->77 35->82 35->83 35->105 35->106 35->113 35->114 35->115 35->116 35->119 35->120 35->128 35->129 35->136 35->137 36->1 36->35 37->1 37->1 37->20 37->37 37->38 37->38 37->59 37->70 38->1 38->37 39->1 39->40 39->55 39->107 40->1 40->1 40->40 40->41 40->41 40->57 40->108 41->1 41->40 42->1 42->1 42->42 42->43 42->43 42->63 42->67 43->1 43->42 44->16 45->33 46->1 46->47 46->48 46->50 46->74 46->75 46->80 46->81 47->1 47->1 48->1 48->1 48->1 49->35 50->1 50->46 50->76 50->77 50->82 50->83 51->1 51->1 52->1 52->1 53->37 54->1 54->1 55->1 55->1 56->1 56->40 57->1 57->1 58->1 58->42 59->1 59->1 59->54 59->60 59->65 59->66 59->72 59->86 59->91 59->93 59->96 59->122 59->123 59->130 59->139 59->140 59->143 59->147 59->149 60->1 60->1 60->39 60->61 60->70 60->73 60->85 60->86 60->87 60->131 60->144 61->1 61->60 63->1 63->1 63->63 63->64 63->64 63->68 63->69 63->124 63->125 63->132 63->133 64->1 64->63 65->1 65->60 66->1 66->1 66->1 67->1 67->63 68->1 68->1 69->1 69->1 70->59 70->59 70->60 70->71 70->78 70->84 70->90 70->90 70->96 70->121 70->138 71->1 71->1 71->59 71->59 72->1 72->1 72->1 72->54 72->60 72->65 72->66 72->79 72->79 72->86 72->92 72->122 72->123 72->141 73->1 73->1 73->1 73->60 73->61 73->94 73->95 73->142 73->145 73->146 73->148 73->150 73->151 74->81 75->1 75->46 75->50 75->80 75->82 76->83 77->1 77->46 77->50 77->80 77->82 78->71 79->1 79->1 79->1 79->84 79->93 80->75 81->1 81->46 81->50 81->74 81->76 82->77 83->1 83->46 83->50 83->74 83->76 84->1 84->93 85->73 86->39 86->70 87->1 87->95 88->1 88->39 88->70 88->86 89->1 89->1 90->60 90->96 91->1 91->21 91->66 91->94 92->39 92->70 93->1 93->84 94->1 94->21 94->66 94->91 95->1 95->87 96->60 96->92 142->60 142->61 142->88 142->89
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int i , j , k , testCases ; int c , d ; char seq [ 10 ] ; char inputString [ 200 ] ; char outputString [ 200 ] ; int lenString , pos , flag ; char temp ; for ( i = 0 ; i < 26 ; i ++ ) { array [ i ] = - 1 ; } array [ 'Q' - 'A' ] = 0 ; array [ 'W' - 'A' ] = 1 ; array [ 'E' - 'A' ] = 2 ; array [ 'R' - 'A' ] = 3 ; array [ 'A' - 'A' ] = 4 ; array [ 'S' - 'A' ] = 5 ; array [ 'D' - 'A' ] = 6 ; array [ 'F' - 'A' ] = 7 ; scanf ( "\x25\x64\x0" , & testCases ) ; for ( i = 1 ; i <= testCases ; i ++ ) { scanf ( "%d" , & c ) ; for ( j = 0 ; j < c ; j ++ ) { scanf ( "%s" , seq ) ; combine [ array [ seq [ 0 ] - 'A' ] ] [ array [ seq [ 1 ] - 'A' ] ] = seq [ 2 ] ; combine [ array [ seq [ 1 ] - 'A' ] ] [ array [ seq [ 0 ] - 'A' ] ] = seq [ 2 ] ; } scanf ( "%d" , & d ) ; for ( j = 0 ; j < d ; j ++ ) { scanf ( "%s" , seq ) ; destruct [ array [ seq [ 0 ] - 'A' ] ] [ array [ seq [ 1 ] - 'A' ] ] = 1 ; destruct [ array [ seq [ 1 ] - 'A' ] ] [ array [ seq [ 0 ] - 'A' ] ] = 1 ; } scanf ( "%d" , & lenString ) ; scanf ( "%s" , inputString ) ; pos = 0 ; for ( j = 0 ; j < lenString ; j ++ ) { if ( pos > 0 && array [ outputString [ pos - 1 ] - 'A' ] != - 1 ) { if ( temp = combine [ array [ outputString [ pos - 1 ] - 'A' ] ] [ array [ inputString [ j ] - 'A' ] ] ) { outputString [ pos - 1 ] = temp ; continue ; } } flag = 1 ; for ( k = 0 ; k < pos ; k ++ ) { if ( array [ outputString [ k ] - 'A' ] != - 1 ) { if ( destruct [ array [ outputString [ k ] - 'A' ] ] [ array [ inputString [ j ] - 'A' ] ] ) { pos = 0 ; flag = 0 ; break ; } } } if ( flag ) { outputString [ pos ++ ] = inputString [ j ] ; } } printf ( "Case #%d: [" , i ) ; if ( pos > 0 ) { printf ( "%c" , outputString [ 0 ] ) ; } for ( j = 1 ; j < pos ; j ++ ) { printf ( ", %c" , outputString [ j ] ) ; } printf ( "]\n" ) ; for ( j = 0 ; j < 8 ; j ++ ) { for ( k = 0 ; k < 8 ; k ++ ) { combine [ j ] [ k ] = 0 ; destruct [ j ] [ k ] = 0 ; } } } }
>>>Func
METHOD binomial_heap_pop
METHOD_RETURN BinomialHeapValue
PARAM BinomialHeap * heap
<operator>.assignment least_index = UINT_MAX
<operator>.assignment least_tree = heap -> roots [ least_index ]
<operator>.assignment heap -> roots [ least_index ] = NULL
<operator>.assignment fake_heap . heap_type = heap -> heap_type
<operator>.assignment fake_heap . compare_func = heap -> compare_func
<operator>.assignment fake_heap . roots = least_tree -> subtrees
<operator>.assignment fake_heap . roots_length = least_tree -> order
<operator>.equals heap -> num_values == 0
<operator>.lessThan i < heap -> roots_length
<operator>.preIncrement ++ i
binomial_heap_merge binomial_heap_merge ( heap , & fake_heap )
RETURN return BINOMIAL_HEAP_NULL ; return BINOMIAL_HEAP_NULL ;
<operator>.assignment i = 0
<operator>.assignment result = least_tree -> value
binomial_tree_unref binomial_tree_unref ( least_tree )
<operator>.preDecrement -- heap -> num_values
RETURN return result ; return result ;
IDENTIFIER BINOMIAL_HEAP_NULL return BINOMIAL_HEAP_NULL ;
<operator>.equals heap -> roots [ i ] == NULL
<operator>.logicalOr least_index == UINT_MAX || binomial_heap_cmp ( heap , heap -> roots [ i ] -> value , heap -> roots [ least_index ] -> value ) < 0
IDENTIFIER result return result ;
<operator>.assignment heap -> roots [ least_index ] = least_tree
RETURN return BINOMIAL_HEAP_NULL ; return BINOMIAL_HEAP_NULL ;
<operator>.assignment least_index = i
IDENTIFIER BINOMIAL_HEAP_NULL return BINOMIAL_HEAP_NULL ;
<operator>.equals least_index == UINT_MAX
<operator>.lessThan binomial_heap_cmp ( heap , heap -> roots [ i ] -> value , heap -> roots [ least_index ] -> value ) < 0
binomial_heap_cmp binomial_heap_cmp ( heap , heap -> roots [ i ] -> value , heap -> roots [ least_index ] -> value )
<operator>.indirectIndexAccess heap -> roots [ least_index ]
<operator>.indirectIndexAccess heap -> roots [ least_index ]
<operator>.fieldAccess fake_heap . heap_type
<operator>.indirectFieldAccess heap -> heap_type
<operator>.fieldAccess fake_heap . compare_func
<operator>.indirectFieldAccess heap -> compare_func
<operator>.fieldAccess fake_heap . roots
<operator>.indirectFieldAccess least_tree -> subtrees
<operator>.fieldAccess fake_heap . roots_length
<operator>.indirectFieldAccess least_tree -> order
<operator>.indirectFieldAccess heap -> roots_length
<operator>.indirectFieldAccess heap -> roots
<operator>.indirectFieldAccess heap -> roots
FIELD_IDENTIFIER heap_type heap_type
FIELD_IDENTIFIER heap_type heap_type
FIELD_IDENTIFIER compare_func compare_func
FIELD_IDENTIFIER compare_func compare_func
FIELD_IDENTIFIER roots roots
FIELD_IDENTIFIER subtrees subtrees
FIELD_IDENTIFIER roots_length roots_length
FIELD_IDENTIFIER order order
<operator>.addressOf & fake_heap
FIELD_IDENTIFIER roots_length roots_length
FIELD_IDENTIFIER roots roots
FIELD_IDENTIFIER roots roots
<operator>.indirectFieldAccess least_tree -> value
<operator>.indirectFieldAccess heap -> num_values
<operator>.indirectIndexAccess heap -> roots [ i ]
FIELD_IDENTIFIER value value
FIELD_IDENTIFIER num_values num_values
<operator>.indirectIndexAccess heap -> roots [ least_index ]
<operator>.indirectFieldAccess heap -> roots
<operator>.indirectFieldAccess heap -> roots
FIELD_IDENTIFIER roots roots
<operator>.indirectFieldAccess heap -> roots [ i ] -> value
<operator>.indirectFieldAccess heap -> roots [ least_index ] -> value
FIELD_IDENTIFIER roots roots
<operator>.indirectIndexAccess heap -> roots [ i ]
FIELD_IDENTIFIER value value
<operator>.indirectIndexAccess heap -> roots [ least_index ]
FIELD_IDENTIFIER value value
<operator>.indirectFieldAccess heap -> roots
<operator>.indirectFieldAccess heap -> roots
FIELD_IDENTIFIER roots roots
FIELD_IDENTIFIER roots roots
>>>PDG&76 0->2 0->3 0->5 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 2->1 2->13 2->30 3->28 4->17 4->24 6->13 7->13 8->13 9->13 10->1 10->1 10->3 10->4 10->5 10->6 10->7 10->8 10->9 10->11 10->13 10->14 10->15 10->18 10->31 10->32 10->33 10->34 10->35 10->36 10->37 10->38 10->39 10->40 10->41 10->42 10->43 10->44 10->45 10->46 10->47 10->48 10->49 10->50 10->51 10->52 10->53 10->54 10->55 11->11 11->12 11->12 11->21 11->26 11->41 11->53 11->58 11->62 11->64 12->11 13->16 13->17 13->18 13->19 13->24 13->25 13->56 13->57 13->59 13->60 13->61 13->63 13->67 14->1 15->11 16->23 19->1 20->14 21->5 21->22 21->28 22->26 23->19 25->1 26->28 27->25 28->22 28->22 28->29 28->30 28->65 28->66 28->68 28->69 28->70 28->71 28->72 28->73 28->74 28->75 29->22 29->22 30->13 30->29 30->29 30->29
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) BinomialHeapValue binomial_heap_pop ( BinomialHeap * heap ) { BinomialTree * least_tree ; BinomialHeap fake_heap ; BinomialHeapValue result ; unsigned int i ; unsigned int least_index ; if ( heap -> num_values == 0 ) { return BINOMIAL_HEAP_NULL ; } least_index = UINT_MAX ; for ( i = 0 ; i < heap -> roots_length ; ++ i ) { if ( heap -> roots [ i ] == NULL ) { continue ; } if ( least_index == UINT_MAX || binomial_heap_cmp ( heap , heap -> roots [ i ] -> value , heap -> roots [ least_index ] -> value ) < 0 ) { least_index = i ; } } least_tree = heap -> roots [ least_index ] ; heap -> roots [ least_index ] = NULL ; fake_heap . heap_type = heap -> heap_type ; fake_heap . compare_func = heap -> compare_func ; fake_heap . roots = least_tree -> subtrees ; fake_heap . roots_length = least_tree -> order ; if ( binomial_heap_merge ( heap , & fake_heap ) ) { result = least_tree -> value ; binomial_tree_unref ( least_tree ) ; -- heap -> num_values ; return result ; } else { heap -> roots [ least_index ] = least_tree ; return BINOMIAL_HEAP_NULL ; } }
>>>Func
METHOD main
METHOD_RETURN int
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= t_case
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.expressionList scanf ( "\x25\x64\x0" , & t_case )   t = 1
scanf scanf ( "%d" , & n )
printf printf ( "Case #%d:\n" , t )
<operator>.lessThan i < n
<operator>.postIncrement i ++
scanf scanf ( "%s" , mat [ i ] )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
printf printf ( "%f\n" , 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ] )
scanf scanf ( "\x25\x64\x0" , & t_case )
<operator>.assignment t = 1
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment count [ i ] = 0
<operator>.assignment i = 0
<operator>.assignment win_count = 0
<operator>.assignment wp [ i ] = win_count * 1.0 / count [ i ]
<operator>.assignment i = 0
<operator>.assignment wp_count = 0
<operator>.assignment owp [ i ] = wp_count / count [ i ]
<operator>.assignment i = 0
<operator>.assignment owp_count = 0
<operator>.assignment oowp [ i ] = owp_count / count [ i ]
<operator>.assignment i = 0
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.addition 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ]
<operator>.assignment j = 0
<operator>.notEquals mat [ i ] [ j ] != '.'
<operator>.assignment j = 0
<operator>.equals mat [ i ] [ j ] == '1'
<operator>.division win_count * 1.0 / count [ i ]
<operator>.assignment j = 0
<operator>.notEquals mat [ i ] [ j ] != '.'
<operator>.division wp_count / count [ i ]
<operator>.assignment j = 0
<operator>.notEquals mat [ i ] [ j ] != '.'
<operator>.division owp_count / count [ i ]
<operator>.addition 0.25 * wp [ i ] + 0.5 * owp [ i ]
<operator>.multiplication 0.25 * oowp [ i ]
<operator>.postIncrement count [ i ] ++
<operator>.postIncrement win_count ++
<operator>.multiplication win_count * 1.0
<operator>.assignmentPlus wp_count += ( wp [ j ] * count [ j ] - ( mat [ i ] [ j ] == '0' ) ) / ( count [ j ] - 1 )
<operator>.assignmentPlus owp_count += owp [ j ]
<operator>.multiplication 0.25 * wp [ i ]
<operator>.multiplication 0.5 * owp [ i ]
<operator>.division ( wp [ j ] * count [ j ] - ( mat [ i ] [ j ] == '0' ) ) / ( count [ j ] - 1 )
<operator>.subtraction wp [ j ] * count [ j ] - ( mat [ i ] [ j ] == '0' )
<operator>.subtraction count [ j ] - 1
<operator>.multiplication wp [ j ] * count [ j ]
<operator>.equals mat [ i ] [ j ] == '0'
<operator>.addressOf & n
<operator>.indirectIndexAccess mat [ i ]
<operator>.indirectIndexAccess count [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess count [ i ]
<operator>.indirectIndexAccess count [ i ]
<operator>.indirectIndexAccess count [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess mat [ i ] [ j ]
<operator>.indirectIndexAccess mat [ i ] [ j ]
<operator>.indirectIndexAccess mat [ i ] [ j ]
<operator>.indirectIndexAccess mat [ i ] [ j ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess mat [ i ]
<operator>.indirectIndexAccess count [ i ]
<operator>.indirectIndexAccess mat [ i ]
<operator>.indirectIndexAccess mat [ i ]
<operator>.indirectIndexAccess mat [ i ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess count [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess count [ j ]
<operator>.indirectIndexAccess mat [ i ] [ j ]
<operator>.indirectIndexAccess mat [ i ]
>>>PDG&99 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->31 0->32 0->34 0->35 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->47 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->56 0->57 0->59 0->61 0->62 0->63 0->64 0->65 0->66 0->69 0->71 2->1 3->1 3->1 3->1 3->3 3->4 3->7 3->8 3->8 3->9 3->12 3->14 3->16 3->18 3->20 3->25 3->26 3->28 3->31 3->34 3->37 3->72 4->1 4->3 5->2 6->1 6->1 7->1 7->9 7->12 7->14 7->16 7->18 7->20 7->38 7->40 7->42 7->44 8->1 8->4 9->9 9->10 9->10 9->11 9->12 9->73 10->1 10->9 11->1 12->12 12->13 12->13 12->14 12->27 12->38 12->38 12->47 12->74 13->1 13->12 14->14 14->15 14->15 14->16 14->29 14->30 14->40 14->40 14->49 14->51 14->62 14->75 14->78 15->1 15->14 16->16 16->17 16->17 16->18 16->32 16->33 16->42 16->42 16->52 16->54 16->76 16->79 17->1 17->16 18->18 18->19 18->19 18->20 18->35 18->36 18->44 18->44 18->55 18->57 18->77 18->80 19->1 19->18 20->1 20->1 20->1 20->7 20->9 20->20 20->21 20->21 20->22 20->46 20->58 20->59 20->65 20->66 20->81 20->86 20->87 21->1 21->20 22->1 22->1 23->1 23->3 23->6 24->3 24->6 25->9 26->12 27->1 27->1 27->51 27->54 27->57 27->60 28->14 29->1 29->61 29->62 30->1 30->1 30->1 30->65 31->16 32->1 32->54 32->63 33->1 33->1 33->1 33->66 34->18 35->1 35->57 35->64 36->1 36->1 36->1 36->59 37->1 37->20 38->1 38->1 38->12 38->38 38->39 38->39 38->48 38->82 38->88 39->1 39->38 40->1 40->1 40->14 40->40 40->41 40->41 40->50 40->83 40->90 41->1 41->40 42->1 42->1 42->16 42->42 42->43 42->43 42->53 42->84 42->91 43->1 43->42 44->1 44->1 44->18 44->44 44->45 44->45 44->56 44->85 44->92 45->1 45->44 46->1 46->1 47->1 47->38 48->1 48->1 48->11 48->50 48->53 48->56 48->60 48->89 49->1 49->40 50->1 50->1 50->11 50->48 50->53 50->56 50->61 51->1 51->1 51->30 51->30 51->54 51->57 52->1 52->42 53->1 53->1 53->11 53->48 53->50 53->56 53->63 53->67 53->68 53->69 53->70 53->71 53->71 53->94 53->95 53->96 53->97 53->98 54->1 54->1 54->33 54->33 54->51 54->57 55->1 55->44 56->1 56->1 56->11 56->48 56->50 56->53 56->64 56->93 57->1 57->1 57->36 57->36 57->51 57->54 58->1 58->1 59->1 59->22 59->22 59->46 59->46 60->1 60->1 60->51 60->54 60->57 61->1 61->62 62->1 62->51 62->51 63->1 63->1 63->54 64->1 64->1 64->57 65->1 65->22 65->22 65->46 65->46 65->58 65->58 66->1 66->22 66->22 66->46 66->46 66->58 66->58 67->1 67->1 67->63 67->63 68->1 68->1 68->67 68->67 69->1 69->67 69->67 69->70 70->1 70->68 70->68 70->69 71->1 71->11 71->48 71->50 71->53 71->56 71->68 71->68
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int t , t_case ; for ( scanf ( "\x25\x64\x0" , & t_case ) , t = 1 ; t <= t_case ; t ++ ) { int n , i , j ; char mat [ MAX_N ] [ MAX_N ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%s" , mat [ i ] ) ; int count [ MAX_N ] ; float wp [ MAX_N ] , owp [ MAX_N ] , oowp [ MAX_N ] ; for ( i = 0 ; i < n ; i ++ ) { count [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) if ( mat [ i ] [ j ] != '.' ) count [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { int win_count = 0 ; for ( j = 0 ; j < n ; j ++ ) if ( mat [ i ] [ j ] == '1' ) win_count ++ ; wp [ i ] = win_count * 1.0 / count [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { float wp_count = 0 ; for ( j = 0 ; j < n ; j ++ ) if ( mat [ i ] [ j ] != '.' ) wp_count += ( wp [ j ] * count [ j ] - ( mat [ i ] [ j ] == '0' ) ) / ( count [ j ] - 1 ) ; owp [ i ] = wp_count / count [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { float owp_count = 0 ; for ( j = 0 ; j < n ; j ++ ) if ( mat [ i ] [ j ] != '.' ) owp_count += owp [ j ] ; oowp [ i ] = owp_count / count [ i ] ; } printf ( "Case #%d:\n" , t ) ; for ( i = 0 ; i < n ; i ++ ) printf ( "%f\n" , 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ] ) ; } return 0 ; }
>>>Func
METHOD binarySearch
METHOD_RETURN int
PARAM int * arr
PARAM int key
PARAM int low
PARAM int high
<operator>.assignment mid = low + ( high - 1 ) / 2
<operator>.greaterEqualsThan low >= high
<operator>.equals arr [ mid ] == key
RETURN return ( key > arr [ low ] ) ? ( low + 1 ) : low ; return ( key > arr [ low ] ) ? ( low + 1 ) : low ;
<operator>.addition low + ( high - 1 ) / 2
RETURN return mid + 1 ; return mid + 1 ;
<operator>.conditional ( key > arr [ low ] ) ? ( low + 1 ) : low
<operator>.division ( high - 1 ) / 2
<operator>.addition mid + 1
<operator>.subtraction high - 1
<operator>.greaterThan arr [ mid ] > key
<operator>.greaterThan key > arr [ low ]
<operator>.addition low + 1
RETURN return binarySearch ( arr , key , low , mid - 1 ) ; return binarySearch ( arr , key , low , mid - 1 ) ;
binarySearch binarySearch ( arr , key , low , mid - 1 )
RETURN return binarySearch ( arr , key , mid + 1 , high ) ; return binarySearch ( arr , key , mid + 1 , high ) ;
binarySearch binarySearch ( arr , key , mid + 1 , high )
<operator>.subtraction mid - 1
<operator>.addition mid + 1
<operator>.indirectIndexAccess arr [ mid ]
<operator>.indirectIndexAccess arr [ low ]
<operator>.indirectIndexAccess arr [ mid ]
>>>PDG&28 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->22 0->23 0->24 2->1 2->8 2->16 2->17 2->20 2->22 3->8 3->17 4->7 5->7 6->14 6->22 6->23 6->24 7->1 7->1 7->6 7->6 7->8 7->9 7->10 7->10 7->12 7->12 7->13 7->15 7->15 7->17 7->18 7->20 7->25 7->26 8->11 8->14 8->16 8->16 8->16 8->27 9->1 11->1 12->1 12->1 12->1 12->1 12->9 13->6 13->6 13->10 13->10 14->11 15->13 15->13 15->22 16->19 16->20 16->20 16->20 16->21 16->22 16->22 16->22 16->23 16->24 17->1 17->1 17->18 19->1 20->19 21->1 22->21 23->20 23->20
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int binarySearch ( int * arr , int key , int low , int high ) { if ( low >= high ) return ( key > arr [ low ] ) ? ( low + 1 ) : low ; int mid = low + ( high - 1 ) / 2 ; if ( arr [ mid ] == key ) return mid + 1 ; else if ( arr [ mid ] > key ) return binarySearch ( arr , key , low , mid - 1 ) ; else return binarySearch ( arr , key , mid + 1 , high ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * * argv
<operator>.assignment delta = 1
<operator>.assignment cdelta = 1
srand srand ( time ( NULL ) )
<operator>.assignment root = ( rand ( ) % 100 - 50 ) + ( rand ( ) % 100 - 50 ) * I
<operator>.assignment counter = 0
<operator>.assignment r = creal ( root )
<operator>.assignment c = fabs ( cimag ( root ) ) < ACCURACY ? 0 : cimag ( root )
printf printf ( "Iter %5lu: Root: %4.4g%c%4.4gi\t\tdelta: %.4g\n" , counter , r , c >= 0 ? '+' : '-' , c >= 0 ? c : - c , delta )
RETURN return 0 ; return 0 ;
<operator>.logicalAnd delta > ACCURACY && counter < ULONG_MAX
LITERAL 0 return 0 ;
time time ( NULL )
<operator>.addition ( rand ( ) % 100 - 50 ) + ( rand ( ) % 100 - 50 ) * I
<operator>.assignment cdelta = func ( root ) / d_func ( root )
<operator>.assignmentPlus root += - cdelta
<operator>.postIncrement counter ++
<operator>.assignment delta = fabs ( cabs ( cdelta ) )
<operator>.logicalOr defined ( DEBUG ) || ! defined ( NDEBUG ) <missing
IDENTIFIER ndif <empty>
creal creal ( root )
<operator>.conditional fabs ( cimag ( root ) ) < ACCURACY ? 0 : cimag ( root )
<operator>.conditional c >= 0 ? '+' : '-'
<operator>.conditional c >= 0 ? c : - c
<operator>.subtraction rand ( ) % 100 - 50
<operator>.multiplication ( rand ( ) % 100 - 50 ) * I
<operator>.greaterThan delta > ACCURACY
<operator>.lessThan counter < ULONG_MAX
<operator>.lessThan fabs ( cimag ( root ) ) < ACCURACY
cimag cimag ( root )
<operator>.greaterEqualsThan c >= 0
<operator>.greaterEqualsThan c >= 0
<operator>.minus - c
<operator>.modulo rand ( ) % 100
<operator>.subtraction rand ( ) % 100 - 50
<operator>.division func ( root ) / d_func ( root )
<operator>.minus - cdelta
fabs fabs ( cabs ( cdelta ) )
defined defined ( DEBUG )
<operator>.lessThan ! defined ( NDEBUG ) <missing
fabs fabs ( cimag ( root ) )
<operator>.modulo rand ( ) % 100
func func ( root )
d_func d_func ( root )
cabs cabs ( cdelta )
<operator>.logicalNot ! defined ( NDEBUG )
cimag cimag ( root )
defined defined ( NDEBUG )
UNKNOWN g g
UNKNOWN ';'> if ( counter % 50 == 0 ) { double r = creal ( root ) ; double c = cimag ( root ) ; printf ( "\x49\x74\x65\x72\x20\x25\x35\x6c\x75\x3a\x20\x52\x6f\x6f\x74\x3a\x20\x25\x34\x2e\x34\x67\x25\x63\x25\x34\x2e\x34\x67\x69\x5c\x74\x5c\x74\x64\x65\x6c\x74\x61\x3a\x20\x25\x2e\x34\x67\x5c\x6e\x0" , counter , r , c >= 0 ? '+' : '-' , c >= 0 ? c : - c , delta ) ; } ';'> if ( counter % 50 == 0 ) { double r = creal ( root ) ; double c = cimag ( root ) ; printf ( "\x49\x74\x65\x72\x20\x25\x35\x6c\x75\x3a\x20\x52\x6f\x6f\x74\x3a\x20\x25\x34\x2e\x34\x67\x25\x63\x25\x34\x2e\x34\x67\x69\x5c\x74\x5c\x74\x64\x65\x6c\x74\x61\x3a\x20\x25\x2e\x34\x67\x5c\x6e\x0" , counter , r , c >= 0 ? '+' : '-' , c >= 0 ? c : - c , delta ) ; }
UNKNOWN f f
>>>PDG&54 0->2 0->3 0->4 0->5 0->8 0->10 0->11 0->12 0->14 0->15 0->18 0->19 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->39 0->41 0->42 0->44 0->45 0->46 0->47 0->49 0->50 2->1 3->1 4->1 4->29 5->1 5->1 6->1 6->1 7->1 7->1 7->23 7->45 8->1 8->11 8->19 8->30 9->1 9->1 9->11 10->1 10->1 10->33 11->1 11->1 11->1 11->1 11->1 11->1 12->1 13->1 13->1 13->1 13->13 13->17 13->18 13->19 13->20 13->21 13->29 13->38 13->39 13->40 13->41 13->45 13->46 13->47 13->51 13->52 13->53 14->12 15->1 15->6 16->1 16->1 17->1 17->1 17->39 18->1 18->1 18->23 18->45 19->1 19->11 19->30 20->1 20->1 20->29 21->1 21->1 21->1 23->9 23->49 24->1 24->1 26->1 26->1 26->1 27->7 27->7 27->16 27->16 28->1 28->7 28->7 28->16 28->16 29->11 29->13 29->13 29->30 29->31 30->1 30->11 30->13 30->13 30->19 31->1 31->1 31->32 32->1 32->10 32->24 33->34 34->11 34->26 34->35 34->35 35->11 35->26 36->27 36->27 37->1 37->28 37->28 38->1 38->1 38->17 38->17 39->18 39->47 40->1 41->1 41->21 41->42 41->48 41->50 42->1 42->1 42->21 42->21 44->1 44->37 44->37 45->38 45->46 46->18 46->38 47->1 47->20 47->40 48->1 48->42 49->1 49->10 49->24 49->31 49->32 49->43 50->1 50->48
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * * argv ) { double delta = 1 ; double complex cdelta = 1 ; srand ( time ( NULL ) ) ; double complex root = ( rand ( ) % 100 - 50 ) + ( rand ( ) % 100 - 50 ) * I ; unsigned long counter = 0 ; while ( delta > ACCURACY && counter < ULONG_MAX ) { cdelta = func ( root ) / d_func ( root ) ; root += - cdelta ; counter ++ ; delta = fabs ( cabs ( cdelta ) ) ; defined ( DEBUG ) || ! defined ( NDEBUG ) <missing ';'> if ( counter % 50 == 0 ) { double r = creal ( root ) ; double c = cimag ( root ) ; printf ( "\x49\x74\x65\x72\x20\x25\x35\x6c\x75\x3a\x20\x52\x6f\x6f\x74\x3a\x20\x25\x34\x2e\x34\x67\x25\x63\x25\x34\x2e\x34\x67\x69\x5c\x74\x5c\x74\x64\x65\x6c\x74\x61\x3a\x20\x25\x2e\x34\x67\x5c\x6e\x0" , counter , r , c >= 0 ? '+' : '-' , c >= 0 ? c : - c , delta ) ; } ndif } double r = creal ( root ) ; double c = fabs ( cimag ( root ) ) < ACCURACY ? 0 : cimag ( root ) ; printf ( "Iter %5lu: Root: %4.4g%c%4.4gi\t\tdelta: %.4g\n" , counter , r , c >= 0 ? '+' : '-' , c >= 0 ? c : - c , delta ) ; return 0 ; }
>>>Func
METHOD OWP
METHOD_RETURN void
<operator>.lessThan i < n
<operator>.preIncrement ++ i
<operator>.assignment i = 0
<operator>.assignment temp = 0
<operator>.assignment num = 0
<operator>.assignment owp [ i ] = temp / ( double ) ( num )
<operator>.lessThan j < n
<operator>.preIncrement ++ j
<operator>.assignment j = 0
<operator>.division temp / ( double ) ( num )
<operator>.equals table [ i ] [ j ] == '1'
<operator>.cast ( double ) ( num )
<operator>.assignmentPlus temp += ( double ) ( wp [ j ] [ 0 ] ) / ( double ) ( wp [ j ] [ 1 ] - 1 )
<operator>.postIncrement num ++
<operator>.division ( double ) ( wp [ j ] [ 0 ] ) / ( double ) ( wp [ j ] [ 1 ] - 1 )
<operator>.equals table [ i ] [ j ] == '0'
<operator>.cast ( double ) ( wp [ j ] [ 0 ] )
<operator>.cast ( double ) ( wp [ j ] [ 1 ] - 1 )
<operator>.assignmentPlus temp += ( double ) ( wp [ j ] [ 0 ] - 1 ) / ( double ) ( wp [ j ] [ 1 ] - 1 )
<operator>.postIncrement num ++
<operator>.subtraction wp [ j ] [ 1 ] - 1
<operator>.division ( double ) ( wp [ j ] [ 0 ] - 1 ) / ( double ) ( wp [ j ] [ 1 ] - 1 )
<operator>.cast ( double ) ( wp [ j ] [ 0 ] - 1 )
<operator>.cast ( double ) ( wp [ j ] [ 1 ] - 1 )
<operator>.subtraction wp [ j ] [ 0 ] - 1
<operator>.subtraction wp [ j ] [ 1 ] - 1
<operator>.indirectIndexAccess owp [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess table [ i ] [ j ]
<operator>.indirectIndexAccess table [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess wp [ j ] [ 0 ]
UNKNOWN double double
<operator>.indirectIndexAccess table [ i ] [ j ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess wp [ j ] [ 1 ]
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess wp [ j ]
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess wp [ j ] [ 0 ]
<operator>.indirectIndexAccess wp [ j ] [ 1 ]
<operator>.indirectIndexAccess wp [ j ]
<operator>.indirectIndexAccess wp [ j ]
>>>PDG&46 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->20 0->21 0->22 0->26 0->27 2->1 2->1 2->1 2->2 2->3 2->3 2->5 2->6 2->7 2->8 2->8 2->10 2->11 2->13 2->28 2->29 3->1 3->2 4->1 4->2 5->1 5->11 5->14 5->20 6->1 6->11 6->13 6->15 6->21 7->1 7->1 7->1 8->1 8->1 8->2 8->8 8->9 8->9 8->12 8->30 8->31 9->1 9->8 10->1 10->8 11->1 11->1 11->7 11->7 12->1 12->1 12->14 12->15 12->16 12->17 12->17 12->18 12->19 12->22 12->32 12->33 12->34 12->35 12->36 12->37 12->38 12->39 13->1 14->1 14->1 14->11 14->20 15->1 15->11 15->13 15->21 16->1 16->1 16->14 16->14 17->1 17->1 17->12 17->20 17->21 17->23 17->24 17->25 17->26 17->27 17->40 17->41 17->42 17->43 17->44 17->45 18->1 19->1 20->1 20->1 20->11 20->14 21->1 21->11 21->13 21->15 22->1 22->16 22->16 22->19 22->19 22->27 23->1 23->1 23->20 23->20 24->1 25->1 26->1 26->16 26->18 26->23 26->23 26->24 26->24 27->1 27->22 27->23 27->23 27->25 27->25
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void OWP ( ) { int i , j ; int up , down ; double temp ; int num ; for ( i = 0 ; i < n ; ++ i ) { temp = 0 ; num = 0 ; for ( j = 0 ; j < n ; ++ j ) { if ( table [ i ] [ j ] == '1' ) { temp += ( double ) ( wp [ j ] [ 0 ] ) / ( double ) ( wp [ j ] [ 1 ] - 1 ) ; num ++ ; } else if ( table [ i ] [ j ] == '0' ) { temp += ( double ) ( wp [ j ] [ 0 ] - 1 ) / ( double ) ( wp [ j ] [ 1 ] - 1 ) ; num ++ ; } } owp [ i ] = temp / ( double ) ( num ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment * in_fp = NULL
<operator>.assignment * out_fp = NULL
<operator>.assignment in_fp = fopen ( argv [ 1 ] , "r" )
ERRCHK ERRCHK ( in_fp )
<operator>.assignment out_fp = fopen ( "output.txt" , "w" )
ERRCHK ERRCHK ( out_fp )
fscanf fscanf ( in_fp , "%d" , & numCases )
<operator>.lessThan LOOP ( counter , numCases ) <missing
fclose fclose ( out_fp )
fclose fclose ( in_fp )
RETURN return 0 ; return 0 ;
<operator>.notEquals argc != 2
LITERAL 0 return 0 ;
ERR ERR ( "\x49\x6e\x63\x6f\x72\x72\x65\x63\x74\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x63\x6f\x6d\x6d\x61\x6e\x64\x20\x6c\x69\x6e\x65\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x2c\x20\x65\x78\x69\x74\x69\x6e\x67\x2e\x2e\x2e\x5c\x6e\x0" )
RETURN return 1 ; return 1 ;
fopen fopen ( argv [ 1 ] , "r" )
fopen fopen ( "output.txt" , "w" )
LOOP LOOP ( counter , numCases )
LITERAL 1 return 1 ;
UNKNOWN g g
UNKNOWN ';'> { possible = 0 ; FIN ( "%lld%d%d" , & N , & pd , & pg ) ; frac = pd / 100.0 ; ERR ( "frac: %f\n" , frac ) ; for ( i = 1 ; i <= N ; i ++ ) { temp = frac * i ; ERR ( "%f == %f?\n"   temp   floor ( temp ) ) ; if ( temp == floor ( temp ) ) possible = 1 ; } if ( pg == 100 && pd != 100 ) possible = 0 ; if ( pg == 0 && pd != 0 ) possible = 0 ; if ( possible ) FOUT ( "Case #%d: Possible\n" , counter + 1 ) ; else FOUT ( "Case #%d: Broken\n" , counter + 1 ) ; } ';'> { possible = 0 ; FIN ( "%lld%d%d" , & N , & pd , & pg ) ; frac = pd / 100.0 ; ERR ( "frac: %f\n" , frac ) ; for ( i = 1 ; i <= N ; i ++ ) { temp = frac * i ; ERR ( "%f == %f?\n"   temp   floor ( temp ) ) ; if ( temp == floor ( temp ) ) possible = 1 ; } if ( pg == 100 && pd != 100 ) possible = 0 ; if ( pg == 0 && pd != 0 ) possible = 0 ; if ( possible ) FOUT ( "Case #%d: Possible\n" , counter + 1 ) ; else FOUT ( "Case #%d: Broken\n" , counter + 1 ) ; }
<operator>.addressOf & numCases
<operator>.indirectIndexAccess argv [ 1 ]
>>>PDG&27 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 2->15 3->1 3->19 4->1 4->1 5->1 5->1 5->1 6->7 7->10 8->9 9->12 10->13 10->21 11->1 14->1 15->1 15->1 15->6 15->7 15->8 15->9 15->10 15->11 15->12 15->13 15->14 15->17 15->18 15->19 15->20 15->21 15->23 15->24 15->25 15->26 16->14 17->1 18->1 19->6 19->6 20->8 20->8 21->11 21->11 22->18
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( int argc , char * argv [ ] ) { FILE * in_fp = NULL ; FILE * out_fp = NULL ; int i , j , k , counter ; int numCases ; long long int N ; int pg , pd ; int possible ; float frac ; float temp ; if ( argc != 2 ) { ERR ( "\x49\x6e\x63\x6f\x72\x72\x65\x63\x74\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x63\x6f\x6d\x6d\x61\x6e\x64\x20\x6c\x69\x6e\x65\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x2c\x20\x65\x78\x69\x74\x69\x6e\x67\x2e\x2e\x2e\x5c\x6e\x0" ) ; return 1 ; } in_fp = fopen ( argv [ 1 ] , "r" ) ; ERRCHK ( in_fp ) ; out_fp = fopen ( "output.txt" , "w" ) ; ERRCHK ( out_fp ) ; fscanf ( in_fp , "%d" , & numCases ) ; LOOP ( counter , numCases ) <missing ';'> { possible = 0 ; FIN ( "%lld%d%d" , & N , & pd , & pg ) ; frac = pd / 100.0 ; ERR ( "frac: %f\n" , frac ) ; for ( i = 1 ; i <= N ; i ++ ) { temp = frac * i ; ERR ( "%f == %f?\n" , temp , floor ( temp ) ) ; if ( temp == floor ( temp ) ) possible = 1 ; } if ( pg == 100 && pd != 100 ) possible = 0 ; if ( pg == 0 && pd != 0 ) possible = 0 ; if ( possible ) FOUT ( "Case #%d: Possible\n" , counter + 1 ) ; else FOUT ( "Case #%d: Broken\n" , counter + 1 ) ; } fclose ( out_fp ) ; fclose ( in_fp ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment n1 = argv [ 1 ] [ 0 ]
<operator>.assignment n2 = argv [ 2 ] [ 0 ]
<operator>.assignment gcd = findgcd ( n1 , n2 )
printf printf ( "\x47\x43\x44\x20\x6f\x66\x20\x25\x64\x20\x61\x6e\x64\x20\x25\x64\x20\x69\x73\x3a\x20\x25\x64\x5c\x6e\x0" , n1 , n2 , gcd )
RETURN return 0 ; return 0 ;
<operator>.lessThan argc < 3
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
findgcd findgcd ( n1 , n2 )
LITERAL 1 return 1 ;
<operator>.indirectIndexAccess argv [ 1 ] [ 0 ]
<operator>.indirectIndexAccess argv [ 2 ] [ 0 ]
<operator>.indirectIndexAccess argv [ 1 ]
<operator>.indirectIndexAccess argv [ 2 ]
>>>PDG&18 0->2 0->3 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->9 3->1 4->12 5->12 6->7 8->1 9->1 9->1 9->4 9->5 9->6 9->7 9->8 9->11 9->12 9->14 9->15 9->16 9->17 10->8 11->1 12->6 12->6 12->7 12->7 13->11
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * argv [ ] ) { if ( argc < 3 ) return 1 ; int n1 , n2 , gcd ; n1 = argv [ 1 ] [ 0 ] ; n2 = argv [ 2 ] [ 0 ] ; gcd = findgcd ( n1 , n2 ) ; printf ( "\x47\x43\x44\x20\x6f\x66\x20\x25\x64\x20\x61\x6e\x64\x20\x25\x64\x20\x69\x73\x3a\x20\x25\x64\x5c\x6e\x0" , n1 , n2 , gcd ) ; return 0 ; }
>>>Func
METHOD mrand_01
METHOD_RETURN double
PARAM void
<operator>.assignment _tls_mrand_x [ _tls_mrand_cur ] = _tls_mrand_x [ _tls_mrand_cur ] ^ _tls_mrand_x [ _tls_mrand_cur2 - 32 ]
<operator>.assignment d = _tls_mrand_x [ _tls_mrand_cur ] * SYS_MRAND_E32
<operator>.postIncrement _tls_mrand_cur ++
<operator>.postIncrement _tls_mrand_cur2 ++
RETURN return d ; return d ;
<operator>.equals _tls_mrand_init_flag == FALSE
<operator>.equals _tls_mrand_cur == 521
<operator>.equals _tls_mrand_cur2 == 553
IDENTIFIER d return d ;
<operator>.assignment _tls_mrand_x [ 0 ] = SYS_MRAND_A * SYS_MRAND_X0
<operator>.assignment _tls_mrand_init_flag = TRUE
<operator>.assignment _tls_mrand_cur = 0
<operator>.assignment _tls_mrand_cur2 = 521
<operator>.xor _tls_mrand_x [ _tls_mrand_cur ] ^ _tls_mrand_x [ _tls_mrand_cur2 - 32 ]
<operator>.multiplication _tls_mrand_x [ _tls_mrand_cur ] * SYS_MRAND_E32
<operator>.assignment _tls_mrand_cur = 0
<operator>.assignment _tls_mrand_cur2 = 32
<operator>.lessThan i < 521
<operator>.postIncrement i ++
<operator>.multiplication SYS_MRAND_A * SYS_MRAND_X0
<operator>.assignment i = 1
<operator>.assignment _tls_mrand_x [ i ] = SYS_MRAND_A * _tls_mrand_x [ i - 1 ]
<operator>.subtraction _tls_mrand_cur2 - 32
<operator>.multiplication SYS_MRAND_A * _tls_mrand_x [ i - 1 ]
<operator>.subtraction i - 1
<operator>.indirectIndexAccess _tls_mrand_x [ 0 ]
<operator>.indirectIndexAccess _tls_mrand_x [ i ]
<operator>.indirectIndexAccess _tls_mrand_x [ i - 1 ]
>>>PDG&31 0->2 0->5 0->6 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 2->1 3->1 3->1 3->17 4->1 4->1 4->1 4->11 5->1 5->9 6->1 6->10 7->1 8->1 8->1 8->1 8->12 8->13 8->14 8->15 8->20 8->22 8->23 8->28 9->1 9->1 9->18 10->1 10->1 10->19 11->7 12->1 12->1 12->1 13->1 13->1 13->1 14->1 14->5 15->1 15->25 16->1 16->3 16->3 17->1 17->1 17->4 17->4 18->1 18->1 19->1 19->1 20->1 20->1 20->20 20->21 20->24 20->26 20->27 20->27 20->29 20->30 21->1 21->20 22->1 22->1 22->12 22->12 22->26 23->1 23->20 24->1 24->1 24->1 25->6 26->1 26->1 26->24 26->24 27->21
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) double mrand_01 ( void ) { int32_t i ; double d ; if ( _tls_mrand_init_flag == FALSE ) { _tls_mrand_x [ 0 ] = SYS_MRAND_A * SYS_MRAND_X0 ; for ( i = 1 ; i < 521 ; i ++ ) { _tls_mrand_x [ i ] = SYS_MRAND_A * _tls_mrand_x [ i - 1 ] ; } _tls_mrand_init_flag = TRUE ; _tls_mrand_cur = 0 ; _tls_mrand_cur2 = 521 ; } _tls_mrand_x [ _tls_mrand_cur ] = _tls_mrand_x [ _tls_mrand_cur ] ^ _tls_mrand_x [ _tls_mrand_cur2 - 32 ] ; d = _tls_mrand_x [ _tls_mrand_cur ] * SYS_MRAND_E32 ; _tls_mrand_cur ++ ; _tls_mrand_cur2 ++ ; if ( _tls_mrand_cur == 521 ) { _tls_mrand_cur = 0 ; } if ( _tls_mrand_cur2 == 553 ) { _tls_mrand_cur2 = 32 ; } return d ; }
>>>Func
METHOD Time2Int
METHOD_RETURN int
PARAM string str
StringSplit2Int StringSplit2Int ( str , "\x3a\x0" , tmp_int )
RETURN return ( ( tmp_int [ 0 ] * 60 ) + tmp_int [ 1 ] ) ; return ( ( tmp_int [ 0 ] * 60 ) + tmp_int [ 1 ] ) ;
<operator>.addition ( tmp_int [ 0 ] * 60 ) + tmp_int [ 1 ]
<operator>.multiplication tmp_int [ 0 ] * 60
>>>PDG&7 0->2 0->3 0->6 2->3 3->1 3->1 3->1 3->5 3->6 4->1 5->1 5->1 5->1 5->4 6->1 6->5 6->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int Time2Int ( string str ) { vector < <missing ';'> int > tmp_int ; StringSplit2Int ( str , "\x3a\x0" , tmp_int ) ; return ( ( tmp_int [ 0 ] * 60 ) + tmp_int [ 1 ] ) ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x69\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan test <= T
<operator>.postIncrement test ++
LITERAL 0 return 0 ;
<operator>.assignment test = 1
scanf scanf ( "%i %i %i %i" , & l , & t , & n , & c )
printf printf ( "Case #%i: %i\n" , test , dp [ n ] [ l ] )
<operator>.lessThan i < c
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= n
<operator>.postIncrement i ++
<operator>.assignment i = 0
scanf scanf ( "%i" , & a )
<operator>.assignment i = 1
<operator>.lessThan j * c + i < n
<operator>.postIncrement j ++
<operator>.assignment tabel [ j * c + i + 1 ] = a
<operator>.lessEqualsThan j <= l
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + 2 * tabel [ i ]
<operator>.addition j * c + i
<operator>.greaterEqualsThan j >= 1
<operator>.multiplication j * c
<operator>.addition j * c + i + 1
<operator>.addition dp [ i - 1 ] [ j ] + 2 * tabel [ i ]
<operator>.assignment m = dp [ i - 1 ] [ j - 1 ]
<operator>.assignment dt = t - m
<operator>.assignmentPlus m += tabel [ i ]
<operator>.addition j * c + i
<operator>.multiplication 2 * tabel [ i ]
<operator>.greaterThan dt > 0
<operator>.lessThan m < dp [ i ] [ j ]
<operator>.multiplication j * c
<operator>.subtraction t - m
assert assert ( dt % 2 == 0 )
<operator>.assignmentPlus m += dt / 2
<operator>.assignment dp [ i ] [ j ] = m
<operator>.subtraction i - 1
<operator>.subtraction j - 1
<operator>.subtraction i - 1
<operator>.equals dt % 2 == 0
<operator>.division dt / 2
<operator>.modulo dt % 2
<operator>.addressOf & l
<operator>.addressOf & t
<operator>.addressOf & n
<operator>.addressOf & c
<operator>.indirectIndexAccess dp [ n ] [ l ]
<operator>.indirectIndexAccess dp [ n ]
<operator>.addressOf & a
<operator>.indirectIndexAccess tabel [ j * c + i + 1 ]
<operator>.indirectIndexAccess dp [ i ] [ j ]
<operator>.indirectIndexAccess dp [ i ]
<operator>.indirectIndexAccess dp [ i - 1 ] [ j ]
<operator>.indirectIndexAccess dp [ i - 1 ]
<operator>.indirectIndexAccess tabel [ i ]
<operator>.indirectIndexAccess dp [ i - 1 ] [ j - 1 ]
<operator>.indirectIndexAccess tabel [ i ]
<operator>.indirectIndexAccess dp [ i - 1 ]
<operator>.indirectIndexAccess dp [ i ] [ j ]
<operator>.indirectIndexAccess dp [ i ]
<operator>.indirectIndexAccess dp [ i ] [ j ]
<operator>.indirectIndexAccess dp [ i ]
>>>PDG&68 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->9 4->10 4->12 4->14 4->16 4->48 4->49 4->50 4->51 4->52 4->53 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->1 8->20 9->1 9->1 9->5 10->1 10->1 10->10 10->11 10->11 10->15 10->17 10->17 10->22 10->25 10->25 10->27 10->27 10->54 11->1 11->10 12->1 12->1 12->1 12->12 12->13 12->13 12->17 12->20 12->23 12->42 13->1 13->12 14->1 14->10 15->1 15->19 16->1 16->12 17->1 17->1 17->12 17->17 17->18 17->19 17->25 17->27 17->28 17->33 17->37 17->55 18->1 18->27 19->1 19->1 19->1 20->1 20->1 20->1 20->8 20->20 20->21 20->24 20->26 20->26 20->29 20->34 20->42 20->56 20->57 20->58 20->59 20->60 21->1 21->20 22->1 22->27 23->1 23->20 24->1 24->1 24->1 24->36 25->1 26->1 26->21 26->30 26->31 26->32 26->35 26->36 26->38 26->43 26->43 26->44 26->61 26->62 26->63 26->64 26->65 27->1 27->10 27->17 27->17 27->25 27->25 27->37 27->37 29->1 29->1 30->1 30->1 30->38 31->1 31->1 31->35 32->1 32->1 32->36 32->40 34->1 34->24 34->24 34->29 34->29 34->32 35->1 35->1 35->39 35->40 35->45 35->46 35->47 35->47 36->1 36->1 36->1 36->41 36->41 36->66 36->67 37->18 37->27 37->28 37->28 37->33 37->33 38->1 38->31 38->31 38->32 39->1 39->1 40->1 40->1 40->36 41->1 41->1 41->1 42->13 42->44 43->21 44->13 44->42 45->1 45->39 45->39 46->1 46->40 46->40 47->45 47->45 47->46
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T ; scanf ( "\x25\x69\x0" , & T ) ; for ( int test = 1 ; test <= T ; test ++ ) { scanf ( "%i %i %i %i" , & l , & t , & n , & c ) ; for ( int i = 0 ; i < c ; i ++ ) { int a ; scanf ( "%i" , & a ) ; for ( int j = 0 ; j * c + i < n ; j ++ ) tabel [ j * c + i + 1 ] = a ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= l ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + 2 * tabel [ i ] ; if ( j >= 1 ) { int m = dp [ i - 1 ] [ j - 1 ] ; int dt = t - m ; m += tabel [ i ] ; if ( dt > 0 ) { assert ( dt % 2 == 0 ) ; m += dt / 2 ; } if ( m < dp [ i ] [ j ] ) dp [ i ] [ j ] = m ; } } } printf ( "Case #%i: %i\n" , test , dp [ n ] [ l ] ) ; } return 0 ; }
>>>Func
METHOD checkIO
METHOD_RETURN void
fileread fileread ( & numdataset , DataSet )
printf printf ( "\x5c\x6e\x20\x2a\x2a\x2a\x20\x63\x68\x65\x63\x6b\x49\x4f\x20\x3a\x20\x52\x65\x61\x64\x44\x61\x74\x61\x73\x65\x74\x20\x3d\x20\x25\x64\x5c\x6e\x0" , numdataset )
filewrite filewrite ( numdataset , DataSet )
>>>PDG&5 0->2 0->3 0->4 2->1 2->1 2->3 2->4 2->4 3->1 3->4 4->1 4->1 4->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void checkIO ( ) { int numdataset ; TypeDataSet DataSet [ MAX_DATASET ] ; fileread ( & numdataset , DataSet ) ; printf ( "\x5c\x6e\x20\x2a\x2a\x2a\x20\x63\x68\x65\x63\x6b\x49\x4f\x20\x3a\x20\x52\x65\x61\x64\x44\x61\x74\x61\x73\x65\x74\x20\x3d\x20\x25\x64\x5c\x6e\x0" , numdataset ) ; filewrite ( numdataset , DataSet ) ; }
>>>Func
METHOD xmalloc
METHOD_RETURN void*
PARAM int size
<operator>.assignment * m = malloc ( size )
RETURN return m ; return m ;
<operator>.equals m == 0
IDENTIFIER m return m ;
malloc malloc ( size )
printf printf ( "\x43\x6f\x75\x6c\x64\x20\x6e\x6f\x74\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x20\x25\x64\x20\x62\x79\x74\x65\x73\x0" , size )
fflush fflush ( stdout )
exit exit ( EXIT_FAILURE )
>>>PDG&11 0->2 0->5 0->6 0->7 0->8 0->9 0->10 2->7 3->1 3->1 3->5 4->1 5->1 5->1 5->6 5->8 5->9 5->10 6->4 7->1 7->3 7->8 8->1 8->1 9->1 9->1 10->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void * xmalloc ( int size ) { void * m = malloc ( size ) ; if ( m == 0 ) { printf ( "\x43\x6f\x75\x6c\x64\x20\x6e\x6f\x74\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x20\x25\x64\x20\x62\x79\x74\x65\x73\x0" , size ) ; fflush ( stdout ) ; exit ( EXIT_FAILURE ) ; } return m ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment cse = 0
scanf scanf ( "\x25\x64\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.postDecrement t --
LITERAL 0 return 0 ;
<operator>.postIncrement cse ++
<operator>.assignment sp = - 1
memset memset ( com , 0 , sizeof com )
memset memset ( opp , 0 , sizeof opp )
scanf scanf ( "%d" , & c )
scanf scanf ( "%d" , & d )
scanf scanf ( "%d" , & n )
scanf scanf ( "%s" , s )
<operator>.assignment final [ ++ sp ] = s [ 0 ]
printf printf ( "Case #%d: " , cse )
print print ( final , sp )
<operator>.lessThan i < c
<operator>.postIncrement i ++
<operator>.lessThan i < d
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.minus - 1
<operator>.assignment i = 0
scanf scanf ( "%s" , s )
<operator>.assignment com [ s [ 0 ] - 'A' ] [ s [ 1 ] - 'A' ] = s [ 2 ]
<operator>.assignment com [ s [ 1 ] - 'A' ] [ s [ 0 ] - 'A' ] = s [ 2 ]
<operator>.assignment i = 0
scanf scanf ( "%s" , s )
<operator>.assignment el = s [ 0 ] - 'A'
<operator>.assignment pel = s [ 1 ] - 'A'
<operator>.assignment opp [ el ] [ pel ] = 1
<operator>.assignment opp [ pel ] [ el ] = 1
<operator>.assignment i = 1
<operator>.assignment el = s [ i ] - 'A'
<operator>.assignment cd = 0
<operator>.preIncrement ++ sp
<operator>.greaterEqualsThan sp >= 0
<operator>.subtraction s [ 0 ] - 'A'
<operator>.subtraction s [ 1 ] - 'A'
<operator>.subtraction s [ i ] - 'A'
<operator>.assignment pel = final [ sp ] - 'A'
<operator>.subtraction s [ 1 ] - 'A'
<operator>.subtraction s [ 0 ] - 'A'
<operator>.notEquals com [ el ] [ pel ] != 0
<operator>.equals cd == 0
<operator>.assignment final [ ++ sp ] = s [ i ]
<operator>.subtraction s [ 0 ] - 'A'
<operator>.subtraction s [ 1 ] - 'A'
<operator>.subtraction final [ sp ] - 'A'
<operator>.assignment final [ sp ] = com [ el ] [ pel ]
<operator>.assignment cd = 1
<operator>.assignment final [ ++ sp ] = s [ i ]
<operator>.lessEqualsThan j <= sp
<operator>.postIncrement j ++
<operator>.preIncrement ++ sp
<operator>.assignment j = 0
<operator>.preIncrement ++ sp
<operator>.equals opp [ final [ j ] - 'A' ] [ el ] == 1
<operator>.assignment sp = - 1
<operator>.assignment cd = 1
<operator>.minus - 1
<operator>.subtraction final [ j ] - 'A'
<operator>.sizeOf sizeof com
<operator>.sizeOf sizeof opp
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.indirectIndexAccess final [ ++ sp ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess com [ s [ 0 ] - 'A' ] [ s [ 1 ] - 'A' ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess com [ s [ 1 ] - 'A' ] [ s [ 0 ] - 'A' ]
<operator>.indirectIndexAccess s [ 2 ]
<operator>.indirectIndexAccess opp [ el ] [ pel ]
<operator>.indirectIndexAccess opp [ pel ] [ el ]
<operator>.indirectIndexAccess com [ s [ 0 ] - 'A' ]
<operator>.indirectIndexAccess com [ s [ 1 ] - 'A' ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess opp [ el ]
<operator>.indirectIndexAccess opp [ pel ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 0 ]
<operator>.indirectIndexAccess s [ 1 ]
<operator>.indirectIndexAccess final [ sp ]
<operator>.indirectIndexAccess com [ el ] [ pel ]
<operator>.indirectIndexAccess final [ ++ sp ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess com [ el ]
<operator>.indirectIndexAccess final [ sp ]
<operator>.indirectIndexAccess com [ el ] [ pel ]
<operator>.indirectIndexAccess final [ ++ sp ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess com [ el ]
<operator>.indirectIndexAccess opp [ final [ j ] - 'A' ] [ el ]
<operator>.indirectIndexAccess opp [ final [ j ] - 'A' ]
<operator>.indirectIndexAccess final [ j ]
>>>PDG&102 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->29 0->30 0->33 0->34 0->35 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->49 0->50 0->51 0->53 0->55 0->56 0->57 0->58 0->59 0->60 0->62 0->63 0->64 2->1 2->1 2->7 3->1 3->5 4->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->17 5->18 5->20 5->22 5->24 5->25 5->29 5->35 5->38 5->65 5->66 5->67 5->68 5->69 5->70 5->71 6->4 7->1 7->16 8->1 8->1 8->38 9->1 9->1 10->1 10->1 11->1 11->18 12->1 12->20 13->1 13->22 14->1 14->15 14->26 14->30 14->40 14->42 14->48 14->49 14->54 15->1 15->1 15->1 15->17 16->1 16->1 16->7 17->1 17->1 17->1 17->51 17->64 18->1 18->1 18->11 18->18 18->19 18->19 18->26 18->27 18->28 18->44 18->45 18->49 18->50 18->72 18->73 18->74 18->75 18->78 18->79 18->85 18->86 18->87 18->88 19->1 19->18 20->1 20->1 20->12 20->20 20->21 20->21 20->30 20->31 20->32 20->33 20->34 20->40 20->41 20->76 20->77 20->80 20->81 20->82 20->83 21->1 21->20 22->1 22->1 22->1 22->13 22->22 22->23 22->23 22->36 22->37 22->39 22->42 22->84 23->1 23->22 24->8 25->18 26->14 26->27 26->28 26->30 26->44 26->45 26->49 26->50 27->1 27->1 28->1 28->1 28->1 29->1 29->20 30->14 30->40 30->41 31->1 31->1 31->1 32->1 32->1 32->1 33->1 33->1 34->1 34->1 35->1 35->22 36->1 36->1 36->1 37->1 37->1 37->47 38->17 38->39 39->1 39->17 39->43 39->46 39->47 39->48 39->51 39->55 39->57 39->57 39->59 39->89 39->90 39->91 39->92 39->93 40->14 40->15 40->26 40->30 40->31 40->31 40->49 41->1 41->14 41->26 41->30 41->32 41->32 41->44 42->1 42->14 42->26 42->30 42->36 42->36 42->48 42->54 43->1 43->1 43->1 44->50 45->14 45->15 45->26 45->30 45->40 45->49 46->1 46->1 46->52 46->52 46->53 46->55 46->58 46->94 46->95 46->98 47->1 47->1 47->54 47->59 47->96 47->97 48->1 48->1 48->1 48->17 49->45 50->1 50->14 50->26 50->30 50->41 50->44 51->1 51->17 51->43 51->43 52->1 52->1 52->1 52->17 52->51 53->1 53->47 54->1 54->1 54->1 54->17 55->1 55->1 55->17 55->39 55->56 55->59 55->60 55->64 55->99 55->100 55->101 56->1 56->55 57->17 57->39 58->1 58->55 59->17 59->39 60->1 60->1 60->55 60->56 60->61 60->62 60->63 61->1 61->1 61->17 61->39 61->59 62->1 62->47 63->61 64->1 64->17
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int t , c , d , i , n , j , k , cse = 0 , sp , a [ 26 ] , cd ; char el , pel , com [ 26 ] [ 26 ] , final [ 200 ] , s [ 110 ] , opp [ 26 ] [ 26 ] ; scanf ( "\x25\x64\x0" , & t ) ; while ( t -- ) { cse ++ ; sp = - 1 ; memset ( com , 0 , sizeof com ) ; memset ( opp , 0 , sizeof opp ) ; scanf ( "%d" , & c ) ; for ( i = 0 ; i < c ; i ++ ) { scanf ( "%s" , s ) ; com [ s [ 0 ] - 'A' ] [ s [ 1 ] - 'A' ] = s [ 2 ] ; com [ s [ 1 ] - 'A' ] [ s [ 0 ] - 'A' ] = s [ 2 ] ; } scanf ( "%d" , & d ) ; for ( i = 0 ; i < d ; i ++ ) { scanf ( "%s" , s ) ; el = s [ 0 ] - 'A' ; pel = s [ 1 ] - 'A' ; opp [ el ] [ pel ] = 1 ; opp [ pel ] [ el ] = 1 ; } scanf ( "%d" , & n ) ; scanf ( "%s" , s ) ; final [ ++ sp ] = s [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { el = s [ i ] - 'A' ; cd = 0 ; if ( sp >= 0 ) { pel = final [ sp ] - 'A' ; if ( com [ el ] [ pel ] != 0 ) { final [ sp ] = com [ el ] [ pel ] ; cd = 1 ; } else { for ( j = 0 ; j <= sp ; j ++ ) { if ( opp [ final [ j ] - 'A' ] [ el ] == 1 ) { sp = - 1 ; cd = 1 ; break ; } } } if ( cd == 0 ) final [ ++ sp ] = s [ i ] ; } else final [ ++ sp ] = s [ i ] ; } printf ( "Case #%d: " , cse ) ; print ( final , sp ) ; } return 0 ; }
>>>Func
METHOD Reduce
METHOD_RETURN void
<operator>.lessThan tope < 2
<operator>.lessThan i < x
<operator>.postIncrement i ++
RETURN return ; return ;
<operator>.assignment i = 0
<operator>.logicalAnd c [ i ] [ 0 ] == lista [ tope - 1 ] && c [ i ] [ 1 ] == lista [ tope - 2 ]
<operator>.logicalAnd c [ i ] [ 0 ] == lista [ tope - 2 ] && c [ i ] [ 1 ] == lista [ tope - 1 ]
<operator>.assignment lista [ tope - 2 ] = c [ i ] [ 2 ]
<operator>.postDecrement tope --
<operator>.assignment lista [ tope - 2 ] = c [ i ] [ 2 ]
<operator>.postDecrement tope --
<operator>.equals c [ i ] [ 0 ] == lista [ tope - 1 ]
<operator>.equals c [ i ] [ 1 ] == lista [ tope - 2 ]
<operator>.equals c [ i ] [ 0 ] == lista [ tope - 2 ]
<operator>.equals c [ i ] [ 1 ] == lista [ tope - 1 ]
<operator>.subtraction tope - 1
<operator>.subtraction tope - 2
<operator>.subtraction tope - 2
<operator>.subtraction tope - 2
<operator>.subtraction tope - 1
<operator>.subtraction tope - 2
<operator>.indirectIndexAccess c [ i ] [ 0 ]
<operator>.indirectIndexAccess lista [ tope - 1 ]
<operator>.indirectIndexAccess c [ i ] [ 1 ]
<operator>.indirectIndexAccess lista [ tope - 2 ]
<operator>.indirectIndexAccess lista [ tope - 2 ]
<operator>.indirectIndexAccess c [ i ] [ 2 ]
<operator>.indirectIndexAccess c [ i ] [ 0 ]
<operator>.indirectIndexAccess lista [ tope - 2 ]
<operator>.indirectIndexAccess c [ i ] [ 1 ]
<operator>.indirectIndexAccess lista [ tope - 1 ]
<operator>.indirectIndexAccess lista [ tope - 2 ]
<operator>.indirectIndexAccess c [ i ] [ 2 ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess c [ i ]
>>>PDG&41 0->2 0->3 0->4 0->5 0->6 0->10 0->12 0->17 0->18 0->19 0->20 0->21 0->22 2->1 2->1 2->3 2->5 2->6 2->17 3->1 3->3 3->4 3->4 3->7 3->8 3->13 3->15 3->17 3->20 3->23 3->24 3->29 3->30 3->35 3->38 4->3 5->1 6->3 7->9 7->10 7->19 7->27 7->28 7->37 8->11 8->12 8->22 8->33 8->34 8->40 9->15 10->20 11->14 11->15 12->17 13->7 13->7 13->14 13->15 13->16 13->18 13->25 13->26 13->36 14->7 14->7 14->15 14->16 15->8 15->8 15->13 15->14 15->16 15->21 15->31 15->32 15->39 16->8 16->8 16->13 16->14 17->18 17->19 17->20 18->19 18->20 19->10 20->17 20->21 20->22 21->17 21->22 22->12
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void Reduce ( ) { int i ; if ( tope < 2 ) return ; for ( i = 0 ; i < x ; i ++ ) { if ( c [ i ] [ 0 ] == lista [ tope - 1 ] && c [ i ] [ 1 ] == lista [ tope - 2 ] ) { lista [ tope - 2 ] = c [ i ] [ 2 ] ; tope -- ; } if ( c [ i ] [ 0 ] == lista [ tope - 2 ] && c [ i ] [ 1 ] == lista [ tope - 1 ] ) { lista [ tope - 2 ] = c [ i ] [ 2 ] ; tope -- ; } } }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x20\x25\x64\x0" , & nt0 )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan nt <= nt0
<operator>.postIncrement nt ++
LITERAL 0 return 0 ;
<operator>.assignment nt = 1
scanf scanf ( " %d" , & n )
qsort qsort ( v1   n   sizeof ( int ) , cmp1 )
qsort qsort ( v2   n   sizeof ( int ) , cmp2 )
<operator>.assignment sum = 0
printf printf ( "Case #%d: %lld\n" , nt , sum )
<operator>.lessThan i < n
<operator>.postIncrement i ++
scanf scanf ( " %d" , & v1 [ i ] )
<operator>.lessThan i < n
<operator>.postIncrement i ++
scanf scanf ( " %d" , & v2 [ i ] )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignmentPlus sum += v1 [ i ] * v2 [ i ]
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.sizeOf sizeof ( int )
<operator>.assignment i = 0
<operator>.multiplication v1 [ i ] * v2 [ i ]
<operator>.addressOf & n
<operator>.sizeOf sizeof ( int )
<operator>.addressOf & v1 [ i ]
<operator>.addressOf & v2 [ i ]
<operator>.indirectIndexAccess v1 [ i ]
<operator>.indirectIndexAccess v2 [ i ]
<operator>.indirectIndexAccess v1 [ i ]
<operator>.indirectIndexAccess v2 [ i ]
>>>PDG&35 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->25 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->16 4->19 4->22 4->23 4->24 4->25 4->27 4->28 5->1 5->4 6->3 7->1 7->4 8->1 8->9 8->10 8->13 8->16 8->19 9->1 9->1 9->1 9->10 9->15 9->26 10->1 10->1 10->1 10->18 10->19 10->26 11->1 11->12 11->21 12->1 12->1 12->5 13->13 13->14 13->14 13->15 13->16 13->29 13->31 14->1 14->13 15->1 15->9 15->26 16->9 16->16 16->17 16->17 16->18 16->30 16->32 17->1 17->16 18->1 18->10 18->26 19->1 19->1 19->1 19->8 19->13 19->19 19->20 19->20 19->21 19->26 19->33 19->34 20->1 20->19 21->1 21->1 21->12 22->13 23->16 24->1 25->1 25->19 26->1 26->1 26->9 26->10 26->15 26->18 26->21 26->21
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int nt , nt0 ; int i , n ; long long int sum ; int v1 [ MAXn ] , v2 [ MAXn ] ; scanf ( "\x20\x25\x64\x0" , & nt0 ) ; for ( nt = 1 ; nt <= nt0 ; nt ++ ) { scanf ( " %d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( " %d" , & v1 [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( " %d" , & v2 [ i ] ) ; qsort ( v1 , n , sizeof ( int ) , cmp1 ) ; qsort ( v2 , n , sizeof ( int ) , cmp2 ) ; sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += v1 [ i ] * v2 [ i ] ; printf ( "Case #%d: %lld\n" , nt , sum ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment fin = freopen ( infile , "\x72\x0" , stdin )
<operator>.assignment fout = freopen ( outfile , "w" , stdout )
scanf scanf ( "%d" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
freopen freopen ( infile , "\x72\x0" , stdin )
freopen freopen ( outfile , "w" , stdout )
<operator>.assignment i = 0
scanf scanf ( "%ld %ld %ld" , & n , & pd , & pg )
printf printf ( "Case #%d: Possible\n" , i + 1 )
<operator>.lessThan n < ( 100 / gcd ( pd , 100 ) )
<operator>.logicalAnd pg == 100 && pd < 100
<operator>.logicalAnd pg == 0 && pd > 0
printf printf ( "Case #%d: Broken\n" , i + 1 )
printf printf ( "Case #%d: Broken\n" , i + 1 )
printf printf ( "Case #%d: Broken\n" , i + 1 )
<operator>.addition i + 1
<operator>.division 100 / gcd ( pd , 100 )
<operator>.equals pg == 100
<operator>.lessThan pd < 100
<operator>.equals pg == 0
<operator>.greaterThan pd > 0
gcd gcd ( pd , 100 )
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.addressOf & n
<operator>.addressOf & pd
<operator>.addressOf & pg
>>>PDG&33 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 2->1 2->1 2->1 3->1 3->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->12 6->13 6->14 6->17 6->18 6->19 6->20 6->21 6->26 6->27 6->28 6->29 6->30 6->31 6->32 7->1 7->6 8->5 9->1 9->1 9->2 9->2 9->2 10->1 10->1 10->3 10->3 10->3 11->1 11->6 12->1 12->1 12->1 12->14 13->1 13->1 14->1 14->1 14->1 14->12 14->15 14->17 14->22 14->27 15->1 15->1 15->1 15->16 15->18 15->24 15->28 16->1 16->1 16->1 16->13 16->19 16->20 16->29 17->1 17->1 18->1 18->1 19->1 19->1 21->1 21->14 21->14 22->1 22->15 22->15 22->23 22->24 23->1 23->15 23->15 23->25 23->26 24->1 24->16 24->16 24->22 24->25 25->1 25->16 25->16 25->26 26->1 26->21 26->21 26->23 26->25
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { FILE * fin , * fout ; int t , i , j ; long int n , pd , pg ; fin = freopen ( infile , "\x72\x0" , stdin ) ; fout = freopen ( outfile , "w" , stdout ) ; scanf ( "%d" , & t ) ; for ( i = 0 ; i < t ; i ++ ) { scanf ( "%ld %ld %ld" , & n , & pd , & pg ) ; if ( n < ( 100 / gcd ( pd , 100 ) ) ) { printf ( "Case #%d: Broken\n" , i + 1 ) ; continue ; } if ( pg == 100 && pd < 100 ) { printf ( "Case #%d: Broken\n" , i + 1 ) ; continue ; } if ( pg == 0 && pd > 0 ) { printf ( "Case #%d: Broken\n" , i + 1 ) ; continue ; } printf ( "Case #%d: Possible\n" , i + 1 ) ; } return 0 ; }
>>>Func
METHOD multiply
METHOD_RETURN void
PARAM large_num * num
PARAM unsigned long n
<operator>.assignment carry = 0
<operator>.lessThan i < num -> num_digits
<operator>.postIncrement i ++
<operator>.notEquals carry != 0
<operator>.assignment i = 0
<operator>.assignment temp = num -> digits [ i ] * n
<operator>.assignmentPlus temp += carry
<operator>.assignment num -> digits [ i ] = temp
add_digit add_digit ( num , carry % 10 )
<operator>.assignmentDivision carry /= 10
<operator>.lessThan temp < 10
<operator>.multiplication num -> digits [ i ] * n
<operator>.assignment carry = 0
<operator>.modulo carry % 10
<operator>.assignment carry = temp / 10
<operator>.assignment temp = temp % 10
<operator>.division temp / 10
<operator>.modulo temp % 10
<operator>.indirectFieldAccess num -> num_digits
FIELD_IDENTIFIER num_digits num_digits
<operator>.indirectIndexAccess num -> digits [ i ]
<operator>.indirectIndexAccess num -> digits [ i ]
<operator>.indirectFieldAccess num -> digits
<operator>.indirectFieldAccess num -> digits
FIELD_IDENTIFIER digits digits
FIELD_IDENTIFIER digits digits
>>>PDG&30 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->20 0->21 2->1 2->12 3->1 3->15 4->1 4->7 4->10 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->10 5->11 5->14 5->15 5->22 5->23 5->24 5->25 5->26 5->27 5->28 5->29 6->1 6->5 7->1 7->1 7->7 7->12 7->13 7->17 7->17 8->1 8->5 9->10 10->14 11->15 13->1 13->7 14->11 14->16 14->18 14->19 14->20 14->20 14->21 15->9 15->9 16->7 16->10 17->12 17->12 17->13 18->7 18->10 19->11 20->18 20->18 20->21 21->19 21->19
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void multiply ( large_num * num , unsigned long n ) { int i ; unsigned long carry = 0 , temp ; for ( i = 0 ; i < num -> num_digits ; i ++ ) { temp = num -> digits [ i ] * n ; temp += carry ; if ( temp < 10 ) carry = 0 ; else { carry = temp / 10 ; temp = temp % 10 ; } num -> digits [ i ] = temp ; } while ( carry != 0 ) { add_digit ( num , carry % 10 ) ; carry /= 10 ; } }
>>>Func
METHOD binomial_tree_merge
METHOD_RETURN BinomialTree
PARAM BinomialHeap * heap
PARAM BinomialTree * tree1
PARAM BinomialTree * tree2
<operator>.assignment new_tree = malloc ( sizeof ( BinomialTree ) )
<operator>.assignment new_tree -> refcount = 0
<operator>.assignment new_tree -> order = ( unsigned short ) ( tree1 -> order + 1 )
<operator>.assignment new_tree -> value = tree1 -> value
<operator>.assignment new_tree -> subtrees = malloc ( sizeof ( BinomialTree * ) * new_tree -> order )
memcpy memcpy ( new_tree -> subtrees   tree1 -> subtrees   sizeof ( BinomialTree * ) * tree1 -> order )
<operator>.assignment new_tree -> subtrees [ new_tree -> order - 1 ] = tree2
RETURN return new_tree ; return new_tree ;
<operator>.greaterThan binomial_heap_cmp ( heap , tree1 -> value , tree2 -> value ) > 0
<operator>.equals new_tree == NULL
<operator>.equals new_tree -> subtrees == NULL
<operator>.lessThan i < new_tree -> order
<operator>.preIncrement ++ i
IDENTIFIER new_tree return new_tree ;
<operator>.assignment tmp = tree1
<operator>.assignment tree1 = tree2
<operator>.assignment tree2 = tmp
RETURN return NULL ; return NULL ;
<operator>.cast ( unsigned short ) ( tree1 -> order + 1 )
malloc malloc ( sizeof ( BinomialTree * ) * new_tree -> order )
free free ( new_tree )
RETURN return NULL ; return NULL ;
<operator>.multiplication sizeof ( BinomialTree * ) * tree1 -> order
<operator>.assignment i = 0
binomial_tree_ref binomial_tree_ref ( new_tree -> subtrees [ i ] )
binomial_heap_cmp binomial_heap_cmp ( heap , tree1 -> value , tree2 -> value )
<operator>.sizeOf sizeof ( BinomialTree )
IDENTIFIER NULL return NULL ;
<operator>.addition tree1 -> order + 1
<operator>.multiplication sizeof ( BinomialTree * ) * new_tree -> order
IDENTIFIER NULL return NULL ;
<operator>.subtraction new_tree -> order - 1
<operator>.indirectFieldAccess new_tree -> refcount
<operator>.indirectFieldAccess new_tree -> order
<operator>.indirectFieldAccess new_tree -> value
<operator>.indirectFieldAccess tree1 -> value
<operator>.indirectFieldAccess new_tree -> subtrees
<operator>.indirectFieldAccess new_tree -> subtrees
<operator>.indirectFieldAccess tree1 -> subtrees
<operator>.indirectIndexAccess new_tree -> subtrees [ new_tree -> order - 1 ]
FIELD_IDENTIFIER refcount refcount
FIELD_IDENTIFIER order order
UNKNOWN unsigned short unsigned short
FIELD_IDENTIFIER value value
FIELD_IDENTIFIER value value
FIELD_IDENTIFIER subtrees subtrees
<operator>.indirectFieldAccess new_tree -> subtrees
FIELD_IDENTIFIER subtrees subtrees
FIELD_IDENTIFIER subtrees subtrees
<operator>.sizeOf sizeof ( BinomialTree * )
<operator>.indirectFieldAccess tree1 -> order
<operator>.indirectFieldAccess new_tree -> subtrees
<operator>.indirectFieldAccess new_tree -> order
<operator>.indirectFieldAccess tree1 -> order
<operator>.sizeOf sizeof ( BinomialTree * )
<operator>.indirectFieldAccess new_tree -> order
FIELD_IDENTIFIER subtrees subtrees
FIELD_IDENTIFIER order order
FIELD_IDENTIFIER subtrees subtrees
<operator>.indirectFieldAccess new_tree -> order
FIELD_IDENTIFIER order order
<operator>.indirectIndexAccess new_tree -> subtrees [ i ]
FIELD_IDENTIFIER order order
FIELD_IDENTIFIER order order
FIELD_IDENTIFIER order order
<operator>.indirectFieldAccess new_tree -> subtrees
FIELD_IDENTIFIER subtrees subtrees
>>>PDG&72 0->2 0->3 0->4 0->6 0->7 0->11 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->25 0->28 0->30 0->32 0->33 0->35 0->36 2->30 3->1 3->19 4->1 4->11 4->20 5->1 5->1 5->14 7->34 9->15 12->1 13->1 13->1 13->19 13->20 13->21 14->1 14->1 14->1 14->6 14->7 14->8 14->9 14->15 14->15 14->18 14->22 14->23 14->24 14->25 14->32 14->33 14->34 14->37 14->38 14->39 14->40 14->41 14->45 14->46 14->47 14->48 14->49 14->50 14->51 14->58 14->59 14->60 14->61 14->67 14->68 15->10 15->10 15->11 15->12 15->16 15->25 15->26 15->27 15->28 15->35 15->36 15->42 15->43 15->44 15->52 15->53 15->54 15->55 15->56 15->57 15->62 15->63 15->64 15->65 15->69 16->16 16->17 16->17 16->29 16->57 16->65 16->66 16->70 16->71 17->16 18->12 19->1 19->21 20->1 20->1 21->1 21->1 21->1 21->11 22->1 24->9 26->1 27->10 28->16 30->1 30->1 30->1 30->8 30->13 30->13 30->13 31->1 32->22 34->24 34->36 35->26 36->16
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static BinomialTree * binomial_tree_merge ( BinomialHeap * heap , BinomialTree * tree1 , BinomialTree * tree2 ) { BinomialTree * new_tree ; BinomialTree * tmp ; int i ; if ( binomial_heap_cmp ( heap , tree1 -> value , tree2 -> value ) > 0 ) { tmp = tree1 ; tree1 = tree2 ; tree2 = tmp ; } new_tree = malloc ( sizeof ( BinomialTree ) ) ; if ( new_tree == NULL ) { return NULL ; } new_tree -> refcount = 0 ; new_tree -> order = ( unsigned short ) ( tree1 -> order + 1 ) ; new_tree -> value = tree1 -> value ; new_tree -> subtrees = malloc ( sizeof ( BinomialTree * ) * new_tree -> order ) ; if ( new_tree -> subtrees == NULL ) { free ( new_tree ) ; return NULL ; } memcpy ( new_tree -> subtrees , tree1 -> subtrees , sizeof ( BinomialTree * ) * tree1 -> order ) ; new_tree -> subtrees [ new_tree -> order - 1 ] = tree2 ; for ( i = 0 ; i < new_tree -> order ; ++ i ) { binomial_tree_ref ( new_tree -> subtrees [ i ] ) ; } return new_tree ; }
>>>Func
METHOD readFile
METHOD_RETURN char*
PARAM char * name
<operator>.assignment inputFile = fopen ( name , "\x72\x0" )
fseek fseek ( inputFile , 0L , SEEK_END )
<operator>.assignment fileLen = ftell ( inputFile )
rewind rewind ( inputFile )
<operator>.assignment stringFile = ( char * ) malloc ( sizeof ( char ) * fileLen )
fclose fclose ( inputFile )
RETURN return stringFile ; return stringFile ;
<operator>.equals inputFile == NULL
<operator>.notEquals ( readLen = fread ( stringFile , 1 , fileLen , inputFile ) ) != fileLen
IDENTIFIER stringFile return stringFile ;
fopen fopen ( name , "\x72\x0" )
fprintf fprintf ( stderr   "Error opening %s: %s (%u)\n"   name   strerror ( errno ) , errno )
RETURN return NULL ; return NULL ;
ftell ftell ( inputFile )
<operator>.cast ( char * ) malloc ( sizeof ( char ) * fileLen )
fprintf fprintf ( stderr , "Read %ld of %ld\n" , readLen , fileLen )
fclose fclose ( inputFile )
RETURN return NULL ; return NULL ;
IDENTIFIER NULL return NULL ;
malloc malloc ( sizeof ( char ) * fileLen )
<operator>.assignment readLen = fread ( stringFile , 1 , fileLen , inputFile )
IDENTIFIER NULL return NULL ;
strerror strerror ( errno )
<operator>.multiplication sizeof ( char ) * fileLen
fread fread ( stringFile , 1 , fileLen , inputFile )
<operator>.sizeOf sizeof ( char )
UNKNOWN char * char *
>>>PDG&30 0->2 0->4 0->6 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->24 0->25 0->26 0->27 2->13 3->1 3->1 3->10 4->1 4->16 5->26 6->27 7->27 9->1 10->1 10->1 10->1 10->4 10->4 10->5 10->6 10->7 10->11 10->14 10->15 10->16 10->17 10->22 10->23 10->25 10->26 10->27 10->28 10->29 11->8 11->9 11->18 11->18 11->19 11->20 12->9 13->3 13->3 13->14 14->1 14->1 14->1 14->1 14->1 15->1 16->5 16->6 20->1 21->15 22->7 22->17 23->11 23->18 24->20 25->14 26->22 26->27 27->8 27->11 27->11 27->11 27->11 27->12 27->19 27->23 27->23 27->23 27->23 28->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) char * readFile ( char * name ) { FILE * inputFile ; long fileLen ; long readLen ; char * stringFile ; inputFile = fopen ( name , "\x72\x0" ) ; if ( inputFile == NULL ) { fprintf ( stderr , "Error opening %s: %s (%u)\n" , name , strerror ( errno ) , errno ) ; return NULL ; } fseek ( inputFile , 0L , SEEK_END ) ; fileLen = ftell ( inputFile ) ; rewind ( inputFile ) ; stringFile = ( char * ) malloc ( sizeof ( char ) * fileLen ) ; if ( ( readLen = fread ( stringFile , 1 , fileLen , inputFile ) ) != fileLen ) { fprintf ( stderr , "Read %ld of %ld\n" , readLen , fileLen ) ; fclose ( inputFile ) ; return NULL ; } fclose ( inputFile ) ; return stringFile ; }
>>>Func
METHOD parseVS
METHOD_RETURN ANY
scanf scanf ( "\x25\x64\x5c\x6e\x0" , & c )
<operator>.greaterThan vector < string > v
RETURN return v ; return v ;
<operator>.lessThan i < c
<operator>.postIncrement i ++
IDENTIFIER v return v ;
<operator>.lessThan vector < string
<operator>.assignment i = 0
fgets fgets ( buf , MAX_LENGTH , stdin )
push_back v . push_back ( string ( buf ) )
string string ( buf )
<operator>.fieldAccess v . push_back
FIELD_IDENTIFIER push_back push_back
>>>PDG&15 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->12 2->1 2->5 3->1 3->1 3->1 3->7 3->11 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->10 5->11 5->12 5->13 5->14 6->1 6->5 7->4 8->1 8->1 8->3 8->3 9->1 9->5 10->1 10->1 10->1 10->12 11->1 11->1 11->1 11->7 12->1 12->10 12->11
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) parseVS ( ) { int c ; scanf ( "\x25\x64\x5c\x6e\x0" , & c ) ; vector < string > v ; char buf [ MAX_LENGTH ] ; for ( int i = 0 ; i < c ; i ++ ) { fgets ( buf , MAX_LENGTH , stdin ) ; v . push_back ( string ( buf ) ) ; } return v ; }
>>>Func
METHOD test_xor8
METHOD_RETURN void
assert assert ( xor8 ( "\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x0" ) == 228 )
assert assert ( xor8 ( "Hello World!" ) == 195 )
assert assert ( xor8 ( "Hello world" ) == 196 )
assert assert ( xor8 ( "Hello world!" ) == 163 )
printf printf ( "Tests passed\n" )
<operator>.equals xor8 ( "\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x0" ) == 228
<operator>.equals xor8 ( "Hello World!" ) == 195
<operator>.equals xor8 ( "Hello world" ) == 196
<operator>.equals xor8 ( "Hello world!" ) == 163
xor8 xor8 ( "\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x0" )
xor8 xor8 ( "Hello World!" )
xor8 xor8 ( "Hello world" )
xor8 xor8 ( "Hello world!" )
>>>PDG&15 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 2->1 3->1 3->1 4->1 4->1 5->1 5->1 6->1 7->1 7->2 7->2 8->1 8->3 8->3 9->1 9->4 9->4 10->1 10->5 10->5 11->7 12->8 13->9 14->10
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void test_xor8 ( ) { assert ( xor8 ( "\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x0" ) == 228 ) ; assert ( xor8 ( "Hello World!" ) == 195 ) ; assert ( xor8 ( "Hello world" ) == 196 ) ; assert ( xor8 ( "Hello world!" ) == 163 ) ; printf ( "Tests passed\n" ) ; }
>>>Func
METHOD read_intx
METHOD_RETURN int
PARAM char * * s
<operator>.assignment * p = * s
<operator>.assignment ret = strtoul ( p , & p , 10 )
<operator>.assignment * s = p
RETURN return ret ; return ret ;
isspace isspace ( * p )
IDENTIFIER ret return ret ;
<operator>.postIncrement p ++
strtoul strtoul ( p , & p , 10 )
<operator>.indirection * p
>>>PDG&12 0->2 0->5 0->8 0->9 0->10 2->1 3->1 3->9 3->10 4->1 4->1 4->1 4->8 5->1 5->1 5->1 6->1 7->1 7->1 7->5 7->7 7->9 7->9 7->10 7->11 8->6 9->1 9->10 10->1 10->4 10->4 10->4 10->5 10->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int read_intx ( char * * s ) { char * p = * s ; int ret ; while ( isspace ( * p ) ) { p ++ ; } ret = strtoul ( p , & p , 10 ) ; * s = p ; return ret ; }
>>>Func
METHOD factorial
METHOD_RETURN long int
PARAM int x
<operator>.assignment fac = x
RETURN return fac ; return fac ;
<operator>.lessThan i < x
<operator>.postIncrement i ++
IDENTIFIER fac return fac ;
<operator>.assignment i = 1
<operator>.assignment fac = fac * ( x - i )
<operator>.multiplication fac * ( x - i )
<operator>.subtraction x - i
>>>PDG&12 0->2 0->3 0->5 0->6 0->7 0->8 0->10 0->11 2->3 2->5 3->1 3->1 3->7 3->10 4->1 5->1 5->1 5->1 5->5 5->6 5->9 5->10 5->11 5->11 5->11 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->1 9->7 9->10 10->1 10->9 10->9 11->5 11->6 11->10 11->10
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) long int factorial ( int x ) { int i ; long int fac ; fac = x ; for ( i = 1 ; i < x ; i ++ ) { fac = fac * ( x - i ) ; } return fac ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment T = getInt ( )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= T
<operator>.preIncrement ++ t
LITERAL 0 return 0 ;
<operator>.assignment t = 1
printf printf ( "Case #%d:\n" , t )
<operator>.assignment N = getInt ( )
<operator>.assignment teams = calloc ( sizeof ( Team ) , N )
free free ( teams )
<operator>.greaterThan t > 1
<operator>.lessThan I < N
<operator>.preIncrement ++ I
<operator>.lessThan I < N
<operator>.preIncrement ++ I
<operator>.lessThan I < N
<operator>.preIncrement ++ I
printf printf ( "\x5c\x6e\x0" )
calloc calloc ( sizeof ( Team ) , N )
<operator>.assignment I = 0
<operator>.assignment teams [ I ] . g = calloc ( sizeof ( unsigned ) , N )
<operator>.assignment I = 0
<operator>.assignment W = 0
<operator>.assignmentDivision teams [ I ] . owp /= W
<operator>.assignment I = 0
<operator>.assignment W = 0
<operator>.assignmentDivision teams [ I ] . oowp /= W
printf printf ( "%f" , 0.25 * teams [ I ] . wp_n / teams [ I ] . wp_d + 0.50 * teams [ I ] . owp + 0.25 * teams [ I ] . oowp )
<operator>.sizeOf sizeof ( Team )
<operator>.lessThan J < N
<operator>.preIncrement ++ J
<operator>.lessThan J < N
<operator>.preIncrement ++ J
IDENTIFIER I if (I)
<operator>.lessThan J < N
<operator>.preIncrement ++ J
calloc calloc ( sizeof ( unsigned ) , N )
<operator>.assignment J = 0
<operator>.assignment J = 0
printf printf ( "\n" )
<operator>.assignment J = 0
<operator>.addition 0.25 * teams [ I ] . wp_n / teams [ I ] . wp_d + 0.50 * teams [ I ] . owp + 0.25 * teams [ I ] . oowp
<operator>.sizeOf sizeof ( unsigned )
<operator>.equals G == '\n'
IDENTIFIER G switch(G)
<operator>.logicalAnd I != J && teams [ I ] . g [ J ]
<operator>.logicalAnd I != J && teams [ I ] . g [ J ]
<operator>.addition 0.25 * teams [ I ] . wp_n / teams [ I ] . wp_d + 0.50 * teams [ I ] . owp
<operator>.multiplication 0.25 * teams [ I ] . oowp
<operator>.assignment G = getChar ( )
LITERAL '1' <empty>
<operator>.preIncrement ++ teams [ I ] . wp_n
<operator>.preIncrement ++ teams [ I ] . wp_d
<operator>.preIncrement ++ teams [ I ] . g [ J ]
LITERAL '0' <empty>
<operator>.preIncrement ++ teams [ I ] . wp_d
<operator>.preIncrement ++ teams [ I ] . g [ J ]
<operators>.assignmentShiftLeft teams [ I ] . g [ J ] <<= 1
<operator>.assignment U = teams [ J ] . wp_n
<operator>.assignment V = teams [ J ] . wp_d - 1
<operator>.assignmentPlus teams [ I ] . owp += ( double ) U / V
<operator>.preIncrement ++ W
<operator>.assignmentPlus teams [ I ] . oowp += teams [ J ] . owp
<operator>.preIncrement ++ W
<operator>.division 0.25 * teams [ I ] . wp_n / teams [ I ] . wp_d
<operator>.multiplication 0.50 * teams [ I ] . owp
<operator>.notEquals I != J
<operator>.arithmeticShiftRight teams [ I ] . g [ J ] >> 1
<operator>.notEquals I != J
<operator>.multiplication 0.25 * teams [ I ] . wp_n
<operator>.subtraction teams [ J ] . wp_d - 1
<operator>.preDecrement -- U
<operator>.division ( double ) U / V
<operator>.cast ( double ) U
getInt getInt ( )
<operator>.fieldAccess teams [ I ] . g
<operator>.fieldAccess teams [ I ] . owp
<operator>.fieldAccess teams [ I ] . oowp
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER g g
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER owp owp
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER oowp oowp
<operator>.fieldAccess teams [ I ] . oowp
<operator>.indirectIndexAccess teams [ I ] . g [ J ]
<operator>.indirectIndexAccess teams [ I ] . g [ J ]
<operator>.fieldAccess teams [ J ] . owp
<operator>.fieldAccess teams [ I ] . wp_d
<operator>.fieldAccess teams [ I ] . owp
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER oowp oowp
getChar getChar ( )
<operator>.fieldAccess teams [ I ] . wp_n
<operator>.fieldAccess teams [ I ] . wp_d
<operator>.indirectIndexAccess teams [ I ] . g [ J ]
<operator>.fieldAccess teams [ I ] . wp_d
<operator>.indirectIndexAccess teams [ I ] . g [ J ]
<operator>.indirectIndexAccess teams [ I ] . g [ J ]
<operator>.fieldAccess teams [ I ] . g
<operator>.fieldAccess teams [ J ] . wp_n
<operator>.fieldAccess teams [ I ] . owp
<operator>.fieldAccess teams [ I ] . g
<operator>.indirectIndexAccess teams [ J ]
FIELD_IDENTIFIER owp owp
<operator>.fieldAccess teams [ I ] . oowp
<operator>.fieldAccess teams [ J ] . owp
<operator>.fieldAccess teams [ I ] . wp_n
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER wp_d wp_d
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER owp owp
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER wp_n wp_n
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER wp_d wp_d
<operator>.fieldAccess teams [ I ] . g
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER wp_d wp_d
<operator>.fieldAccess teams [ I ] . g
<operator>.fieldAccess teams [ I ] . g
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER g g
<operator>.indirectIndexAccess teams [ J ]
FIELD_IDENTIFIER wp_n wp_n
<operator>.fieldAccess teams [ J ] . wp_d
<operator>.indirectIndexAccess teams [ I ] . g [ J ]
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER owp owp
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER g g
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER oowp oowp
<operator>.indirectIndexAccess teams [ J ]
FIELD_IDENTIFIER owp owp
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER wp_n wp_n
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER g g
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER g g
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER g g
<operator>.indirectIndexAccess teams [ J ]
FIELD_IDENTIFIER wp_d wp_d
<operator>.fieldAccess teams [ I ] . g
UNKNOWN double double
<operator>.indirectIndexAccess teams [ I ]
FIELD_IDENTIFIER g g
>>>PDG&151 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->45 0->46 0->50 0->51 0->52 0->56 0->59 0->63 0->65 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 2->1 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->15 4->17 4->20 4->21 4->23 4->26 4->30 4->76 5->1 5->4 6->3 7->1 7->4 8->1 8->5 9->1 9->1 9->10 9->13 9->20 10->1 10->1 10->11 11->1 12->1 12->8 12->19 13->13 13->14 13->14 13->15 13->22 13->22 13->31 13->31 13->38 13->38 13->39 13->44 13->77 13->80 13->81 14->1 14->13 15->15 15->16 15->16 15->17 15->24 15->25 15->33 15->33 15->40 15->68 15->78 15->82 15->83 16->1 16->15 17->1 17->1 17->1 17->17 17->18 17->18 17->27 17->28 17->29 17->36 17->36 17->41 17->42 17->43 17->49 17->50 17->66 17->67 17->70 17->71 17->79 17->84 17->85 17->86 17->90 17->91 17->92 17->93 17->109 17->110 17->111 17->112 17->113 17->137 17->138 18->1 18->17 19->1 21->13 22->1 22->1 23->15 24->1 24->25 24->63 25->1 25->1 26->1 26->17 27->1 27->28 27->65 28->1 28->1 28->50 29->1 29->1 30->1 31->1 31->1 31->13 31->31 31->32 31->32 31->45 31->51 31->53 31->54 31->55 31->57 31->58 31->59 31->94 31->95 31->96 31->97 31->98 31->99 31->100 31->114 31->115 31->116 31->117 31->118 31->119 31->120 31->121 31->122 31->139 31->140 31->141 31->142 31->143 31->144 32->1 32->31 33->1 33->1 33->15 33->33 33->34 33->47 33->68 33->68 34->1 34->33 36->1 36->1 36->17 36->36 36->37 36->48 36->70 36->70 37->1 37->36 39->1 39->31 40->1 40->33 41->1 42->1 42->36 43->1 43->1 44->1 45->1 45->1 45->45 45->51 45->94 47->1 47->1 47->1 47->48 47->55 47->58 47->60 47->61 47->62 47->63 47->69 47->69 47->72 47->74 47->75 47->102 47->103 47->125 47->126 47->127 47->128 47->129 47->130 47->145 47->146 47->147 47->148 47->149 47->150 48->1 48->1 48->1 48->47 48->55 48->58 48->64 48->65 48->89 48->105 48->106 48->107 48->108 48->133 48->134 48->135 48->136 49->1 49->1 50->29 50->29 50->43 50->43 51->1 51->1 51->45 53->1 54->1 54->57 55->1 55->1 55->47 55->48 55->58 57->1 57->54 58->1 58->59 59->1 59->47 59->48 59->55 59->58 60->1 60->73 60->74 60->75 61->1 61->1 61->74 62->1 62->1 62->25 63->1 63->25 64->1 64->28 65->1 65->28 66->1 66->29 66->29 66->43 66->43 66->49 66->49 67->29 67->29 67->43 67->43 67->49 67->49 68->16 68->34 68->47 68->47 68->87 68->101 68->123 68->124 69->1 69->1 69->47 69->48 69->55 69->58 69->73 70->18 70->37 70->48 70->48 70->88 70->104 70->131 70->132 71->66 71->66 72->61 72->61 73->1 73->74 73->75 74->1 74->1 74->62 74->62 75->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T , N , G , U , V , W ; Team * teams ; T = getInt ( ) ; for ( int t = 1 ; t <= T ; ++ t ) { if ( t > 1 ) { printf ( "\x5c\x6e\x0" ) ; } printf ( "Case #%d:\n" , t ) ; N = getInt ( ) ; teams = calloc ( sizeof ( Team ) , N ) ; for ( int I = 0 ; I < N ; ++ I ) { teams [ I ] . g = calloc ( sizeof ( unsigned ) , N ) ; for ( int J = 0 ; J < N ; ++ J ) { do { G = getChar ( ) ; } while ( G == '\n' ) ; switch ( G ) { case '1' : ++ teams [ I ] . wp_n ; ++ teams [ I ] . wp_d ; ++ teams [ I ] . g [ J ] ; break ; case '0' : ++ teams [ I ] . wp_d ; ++ teams [ I ] . g [ J ] ; teams [ I ] . g [ J ] <<= 1 ; break ; default : break ; } } } for ( int I = 0 ; I < N ; ++ I ) { W = 0 ; for ( int J = 0 ; J < N ; ++ J ) { if ( I != J && teams [ I ] . g [ J ] ) { U = teams [ J ] . wp_n ; V = teams [ J ] . wp_d - 1 ; if ( teams [ I ] . g [ J ] >> 1 ) { -- U ; } teams [ I ] . owp += ( double ) U / V ; ++ W ; } } teams [ I ] . owp /= W ; } for ( int I = 0 ; I < N ; ++ I ) { if ( I ) { printf ( "\n" ) ; } W = 0 ; for ( int J = 0 ; J < N ; ++ J ) { if ( I != J && teams [ I ] . g [ J ] ) { teams [ J ] . owp ; teams [ I ] . oowp += teams [ J ] . owp ; ++ W ; } } teams [ I ] . oowp /= W ; printf ( "%f" , 0.25 * teams [ I ] . wp_n / teams [ I ] . wp_d + 0.50 * teams [ I ] . owp + 0.25 * teams [ I ] . oowp ) ; } free ( teams ) ; } return 0 ; }
>>>Func
METHOD sort
METHOD_RETURN void
PARAM int * numbers
PARAM int size
<operator>.assignment pos = 0
<operator>.lessThan pos < size
<operator>.greaterEqualsThan numbers [ pos ] >= numbers [ pos - 1 ]
<operator>.postIncrement pos ++
<operator>.assignment tmp = numbers [ pos - 1 ]
<operator>.assignment numbers [ pos - 1 ] = numbers [ pos ]
<operator>.assignment numbers [ pos ] = tmp
<operator>.postDecrement pos --
<operator>.subtraction pos - 1
<operator>.equals pos == 0
<operator>.assignment pos = 1
<operator>.subtraction pos - 1
<operator>.subtraction pos - 1
<operator>.indirectIndexAccess numbers [ pos ]
<operator>.indirectIndexAccess numbers [ pos - 1 ]
<operator>.indirectIndexAccess numbers [ pos - 1 ]
<operator>.indirectIndexAccess numbers [ pos - 1 ]
<operator>.indirectIndexAccess numbers [ pos ]
<operator>.indirectIndexAccess numbers [ pos ]
>>>PDG&23 0->2 0->3 0->4 0->5 0->7 0->10 0->11 0->12 0->13 0->14 0->15 0->16 2->1 2->6 2->8 2->9 3->5 4->1 4->5 5->1 5->1 5->1 5->5 5->6 5->12 5->12 5->17 5->18 6->7 6->8 6->8 6->9 6->9 6->10 6->11 6->13 6->15 6->16 6->19 6->20 6->21 6->22 7->1 7->5 8->10 9->6 10->6 11->13 12->7 12->15 13->1 13->5 13->14 14->1 14->5 15->16 16->11
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void sort ( int * numbers , int size ) { int pos = 0 ; while ( pos < size ) { if ( numbers [ pos ] >= numbers [ pos - 1 ] ) pos ++ ; else { int tmp = numbers [ pos - 1 ] ; numbers [ pos - 1 ] = numbers [ pos ] ; numbers [ pos ] = tmp ; pos -- ; if ( pos == 0 ) pos = 1 ; } } }
>>>Func
METHOD lineReturn
METHOD_RETURN char*
PARAM char * file
<operator>.assignment position = 0
<operator>.assignment start = position
<operator>.logicalAnd file [ position ] != '\n' && file [ position ] != 0
<operator>.equals file [ position ] == '\n'
<operator>.postIncrement position ++
<operator>.assignment file [ position ] = 0
<operator>.postIncrement position ++
RETURN return file + start ; return file + start ;
<operator>.notEquals file [ position ] != '\n'
<operator>.notEquals file [ position ] != 0
<operator>.addition file + start
RETURN return NULL ; return NULL ;
IDENTIFIER NULL return NULL ;
<operator>.indirectIndexAccess file [ position ]
<operator>.indirectIndexAccess file [ position ]
<operator>.indirectIndexAccess file [ position ]
>>>PDG&19 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 2->6 2->11 2->12 2->13 3->1 3->4 3->7 3->9 4->1 4->13 5->1 5->1 5->1 5->5 5->7 5->11 5->16 6->1 6->8 6->9 6->10 6->13 6->14 6->18 7->9 8->1 8->1 8->13 9->1 9->1 10->1 11->5 11->5 11->6 11->12 11->12 11->17 12->5 12->5 12->6 12->11 13->1 13->1 13->1 13->10 14->1 15->14
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) char * lineReturn ( char * file ) { static int position = 0 ; static int start ; start = position ; while ( file [ position ] != '\n' && file [ position ] != 0 ) { position ++ ; } if ( file [ position ] == '\n' ) { file [ position ] = 0 ; position ++ ; return file + start ; } else return NULL ; }
>>>Func
METHOD sortedSquares
METHOD_RETURN int*
PARAM int * A
PARAM int ASize
PARAM int * returnSize
<operator>.assignment * res = malloc ( ASize * sizeof ( int ) )
<operator>.assignment * returnSize = ASize
qsort qsort ( res   ASize   sizeof ( int ) , cmpval )
RETURN return res ; return res ;
<operator>.lessThan i < ASize
<operator>.postIncrement i ++
<operator>.assignment res [ i ] = A [ i ] * A [ i ]
IDENTIFIER res return res ;
malloc malloc ( ASize * sizeof ( int ) )
<operator>.assignment i = 0
<operator>.sizeOf sizeof ( int )
<operator>.multiplication ASize * sizeof ( int )
<operator>.multiplication A [ i ] * A [ i ]
<operator>.indirectIndexAccess res [ i ]
<operator>.indirectIndexAccess A [ i ]
<operator>.indirectIndexAccess A [ i ]
>>>PDG&21 0->2 0->3 0->4 0->6 0->7 0->9 0->10 0->12 0->14 0->16 2->1 2->17 3->16 4->1 5->1 5->1 5->7 6->1 6->1 7->1 7->1 7->1 7->1 7->12 8->1 9->1 9->1 9->6 9->7 9->9 9->10 9->10 9->11 9->17 9->18 9->19 9->20 10->1 10->9 11->1 11->1 11->1 11->7 11->12 12->8 13->1 13->5 14->1 14->9 15->1 16->9 16->13 17->1 17->11
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int * sortedSquares ( int * A , int ASize , int * returnSize ) { int * res = malloc ( ASize * sizeof ( int ) ) ; for ( int i = 0 ; i < ASize ; i ++ ) res [ i ] = A [ i ] * A [ i ] ; * returnSize = ASize ; qsort ( res , ASize , sizeof ( int ) , cmpval ) ; return res ; }
>>>Func
METHOD combi
METHOD_RETURN int
PARAM int l
RETURN return 0 ; return 0 ;
<operator>.logicalAnd ctable [ str [ l ] % 65 ] [ k ] [ 0 ] != str [ l - 1 ] % 65 && ctable [ str [ l ] % 65 ] [ k ] [ 0 ] >= 0
<operator>.postIncrement k ++
<operator>.equals ctable [ str [ l ] % 65 ] [ k ] [ 0 ] == str [ l - 1 ] % 65
LITERAL 0 return 0 ;
<operator>.assignment k = 0
<operator>.assignment str [ l ] = ctable [ str [ l ] % 65 ] [ k ] [ 1 ] + 65
<operator>.postIncrement start ++
<operator>.notEquals ctable [ str [ l ] % 65 ] [ k ] [ 0 ] != str [ l - 1 ] % 65
<operator>.greaterEqualsThan ctable [ str [ l ] % 65 ] [ k ] [ 0 ] >= 0
<operator>.modulo str [ l - 1 ] % 65
<operator>.greaterEqualsThan y >= start
<operator>.postDecrement y --
<operator>.assignment str [ y + 1 ] = str [ y ]
<operator>.modulo str [ l - 1 ] % 65
<operator>.addition ctable [ str [ l ] % 65 ] [ k ] [ 1 ] + 65
<operator>.assignment y = l - 2
<operator>.subtraction l - 1
<operator>.subtraction l - 1
<operator>.modulo str [ l ] % 65
<operator>.subtraction l - 2
<operator>.addition y + 1
<operator>.modulo str [ l ] % 65
<operator>.modulo str [ l ] % 65
<operator>.modulo str [ l ] % 65
<operator>.indirectIndexAccess ctable [ str [ l ] % 65 ] [ k ] [ 0 ]
<operator>.indirectIndexAccess ctable [ str [ l ] % 65 ] [ k ] [ 0 ]
<operator>.indirectIndexAccess str [ l ]
<operator>.indirectIndexAccess ctable [ str [ l ] % 65 ] [ k ]
<operator>.indirectIndexAccess str [ l - 1 ]
<operator>.indirectIndexAccess ctable [ str [ l ] % 65 ] [ k ]
<operator>.indirectIndexAccess ctable [ str [ l ] % 65 ] [ k ] [ 1 ]
<operator>.indirectIndexAccess str [ y + 1 ]
<operator>.indirectIndexAccess str [ y ]
<operator>.indirectIndexAccess ctable [ str [ l ] % 65 ]
<operator>.indirectIndexAccess ctable [ str [ l ] % 65 ]
<operator>.indirectIndexAccess ctable [ str [ l ] % 65 ] [ k ]
<operator>.indirectIndexAccess ctable [ str [ l ] % 65 ]
<operator>.indirectIndexAccess str [ l ]
<operator>.indirectIndexAccess str [ l ]
<operator>.indirectIndexAccess str [ l ]
>>>PDG&44 0->2 0->3 0->5 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->21 3->1 4->1 4->1 4->1 4->4 4->5 4->11 4->17 4->21 4->25 4->28 4->31 4->32 4->37 4->41 5->1 5->1 6->1 6->1 6->1 6->9 6->10 6->14 6->18 6->19 6->23 6->27 6->30 6->34 6->39 6->40 6->43 7->3 8->1 8->1 8->5 9->1 9->1 9->1 10->1 10->1 11->4 11->4 11->6 11->12 11->12 11->26 11->29 11->33 11->38 11->42 12->4 12->4 12->6 12->11 13->1 13->6 13->6 14->1 14->1 14->10 14->14 14->15 14->15 14->16 14->24 14->24 14->35 14->36 15->1 15->14 16->1 16->1 16->1 17->11 17->11 17->13 18->1 19->1 19->1 19->14 20->1 20->23 21->20 22->1 22->27 23->1 23->19 23->19 25->22 25->26 26->22 26->25
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int combi ( int l ) { int k , y ; for ( k = 0 ; ctable [ str [ l ] % 65 ] [ k ] [ 0 ] != str [ l - 1 ] % 65 && ctable [ str [ l ] % 65 ] [ k ] [ 0 ] >= 0 ; k ++ ) ; if ( ctable [ str [ l ] % 65 ] [ k ] [ 0 ] == str [ l - 1 ] % 65 ) { str [ l ] = ctable [ str [ l ] % 65 ] [ k ] [ 1 ] + 65 ; for ( y = l - 2 ; y >= start ; y -- ) str [ y + 1 ] = str [ y ] ; start ++ ; } return 0 ; }
>>>Func
METHOD baseElementToInt
METHOD_RETURN int
PARAM char c
<operator>.assignment ret = - 1
RETURN return ret ; return ret ;
IDENTIFIER c switch(c)
IDENTIFIER ret return ret ;
<operator>.minus - 1
LITERAL 'Q' <empty>
<operator>.assignment ret = 0
LITERAL 'W' <empty>
<operator>.assignment ret = 1
LITERAL 'E' <empty>
<operator>.assignment ret = 2
LITERAL 'R' <empty>
<operator>.assignment ret = 3
LITERAL 'A' <empty>
<operator>.assignment ret = 4
LITERAL 'S' <empty>
<operator>.assignment ret = 5
LITERAL 'D' <empty>
<operator>.assignment ret = 6
LITERAL 'F' <empty>
<operator>.assignment ret = 7
>>>PDG&24 0->2 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 2->1 3->1 3->1 3->1 3->6 4->1 6->4 7->3 9->1 9->1 9->6 11->1 11->1 11->6 13->1 13->1 13->6 15->1 15->1 15->6 17->1 17->1 17->6 19->1 19->1 19->6 21->1 21->1 21->6 23->1 23->1 23->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int baseElementToInt ( char c ) { int ret = - 1 ; switch ( c ) { case 'Q' : ret = 0 ; break ; case 'W' : ret = 1 ; break ; case 'E' : ret = 2 ; break ; case 'R' : ret = 3 ; break ; case 'A' : ret = 4 ; break ; case 'S' : ret = 5 ; break ; case 'D' : ret = 6 ; break ; case 'F' : ret = 7 ; break ; default : break ; } return ret ; }
>>>Func
METHOD avl_tree_balance_to_root
METHOD_RETURN void
PARAM AVLTree * tree
PARAM AVLTreeNode * node
<operator>.assignment rover = node
<operator>.notEquals rover != NULL
<operator>.assignment rover = avl_tree_node_balance ( tree , rover )
<operator>.assignment rover = rover -> parent
avl_tree_node_balance avl_tree_node_balance ( tree , rover )
<operator>.indirectFieldAccess rover -> parent
FIELD_IDENTIFIER parent parent
>>>PDG&11 0->2 0->3 0->4 0->5 0->8 2->1 2->8 3->4 4->1 4->1 4->5 5->1 5->1 5->1 5->5 5->6 5->7 5->8 5->8 5->9 5->10 7->1 7->1 7->5 8->6 8->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static void avl_tree_balance_to_root ( AVLTree * tree , AVLTreeNode * node ) { AVLTreeNode * rover ; rover = node ; while ( rover != NULL ) { rover = avl_tree_node_balance ( tree , rover ) ; rover = rover -> parent ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment start = 0
<operator>.assignment finish = 5
<operator>.assignment steps = 0
printf printf ( "\x49\x6e\x70\x75\x74\x20\x61\x20\x6e\x75\x6d\x62\x65\x72\x2c\x20\x74\x68\x69\x73\x20\x69\x73\x20\x74\x68\x65\x20\x62\x69\x67\x67\x65\x72\x20\x62\x6f\x75\x6e\x64\x20\x6f\x66\x20\x74\x68\x65\x20\x6c\x65\x72\x70\x3a\x5c\x6e\x0" )
scanf scanf ( "%f" , & finish )
printf printf ( "Input a number, this is in how many steps you want to divide the " "lerp:\n" )
scanf scanf ( "%f" , & steps )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < steps + 1
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
printf printf ( "%f\n"   lerp ( start , finish , i / steps ) )
<operator>.addition steps + 1
lerp lerp ( start , finish , i / steps )
<operator>.division i / steps
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->1 2->1 2->16 3->1 3->1 3->6 3->16 4->1 4->8 4->10 4->15 4->17 5->1 6->1 6->16 7->1 8->1 8->10 8->15 8->17 9->1 10->1 10->1 10->1 10->10 10->11 10->14 10->15 10->16 10->17 10->17 11->1 11->10 12->9 13->1 13->10 14->1 14->1 15->1 16->1 16->1 16->1 16->14 16->14 16->14 17->10 17->11 17->15 17->16 17->16
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { float start = 0 ; float finish = 5 ; float steps = 0 ; printf ( "\x49\x6e\x70\x75\x74\x20\x61\x20\x6e\x75\x6d\x62\x65\x72\x2c\x20\x74\x68\x69\x73\x20\x69\x73\x20\x74\x68\x65\x20\x62\x69\x67\x67\x65\x72\x20\x62\x6f\x75\x6e\x64\x20\x6f\x66\x20\x74\x68\x65\x20\x6c\x65\x72\x70\x3a\x5c\x6e\x0" ) ; scanf ( "%f" , & finish ) ; printf ( "Input a number, this is in how many steps you want to divide the " "lerp:\n" ) ; scanf ( "%f" , & steps ) ; for ( int i = 0 ; i < steps + 1 ; i ++ ) { printf ( "%f\n" , lerp ( start , finish , i / steps ) ) ; } return 0 ; }
>>>Func
METHOD removes
METHOD_RETURN int
<operator>.assignment p = p1 = front
<operator>.assignment follow = follow1 = NULL
<operator>.assignment min = front -> data
free free ( p1 )
RETURN return min ; return min ;
empty empty ( )
<operator>.notEquals p != NULL
<operator>.equals p1 == front
IDENTIFIER min return min ;
printf printf ( "\x5c\x6e\x51\x75\x65\x75\x65\x20\x55\x6e\x64\x65\x72\x66\x6c\x6f\x77\x2e\x20\x55\x6e\x61\x62\x6c\x65\x20\x74\x6f\x20\x72\x65\x6d\x6f\x76\x65\x2e\x0" )
exit exit ( 1 )
<operator>.assignment p1 = front
<operator>.assignment follow1 = NULL
<operator>.assignment follow = p
<operator>.assignment p = p -> next
<operator>.assignment front = front -> next
<operator>.lessThan p -> data < min
<operator>.equals front == NULL
<operator>.assignment min = p -> data
<operator>.assignment follow1 = follow
<operator>.assignment p1 = p
<operator>.assignment rear = NULL
<operator>.equals p1 == rear
<operator>.assignment rear = follow1
<operator>.assignment rear -> next = NULL
<operator>.assignment follow1 -> next = p1 -> next
<operator>.indirectFieldAccess p -> next
<operator>.indirectFieldAccess front -> next
<operator>.indirectFieldAccess p -> data
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER data data
<operator>.indirectFieldAccess p -> data
FIELD_IDENTIFIER data data
<operator>.indirectFieldAccess rear -> next
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess follow1 -> next
<operator>.indirectFieldAccess p1 -> next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
>>>PDG&42 0->2 0->3 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->18 0->19 0->21 0->22 0->23 0->24 0->25 0->26 2->1 2->1 2->8 3->1 3->1 3->1 3->21 4->1 4->1 4->1 4->10 4->18 5->1 6->1 7->1 7->11 7->12 8->1 8->1 8->1 8->8 8->15 8->15 8->16 8->18 8->19 8->22 8->26 8->28 8->30 8->31 8->33 9->1 9->1 9->5 9->17 9->19 9->24 9->24 9->29 9->32 10->6 11->1 13->2 13->9 14->1 14->3 14->25 15->1 15->1 15->21 16->1 16->1 16->8 17->1 17->1 17->19 18->1 18->1 18->1 18->10 18->20 18->20 18->21 18->22 18->34 18->35 19->1 19->1 19->1 19->23 19->23 20->1 20->1 20->1 20->10 20->18 21->1 21->1 21->25 22->1 22->9 23->1 23->1 23->1 24->1 24->1 24->5 24->25 24->26 24->27 24->36 24->37 24->38 24->39 24->40 24->41 25->1 25->1 25->1 26->1 26->1 26->1 27->1 27->1 27->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int removes ( ) { int min ; struct node * follow , * follow1 , * p , * p1 ; if ( empty ( ) ) { printf ( "\x5c\x6e\x51\x75\x65\x75\x65\x20\x55\x6e\x64\x65\x72\x66\x6c\x6f\x77\x2e\x20\x55\x6e\x61\x62\x6c\x65\x20\x74\x6f\x20\x72\x65\x6d\x6f\x76\x65\x2e\x0" ) ; exit ( 1 ) ; } p = p1 = front ; follow = follow1 = NULL ; min = front -> data ; while ( p != NULL ) { if ( p -> data < min ) { min = p -> data ; follow1 = follow ; p1 = p ; } follow = p ; p = p -> next ; } if ( p1 == front ) { front = front -> next ; if ( front == NULL ) rear = NULL ; } else if ( p1 == rear ) { rear = follow1 ; rear -> next = NULL ; } else follow1 -> next = p1 -> next ; free ( p1 ) ; return min ; }
>>>Func
METHOD getline
METHOD_RETURN char*
PARAM char * buffer
<operator>.assignment * start = buffer ? buffer : private_buffer
<operator>.assignment * p = start
LITERAL 1 while (1)
<operator>.conditional buffer ? buffer : private_buffer
<operator>.assignment * p ++ = ch
<operator>.assignment ch = getchar ( )
LITERAL '\r' <empty>
LITERAL '\n' <empty>
<operator>.assignment * p = 0
RETURN return start ; return start ;
IDENTIFIER EOF <empty>
RETURN return NULL ; return NULL ;
IDENTIFIER start return start ;
IDENTIFIER NULL return NULL ;
<operator>.postIncrement p ++
<operator>.indirection * p ++
getchar getchar ( )
<operator>.indirection * p
>>>PDG&21 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 2->3 2->6 3->1 3->1 3->4 3->15 4->1 4->1 4->1 4->17 6->1 6->1 7->1 7->1 8->1 8->1 8->1 8->7 8->7 8->8 8->11 8->12 8->14 8->17 8->18 8->19 8->20 11->1 11->1 12->1 14->1 15->12 16->14 17->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) lse ndif char * getline ( char * buffer ) { static char private_buffer [ BUFFER_SZ ] ; char * start = buffer ? buffer : private_buffer ; char * p = start ; int ch ; while ( 1 ) { switch ( ( ch = getchar ( ) ) ) { case '\r' : case '\n' : * p = 0 ; return start ; case EOF : return NULL ; } * p ++ = ch ; } }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= T
<operator>.preIncrement ++ i
LITERAL 0 return 0 ;
<operator>.assignment i = 1
scanf scanf ( "%d" , & N )
printf printf ( "Case #%d:\n" , i )
<operator>.lessThan j < N
<operator>.preIncrement ++ j
<operator>.lessThan j < N
<operator>.preIncrement ++ j
<operator>.lessThan j < N
<operator>.preIncrement ++ j
<operator>.lessThan j < N
<operator>.preIncrement ++ j
<operator>.assignment j = 0
<operator>.assignment stats [ j ] . wins = 0
<operator>.assignment stats [ j ] . total = 0
<operator>.assignment j = 0
<operator>.assignment stats [ j ] . owp = 0
<operator>.assignment stats [ j ] . owpcount = 0
<operator>.assignmentDivision stats [ j ] . owp /= ( 1.0 * stats [ j ] . owpcount )
<operator>.assignment j = 0
<operator>.assignment stats [ j ] . oowp = 0
<operator>.assignmentDivision stats [ j ] . oowp /= ( 1.0 * stats [ j ] . owpcount )
<operator>.assignment j = 0
printf printf ( "%.8f\n"   ( 0.25 * stats [ j ] . wins ) / stats [ j ] . total + 0.5 * stats [ j ] . owp + 0.25 * stats [ j ] . oowp )
<operator>.logicalAnd ( c = getchar ( ) ) != EOF && c != '.' && c != '0' && c != '1'
<operator>.lessThan k < N
<operator>.expressionList ++ k   c = getchar ( )
<operator>.lessThan k < N
<operator>.preIncrement ++ k
<operator>.lessThan k < N
<operator>.preIncrement ++ k
<operator>.assignment k = 0
<operator>.assignment team [ j ] [ k ] = c
<operator>.assignment k = 0
<operator>.multiplication 1.0 * stats [ j ] . owpcount
<operator>.assignment k = 0
<operator>.multiplication 1.0 * stats [ j ] . owpcount
<operator>.addition ( 0.25 * stats [ j ] . wins ) / stats [ j ] . total + 0.5 * stats [ j ] . owp + 0.25 * stats [ j ] . oowp
<operator>.logicalAnd ( c = getchar ( ) ) != EOF && c != '.' && c != '0'
<operator>.notEquals c != '1'
<operator>.preIncrement ++ k
<operator>.assignment c = getchar ( )
<operator>.logicalAnd k != j && c != '.'
<operator>.logicalAnd j != k && team [ j ] [ k ] != '.'
<operator>.logicalAnd j != k && team [ j ] [ k ] != '.'
<operator>.addition ( 0.25 * stats [ j ] . wins ) / stats [ j ] . total + 0.5 * stats [ j ] . owp
<operator>.multiplication 0.25 * stats [ j ] . oowp
<operator>.logicalAnd ( c = getchar ( ) ) != EOF && c != '.'
<operator>.notEquals c != '0'
<operator>.postIncrement stats [ j ] . total ++
<operator>.assignmentPlus stats [ j ] . owp += ( stats [ k ] . wins - ( team [ k ] [ j ] == '1' ? 1 : 0 ) ) / ( 1.0 * ( stats [ k ] . total - 1 ) )
<operator>.postIncrement stats [ j ] . owpcount ++
<operator>.assignmentPlus stats [ j ] . oowp += stats [ k ] . owp
<operator>.division ( 0.25 * stats [ j ] . wins ) / stats [ j ] . total
<operator>.multiplication 0.5 * stats [ j ] . owp
<operator>.notEquals ( c = getchar ( ) ) != EOF
<operator>.notEquals c != '.'
<operator>.notEquals k != j
<operator>.notEquals c != '.'
<operator>.equals c == '1'
<operator>.notEquals j != k
<operator>.notEquals team [ j ] [ k ] != '.'
<operator>.notEquals j != k
<operator>.notEquals team [ j ] [ k ] != '.'
<operator>.multiplication 0.25 * stats [ j ] . wins
<operator>.assignment c = getchar ( )
<operator>.postIncrement stats [ j ] . wins ++
<operator>.division ( stats [ k ] . wins - ( team [ k ] [ j ] == '1' ? 1 : 0 ) ) / ( 1.0 * ( stats [ k ] . total - 1 ) )
<operator>.subtraction stats [ k ] . wins - ( team [ k ] [ j ] == '1' ? 1 : 0 )
<operator>.multiplication 1.0 * ( stats [ k ] . total - 1 )
<operator>.conditional team [ k ] [ j ] == '1' ? 1 : 0
<operator>.subtraction stats [ k ] . total - 1
<operator>.equals team [ k ] [ j ] == '1'
<operator>.addressOf & N
<operator>.fieldAccess stats [ j ] . wins
<operator>.fieldAccess stats [ j ] . total
<operator>.fieldAccess stats [ j ] . owp
<operator>.fieldAccess stats [ j ] . owpcount
<operator>.fieldAccess stats [ j ] . owp
<operator>.fieldAccess stats [ j ] . oowp
<operator>.fieldAccess stats [ j ] . oowp
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER wins wins
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER total total
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER owp owp
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER owpcount owpcount
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER owp owp
<operator>.fieldAccess stats [ j ] . owpcount
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER oowp oowp
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER oowp oowp
<operator>.fieldAccess stats [ j ] . owpcount
getchar getchar ( )
<operator>.indirectIndexAccess team [ j ] [ k ]
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER owpcount owpcount
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER owpcount owpcount
<operator>.fieldAccess stats [ j ] . oowp
<operator>.indirectIndexAccess team [ j ]
<operator>.fieldAccess stats [ j ] . total
<operator>.fieldAccess stats [ j ] . owp
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER oowp oowp
<operator>.fieldAccess stats [ j ] . total
<operator>.indirectIndexAccess team [ j ] [ k ]
<operator>.fieldAccess stats [ j ] . owp
<operator>.fieldAccess stats [ j ] . owpcount
<operator>.indirectIndexAccess team [ j ] [ k ]
<operator>.fieldAccess stats [ j ] . oowp
<operator>.fieldAccess stats [ k ] . owp
<operator>.fieldAccess stats [ j ] . wins
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER total total
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER owp owp
getchar getchar ( )
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER total total
<operator>.indirectIndexAccess team [ j ]
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER owp owp
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER owpcount owpcount
<operator>.indirectIndexAccess team [ j ]
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER oowp oowp
<operator>.indirectIndexAccess stats [ k ]
FIELD_IDENTIFIER owp owp
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER wins wins
<operator>.fieldAccess stats [ j ] . wins
<operator>.fieldAccess stats [ k ] . wins
<operator>.indirectIndexAccess stats [ j ]
FIELD_IDENTIFIER wins wins
<operator>.indirectIndexAccess stats [ k ]
FIELD_IDENTIFIER wins wins
<operator>.fieldAccess stats [ k ] . total
<operator>.indirectIndexAccess team [ k ] [ j ]
<operator>.indirectIndexAccess stats [ k ]
FIELD_IDENTIFIER total total
<operator>.indirectIndexAccess team [ k ]
>>>PDG&153 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->28 0->29 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->45 0->46 0->47 0->52 0->54 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->74 0->75 0->76 0->77 0->78 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->9 4->10 4->12 4->14 4->16 4->18 4->21 4->25 4->28 4->79 5->1 5->4 6->3 7->1 7->4 8->1 8->10 8->12 8->14 8->16 8->31 8->33 8->35 9->1 9->5 10->10 10->11 10->11 10->12 10->19 10->20 10->30 10->31 10->31 10->37 10->44 10->53 10->61 10->63 10->71 10->80 10->81 10->87 10->88 10->89 10->90 10->127 11->1 11->10 12->12 12->13 12->13 12->14 12->22 12->23 12->24 12->33 12->33 12->39 12->40 12->66 12->82 12->83 12->84 12->91 12->92 12->93 12->94 12->95 12->96 12->97 12->105 12->106 13->1 13->12 14->14 14->15 14->15 14->16 14->26 14->27 14->35 14->35 14->41 14->42 14->68 14->85 14->86 14->98 14->99 14->100 14->101 14->102 14->107 14->108 15->1 15->14 16->1 16->1 16->1 16->8 16->10 16->16 16->17 16->17 16->29 16->43 16->51 16->52 16->59 16->60 16->70 16->109 16->111 16->112 16->113 16->114 16->122 16->123 16->124 16->125 16->126 16->140 16->141 17->1 17->16 18->10 19->1 20->1 21->12 22->1 22->24 23->1 23->40 24->1 24->1 25->14 26->1 26->27 27->1 27->1 28->1 28->16 29->1 29->1 30->1 30->1 30->1 31->1 31->1 31->10 31->31 31->32 31->38 31->46 31->47 31->48 31->63 31->63 31->103 31->104 31->110 32->1 32->1 32->1 33->1 33->1 33->12 33->33 33->34 33->49 33->66 33->66 34->1 34->33 35->1 35->1 35->14 35->35 35->36 35->50 35->68 35->68 36->1 36->35 37->1 37->31 38->1 38->1 38->67 38->69 39->1 39->33 40->24 40->24 41->1 41->35 42->27 42->27 43->1 43->1 44->1 44->1 44->30 44->30 44->45 45->1 45->30 45->30 45->38 45->64 45->65 46->31 46->32 47->1 47->1 47->32 47->38 47->64 47->65 48->1 48->1 48->1 48->53 48->55 48->65 48->115 48->128 48->129 49->1 49->1 49->1 49->50 49->56 49->57 49->73 49->74 49->75 49->76 49->77 49->78 49->117 49->118 49->131 49->132 49->133 49->134 49->143 49->146 49->147 49->148 49->149 49->150 49->151 49->152 50->1 50->1 50->1 50->49 50->58 50->120 50->121 50->136 50->137 50->138 50->139 51->1 51->1 52->29 52->29 52->43 52->43 53->1 53->1 53->44 53->44 53->48 53->54 54->1 54->38 54->44 54->44 54->45 54->64 54->65 55->1 56->1 56->1 56->24 57->1 57->40 58->1 58->27 59->1 59->29 59->29 59->43 59->43 59->51 59->51 60->29 60->29 60->43 60->43 60->51 60->51 61->1 61->1 61->53 61->53 61->62 62->1 62->38 62->45 62->53 62->53 62->54 62->64 62->65 63->11 63->46 63->48 63->48 63->64 64->48 64->48 64->65 65->1 65->72 65->142 65->144 65->145 66->13 66->34 66->49 66->49 66->67 66->116 66->130 67->1 67->49 67->49 67->69 68->15 68->36 68->50 68->50 68->69 68->119 68->135 69->1 69->50 69->50 69->67 70->59 70->59 71->1 71->1 71->38 71->45 71->54 71->61 71->62 71->64 71->65 72->1 73->1 73->1 73->56 73->56 74->1 74->73 74->73 75->1 75->73 75->73 76->1 77->75 77->75 78->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int team [ MAXN ] [ MAXN ] ; wp stats [ MAXN ] ; int T , N , i , j , k , c ; scanf ( "\x25\x64\x0" , & T ) ; for ( i = 1 ; i <= T ; ++ i ) { scanf ( "%d" , & N ) ; for ( j = 0 ; j < N ; ++ j ) { stats [ j ] . wins = 0 ; stats [ j ] . total = 0 ; while ( ( c = getchar ( ) ) != EOF && c != '.' && c != '0' && c != '1' ) ; for ( k = 0 ; k < N ; ++ k , c = getchar ( ) ) { team [ j ] [ k ] = c ; if ( k != j && c != '.' ) { stats [ j ] . total ++ ; if ( c == '1' ) { stats [ j ] . wins ++ ; } } } } for ( j = 0 ; j < N ; ++ j ) { stats [ j ] . owp = 0 ; stats [ j ] . owpcount = 0 ; for ( k = 0 ; k < N ; ++ k ) { if ( j != k && team [ j ] [ k ] != '.' ) { stats [ j ] . owp += ( stats [ k ] . wins - ( team [ k ] [ j ] == '1' ? 1 : 0 ) ) / ( 1.0 * ( stats [ k ] . total - 1 ) ) ; stats [ j ] . owpcount ++ ; } } stats [ j ] . owp /= ( 1.0 * stats [ j ] . owpcount ) ; } for ( j = 0 ; j < N ; ++ j ) { stats [ j ] . oowp = 0 ; for ( k = 0 ; k < N ; ++ k ) { if ( j != k && team [ j ] [ k ] != '.' ) { stats [ j ] . oowp += stats [ k ] . owp ; } } stats [ j ] . oowp /= ( 1.0 * stats [ j ] . owpcount ) ; } printf ( "Case #%d:\n" , i ) ; for ( j = 0 ; j < N ; ++ j ) { printf ( "%.8f\n" , ( 0.25 * stats [ j ] . wins ) / stats [ j ] . total + 0.5 * stats [ j ] . owp + 0.25 * stats [ j ] . oowp ) ; } } return 0 ; }
>>>Func
METHOD prompt
METHOD_RETURN multi
PARAM char * message
PARAM char terminator
memset memset ( & ret_val   0   sizeof ( multi ) )
printf printf ( message )
<operator>.assignment current_input = 0
set_other_types set_other_types ( & ret_val )
RETURN return ret_val ; return ret_val ;
<operator>.notEquals current_input != terminator
IDENTIFIER ret_val return ret_val ;
<operator>.sizeOf sizeof ( multi )
<operator>.assignment current_input = getchar ( )
add_char add_char ( & ret_val . s , current_input )
getchar getchar ( )
<operator>.addressOf & ret_val . s
<operator>.fieldAccess ret_val . s
FIELD_IDENTIFIER s s
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->12 0->13 2->5 3->9 4->1 4->7 4->10 5->1 5->1 6->1 6->9 7->1 7->1 7->10 8->1 9->1 9->1 9->1 9->9 9->12 9->13 9->14 9->15 9->16 9->17 10->8 11->1 12->1 12->1 12->13 13->1 13->1 13->7 13->9 13->10
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) multi prompt ( char * message , char terminator ) { multi ret_val ; memset ( & ret_val , 0 , sizeof ( multi ) ) ; printf ( message ) ; char current_input = 0 ; while ( current_input != terminator ) { current_input = getchar ( ) ; add_char ( & ret_val . s , current_input ) ; } set_other_types ( & ret_val ) ; return ret_val ; }
>>>Func
METHOD printTable
METHOD_RETURN char
PARAM int logic
PARAM int stage
<operator>.equals stage == 0
<operator>.equals logic == 0
RETURN return '.' ; return '.' ;
<operator>.logicalOr logic == 0 || logic == - 1 || logic == 1 || logic == 2 || logic == 3
LITERAL '.' return '.' ;
RETURN return '.' ; return '.' ;
<operator>.equals logic == - 1
<operator>.logicalOr logic == 0 || logic == - 1 || logic == 1 || logic == 2
<operator>.equals logic == 3
LITERAL '.' return '.' ;
RETURN return '*' ; return '*' ;
<operator>.logicalOr logic == 0 || logic == - 1 || logic == 1
<operator>.equals logic == 2
<operator>.equals logic == - 2
<operator>.minus - 1
LITERAL '*' return '*' ;
<operator>.logicalOr logic == 0 || logic == - 1
<operator>.equals logic == 1
RETURN return 'x' ; return 'x' ;
<operator>.equals logic == 1
<operator>.equals logic == 0
<operator>.equals logic == - 1
<operator>.minus - 2
LITERAL 'x' return 'x' ;
RETURN return '1' ; return '1' ;
<operator>.minus - 1
<operator>.logicalOr logic == 10 || logic == 20 || logic == 30
LITERAL '1' return '1' ;
RETURN return 'N' ; return 'N' ;
<operator>.equals logic == 2
<operator>.logicalOr logic == 10 || logic == 20
<operator>.equals logic == 30
LITERAL 'N' return 'N' ;
RETURN return 'A' ; return 'A' ;
RETURN return '2' ; return '2' ;
<operator>.equals logic == 10
<operator>.equals logic == 20
LITERAL 'A' return 'A' ;
LITERAL '2' return '2' ;
RETURN return '3' ; return '3' ;
LITERAL '3' return '3' ;
>>>PDG&45 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 2->5 2->24 3->4 4->1 4->1 4->5 4->7 4->11 4->15 4->20 4->24 5->1 5->1 5->6 5->10 5->10 5->18 6->1 7->9 7->17 7->26 8->6 9->1 10->14 10->23 10->23 11->7 11->7 11->12 12->7 12->7 12->17 13->9 14->1 15->11 15->11 15->16 16->11 16->11 16->12 16->17 17->22 17->30 17->34 17->39 17->39 18->10 19->14 20->15 20->15 20->21 21->12 21->15 21->15 21->16 21->17 22->1 23->28 23->33 23->33 24->12 24->16 24->17 24->20 24->20 24->21 24->25 24->25 24->29 25->12 25->16 25->17 25->20 25->20 25->21 26->17 27->22 28->1 29->25 30->32 30->37 31->28 32->1 33->38 33->43 34->30 34->30 34->35 35->30 35->30 36->32 37->1 38->1 39->34 39->34 39->35 39->40 39->40 40->34 40->34 40->35 41->37 42->38 43->1 44->43
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) char printTable ( int logic , int stage ) { if ( stage == 0 ) { if ( logic == 0 ) { return '.' ; } else if ( logic == - 1 ) { return '*' ; } else if ( logic == 1 ) { return '1' ; } else if ( logic == 2 ) { return '2' ; } else { return '3' ; } } else { if ( logic == 0 || logic == - 1 || logic == 1 || logic == 2 || logic == 3 ) { return '.' ; } else if ( logic == - 2 ) { return 'x' ; } else if ( logic == 10 || logic == 20 || logic == 30 ) { return 'N' ; } else { return 'A' ; } } }
>>>Func
METHOD read_case
METHOD_RETURN void
PARAM FILE * fp
<operator>.assignment i = 0
<operator>.assignment cidx = 0
<operator>.assignment oidx = 0
fscanf fscanf ( fp , "\x25\x64\x20\x0" , & ncomb )
<operator>.lessThan printf <missing
<operator>.greaterThan ';'> ( "combines = %d\n" , ncomb )
IDENTIFIER ndif <empty>
fscanf fscanf ( fp , "%d " , & nopp )
fscanf fscanf ( fp , "%d " , & nchar )
<operator>.lessThan i < ncomb
<operator>.preIncrement ++ i
<operator>.lessThan i < nopp
<operator>.preIncrement ++ i
<operator>.lessThan i < nchar
<operator>.preIncrement ++ i
<operator>.bracketedPrimary ( "combines = %d\n" , ncomb )
<operator>.assignment i = 0
fscanf fscanf ( fp , "%c%c%c " , & co [ cidx ] . a , & co [ cidx ] . b , & co [ cidx ] . c )
<operator>.lessThan printf <missing
<operator>.greaterThan ';'> ( "combine %c %c to get %c\n" , co [ cidx ] . a , co [ cidx ] . b , co [ cidx ] . c )
<operator>.assignment i = 0
fscanf fscanf ( fp , "%c%c " , & op [ oidx ] . a , & op [ oidx ] . b )
<operator>.lessThan printf <missing
<operator>.greaterThan ';'> ( "%c opposes %c\n" , op [ oidx ] . a , op [ oidx ] . b )
<operator>.assignment i = 0
fscanf fscanf ( fp , "%c" , & tcase [ i ] )
<operator>.lessThan printf <missing
<operator>.greaterThan ';'> ( "test string: %s\n" , tcase )
IDENTIFIER ndif <empty>
<operator>.expressionList "combines = %d\n"   ncomb
<operator>.bracketedPrimary ( "combine %c %c to get %c\n" , co [ cidx ] . a , co [ cidx ] . b , co [ cidx ] . c )
<operator>.bracketedPrimary ( "%c opposes %c\n" , op [ oidx ] . a , op [ oidx ] . b )
<operator>.bracketedPrimary ( "test string: %s\n" , tcase )
<operator>.expressionList "combine %c %c to get %c\n"   co [ cidx ] . a   co [ cidx ] . b   co [ cidx ] . c
<operator>.expressionList "%c opposes %c\n"   op [ oidx ] . a   op [ oidx ] . b
<operator>.expressionList "test string: %s\n"   tcase
UNKNOWN G G
UNKNOWN g g
UNKNOWN x x
UNKNOWN ++ ; ++ ;
UNKNOWN G G
UNKNOWN g g
UNKNOWN x x
UNKNOWN ++ ; ++ ;
UNKNOWN G G
UNKNOWN g g
UNKNOWN f f
<operator>.addressOf & co [ cidx ] . a
<operator>.addressOf & co [ cidx ] . b
<operator>.addressOf & co [ cidx ] . c
<operator>.addressOf & op [ oidx ] . a
<operator>.addressOf & op [ oidx ] . b
<operator>.addressOf & tcase [ i ]
<operator>.fieldAccess co [ cidx ] . a
<operator>.fieldAccess co [ cidx ] . b
<operator>.fieldAccess co [ cidx ] . c
<operator>.fieldAccess op [ oidx ] . a
<operator>.fieldAccess op [ oidx ] . b
<operator>.indirectIndexAccess tcase [ i ]
<operator>.indirectIndexAccess co [ cidx ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess co [ cidx ]
FIELD_IDENTIFIER b b
<operator>.indirectIndexAccess co [ cidx ]
FIELD_IDENTIFIER c c
<operator>.fieldAccess co [ cidx ] . a
<operator>.fieldAccess co [ cidx ] . b
<operator>.fieldAccess co [ cidx ] . c
<operator>.indirectIndexAccess op [ oidx ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess op [ oidx ]
FIELD_IDENTIFIER b b
<operator>.fieldAccess op [ oidx ] . a
<operator>.fieldAccess op [ oidx ] . b
<operator>.indirectIndexAccess co [ cidx ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess co [ cidx ]
FIELD_IDENTIFIER b b
<operator>.indirectIndexAccess co [ cidx ]
FIELD_IDENTIFIER c c
<operator>.indirectIndexAccess op [ oidx ]
FIELD_IDENTIFIER a a
<operator>.indirectIndexAccess op [ oidx ]
FIELD_IDENTIFIER b b
>>>PDG&87 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->36 0->37 0->38 2->6 4->1 4->1 5->1 5->1 6->1 6->1 6->10 6->12 6->20 6->32 7->1 7->1 7->1 7->21 7->21 7->25 7->25 7->29 7->29 8->1 8->1 10->1 10->1 10->11 10->14 10->24 11->1 11->1 11->1 11->16 11->28 12->1 12->1 12->12 12->13 12->13 12->20 12->21 12->22 12->33 12->36 12->39 12->40 12->41 12->42 12->50 12->51 12->52 12->56 12->57 12->58 12->62 12->63 12->64 12->65 12->66 12->67 12->68 12->69 12->70 12->77 12->78 12->79 12->80 12->81 12->82 13->1 13->12 14->1 14->1 14->14 14->15 14->15 14->24 14->25 14->26 14->34 14->37 14->43 14->44 14->45 14->46 14->53 14->54 14->59 14->60 14->71 14->72 14->73 14->74 14->75 14->76 14->83 14->84 14->85 14->86 15->1 15->14 16->1 16->1 16->1 16->16 16->17 16->17 16->28 16->29 16->30 16->35 16->38 16->47 16->48 16->49 16->55 16->61 17->1 17->16 18->1 18->8 19->12 20->10 20->36 20->36 20->36 21->25 21->25 21->29 21->29 23->14 24->11 24->37 24->37 25->29 25->29 27->1 27->16 28->38 32->12 32->18 32->18 33->22 34->26 35->30 36->20 36->20 36->20 36->33 36->33 36->33 36->33 37->24 37->24 37->34 37->34 37->34 38->28 38->35 38->35
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static void read_case ( FILE * fp ) { int i = 0 ; int cidx = 0 ; int oidx = 0 ; fscanf ( fp , "\x25\x64\x20\x0" , & ncomb ) ; def S_DEBUG printf <missing ';'> ( "combines = %d\n" , ncomb ) ; ndif for ( i = 0 ; i < ncomb ; ++ i ) { fscanf ( fp , "%c%c%c " , & co [ cidx ] . a , & co [ cidx ] . b , & co [ cidx ] . c ) ; def S_DEBUG printf <missing ';'> ( "combine %c %c to get %c\n" , co [ cidx ] . a , co [ cidx ] . b , co [ cidx ] . c ) ; ndif cidx ++ ; } fscanf ( fp , "%d " , & nopp ) ; for ( i = 0 ; i < nopp ; ++ i ) { fscanf ( fp , "%c%c " , & op [ oidx ] . a , & op [ oidx ] . b ) ; def S_DEBUG printf <missing ';'> ( "%c opposes %c\n" , op [ oidx ] . a , op [ oidx ] . b ) ; ndif oidx ++ ; } fscanf ( fp , "%d " , & nchar ) ; for ( i = 0 ; i < nchar ; ++ i ) { fscanf ( fp , "%c" , & tcase [ i ] ) ; def S_DEBUG printf <missing ';'> ( "test string: %s\n" , tcase ) ; ndif } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment c = argv [ 1 ] [ 0 ]
RETURN return 0 ; return 0 ;
<operator>.greaterThan c > 127
<operator>.equals c == 63
LITERAL 0 return 0 ;
printf printf ( "\x69\x66\x2d\x31\x2d\x77\x69\x6e\x20\x0" )
printf printf ( "if-2-win\n" )
printf printf ( "if-1-lose " )
printf printf ( "if-2-lose\n" )
>>>PDG&13 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 3->1 4->1 4->1 4->6 5->1 6->1 6->7 6->9 6->11 7->1 7->1 7->10 7->12 8->5 9->1 10->1 11->1 12->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * argv [ ] ) { unsigned char c = argv [ 1 ] [ 0 ] ; if ( c > 127 ) printf ( "\x69\x66\x2d\x31\x2d\x77\x69\x6e\x20\x0" ) ; else printf ( "if-1-lose " ) ; if ( c == 63 ) printf ( "if-2-win\n" ) ; else printf ( "if-2-lose\n" ) ; return 0 ; }
>>>Func
METHOD binary
METHOD_RETURN int
PARAM int a [ ]
PARAM int n
PARAM int m
PARAM int l
PARAM int u
<operator>.assignment c = 0
<operator>.lessEqualsThan l <= u
<operator>.assignment mid = ( l + u ) / 2
<operator>.equals m == a [ mid ]
RETURN return c ; return c ;
<operator>.division ( l + u ) / 2
<operator>.assignment c = 1
IDENTIFIER c return c ;
<operator>.addition l + u
<operator>.lessThan m < a [ mid ]
RETURN return binary ( a , n , m , l , mid - 1 ) ; return binary ( a , n , m , l , mid - 1 ) ;
binary binary ( a , n , m , l , mid - 1 )
RETURN return binary ( a , n , m , mid + 1 , u ) ; return binary ( a , n , m , mid + 1 , u ) ;
binary binary ( a , n , m , mid + 1 , u )
<operator>.subtraction mid - 1
<operator>.addition mid + 1
<operator>.indirectIndexAccess a [ mid ]
<operator>.indirectIndexAccess a [ mid ]
>>>PDG&25 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->12 0->13 0->14 0->15 0->16 0->18 0->20 0->21 0->22 2->10 2->16 2->18 2->20 3->18 3->20 4->10 5->8 6->8 7->1 7->1 7->14 8->1 8->9 8->10 8->11 8->12 8->12 8->12 8->15 8->15 8->15 8->18 8->20 8->23 9->1 9->1 9->20 9->21 9->22 10->1 10->13 10->16 10->16 10->16 10->24 11->1 12->1 12->9 12->9 14->11 15->1 16->1 16->1 16->17 16->18 16->18 16->18 16->19 16->20 16->20 16->20 16->21 16->22 17->1 18->1 18->1 18->1 18->1 18->1 18->1 18->17 19->1 20->19 21->1 21->18 21->18
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int binary ( int a [ ] , int n , int m , int l , int u ) { int mid , c = 0 ; if ( l <= u ) { mid = ( l + u ) / 2 ; if ( m == a [ mid ] ) { c = 1 ; } else if ( m < a [ mid ] ) { return binary ( a , n , m , l , mid - 1 ) ; } else return binary ( a , n , m , mid + 1 , u ) ; } else return c ; }
>>>Func
METHOD printelements
METHOD_RETURN void
printf printf ( "\x5b\x0" )
printf printf ( "]\n" )
<operator>.lessThan i < elen
<operator>.postIncrement i ++
<operator>.assignment i = 0
printf printf ( "%c" , elist [ i ] )
<operator>.greaterThan i > 0
printf printf ( ", " )
<operator>.indirectIndexAccess elist [ i ]
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 3->1 4->1 4->1 4->1 4->4 4->5 4->7 4->8 4->8 4->10 5->1 5->4 6->1 6->4 7->1 7->1 8->1 8->5 8->9 9->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void printelements ( ) { int i ; printf ( "\x5b\x0" ) ; for ( i = 0 ; i < elen ; i ++ ) { if ( i > 0 ) printf ( ", " ) ; printf ( "%c" , elist [ i ] ) ; } printf ( "]\n" ) ; }
>>>Func
METHOD maxNumberOfBalloons
METHOD_RETURN int
PARAM char * text
<operator>.assignment count_letters [ 5 ] = { 0 }
<operator>.assignmentDivision count_letters [ 2 ] /= 2
<operator>.assignmentDivision count_letters [ 3 ] /= 2
<operator>.assignment min_counter_ballons = count_letters [ 0 ]
RETURN return min_counter_ballons ; return min_counter_ballons ;
<operator>.postIncrement ptr ++
<operator>.lessThan i < 5
<operator>.postIncrement i ++
IDENTIFIER min_counter_ballons return min_counter_ballons ;
<operator>.arrayInitializer { 0 }
<operator>.assignment * ptr = text
<operator>.assignment i = 1
<operator>.equals * ptr == 'b'
<operator>.lessThan count_letters [ i ] < min_counter_ballons
<operator>.postIncrement count_letters [ 0 ] ++
<operator>.assignment min_counter_ballons = count_letters [ i ]
<operator>.equals * ptr == 'a'
<operator>.postIncrement count_letters [ 1 ] ++
<operator>.equals * ptr == 'l'
<operator>.postIncrement count_letters [ 2 ] ++
<operator>.equals * ptr == 'o'
<operator>.postIncrement count_letters [ 3 ] ++
<operator>.equals * ptr == 'n'
<operator>.postIncrement count_letters [ 4 ] ++
<operator>.indirection * ptr
<operator>.indirection * ptr
<operator>.indirectIndexAccess count_letters [ i ]
<operator>.indirectIndexAccess count_letters [ 0 ]
<operator>.indirectIndexAccess count_letters [ i ]
<operator>.indirection * ptr
<operator>.indirectIndexAccess count_letters [ 1 ]
<operator>.indirection * ptr
<operator>.indirectIndexAccess count_letters [ 2 ]
<operator>.indirection * ptr
<operator>.indirectIndexAccess count_letters [ 3 ]
<operator>.indirection * ptr
<operator>.indirectIndexAccess count_letters [ 4 ]
>>>PDG&40 0->2 0->4 0->5 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->19 0->21 0->23 0->25 2->13 3->1 3->1 3->1 3->4 3->5 3->6 3->16 3->17 3->18 3->20 3->22 3->24 3->26 4->1 4->1 5->1 5->1 6->1 6->1 6->1 6->11 6->16 7->1 8->1 8->1 9->1 9->1 9->9 9->10 9->10 9->16 9->29 10->1 10->9 11->7 12->3 13->1 13->1 13->1 13->8 14->1 14->9 15->1 15->1 15->8 15->17 15->19 15->19 15->30 15->32 16->1 16->1 16->1 16->11 16->18 16->18 16->31 17->1 17->6 18->1 18->1 18->1 18->11 18->16 19->1 19->1 19->8 19->15 19->20 19->21 19->21 19->33 19->34 20->1 20->1 21->1 21->1 21->8 21->15 21->22 21->23 21->23 21->35 21->36 22->1 22->4 23->1 23->1 23->8 23->15 23->24 23->25 23->25 23->37 23->38 24->1 24->5 25->1 25->1 25->8 25->15 25->26 25->39 26->1 26->1 27->8 27->15 27->27 27->28
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int maxNumberOfBalloons ( char * text ) { int count_letters [ 5 ] = { 0 } ; int i , min_counter_ballons ; for ( char * ptr = text ; * ptr ; ptr ++ ) { if ( * ptr == 'b' ) { count_letters [ 0 ] ++ ; } else if ( * ptr == 'a' ) { count_letters [ 1 ] ++ ; } else if ( * ptr == 'l' ) { count_letters [ 2 ] ++ ; } else if ( * ptr == 'o' ) { count_letters [ 3 ] ++ ; } else if ( * ptr == 'n' ) { count_letters [ 4 ] ++ ; } } count_letters [ 2 ] /= 2 ; count_letters [ 3 ] /= 2 ; min_counter_ballons = count_letters [ 0 ] ; for ( i = 1 ; i < 5 ; i ++ ) { if ( count_letters [ i ] < min_counter_ballons ) min_counter_ballons = count_letters [ i ] ; } return min_counter_ballons ; }
>>>Func
METHOD crc32
METHOD_RETURN uint32_t
PARAM const char * s
<operator>.assignment crc = 0xffffffff
<operator>.assignment i = 0
RETURN return crc ^ 0xffffffff ; return crc ^ 0xffffffff ;
<operator>.notEquals s [ i ] != '\0'
<operator>.xor crc ^ 0xffffffff
<operator>.assignment byte = s [ i ]
<operator>.assignment crc = crc ^ byte
<operator>.postIncrement i ++
<operator>.greaterThan j > 0
<operator>.preDecrement -- j
<operator>.xor crc ^ byte
<operator>.assignment j = 8
<operator>.assignment crc = ( crc >> 1 ) ^ ( 0xEDB88320 & ( - ( crc & 1 ) ) )
<operator>.xor ( crc >> 1 ) ^ ( 0xEDB88320 & ( - ( crc & 1 ) ) )
<operator>.arithmeticShiftRight crc >> 1
<operator>.and 0xEDB88320 & ( - ( crc & 1 ) )
<operator>.minus - ( crc & 1 )
<operator>.and crc & 1
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i ]
>>>PDG&23 0->2 0->3 0->4 0->6 0->7 0->10 0->11 0->12 0->13 0->14 0->17 0->18 0->20 2->1 2->6 2->8 3->1 3->7 3->13 4->1 4->1 4->10 5->1 6->1 6->1 6->6 6->8 6->8 6->9 6->10 6->11 6->13 6->14 6->21 6->22 7->1 7->1 7->5 8->1 8->13 9->1 9->1 9->7 9->13 9->17 10->1 10->1 11->1 11->1 11->11 11->12 11->12 11->15 11->16 11->17 11->18 11->19 11->20 12->1 12->11 13->1 13->9 13->9 14->1 14->11 15->1 15->1 15->7 15->13 15->17 16->1 16->1 16->15 16->15 17->16 17->16 17->20 18->1 18->16 18->16 19->1 19->18 20->19 20->19
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) uint32_t crc32 ( const char * s ) { uint32_t crc = 0xffffffff ; size_t i = 0 ; while ( s [ i ] != '\0' ) { uint8_t byte = s [ i ] ; crc = crc ^ byte ; for ( uint8_t j = 8 ; j > 0 ; -- j ) { crc = ( crc >> 1 ) ^ ( 0xEDB88320 & ( - ( crc & 1 ) ) ) ; } i ++ ; } return crc ^ 0xffffffff ; }
>>>Func
METHOD min_denom_cond
METHOD_RETURN int
PARAM int N
PARAM int PERC
<operator>.assignment arr [ ] = { 0   100   50   0   25   20   100   100   12.5   100   10 }
<operator>.assignment flag = 0
RETURN return flag ; return flag ;
<operator>.lessEqualsThan i <= N
<operator>.postIncrement i ++
IDENTIFIER flag return flag ;
<operator>.arrayInitializer { 0   100   50   0   25   20   100   100   12.5   100   10 }
<operator>.assignment i = 1
<operator>.equals fmod ( PERC / arr [ i ] , 1.0 ) == 0.0
<operator>.assignment flag = 1
fmod fmod ( PERC / arr [ i ] , 1.0 )
<operator>.division PERC / arr [ i ]
<operator>.indirectIndexAccess arr [ i ]
>>>PDG&17 0->2 0->3 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->7 3->1 3->15 4->1 4->1 4->1 4->15 5->1 5->1 5->9 6->1 7->1 7->1 7->1 7->8 7->12 7->14 7->15 7->16 8->1 8->7 9->6 10->4 10->4 10->4 10->4 10->4 10->4 10->4 11->1 11->7 12->1 12->1 12->7 12->8 12->13 13->1 13->1 13->9 14->1 14->12 14->12 15->1 15->1 15->14 15->14
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int min_denom_cond ( int N , int PERC ) { float arr [ ] = { 0 , 100 , 50 , 0 , 25 , 20 , 100 , 100 , 12.5 , 100 , 10 } ; int i ; int flag = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( fmod ( PERC / arr [ i ] , 1.0 ) == 0.0 ) { flag = 1 ; break ; } } return flag ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan pp <= t
<operator>.postIncrement pp ++
LITERAL 0 return 0 ;
<operator>.assignment pp = 1
scanf scanf ( "%d%d%d" , & n , & pd , & pg )
<operator>.assignment D = ( 100 / gcd ( 100 , pd ) )
printf printf ( "Case #%d: Possible\n" , pp )
<operator>.equals pd == 0
<operator>.greaterThan D > n
<operator>.logicalAnd pg == 100 && pd < 100
<operator>.logicalAnd pg == 0 && pd > 0
<operator>.division 100 / gcd ( 100 , pd )
printf printf ( "Case #%d: Broken\n" , pp )
printf printf ( "Case #%d: Broken\n" , pp )
printf printf ( "Case #%d: Broken\n" , pp )
<operator>.notEquals pg != 100
gcd gcd ( 100 , pd )
<operator>.equals pg == 100
<operator>.lessThan pd < 100
<operator>.equals pg == 0
<operator>.greaterThan pd > 0
printf printf ( "Case #%d: Possible\n" , pp )
printf printf ( "Case #%d: Broken\n" , pp )
<operator>.addressOf & n
<operator>.addressOf & pd
<operator>.addressOf & pg
>>>PDG&30 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->10 4->11 4->16 4->17 4->18 4->25 4->26 4->27 4->28 4->29 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->12 9->1 9->1 9->12 10->1 10->5 11->1 11->1 11->9 11->12 11->15 11->19 11->20 11->20 12->1 12->1 12->1 12->8 12->13 12->16 12->21 13->1 13->1 13->1 13->14 13->17 13->23 14->1 14->1 14->1 14->10 14->18 15->1 15->9 15->9 16->1 16->5 17->1 17->5 18->1 18->5 19->1 19->1 19->21 19->25 19->26 20->1 20->11 20->15 20->15 20->22 20->24 21->1 21->13 21->13 21->19 21->22 21->23 22->1 22->11 22->13 22->13 22->24 23->1 23->14 23->14 23->19 23->21 23->24 24->1 24->11 24->14 24->14 25->1 25->5 26->1 26->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int t ; scanf ( "\x25\x64\x0" , & t ) ; int pp ; for ( pp = 1 ; pp <= t ; pp ++ ) { int n , pd , pg ; scanf ( "%d%d%d" , & n , & pd , & pg ) ; if ( pd == 0 ) { if ( pg != 100 ) printf ( "Case #%d: Possible\n" , pp ) ; else printf ( "Case #%d: Broken\n" , pp ) ; continue ; } int D = ( 100 / gcd ( 100 , pd ) ) ; if ( D > n ) { printf ( "Case #%d: Broken\n" , pp ) ; continue ; } if ( pg == 100 && pd < 100 ) { printf ( "Case #%d: Broken\n" , pp ) ; continue ; } if ( pg == 0 && pd > 0 ) { printf ( "Case #%d: Broken\n" , pp ) ; continue ; } printf ( "Case #%d: Possible\n" , pp ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf ( "\x45\x6e\x74\x65\x72\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x74\x65\x73\x74\x20\x63\x61\x73\x65\x73\x20\x3a\x20\x0" )
scanf scanf ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.postDecrement T --
LITERAL 0 return 0 ;
<operator>.assignment a [ 1 ] = 1
<operator>.assignment carry = 0
<operator>.assignment count = 0
printf printf ( "Enter a number : " )
scanf scanf ( "%d" , & N )
printf printf ( "\n" )
<operator>.lessThan i < 16500
<operator>.postIncrement i ++
<operator>.lessEqualsThan i <= N
<operator>.postIncrement i ++
<operator>.lessThan i < 16500
<operator>.postIncrement i ++
<operator>.greaterThan i > 0
<operator>.postDecrement i --
<operator>.assignment i = 0
<operator>.assignment a [ i ] = 0
<operator>.assignment i = 1
<operator>.assignment carry = 0
<operator>.assignment i = 0
<operator>.assignment i = count
printf printf ( "%d" , a [ i ] )
<operator>.lessThan j < 16500
<operator>.postIncrement j ++
<operator>.notEquals a [ i ] != 0
<operator>.assignment j = 0
<operator>.assignment a [ j ] = a [ j ] * i + carry
<operator>.assignment carry = a [ j ] / 10
<operator>.assignment a [ j ] = a [ j ] % 10
<operator>.assignment count = i
<operator>.addition a [ j ] * i + carry
<operator>.division a [ j ] / 10
<operator>.modulo a [ j ] % 10
<operator>.multiplication a [ j ] * i
<operator>.indirectIndexAccess a [ 1 ]
<operator>.addressOf & N
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
>>>PDG&50 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->35 0->36 0->37 0->38 0->39 2->1 3->1 3->5 4->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->12 5->13 5->15 5->17 5->19 5->21 5->23 5->25 5->26 5->40 5->41 6->4 7->1 7->1 8->1 8->1 9->1 9->26 10->1 11->1 11->15 12->1 13->13 13->14 13->14 13->22 13->42 14->1 14->13 15->1 15->1 15->11 15->15 15->16 15->16 15->24 15->28 15->31 15->39 16->1 16->15 17->1 17->17 17->18 17->18 17->30 17->35 17->44 18->1 18->17 19->1 19->1 19->19 19->20 19->20 19->27 19->43 20->1 20->19 21->13 22->1 22->1 22->27 22->30 23->1 23->15 24->1 24->1 24->32 24->36 25->1 25->17 26->1 26->1 26->19 27->1 27->1 27->30 28->1 28->1 28->28 28->29 28->29 28->32 28->33 28->34 28->36 28->37 28->38 28->39 28->45 28->46 28->47 28->48 28->49 29->1 29->28 30->1 30->1 30->27 30->35 31->1 31->28 32->1 32->1 32->37 33->1 33->1 33->1 33->32 33->36 34->1 34->1 34->1 34->39 35->1 35->26 36->1 37->33 37->33 37->38 38->34 38->34 39->16 39->32 39->32 39->36 39->36
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { int a [ 16500 ] , T ; long long int i , j ; printf ( "\x45\x6e\x74\x65\x72\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x66\x20\x74\x65\x73\x74\x20\x63\x61\x73\x65\x73\x20\x3a\x20\x0" ) ; scanf ( "%d" , & T ) ; while ( T -- ) { for ( i = 0 ; i < 16500 ; i ++ ) { a [ i ] = 0 ; } a [ 1 ] = 1 ; int N , carry = 0 , count = 0 ; printf ( "Enter a number : " ) ; scanf ( "%d" , & N ) ; for ( i = 1 ; i <= N ; i ++ ) { carry = 0 ; for ( j = 0 ; j < 16500 ; j ++ ) { a [ j ] = a [ j ] * i + carry ; carry = a [ j ] / 10 ; a [ j ] = a [ j ] % 10 ; } } for ( i = 0 ; i < 16500 ; i ++ ) { if ( a [ i ] != 0 ) { count = i ; } } for ( i = count ; i > 0 ; i -- ) { printf ( "%d" , a [ i ] ) ; } printf ( "\n" ) ; } return 0 ; }
>>>Func
METHOD printsTray
METHOD_RETURN void
PARAM int mat [ 10 ] [ 10 ]
PARAM int stage
printf printf ( "\x20\x20\x20\x20\x20\x0" )
printf printf ( "\n" )
<operator>.lessThan i < 75
<operator>.postIncrement i ++
<operator>.lessThan i < 12
<operator>.postIncrement i ++
<operator>.assignment i = 65
printf printf ( "%c" , i )
<operator>.assignment i = 0
printf printf ( "\n" )
<operator>.lessThan i < 74
<operator>.logicalAnd i > 0 && i < 11
<operator>.lessThan j < 12
<operator>.postIncrement j ++
printf printf ( " " )
printf printf ( "%02d " , i )
<operator>.assignment j = 0
<operator>.greaterThan i > 0
<operator>.lessThan i < 11
printf printf ( "   " )
<operator>.logicalAnd ( i > 0 && i < 11 ) && ( j > 0 && j < 11 )
<operator>.lessThan j < 11
<operator>.assignment logic = mat [ i - 1 ] [ j - 1 ]
<operator>.assignment imp = printTable ( logic , stage )
printf printf ( "%c" , imp )
printf printf ( " " )
<operator>.logicalAnd i > 0 && i < 11
<operator>.logicalAnd j > 0 && j < 11
printf printf ( "#" )
<operator>.greaterThan i > 0
<operator>.lessThan i < 11
<operator>.greaterThan j > 0
<operator>.lessThan j < 11
printTable printTable ( logic , stage )
<operator>.subtraction j - 1
<operator>.subtraction i - 1
<operator>.indirectIndexAccess mat [ i - 1 ] [ j - 1 ]
<operator>.indirectIndexAccess mat [ i - 1 ]
>>>PDG&42 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->28 0->29 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 2->1 3->1 3->37 4->1 5->1 6->1 6->6 6->7 6->11 6->11 6->14 7->1 7->6 8->1 8->1 8->8 8->9 8->13 8->15 8->16 8->20 8->21 8->21 9->1 9->8 10->1 10->6 11->14 12->1 12->8 14->7 14->18 15->19 15->23 15->30 16->16 16->17 16->24 16->25 16->25 16->30 16->33 16->35 16->38 17->16 19->9 19->33 20->16 21->9 21->15 21->15 21->19 21->22 21->22 21->33 22->9 22->15 22->15 22->19 22->33 24->26 24->27 24->28 24->32 24->37 24->38 24->39 24->40 24->41 25->17 25->29 25->31 26->37 27->28 30->15 30->24 30->24 30->31 30->35 31->24 31->24 33->9 33->30 33->30 33->34 33->34 33->39 34->9 34->30 34->30 34->33 34->39 35->25 35->31 35->31 35->36 35->36 35->38 36->25 36->31 36->31 36->38 37->27 37->27 38->25 39->9 39->33
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  void printsTray ( int mat [ 10 ] [ 10 ] , int stage ) { int logic ; char imp ; printf ( "\x20\x20\x20\x20\x20\x0" ) ; for ( int i = 65 ; i < 75 ; i ++ ) { printf ( "%c" , i ) ; if ( i < 74 ) { printf ( " " ) ; } } printf ( "\n" ) ; for ( int i = 0 ; i < 12 ; i ++ ) { if ( i > 0 && i < 11 ) { printf ( "%02d " , i ) ; } else { printf ( "   " ) ; } for ( int j = 0 ; j < 12 ; j ++ ) { if ( ( i > 0 && i < 11 ) && ( j > 0 && j < 11 ) ) { logic = mat [ i - 1 ] [ j - 1 ] ; imp = printTable ( logic , stage ) ; printf ( "%c" , imp ) ; } else { printf ( "#" ) ; } if ( j < 11 ) { printf ( " " ) ; } } printf ( "\n" ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment i = 1
<operator>.assignment decimalNumber = ( int ) argv [ 1 ] [ 0 ]
<operator>.assignment quotient = decimalNumber
printf printf ( "\x45\x71\x75\x69\x76\x61\x6c\x65\x6e\x74\x20\x6f\x63\x74\x61\x6c\x20\x76\x61\x6c\x75\x65\x20\x6f\x66\x20\x64\x65\x63\x69\x6d\x61\x6c\x20\x6e\x75\x6d\x62\x65\x72\x20\x25\x64\x3a\x20\x5c\x6e\x0" , decimalNumber )
RETURN return 0 ; return 0 ;
<operator>.lessThan argc < 2
<operator>.notEquals quotient != 0
<operator>.greaterThan j > 0
<operator>.postDecrement j --
printf printf ( "%d" , octalNumber [ j ] )
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
<operator>.assignment octalNumber [ i ++ ] = quotient % 8
<operator>.assignment quotient = quotient / 8
<operator>.assignment j = i - 1
LITERAL 1 return 1 ;
<operator>.modulo quotient % 8
<operator>.division quotient / 8
<operator>.subtraction i - 1
<operator>.postIncrement i ++
<operator>.cast ( int ) argv [ 1 ] [ 0 ]
UNKNOWN int int
<operator>.indirectIndexAccess argv [ 1 ] [ 0 ]
<operator>.indirectIndexAccess octalNumber [ j ]
<operator>.indirectIndexAccess argv [ 1 ]
<operator>.indirectIndexAccess octalNumber [ i ++ ]
>>>PDG&30 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->19 0->20 0->21 0->22 0->23 2->9 3->1 4->22 4->23 5->6 5->7 6->10 8->1 9->1 9->1 9->4 9->5 9->6 9->7 9->8 9->10 9->11 9->15 9->18 9->22 9->24 9->25 9->26 9->28 10->10 10->16 10->17 10->20 10->20 10->21 10->23 10->29 11->11 11->12 11->12 11->13 11->27 12->11 14->8 15->1 17->10 18->11 19->15 20->16 20->16 20->21 21->17 21->17 22->18 22->18 23->22
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * argv [ ] ) { if ( argc < 2 ) return 1 ; long int decimalNumber , remainder , quotient ; int octalNumber [ 100 ] , i = 1 , j ; decimalNumber = ( int ) argv [ 1 ] [ 0 ] ; quotient = decimalNumber ; while ( quotient != 0 ) { octalNumber [ i ++ ] = quotient % 8 ; quotient = quotient / 8 ; } printf ( "\x45\x71\x75\x69\x76\x61\x6c\x65\x6e\x74\x20\x6f\x63\x74\x61\x6c\x20\x76\x61\x6c\x75\x65\x20\x6f\x66\x20\x64\x65\x63\x69\x6d\x61\x6c\x20\x6e\x75\x6d\x62\x65\x72\x20\x25\x64\x3a\x20\x5c\x6e\x0" , decimalNumber ) ; for ( j = i - 1 ; j > 0 ; j -- ) printf ( "%d" , octalNumber [ j ] ) ; return 0 ; }
>>>Func
METHOD run
METHOD_RETURN float
PARAM int l
PARAM float t
PARAM int n
<operator>.assignment min = 0
<operator>.assignment sum = 0
<operator>.lessThan SGLIB_ARRAY_SINGLE_QUICK_SORT <missing
<operator>.assignment sum = 0
RETURN return ( sum ) ; return ( sum ) ;
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < ( n - min )
<operator>.postIncrement i ++
<operator>.assignment sorted [ i ] = i + min
<operator>.lessThan i < ( n - min )
<operator>.postIncrement i ++
<operator>.expressionList i < ( n - min )   i < l
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignmentPlus sum += 2 * dist [ i ]
IDENTIFIER sum return ( sum ) ;
<operator>.assignment i = 0
<operator>.assignmentPlus sum += dist [ i ]
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.equals sorted [ i ] == min
<operator>.assignment i = 0
<operator>.assignmentDivision dist [ sorted [ i ] ] /= 2
<operator>.assignment i = 0
<operator>.greaterEqualsThan sum >= t
<operator>.subtraction n - min
<operator>.addition i + min
<operator>.subtraction n - min
<operator>.assignment j = i
<operator>.preDecrement -- i
<operator>.assignment sorted [ j ] = sorted [ i ]
<operator>.assignment sorted [ i ] = min
<operator>.lessThan i < ( n - min )
<operator>.lessThan i < l
<operator>.logicalAnd sorted [ i ] == min && sum - dist [ min ] < t
<operator>.multiplication 2 * dist [ i ]
<operator>.assignment min = i
<operator>.logicalAnd i < ( n - min ) && dist [ min ] == dist [ sorted [ i ] ]
<operator>.logicalAnd i + 1 < ( n - min ) && dist [ sorted [ i + 1 ] ] > ( sum - t )
<operator>.subtraction n - min
<operator>.assignmentPlus dist [ min ] += ( 2 * t + dist [ min ] - sum ) / 2
<operator>.postIncrement i ++
<operator>.assignment tmp = sorted [ i ]
<operator>.assignment sorted [ i ] = sorted [ i + 1 ]
<operator>.assignment sorted [ i + 1 ] = tmp
<operator>.assignment k = i
<operator>.preDecrement -- i
<operator>.assignment tmp = sorted [ k + 1 ]
<operator>.assignment sorted [ k + 1 ] = sorted [ i ]
<operator>.assignment sorted [ i ] = tmp
<operator>.equals sorted [ i ] == min
<operator>.lessThan sum - dist [ min ] < t
<operator>.lessThan i < ( n - min )
<operator>.equals dist [ min ] == dist [ sorted [ i ] ]
<operator>.lessThan i + 1 < ( n - min )
<operator>.greaterThan dist [ sorted [ i + 1 ] ] > ( sum - t )
<operator>.logicalAnd i < ( n - min ) && dist [ sorted [ i ] ] == dist [ sorted [ k ] ]
<operator>.subtraction sum - dist [ min ]
<operator>.division ( 2 * t + dist [ min ] - sum ) / 2
<operator>.subtraction n - min
<operator>.addition i + 1
<operator>.subtraction n - min
<operator>.subtraction sum - t
<operator>.postIncrement i ++
<operator>.subtraction 2 * t + dist [ min ] - sum
<operator>.addition i + 1
<operator>.addition i + 1
<operator>.lessThan i < ( n - min )
<operator>.equals dist [ sorted [ i ] ] == dist [ sorted [ k ] ]
<operator>.addition k + 1
<operator>.addition k + 1
<operator>.addition 2 * t + dist [ min ]
<operator>.addition i + 1
<operator>.subtraction n - min
<operator>.multiplication 2 * t
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess dist [ i ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess dist [ sorted [ i ] ]
<operator>.indirectIndexAccess dist [ i ]
<operator>.indirectIndexAccess sorted [ j ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess dist [ min ]
<operator>.indirectIndexAccess dist [ min ]
<operator>.indirectIndexAccess dist [ sorted [ i ] ]
<operator>.indirectIndexAccess dist [ sorted [ i + 1 ] ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess sorted [ i + 1 ]
<operator>.indirectIndexAccess sorted [ i + 1 ]
<operator>.indirectIndexAccess sorted [ k + 1 ]
<operator>.indirectIndexAccess sorted [ k + 1 ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess dist [ min ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess sorted [ i + 1 ]
<operator>.indirectIndexAccess dist [ sorted [ i ] ]
<operator>.indirectIndexAccess dist [ sorted [ k ] ]
<operator>.indirectIndexAccess dist [ min ]
<operator>.indirectIndexAccess sorted [ i ]
<operator>.indirectIndexAccess sorted [ k ]
>>>PDG&112 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->42 0->43 0->46 0->48 0->51 0->52 0->53 0->56 0->57 0->58 0->59 0->61 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->76 0->77 0->79 0->80 0->81 2->40 3->1 3->31 3->58 3->69 3->81 4->10 5->1 5->32 6->24 6->64 6->69 6->71 7->1 7->1 7->1 8->1 8->1 8->21 8->22 9->1 10->11 10->24 10->31 10->32 10->43 10->83 11->1 11->10 12->12 12->13 12->13 12->14 12->14 12->32 12->33 12->33 12->82 13->1 13->12 14->1 14->1 14->1 14->27 14->57 15->16 15->27 15->35 15->48 15->84 16->1 16->15 17->1 17->1 17->1 17->17 17->18 17->29 17->39 17->40 17->41 17->46 17->57 17->85 17->90 17->91 18->1 18->39 19->1 19->1 19->1 19->19 19->20 19->20 19->21 19->42 19->86 20->1 20->19 21->1 21->1 21->1 21->22 22->9 23->10 24->1 24->1 24->31 25->12 26->15 27->1 27->1 27->15 27->16 27->34 27->34 27->35 27->36 27->37 27->37 27->38 27->44 27->45 27->48 27->57 27->59 27->61 27->66 27->66 27->67 27->68 27->87 27->88 27->89 28->39 29->1 29->1 30->1 30->19 31->1 31->1 31->10 31->11 31->24 31->43 31->58 31->64 31->69 31->69 31->71 31->81 32->12 32->12 32->14 32->33 32->34 32->34 34->15 34->15 34->27 34->46 34->46 34->66 35->1 35->1 36->1 36->52 36->61 36->67 36->70 36->72 36->73 36->79 37->1 37->1 38->1 38->1 38->49 38->57 39->1 39->17 39->17 39->40 40->1 40->17 40->17 40->18 41->1 41->1 41->1 41->47 41->65 41->71 41->78 41->81 41->92 41->109 42->1 42->21 42->21 43->1 43->32 44->1 44->1 44->44 44->48 44->59 44->66 45->1 45->1 45->1 45->49 45->50 45->51 45->52 45->53 45->54 45->55 45->56 45->63 45->70 45->72 45->73 45->74 45->76 45->77 45->80 45->96 45->97 45->98 45->99 45->100 45->101 45->102 45->103 46->1 46->19 46->39 46->39 46->57 47->1 47->1 47->1 47->64 47->71 47->78 48->1 48->59 49->1 49->51 50->1 50->55 51->1 51->1 52->1 52->76 52->77 53->1 54->1 54->56 55->1 55->1 56->1 56->1 56->1 56->57 57->1 57->41 57->41 57->46 57->58 57->64 57->104 58->1 58->1 58->41 58->41 58->81 59->36 59->44 59->44 59->48 59->60 59->93 59->94 59->105 60->1 60->1 60->29 60->44 60->44 60->47 60->64 60->71 60->75 60->78 61->1 61->45 61->45 61->62 61->69 61->79 61->95 61->106 62->1 62->1 62->45 62->45 63->1 63->1 63->63 63->70 63->74 63->80 64->1 64->47 64->58 64->58 64->71 64->71 64->78 65->1 65->47 65->47 66->38 66->59 66->59 66->68 66->68 68->46 68->46 68->61 68->61 68->80 68->80 69->1 69->58 69->62 69->62 69->64 69->71 69->81 70->1 70->74 71->1 71->64 71->65 71->65 74->53 74->63 74->63 74->70 74->75 74->107 74->108 74->110 74->111 75->1 75->1 75->29 75->63 75->63 77->1 78->1 80->46 80->46 80->74 80->74 81->1 81->58 81->71 81->71 81->78 81->78
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) float run ( int l , float t , int n ) { int min = 0 ; float sum = 0 ; int sorted [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += dist [ i ] ; if ( sum >= t ) { min = i ; break ; } } for ( int i = 0 ; i < ( n - min ) ; i ++ ) sorted [ i ] = i + min ; SGLIB_ARRAY_SINGLE_QUICK_SORT <missing ';'> ( <missing ';'> int , sorted , ( n <missing ';'> - min ) , FLOAT_COMPARATOR ) ; for ( int i = 0 ; i < ( n - min ) ; i ++ ) if ( sorted [ i ] == min ) { int j = i ; do { i ++ ; } while ( i < ( n - min ) && dist [ min ] == dist [ sorted [ i ] ] ) ; -- i ; sorted [ j ] = sorted [ i ] ; sorted [ i ] = min ; if ( i + 1 < ( n - min ) && dist [ sorted [ i + 1 ] ] > ( sum - t ) ) { int tmp = sorted [ i ] ; sorted [ i ] = sorted [ i + 1 ] ; sorted [ i + 1 ] = tmp ; int k = i ; do { i ++ ; } while ( i < ( n - min ) && dist [ sorted [ i ] ] == dist [ sorted [ k ] ] ) ; -- i ; tmp = sorted [ k + 1 ] ; sorted [ k + 1 ] = sorted [ i ] ; sorted [ i ] = tmp ; } break ; } for ( int i = 0 ; i < ( n - min ) , i < l ; i ++ ) { if ( sorted [ i ] == min && sum - dist [ min ] < t ) dist [ min ] += ( 2 * t + dist [ min ] - sum ) / 2 ; dist [ sorted [ i ] ] /= 2 ; } sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += 2 * dist [ i ] ; return ( sum ) ; }
>>>Func
METHOD maxDepth
METHOD_RETURN int
PARAM struct TreeNode * root
<operator>.equals root == NULL
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
RETURN return 1 + maxval ( maxDepth ( root -> left )   maxDepth ( root -> right ) ) ; return 1 + maxval ( maxDepth ( root -> left )   maxDepth ( root -> right ) ) ;
<operator>.addition 1 + maxval ( maxDepth ( root -> left )   maxDepth ( root -> right ) )
maxval maxval ( maxDepth ( root -> left )   maxDepth ( root -> right ) )
maxDepth maxDepth ( root -> left )
maxDepth maxDepth ( root -> right )
<operator>.indirectFieldAccess root -> left
<operator>.indirectFieldAccess root -> right
FIELD_IDENTIFIER left left
FIELD_IDENTIFIER right right
>>>PDG&15 0->2 0->3 0->4 0->5 0->7 2->3 3->1 3->1 3->1 3->4 3->6 3->7 3->8 3->9 3->10 3->11 3->12 3->13 3->14 4->1 5->4 6->1 7->6 8->7 8->7 9->8 10->8
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int maxDepth ( struct TreeNode * root ) { if ( root == NULL ) return 0 ; else return 1 + maxval ( maxDepth ( root -> left ) , maxDepth ( root -> right ) ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment fin = fopen ( "\x4d\x61\x67\x69\x63\x6b\x61\x2e\x69\x6e\x0" , "r" )
<operator>.assignment fout = fopen ( "Magicka.out" , "w" )
fscanf fscanf ( fin , "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < T
<operator>.preIncrement ++ i
work work ( i + 1 )
LITERAL 0 return 0 ;
fopen fopen ( "\x4d\x61\x67\x69\x63\x6b\x61\x2e\x69\x6e\x0" , "r" )
fopen fopen ( "Magicka.out" , "w" )
<operator>.assignment i = 0
<operator>.addition i + 1
>>>PDG&14 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->1 2->1 2->4 3->1 3->1 3->1 4->1 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->8 6->8 6->13 6->13 7->1 7->6 8->1 8->1 9->5 10->2 10->2 11->3 11->3 12->1 12->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { fin = fopen ( "\x4d\x61\x67\x69\x63\x6b\x61\x2e\x69\x6e\x0" , "r" ) ; fout = fopen ( "Magicka.out" , "w" ) ; int i ; fscanf ( fin , "%d" , & T ) ; for ( i = 0 ; i < T ; ++ i ) work ( i + 1 ) ; return 0 ; }
>>>Func
METHOD RightLeftRotate
METHOD_RETURN avlNode
PARAM avlNode * z
<operator>.assignment z -> right = rightRotate ( z -> right )
RETURN return ( leftRotate ( z ) ) ; return ( leftRotate ( z ) ) ;
leftRotate leftRotate ( z )
rightRotate rightRotate ( z -> right )
>>>PDG&7 0->2 0->5 2->5 3->1 3->1 3->1 4->1 5->1 5->1 5->4 6->3
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) avlNode * RightLeftRotate ( avlNode * z ) { z -> right = rightRotate ( z -> right ) ; return ( leftRotate ( z ) ) ; }
>>>Func
METHOD main
METHOD_RETURN int
freopen freopen ( "\x31\x43\x2d\x42\x2e\x69\x6e\x0" , "r" , stdin )
freopen freopen ( "1C-B.out" , "w" , stdout )
scanf scanf ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 1
scanf scanf ( "%d %d %d %d" , & L , & t , & N , & C )
printf printf ( "Case #%d: " , i )
<operator>.assignment sumA = 0
<operator>.assignment sumAll = sumA * ( N / C ) * 2
<operator>.assignment tmpT = t % ( sumA * 2 )
<operator>.assignment a [ j - 1 ] [ 2 ] = 1
<operator>.assignment bet = - tmpT / 2
<operator>.assignment a [ C ] [ 0 ] = bet
<operator>.assignment a [ C ] [ 1 ] = 1
<operator>.assignment a [ C ] [ 2 ] = 2
qsort qsort ( a   C + 1   sizeof ( a [ 0 ] ) , compare )
<operator>.assignment tmpL = L
printf printf ( "%d\n" , sumAll )
<operator>.lessThan j < 1100
<operator>.postIncrement j ++
<operator>.lessThan j < ( N % C )
<operator>.postIncrement j ++
<operator>.greaterThan t > sumAll
<operator>.greaterThan tmpT > 0
<operator>.postIncrement j ++
<operator>.lessThan j < C
<operator>.postIncrement j ++
<operator>.lessThan j < C
<operator>.postIncrement j ++
<operator>.lessThan j < C + 1
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment a [ j ] [ 1 ] = 0
<operator>.assignment a [ j ] [ 2 ] = 0
<operator>.multiplication sumA * ( N / C ) * 2
<operator>.assignment j = 0
<operator>.assignmentPlus sumAll += a [ j ] [ 0 ] * 2
<operator>.assignmentPlus a [ j ] [ 1 ] += 1
printf printf ( "%d\n" , sumAll )
<operator>.modulo t % ( sumA * 2 )
<operator>.assignment j = 0
<operator>.assignmentMinus tmpT -= a [ j ] [ 0 ] * 2
<operator>.division - tmpT / 2
<operator>.assignmentPlus a [ j ] [ 1 ] += 1
<operator>.assignment j = 0
<operator>.assignmentPlus a [ j ] [ 1 ] += ( N / C ) - ( t / ( sumA * 2 ) ) - 1
<operator>.addition C + 1
<operator>.sizeOf sizeof ( a [ 0 ] )
<operator>.assignment j = 0
<operator>.lessThan j < C
<operator>.multiplication sumA * ( N / C )
<operator>.modulo N % C
<operator>.multiplication sumA * 2
<operator>.minus - tmpT
<operator>.addition C + 1
<operator>.greaterThan tmpL > a [ j ] [ 1 ]
scanf scanf ( "%d" , & a [ j ] [ 0 ] )
<operator>.assignmentPlus sumA += a [ j ] [ 0 ]
<operator>.division N / C
<operator>.multiplication a [ j ] [ 0 ] * 2
<operator>.multiplication a [ j ] [ 0 ] * 2
<operator>.subtraction j - 1
<operator>.subtraction ( N / C ) - ( t / ( sumA * 2 ) ) - 1
<operator>.assignmentMinus sumAll -= a [ j ] [ 0 ] * a [ j ] [ 1 ]
<operator>.assignmentMinus tmpL -= a [ j ] [ 1 ]
<operator>.assignment a [ j ] [ 0 ] = 0
<operator>.subtraction ( N / C ) - ( t / ( sumA * 2 ) )
<operator>.assignmentMinus sumAll -= a [ j ] [ 0 ] * tmpL
<operator>.assignment tmpL = 0
<operator>.division N / C
<operator>.division t / ( sumA * 2 )
<operator>.multiplication a [ j ] [ 0 ] * a [ j ] [ 1 ]
<operator>.multiplication sumA * 2
<operator>.multiplication a [ j ] [ 0 ] * tmpL
<operator>.addressOf & L
<operator>.addressOf & t
<operator>.addressOf & N
<operator>.addressOf & C
<operator>.indirectIndexAccess a [ j - 1 ] [ 2 ]
<operator>.indirectIndexAccess a [ C ] [ 0 ]
<operator>.indirectIndexAccess a [ C ] [ 1 ]
<operator>.indirectIndexAccess a [ C ] [ 2 ]
<operator>.indirectIndexAccess a [ j - 1 ]
<operator>.indirectIndexAccess a [ C ]
<operator>.indirectIndexAccess a [ C ]
<operator>.indirectIndexAccess a [ C ]
<operator>.indirectIndexAccess a [ 0 ]
<operator>.indirectIndexAccess a [ j ] [ 1 ]
<operator>.indirectIndexAccess a [ j ] [ 2 ]
<operator>.indirectIndexAccess a [ j ] [ 1 ]
<operator>.indirectIndexAccess a [ j ] [ 1 ]
<operator>.indirectIndexAccess a [ j ] [ 1 ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ] [ 0 ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ] [ 0 ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ] [ 1 ]
<operator>.addressOf & a [ j ] [ 0 ]
<operator>.indirectIndexAccess a [ j ] [ 0 ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ] [ 1 ]
<operator>.indirectIndexAccess a [ j ] [ 0 ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ] [ 0 ]
<operator>.indirectIndexAccess a [ j ] [ 0 ]
<operator>.indirectIndexAccess a [ j ] [ 1 ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ]
<operator>.indirectIndexAccess a [ j ] [ 0 ]
<operator>.indirectIndexAccess a [ j ]
>>>PDG&123 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->72 0->73 0->74 0->75 0->77 0->78 2->1 2->1 3->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->11 6->12 6->13 6->23 6->25 6->27 6->36 6->39 6->40 6->55 6->56 6->63 6->79 6->80 6->81 6->82 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->1 10->1 10->21 11->1 11->7 12->1 12->55 12->62 13->1 13->1 13->27 13->41 14->1 14->1 14->28 15->1 15->1 16->1 16->1 16->17 17->1 17->1 17->1 18->1 18->1 19->1 19->1 20->1 20->1 20->1 21->1 21->1 21->1 21->60 22->1 22->1 23->1 23->23 23->24 23->37 23->38 23->54 23->54 23->92 23->93 23->97 23->98 24->1 24->23 25->1 25->1 25->1 25->25 25->26 25->26 25->41 25->42 25->56 25->64 25->94 25->99 25->100 25->107 26->1 26->25 27->1 27->1 27->14 27->15 27->16 27->17 27->18 27->19 27->20 27->21 27->22 27->22 27->28 27->30 27->32 27->34 27->43 27->43 27->44 27->44 27->45 27->47 27->49 27->51 27->52 27->53 27->57 27->58 27->59 27->66 27->68 27->72 27->83 27->84 27->85 27->86 27->87 27->88 27->89 27->90 27->91 28->1 28->28 28->29 28->46 28->46 28->58 28->65 28->101 28->108 29->1 29->66 30->30 30->31 30->31 30->32 30->48 30->95 30->102 31->1 31->30 32->1 32->20 32->32 32->33 32->33 32->34 32->50 32->51 32->54 32->59 32->63 32->67 32->71 32->74 32->74 32->75 32->77 32->96 32->103 33->1 33->32 34->1 34->1 34->1 34->34 34->35 34->35 34->59 34->60 34->104 34->109 35->1 35->34 36->23 37->1 37->1 37->42 37->48 37->50 37->60 38->1 38->1 39->1 39->13 39->13 40->1 40->25 41->1 41->1 41->27 42->1 42->1 42->48 42->50 42->60 43->1 43->1 44->1 44->1 44->14 44->14 44->27 44->75 45->29 45->66 46->1 46->1 46->28 47->1 47->16 47->16 48->1 48->1 48->42 48->50 48->60 49->32 50->1 50->1 50->1 50->42 50->48 50->60 52->1 53->1 53->34 54->1 54->24 54->61 54->62 54->63 54->70 54->105 54->106 54->111 54->112 54->113 54->117 54->118 55->1 55->1 55->39 55->39 55->57 56->1 56->1 56->25 56->25 56->30 56->54 56->63 56->63 56->74 57->1 57->44 57->44 57->77 58->1 58->47 59->1 60->1 60->1 60->42 60->48 60->50 60->68 60->69 60->69 60->72 60->73 60->76 60->76 60->78 60->78 60->110 60->114 60->115 60->116 60->119 60->120 60->121 60->122 61->1 61->62 61->64 61->65 61->76 61->78 62->1 62->1 62->55 63->55 63->55 63->56 63->56 64->1 64->41 64->41 64->61 64->62 64->65 64->76 64->78 65->1 65->46 65->46 65->61 65->62 65->64 65->76 65->78 66->30 67->1 67->50 67->50 68->1 68->1 68->22 68->72 69->1 69->1 69->1 69->60 70->1 70->1 70->61 70->62 70->64 70->65 70->76 70->78 71->1 71->1 71->67 71->67 72->1 72->1 72->22 72->68 73->1 73->1 73->60 74->1 74->32 74->63 74->71 74->71 75->1 75->1 75->27 75->71 75->71 76->1 76->42 76->48 76->50 76->60 76->61 76->62 76->64 76->65 76->68 76->68 76->69 76->78 77->1 77->75 77->75 78->1 78->61 78->62 78->64 78->65 78->72 78->72 78->76
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { freopen ( "\x31\x43\x2d\x42\x2e\x69\x6e\x0" , "r" , stdin ) ; freopen ( "1C-B.out" , "w" , stdout ) ; int T , L , t , N , C ; int a [ 1100 ] [ 3 ] ; int bet , sumA , sumAll , tmpT , useBet , tmpL ; int i , j , k ; scanf ( "%d" , & T ) ; for ( i = 1 ; i <= T ; i ++ ) { scanf ( "%d %d %d %d" , & L , & t , & N , & C ) ; printf ( "Case #%d: " , i ) ; sumA = 0 ; for ( j = 0 ; j < 1100 ; j ++ ) { if ( j < C ) { scanf ( "%d" , & a [ j ] [ 0 ] ) ; sumA += a [ j ] [ 0 ] ; } else { a [ j ] [ 0 ] = 0 ; } a [ j ] [ 1 ] = 0 ; a [ j ] [ 2 ] = 0 ; } sumAll = sumA * ( N / C ) * 2 ; for ( j = 0 ; j < ( N % C ) ; j ++ ) { sumAll += a [ j ] [ 0 ] * 2 ; a [ j ] [ 1 ] += 1 ; } if ( t > sumAll ) { printf ( "%d\n" , sumAll ) ; continue ; } tmpT = t % ( sumA * 2 ) ; for ( j = 0 ; tmpT > 0 ; j ++ ) { tmpT -= a [ j ] [ 0 ] * 2 ; } a [ j - 1 ] [ 2 ] = 1 ; bet = - tmpT / 2 ; a [ C ] [ 0 ] = bet ; a [ C ] [ 1 ] = 1 ; a [ C ] [ 2 ] = 2 ; for ( ; j < C ; j ++ ) { a [ j ] [ 1 ] += 1 ; } for ( j = 0 ; j < C ; j ++ ) { a [ j ] [ 1 ] += ( N / C ) - ( t / ( sumA * 2 ) ) - 1 ; } qsort ( a , C + 1 , sizeof ( a [ 0 ] ) , compare ) ; tmpL = L ; for ( j = 0 ; j < C + 1 ; j ++ ) { if ( tmpL > a [ j ] [ 1 ] ) { sumAll -= a [ j ] [ 0 ] * a [ j ] [ 1 ] ; tmpL -= a [ j ] [ 1 ] ; } else { sumAll -= a [ j ] [ 0 ] * tmpL ; tmpL = 0 ; } } printf ( "%d\n" , sumAll ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment inp = fopen ( "\x69\x6e\x70\x2e\x74\x78\x74\x0" , "r" )
<operator>.assignment out = fopen ( "out.txt" , "w" )
fscanf fscanf ( inp , "%d" , & T )
<operator>.assignment r = T
fclose fclose ( inp )
fclose fclose ( out )
IDENTIFIER T while (T)
fopen fopen ( "\x69\x6e\x70\x2e\x74\x78\x74\x0" , "r" )
fopen fopen ( "out.txt" , "w" )
fscanf fscanf ( inp , "%d" , & N )
fscanf fscanf ( inp , "%c" , & w )
fprintf fprintf ( out , "Case #" )
fprintf fprintf ( out , "%d" , r - T + 1 )
fprintf fprintf ( out , ": \n" )
<operator>.postDecrement T --
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan i < N
<operator>.postIncrement i ++
<operator>.lessThan k < N
<operator>.postIncrement k ++
<operator>.assignment i = 0
fscanf fscanf ( inp , "%c" , & w )
<operator>.assignment i = 0
<operator>.assignment wins = 0
<operator>.assignment dots = 0
<operator>.assignment WParr [ i ] = ( ( long double ) wins / ( N - dots ) )
<operator>.assignment winsarr [ i ] = wins
<operator>.assignment dotsarr [ i ] = dots
<operator>.assignment i = 0
<operator>.assignment OWPsum = 0
<operator>.assignment temp = 0
<operator>.assignment OWParr [ i ] = OWPsum / ( N - temp )
<operator>.assignment i = 0
<operator>.assignment OOWPsum = 0
<operator>.assignment OOWParr [ i ] = ( OOWPsum / ( N - dotsarr [ i ] ) )
<operator>.addition r - T + 1
<operator>.assignment k = 0
<operator>.assignment RPIarr [ k ] = ( 1.0 / 4.0 ) * WParr [ k ] + ( 1.0 / 2.0 ) * OWParr [ k ] + ( 1.0 / 4.0 ) * OOWParr [ k ]
fprintf fprintf ( out , "%Lf\n" , RPIarr [ k ] )
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.lessThan j < N
<operator>.postIncrement j ++
<operator>.subtraction r - T
<operator>.assignment j = 0
fscanf fscanf ( inp , "%c" , & table [ i ] [ j ] )
<operator>.assignment j = 0
<operator>.division ( long double ) wins / ( N - dots )
<operator>.assignment j = 0
<operator>.division OWPsum / ( N - temp )
<operator>.assignment j = 0
<operator>.division OOWPsum / ( N - dotsarr [ i ] )
<operator>.addition ( 1.0 / 4.0 ) * WParr [ k ] + ( 1.0 / 2.0 ) * OWParr [ k ] + ( 1.0 / 4.0 ) * OOWParr [ k ]
<operator>.equals table [ i ] [ j ] == '.'
<operator>.cast ( long double ) wins
<operator>.subtraction N - dots
<operator>.equals table [ j ] [ i ] == '1'
<operator>.equals table [ j ] [ i ] == '0'
<operator>.equals table [ j ] [ i ] == '.'
<operator>.subtraction N - temp
<operator>.logicalOr j == i || table [ j ] [ i ] == '.'
<operator>.subtraction N - dotsarr [ i ]
<operator>.addition ( 1.0 / 4.0 ) * WParr [ k ] + ( 1.0 / 2.0 ) * OWParr [ k ]
<operator>.multiplication ( 1.0 / 4.0 ) * OOWParr [ k ]
<operator>.postIncrement dots ++
<operator>.assignmentPlus OWPsum += ( long double ) ( winsarr [ j ] - 1 ) / ( N - 1 - dotsarr [ j ] )
<operator>.assignmentPlus OWPsum += ( long double ) ( winsarr [ j ] ) / ( N - 1 - dotsarr [ j ] )
<operator>.postIncrement temp ++
<operator>.multiplication ( 1.0 / 4.0 ) * WParr [ k ]
<operator>.multiplication ( 1.0 / 2.0 ) * OWParr [ k ]
<operator>.division 1.0 / 4.0
<operator>.equals j == i
<operator>.equals table [ j ] [ i ] == '.'
<operator>.assignmentPlus OOWPsum += OWParr [ j ]
<operator>.division 1.0 / 4.0
<operator>.division 1.0 / 2.0
<operator>.equals table [ i ] [ j ] == '1'
<operator>.division ( long double ) ( winsarr [ j ] - 1 ) / ( N - 1 - dotsarr [ j ] )
<operator>.division ( long double ) ( winsarr [ j ] ) / ( N - 1 - dotsarr [ j ] )
<operator>.postIncrement wins ++
<operator>.cast ( long double ) ( winsarr [ j ] - 1 )
<operator>.subtraction N - 1 - dotsarr [ j ]
<operator>.cast ( long double ) ( winsarr [ j ] )
<operator>.subtraction N - 1 - dotsarr [ j ]
<operator>.subtraction winsarr [ j ] - 1
<operator>.subtraction N - 1
<operator>.subtraction N - 1
<operator>.addressOf & w
<operator>.indirectIndexAccess WParr [ i ]
<operator>.indirectIndexAccess winsarr [ i ]
<operator>.indirectIndexAccess dotsarr [ i ]
<operator>.indirectIndexAccess OWParr [ i ]
<operator>.indirectIndexAccess OOWParr [ i ]
<operator>.indirectIndexAccess RPIarr [ k ]
<operator>.indirectIndexAccess RPIarr [ k ]
<operator>.addressOf & table [ i ] [ j ]
UNKNOWN long double long double
<operator>.indirectIndexAccess dotsarr [ i ]
<operator>.indirectIndexAccess OOWParr [ k ]
<operator>.indirectIndexAccess table [ i ] [ j ]
<operator>.indirectIndexAccess table [ i ] [ j ]
<operator>.indirectIndexAccess table [ j ] [ i ]
<operator>.indirectIndexAccess table [ j ] [ i ]
<operator>.indirectIndexAccess table [ j ] [ i ]
<operator>.indirectIndexAccess WParr [ k ]
<operator>.indirectIndexAccess OWParr [ k ]
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess table [ j ]
<operator>.indirectIndexAccess table [ j ]
<operator>.indirectIndexAccess table [ j ]
<operator>.indirectIndexAccess table [ j ] [ i ]
<operator>.indirectIndexAccess table [ j ]
<operator>.indirectIndexAccess OWParr [ j ]
<operator>.indirectIndexAccess table [ i ] [ j ]
UNKNOWN long double long double
<operator>.indirectIndexAccess dotsarr [ j ]
UNKNOWN long double long double
<operator>.indirectIndexAccess winsarr [ j ]
<operator>.indirectIndexAccess dotsarr [ j ]
<operator>.indirectIndexAccess table [ i ]
<operator>.indirectIndexAccess winsarr [ j ]
>>>PDG&133 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->42 0->43 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->72 0->75 0->76 0->77 0->78 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->90 0->95 0->96 0->97 2->1 2->1 2->4 3->1 3->1 3->7 3->13 4->1 4->1 4->5 4->6 4->11 4->16 4->54 5->1 5->1 5->1 5->54 6->1 6->1 7->1 7->1 9->2 9->2 10->3 10->3 11->1 11->1 11->12 11->17 11->19 11->21 11->23 11->25 11->46 11->48 11->50 11->52 11->66 11->70 11->72 11->96 11->97 12->1 12->1 12->6 12->11 12->28 12->28 12->56 13->1 13->14 14->1 14->1 14->15 15->1 15->7 15->13 15->45 16->1 16->1 16->54 17->17 17->18 17->18 17->19 17->28 17->46 17->46 17->55 17->98 18->1 18->17 19->19 19->20 19->20 19->21 19->30 19->31 19->32 19->33 19->34 19->48 19->48 19->57 19->58 19->65 19->66 19->99 19->100 19->101 19->107 20->1 20->19 21->21 21->22 21->22 21->23 21->36 21->37 21->38 21->50 21->50 21->59 21->60 21->70 21->102 22->1 22->21 23->1 23->1 23->23 23->24 23->24 23->25 23->40 23->41 23->52 23->52 23->61 23->62 23->72 23->82 23->103 23->108 24->1 24->23 25->1 25->1 25->1 25->11 25->17 25->25 25->26 25->26 25->44 25->45 25->63 25->73 25->74 25->79 25->80 25->81 25->85 25->86 25->104 25->105 25->109 25->115 25->116 26->1 26->25 27->17 28->1 28->1 28->6 28->11 28->12 28->56 29->19 30->1 30->33 30->58 30->65 30->90 31->1 31->66 31->75 32->1 32->1 32->1 33->1 33->1 33->1 34->1 34->1 34->1 34->72 35->21 36->1 36->60 36->76 36->77 37->1 37->70 37->78 38->1 38->1 38->1 39->1 39->23 40->1 40->62 40->84 41->1 41->1 41->1 42->1 43->1 43->25 44->1 44->1 44->45 45->1 45->1 45->7 45->13 46->1 46->1 46->17 46->46 46->47 46->47 46->56 46->106 46->110 46->117 47->1 47->46 48->1 48->1 48->48 48->49 48->49 48->64 48->66 48->111 48->118 49->1 49->48 50->1 50->1 50->50 50->51 50->51 50->67 50->68 50->69 50->70 50->96 50->97 50->112 50->113 50->114 50->119 50->120 50->121 51->1 51->50 52->1 52->1 52->52 52->53 52->71 52->72 52->82 52->82 53->1 53->52 54->1 54->14 54->14 54->16 54->42 54->42 55->1 55->46 56->1 56->1 56->28 56->64 56->87 57->1 57->48 58->1 58->1 58->32 58->32 59->1 59->50 60->1 60->1 60->38 60->38 61->1 61->52 62->1 62->1 62->41 62->41 63->1 63->1 64->1 64->1 64->56 64->75 64->87 64->87 64->125 64->131 66->19 66->34 66->58 66->58 67->1 67->68 67->76 67->88 67->91 67->92 67->95 67->96 67->126 67->127 67->132 68->1 68->69 68->77 68->89 68->93 68->94 68->97 68->128 68->129 68->130 69->1 69->1 69->67 69->71 69->78 69->83 70->1 70->21 70->60 70->60 71->1 71->1 71->1 71->84 71->124 72->1 72->23 72->62 72->62 73->1 73->1 74->1 74->1 74->44 74->44 74->63 74->63 75->1 75->66 76->1 76->1 76->60 76->77 77->1 77->1 77->60 77->76 78->1 78->70 79->1 79->44 79->44 79->63 79->63 79->73 79->73 80->1 80->1 80->44 80->44 80->63 80->63 80->73 80->73 81->74 81->74 82->24 82->53 82->71 82->71 82->83 82->122 82->123 83->1 83->67 83->71 83->71 84->1 84->1 84->62 85->79 85->79 86->80 86->80 87->1 87->1 87->56 87->64 87->90 88->1 88->1 88->76 88->76 89->1 89->1 89->77 89->77 90->1 90->33 90->58 90->65 91->1 92->1 92->1 92->88 92->88 92->94 93->1 94->1 94->1 94->89 94->89 94->92 95->1 95->88 95->88 95->89 95->91 95->91 95->93 96->50 96->92 96->92 96->97 97->50 97->94 97->94
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { FILE * inp ; FILE * out ; inp = fopen ( "\x69\x6e\x70\x2e\x74\x78\x74\x0" , "r" ) ; out = fopen ( "out.txt" , "w" ) ; int T , N , r , i , j , k ; char table [ 10 ] [ 10 ] ; long double WParr [ 10 ] ; long double OWParr [ 10 ] ; long double OOWParr [ 10 ] ; long double RPIarr [ 10 ] ; int winsarr [ 10 ] ; int dotsarr [ 10 ] ; int wins , dots ; char w ; fscanf ( inp , "%d" , & T ) ; r = T ; while ( T ) { fscanf ( inp , "%d" , & N ) ; fscanf ( inp , "%c" , & w ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { fscanf ( inp , "%c" , & table [ i ] [ j ] ) ; } fscanf ( inp , "%c" , & w ) ; } for ( i = 0 ; i < N ; i ++ ) { wins = 0 ; dots = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( table [ i ] [ j ] == '.' ) dots ++ ; else if ( table [ i ] [ j ] == '1' ) wins ++ ; } WParr [ i ] = ( ( long double ) wins / ( N - dots ) ) ; winsarr [ i ] = wins ; dotsarr [ i ] = dots ; } long double OWPsum ; int temp ; for ( i = 0 ; i < N ; i ++ ) { OWPsum = 0 ; temp = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( table [ j ] [ i ] == '1' ) OWPsum += ( long double ) ( winsarr [ j ] - 1 ) / ( N - 1 - dotsarr [ j ] ) ; if ( table [ j ] [ i ] == '0' ) OWPsum += ( long double ) ( winsarr [ j ] ) / ( N - 1 - dotsarr [ j ] ) ; if ( table [ j ] [ i ] == '.' ) temp ++ ; } OWParr [ i ] = OWPsum / ( N - temp ) ; } long double OOWPsum ; for ( i = 0 ; i < N ; i ++ ) { OOWPsum = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( j == i || table [ j ] [ i ] == '.' ) continue ; else OOWPsum += OWParr [ j ] ; } OOWParr [ i ] = ( OOWPsum / ( N - dotsarr [ i ] ) ) ; } fprintf ( out , "Case #" ) ; fprintf ( out , "%d" , r - T + 1 ) ; fprintf ( out , ": \n" ) ; for ( k = 0 ; k < N ; k ++ ) { RPIarr [ k ] = ( 1.0 / 4.0 ) * WParr [ k ] + ( 1.0 / 2.0 ) * OWParr [ k ] + ( 1.0 / 4.0 ) * OOWParr [ k ] ; fprintf ( out , "%Lf\n" , RPIarr [ k ] ) ; } T -- ; } fclose ( inp ) ; fclose ( out ) ; }
>>>Func
METHOD test_djb2
METHOD_RETURN void
PARAM void
assert assert ( djb2 ( "\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x0" ) == 13827776004929097857 )
assert assert ( djb2 ( "Hello World!" ) == 13594750393630990530 )
assert assert ( djb2 ( "Hello world" ) == 13827776004967047329 )
assert assert ( djb2 ( "Hello world!" ) == 13594750394883323106 )
printf printf ( "Tests passed\n" )
<operator>.equals djb2 ( "\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x0" ) == 13827776004929097857
<operator>.equals djb2 ( "Hello World!" ) == 13594750393630990530
<operator>.equals djb2 ( "Hello world" ) == 13827776004967047329
<operator>.equals djb2 ( "Hello world!" ) == 13594750394883323106
djb2 djb2 ( "\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x0" )
djb2 djb2 ( "Hello World!" )
djb2 djb2 ( "Hello world" )
djb2 djb2 ( "Hello world!" )
>>>PDG&16 0->2 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->1 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 8->1 8->3 8->3 9->1 9->4 9->4 10->1 10->5 10->5 11->1 11->6 11->6 12->8 13->9 14->10 15->11
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void test_djb2 ( void ) { assert ( djb2 ( "\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x0" ) == 13827776004929097857 ) ; assert ( djb2 ( "Hello World!" ) == 13594750393630990530 ) ; assert ( djb2 ( "Hello world" ) == 13827776004967047329 ) ; assert ( djb2 ( "Hello world!" ) == 13594750394883323106 ) ; printf ( "Tests passed\n" ) ; }
>>>Func
METHOD getindex
METHOD_RETURN int
PARAM char element
<operator>.assignment index = 1
RETURN return index ; return index ;
IDENTIFIER element switch(element)
IDENTIFIER index return index ;
LITERAL 'Q' <empty>
<operators>.assignmentShiftLeft index <<= 1
LITERAL 'W' <empty>
<operators>.assignmentShiftLeft index <<= 1
LITERAL 'E' <empty>
<operators>.assignmentShiftLeft index <<= 1
LITERAL 'R' <empty>
<operators>.assignmentShiftLeft index <<= 1
LITERAL 'A' <empty>
<operators>.assignmentShiftLeft index <<= 1
LITERAL 'S' <empty>
<operators>.assignmentShiftLeft index <<= 1
LITERAL 'D' <empty>
<operators>.assignmentShiftLeft index <<= 1
LITERAL 'F' <empty>
<operator>.assignment index = 0
>>>PDG&23 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 2->1 3->1 3->1 3->6 3->8 3->10 3->12 3->14 3->16 3->18 3->20 4->1 6->4 8->10 10->12 12->14 14->16 16->18 18->20 20->1 20->6 22->1 22->1 22->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int getindex ( char element ) { int index = 1 ; switch ( element ) { case 'Q' : index <<= 1 ; case 'W' : index <<= 1 ; case 'E' : index <<= 1 ; case 'R' : index <<= 1 ; case 'A' : index <<= 1 ; case 'S' : index <<= 1 ; case 'D' : index <<= 1 ; case 'F' : break ; default : index = 0 ; break ; } return index ; }
>>>Func
METHOD printLeaks
METHOD_RETURN void
<operator>.assignment * tmp = memoryInformation
<operator>.assignment * previous = NULL
<operator>.assignment sum = 0
<operator>.assignment nbBlocks = 0
printf printf ( "SUMMARY :\n%ld bytes lost in %d blocks\n" , sum , nbBlocks )
IDENTIFIER tmp if (tmp)
IDENTIFIER tmp while (tmp)
printf printf ( "\x4d\x65\x6d\x6f\x72\x79\x20\x4c\x65\x61\x6b\x73\x20\x64\x65\x74\x65\x63\x74\x65\x64\x2e\x5c\x6e\x0" )
<operator>.assignment previous = tmp
printf printf ( "\n%ld bytes lost\n" , tmp -> bytes )
printf printf ( "address : 0x%p in %s\t%s:%d\n" , tmp -> ptr , tmp -> functionName , tmp -> fileName , tmp -> line )
printf printf ( "\n====================================\n" )
<operator>.assignmentPlus sum += tmp -> bytes
<operator>.assignment tmp = tmp -> next
free free ( previous )
<operator>.postIncrement nbBlocks ++
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 2->1 2->1 2->1 2->10 3->1 3->1 3->1 4->1 4->6 4->14 5->1 5->6 5->17 6->1 6->1 6->1 9->1 10->1 10->16 11->1 11->14 12->1 12->1 12->1 12->1 12->1 13->1 14->1 14->1 14->6 15->1 15->1 15->1 15->10 16->1 17->1 17->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void printLeaks ( ) { mem_info * tmp = memoryInformation ; mem_info * previous = NULL ; size_t sum = 0 ; int nbBlocks = 0 ; if ( tmp ) { printf ( "\x4d\x65\x6d\x6f\x72\x79\x20\x4c\x65\x61\x6b\x73\x20\x64\x65\x74\x65\x63\x74\x65\x64\x2e\x5c\x6e\x0" ) ; } while ( tmp ) { previous = tmp ; printf ( "\n%ld bytes lost\n" , tmp -> bytes ) ; printf ( "address : 0x%p in %s\t%s:%d\n" , tmp -> ptr , tmp -> functionName , tmp -> fileName , tmp -> line ) ; printf ( "\n====================================\n" ) ; sum += tmp -> bytes ; tmp = tmp -> next ; free ( previous ) ; nbBlocks ++ ; } printf ( "SUMMARY :\n%ld bytes lost in %d blocks\n" , sum , nbBlocks ) ; }
>>>Func
>>>PDG&0
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) _WIN32 ( <missing ')'> memset ( ( b ) <missing ')'> , '\0' , ( len ) ) , <missing '{'> ( void ) 0 ) lse ndif void func ( int sockfd ) <missing ';'> { char buff [ MAX ] ; int n ; for ( ; ; ) { bzero ( buff , sizeof ( buff ) ) ; printf ( "\x45\x6e\x74\x65\x72\x20\x74\x68\x65\x20\x73\x74\x72\x69\x6e\x67\x20\x3a\x20\x0" ) ; n = 0 ; while ( ( buff [ n ++ ] = getchar ( ) ) != '\n' ) { ; } write ( sockfd , buff , sizeof ( buff ) ) ; bzero ( buff , sizeof ( buff ) ) ; read ( sockfd , buff , sizeof ( buff ) ) ; printf ( "From Server : %s" , buff ) ; if ( ( strncmp ( buff , "exit" , 4 ) ) == 0 ) { printf ( "Client Exit...\n" ) ; break ; } } } def _WIN32 void cleanup ( ) <missing ';'> { WSACleanup ( ) ; } ndif int main ( ) <missing ';'> { def _WIN32 WSADATA wsData ; if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsData ) != 0 ) { perror ( "WSA Startup error: \n" ) ; return 0 ; } atexit ( cleanup ) ; ndif int sockfd , connfd ; struct sockaddr_in servaddr , cli ; sockfd = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( sockfd == - 1 ) { printf ( "socket creation failed...\n" ) ; exit ( 0 ) ; } else { printf ( "Socket successfully created..\n" ) ; } bzero ( & servaddr , sizeof ( servaddr ) ) ; servaddr . sin_family = AF_INET ; servaddr . sin_addr . s_addr = inet_addr ( "127.0.0.1" ) ; servaddr . sin_port = htons ( PORT ) ; if ( connect ( sockfd , ( SA * ) & servaddr , sizeof ( servaddr ) ) != 0 ) { printf ( "connection with the server failed...\n" ) ; exit ( 0 ) ; } else { printf ( "connected to the server..\n" ) ; } func ( sockfd ) ; close ( sockfd ) ; return 0 ; } <missing '}'>
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < t
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.assignment flag = 0
scanf scanf ( "%lld %d %d" , & n , & d , & g )
printf printf ( "Case #%d: " , i + 1 )
<operator>.logicalAnd g == d && g == 100
<operator>.equals flag == 0
<operator>.equals flag == 1
<operator>.addition i + 1
<operator>.assignment flag = 1
printf printf ( "Broken\n" )
printf printf ( "Possible\n" )
<operator>.equals g == d
<operator>.equals g == 100
<operator>.logicalAnd g != d && g == 100
<operator>.assignment flag = 0
<operator>.notEquals g != d
<operator>.equals g == 100
<operator>.logicalAnd g == 0 && d != 0
<operator>.assignment flag = 0
<operator>.equals g == 0
<operator>.notEquals d != 0
<operator>.logicalAnd g == 0 && d == 0
<operator>.assignment flag = 1
<operator>.equals g == 0
<operator>.equals d == 0
<operator>.lessEqualsThan j <= n
<operator>.postIncrement j ++
<operator>.assignment j = 1
<operator>.equals ( j * d ) % 100 == 0
<operator>.assignment flag = 1
<operator>.modulo ( j * d ) % 100
<operator>.multiplication j * d
<operator>.addressOf & n
<operator>.addressOf & d
<operator>.addressOf & g
>>>PDG&42 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->21 0->22 0->23 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->10 4->11 4->12 4->13 4->14 4->14 4->18 4->39 4->40 4->41 5->1 5->4 6->3 7->1 7->4 8->1 8->12 9->1 9->1 9->1 9->32 10->1 10->1 11->1 11->1 11->1 11->15 11->20 11->20 11->22 12->1 12->13 12->16 13->1 13->1 13->17 15->1 15->12 16->1 17->1 18->1 18->1 18->11 18->11 18->19 18->19 18->22 18->22 19->1 19->11 19->11 19->18 19->22 20->1 20->1 20->1 20->11 20->21 20->24 20->26 21->1 21->12 22->1 22->1 22->18 22->18 22->20 22->20 22->23 22->23 22->26 22->27 22->31 22->38 23->1 23->18 23->20 23->20 23->26 24->1 24->1 24->1 24->25 24->28 24->30 25->1 25->12 26->1 26->18 26->24 26->24 26->27 26->30 27->1 27->18 27->24 27->24 27->31 27->38 28->1 28->1 28->1 28->29 28->32 28->34 29->1 29->12 30->1 30->18 30->28 30->28 30->31 31->1 31->18 31->28 31->28 31->38 32->1 32->1 32->1 32->9 32->35 32->37 32->38 32->38 33->1 33->32 34->1 34->32 35->1 35->1 35->32 35->33 35->36 36->1 36->12 37->1 37->35 37->35 38->1 38->1 38->18 38->33 38->37 38->37
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  def SMALL ndif int main ( ) { int t , d , g ; long long int n , j ; int i , flag ; scanf ( "\x25\x64\x0" , & t ) ; for ( i = 0 ; i < t ; i ++ ) { flag = 0 ; scanf ( "%lld %d %d" , & n , & d , & g ) ; printf ( "Case #%d: " , i + 1 ) ; if ( g == d && g == 100 ) flag = 1 ; else if ( g != d && g == 100 ) flag = 0 ; else if ( g == 0 && d != 0 ) flag = 0 ; else if ( g == 0 && d == 0 ) flag = 1 ; else { for ( j = 1 ; j <= n ; j ++ ) if ( ( j * d ) % 100 == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) printf ( "Broken\n" ) ; if ( flag == 1 ) printf ( "Possible\n" ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment st . top = - 1
test test ( )
printf printf ( "\x45\x6e\x74\x65\x72\x20\x69\x6e\x66\x69\x78\x3a\x20\x0" )
scanf scanf ( "%s" , inf )
printf printf ( "Postfix: %s"   convert ( inf ) )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.minus - 1
convert convert ( inf )
>>>PDG&11 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 2->1 3->1 4->1 5->10 6->1 6->1 7->1 8->7 9->2 10->1 10->6
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { st . top = - 1 ; test ( ) ; char inf [ 25 ] ; printf ( "\x45\x6e\x74\x65\x72\x20\x69\x6e\x66\x69\x78\x3a\x20\x0" ) ; scanf ( "%s" , inf ) ; printf ( "Postfix: %s" , convert ( inf ) ) ; return 0 ; }
>>>Func
METHOD is_same_street
METHOD_RETURN int
PARAM point p0
PARAM point p1
RETURN return TRUE ; return TRUE ;
<operator>.notEquals p0 . x / 2 != p1 . x / 2
<operator>.notEquals p0 . y / 2 != p1 . y / 2
IDENTIFIER TRUE return TRUE ;
RETURN return FALSE ; return FALSE ;
RETURN return FALSE ; return FALSE ;
<operator>.division p0 . x / 2
<operator>.division p1 . x / 2
IDENTIFIER FALSE return FALSE ;
<operator>.division p0 . y / 2
<operator>.division p1 . y / 2
IDENTIFIER FALSE return FALSE ;
<operator>.fieldAccess p0 . y
<operator>.fieldAccess p1 . y
FIELD_IDENTIFIER y y
FIELD_IDENTIFIER y y
>>>PDG&20 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->1 2->10 2->13 3->1 3->11 3->14 4->1 5->1 5->1 5->1 5->6 5->8 5->13 5->14 5->16 5->17 5->18 5->19 6->4 6->9 7->4 8->1 9->1 10->1 10->5 10->5 11->1 11->5 11->5 12->8 13->6 13->6 14->6 14->6 15->9
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int is_same_street ( point p0 , point p1 ) { if ( p0 . x / 2 != p1 . x / 2 ) { return FALSE ; } if ( p0 . y / 2 != p1 . y / 2 ) { return FALSE ; } return TRUE ; }
>>>Func
METHOD clear
METHOD_RETURN void
PARAM deck_t * deck
PARAM hand_t * hand
<operator>.assignment deck -> end = 0
<operator>.assignment deck -> start = 0
<operator>.assignment hand -> end = 0
<operator>.assignment hand -> start = 0
<operator>.lessThan i < 80
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment deck -> deck [ i ] . c = 0
<operator>.assignment deck -> deck [ i ] . s = 0
<operator>.assignment deck -> deck [ i ] . t = 0
<operator>.assignment hand -> hand [ i ] . c = 0
<operator>.assignment hand -> hand [ i ] . s = 0
<operator>.assignment hand -> hand [ i ] . t = 0
<operator>.fieldAccess deck -> deck [ i ] . c
<operator>.fieldAccess deck -> deck [ i ] . s
<operator>.fieldAccess deck -> deck [ i ] . t
<operator>.fieldAccess hand -> hand [ i ] . c
<operator>.fieldAccess hand -> hand [ i ] . s
<operator>.fieldAccess hand -> hand [ i ] . t
<operator>.indirectIndexAccess deck -> deck [ i ]
FIELD_IDENTIFIER c c
<operator>.indirectIndexAccess deck -> deck [ i ]
FIELD_IDENTIFIER s s
<operator>.indirectIndexAccess deck -> deck [ i ]
FIELD_IDENTIFIER t t
<operator>.indirectIndexAccess hand -> hand [ i ]
FIELD_IDENTIFIER c c
<operator>.indirectIndexAccess hand -> hand [ i ]
FIELD_IDENTIFIER s s
<operator>.indirectIndexAccess hand -> hand [ i ]
FIELD_IDENTIFIER t t
<operator>.indirectFieldAccess deck -> deck
<operator>.indirectFieldAccess deck -> deck
<operator>.indirectFieldAccess deck -> deck
<operator>.indirectFieldAccess hand -> hand
<operator>.indirectFieldAccess hand -> hand
<operator>.indirectFieldAccess hand -> hand
FIELD_IDENTIFIER deck deck
FIELD_IDENTIFIER deck deck
FIELD_IDENTIFIER deck deck
FIELD_IDENTIFIER hand hand
FIELD_IDENTIFIER hand hand
FIELD_IDENTIFIER hand hand
>>>PDG&47 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 2->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 8->8 8->9 8->9 8->11 8->12 8->13 8->14 8->15 8->16 8->17 8->18 8->19 8->20 8->21 8->22 8->23 8->24 8->25 8->26 8->27 8->28 8->29 8->30 8->31 8->32 8->33 8->34 8->35 8->36 8->37 8->38 8->39 8->40 8->41 8->42 8->43 8->44 8->45 8->46 9->1 9->8 10->1 10->8 11->1 12->1 13->1 14->1 15->1 16->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void clear ( deck_t * deck , hand_t * hand ) { int i ; for ( i = 0 ; i < 80 ; i ++ ) { deck -> deck [ i ] . c = 0 ; deck -> deck [ i ] . s = 0 ; deck -> deck [ i ] . t = 0 ; hand -> hand [ i ] . c = 0 ; hand -> hand [ i ] . s = 0 ; hand -> hand [ i ] . t = 0 ; } deck -> end = 0 ; deck -> start = 0 ; hand -> end = 0 ; hand -> start = 0 ; }
>>>Func
METHOD strStr
METHOD_RETURN int
PARAM char * haystack
PARAM char * needle
<operator>.assignment i = 0
<operator>.assignment j = 0
<operator>.assignment len_needle = strlen ( needle )
<operator>.assignment len_haystack = strlen ( haystack )
fill_overlap fill_overlap ( needle , len_needle , overlap )
RETURN return - 1 ; return - 1 ;
<operator>.logicalNot ! len_needle
<operator>.lessThan i < len_haystack
<operator>.minus - 1
strlen strlen ( needle )
strlen strlen ( haystack )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
<operator>.equals needle [ j ] == haystack [ i ]
<operator>.equals j == len_needle
<operator>.postIncrement i ++
<operator>.postIncrement j ++
RETURN return ( i - j ) ; return ( i - j ) ;
<operator>.subtraction i - j
<operator>.logicalAnd i < len_haystack && needle [ j ] != haystack [ i ]
<operator>.lessThan i < len_haystack
<operator>.notEquals needle [ j ] != haystack [ i ]
<operator>.notEquals j != 0
<operator>.assignment j = overlap [ j - 1 ]
<operator>.assignment i = i + 1
<operator>.subtraction j - 1
<operator>.addition i + 1
<operator>.indirectIndexAccess needle [ j ]
<operator>.indirectIndexAccess haystack [ i ]
<operator>.indirectIndexAccess needle [ j ]
<operator>.indirectIndexAccess haystack [ i ]
<operator>.indirectIndexAccess overlap [ j - 1 ]
>>>PDG&36 0->2 0->3 0->4 0->5 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->22 0->24 0->26 0->28 0->29 0->30 2->14 3->13 4->1 4->1 4->11 5->1 5->1 5->18 5->20 6->1 6->1 6->10 7->1 7->1 7->1 7->11 8->17 8->18 8->25 8->27 9->1 10->1 10->1 10->8 10->8 10->11 10->15 11->9 11->12 11->17 11->18 11->19 11->22 11->24 11->24 11->31 11->32 12->9 13->1 13->6 13->8 14->1 14->7 14->17 14->25 15->1 16->15 17->19 17->20 17->25 17->25 18->11 18->20 18->21 18->22 18->22 18->23 18->24 18->26 19->22 19->24 20->18 21->1 22->21 23->26 24->11 24->11 24->23 24->23 24->25 24->28 24->30 24->33 24->34 25->17 25->17 25->23 25->23 26->18 26->20 26->27 26->28 26->29 26->29 26->30 26->35 27->18 27->20 28->11
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int strStr ( char * haystack , char * needle ) { int i = 0 ; int j = 0 ; int len_needle = strlen ( needle ) ; int len_haystack = strlen ( haystack ) ; if ( ! len_needle ) return 0 ; int overlap [ len_needle ] ; fill_overlap ( needle , len_needle , overlap ) ; while ( i < len_haystack ) { if ( needle [ j ] == haystack [ i ] ) { i ++ ; j ++ ; } if ( j == len_needle ) { return ( i - j ) ; } else if ( i < len_haystack && needle [ j ] != haystack [ i ] ) { if ( j != 0 ) j = overlap [ j - 1 ] ; else i = i + 1 ; } } return - 1 ; }
>>>Func
METHOD calc
METHOD_RETURN int
PARAM int p
PARAM int s
<operator>.assignment r = 1000000
RETURN return r ; return r ;
<operator>.equals p == Q
<operator>.greaterEqualsThan best [ p ] [ s ] >= 0
<operator>.notEquals s != query [ p ]
<operator>.lessThan i < S
<operator>.postIncrement i ++
IDENTIFIER r return r ;
RETURN return 0 ; return 0 ;
RETURN return best [ p ] [ s ] ; return best [ p ] [ s ] ;
<operator>.assignment r = calc ( p + 1 , s )
RETURN return r ; return r ;
<operator>.assignment i = 0
<operator>.assignment t = calc ( p + 1 , i ) + 1
LITERAL 0 return 0 ;
IDENTIFIER r return r ;
<operator>.equals i == s
<operator>.lessThan t < r
calc calc ( p + 1 , s )
<operator>.addition calc ( p + 1 , i ) + 1
<operator>.assignment r = t
<operator>.addition p + 1
calc calc ( p + 1 , i )
<operator>.addition p + 1
UNKNOWN int & r = best [ p ] [ s ] ; int & r = best [ p ] [ s ] ;
<operator>.indirectIndexAccess best [ p ] [ s ]
<operator>.indirectIndexAccess query [ p ]
<operator>.indirectIndexAccess best [ p ]
<operator>.indirectIndexAccess best [ p ] [ s ]
<operator>.indirectIndexAccess best [ p ]
>>>PDG&34 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->6 3->1 3->8 4->11 4->21 5->1 6->1 6->1 6->1 6->7 6->12 6->22 6->25 6->26 6->27 6->29 6->31 7->8 7->13 7->28 7->30 7->32 7->33 8->4 8->5 8->9 8->14 8->15 8->16 8->20 8->22 8->22 8->25 9->1 9->9 9->10 9->20 9->20 10->9 11->5 12->1 13->1 14->19 15->1 16->9 17->21 18->12 19->15 20->10 20->17 20->21 20->23 20->26 20->26 20->27 21->11 21->24 21->24 22->14 22->14 24->11 24->21 26->10 26->17 26->17 26->23 26->23
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int calc ( int p , int s ) { if ( p == Q ) return 0 ; if ( best [ p ] [ s ] >= 0 ) return best [ p ] [ s ] ; int & r = best [ p ] [ s ] ; if ( s != query [ p ] ) { r = calc ( p + 1 , s ) ; return r ; } r = 1000000 ; for ( int i = 0 ; i < S ; i ++ ) { if ( i == s ) continue ; int t = calc ( p + 1 , i ) + 1 ; if ( t < r ) r = t ; } return r ; }
>>>Func
METHOD get_link_name
METHOD_RETURN void
PARAM char const * filename
PARAM struct fileinfo * f
PARAM bool command_line_arg
<operator>.assignment f -> linkname = areadlink_with_size ( filename , f -> stat . st_size )
<operator>.equals f -> linkname == NULL
areadlink_with_size areadlink_with_size ( filename , f -> stat . st_size )
file_failure file_failure ( command_line_arg   _ ( "\x63\x61\x6e\x6e\x6f\x74\x20\x72\x65\x61\x64\x20\x73\x79\x6d\x62\x6f\x6c\x69\x63\x20\x6c\x69\x6e\x6b\x20\x25\x73\x0" ) , filename )
_ _ ( "\x63\x61\x6e\x6e\x6f\x74\x20\x72\x65\x61\x64\x20\x73\x79\x6d\x62\x6f\x6c\x69\x63\x20\x6c\x69\x6e\x6b\x20\x25\x73\x0" )
>>>PDG&10 0->2 0->3 0->4 0->6 0->7 0->8 0->9 2->7 3->1 4->8 5->1 5->1 5->6 6->1 6->1 6->1 6->8 6->9 7->1 7->5 7->5 7->8 8->1 8->1 8->1 8->1 9->8
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static void get_link_name ( char const * filename , struct fileinfo * f , bool command_line_arg ) { f -> linkname = areadlink_with_size ( filename , f -> stat . st_size ) ; if ( f -> linkname == NULL ) file_failure ( command_line_arg , _ ( "\x63\x61\x6e\x6e\x6f\x74\x20\x72\x65\x61\x64\x20\x73\x79\x6d\x62\x6f\x6c\x69\x63\x20\x6c\x69\x6e\x6b\x20\x25\x73\x0" ) , filename ) ; }
>>>Func
METHOD hcf
METHOD_RETURN int
PARAM int m
PARAM int n
RETURN return - 1 ; return - 1 ;
<operator>.lessThan m < n
LITERAL 1 while (1)
<operator>.minus - 1
<operator>.assignment temp = m
<operator>.assignment m = n
<operator>.assignment n = temp
<operator>.assignment reminder = m % n
<operator>.assignment n = reminder
<operator>.equals reminder == 0
<operator>.modulo m % n
RETURN return n ; return n ;
IDENTIFIER n return n ;
<operator>.assignment m = n
>>>PDG&18 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->16 0->17 2->5 3->5 4->1 5->1 5->8 5->8 5->9 5->9 5->10 5->14 5->14 7->4 8->1 8->10 9->1 9->14 10->1 10->1 10->14 11->1 11->1 11->13 12->1 12->14 13->1 13->1 13->4 13->7 13->11 13->12 13->12 13->13 13->14 13->15 13->17 14->1 14->1 14->11 14->11 14->16 14->17 15->1 16->15 17->1 17->14
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int hcf ( int m , int n ) { int temp , reminder ; if ( m < n ) { temp = m ; m = n ; n = temp ; } while ( 1 ) { reminder = m % n ; if ( reminder == 0 ) return n ; else m = n ; n = reminder ; } return - 1 ; }
>>>Func
METHOD printstr
METHOD_RETURN void
PARAM char * str
PARAM int el
<operator>.greaterThan el > 0
<operator>.lessThan i < el
<operator>.postIncrement i ++
printf printf ( "\x25\x63\x0" , str [ 0 ] )
<operator>.assignment i = 1
printf printf ( ", %c" , str [ i ] )
<operator>.indirectIndexAccess str [ 0 ]
<operator>.indirectIndexAccess str [ i ]
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 2->7 2->9 3->4 4->1 4->5 4->7 4->10 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->11 6->1 6->5 7->1 7->1 8->1 8->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void printstr ( char * str , int el ) { int i ; if ( el > 0 ) { printf ( "\x25\x63\x0" , str [ 0 ] ) ; } for ( i = 1 ; i < el ; i ++ ) { printf ( ", %c" , str [ i ] ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
printf printf ( "Case #%d: " , i + 1 )
solveCase solveCase ( )
<operator>.addition i + 1
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->8 4->9 4->10 4->10 5->1 5->4 6->3 7->1 7->4 8->1 8->1 9->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T , i ; scanf ( "\x25\x64\x0" , & T ) ; for ( i = 0 ; i < T ; i ++ ) { printf ( "Case #%d: " , i + 1 ) ; solveCase ( ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment sum = 0
printf printf ( "\x53\x75\x6d\x20\x69\x73\x3a\x20\x25\x64\x5c\x6e\x0" , sum )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < argv [ 1 ] [ 0 ]
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.equals argv [ 1 ] [ 0 ] == 127
<operator>.assignmentPlus sum += i
<operator>.assignmentMultiplication sum *= i
<operator>.indirectIndexAccess argv [ 1 ] [ 0 ]
<operator>.indirectIndexAccess argv [ 1 ]
<operator>.indirectIndexAccess argv [ 1 ] [ 0 ]
<operator>.indirectIndexAccess argv [ 1 ]
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->1 3->1 4->1 4->5 4->12 4->13 5->1 5->1 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->11 7->11 7->12 7->13 7->14 7->15 7->16 7->17 8->1 8->7 9->6 10->1 10->7 11->1 11->7 11->12 11->13 12->1 12->5 12->13 13->1 13->5 13->12
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * argv [ ] ) { int i ; int sum = 0 ; for ( i = 0 ; i < argv [ 1 ] [ 0 ] ; i ++ ) { if ( argv [ 1 ] [ 0 ] == 127 ) sum += i ; else sum *= i ; } printf ( "\x53\x75\x6d\x20\x69\x73\x3a\x20\x25\x64\x5c\x6e\x0" , sum ) ; return 0 ; }
>>>Func
METHOD sortArrayByParity
METHOD_RETURN int*
PARAM int * A
PARAM int ASize
PARAM int * returnSize
<operator>.assignment * retArr = malloc ( ASize * sizeof ( int ) )
<operator>.assignment oddIndex = ASize - 1
<operator>.assignment evenIndex = 0
<operator>.assignment * returnSize = ASize
RETURN return retArr ; return retArr ;
<operator>.lessThan i < ASize
<operator>.postIncrement i ++
IDENTIFIER retArr return retArr ;
malloc malloc ( ASize * sizeof ( int ) )
<operator>.subtraction ASize - 1
<operator>.assignment i = 0
<operator>.multiplication ASize * sizeof ( int )
<operator>.equals A [ i ] % 2 == 0
<operator>.sizeOf sizeof ( int )
<operator>.assignment retArr [ evenIndex ] = A [ i ]
<operator>.postIncrement evenIndex ++
<operator>.modulo A [ i ] % 2
<operator>.assignment retArr [ oddIndex ] = A [ i ]
<operator>.postDecrement oddIndex --
<operator>.indirectIndexAccess A [ i ]
<operator>.indirectIndexAccess retArr [ evenIndex ]
<operator>.indirectIndexAccess A [ i ]
<operator>.indirectIndexAccess retArr [ oddIndex ]
<operator>.indirectIndexAccess A [ i ]
>>>PDG&29 0->2 0->3 0->4 0->7 0->8 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->20 0->21 0->23 2->1 2->19 2->21 2->22 3->16 4->1 5->1 5->1 5->1 5->12 6->1 6->1 6->1 6->23 7->1 7->1 7->20 8->1 8->1 9->1 10->1 10->1 10->1 10->10 10->11 10->11 10->17 10->21 10->24 11->1 11->10 12->9 13->1 13->5 14->6 14->6 14->8 14->10 15->1 15->10 16->13 16->14 17->1 17->1 17->19 17->20 17->22 17->23 17->25 17->26 17->27 17->28 18->1 19->1 19->1 19->1 19->12 20->1 20->1 21->17 21->17 21->19 21->22 22->1 22->1 22->1 22->12 23->1 23->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int * sortArrayByParity ( int * A , int ASize , int * returnSize ) { int * retArr = malloc ( ASize * sizeof ( int ) ) ; int oddIndex = ASize - 1 ; int evenIndex = 0 ; * returnSize = ASize ; for ( int i = 0 ; i < ASize ; i ++ ) { if ( A [ i ] % 2 == 0 ) { retArr [ evenIndex ] = A [ i ] ; evenIndex ++ ; } else { retArr [ oddIndex ] = A [ i ] ; oddIndex -- ; } } return retArr ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
freopen freopen ( "\x69\x6e\x70\x75\x74\x2e\x74\x78\x74\x0" , "r" , stdin )
scanf scanf ( "%d" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= T
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 1
scanf scanf ( "%d " , & C )
<operator>.assignment anscnt = 0
scanf scanf ( "%d " , & D )
scanf scanf ( "%d " , & N )
printf printf ( "Case #%d: [" , t )
printf printf ( "]\n" )
<operator>.lessThan i < M
<operator>.postIncrement i ++
<operator>.postDecrement C --
<operator>.postDecrement D --
<operator>.postDecrement N --
<operator>.lessThan i < anscnt
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.lessThan j < M
<operator>.postIncrement j ++
<operator>.assignment c [ i ] [ j ] = d [ i ] [ j ] = 0
scanf scanf ( "%c%c%c " , & b1 , & b2 , & bc )
<operator>.assignment c [ b1 ] [ b2 ] = c [ b2 ] [ b1 ] = bc
scanf scanf ( "%c%c " , & b1 , & b2 )
<operator>.assignment d [ b1 ] [ b2 ] = d [ b2 ] [ b1 ] = 1
scanf scanf ( "%c" , & bc )
<operator>.assignment i = 0
<operator>.assignment j = 0
<operator>.logicalAnd anscnt > 0 && c [ bc ] [ ans [ anscnt - 1 ] ]
<operator>.equals i == 0
<operator>.assignment d [ i ] [ j ] = 0
<operator>.assignment c [ b2 ] [ b1 ] = bc
<operator>.assignment d [ b2 ] [ b1 ] = 1
<operator>.assignment ans [ anscnt - 1 ] = c [ bc ] [ ans [ anscnt - 1 ] ]
printf printf ( "%c" , ans [ i ] )
<operator>.greaterThan anscnt > 0
printf printf ( ", %c" , ans [ i ] )
<operator>.lessThan i < anscnt
<operator>.postIncrement i ++
<operator>.notEquals i != - 3
<operator>.subtraction anscnt - 1
<operator>.subtraction anscnt - 1
<operator>.assignment i = 0
<operator>.assignment ans [ anscnt ++ ] = bc
<operator>.subtraction anscnt - 1
<operator>.minus - 3
<operator>.assignment anscnt = 0
<operator>.assignment i = - 3
<operator>.postIncrement anscnt ++
<operator>.minus - 3
<operator>.addressOf & C
<operator>.addressOf & D
<operator>.addressOf & N
<operator>.indirectIndexAccess c [ i ] [ j ]
<operator>.addressOf & b1
<operator>.addressOf & b2
<operator>.addressOf & bc
<operator>.indirectIndexAccess c [ b1 ] [ b2 ]
<operator>.addressOf & b1
<operator>.addressOf & b2
<operator>.indirectIndexAccess d [ b1 ] [ b2 ]
<operator>.addressOf & bc
<operator>.indirectIndexAccess c [ i ]
<operator>.indirectIndexAccess d [ i ] [ j ]
<operator>.indirectIndexAccess c [ b1 ]
<operator>.indirectIndexAccess c [ b2 ] [ b1 ]
<operator>.indirectIndexAccess d [ b1 ]
<operator>.indirectIndexAccess d [ b2 ] [ b1 ]
<operator>.indirectIndexAccess c [ bc ] [ ans [ anscnt - 1 ] ]
<operator>.indirectIndexAccess d [ i ]
<operator>.indirectIndexAccess c [ b2 ]
<operator>.indirectIndexAccess d [ b2 ]
<operator>.indirectIndexAccess c [ bc ]
<operator>.indirectIndexAccess ans [ anscnt - 1 ]
<operator>.indirectIndexAccess ans [ anscnt - 1 ]
<operator>.indirectIndexAccess c [ bc ] [ ans [ anscnt - 1 ] ]
<operator>.indirectIndexAccess ans [ i ]
<operator>.indirectIndexAccess c [ bc ]
<operator>.indirectIndexAccess ans [ anscnt - 1 ]
<operator>.indirectIndexAccess ans [ i ]
<operator>.indirectIndexAccess d [ ans [ i ] ] [ bc ]
<operator>.indirectIndexAccess ans [ anscnt ++ ]
<operator>.indirectIndexAccess d [ ans [ i ] ]
<operator>.indirectIndexAccess ans [ i ]
>>>PDG&90 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->54 0->55 2->1 3->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->12 6->13 6->14 6->14 6->15 6->16 6->18 6->19 6->20 6->21 6->23 6->32 6->56 6->57 6->58 7->1 7->6 8->5 9->1 9->6 10->1 10->18 11->1 11->21 11->41 12->1 12->19 13->1 13->20 14->1 14->7 15->1 16->1 16->1 16->16 16->17 16->17 16->24 16->24 16->33 17->1 17->16 18->1 18->1 18->10 18->18 18->27 18->28 18->37 18->60 18->61 18->62 18->63 18->70 18->71 18->76 19->1 19->1 19->12 19->19 19->29 19->30 19->38 19->64 19->65 19->66 19->72 19->73 19->77 20->1 20->1 20->13 20->20 20->31 20->34 20->41 20->67 21->1 21->1 21->1 21->21 21->22 21->35 21->35 22->1 22->21 23->16 24->1 24->1 24->16 24->24 24->25 24->25 24->26 24->36 24->59 24->68 24->69 24->75 25->1 25->24 26->1 26->1 26->1 27->1 27->1 27->1 27->29 28->1 28->1 28->1 29->1 29->1 29->27 30->1 30->1 30->1 31->1 31->28 31->37 31->49 32->1 32->21 33->1 33->24 34->1 34->1 34->1 34->39 34->39 34->43 34->45 34->47 34->48 34->50 34->51 34->80 34->81 34->83 34->84 35->1 35->22 35->40 35->42 35->82 35->85 36->1 36->26 37->1 37->1 37->28 38->1 38->30 39->1 39->1 39->1 40->1 40->1 40->42 41->34 41->34 41->43 41->46 41->46 41->47 41->74 41->78 41->79 42->1 42->1 42->40 43->21 43->41 43->44 43->45 43->54 43->86 43->88 43->89 44->1 44->43 45->1 45->1 45->49 45->54 45->87 46->43 46->47 47->50 48->43 49->1 49->1 49->1 50->21 50->41 51->45 52->1 52->21 52->41 52->54 53->1 53->45 54->21 54->41 55->53 86->43 86->44 86->52 86->53 86->55
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( void ) { freopen ( "\x69\x6e\x70\x75\x74\x2e\x74\x78\x74\x0" , "r" , stdin ) ; int i , j , t , T , C , D , N , anscnt ; char ans [ 111 ] , c [ M ] [ M ] , d [ M ] [ M ] , b1 , b2 , bc ; scanf ( "%d" , & T ) ; for ( t = 1 ; t <= T ; t ++ ) { scanf ( "%d " , & C ) ; anscnt = 0 ; for ( i = 0 ; i < M ; i ++ ) for ( j = 0 ; j < M ; j ++ ) c [ i ] [ j ] = d [ i ] [ j ] = 0 ; while ( C -- ) { scanf ( "%c%c%c " , & b1 , & b2 , & bc ) ; c [ b1 ] [ b2 ] = c [ b2 ] [ b1 ] = bc ; } scanf ( "%d " , & D ) ; while ( D -- ) { scanf ( "%c%c " , & b1 , & b2 ) ; d [ b1 ] [ b2 ] = d [ b2 ] [ b1 ] = 1 ; } scanf ( "%d " , & N ) ; while ( N -- ) { scanf ( "%c" , & bc ) ; if ( anscnt > 0 && c [ bc ] [ ans [ anscnt - 1 ] ] ) { ans [ anscnt - 1 ] = c [ bc ] [ ans [ anscnt - 1 ] ] ; } else { for ( i = 0 ; i < anscnt ; i ++ ) { if ( d [ ans [ i ] ] [ bc ] ) { anscnt = 0 ; i = - 3 ; break ; } } if ( i != - 3 ) { ans [ anscnt ++ ] = bc ; } } } printf ( "Case #%d: [" , t ) ; for ( i = 0 ; i < anscnt ; i ++ ) { if ( i == 0 ) printf ( "%c" , ans [ i ] ) ; else printf ( ", %c" , ans [ i ] ) ; } printf ( "]\n" ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.notEquals scanf ( "\x25\x64\x0" , & t ) != EOF
scanf scanf ( "\x25\x64\x0" , & t )
<operator>.lessThan i < t
<operator>.postIncrement i ++
<operator>.assignment i = 0
scanf scanf ( "%d" , & e )
printf printf ( "Case #%d:\n" , i + 1 )
<operator>.lessThan j < e
<operator>.postIncrement j ++
<operator>.lessThan j < e
<operator>.postIncrement j ++
<operator>.lessThan j < e
<operator>.postIncrement j ++
<operator>.lessThan j < e
<operator>.postIncrement j ++
<operator>.lessThan j < e
<operator>.postIncrement j ++
<operator>.addition i + 1
<operator>.assignment j = 0
scanf scanf ( "%s" , array [ j ] )
<operator>.assignment j = 0
<operator>.assignment g = p = jugados = 0
<operator>.assignment j = 0
<operator>.assignment suma = 0
<operator>.assignment jugados = 0
<operator>.assignment j = 0
<operator>.assignment jugados = 0
<operator>.assignment suma = 0
<operator>.assignment j = 0
<operator>.assignment rpi = 0.25 * wpa [ j ] + 0.50 * owpa [ j ] + 0.25 * oowpa [ j ]
printf printf ( "%lf\n" , rpi )
<operator>.lessThan x < e
<operator>.postIncrement x ++
<operator>.equals jugados == 0
<operator>.lessThan x < e
<operator>.postIncrement x ++
<operator>.equals jugados == 0
<operator>.lessThan x < e
<operator>.postIncrement x ++
<operator>.equals jugados == 0
<operator>.assignment p = jugados = 0
<operator>.assignment x = 0
<operator>.assignment wpa [ j ] = 0
<operator>.assignment x = 0
<operator>.assignment owpa [ j ] = 0
<operator>.assignment x = 0
<operator>.assignment oowpa [ j ] = 0
<operator>.addition 0.25 * wpa [ j ] + 0.50 * owpa [ j ] + 0.25 * oowpa [ j ]
<operator>.assignment jugados = 0
<operator>.equals array [ j ] [ x ] == '1'
<operator>.equals array [ j ] [ x ] == '0'
<operator>.assignment wpa [ j ] = g / jugados
<operator>.logicalOr array [ j ] [ x ] == '1' || array [ j ] [ x ] == '0'
<operator>.assignment owpa [ j ] = suma / jugados
<operator>.logicalOr array [ j ] [ x ] == '1' || array [ j ] [ x ] == '0'
<operator>.assignment oowpa [ j ] = suma / jugados
<operator>.addition 0.25 * wpa [ j ] + 0.50 * owpa [ j ]
<operator>.multiplication 0.25 * oowpa [ j ]
<operator>.postIncrement g ++
<operator>.postIncrement jugados ++
<operator>.postIncrement p ++
<operator>.postIncrement jugados ++
<operator>.assignment g = 0
<operator>.assignment p = 0
<operator>.assignmentPlus suma += wp
<operator>.postIncrement jugados ++
<operator>.postIncrement jugados ++
<operator>.assignmentPlus suma += owpa [ x ]
<operator>.multiplication 0.25 * wpa [ j ]
<operator>.multiplication 0.50 * owpa [ j ]
<operator>.division g / jugados
<operator>.equals array [ j ] [ x ] == '1'
<operator>.equals array [ j ] [ x ] == '0'
<operator>.lessThan y < e
<operator>.postIncrement y ++
<operator>.equals p == 0
<operator>.division suma / jugados
<operator>.equals array [ j ] [ x ] == '1'
<operator>.equals array [ j ] [ x ] == '0'
<operator>.division suma / jugados
<operator>.assignment y = 0
<operator>.assignment wp = 0
<operator>.logicalAnd array [ x ] [ y ] == '1' && y != j
<operator>.logicalAnd array [ x ] [ y ] == '0' && y != j
<operator>.assignment wp = g / p
<operator>.postIncrement g ++
<operator>.postIncrement p ++
<operator>.postIncrement p ++
<operator>.equals array [ x ] [ y ] == '1'
<operator>.notEquals y != j
<operator>.equals array [ x ] [ y ] == '0'
<operator>.notEquals y != j
<operator>.division g / p
<operator>.addressOf & t
<operator>.addressOf & e
<operator>.indirectIndexAccess array [ j ]
<operator>.indirectIndexAccess wpa [ j ]
<operator>.indirectIndexAccess owpa [ j ]
<operator>.indirectIndexAccess oowpa [ j ]
<operator>.indirectIndexAccess oowpa [ j ]
<operator>.indirectIndexAccess array [ j ] [ x ]
<operator>.indirectIndexAccess array [ j ] [ x ]
<operator>.indirectIndexAccess wpa [ j ]
<operator>.indirectIndexAccess owpa [ j ]
<operator>.indirectIndexAccess oowpa [ j ]
<operator>.indirectIndexAccess wpa [ j ]
<operator>.indirectIndexAccess owpa [ j ]
<operator>.indirectIndexAccess array [ j ]
<operator>.indirectIndexAccess array [ j ]
<operator>.indirectIndexAccess array [ j ] [ x ]
<operator>.indirectIndexAccess array [ j ] [ x ]
<operator>.indirectIndexAccess array [ j ] [ x ]
<operator>.indirectIndexAccess array [ j ] [ x ]
<operator>.indirectIndexAccess owpa [ x ]
<operator>.indirectIndexAccess array [ j ]
<operator>.indirectIndexAccess array [ j ]
<operator>.indirectIndexAccess array [ j ]
<operator>.indirectIndexAccess array [ j ]
<operator>.indirectIndexAccess array [ x ] [ y ]
<operator>.indirectIndexAccess array [ x ] [ y ]
<operator>.indirectIndexAccess array [ x ]
<operator>.indirectIndexAccess array [ x ]
>>>PDG&124 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 2->1 2->1 2->2 2->3 2->4 2->6 2->95 3->1 3->2 3->4 4->4 4->5 4->5 4->7 4->8 4->8 4->9 4->11 4->13 4->15 4->17 4->19 4->19 4->20 4->22 4->24 4->27 4->30 4->96 5->4 6->4 7->9 7->11 7->13 7->15 7->17 7->33 7->36 7->39 7->75 9->9 9->10 9->10 9->11 9->21 9->97 10->9 11->11 11->12 11->12 11->13 11->23 11->33 11->33 11->35 11->42 11->43 11->50 12->11 13->13 13->14 13->14 13->15 13->25 13->26 13->36 13->36 13->38 13->45 13->91 13->93 14->13 15->15 15->16 15->16 15->17 15->28 15->29 15->39 15->39 15->41 15->47 16->15 17->7 17->9 17->17 17->18 17->18 17->31 17->32 17->49 17->58 17->59 17->70 17->71 17->101 17->107 17->108 18->17 20->9 22->11 23->60 23->72 24->13 25->66 25->78 26->38 26->67 27->15 28->41 28->68 29->69 29->81 30->17 31->32 33->11 33->33 33->34 33->34 33->51 33->52 33->102 33->103 33->109 33->110 34->33 35->44 35->53 35->72 35->72 35->98 35->104 36->13 36->36 36->37 36->37 36->54 36->73 36->75 36->111 36->116 37->36 38->46 38->55 38->78 38->78 38->99 38->105 39->15 39->39 39->40 39->40 39->56 39->79 39->113 39->118 40->39 41->48 41->57 41->81 41->81 41->100 41->106 42->23 42->62 43->33 44->70 45->36 46->71 47->39 48->59 50->23 50->35 50->42 50->61 50->63 51->52 51->60 51->61 52->21 52->51 52->54 52->56 52->62 52->63 52->73 52->79 53->70 54->56 54->64 54->65 54->66 54->67 54->75 54->77 54->82 55->71 56->54 56->68 56->69 56->115 57->59 59->31 59->31 59->49 59->49 60->72 61->35 61->63 63->35 63->61 64->87 64->94 65->77 65->88 65->89 66->78 67->38 68->41 69->81 70->31 70->31 70->49 70->49 70->58 70->58 71->31 71->31 71->49 71->49 71->58 71->58 72->53 72->53 73->21 73->51 73->54 73->54 73->74 73->74 73->79 73->112 73->117 74->21 74->51 74->54 74->54 74->73 74->79 75->36 75->75 75->76 75->76 75->84 75->85 75->90 75->91 75->92 75->93 75->120 75->121 75->122 75->123 76->75 77->83 77->86 77->94 77->94 78->55 78->55 79->21 79->51 79->56 79->56 79->73 79->80 79->80 79->114 79->119 80->21 80->51 80->56 80->56 80->73 80->79 81->57 81->57 82->75 83->66 84->85 84->87 84->88 85->84 85->89 86->66 87->94 88->77 88->89 89->77 89->88 90->84 90->84 90->91 90->92 91->14 91->76 91->84 91->84 91->93 91->93 92->85 92->85 92->90 92->93 93->14 93->76 93->85 93->85 93->91 94->86 94->86
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int t , i , j , e , x , y ; double g , p , jugados ; char array [ 1000 ] [ 1000 ] ; double wp , owp , oowp , rpi , suma ; double wpa [ 1000 ] , owpa [ 1000 ] , oowpa [ 1000 ] ; while ( scanf ( "\x25\x64\x0" , & t ) != EOF ) { for ( i = 0 ; i < t ; i ++ ) { scanf ( "%d" , & e ) ; printf ( "Case #%d:\n" , i + 1 ) ; for ( j = 0 ; j < e ; j ++ ) { scanf ( "%s" , array [ j ] ) ; } for ( j = 0 ; j < e ; j ++ ) { g = p = jugados = 0 ; for ( x = 0 ; x < e ; x ++ ) { if ( array [ j ] [ x ] == '1' ) { g ++ ; jugados ++ ; } if ( array [ j ] [ x ] == '0' ) { p ++ ; jugados ++ ; } } if ( jugados == 0 ) wpa [ j ] = 0 ; else wpa [ j ] = g / jugados ; } for ( j = 0 ; j < e ; j ++ ) { suma = 0 ; jugados = 0 ; for ( x = 0 ; x < e ; x ++ ) { if ( array [ j ] [ x ] == '1' || array [ j ] [ x ] == '0' ) { g = 0 ; p = 0 ; for ( y = 0 ; y < e ; y ++ ) { if ( array [ x ] [ y ] == '1' && y != j ) { g ++ ; p ++ ; } if ( array [ x ] [ y ] == '0' && y != j ) p ++ ; } if ( p == 0 ) wp = 0 ; else wp = g / p ; suma += wp ; jugados ++ ; } } if ( jugados == 0 ) owpa [ j ] = 0 ; else owpa [ j ] = suma / jugados ; } for ( j = 0 ; j < e ; j ++ ) { jugados = 0 ; suma = 0 ; for ( x = 0 ; x < e ; x ++ ) { if ( array [ j ] [ x ] == '1' || array [ j ] [ x ] == '0' ) { jugados ++ ; suma += owpa [ x ] ; } } if ( jugados == 0 ) oowpa [ j ] = 0 ; else oowpa [ j ] = suma / jugados ; } for ( j = 0 ; j < e ; j ++ ) { rpi = 0.25 * wpa [ j ] + 0.50 * owpa [ j ] + 0.25 * oowpa [ j ] ; printf ( "%lf\n" , rpi ) ; } } } }
>>>Func
METHOD eraseCArray
METHOD_RETURN int
PARAM CArray * array
RETURN return 0 ; return 0 ;
<operator>.lessThan i < array -> size
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.assignment array -> array [ i ] = 0
<operator>.indirectFieldAccess array -> size
FIELD_IDENTIFIER size size
<operator>.indirectIndexAccess array -> array [ i ]
<operator>.indirectFieldAccess array -> array
FIELD_IDENTIFIER array array
>>>PDG&14 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 5->1 5->4 6->3 7->1 7->4 8->1 8->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int eraseCArray ( CArray * array ) { int i ; for ( i = 0 ; i < array -> size ; i ++ ) { array -> array [ i ] = 0 ; } return 0 ; }
>>>Func
METHOD invoke
METHOD_RETURN void
PARAM char c
<operator>.greaterThan spell_length > 0
<operator>.assignment e = combine [ peek ( ) ] [ c ]
IDENTIFIER e if (e)
push push ( c )
pop pop ( )
push push ( e )
clear clear ( )
push push ( c )
<operator>.indirectIndexAccess combine [ peek ( ) ] [ c ]
<operator>.indirectIndexAccess combine [ peek ( ) ]
peek peek ( )
<operator>.indirectIndexAccess oppose_elements [ c ]
>>>PDG&15 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->6 2->10 3->1 3->1 3->4 3->6 3->7 3->8 3->11 3->12 3->13 3->14 4->1 4->1 4->8 7->1 8->1 8->1 14->9 14->10
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void invoke ( char c ) { if ( spell_length > 0 ) { char e = combine [ peek ( ) ] [ c ] ; if ( e ) { pop ( ) ; push ( e ) ; } else if ( oppose_elements [ c ] ) clear ( ) ; else push ( c ) ; } else push ( c ) ; }
>>>Func
METHOD isValid
METHOD_RETURN bool
PARAM char * s
<operator>.assignment k = 0
<operator>.assignment len = strlen ( s )
<operator>.assignment * store = calloc ( len   sizeof ( char ) )
free free ( store )
RETURN return s [ i ] == '\0' && k == 0 ; return s [ i ] == '\0' && k == 0 ;
<operator>.notEquals s [ i ] != '\0'
<operator>.postIncrement i ++
<operator>.logicalAnd s [ i ] == '\0' && k == 0
strlen strlen ( s )
calloc calloc ( len   sizeof ( char ) )
<operator>.assignment i = 0
<operator>.sizeOf sizeof ( char )
<operator>.equals s [ i ] == '\0'
<operator>.equals k == 0
LITERAL '(' <empty>
LITERAL '{' <empty>
LITERAL '[' <empty>
<operator>.assignment store [ k ++ ] = s [ i ]
LITERAL,')' <empty>
LITERAL '}' <empty>
LITERAL ']' <empty>
<operator>.logicalOr k < 1 || store [ -- k ] != '('
<operator>.logicalOr k < 1 || store [ -- k ] != '{'
<operator>.logicalOr k < 1 || store [ -- k ] != '['
<operator>.postIncrement k ++
<operator>.lessThan k < 1
<operator>.notEquals store [ -- k ] != '('
<operator>.lessThan k < 1
<operator>.notEquals store [ -- k ] != '{'
<operator>.lessThan k < 1
<operator>.notEquals store [ -- k ] != '['
<operator>.preDecrement -- k
<operator>.preDecrement -- k
<operator>.preDecrement -- k
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess store [ k ++ ]
<operator>.indirectIndexAccess s [ i ]
<operator>.indirectIndexAccess store [ -- k ]
<operator>.indirectIndexAccess store [ -- k ]
<operator>.indirectIndexAccess store [ -- k ]
>>>PDG&44 0->2 0->3 0->5 0->6 0->8 0->9 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->21 0->22 0->23 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 2->11 3->1 3->1 3->16 3->27 3->28 3->30 3->32 4->1 4->1 4->5 4->12 5->1 5->1 5->6 5->29 5->31 5->33 6->1 7->1 8->1 8->15 8->20 8->38 9->1 9->1 10->1 10->1 10->1 10->7 11->1 11->4 11->8 11->15 11->20 12->1 13->1 13->1 13->9 14->1 15->1 15->10 15->10 15->16 16->1 16->10 16->10 20->1 20->1 20->6 24->1 24->1 24->1 24->8 24->9 24->37 25->1 25->1 25->1 25->8 25->9 25->37 26->1 26->1 26->1 26->8 26->9 26->37 27->1 27->16 27->28 27->30 27->32 28->1 28->16 28->24 28->24 28->27 28->29 28->30 28->32 28->34 28->34 28->41 29->1 29->6 29->24 29->24 29->31 29->33 30->1 30->16 30->25 30->25 30->27 30->28 30->31 30->32 30->35 30->35 30->42 31->1 31->6 31->25 31->25 31->29 31->33 32->1 32->16 32->26 32->26 32->27 32->28 32->30 32->33 32->36 32->36 32->43 33->1 33->6 33->26 33->26 33->29 33->31 34->1 34->16 34->27 34->28 34->30 34->32 35->1 35->16 35->27 35->28 35->30 35->32 36->1 36->16 36->27 36->28 36->30 36->32 38->8 38->9 38->20 38->24 38->25 38->26 38->27 38->28 38->30 38->32 38->37 38->39 38->40
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) bool isValid ( char * s ) { int i , k = 0 , len = strlen ( s ) ; char * store = calloc ( len , sizeof ( char ) ) ; for ( i = 0 ; s [ i ] != '\0' ; i ++ ) { switch ( s [ i ] ) { case '(' : case '{' : case '[' : store [ k ++ ] = s [ i ] ; break ; case ')' : if ( k < 1 || store [ -- k ] != '(' ) goto out ; break ; case '}' : if ( k < 1 || store [ -- k ] != '{' ) goto out ; break ; case ']' : if ( k < 1 || store [ -- k ] != '[' ) goto out ; break ; } } out : free ( store ) ; return s [ i ] == '\0' && k == 0 ; }
>>>Func
METHOD is_oppose_hist_present
METHOD_RETURN int
PARAM char curr_elem
PARAM int oppose_history_matrix [ 9 ] [ 9 ]
<operator>.assignment curr_idx = char_idx [ curr_elem - 'A' ]
RETURN return 0 ; return 0 ;
<operator>.lessThan i < 8
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.subtraction curr_elem - 'A'
<operator>.greaterThan oppose_history_matrix [ i ] [ curr_idx ] > 0
RETURN return 1 ; return 1 ;
LITERAL 1 return 1 ;
<operator>.indirectIndexAccess oppose_history_matrix [ i ] [ curr_idx ]
<operator>.indirectIndexAccess oppose_history_matrix [ i ]
>>>PDG&16 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->10 3->1 4->1 4->1 4->1 5->1 6->1 6->1 6->5 6->7 6->11 6->14 6->15 7->1 7->6 8->5 9->1 9->6 10->1 11->1 11->1 11->6 11->7 11->12 12->1 13->12
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static int is_oppose_hist_present ( char curr_elem , int oppose_history_matrix [ 9 ] [ 9 ] ) { int i ; int curr_idx = char_idx [ curr_elem - 'A' ] ; for ( i = 0 ; i < 8 ; i ++ ) { if ( oppose_history_matrix [ i ] [ curr_idx ] > 0 ) { return 1 ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x5c\x6e\x0" , & ndc )
<operator>.lessThan casoactual < ndc
<operator>.postIncrement casoactual ++
<operator>.assignment casoactual = 0
resolver resolver ( casoactual )
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->3 3->1 3->1 3->1 3->3 3->4 3->6 3->6 4->1 4->3 5->1 5->3 6->1 6->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { scanf ( "\x25\x64\x5c\x6e\x0" , & ndc ) ; for ( casoactual = 0 ; casoactual < ndc ; casoactual ++ ) { resolver ( casoactual ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment len = 0
scanf scanf ( "\x25\x64\x0" , & tests )
RETURN return 0 ; return 0 ;
<operator>.lessThan jj < tests
<operator>.postIncrement jj ++
LITERAL 0 return 0 ;
<operator>.assignment jj = 0
scanf scanf ( "%d" , & c )
scanf scanf ( "%d" , & d )
scanf scanf ( "%d %s" , & n , ip_string )
<operator>.assignment len = 0
printf printf ( "Case #%d: [" , jj + 1 )
printf printf ( "]\n" )
<operator>.lessThan ii < c
<operator>.postIncrement ii ++
<operator>.lessThan ii < d
<operator>.postIncrement ii ++
<operator>.lessThan ii < n
<operator>.postIncrement ii ++
<operator>.lessThan ii < len
<operator>.postIncrement ii ++
<operator>.assignment ii = 0
scanf scanf ( "%c" , & ch )
scanf scanf ( "%c" , & ch )
<operator>.assignment base_pair [ ii ] [ 0 ] = ch
scanf scanf ( "%c" , & ch )
<operator>.assignment base_pair [ ii ] [ 1 ] = ch
scanf scanf ( "%c" , & ch )
<operator>.assignment base_pair [ ii ] [ 2 ] = ch
<operator>.assignment ii = 0
scanf scanf ( "%c" , & ch )
scanf scanf ( "%c" , & ch )
<operator>.assignment opposed_pair [ ii ] [ 0 ] = ch
scanf scanf ( "%c" , & ch )
<operator>.assignment opposed_pair [ ii ] [ 1 ] = ch
<operator>.assignment ii = 0
<operator>.assignment out_list [ len ++ ] = ip_string [ ii ]
<operator>.addition jj + 1
<operator>.assignment ii = 0
printf printf ( "%c" , out_list [ ii ] )
<operator>.greaterThan len > 1
<operator>.greaterThan len > 1
<operator>.notEquals ii != len - 1
<operator>.assignment match_index = merge ( out_list [ len - 2 ] , out_list [ len - 1 ] , c )
printf printf ( ", " )
<operator>.postIncrement len ++
<operator>.greaterEqualsThan match_index >= 0
<operator>.logicalAnd ( match_index == - 1 ) && eliminate ( out_list , len , d )
<operator>.subtraction len - 1
merge merge ( out_list [ len - 2 ] , out_list [ len - 1 ] , c )
<operator>.assignment out_list [ len - 2 ] = base_pair [ match_index ] [ 2 ]
<operator>.assignment len = len - 1
<operator>.assignment len = 0
<operator>.equals match_index == - 1
eliminate eliminate ( out_list , len , d )
<operator>.subtraction len - 2
<operator>.subtraction len - 1
<operator>.subtraction len - 1
<operator>.minus - 1
<operator>.subtraction len - 2
<operator>.addressOf & c
<operator>.addressOf & d
<operator>.addressOf & n
<operator>.addressOf & ch
<operator>.addressOf & ch
<operator>.indirectIndexAccess base_pair [ ii ] [ 0 ]
<operator>.addressOf & ch
<operator>.indirectIndexAccess base_pair [ ii ] [ 1 ]
<operator>.addressOf & ch
<operator>.indirectIndexAccess base_pair [ ii ] [ 2 ]
<operator>.addressOf & ch
<operator>.addressOf & ch
<operator>.indirectIndexAccess opposed_pair [ ii ] [ 0 ]
<operator>.addressOf & ch
<operator>.indirectIndexAccess opposed_pair [ ii ] [ 1 ]
<operator>.indirectIndexAccess out_list [ len ++ ]
<operator>.indirectIndexAccess ip_string [ ii ]
<operator>.indirectIndexAccess out_list [ ii ]
<operator>.indirectIndexAccess base_pair [ ii ]
<operator>.indirectIndexAccess base_pair [ ii ]
<operator>.indirectIndexAccess base_pair [ ii ]
<operator>.indirectIndexAccess opposed_pair [ ii ]
<operator>.indirectIndexAccess opposed_pair [ ii ]
<operator>.indirectIndexAccess out_list [ len - 2 ]
<operator>.indirectIndexAccess out_list [ len - 1 ]
<operator>.indirectIndexAccess out_list [ len - 2 ]
<operator>.indirectIndexAccess base_pair [ match_index ] [ 2 ]
<operator>.indirectIndexAccess base_pair [ match_index ]
>>>PDG&90 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->50 0->51 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 2->1 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->10 5->11 5->12 5->13 5->13 5->14 5->15 5->17 5->19 5->21 5->23 5->31 5->37 5->39 5->39 5->40 5->62 5->63 5->64 6->1 6->5 7->4 8->1 8->5 9->1 9->15 9->51 10->1 10->17 10->56 11->1 11->1 11->19 12->1 12->21 12->47 13->1 13->1 14->1 15->1 15->1 15->9 15->15 15->16 15->16 15->24 15->25 15->26 15->27 15->28 15->29 15->30 15->51 15->65 15->66 15->67 15->68 15->69 15->70 15->71 15->80 15->81 15->82 16->1 16->15 17->1 17->1 17->10 17->17 17->18 17->18 17->32 17->33 17->34 17->35 17->36 17->56 17->72 17->73 17->74 17->75 17->76 17->83 17->84 18->1 18->17 19->1 19->1 19->11 19->19 19->20 19->20 19->38 19->42 19->43 19->47 19->77 19->78 20->1 20->19 21->1 21->1 21->1 21->21 21->22 21->41 21->44 21->44 21->50 21->50 21->79 22->1 22->21 23->15 24->25 24->26 25->24 25->26 25->27 25->28 25->29 25->30 25->32 25->33 25->34 25->35 25->36 26->1 26->1 27->24 27->25 27->26 27->28 27->29 27->30 27->32 27->33 27->34 27->35 27->36 28->1 28->1 29->1 29->24 29->25 29->26 29->30 29->32 29->33 29->34 29->35 29->36 30->1 30->1 30->1 31->17 32->24 32->25 32->26 32->33 32->34 32->35 32->36 33->24 33->25 33->26 33->34 33->35 33->36 34->1 34->1 35->1 35->24 35->25 35->26 35->32 35->33 35->34 35->36 36->1 36->1 36->1 37->19 38->1 38->1 38->1 38->56 40->1 40->21 41->1 41->1 41->56 42->43 42->45 42->48 42->51 42->57 42->57 42->58 42->85 42->86 43->1 43->21 43->47 43->49 43->55 43->56 43->60 44->1 44->1 44->22 44->46 45->1 45->1 45->48 46->1 47->42 48->1 48->1 48->52 48->53 48->55 48->59 48->61 48->87 48->88 48->89 49->1 49->1 49->1 49->54 50->21 50->44 50->44 51->1 51->1 51->1 51->9 51->15 51->45 51->45 51->45 51->56 51->56 52->1 52->1 52->1 52->51 52->56 53->1 53->1 53->43 54->1 54->21 54->47 55->1 55->1 55->49 55->49 55->56 56->1 56->1 56->10 56->17 56->21 56->41 56->47 56->49 56->49 56->49 56->51 57->58 58->43 58->61 59->53 59->53 60->55 61->59
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int tests , c , d , n ; int ii , jj ; char ch ; int len = 0 ; int match_index ; scanf ( "\x25\x64\x0" , & tests ) ; for ( jj = 0 ; jj < tests ; jj ++ ) { scanf ( "%d" , & c ) ; for ( ii = 0 ; ii < c ; ii ++ ) { scanf ( "%c" , & ch ) ; scanf ( "%c" , & ch ) ; base_pair [ ii ] [ 0 ] = ch ; scanf ( "%c" , & ch ) ; base_pair [ ii ] [ 1 ] = ch ; scanf ( "%c" , & ch ) ; base_pair [ ii ] [ 2 ] = ch ; } scanf ( "%d" , & d ) ; for ( ii = 0 ; ii < d ; ii ++ ) { scanf ( "%c" , & ch ) ; scanf ( "%c" , & ch ) ; opposed_pair [ ii ] [ 0 ] = ch ; scanf ( "%c" , & ch ) ; opposed_pair [ ii ] [ 1 ] = ch ; } scanf ( "%d %s" , & n , ip_string ) ; len = 0 ; for ( ii = 0 ; ii < n ; ii ++ ) { out_list [ len ++ ] = ip_string [ ii ] ; if ( len > 1 ) { match_index = merge ( out_list [ len - 2 ] , out_list [ len - 1 ] , c ) ; if ( match_index >= 0 ) { out_list [ len - 2 ] = base_pair [ match_index ] [ 2 ] ; len = len - 1 ; } } if ( len > 1 ) { if ( ( match_index == - 1 ) && eliminate ( out_list , len , d ) ) len = 0 ; } } printf ( "Case #%d: [" , jj + 1 ) ; for ( ii = 0 ; ii < len ; ii ++ ) { printf ( "%c" , out_list [ ii ] ) ; if ( ii != len - 1 ) printf ( ", " ) ; } printf ( "]\n" ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & cases )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan j <= cases
<operator>.postIncrement j ++
LITERAL 0 return 0 ;
<operator>.assignment j = 1
getchar getchar ( )
scanf scanf ( "%d" , & team_no )
printf printf ( "Case #%d:\n" , j )
free free ( wp )
free free ( owp )
free free ( oowp )
free free ( games )
free free ( wins )
free free ( team_res )
<operator>.lessThan i < team_no
<operator>.postIncrement i ++
<operator>.lessThan k < team_no
<operator>.postIncrement k ++
<operator>.lessThan i < team_no
<operator>.postIncrement i ++
<operator>.assignment wp [ i ] = ( wins [ i ] ) / ( games [ i ] )
<operator>.lessThan k < team_no
<operator>.postIncrement k ++
<operator>.lessThan k < team_no
<operator>.postIncrement k ++
<operator>.lessThan i < team_no
<operator>.postIncrement i ++
<operator>.lessThan i < team_no
<operator>.postIncrement i ++
free free ( team_res [ i ] )
<operator>.assignment i = 0
scanf scanf ( "%s" , team_res [ i ] )
<operator>.assignment k = 0
<operator>.assignment i = 0
<operator>.assignment k = 0
<operator>.assignment number = 0
<operator>.assignmentDivision owp [ k ] /= ( ( double ) number )
<operator>.assignment k = 0
<operator>.assignment number = 0
<operator>.assignmentDivision oowp [ k ] /= ( ( double ) number )
<operator>.assignment i = 0
printf printf ( "%0.12f\n" , 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ] )
<operator>.assignment i = 0
<operator>.lessThan i < team_no
<operator>.postIncrement i ++
<operator>.division ( wins [ i ] ) / ( games [ i ] )
<operator>.lessThan i < team_no
<operator>.postIncrement i ++
<operator>.lessThan i < team_no
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.cast ( double ) number
<operator>.assignment i = 0
<operator>.cast ( double ) number
<operator>.addition 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ]
<operator>.equals team_res [ i ] [ k ] == '1'
<operator>.notEquals team_res [ i ] [ k ] != '.'
<operator>.notEquals team_res [ k ] [ i ] != '.'
<operator>.notEquals team_res [ k ] [ i ] != '.'
<operator>.addition 0.25 * wp [ i ] + 0.5 * owp [ i ]
<operator>.multiplication 0.25 * oowp [ i ]
<operator>.postIncrement wins [ i ] ++
<operator>.postIncrement games [ i ] ++
<operator>.postIncrement number ++
<operator>.assignment temp_wins = wins [ i ]
<operator>.assignment temp_games = games [ i ]
<operator>.assignmentMinus temp_games -= 1
<operator>.assignmentPlus owp [ k ] += ( temp_wins ) / ( temp_games )
<operator>.assignmentPlus oowp [ k ] += owp [ i ]
<operator>.postIncrement number ++
<operator>.multiplication 0.25 * wp [ i ]
<operator>.multiplication 0.5 * owp [ i ]
<operator>.equals team_res [ k ] [ i ] == '0'
<operator>.assignmentMinus temp_wins -= 1
<operator>.division ( temp_wins ) / ( temp_games )
UNKNOWN <missing ';'> Malloc <missing ';'> ( <missing ';'> team_res , char <missing ';'> * , team_no ) ; <missing ';'> Malloc <missing ';'> ( <missing ';'> team_res , char <missing ';'> * , team_no ) ;
UNKNOWN <missing ';'> Malloc <missing ';'> ( <missing ';'> wp , <missing ';'> double , team_no ) ; <missing ';'> Malloc <missing ';'> ( <missing ';'> wp , <missing ';'> double , team_no ) ;
UNKNOWN <missing ';'> Calloc <missing ';'> ( <missing ';'> owp , <missing ';'> double , team_no ) ; <missing ';'> Calloc <missing ';'> ( <missing ';'> owp , <missing ';'> double , team_no ) ;
UNKNOWN <missing ';'> Calloc <missing ';'> ( <missing ';'> oowp , <missing ';'> double , team_no ) ; <missing ';'> Calloc <missing ';'> ( <missing ';'> oowp , <missing ';'> double , team_no ) ;
UNKNOWN <missing ';'> Calloc <missing ';'> ( <missing ';'> games , <missing ';'> double , team_no ) ; <missing ';'> Calloc <missing ';'> ( <missing ';'> games , <missing ';'> double , team_no ) ;
UNKNOWN <missing ';'> Calloc <missing ';'> ( <missing ';'> wins , <missing ';'> double , team_no ) ; <missing ';'> Calloc <missing ';'> ( <missing ';'> wins , <missing ';'> double , team_no ) ;
<operator>.addressOf & team_no
UNKNOWN <missing ';'> Malloc <missing ';'> ( <missing ';'> team_res [ i ] , <missing ';'> char , team_no ) ; <missing ';'> Malloc <missing ';'> ( <missing ';'> team_res [ i ] , <missing ';'> char , team_no ) ;
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess team_res [ i ]
<operator>.indirectIndexAccess team_res [ i ]
<operator>.indirectIndexAccess wins [ i ]
<operator>.indirectIndexAccess games [ i ]
<operator>.indirectIndexAccess owp [ k ]
<operator>.indirectIndexAccess oowp [ k ]
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess team_res [ i ] [ k ]
<operator>.indirectIndexAccess team_res [ i ] [ k ]
<operator>.indirectIndexAccess team_res [ k ] [ i ]
<operator>.indirectIndexAccess team_res [ k ] [ i ]
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess team_res [ i ]
<operator>.indirectIndexAccess wins [ i ]
<operator>.indirectIndexAccess team_res [ i ]
<operator>.indirectIndexAccess games [ i ]
<operator>.indirectIndexAccess team_res [ k ]
<operator>.indirectIndexAccess wins [ i ]
<operator>.indirectIndexAccess games [ i ]
<operator>.indirectIndexAccess owp [ k ]
<operator>.indirectIndexAccess team_res [ k ]
<operator>.indirectIndexAccess oowp [ k ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess team_res [ k ] [ i ]
<operator>.indirectIndexAccess team_res [ k ]
>>>PDG&116 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->59 0->60 0->61 0->62 0->64 0->67 0->70 0->73 0->74 0->75 0->76 0->77 0->78 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->19 4->21 4->24 4->26 4->28 4->30 4->33 4->35 4->36 4->37 4->40 4->43 4->45 4->79 4->80 4->81 4->82 4->83 4->84 4->85 5->1 5->4 6->3 7->1 7->4 8->1 9->1 9->17 9->19 9->21 9->24 9->26 9->28 9->30 9->46 9->49 9->51 10->1 10->5 11->1 11->74 12->1 12->39 12->71 12->72 12->75 13->1 13->42 13->64 13->72 14->1 14->48 14->66 14->69 15->1 15->48 15->65 15->68 16->1 16->32 16->34 17->17 17->18 17->18 17->19 17->34 17->86 17->89 18->1 18->17 19->19 19->20 19->20 19->21 19->46 19->46 19->53 20->1 20->19 21->21 21->22 21->22 21->23 21->24 21->48 21->87 21->90 21->91 22->1 22->21 23->1 23->1 23->1 23->11 23->74 24->24 24->25 24->25 24->26 24->38 24->39 24->49 24->49 24->54 24->55 24->92 24->94 25->1 25->24 26->1 26->1 26->26 26->27 26->27 26->28 26->41 26->42 26->51 26->51 26->56 26->57 26->93 26->95 27->1 27->26 28->28 28->29 28->29 28->30 28->44 28->58 28->63 28->64 28->74 28->75 28->96 28->101 28->102 29->1 29->28 30->1 30->1 30->1 30->9 30->17 30->30 30->31 30->31 30->32 30->88 31->1 31->30 32->1 32->16 32->34 33->17 34->1 34->16 34->32 35->19 36->21 37->24 38->1 38->39 38->55 38->67 39->1 39->1 39->1 39->12 39->71 40->1 40->26 41->1 41->42 41->57 41->73 42->1 42->1 42->1 42->13 42->72 43->28 44->1 44->1 45->1 45->30 46->19 46->46 46->47 46->47 46->59 46->60 46->97 46->98 46->103 46->105 47->1 47->46 48->1 48->1 48->14 48->15 48->23 48->23 48->65 48->66 48->68 48->69 49->24 49->49 49->50 49->50 49->61 49->99 49->107 50->1 50->49 51->26 51->51 51->52 51->52 51->62 51->100 51->111 52->1 52->51 53->46 54->49 55->1 56->51 57->1 58->1 58->1 59->1 59->60 59->65 59->104 60->1 60->1 60->32 60->34 60->59 60->66 60->106 61->1 61->1 61->62 61->67 61->68 61->69 61->70 61->71 61->76 61->76 61->78 61->108 61->109 61->110 61->114 61->115 62->1 62->1 62->61 62->72 62->73 62->112 62->113 63->1 63->1 64->1 64->13 64->44 64->44 64->58 64->58 65->1 65->1 65->15 65->48 65->68 66->1 66->1 66->14 66->48 66->69 67->1 67->39 67->55 68->1 68->1 68->77 68->78 69->1 69->1 69->70 70->1 70->78 71->1 71->1 71->39 72->1 72->1 72->42 73->1 73->42 73->57 74->1 74->11 74->44 74->44 74->58 74->58 74->63 74->63 75->1 75->12 75->44 75->44 75->58 75->58 75->63 75->63 75->72 76->1 76->1 76->61 76->62 76->77 77->1 77->78 78->1 78->1 78->71 78->71
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int i , j , k , num ; int cases , team_no , number ; double temp_games , temp_wins ; char * * team_res ; double * owp ; double * oowp ; double * wp ; double * games ; double * wins ; scanf ( "\x25\x64\x0" , & cases ) ; for ( j = 1 ; j <= cases ; j ++ ) { getchar ( ) ; scanf ( "%d" , & team_no ) ; <missing ';'> Malloc <missing ';'> ( <missing ';'> team_res , char <missing ';'> * , team_no ) ; <missing ';'> Malloc <missing ';'> ( <missing ';'> wp , <missing ';'> double , team_no ) ; <missing ';'> Calloc <missing ';'> ( <missing ';'> owp , <missing ';'> double , team_no ) ; <missing ';'> Calloc <missing ';'> ( <missing ';'> oowp , <missing ';'> double , team_no ) ; <missing ';'> Calloc <missing ';'> ( <missing ';'> games , <missing ';'> double , team_no ) ; <missing ';'> Calloc <missing ';'> ( <missing ';'> wins , <missing ';'> double , team_no ) ; for ( i = 0 ; i < team_no ; i ++ ) { <missing ';'> Malloc <missing ';'> ( <missing ';'> team_res [ i ] , <missing ';'> char , team_no ) ; scanf ( "%s" , team_res [ i ] ) ; } for ( k = 0 ; k < team_no ; k ++ ) { for ( i = 0 ; i < team_no ; i ++ ) { if ( team_res [ i ] [ k ] == '1' ) wins [ i ] ++ ; if ( team_res [ i ] [ k ] != '.' ) games [ i ] ++ ; } } for ( i = 0 ; i < team_no ; i ++ ) wp [ i ] = ( wins [ i ] ) / ( games [ i ] ) ; for ( k = 0 ; k < team_no ; k ++ ) { number = 0 ; for ( i = 0 ; i < team_no ; i ++ ) { if ( team_res [ k ] [ i ] != '.' ) { number ++ ; temp_wins = wins [ i ] ; temp_games = games [ i ] ; if ( team_res [ k ] [ i ] == '0' ) temp_wins -= 1 ; temp_games -= 1 ; owp [ k ] += ( temp_wins ) / ( temp_games ) ; } } owp [ k ] /= ( ( double ) number ) ; } for ( k = 0 ; k < team_no ; k ++ ) { number = 0 ; for ( i = 0 ; i < team_no ; i ++ ) { if ( team_res [ k ] [ i ] != '.' ) { oowp [ k ] += owp [ i ] ; number ++ ; } } oowp [ k ] /= ( ( double ) number ) ; } printf ( "Case #%d:\n" , j ) ; for ( i = 0 ; i < team_no ; i ++ ) { printf ( "%0.12f\n" , 0.25 * wp [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ] ) ; } free ( wp ) ; free ( owp ) ; free ( oowp ) ; free ( games ) ; free ( wins ) ; for ( i = 0 ; i < team_no ; i ++ ) free ( team_res [ i ] ) ; free ( team_res ) ; } return 0 ; }
>>>Func
METHOD setup
METHOD_RETURN void
PARAM void
fgets fgets ( buf , SZ , stdin )
<operator>.assignment N = strtol ( buf , NULL , 0 )
strtol strtol ( buf , NULL , 0 )
>>>PDG&6 0->2 0->3 0->5 2->1 3->1 3->1 3->1 3->5 4->1 4->1 4->1 5->1 5->1 5->4 5->4 5->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void setup ( void ) { char buf [ SZ ] ; fgets ( buf , SZ , stdin ) ; N = strtol ( buf , NULL , 0 ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
freopen freopen ( "\x69\x6e\x2e\x73\x6d\x61\x6c\x6c\x0" , "r" , stdin )
<operator>.assignment testcase = 0
scanf scanf ( "%d\n" , & testcases )
RETURN return 0 ; return 0 ;
<operator>.lessThan testcase < testcases
LITERAL 0 return 0 ;
<operator>.assignment hours = 0
<operator>.assignment parsecs [ 1000002 ] = { 0 }
scanf scanf ( "%d" , & boosters )
scanf scanf ( "%d" , & t )
scanf scanf ( "%d" , & stars )
scanf scanf ( "%d" , & n )
printf printf ( "Case #%d: %d\n" , ++ testcase , hours )
<operator>.lessThan i < n
<operator>.postIncrement i ++
scanf scanf ( "%d" , & parsecs [ i ] )
<operator>.lessThan i < stars
<operator>.postIncrement i ++
<operator>.arrayInitializer { 0 }
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment speed = 0.5
<operator>.assignment remaining_pasecs = parsecs [ i % n ]
<operator>.assignmentPlus hours += remaining_pasecs / speed
<operator>.preIncrement ++ testcase
<operator>.logicalAnd boosters > 0 && hours + remaining_pasecs > t
<operator>.assignment x = 0
<operator>.division remaining_pasecs / speed
<operator>.modulo i % n
<operator>.greaterThan boosters > 0
<operator>.greaterThan hours + remaining_pasecs > t
<operator>.lessThan j < stars
<operator>.postIncrement j ++
<operator>.greaterEqualsThan boosters >= x
<operator>.addition hours + remaining_pasecs
<operator>.assignment j = i + 1
<operator>.assignment tmp = hours
<operator>.postDecrement boosters --
<operator>.assignmentMinus remaining_pasecs -= ( t - tmp > 0 ? t - tmp : 0 ) * speed
<operator>.assignment speed = 1
<operator>.assignmentPlus hours += ( t - tmp > 0 ? t - tmp : 0 )
<operator>.greaterThan parsecs [ j % n ] > remaining_pasecs
<operator>.addition i + 1
<operator>.postIncrement x ++
<operator>.multiplication ( t - tmp > 0 ? t - tmp : 0 ) * speed
<operator>.conditional t - tmp > 0 ? t - tmp : 0
<operator>.conditional t - tmp > 0 ? t - tmp : 0
<operator>.greaterThan t - tmp > 0
<operator>.subtraction t - tmp
<operator>.modulo j % n
<operator>.greaterThan t - tmp > 0
<operator>.subtraction t - tmp
<operator>.subtraction t - tmp
<operator>.subtraction t - tmp
<operator>.addressOf & boosters
<operator>.addressOf & t
<operator>.addressOf & stars
<operator>.addressOf & n
<operator>.addressOf & parsecs [ i ]
<operator>.indirectIndexAccess parsecs [ i ]
<operator>.indirectIndexAccess parsecs [ i % n ]
<operator>.indirectIndexAccess parsecs [ j % n ]
>>>PDG&65 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 2->1 3->1 3->1 4->1 4->7 5->1 5->7 6->1 7->1 7->1 7->1 7->7 7->9 7->10 7->11 7->12 7->13 7->14 7->15 7->16 7->19 7->21 7->22 7->23 7->27 7->27 7->57 7->58 7->59 7->60 8->6 9->1 9->15 9->26 9->33 9->37 9->39 9->43 10->1 10->1 10->1 10->18 10->25 10->44 11->1 11->32 11->36 11->40 12->1 12->33 12->51 12->54 12->55 12->56 13->1 13->19 13->34 14->1 14->16 14->31 14->52 15->1 15->1 15->1 16->1 16->1 16->14 16->16 16->17 16->17 16->18 16->31 16->61 16->62 17->1 17->16 18->1 19->1 19->1 19->1 19->13 19->19 19->20 19->24 19->25 19->26 19->28 19->30 19->31 19->31 19->32 19->34 19->63 20->1 20->19 21->10 22->16 23->1 23->19 24->1 24->30 24->47 25->1 25->1 25->30 25->33 25->37 25->41 25->44 26->1 26->1 26->15 26->33 26->37 26->39 26->43 27->7 27->15 28->1 28->1 28->1 28->29 28->34 28->36 28->38 28->45 29->1 29->36 29->46 30->1 30->1 30->26 30->26 31->1 31->14 31->16 31->20 31->38 31->45 31->52 32->1 32->11 32->28 32->28 32->33 32->36 32->37 33->1 33->1 33->12 33->28 33->28 33->56 34->1 34->1 34->19 34->34 34->35 34->44 34->52 34->52 34->64 35->1 35->34 36->1 36->1 36->1 36->11 36->32 36->39 36->40 36->40 36->41 36->42 36->43 36->47 36->48 36->49 36->50 36->53 36->55 36->56 38->1 38->1 38->34 39->1 39->56 40->1 40->1 40->11 40->32 41->1 41->1 41->30 42->1 42->30 43->1 43->1 43->26 44->1 44->1 44->30 44->41 44->46 46->1 46->36 47->41 47->41 48->1 48->1 50->43 50->48 50->51 51->1 51->1 51->12 51->33 51->43 51->43 51->48 51->48 51->56 52->1 52->14 52->16 52->31 52->35 53->47 53->49 53->54 54->47 54->47 54->49 54->49 54->55 54->55 55->1 55->1 55->12 55->33 55->50 55->50 55->51 55->51 55->56 56->53 56->53 56->54 56->54 56->55 56->55
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( void ) { freopen ( "\x69\x6e\x2e\x73\x6d\x61\x6c\x6c\x0" , "r" , stdin ) ; int testcase = 0 ; int testcases ; scanf ( "%d\n" , & testcases ) ; while ( testcase < testcases ) { int hours = 0 ; int boosters ; int t ; int stars ; int n ; int parsecs [ 1000002 ] = { 0 } ; int i ; scanf ( "%d" , & boosters ) ; scanf ( "%d" , & t ) ; scanf ( "%d" , & stars ) ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & parsecs [ i ] ) ; for ( i = 0 ; i < stars ; i ++ ) { double speed = 0.5 ; int remaining_pasecs = parsecs [ i % n ] ; if ( boosters > 0 && hours + remaining_pasecs > t ) { int x = 0 ; int j ; for ( j = i + 1 ; j < stars ; j ++ ) { if ( parsecs [ j % n ] > remaining_pasecs ) { x ++ ; } } if ( boosters >= x ) { int tmp = hours ; boosters -- ; remaining_pasecs -= ( t - tmp > 0 ? t - tmp : 0 ) * speed ; speed = 1 ; hours += ( t - tmp > 0 ? t - tmp : 0 ) ; } } hours += remaining_pasecs / speed ; } printf ( "Case #%d: %d\n" , ++ testcase , hours ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < T
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
<operator>.assignment p = 0
<operator>.assignment f = 0
scanf scanf ( "%d %lld %d %d" , & l , & t , & n , & c )
<operator>.lessThan j < c
<operator>.postIncrement j ++
<operator>.lessThan j < c
<operator>.postIncrement j ++
<operator>.equals f == 0
<operator>.assignment j = 0
scanf scanf ( "%d" , & x )
<operator>.assignment a [ j ] . d = ( double ) x
<operator>.assignment a [ j ] . n = n / c
<operator>.assignment j = 0
qsort qsort ( a   c   sizeof ( dist ) , cmp )
printf printf ( "Case #%d: %d\n"   i + 1   ( int ) p )
<operator>.lessThan j < n % c
<operator>.equals a [ j ] . n == 0
<operator>.lessEqualsThan p + a [ j ] . d * 2 <= t
<operator>.equals j == c - 1
<operator>.lessThan j < c
<operator>.postIncrement j ++
<operator>.cast ( double ) x
<operator>.division n / c
<operator>.postIncrement a [ j ] . n ++
printf printf ( "Case #%d: %d\n"   i + 1   ( int ) p )
<operator>.assignment f = 1
<operator>.assignmentPlus p += a [ j ] . d * 2
<operator>.postDecrement a [ j ] . n --
<operator>.assignment j = - 1
<operator>.sizeOf sizeof ( dist )
<operator>.assignment j = 0
<operator>.addition i + 1
<operator>.cast ( int ) p
<operator>.modulo n % c
<operator>.addition p + a [ j ] . d * 2
<operator>.assignment a [ c ] . d = a [ j ] . d - ( t - p ) / 2.0
<operator>.assignment a [ c ] . n = 1
<operator>.postDecrement a [ j ] . n --
<operator>.assignment p = t
<operator>.postIncrement c ++
<operator>.subtraction c - 1
<operator>.equals a [ j ] . n == 0
<operator>.greaterEqualsThan l >= a [ j ] . n
<operator>.addition i + 1
<operator>.cast ( int ) p
<operator>.multiplication a [ j ] . d * 2
<operator>.multiplication a [ j ] . d * 2
<operator>.minus - 1
<operator>.assignmentPlus p += a [ j ] . n * a [ j ] . d
<operator>.assignmentMinus l -= a [ j ] . n
<operator>.subtraction a [ j ] . d - ( t - p ) / 2.0
<operator>.assignmentPlus p += l * a [ j ] . d
<operator>.assignmentPlus p += ( a [ j ] . n - l ) * a [ j ] . d * 2
<operator>.assignment l = 0
<operator>.division ( t - p ) / 2.0
<operator>.multiplication a [ j ] . n * a [ j ] . d
<operator>.subtraction t - p
<operator>.multiplication l * a [ j ] . d
<operator>.multiplication ( a [ j ] . n - l ) * a [ j ] . d * 2
<operator>.multiplication ( a [ j ] . n - l ) * a [ j ] . d
<operator>.subtraction a [ j ] . n - l
<operator>.addressOf & l
<operator>.addressOf & t
<operator>.addressOf & n
<operator>.addressOf & c
<operator>.addressOf & x
<operator>.fieldAccess a [ j ] . d
<operator>.fieldAccess a [ j ] . n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER d d
UNKNOWN double double
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER n n
<operator>.fieldAccess a [ j ] . n
UNKNOWN int int
<operator>.fieldAccess a [ j ] . n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER n n
<operator>.fieldAccess a [ j ] . n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER n n
UNKNOWN int int
<operator>.fieldAccess a [ j ] . d
<operator>.fieldAccess a [ j ] . d
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER n n
<operator>.fieldAccess a [ c ] . d
<operator>.fieldAccess a [ c ] . n
<operator>.fieldAccess a [ j ] . n
<operator>.fieldAccess a [ j ] . n
<operator>.fieldAccess a [ j ] . n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER d d
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER d d
<operator>.indirectIndexAccess a [ c ]
FIELD_IDENTIFIER d d
<operator>.fieldAccess a [ j ] . d
<operator>.indirectIndexAccess a [ c ]
FIELD_IDENTIFIER n n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER n n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER n n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER n n
<operator>.fieldAccess a [ j ] . n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER d d
<operator>.fieldAccess a [ j ] . n
<operator>.fieldAccess a [ j ] . d
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER n n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER n n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER d d
<operator>.fieldAccess a [ j ] . d
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER d d
<operator>.fieldAccess a [ j ] . d
<operator>.fieldAccess a [ j ] . n
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER d d
<operator>.indirectIndexAccess a [ j ]
FIELD_IDENTIFIER n n
>>>PDG&134 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->34 0->38 0->39 0->40 0->41 0->42 0->44 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->59 0->60 0->61 0->62 0->64 0->65 0->66 0->68 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->13 4->15 4->16 4->20 4->22 4->32 4->39 4->51 4->69 4->70 4->71 4->72 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->22 8->25 8->32 8->34 8->40 8->42 8->52 8->56 8->59 8->64 9->1 9->15 10->1 10->1 10->1 10->1 10->50 10->57 10->65 10->68 11->11 11->12 11->13 11->17 11->18 11->19 11->23 11->23 11->29 11->30 11->30 11->41 11->73 11->74 11->75 11->76 11->77 11->78 11->79 11->80 12->1 12->11 13->1 13->1 13->1 13->11 13->21 13->24 13->26 13->47 13->48 13->81 13->84 13->85 14->1 14->13 15->1 15->1 15->21 15->22 15->27 15->37 15->38 15->39 15->40 15->82 16->11 17->1 17->18 17->29 18->1 18->1 19->1 19->1 20->1 20->13 21->1 21->1 21->1 21->27 22->1 22->1 22->1 23->1 23->1 23->12 23->31 23->83 23->87 23->88 24->1 24->1 24->25 24->32 24->33 24->35 24->42 24->45 24->51 24->52 24->53 24->89 24->90 24->99 24->100 25->1 25->1 25->1 25->13 25->14 25->26 25->34 25->35 25->43 25->44 25->45 25->46 25->47 25->48 25->54 25->58 25->62 25->64 25->64 25->86 25->91 25->92 25->93 25->94 25->95 25->96 25->101 25->102 25->103 25->104 25->105 25->106 25->107 25->108 25->109 25->115 25->116 26->1 26->1 26->14 26->36 26->55 27->1 27->1 27->1 27->11 27->27 27->28 27->28 27->49 27->97 27->110 27->111 28->1 28->27 29->1 30->19 30->19 30->41 30->41 31->1 32->1 32->1 32->1 33->1 33->15 34->1 34->1 34->1 34->22 34->25 34->32 34->40 34->42 34->52 34->56 34->59 34->64 35->1 36->1 36->1 36->14 37->1 38->1 38->27 40->1 41->1 41->11 41->23 41->23 41->30 42->1 43->1 43->1 44->1 45->1 45->1 46->1 46->1 46->1 46->22 46->40 46->56 46->59 47->1 47->1 47->11 47->21 48->13 48->26 48->26 49->1 49->50 49->50 49->98 49->112 49->113 50->1 50->56 50->57 50->57 50->59 50->60 50->61 50->63 50->63 50->65 50->65 50->66 50->67 50->68 50->68 50->114 50->117 50->118 50->119 50->120 50->121 50->122 50->123 50->124 50->125 50->126 50->127 50->128 50->129 50->130 50->131 50->132 50->133 52->1 53->25 53->25 53->42 53->42 53->54 53->58 54->34 54->34 55->36 56->1 56->1 56->22 56->40 56->59 57->1 57->1 57->10 57->50 58->1 58->1 58->43 58->43 59->1 59->1 59->60 60->1 60->1 60->22 60->40 60->56 60->59 61->1 61->1 61->10 61->50 62->1 62->58 62->58 63->56 63->56 63->57 64->25 64->46 64->62 64->62 65->59 65->59 65->67 65->68 66->1 66->60 66->60 67->1 67->66 67->66 68->67 68->67
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int T , l , n , c , i , j ; long long t ; dist a [ 1001 ] ; scanf ( "\x25\x64\x0" , & T ) ; for ( i = 0 ; i < T ; i ++ ) { double p = 0 ; int f = 0 ; scanf ( "%d %lld %d %d" , & l , & t , & n , & c ) ; for ( j = 0 ; j < c ; j ++ ) { int x ; scanf ( "%d" , & x ) ; a [ j ] . d = ( double ) x ; a [ j ] . n = n / c ; if ( j < n % c ) a [ j ] . n ++ ; } for ( j = 0 ; j < c ; j ++ ) { if ( a [ j ] . n == 0 ) { printf ( "Case #%d: %d\n" , i + 1 , ( int ) p ) ; f = 1 ; break ; } if ( p + a [ j ] . d * 2 <= t ) { p += a [ j ] . d * 2 ; a [ j ] . n -- ; } else { a [ c ] . d = a [ j ] . d - ( t - p ) / 2.0 ; a [ c ] . n = 1 ; a [ j ] . n -- ; p = t ; ; c ++ ; break ; } if ( j == c - 1 ) j = - 1 ; } if ( f == 0 ) { qsort ( a , c , sizeof ( dist ) , cmp ) ; for ( j = 0 ; j < c ; j ++ ) { if ( a [ j ] . n == 0 ) continue ; if ( l >= a [ j ] . n ) { p += a [ j ] . n * a [ j ] . d ; l -= a [ j ] . n ; } else { p += l * a [ j ] . d ; p += ( a [ j ] . n - l ) * a [ j ] . d * 2 ; l = 0 ; } } printf ( "Case #%d: %d\n" , i + 1 , ( int ) p ) ; } } return 0 ; }
>>>Func
METHOD Resolve
METHOD_RETURN void
RETURN return ; return ;
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment wp [ i ] = WP ( i , - 1 )
<operator>.assignment owp [ i ] = 0.0
<operator>.assignment divn = 0
<operator>.assignment owp [ i ] = owp [ i ] / ( double ) divn
<operator>.assignment i = 0
<operator>.assignment rpi = wp [ i ] * 0.25
<operator>.assignment oowp = 0.0
<operator>.assignment divn = 0
printf printf ( "\x25\x6c\x66\x5c\x6e\x0"   rpi + 0.5 * owp [ i ] + 0.25 * ( oowp / ( double ) divn ) )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
WP WP ( i , - 1 )
<operator>.assignment j = 0
<operator>.division owp [ i ] / ( double ) divn
<operator>.multiplication wp [ i ] * 0.25
<operator>.assignment j = 0
<operator>.notEquals m [ i ] [ j ] != '.'
<operator>.addition rpi + 0.5 * owp [ i ] + 0.25 * ( oowp / ( double ) divn )
<operator>.minus - 1
<operator>.notEquals m [ i ] [ j ] != '.'
<operator>.cast ( double ) divn
<operator>.postIncrement divn ++
<operator>.assignmentPlus oowp += owp [ j ]
<operator>.addition rpi + 0.5 * owp [ i ]
<operator>.multiplication 0.25 * ( oowp / ( double ) divn )
<operator>.assignmentPlus owp [ i ] += WP ( j , i )
<operator>.postIncrement divn ++
<operator>.multiplication 0.5 * owp [ i ]
<operator>.division oowp / ( double ) divn
<operator>.cast ( double ) divn
WP WP ( j , i )
<operator>.indirectIndexAccess wp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess wp [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess m [ i ] [ j ]
<operator>.indirectIndexAccess m [ i ] [ j ]
<operator>.indirectIndexAccess m [ i ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess m [ i ]
<operator>.indirectIndexAccess owp [ i ]
UNKNOWN double double
>>>PDG&55 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->36 0->37 0->38 0->39 0->40 2->1 3->3 3->4 3->5 3->8 3->9 3->10 3->11 3->17 3->17 3->21 3->21 3->22 3->23 3->28 3->30 3->41 3->42 3->43 3->44 3->46 4->1 4->3 5->1 5->1 5->1 5->5 5->6 5->6 5->13 5->14 5->15 5->16 5->19 5->19 5->24 5->25 5->27 5->33 5->34 5->37 5->38 5->39 5->45 5->51 5->54 6->1 6->5 7->3 8->1 8->1 8->1 8->24 9->1 9->23 9->35 10->1 10->23 10->30 10->36 11->1 11->1 11->1 11->37 12->1 12->5 13->1 13->1 13->16 13->27 13->33 14->1 14->32 14->38 15->1 15->31 15->38 15->39 16->1 16->1 17->1 17->1 17->3 17->17 17->18 17->18 17->29 17->40 17->48 17->52 18->1 18->17 19->1 19->1 19->5 19->19 19->20 19->20 19->26 19->47 19->49 20->1 20->19 21->1 21->4 21->8 21->8 21->40 22->1 22->17 23->1 23->11 23->11 24->1 24->13 24->13 25->1 25->19 26->1 26->1 26->31 26->32 26->50 27->1 27->1 28->21 29->1 29->1 29->26 29->35 29->36 29->40 29->53 30->1 31->1 31->38 31->39 32->1 32->1 32->38 33->1 33->1 34->1 34->16 34->16 34->27 34->27 35->1 35->1 35->23 36->1 36->23 36->30 37->1 37->16 37->16 37->27 37->27 37->33 37->33 38->1 38->1 38->34 38->34 39->1 40->4 40->18 40->35 40->35
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void Resolve ( ) { int divn , i , j ; double rpi , oowp ; for ( i = 0 ; i < n ; i ++ ) { wp [ i ] = WP ( i , - 1 ) ; owp [ i ] = 0.0 ; divn = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != '.' ) { owp [ i ] += WP ( j , i ) ; divn ++ ; } } owp [ i ] = owp [ i ] / ( double ) divn ; } for ( i = 0 ; i < n ; i ++ ) { rpi = wp [ i ] * 0.25 ; oowp = 0.0 ; divn = 0 ; for ( j = 0 ; j < n ; j ++ ) if ( m [ i ] [ j ] != '.' ) { divn ++ ; oowp += owp [ j ] ; } printf ( "\x25\x6c\x66\x5c\x6e\x0" , rpi + 0.5 * owp [ i ] + 0.25 * ( oowp / ( double ) divn ) ) ; } return ; }
>>>Func
METHOD try_oppose
METHOD_RETURN int
PARAM int test_case
PARAM char element
RETURN return - 1 ; return - 1 ;
<operator>.lessEqualsThan test_case_table [ test_case ] . output . element_count <= 0
<operator>.lessThan i < ( test_case_table [ test_case ] . output . element_count )
<operator>.postIncrement i ++
<operator>.minus - 1
RETURN return - 1 ; return - 1 ;
<operator>.assignment i = 0
<operator>.minus - 1
<operator>.equals check_oppose ( test_case , element , test_case_table [ test_case ] . output . element_list [ i ] ) == 0
<operator>.assignment test_case_table [ test_case ] . output . element_count = 0
RETURN return 0 ; return 0 ;
check_oppose check_oppose ( test_case , element , test_case_table [ test_case ] . output . element_list [ i ] )
LITERAL 0 return 0 ;
<operator>.fieldAccess test_case_table [ test_case ] . output . element_count
<operator>.fieldAccess test_case_table [ test_case ] . output
FIELD_IDENTIFIER element_count element_count
<operator>.indirectIndexAccess test_case_table [ test_case ]
FIELD_IDENTIFIER output output
<operator>.indirectIndexAccess test_case_table [ test_case ] . output . element_list [ i ]
<operator>.fieldAccess test_case_table [ test_case ] . output . element_count
<operator>.fieldAccess test_case_table [ test_case ] . output . element_list
<operator>.fieldAccess test_case_table [ test_case ] . output
FIELD_IDENTIFIER element_count element_count
<operator>.fieldAccess test_case_table [ test_case ] . output
FIELD_IDENTIFIER element_list element_list
<operator>.indirectIndexAccess test_case_table [ test_case ]
FIELD_IDENTIFIER output output
<operator>.indirectIndexAccess test_case_table [ test_case ]
FIELD_IDENTIFIER output output
>>>PDG&33 0->2 0->3 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 2->1 2->15 3->1 3->15 4->1 5->1 5->1 5->6 5->6 5->9 5->10 5->11 5->17 5->18 5->19 5->20 5->21 6->4 6->7 6->8 6->12 6->15 6->22 6->24 6->27 6->28 6->31 6->32 7->6 8->4 9->1 10->6 11->1 11->9 12->6 12->7 12->13 12->14 12->17 12->18 12->19 12->20 12->21 12->23 12->25 12->26 12->29 12->30 14->1 15->12 15->12 15->12 16->14
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int try_oppose ( int test_case , char element ) { int i ; if ( test_case_table [ test_case ] . output . element_count <= 0 ) { return - 1 ; } for ( i = 0 ; i < ( test_case_table [ test_case ] . output . element_count ) ; i ++ ) { if ( check_oppose ( test_case , element , test_case_table [ test_case ] . output . element_list [ i ] ) == 0 ) { test_case_table [ test_case ] . output . element_count = 0 ; return 0 ; } } return - 1 ; }
>>>Func
METHOD line_intersect
METHOD_RETURN bool
PARAM double x1
PARAM double y1
PARAM double x2
PARAM double y2
PARAM double x3
PARAM double y3
PARAM double x4
PARAM double y4
RETURN return ( ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 ) < 0 && ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 ) < 0 ) ; return ( ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 ) < 0 && ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 ) < 0 ) ;
<operator>.logicalAnd ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 ) < 0 && ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 ) < 0
<operator>.lessThan ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 ) < 0
<operator>.lessThan ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 ) < 0
<operator>.multiplication ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 )
<operator>.multiplication ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 )
ccw ccw ( x1 , y1 , x2 , y2 , x3 , y3 )
ccw ccw ( x1 , y1 , x2 , y2 , x4 , y4 )
ccw ccw ( x3 , y3 , x4 , y4 , x1 , y1 )
ccw ccw ( x3 , y3 , x4 , y4 , x2 , y2 )
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->12 0->13 0->16 0->17 0->18 0->19 2->16 3->16 4->16 5->16 6->16 7->16 8->17 9->17 10->1 11->1 11->1 11->1 11->10 12->1 12->11 12->11 12->13 12->15 12->18 12->19 13->1 13->11 13->11 14->1 14->1 14->12 14->12 15->1 15->1 15->13 15->13 16->1 16->1 16->14 16->14 16->14 16->14 16->14 16->14 16->17 16->17 16->17 16->17 16->18 16->18 17->1 17->1 17->1 17->1 17->1 17->1 17->14 17->14 17->14 17->14 17->14 17->14 17->18 17->18 17->18 17->18 17->19 17->19 18->1 18->1 18->15 18->15 18->15 18->15 18->15 18->15 18->19 18->19 18->19 18->19 19->1 19->1 19->1 19->1 19->1 19->1 19->15 19->15 19->15 19->15 19->15 19->15
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) bool line_intersect ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 , double x4 , double y4 ) { return ( ccw ( x1 , y1 , x2 , y2 , x3 , y3 ) * ccw ( x1 , y1 , x2 , y2 , x4 , y4 ) < 0 && ccw ( x3 , y3 , x4 , y4 , x1 , y1 ) * ccw ( x3 , y3 , x4 , y4 , x2 , y2 ) < 0 ) ; }
>>>Func
METHOD list_sort_internal
METHOD_RETURN ListEntry
PARAM ListEntry * * list
PARAM ListCompareFunc compare_func
<operator>.assignment pivot = * list
<operator>.assignment less_list = NULL
<operator>.assignment more_list = NULL
<operator>.assignment rover = ( * list ) -> next
<operator>.assignment less_list_end = list_sort_internal ( & less_list , compare_func )
<operator>.assignment more_list_end = list_sort_internal ( & more_list , compare_func )
<operator>.assignment * list = less_list
<operator>.assignment pivot -> next = more_list
<operator>.logicalOr list == NULL || compare_func == NULL
<operator>.logicalOr * list == NULL || ( * list ) -> next == NULL
<operator>.notEquals rover != NULL
<operator>.equals less_list == NULL
<operator>.notEquals more_list != NULL
<operator>.equals more_list == NULL
RETURN return NULL ; return NULL ;
RETURN return * list ; return * list ;
<operator>.assignment * next = rover -> next
<operator>.assignment rover = next
list_sort_internal list_sort_internal ( & less_list , compare_func )
list_sort_internal list_sort_internal ( & more_list , compare_func )
<operator>.assignment pivot -> prev = NULL
<operator>.assignment * list = pivot
<operator>.assignment more_list -> prev = pivot
RETURN return pivot ; return pivot ;
<operator>.equals list == NULL
<operator>.equals compare_func == NULL
IDENTIFIER NULL return NULL ;
<operator>.equals * list == NULL
<operator>.equals ( * list ) -> next == NULL
<operator>.lessThan compare_func ( rover -> data , pivot -> data ) < 0
<operator>.assignment pivot -> prev = less_list_end
<operator>.assignment less_list_end -> next = pivot
IDENTIFIER pivot return pivot ;
RETURN return more_list_end ; return more_list_end ;
<operator>.assignment rover -> prev = NULL
<operator>.assignment rover -> next = less_list
<operator>.assignment less_list = rover
IDENTIFIER more_list_end return more_list_end ;
compare_func compare_func ( rover -> data , pivot -> data )
<operator>.notEquals less_list != NULL
<operator>.assignment rover -> prev = NULL
<operator>.assignment rover -> next = more_list
<operator>.assignment more_list = rover
<operator>.assignment less_list -> prev = rover
<operator>.notEquals more_list != NULL
<operator>.assignment more_list -> prev = rover
<operator>.indirection * list
<operator>.indirectFieldAccess ( * list ) -> next
<operator>.indirection * list
<operator>.indirectFieldAccess pivot -> next
<operator>.indirection * list
FIELD_IDENTIFIER next next
<operator>.addressOf & less_list
<operator>.addressOf & more_list
FIELD_IDENTIFIER next next
<operator>.indirection * list
<operator>.indirectFieldAccess ( * list ) -> next
<operator>.indirection * list
<operator>.indirectFieldAccess rover -> next
<operator>.indirectFieldAccess pivot -> prev
<operator>.indirection * list
<operator>.indirectFieldAccess more_list -> prev
<operator>.indirection * list
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER prev prev
<operator>.indirectFieldAccess pivot -> prev
<operator>.indirectFieldAccess less_list_end -> next
FIELD_IDENTIFIER prev prev
<operator>.indirectFieldAccess rover -> data
<operator>.indirectFieldAccess pivot -> data
<operator>.indirectFieldAccess rover -> prev
<operator>.indirectFieldAccess rover -> next
FIELD_IDENTIFIER prev prev
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER data data
FIELD_IDENTIFIER data data
FIELD_IDENTIFIER prev prev
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess rover -> prev
<operator>.indirectFieldAccess rover -> next
<operator>.indirectFieldAccess less_list -> prev
FIELD_IDENTIFIER prev prev
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER prev prev
<operator>.indirectFieldAccess more_list -> prev
FIELD_IDENTIFIER prev prev
>>>PDG&91 0->2 0->3 0->5 0->6 0->10 0->11 0->14 0->15 0->16 0->17 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->49 2->28 3->1 3->22 3->29 4->25 4->26 4->35 4->36 5->10 5->15 5->22 5->39 5->43 6->11 6->16 6->23 6->45 6->48 7->14 8->34 9->41 12->1 12->1 12->1 12->13 12->18 12->31 12->59 13->4 13->5 13->6 13->7 13->8 13->9 13->10 13->11 13->14 13->15 13->16 13->17 13->19 13->22 13->23 13->50 13->51 13->52 13->53 13->54 13->55 13->56 13->57 13->58 13->61 14->14 14->15 14->20 14->21 14->33 14->38 14->40 14->42 14->43 14->44 14->46 14->47 14->48 14->49 14->62 14->68 14->73 14->74 14->79 14->80 15->16 15->24 15->24 15->25 15->34 15->35 15->63 15->64 15->69 15->70 15->71 15->77 15->78 16->17 16->17 16->26 16->65 16->72 17->27 17->37 18->1 19->1 20->21 21->14 22->8 22->8 22->10 22->15 22->23 23->9 23->9 23->11 23->16 23->17 27->1 28->1 28->1 28->12 28->12 28->29 28->29 28->30 28->31 29->1 29->1 29->12 29->12 29->22 29->30 29->31 30->18 31->4 31->5 31->6 31->13 31->13 31->14 31->32 31->32 31->60 31->66 31->67 32->5 32->6 32->7 32->13 32->13 32->14 33->38 33->39 33->40 33->43 33->44 33->45 33->46 33->48 33->75 33->76 33->81 33->82 33->83 33->84 33->86 33->87 36->27 37->1 39->20 40->10 40->15 40->22 40->39 40->43 41->37 42->33 42->33 43->14 43->47 43->85 43->88 45->20 46->11 46->16 46->23 46->45 46->48 48->14 48->49 48->89 48->90
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static ListEntry * list_sort_internal ( ListEntry * * list , ListCompareFunc compare_func ) { ListEntry * pivot ; ListEntry * rover ; ListEntry * less_list , * more_list ; ListEntry * less_list_end , * more_list_end ; if ( list == NULL || compare_func == NULL ) { return NULL ; } if ( * list == NULL || ( * list ) -> next == NULL ) { return * list ; } pivot = * list ; less_list = NULL ; more_list = NULL ; rover = ( * list ) -> next ; while ( rover != NULL ) { ListEntry * next = rover -> next ; if ( compare_func ( rover -> data , pivot -> data ) < 0 ) { rover -> prev = NULL ; rover -> next = less_list ; if ( less_list != NULL ) { less_list -> prev = rover ; } less_list = rover ; } else { rover -> prev = NULL ; rover -> next = more_list ; if ( more_list != NULL ) { more_list -> prev = rover ; } more_list = rover ; } rover = next ; } less_list_end = list_sort_internal ( & less_list , compare_func ) ; more_list_end = list_sort_internal ( & more_list , compare_func ) ; * list = less_list ; if ( less_list == NULL ) { pivot -> prev = NULL ; * list = pivot ; } else { pivot -> prev = less_list_end ; less_list_end -> next = pivot ; } pivot -> next = more_list ; if ( more_list != NULL ) { more_list -> prev = pivot ; } if ( more_list == NULL ) { return pivot ; } else { return more_list_end ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
scanf scanf ( "\x25\x64\x0" , & tc )
RETURN return EXIT_SUCCESS ; return EXIT_SUCCESS ;
<operator>.lessEqualsThan i <= tc
<operator>.postIncrement i ++
IDENTIFIER EXIT_SUCCESS return EXIT_SUCCESS ;
<operator>.assignment i = 1
memset memset ( R1   0   sizeof ( R1 ) )
memset memset ( R2   0   sizeof ( R2 ) )
scanf scanf ( "%d" , & x )
scanf scanf ( "%d" , & x )
scanf scanf ( "%d%s" , & x , tmp )
<operator>.assignment S [ 200 ] = { 0 }
printf printf ( "Case #%d: [" , i )
printf printf ( "]\n" )
<operator>.lessThan j < x
<operator>.postIncrement j ++
<operator>.lessThan j < x
<operator>.postIncrement j ++
<operator>.lessThan j < x
<operator>.postIncrement j ++
<operator>.lessEqualsThan j <= S [ 0 ]
<operator>.postIncrement j ++
<operator>.assignment j = 0
scanf scanf ( "%s" , tmp )
<operator>.assignment R1 [ tmp [ 0 ] + 0 ] [ tmp [ 1 ] + 0 ] = R1 [ 0 + tmp [ 1 ] ] [ 0 + tmp [ 0 ] ] = tmp [ 2 ]
<operator>.assignment j = 0
scanf scanf ( "%s" , tmp )
<operator>.assignment R2 [ 0 + tmp [ 0 ] ] [ 0 + tmp [ 1 ] ] = R2 [ 0 + tmp [ 1 ] ] [ 0 + tmp [ 0 ] ] = 1
<operator>.arrayInitializer { 0 }
<operator>.assignment j = 0
<operator>.assignment j = 1
printf printf ( "%c%s" , S [ j ] , j == S [ 0 ] ? "" : ", " )
<operator>.logicalAnd S [ 0 ] && ( d = R1 [ S [ S [ 0 ] ] ] [ 0 + tmp [ j ] ] ) > 1
<operator>.assignment R1 [ 0 + tmp [ 1 ] ] [ 0 + tmp [ 0 ] ] = tmp [ 2 ]
<operator>.assignment R2 [ 0 + tmp [ 1 ] ] [ 0 + tmp [ 0 ] ] = 1
<operator>.assignment S [ S [ 0 ] ] = d
<operator>.conditional j == S [ 0 ] ? "" : "  "
<operator>.addition tmp [ 1 ] + 0
<operator>.addition 0 + tmp [ 1 ]
<operator>.greaterThan ( d = R1 [ S [ S [ 0 ] ] ] [ 0 + tmp [ j ] ] ) > 1
<operator>.equals j == S [ 0 ]
<operator>.addition tmp [ 0 ] + 0
<operator>.addition 0 + tmp [ 0 ]
<operator>.addition 0 + tmp [ 0 ]
<operator>.addition 0 + tmp [ 0 ]
<operator>.assignment d = R1 [ S [ S [ 0 ] ] ] [ 0 + tmp [ j ] ]
IDENTIFIER k for (k = S [ 0 ] ;k;k --)
<operator>.postDecrement k --
<operator>.greaterThan k > 0
<operator>.addition 0 + tmp [ 1 ]
<operator>.addition 0 + tmp [ 1 ]
<operator>.assignment k = S [ 0 ]
<operator>.equals R2 [ S [ k ] ] [ 0 + tmp [ j ] ] == 1
<operator>.assignment S [ 0 ] = 0
<operator>.addition 0 + tmp [ j ]
<operator>.assignment S [ ++ S [ 0 ] ] = tmp [ j ]
<operator>.addition 0 + tmp [ j ]
<operator>.preIncrement ++ S [ 0 ]
<operator>.sizeOf sizeof ( R1 )
<operator>.sizeOf sizeof ( R2 )
<operator>.addressOf & x
<operator>.addressOf & x
<operator>.addressOf & x
<operator>.indirectIndexAccess S [ 0 ]
<operator>.indirectIndexAccess R1 [ tmp [ 0 ] + 0 ] [ tmp [ 1 ] + 0 ]
<operator>.indirectIndexAccess R2 [ 0 + tmp [ 0 ] ] [ 0 + tmp [ 1 ] ]
<operator>.indirectIndexAccess S [ j ]
<operator>.indirectIndexAccess R1 [ tmp [ 0 ] + 0 ]
<operator>.indirectIndexAccess R1 [ 0 + tmp [ 1 ] ] [ 0 + tmp [ 0 ] ]
<operator>.indirectIndexAccess tmp [ 2 ]
<operator>.indirectIndexAccess R2 [ 0 + tmp [ 0 ] ]
<operator>.indirectIndexAccess R2 [ 0 + tmp [ 1 ] ] [ 0 + tmp [ 0 ] ]
<operator>.indirectIndexAccess S [ 0 ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess R1 [ 0 + tmp [ 1 ] ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess R2 [ 0 + tmp [ 1 ] ]
<operator>.indirectIndexAccess S [ S [ 0 ] ]
<operator>.indirectIndexAccess S [ 0 ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess tmp [ 0 ]
<operator>.indirectIndexAccess R1 [ S [ S [ 0 ] ] ] [ 0 + tmp [ j ] ]
<operator>.indirectIndexAccess S [ 0 ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess tmp [ 1 ]
<operator>.indirectIndexAccess R1 [ S [ S [ 0 ] ] ]
<operator>.indirectIndexAccess S [ S [ 0 ] ]
<operator>.indirectIndexAccess tmp [ j ]
<operator>.indirectIndexAccess S [ 0 ]
<operator>.indirectIndexAccess R2 [ S [ k ] ] [ 0 + tmp [ j ] ]
<operator>.indirectIndexAccess S [ 0 ]
<operator>.indirectIndexAccess S [ 0 ]
<operator>.indirectIndexAccess R2 [ S [ k ] ]
<operator>.indirectIndexAccess S [ ++ S [ 0 ] ]
<operator>.indirectIndexAccess tmp [ j ]
<operator>.indirectIndexAccess S [ k ]
<operator>.indirectIndexAccess tmp [ j ]
<operator>.indirectIndexAccess S [ 0 ]
>>>PDG&104 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->53 0->54 0->56 0->57 0->58 0->60 2->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->16 6->17 6->18 6->20 6->22 6->24 6->26 6->29 6->32 6->33 6->34 6->62 6->63 6->64 6->65 6->66 6->67 7->1 7->6 8->5 9->1 9->6 10->1 10->1 11->1 11->1 12->13 12->18 12->20 13->14 13->20 13->22 14->1 14->1 14->12 14->18 14->22 15->1 15->1 15->1 15->24 15->35 15->36 15->44 15->55 15->61 16->1 16->7 17->1 18->13 18->18 18->19 18->19 18->20 18->27 18->28 18->37 18->41 18->45 18->46 18->53 18->68 18->71 18->72 18->73 18->77 18->78 18->83 18->84 18->89 19->1 19->18 20->14 20->20 20->21 20->21 20->22 20->30 20->31 20->38 20->42 20->47 20->48 20->54 20->69 20->74 20->75 20->79 20->80 20->85 20->86 20->90 21->1 21->20 22->1 22->1 22->12 22->18 22->22 22->23 22->23 22->36 22->76 23->1 23->22 24->1 24->1 24->1 24->24 24->25 24->35 24->36 24->40 24->44 24->44 24->44 24->67 24->70 24->82 25->1 25->24 26->18 27->28 27->30 27->37 27->41 27->42 27->45 27->46 27->47 27->48 27->53 27->54 28->1 28->1 28->1 29->20 30->27 30->42 30->47 30->48 30->54 31->1 31->1 31->1 32->15 33->1 33->22 34->1 34->24 35->1 35->1 35->1 36->1 36->1 36->24 36->39 36->52 36->55 36->55 36->56 36->60 36->61 36->81 36->88 36->94 36->95 36->98 36->101 36->102 37->1 37->1 37->28 38->1 38->31 39->1 39->1 39->1 40->1 43->1 43->36 43->36 44->24 44->25 46->1 48->1 49->1 49->1 49->39 49->43 51->1 51->52 52->1 52->1 52->57 52->59 52->61 52->96 52->99 52->100 52->103 53->1 54->1 55->1 55->51 55->52 56->1 56->1 56->51 56->56 56->60 56->95 56->98 56->101 56->102 57->1 57->24 57->36 58->1 59->1 59->1 59->1 60->1 61->24 61->36 76->43 76->49 76->58 76->87 76->91 76->92 76->93 76->97
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( int argc , char * argv [ ] ) { int i , tc , j , k ; scanf ( "\x25\x64\x0" , & tc ) ; for ( i = 1 ; i <= tc ; i ++ ) { memset ( R1 , 0 , sizeof ( R1 ) ) ; memset ( R2 , 0 , sizeof ( R2 ) ) ; int x ; char tmp [ 120 ] ; scanf ( "%d" , & x ) ; for ( j = 0 ; j < x ; j ++ ) { scanf ( "%s" , tmp ) ; R1 [ tmp [ 0 ] + 0 ] [ tmp [ 1 ] + 0 ] = R1 [ 0 + tmp [ 1 ] ] [ 0 + tmp [ 0 ] ] = tmp [ 2 ] ; } scanf ( "%d" , & x ) ; for ( j = 0 ; j < x ; j ++ ) { scanf ( "%s" , tmp ) ; R2 [ 0 + tmp [ 0 ] ] [ 0 + tmp [ 1 ] ] = R2 [ 0 + tmp [ 1 ] ] [ 0 + tmp [ 0 ] ] = 1 ; } scanf ( "%d%s" , & x , tmp ) ; int S [ 200 ] = { 0 } , d ; for ( j = 0 ; j < x ; j ++ ) { if ( S [ 0 ] && ( d = R1 [ S [ S [ 0 ] ] ] [ 0 + tmp [ j ] ] ) > 1 ) { S [ S [ 0 ] ] = d ; } else { for ( k = S [ 0 ] ; k ; k -- ) if ( R2 [ S [ k ] ] [ 0 + tmp [ j ] ] == 1 ) break ; if ( k > 0 ) S [ 0 ] = 0 ; else S [ ++ S [ 0 ] ] = tmp [ j ] ; } } printf ( "Case #%d: [" , i ) ; for ( j = 1 ; j <= S [ 0 ] ; j ++ ) { printf ( "%c%s" , S [ j ] , j == S [ 0 ] ? "" : ", " ) ; } printf ( "]\n" ) ; } return EXIT_SUCCESS ; }
>>>Func
METHOD try_link
METHOD_RETURN int
PARAM char * dest
PARAM void * arg
<operator>.assignment * a = arg
RETURN return linkat ( a -> srcdir , a -> srcname , a -> dstdir , dest , a -> flags ) ; return linkat ( a -> srcdir , a -> srcname , a -> dstdir , dest , a -> flags ) ;
linkat linkat ( a -> srcdir , a -> srcname , a -> dstdir , dest , a -> flags )
>>>PDG&7 0->2 0->3 0->4 0->6 2->6 3->4 4->1 4->1 4->1 5->1 6->1 6->1 6->1 6->1 6->1 6->1 6->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static int try_link ( char * dest , void * arg ) { struct link_arg * a = arg ; return linkat ( a -> srcdir , a -> srcname , a -> dstdir , dest , a -> flags ) ; }
>>>Func
METHOD new_adaline
METHOD_RETURN struct adaline
PARAM const int num_features
PARAM const double eta
<operator>.assignment num_weights = num_features + 1
<operator>.assignment ada . eta = eta
<operator>.assignment ada . num_weights = num_weights
<operator>.assignment ada . weights = ( double * ) malloc ( num_weights * sizeof ( double ) )
RETURN return ada ; return ada ;
<operator>.logicalOr eta <= 0.f || eta >= 1.f
<operator>.logicalNot ! ada . weights
<operator>.lessThan i < num_weights
<operator>.postIncrement i ++
<operator>.assignment ada . weights [ i ] = 1.f
IDENTIFIER ada return ada ;
fprintf fprintf ( stderr , "\x6c\x65\x61\x72\x6e\x69\x6e\x67\x20\x72\x61\x74\x65\x20\x73\x68\x6f\x75\x6c\x64\x20\x62\x65\x20\x3e\x20\x30\x20\x61\x6e\x64\x20\x3c\x20\x31\x5c\x6e\x0" )
exit exit ( EXIT_FAILURE )
<operator>.addition num_features + 1
<operator>.cast ( double * ) malloc ( num_weights * sizeof ( double ) )
perror perror ( "Unable to allocate error for weights!" )
RETURN return ada ; return ada ;
<operator>.assignment i = 0
<operator>.lessEqualsThan eta <= 0.f
<operator>.greaterEqualsThan eta >= 1.f
malloc malloc ( num_weights * sizeof ( double ) )
IDENTIFIER ada return ada ;
<operator>.multiplication num_weights * sizeof ( double )
<operator>.sizeOf sizeof ( double )
<operator>.indirectIndexAccess ada . weights [ i ]
<operator>.fieldAccess ada . weights
FIELD_IDENTIFIER weights weights
>>>PDG&31 0->2 0->3 0->4 0->5 0->6 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->21 0->22 0->23 0->25 0->26 2->4 2->17 3->22 4->1 4->1 4->6 4->26 5->1 5->1 5->1 5->14 5->25 6->1 6->1 6->14 6->25 7->1 7->1 7->10 8->1 9->1 9->1 9->1 9->15 9->16 10->1 10->1 10->8 10->11 10->14 10->19 10->20 10->21 10->25 11->11 11->12 11->12 11->13 11->28 11->29 11->30 12->11 14->8 15->1 15->1 16->1 17->1 18->1 19->1 20->1 21->11 22->5 22->9 22->9 22->23 22->23 23->5 23->9 23->9 24->1 24->7 24->18 25->20 26->1 26->11 26->24 27->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) struct adaline new_adaline ( const int num_features , const double eta ) { if ( eta <= 0.f || eta >= 1.f ) { fprintf ( stderr , "\x6c\x65\x61\x72\x6e\x69\x6e\x67\x20\x72\x61\x74\x65\x20\x73\x68\x6f\x75\x6c\x64\x20\x62\x65\x20\x3e\x20\x30\x20\x61\x6e\x64\x20\x3c\x20\x31\x5c\x6e\x0" ) ; exit ( EXIT_FAILURE ) ; } int num_weights = num_features + 1 ; struct adaline ada ; ada . eta = eta ; ada . num_weights = num_weights ; ada . weights = ( double * ) malloc ( num_weights * sizeof ( double ) ) ; if ( ! ada . weights ) { perror ( "Unable to allocate error for weights!" ) ; return ada ; } for ( int i = 0 ; i < num_weights ; i ++ ) ada . weights [ i ] = 1.f ; return ada ; }
>>>Func
METHOD initialize
METHOD_RETURN void
PARAM int combine [ ] [ 26 ]
PARAM int oppose [ ] [ 26 ]
<operator>.lessThan i < 26
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.lessThan j < 26
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment combine [ i ] [ j ] = - 1
<operator>.assignment oppose [ i ] [ j ] = - 1
<operator>.minus - 1
<operator>.minus - 1
<operator>.indirectIndexAccess combine [ i ] [ j ]
<operator>.indirectIndexAccess oppose [ i ] [ j ]
<operator>.indirectIndexAccess combine [ i ]
<operator>.indirectIndexAccess oppose [ i ]
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->12 0->13 2->1 3->1 4->1 4->1 4->4 4->5 4->5 4->7 4->9 5->1 5->4 6->1 6->4 7->7 7->8 7->8 7->10 7->11 7->12 7->13 7->14 7->15 7->16 7->17 8->7 9->7 12->10 13->11
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) static void initialize ( int combine [ ] [ 26 ] , int oppose [ ] [ 26 ] ) { int i , j ; for ( i = 0 ; i < 26 ; i ++ ) { for ( j = 0 ; j < 26 ; j ++ ) { combine [ i ] [ j ] = - 1 ; oppose [ i ] [ j ] = - 1 ; } } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM const char * argv [ ]
srand srand ( time ( NULL ) )
test test ( )
RETURN return 0 ; return 0 ;
LITERAL 0 return 0 ;
time time ( NULL )
>>>PDG&9 0->2 0->3 0->5 0->6 0->7 0->8 2->1 3->1 4->1 4->1 5->1 6->1 7->6 8->1 8->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , const char * argv [ ] ) { srand ( time ( NULL ) ) ; test ( ) ; return 0 ; }
>>>Func
METHOD sort
METHOD_RETURN void
PARAM int * a
PARAM int n
<operator>.logicalNot ! check_sorted ( a , n )
shuffle shuffle ( a , n )
check_sorted check_sorted ( a , n )
>>>PDG&7 0->2 0->3 0->5 0->6 2->6 3->6 4->1 4->1 4->4 4->5 4->6 6->1 6->1 6->4 6->4 6->5 6->5
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void sort ( int * a , int n ) { while ( ! check_sorted ( a , n ) ) shuffle ( a , n ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int argc
PARAM char * argv [ ]
<operator>.assignment big = a [ 0 ]
printf printf ( "\x4c\x61\x72\x67\x65\x73\x74\x20\x65\x6c\x65\x6d\x65\x6e\x74\x3a\x20\x25\x64\x5c\x6e\x0" , big )
<operator>.assignment small = a [ 0 ]
printf printf ( "Smallest element: %d\n" , small )
RETURN return 0 ; return 0 ;
<operator>.lessThan argc < 11
<operator>.lessThan i < argc
<operator>.postIncrement i ++
<operator>.assignment a [ i - 1 ] = argv [ i ] [ 0 ]
<operator>.lessThan i < argc - 1
<operator>.postIncrement i ++
<operator>.lessThan i < argc - 1
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
RETURN return 1 ; return 1 ;
<operator>.assignment i = 1
<operator>.assignment i = 1
<operator>.assignment i = 1
LITERAL 1 return 1 ;
<operator>.subtraction argc - 1
<operator>.lessThan big < a [ i ]
<operator>.subtraction argc - 1
<operator>.greaterThan small > a [ i ]
<operator>.subtraction i - 1
<operator>.assignment big = a [ i ]
<operator>.assignment small = a [ i ]
<operator>.indirectIndexAccess a [ 0 ]
<operator>.indirectIndexAccess a [ 0 ]
<operator>.indirectIndexAccess a [ i - 1 ]
<operator>.indirectIndexAccess argv [ i ] [ 0 ]
<operator>.indirectIndexAccess argv [ i ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess a [ i ]
<operator>.indirectIndexAccess a [ i ]
>>>PDG&39 0->2 0->3 0->5 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->9 3->1 4->5 4->24 6->7 6->26 8->1 9->1 9->1 9->4 9->5 9->6 9->7 9->8 9->10 9->10 9->13 9->15 9->18 9->19 9->20 9->21 9->23 9->25 9->30 9->31 10->10 10->11 10->12 10->23 10->27 10->27 10->32 10->33 10->34 11->10 13->13 13->14 13->14 13->23 13->24 13->35 14->13 15->15 15->16 15->16 15->25 15->26 15->36 16->15 17->8 18->1 19->10 20->13 21->15 22->18 23->13 23->13 23->25 24->5 24->26 24->28 24->28 24->37 25->15 25->15 26->7 26->29 26->29 26->38 27->11 28->5 28->24 29->7 29->26
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( int argc , char * argv [ ] ) { if ( argc < 11 ) return 1 ; int a [ 10 ] , i , big , small ; for ( i = 1 ; i < argc ; i ++ ) a [ i - 1 ] = argv [ i ] [ 0 ] ; big = a [ 0 ] ; for ( i = 1 ; i < argc - 1 ; i ++ ) { if ( big < a [ i ] ) big = a [ i ] ; } printf ( "\x4c\x61\x72\x67\x65\x73\x74\x20\x65\x6c\x65\x6d\x65\x6e\x74\x3a\x20\x25\x64\x5c\x6e\x0" , big ) ; small = a [ 0 ] ; for ( i = 1 ; i < argc - 1 ; i ++ ) { if ( small > a [ i ] ) small = a [ i ] ; } printf ( "Smallest element: %d\n" , small ) ; return 0 ; }
>>>Func
METHOD sort_string
METHOD_RETURN void
PARAM char string [ 200 ] [ 4 ]
PARAM int n
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 1
strcpy strcpy ( x , string [ i ] )
strcpy strcpy ( string [ j + 1 ] , x )
<operator>.greaterEqualsThan j >= 0
<operator>.postDecrement j --
<operator>.assignment j = i - 1
<operator>.greaterThan strcmp ( string [ j ] , x ) > 0
<operator>.addition j + 1
<operator>.subtraction i - 1
strcpy strcpy ( string [ j + 1 ] , string [ j ] )
strcmp strcmp ( string [ j ] , x )
<operator>.addition j + 1
<operator>.indirectIndexAccess string [ i ]
<operator>.indirectIndexAccess string [ j + 1 ]
<operator>.indirectIndexAccess string [ j ]
<operator>.indirectIndexAccess string [ j + 1 ]
<operator>.indirectIndexAccess string [ j ]
>>>PDG&23 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->16 0->17 2->1 2->7 2->8 2->15 2->16 3->4 4->1 4->1 4->1 4->4 4->5 4->7 4->8 4->9 4->11 4->13 4->14 4->14 4->18 4->19 5->1 5->4 6->1 6->4 7->8 7->16 8->7 8->15 9->10 9->12 9->13 9->16 9->17 9->20 10->9 11->9 12->9 12->10 12->15 12->17 12->21 12->22 14->5 14->11 14->11 15->8 15->16 16->8 16->12 16->12 16->15
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void sort_string ( char string [ 200 ] [ 4 ] , int n ) { int i , j ; char s [ 4 ] , x [ 4 ] ; for ( i = 1 ; i < n ; i ++ ) { strcpy ( x , string [ i ] ) ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( strcmp ( string [ j ] , x ) > 0 ) strcpy ( string [ j + 1 ] , string [ j ] ) ; else break ; } strcpy ( string [ j + 1 ] , x ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan i <= T
<operator>.postIncrement i ++
testcase testcase ( i )
LITERAL 0 return 0 ;
<operator>.assignment i = 1
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->6 4->6 5->1 5->4 6->1 6->5 7->3 8->1 8->4
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int main ( ) { int T , i ; scanf ( "\x25\x64\x0" , & T ) ; for ( i = 1 ; i <= T ; i ++ ) testcase ( i ) ; return 0 ; }
>>>Func
METHOD lerp_precise
METHOD_RETURN float
PARAM int k0
PARAM int k1
PARAM float t
RETURN return ( 1 - t ) * k0 + t * k1 ; return ( 1 - t ) * k0 + t * k1 ;
<operator>.addition ( 1 - t ) * k0 + t * k1
<operator>.multiplication ( 1 - t ) * k0
<operator>.multiplication t * k1
<operator>.subtraction 1 - t
>>>PDG&10 0->2 0->3 0->4 0->7 0->8 0->9 2->7 3->8 4->9 5->1 6->1 6->1 6->1 6->5 7->1 7->1 7->6 7->6 8->1 8->1 8->6 8->6 9->7 9->7 9->8
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) float lerp_precise ( int k0 , int k1 , float t ) { return ( 1 - t ) * k0 + t * k1 ; }
>>>Func
METHOD clear
METHOD_RETURN void
<operator>.assignment p = 0
<operator>.assignment q = 0
<operator>.lessThan q < d
<operator>.postIncrement q ++
<operator>.assignment q = 0
<operator>.lessThan r < n
<operator>.postIncrement r ++
<operator>.assignment r = 0
<operator>.equals opp [ q ] [ 0 ] == str [ n ]
<operator>.equals str [ r ] == opp [ q ] [ 1 ]
<operator>.assignment n = - 1
<operator>.equals opp [ q ] [ 1 ] == str [ n ]
<operator>.minus - 1
<operator>.equals str [ r ] == opp [ q ] [ 0 ]
<operator>.assignment n = - 1
<operator>.minus - 1
<operator>.indirectIndexAccess opp [ q ] [ 0 ]
<operator>.indirectIndexAccess str [ n ]
<operator>.indirectIndexAccess opp [ q ]
<operator>.indirectIndexAccess str [ r ]
<operator>.indirectIndexAccess opp [ q ] [ 1 ]
<operator>.indirectIndexAccess opp [ q ]
<operator>.indirectIndexAccess opp [ q ] [ 1 ]
<operator>.indirectIndexAccess str [ n ]
<operator>.indirectIndexAccess opp [ q ]
<operator>.indirectIndexAccess str [ r ]
<operator>.indirectIndexAccess opp [ q ] [ 0 ]
<operator>.indirectIndexAccess opp [ q ]
>>>PDG&30 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->14 0->17 2->1 2->1 4->1 4->1 4->1 4->4 4->5 4->5 4->7 4->9 5->1 5->4 6->1 6->4 7->1 7->1 7->1 7->7 7->8 7->8 7->10 7->18 7->19 7->20 8->1 8->7 9->1 9->7 10->1 10->1 10->1 10->11 10->13 10->13 10->15 10->21 10->22 10->23 10->24 10->25 10->26 11->1 11->1 11->1 11->12 11->13 11->14 11->15 12->1 12->1 12->7 13->1 13->1 13->1 13->10 13->11 13->15 13->27 13->28 13->29 14->12 15->1 15->1 15->1 15->10 15->11 15->16 15->17 16->1 16->1 16->7 17->16
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void clear ( ) { int p = 0 , q = 0 , r , s ; for ( q = 0 ; q < d ; q ++ ) { for ( r = 0 ; r < n ; r ++ ) { if ( opp [ q ] [ 0 ] == str [ n ] ) { if ( str [ r ] == opp [ q ] [ 1 ] ) n = - 1 ; } else if ( opp [ q ] [ 1 ] == str [ n ] ) { if ( str [ r ] == opp [ q ] [ 0 ] ) n = - 1 ; } } } }
>>>Func
METHOD fill_happy
METHOD_RETURN void
PARAM int base
memset memset ( happy   0   sizeof ( happy ) )
<operator>.assignment happy [ 1 ] = 1
<operator>.lessEqualsThan i <= N
<operator>.preIncrement ++ i
<operator>.assignment i = 2
<operator>.assignment ni = i
<operator>.assignment sp = 0
<operator>.assignment nv = happy [ ni ] == 2 ? - 1 : happy [ ni ]
<operator>.equals happy [ ni ] == 0
<operator>.greaterThan sp > 0
<operator>.assignment happy [ stack [ -- sp ] ] = nv
<operator>.assignment stack [ sp ++ ] = ni
<operator>.assignment happy [ ni ] = 2
<operator>.assignment ni = next_step ( ni , base )
<operator>.conditional happy [ ni ] == 2 ? - 1 : happy [ ni ]
<operator>.equals happy [ ni ] == 2
<operator>.minus - 1
next_step next_step ( ni , base )
<operator>.postIncrement sp ++
<operator>.preDecrement -- sp
<operator>.indirectIndexAccess happy [ ni ]
<operator>.indirectIndexAccess happy [ ni ]
<operator>.indirectIndexAccess happy [ stack [ -- sp ] ]
<operator>.indirectIndexAccess stack [ sp ++ ]
<operator>.indirectIndexAccess happy [ ni ]
<operator>.indirectIndexAccess happy [ ni ]
<operator>.indirectIndexAccess stack [ -- sp ]
>>>PDG&30 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->18 0->19 0->20 0->21 0->22 2->1 2->20 3->1 3->1 3->10 3->11 3->17 3->18 4->1 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->8 5->8 5->9 5->10 5->11 5->12 5->17 5->18 5->23 5->28 6->1 6->5 7->1 7->5 8->14 8->20 9->12 9->21 10->13 11->11 11->14 11->15 11->16 11->18 11->20 11->21 11->23 11->26 11->27 12->12 12->13 12->22 12->22 12->25 12->29 15->11 16->14 16->20 18->10 18->11 18->17 18->19 18->24 19->10 19->17 20->16 20->16 21->12 22->12
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void fill_happy ( int base ) { int i ; memset ( happy , 0 , sizeof ( happy ) ) ; happy [ 1 ] = 1 ; for ( i = 2 ; i <= N ; ++ i ) { int ni = i , sp = 0 ; while ( happy [ ni ] == 0 ) { stack [ sp ++ ] = ni ; happy [ ni ] = 2 ; ni = next_step ( ni , base ) ; } int nv = happy [ ni ] == 2 ? - 1 : happy [ ni ] ; while ( sp > 0 ) happy [ stack [ -- sp ] ] = nv ; } }
>>>Func
METHOD down_heapify
METHOD_RETURN void
PARAM Heap * heap
PARAM int index
<operator>.assignment left = index * 2 + 1
<operator>.assignment right = index * 2 + 2
<operator>.assignment leftflag = 0
<operator>.assignment rightflag = 0
<operator>.assignment minimum = * ( ( heap -> p ) + index )
<operator>.greaterEqualsThan index >= heap -> count
<operator>.logicalAnd left < heap -> count && minimum > * ( ( heap -> p ) + left )
<operator>.logicalAnd right < heap -> count && minimum > * ( ( heap -> p ) + right )
IDENTIFIER leftflag if (leftflag)
IDENTIFIER rightflag if (rightflag)
RETURN return ; return ;
<operator>.addition index * 2 + 1
<operator>.addition index * 2 + 2
<operator>.assignment minimum = * ( ( heap -> p ) + left )
<operator>.assignment leftflag = 1
<operator>.assignment minimum = * ( ( heap -> p ) + right )
<operator>.assignment leftflag = 0
<operator>.assignment rightflag = 1
<operator>.assignment * ( ( heap -> p ) + left ) = * ( ( heap -> p ) + index )
<operator>.assignment * ( ( heap -> p ) + index ) = minimum
down_heapify down_heapify ( heap , left )
<operator>.assignment * ( ( heap -> p ) + right ) = * ( ( heap -> p ) + index )
<operator>.assignment * ( ( heap -> p ) + index ) = minimum
down_heapify down_heapify ( heap , right )
<operator>.multiplication index * 2
<operator>.multiplication index * 2
<operator>.addition ( heap -> p ) + index
<operator>.lessThan left < heap -> count
<operator>.greaterThan minimum > * ( ( heap -> p ) + left )
<operator>.lessThan right < heap -> count
<operator>.greaterThan minimum > * ( ( heap -> p ) + right )
<operator>.addition ( heap -> p ) + left
<operator>.addition ( heap -> p ) + left
<operator>.addition ( heap -> p ) + right
<operator>.addition ( heap -> p ) + right
<operator>.addition ( heap -> p ) + left
<operator>.addition ( heap -> p ) + index
<operator>.addition ( heap -> p ) + index
<operator>.addition ( heap -> p ) + right
<operator>.addition ( heap -> p ) + index
<operator>.addition ( heap -> p ) + index
<operator>.indirection * ( ( heap -> p ) + index )
<operator>.indirectFieldAccess heap -> p
<operator>.indirectFieldAccess heap -> count
<operator>.indirection * ( ( heap -> p ) + left )
<operator>.indirection * ( ( heap -> p ) + left )
<operator>.indirectFieldAccess heap -> count
<operator>.indirection * ( ( heap -> p ) + right )
<operator>.indirection * ( ( heap -> p ) + right )
<operator>.indirection * ( ( heap -> p ) + left )
<operator>.indirection * ( ( heap -> p ) + index )
<operator>.indirection * ( ( heap -> p ) + index )
<operator>.indirection * ( ( heap -> p ) + right )
<operator>.indirection * ( ( heap -> p ) + index )
<operator>.indirection * ( ( heap -> p ) + index )
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER count count
FIELD_IDENTIFIER count count
<operator>.indirectFieldAccess heap -> p
<operator>.indirectFieldAccess heap -> p
<operator>.indirectFieldAccess heap -> p
<operator>.indirectFieldAccess heap -> p
<operator>.indirectFieldAccess heap -> p
<operator>.indirectFieldAccess heap -> p
<operator>.indirectFieldAccess heap -> p
<operator>.indirectFieldAccess heap -> p
<operator>.indirectFieldAccess heap -> p
<operator>.indirectFieldAccess heap -> p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
>>>PDG&82 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->12 0->13 0->14 0->15 0->16 0->18 0->20 0->21 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 2->1 2->24 2->27 3->9 4->31 5->33 8->23 8->26 8->32 8->34 9->1 9->1 9->1 9->4 9->5 9->6 9->7 9->8 9->10 9->11 9->14 9->15 9->16 9->22 9->23 9->24 9->25 9->26 9->27 9->28 9->28 9->29 9->30 9->31 9->31 9->33 9->39 9->40 9->41 9->42 9->43 9->44 9->45 9->46 9->47 9->50 9->53 9->54 9->55 9->56 9->57 9->58 9->59 9->60 9->61 9->66 9->67 9->68 9->69 9->70 9->71 9->76 9->77 9->78 9->79 9->80 9->81 10->17 10->18 10->36 10->49 10->63 10->73 11->19 11->20 11->21 11->38 11->52 11->65 11->75 14->1 17->23 17->26 17->34 19->23 19->26 24->27 28->4 28->4 28->15 28->15 28->29 29->5 29->5 29->16 29->16 29->30 29->40 29->41 29->43 29->44 31->10 31->10 31->24 31->32 31->33 31->35 31->35 31->36 31->39 31->48 31->62 31->72 32->10 32->10 32->23 32->26 32->34 33->11 33->11 33->27 33->34 33->37 33->37 33->38 33->42 33->51 33->64 33->74 34->11 34->11 34->23 34->26
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void down_heapify ( Heap * heap , int index ) { if ( index >= heap -> count ) return ; int left = index * 2 + 1 ; int right = index * 2 + 2 ; int leftflag = 0 , rightflag = 0 ; int minimum = * ( ( heap -> p ) + index ) ; if ( left < heap -> count && minimum > * ( ( heap -> p ) + left ) ) { minimum = * ( ( heap -> p ) + left ) ; leftflag = 1 ; } if ( right < heap -> count && minimum > * ( ( heap -> p ) + right ) ) { minimum = * ( ( heap -> p ) + right ) ; leftflag = 0 ; rightflag = 1 ; } if ( leftflag ) { * ( ( heap -> p ) + left ) = * ( ( heap -> p ) + index ) ; * ( ( heap -> p ) + index ) = minimum ; down_heapify ( heap , left ) ; } if ( rightflag ) { * ( ( heap -> p ) + right ) = * ( ( heap -> p ) + index ) ; * ( ( heap -> p ) + index ) = minimum ; down_heapify ( heap , right ) ; } }
>>>Func
METHOD combine
METHOD_RETURN void
PARAM char * output
PARAM char c
PARAM char * * combinematrix
PARAM int present [ ]
<operator>.assignment len = strlen ( output )
<operator>.assignment last = output [ len - 1 ]
<operator>.assignment n = combinematrix [ getBaseIndex ( c ) ] [ getBaseIndex ( last ) ]
<operator>.assignment output [ len - 1 ] = n
<operator>.postDecrement present [ getBaseIndex ( last ) ] --
RETURN return ; return ;
<operator>.logicalOr ! isBase ( last ) || combinematrix [ getBaseIndex ( c ) ] [ getBaseIndex ( last ) ] == 0
strlen strlen ( output )
<operator>.assignment output = realloc ( output   ( len + 2 ) * sizeof ( char ) )
<operator>.assignment output [ len ] = c
<operator>.assignment output [ len + 1 ] = 0
RETURN return ; return ;
<operator>.subtraction len - 1
<operator>.logicalNot ! isBase ( last )
<operator>.equals combinematrix [ getBaseIndex ( c ) ] [ getBaseIndex ( last ) ] == 0
isBase isBase ( c )
getBaseIndex getBaseIndex ( last )
<operator>.subtraction len - 1
getBaseIndex getBaseIndex ( last )
isBase isBase ( last )
realloc realloc ( output   ( len + 2 ) * sizeof ( char ) )
<operator>.postIncrement present [ getBaseIndex ( c ) ] ++
getBaseIndex getBaseIndex ( c )
getBaseIndex getBaseIndex ( last )
<operator>.multiplication ( len + 2 ) * sizeof ( char )
<operator>.addition len + 1
getBaseIndex getBaseIndex ( c )
<operator>.addition len + 2
<operator>.sizeOf sizeof ( char )
getBaseIndex getBaseIndex ( c )
<operator>.indirectIndexAccess combinematrix [ getBaseIndex ( c ) ] [ getBaseIndex ( last ) ]
<operator>.indirectIndexAccess output [ len - 1 ]
<operator>.indirectIndexAccess present [ getBaseIndex ( last ) ]
<operator>.indirectIndexAccess combinematrix [ getBaseIndex ( c ) ]
<operator>.indirectIndexAccess combinematrix [ getBaseIndex ( c ) ] [ getBaseIndex ( last ) ]
<operator>.indirectIndexAccess output [ len ]
<operator>.indirectIndexAccess output [ len + 1 ]
<operator>.indirectIndexAccess combinematrix [ getBaseIndex ( c ) ]
<operator>.indirectIndexAccess present [ getBaseIndex ( c ) ]
>>>PDG&45 0->2 0->3 0->4 0->5 0->9 0->11 0->13 0->15 0->16 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->28 0->29 0->30 0->31 0->32 0->33 0->35 2->13 3->15 3->21 3->28 3->32 4->1 5->1 5->10 5->27 6->1 6->1 6->18 7->1 7->1 7->25 8->9 11->1 12->1 12->1 12->1 12->8 12->9 12->10 12->11 12->14 12->15 12->16 12->17 12->21 12->22 12->23 12->24 12->26 12->28 12->30 12->31 12->33 12->34 12->36 12->37 12->38 12->39 12->41 12->42 13->6 13->7 13->26 14->1 14->1 14->1 15->1 15->1 16->1 16->1 17->1 18->23 18->30 18->31 18->33 19->1 19->12 19->20 19->29 19->32 19->40 19->43 20->1 20->8 20->12 20->12 21->1 21->1 21->27 21->35 21->35 21->44 22->24 25->1 25->19 25->22 25->29 26->1 26->14 26->14 27->1 27->1 29->1 29->22 30->1 30->26 31->1 32->15 32->21 32->28 34->1 35->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void combine ( char * output , char c , char * * combinematrix , int present [ ] ) { int len = strlen ( output ) ; char last = output [ len - 1 ] ; if ( ! isBase ( last ) || combinematrix [ getBaseIndex ( c ) ] [ getBaseIndex ( last ) ] == 0 ) { output = realloc ( output , ( len + 2 ) * sizeof ( char ) ) ; output [ len ] = c ; output [ len + 1 ] = 0 ; if ( isBase ( c ) ) present [ getBaseIndex ( c ) ] ++ ; return ; } char n = combinematrix [ getBaseIndex ( c ) ] [ getBaseIndex ( last ) ] ; output [ len - 1 ] = n ; present [ getBaseIndex ( last ) ] -- ; return ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x69\x0" , & t )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan test <= t
<operator>.postIncrement test ++
LITERAL 0 return 0 ;
<operator>.assignment test = 1
memset memset ( games   0   sizeof ( games ) )
memset memset ( wins   0   sizeof ( wins ) )
scanf scanf ( "%i\n" , & n )
printf printf ( "Case #%i:\n" , test )
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.lessThan i < n
<operator>.postIncrement i ++
<operator>.assignment i = 0
<operator>.assignment i = 0
<operator>.assignment total_wins [ i ] = total_games [ i ] = 0
<operator>.assignment i = 0
<operator>.assignment count = 0
<operator>.assignment owp [ i ] = 0
<operator>.assignmentDivision owp [ i ] /= count
<operator>.assignment i = 0
<operator>.assignment count = 0
<operator>.assignment oowp [ i ] = 0
<operator>.assignmentDivision oowp [ i ] /= count
<operator>.assignment i = 0
printf printf ( "%.6lf\n"   0.25 * ( ( double ) total_wins [ i ] / total_games [ i ] ) + 0.50 * owp [ i ] + 0.25 * oowp [ i ] )
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.lessThan j < n
<operator>.postIncrement j ++
<operator>.assignment j = 0
<operator>.assignment c = getchar ( )
<operator>.assignment total_games [ i ] = 0
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.assignment j = 0
<operator>.addition 0.25 * ( ( double ) total_wins [ i ] / total_games [ i ] ) + 0.50 * owp [ i ] + 0.25 * oowp [ i ]
<operator>.logicalOr c == '0' || c == '1'
<operator>.notEquals j != n
<operator>.logicalAnd i != j && games [ j ] [ i ]
<operator>.logicalAnd i != j && games [ j ] [ i ]
<operator>.addition 0.25 * ( ( double ) total_wins [ i ] / total_games [ i ] ) + 0.50 * owp [ i ]
<operator>.multiplication 0.25 * oowp [ i ]
<operator>.postIncrement games [ i ] [ j ] ++
<operator>.assignmentPlus total_wins [ i ] += wins [ i ] [ j ]
<operator>.assignmentPlus total_games [ i ] += games [ i ] [ j ]
<operator>.postIncrement count ++
<operator>.assignmentPlus owp [ i ] += ( double ) ( total_wins [ j ] - wins [ j ] [ i ] ) / ( total_games [ j ] - games [ j ] [ i ] )
<operator>.postIncrement count ++
<operator>.assignmentPlus oowp [ i ] += owp [ j ]
<operator>.multiplication 0.25 * ( ( double ) total_wins [ i ] / total_games [ i ] )
<operator>.multiplication 0.50 * owp [ i ]
<operator>.equals c == '0'
<operator>.equals c == '1'
<operator>.equals c == '1'
assert assert ( c == '.' )
<operator>.notEquals i != j
<operator>.notEquals i != j
<operator>.division ( double ) total_wins [ i ] / total_games [ i ]
<operator>.postIncrement wins [ i ] [ j ] ++
<operator>.division ( double ) ( total_wins [ j ] - wins [ j ] [ i ] ) / ( total_games [ j ] - games [ j ] [ i ] )
<operator>.cast ( double ) total_wins [ i ]
<operator>.equals c == '.'
<operator>.cast ( double ) ( total_wins [ j ] - wins [ j ] [ i ] )
<operator>.subtraction total_games [ j ] - games [ j ] [ i ]
<operator>.subtraction total_wins [ j ] - wins [ j ] [ i ]
<operator>.sizeOf sizeof ( games )
<operator>.sizeOf sizeof ( wins )
<operator>.addressOf & n
scanf scanf ( "\n" )
<operator>.indirectIndexAccess total_wins [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess total_games [ i ]
getchar getchar ( )
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess games [ j ] [ i ]
<operator>.indirectIndexAccess games [ j ] [ i ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess games [ i ] [ j ]
<operator>.indirectIndexAccess total_wins [ i ]
<operator>.indirectIndexAccess wins [ i ] [ j ]
<operator>.indirectIndexAccess total_games [ i ]
<operator>.indirectIndexAccess games [ i ] [ j ]
<operator>.indirectIndexAccess games [ j ]
<operator>.indirectIndexAccess owp [ i ]
<operator>.indirectIndexAccess games [ j ]
<operator>.indirectIndexAccess oowp [ i ]
<operator>.indirectIndexAccess owp [ j ]
<operator>.indirectIndexAccess total_games [ i ]
<operator>.indirectIndexAccess games [ i ]
<operator>.indirectIndexAccess wins [ i ]
<operator>.indirectIndexAccess games [ i ]
UNKNOWN double double
<operator>.indirectIndexAccess total_wins [ i ]
<operator>.indirectIndexAccess wins [ i ] [ j ]
UNKNOWN double double
<operator>.indirectIndexAccess total_games [ j ]
<operator>.indirectIndexAccess games [ j ] [ i ]
<operator>.indirectIndexAccess wins [ i ]
<operator>.indirectIndexAccess total_wins [ j ]
<operator>.indirectIndexAccess wins [ j ] [ i ]
<operator>.indirectIndexAccess games [ j ]
<operator>.indirectIndexAccess wins [ j ]
>>>PDG&119 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->51 0->55 0->59 0->61 0->63 0->64 0->65 0->66 0->67 0->69 0->70 0->75 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->11 4->12 4->14 4->16 4->18 4->20 4->22 4->23 4->25 4->29 4->33 4->79 4->80 4->81 5->1 5->4 6->3 7->1 7->4 8->1 8->1 9->1 9->1 10->1 10->12 10->14 10->16 10->18 10->20 10->35 10->37 10->39 10->41 10->51 11->1 11->5 12->12 12->13 12->13 12->14 12->35 12->35 12->43 12->82 13->1 13->12 14->14 14->15 14->15 14->16 14->24 14->37 14->37 14->45 14->46 14->83 14->88 15->1 15->14 16->16 16->17 16->17 16->18 16->26 16->27 16->28 16->39 16->39 16->47 16->69 16->84 16->85 17->1 17->16 18->18 18->19 18->19 18->20 18->30 18->31 18->32 18->41 18->41 18->48 18->70 18->86 18->87 19->1 19->18 20->1 20->1 20->1 20->10 20->12 20->20 20->21 20->21 20->34 20->49 20->54 20->55 20->63 20->64 20->71 20->74 20->90 20->93 20->104 20->108 20->109 21->1 21->20 22->12 23->14 24->1 24->1 24->1 24->57 24->71 24->74 25->16 26->1 26->28 26->59 27->1 27->28 27->60 28->1 28->1 28->1 28->64 29->18 30->1 30->32 30->61 31->1 31->32 31->62 32->1 32->1 32->1 32->55 33->1 33->20 34->1 34->1 35->1 35->1 35->12 35->35 35->36 35->36 35->44 35->50 35->65 35->89 36->1 36->35 37->1 37->1 37->14 37->37 37->38 37->51 37->51 37->51 38->1 38->37 39->1 39->1 39->16 39->39 39->40 39->52 39->69 39->69 40->1 40->39 41->1 41->1 41->18 41->41 41->42 41->53 41->70 41->70 42->1 42->41 43->1 43->35 44->1 44->1 44->65 45->1 45->24 45->58 45->71 46->1 46->37 47->1 47->39 48->1 48->41 49->1 49->1 50->1 50->1 50->1 50->56 50->67 50->68 50->75 50->94 50->105 51->1 51->37 51->38 51->57 51->58 51->95 51->96 51->97 51->98 51->106 51->107 52->1 52->1 52->1 52->53 52->59 52->60 52->73 52->76 52->77 52->77 52->78 52->100 52->111 52->112 52->113 52->115 52->116 52->117 52->118 53->1 53->1 53->1 53->52 53->61 53->62 53->102 53->103 54->1 54->1 55->1 55->34 55->34 55->49 55->49 56->1 56->1 56->58 57->1 57->1 57->1 57->71 57->74 58->1 58->1 58->1 58->71 59->1 59->28 60->1 60->1 60->28 61->1 61->32 62->1 62->1 62->32 63->1 63->34 63->34 63->49 63->49 63->54 63->54 64->1 64->34 64->34 64->49 64->49 64->54 64->54 65->50 65->50 65->66 65->66 65->67 65->75 66->50 66->50 66->67 66->75 67->1 67->1 67->50 67->72 67->110 67->114 68->1 68->1 69->17 69->40 69->52 69->52 69->91 69->99 70->19 70->42 70->53 70->53 70->92 70->101 71->1 71->1 71->63 71->63 72->1 72->1 72->57 73->1 73->1 73->60 73->60 74->1 75->1 75->68 75->68 76->1 77->1 77->1 77->52 77->53 77->73 77->73 78->1 78->1 78->73 78->73 78->76 78->76
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { int t ; scanf ( "\x25\x69\x0" , & t ) ; for ( int test = 1 ; test <= t ; test ++ ) { memset ( games , 0 , sizeof ( games ) ) ; memset ( wins , 0 , sizeof ( wins ) ) ; int n ; scanf ( "%i\n" , & n ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { char c = getchar ( ) ; if ( c == '0' || c == '1' ) { games [ i ] [ j ] ++ ; if ( c == '1' ) wins [ i ] [ j ] ++ ; } else assert ( c == '.' ) ; } scanf ( "\n" ) ; } for ( int i = 0 ; i < n ; i ++ ) { total_wins [ i ] = total_games [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != n ) { total_wins [ i ] += wins [ i ] [ j ] ; total_games [ i ] += games [ i ] [ j ] ; } } } for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; owp [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && games [ j ] [ i ] ) { count ++ ; owp [ i ] += ( double ) ( total_wins [ j ] - wins [ j ] [ i ] ) / ( total_games [ j ] - games [ j ] [ i ] ) ; } } owp [ i ] /= count ; } for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; oowp [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && games [ j ] [ i ] ) { count ++ ; oowp [ i ] += owp [ j ] ; } } oowp [ i ] /= count ; } printf ( "Case #%i:\n" , test ) ; for ( int i = 0 ; i < n ; i ++ ) { printf ( "%.6lf\n" , 0.25 * ( ( double ) total_wins [ i ] / total_games [ i ] ) + 0.50 * owp [ i ] + 0.25 * oowp [ i ] ) ; } } return 0 ; }
>>>Func
METHOD findMinCArray
METHOD_RETURN int
PARAM CArray * array
<operator>.assignment min = array -> array [ 0 ]
RETURN return min ; return min ;
<operator>.lessThan i < array -> size
<operator>.postIncrement i ++
IDENTIFIER min return min ;
<operator>.assignment i = 1
<operator>.lessThan array -> array [ i ] < min
<operator>.assignment min = array -> array [ i ]
<operator>.indirectFieldAccess array -> size
FIELD_IDENTIFIER size size
<operator>.indirectIndexAccess array -> array [ i ]
<operator>.indirectFieldAccess array -> array
<operator>.indirectIndexAccess array -> array [ i ]
FIELD_IDENTIFIER array array
<operator>.indirectFieldAccess array -> array
FIELD_IDENTIFIER array array
>>>PDG&19 0->2 0->5 0->6 0->7 0->8 0->9 2->1 3->1 3->1 3->1 3->7 3->9 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->11 5->12 5->13 5->14 5->16 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->1 9->7 9->10 9->10 9->15 9->17 9->18 10->1 10->1 10->1 10->7 10->9
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) int findMinCArray ( CArray * array ) { int i ; int min = array -> array [ 0 ] ; for ( i = 1 ; i < array -> size ; i ++ ) { if ( array -> array [ i ] < min ) { min = array -> array [ i ] ; } } return min ; }
>>>Func
METHOD pb_fonction
METHOD_RETURN void
<operator>.assignment texte = lit_fichier ( )
<operator>.notEquals texte != NULL
<operator>.assignment nb_ligne_max = atoi ( texte )
<operator>.postIncrement num_ligne ++
<operator>.assignment taille = 4
<operator>.assignment part_ligne = 3
<operator>.assignment nb_args = 0
<operator>.notEquals ( texte = lit_fichier ( ) ) != NULL
atoi atoi ( texte )
<operator>.assignment texte = lit_fichier ( )
<operator>.equals nb_args == 0
IDENTIFIER part_ligne switch(part_ligne)
LITERAL 3 <empty>
<operator>.assignment nb_args = atoi ( texte )
<operator>.assignment nb_args_max = nb_args
<operator>.assignment temp1 = malloc ( nb_args * sizeof ( char * ) )
<operator>.assignment taille = 3
<operator>.assignment part_ligne = 1
LITERAL 1 <empty>
<operator>.assignment nb_args = atoi ( texte )
<operator>.assignment temp2 = malloc ( ( nb_args + nb_args_max + 1 ) * sizeof ( char * ) )
free free ( temp1 )
<operator>.assignment temp = nb_args_max
<operator>.assignmentPlus nb_args_max += nb_args
<operator>.assignment part_ligne = 2
<operator>.assignment taille = 2
LITERAL 2 <empty>
<operator>.assignment nb_args = atoi ( texte )
<operator>.assignment taille = nb_args_max
<operator>.assignment part_ligne = 3
IDENTIFIER part_ligne switch(part_ligne)
<operator>.equals part_ligne == 3
<operator>.lessThan i < nb_args_max
<operator>.postIncrement i ++
<operator>.assignment temp2 [ i ] = temp1 [ i ]
LITERAL 1 <empty>
<operator>.assignment temp1 [ -- nb_args ] = texte
LITERAL 2 <empty>
<operator>.assignment temp2 [ nb_args_max - nb_args ] = texte
<operator>.postDecrement nb_args --
LITERAL 3 <empty>
<operator>.assignment temp2 [ nb_args_max ] = texte
<operator>.assignment res = algo ( temp2 , temp , nb_args_max , nb_args )
<operator>.assignment * aff = malloc ( 15 + 3 * res * sizeof ( char ) )
<operator>.assignment nb_args = 0
free free ( temp2 )
atoi atoi ( texte )
malloc malloc ( nb_args * sizeof ( char * ) )
atoi atoi ( texte )
malloc malloc ( ( nb_args + nb_args_max + 1 ) * sizeof ( char * ) )
<operator>.assignment i = 0
atoi atoi ( texte )
<operator>.greaterEqualsThan ( num_ligne ++ ) >= nb_ligne_max
<operator>.multiplication nb_args * sizeof ( char * )
<operator>.multiplication ( nb_args + nb_args_max + 1 ) * sizeof ( char * )
algo algo ( temp2 , temp , nb_args_max , nb_args )
malloc malloc ( 15 + 3 * res * sizeof ( char ) )
RETURN return ; return ;
<operator>.addition nb_args + nb_args_max + 1
<operator>.preDecrement -- nb_args
<operator>.subtraction nb_args_max - nb_args
<operator>.addition 15 + 3 * res * sizeof ( char )
<operator>.postIncrement num_ligne ++
<operator>.addition nb_args + nb_args_max
<operator>.multiplication 3 * res * sizeof ( char )
<operator>.multiplication 3 * res
<operator>.sizeOf sizeof ( char )
lit_fichier lit_fichier ( )
UNKNOWN <missing ';'> sprintf <missing ';'> ( <missing ';'> aff   % d : % s ecrit_fichier ( aff ) ; <missing ';'> sprintf <missing ';'> ( <missing ';'> aff   % d : % s ecrit_fichier ( aff ) ;
<operator>.indirectIndexAccess temp2 [ i ]
<operator>.indirectIndexAccess temp1 [ i ]
<operator>.indirectIndexAccess temp1 [ -- nb_args ]
<operator>.indirectIndexAccess temp2 [ nb_args_max - nb_args ]
<operator>.indirectIndexAccess temp2 [ nb_args_max ]
<operator>.sizeOf sizeof ( char * )
<operator>.sizeOf sizeof ( char * )
>>>PDG&78 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->18 0->19 0->20 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->31 0->32 0->33 0->34 0->35 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->46 0->47 0->48 0->50 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->67 2->3 3->1 3->4 3->5 3->6 3->7 3->8 3->9 3->9 3->10 3->10 3->11 3->69 4->1 4->1 4->54 5->64 6->1 6->1 7->1 7->33 8->12 9->1 9->1 9->1 9->12 10->4 11->1 11->1 11->9 11->38 11->40 11->43 11->48 11->50 11->53 12->1 12->9 12->11 12->15 12->16 12->17 12->18 12->19 12->21 12->22 12->23 12->24 12->25 12->26 12->27 12->29 12->30 12->31 12->33 12->34 12->38 12->40 12->41 12->43 12->48 12->49 12->50 12->51 12->52 12->53 12->55 12->56 12->57 12->60 12->61 12->61 12->62 12->62 12->65 12->69 12->73 12->74 12->75 12->76 12->77 15->1 15->1 15->16 15->55 16->1 16->30 16->34 16->56 16->57 16->60 16->62 16->65 17->1 17->1 17->1 17->23 17->36 18->1 18->1 19->1 19->33 21->1 21->1 21->12 21->25 21->56 21->60 21->65 22->1 22->1 22->57 23->1 23->36 24->1 24->57 25->1 25->30 25->34 25->56 25->57 25->60 25->62 25->65 26->1 26->33 27->1 27->1 29->1 29->1 29->12 30->1 30->1 31->1 31->33 33->1 33->1 33->9 33->11 33->44 33->45 33->46 33->47 33->54 33->57 33->58 33->63 33->64 33->66 33->67 33->68 33->69 33->70 34->1 34->1 34->24 34->25 34->34 34->35 34->35 34->36 34->71 34->72 35->1 35->34 36->1 36->1 36->1 36->47 36->57 38->1 38->1 38->1 38->23 40->1 40->1 40->1 40->47 40->57 41->1 41->12 41->57 43->1 43->1 43->1 43->47 43->57 44->1 44->1 44->67 45->1 45->1 45->1 46->1 46->1 46->12 47->1 47->57 48->15 49->1 49->17 50->21 51->1 51->22 52->1 52->34 53->29 54->1 54->1 54->1 54->9 54->11 54->59 54->69 55->12 55->49 56->1 56->51 57->1 57->1 57->30 57->34 57->44 57->44 57->44 57->44 57->47 57->56 57->60 57->62 57->65 58->1 58->45 59->1 60->1 61->12 61->57 62->30 62->34 62->41 62->56 62->57 62->60 62->65 63->1 64->1 64->54 66->1 66->58 66->63 67->1 67->66 67->66 68->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) void pb_fonction ( ) { char * texte ; texte = lit_fichier ( ) ; if ( texte != NULL ) { nb_ligne_max = atoi ( texte ) ; num_ligne ++ ; taille = 4 ; char * * temp1 , * * temp2 ; int i ; int temp ; part_ligne = 3 ; nb_args = 0 ; while ( ( texte = lit_fichier ( ) ) != NULL ) { if ( nb_args == 0 ) { switch ( part_ligne ) { case 3 : nb_args = atoi ( texte ) ; nb_args_max = nb_args ; temp1 = malloc ( nb_args * sizeof ( char * ) ) ; taille = 3 ; part_ligne = 1 ; break ; case 1 : nb_args = atoi ( texte ) ; temp2 = malloc ( ( nb_args + nb_args_max + 1 ) * sizeof ( char * ) ) ; for ( i = 0 ; i < nb_args_max ; i ++ ) temp2 [ i ] = temp1 [ i ] ; free ( temp1 ) ; temp = nb_args_max ; nb_args_max += nb_args ; part_ligne = 2 ; taille = 2 ; break ; case 2 : nb_args = atoi ( texte ) ; taille = nb_args_max ; part_ligne = 3 ; break ; } } else { switch ( part_ligne ) { case 1 : temp1 [ -- nb_args ] = texte ; break ; case 2 : temp2 [ nb_args_max - nb_args ] = texte ; nb_args -- ; break ; case 3 : temp2 [ nb_args_max ] = texte ; break ; } if ( part_ligne == 3 ) { char * affiche_char ( void * a ) ; int res = algo ( temp2 , temp , nb_args_max , nb_args ) ; char * aff = malloc ( 15 + 3 * res * sizeof ( char ) ) ; <missing ';'> sprintf <missing ';'> ( <missing ';'> aff , % d : % s ecrit_fichier ( aff ) ; nb_args = 0 ; free ( temp2 ) ; if ( ( num_ligne ++ ) >= nb_ligne_max ) return ; } } } } }
>>>Func
METHOD GetNextToken
METHOD_RETURN char*
PARAM char * buf
<operator>.assignment * token = NULL
<operator>.assignment i = 0
<operator>.assignment token = ( char * ) malloc ( i + 1 )
memset memset ( token , 0 , i + 1 )
strncpy strncpy ( token , buf , i )
RETURN return token ; return token ;
<operator>.logicalAnd buf [ i ] != ' ' && buf [ i ] != '\0'
IDENTIFIER token return token ;
<operator>.postIncrement i ++
<operator>.cast ( char * ) malloc ( i + 1 )
<operator>.addition i + 1
<operator>.notEquals buf [ i ] != ' '
<operator>.notEquals buf [ i ] != '\0'
malloc malloc ( i + 1 )
<operator>.addition i + 1
<operator>.indirectIndexAccess buf [ i ]
<operator>.indirectIndexAccess buf [ i ]
>>>PDG&20 0->2 0->3 0->4 0->6 0->7 0->10 0->11 0->13 0->14 0->15 0->16 0->17 2->7 2->14 2->15 3->1 3->1 4->1 4->6 4->7 4->11 4->13 4->16 4->17 5->1 5->1 5->6 6->1 6->1 6->7 7->1 7->1 7->1 7->1 7->10 8->1 9->1 9->1 9->1 9->9 9->11 9->14 9->18 10->8 11->1 11->6 11->7 11->13 11->16 11->17 12->1 14->1 14->7 14->9 14->9 14->15 14->15 14->19 15->1 15->7 15->9 15->9 15->14 16->5 16->12
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() ) char * GetNextToken ( char * buf ) { char * token = NULL ; int i = 0 ; while ( buf [ i ] != ' ' && buf [ i ] != '\0' ) { i ++ ; } token = ( char * ) malloc ( i + 1 ) ; memset ( token , 0 , i + 1 ) ; strncpy ( token , buf , i ) ; return token ; }
>>>Func
METHOD main
METHOD_RETURN int
freopen freopen ( "\x6d\x61\x67\x69\x6b\x61\x2e\x69\x6e\x0" , "r" , stdin )
freopen freopen ( "magika.out" , "w" , stdout )
scanf scanf ( "%d " , & numCases )
RETURN return 0 ; return 0 ;
<operator>.lessThan i < numCases
<operator>.postIncrement i ++
LITERAL 0 return 0 ;
<operator>.assignment i = 0
printf printf ( "Case #%d: " , i + 1 )
handleCase handleCase ( )
<operator>.addition i + 1
>>>PDG&13 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 2->1 3->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->10 6->11 6->12 6->12 7->1 7->6 8->5 9->1 9->6 10->1 10->1 11->1
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { freopen ( "\x6d\x61\x67\x69\x6b\x61\x2e\x69\x6e\x0" , "r" , stdin ) ; freopen ( "magika.out" , "w" , stdout ) ; int numCases ; scanf ( "%d " , & numCases ) ; int i ; for ( i = 0 ; i < numCases ; i ++ ) { printf ( "Case #%d: " , i + 1 ) ; handleCase ( ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf ( "\x25\x64\x0" , & T )
RETURN return 0 ; return 0 ;
<operator>.lessEqualsThan t <= T
<operator>.postIncrement t ++
LITERAL 0 return 0 ;
<operator>.assignment t = 1
scanf scanf ( "%d%d%d" , & n , & d1 , & g1 )
printf printf ( "Case #%d: " , t )
<operator>.logicalOr ( d1 > 0 && g1 == 0 ) || ( d1 < 100 && g1 == 100 )
IDENTIFIER d1 if (d1)
<operator>.lessEqualsThan d2 <= n
printf printf ( "Broken\n" )
<operator>.assignment g = gcd ( d1 , 100 )
<operator>.assignmentDivision d1 /= g
<operator>.assignment d2 = 100 / g
printf printf ( "Possible\n" )
<operator>.logicalAnd d1 > 0 && g1 == 0
<operator>.logicalAnd d1 < 100 && g1 == 100
<operator>.assignment d2 = 1
printf printf ( "Broken\n" )
<operator>.greaterThan d1 > 0
<operator>.equals g1 == 0
<operator>.lessThan d1 < 100
<operator>.equals g1 == 100
gcd gcd ( d1 , 100 )
<operator>.division 100 / g
<operator>.addressOf & n
<operator>.addressOf & d1
<operator>.addressOf & g1
>>>PDG&31 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->15 0->17 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->9 4->10 4->18 4->22 4->28 4->29 4->30 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->12 9->1 9->5 10->1 10->1 10->1 10->12 10->13 10->14 10->15 10->16 10->20 10->26 10->27 12->1 12->1 12->1 12->8 12->17 12->21 13->1 14->1 14->1 14->15 14->27 15->1 15->1 15->22 16->1 16->1 16->12 17->1 18->1 18->1 18->10 18->10 18->19 18->24 19->1 19->1 19->10 19->10 20->1 20->12 21->1 22->1 22->18 22->18 22->23 22->24 22->26 23->1 23->18 23->18 23->25 24->1 24->19 24->19 24->22 24->25 24->26 25->1 25->19 25->19 25->23 26->14 26->14 26->15 27->1 27->16 27->16
>>>Token #include <bits/stdc++.h>  #define ffrr ( i , a , b )  for(long long int i=a;i<b;i++) #define vvvsort(v) sort(v.begin(),v.end()) #define vvvuni(vec) vec.erase( unique( vec.begin(), vec.end() ), vec.end() )  int main ( ) { scanf ( "\x25\x64\x0" , & T ) ; for ( t = 1 ; t <= T ; t ++ ) { scanf ( "%d%d%d" , & n , & d1 , & g1 ) ; printf ( "Case #%d: " , t ) ; if ( ( d1 > 0 && g1 == 0 ) || ( d1 < 100 && g1 == 100 ) ) { printf ( "Broken\n" ) ; continue ; } if ( d1 ) { g = gcd ( d1 , 100 ) ; d1 /= g ; d2 = 100 / g ; } else d2 = 1 ; if ( d2 <= n ) printf ( "Possible\n" ) ; else printf ( "Broken\n" ) ; } return 0 ; }
>>>Func
