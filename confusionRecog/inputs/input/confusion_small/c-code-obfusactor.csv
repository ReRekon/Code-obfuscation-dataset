METHOD pqzgumbdgrasinvoke
METHOD_RETURN ANY
PARAM int zixqgqwjfggh [ ][26]
PARAM int vveowjklkglc [ ][26]
PARAM int iqutqolavxkr
<operator>.assignment eIdx=-1
<operator>.lessThan acbcbqctjvxl<iqutqolavxkr
<operator>.postIncrement acbcbqctjvxl++
<operator>.lessEqualsThan acbcbqctjvxl<=eIdx
<operator>.postIncrement acbcbqctjvxl++
<operator>.minus -1
<operator>.assignment acbcbqctjvxl=0
scanf scanf("%c",&muhixtoyqprw)
<operator>.assignment tuynsepkjdgk[++eIdx]=muhixtoyqprw-'A'
<operator>.assignment acbcbqctjvxl=0
<operator>.equals eIdx==0
<operator>.lessThan acbcbqctjvxl<eIdx
<operator>.subtraction muhixtoyqprw-'A'
tdzgqdztdlot tdzgqdztdlot("%c, ",tuynsepkjdgk[acbcbqctjvxl]+'A')
<operator>.preIncrement ++eIdx
<operator>.assignment pqgegzawzwpd=tuynsepkjdgk[eIdx]
<operator>.assignment cwreqkilxgvw=tuynsepkjdgk[eIdx-1]
tdzgqdztdlot tdzgqdztdlot ("%c",tuynsepkjdgk[acbcbqctjvxl]+'A')
<operator>.logicalOr zixqgqwjfggh[pqgegzawzwpd][cwreqkilxgvw]>0||zixqgqwjfggh[cwreqkilxgvw][pqgegzawzwpd]>0
<operator>.addition tuynsepkjdgk[acbcbqctjvxl]+'A'
<operator>.assignment tuynsepkjdgk[eIdx-1]=zixqgqwjfggh[pqgegzawzwpd][cwreqkilxgvw]
<operator>.postDecrement eIdx--
<operator>.addition tuynsepkjdgk[acbcbqctjvxl]+'A'
<operator>.subtraction eIdx-1
<operator>.greaterThan zixqgqwjfggh[pqgegzawzwpd][cwreqkilxgvw]>0
<operator>.greaterThan zixqgqwjfggh[cwreqkilxgvw][pqgegzawzwpd]>0
<operator>.lessThan ekzpvdwdcvzy<eIdx
<operator>.postIncrement ekzpvdwdcvzy++
<operator>.subtraction eIdx-1
<operator>.assignment ekzpvdwdcvzy=0
<operator>.logicalOr vveowjklkglc[pqgegzawzwpd][tuynsepkjdgk[ekzpvdwdcvzy]]>0||vveowjklkglc[tuynsepkjdgk[ekzpvdwdcvzy]][pqgegzawzwpd]>0
<operator>.assignment eIdx=-1
<operator>.greaterThan vveowjklkglc[pqgegzawzwpd][tuynsepkjdgk[ekzpvdwdcvzy]]>0
<operator>.greaterThan vveowjklkglc[tuynsepkjdgk[ekzpvdwdcvzy]][pqgegzawzwpd]>0
<operator>.minus -1
<operator>.addressOf &muhixtoyqprw
<operator>.indirectIndexAccess tuynsepkjdgk[++eIdx]
<operator>.indirectIndexAccess tuynsepkjdgk[eIdx]
<operator>.indirectIndexAccess tuynsepkjdgk[eIdx-1]
<operator>.indirectIndexAccess tuynsepkjdgk[acbcbqctjvxl]
<operator>.indirectIndexAccess tuynsepkjdgk[acbcbqctjvxl]
<operator>.indirectIndexAccess zixqgqwjfggh[pqgegzawzwpd][cwreqkilxgvw]
<operator>.indirectIndexAccess zixqgqwjfggh[cwreqkilxgvw][pqgegzawzwpd]
<operator>.indirectIndexAccess tuynsepkjdgk[eIdx-1]
<operator>.indirectIndexAccess zixqgqwjfggh[pqgegzawzwpd][cwreqkilxgvw]
<operator>.indirectIndexAccess zixqgqwjfggh[pqgegzawzwpd]
<operator>.indirectIndexAccess zixqgqwjfggh[cwreqkilxgvw]
<operator>.indirectIndexAccess zixqgqwjfggh[pqgegzawzwpd]
<operator>.indirectIndexAccess vveowjklkglc[pqgegzawzwpd][tuynsepkjdgk[ekzpvdwdcvzy]]
<operator>.indirectIndexAccess vveowjklkglc[tuynsepkjdgk[ekzpvdwdcvzy]][pqgegzawzwpd]
<operator>.indirectIndexAccess vveowjklkglc[pqgegzawzwpd]
<operator>.indirectIndexAccess tuynsepkjdgk[ekzpvdwdcvzy]
<operator>.indirectIndexAccess vveowjklkglc[tuynsepkjdgk[ekzpvdwdcvzy]]
<operator>.indirectIndexAccess tuynsepkjdgk[ekzpvdwdcvzy]
>>>PDG&59 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->22 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->37 0->38 0->39 2->1 3->1 4->6 5->1 5->1 5->8 5->19 6->1 6->1 6->6 6->7 6->7 6->12 6->13 6->15 6->17 6->19 6->40 6->41 7->1 7->6 8->1 8->1 8->1 8->8 8->9 8->16 8->16 8->16 9->1 9->8 10->5 11->6 12->17 14->1 14->8 15->8 15->19 15->20 15->21 15->23 15->28 15->28 15->29 15->42 15->43 15->46 15->50 16->8 16->9 16->18 16->22 16->24 16->27 16->44 16->45 17->12 17->13 17->13 19->15 23->25 23->26 23->31 23->33 23->34 23->48 23->49 23->52 25->21 26->8 26->19 28->31 28->33 29->23 29->23 29->25 29->30 29->47 29->51 30->23 30->23 31->8 31->19 31->32 31->35 31->37 31->53 31->55 31->56 32->31 33->26 34->31 35->31 35->32 35->36 35->39 36->8 36->19 37->35 37->35 37->38 37->54 37->57 37->58 38->35 38->35 39->36
>>>Token static pqzgumbdgrasinvoke ( int  zixqgqwjfggh [ ] [ 26 ] , int vveowjklkglc [ ] [ 26 ] , int iqutqolavxkr ) { int acbcbqctjvxl ; int tuynsepkjdgk [ 100 ] , eIdx = -1 ; for ( acbcbqctjvxl = 0 ; acbcbqctjvxl < iqutqolavxkr ; acbcbqctjvxl ++ ) { char muhixtoyqprw ; scanf ( " " , & muhixtoyqprw ) ; tuynsepkjdgk [ ++ eIdx ] = muhixtoyqprw - ' ' ; if ( eIdx == 0 ) { continue ; } else { int pqgegzawzwpd = tuynsepkjdgk [ eIdx ] ; int cwreqkilxgvw = tuynsepkjdgk [ eIdx - 1 ] ; if ( zixqgqwjfggh [ pqgegzawzwpd ] [ cwreqkilxgvw ] > 0 || zixqgqwjfggh [ cwreqkilxgvw ] [ pqgegzawzwpd ] > 0 ) { tuynsepkjdgk [ eIdx - 1 ] = zixqgqwjfggh [ pqgegzawzwpd ] [ cwreqkilxgvw ] ; eIdx -- ; } else { int ekzpvdwdcvzy ; for ( ekzpvdwdcvzy = 0 ; ekzpvdwdcvzy < eIdx ; ekzpvdwdcvzy ++ ) { if ( vveowjklkglc [ pqgegzawzwpd ] [ tuynsepkjdgk [ ekzpvdwdcvzy ] ] > 0 || vveowjklkglc [ tuynsepkjdgk [ ekzpvdwdcvzy ] ] [ pqgegzawzwpd ] > 0 ) { eIdx = -1 ; break ; } } } } } for ( acbcbqctjvxl = 0 ; acbcbqctjvxl <= eIdx ; acbcbqctjvxl ++ ) { if ( acbcbqctjvxl < eIdx ) tdzgqdztdlot ( " " , tuynsepkjdgk [ acbcbqctjvxl ] + ' ' ) ; else tdzgqdztdlot ( " " , tuynsepkjdgk [ acbcbqctjvxl ] + ' ' ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment fp=fopen("A-small-attempt1.in","r")
<operator>.assignment fo=fopen(" Freecell.out","w")
<operator>.assignment flag=0
fscanf fscanf(fp,"%d\n",&test_case)
fclose fclose(fp)
fclose fclose(fo)
RETURN return (0); return (0);
<operator>.lessThan dhwkpymnwlhk<test_case
<operator>.postIncrement dhwkpymnwlhk++
LITERAL 0 return (0);
fopen fopen("A-small-attempt1.in","r")
fopen fopen(" Freecell.out","w")
<operator>.assignment dhwkpymnwlhk=0
<operator>.assignment flag=0
fscanf fscanf(fp,"%d %d %d\n",&n,&pd,&pg)
bebaovnuwwdd bebaovnuwwdd(flag==1)
BLOCK <empty> <empty>
<operator>.lessEqualsThan j<=n
<operator>.postIncrement j++
bebaovnuwwdd bebaovnuwwdd(pg==100&&pd<pg)
BLOCK <empty> <empty>
<operator>.assignment j=1
<operator>.assignment a=j *pd
bebaovnuwwdd bebaovnuwwdd(a%100==0)
<operator>.equals flag==1
phjyppxwblgm phjyppxwblgm(fo,"Case #%d: Broken\n",dhwkpymnwlhk+1)
<operator>.assignment flag=1
<operator>.logicalAnd pg==100&&pd<pg
<operator>.multiplication j *pd
<operator>.equals a%100==0
<operator>.equals pg==100
<operator>.lessThan pd<pg
<operator>.addition dhwkpymnwlhk+1
<operator>.modulo a%100
UNKNOWN,),)
UNKNOWN else phjyppxwblgm (fo,"Case #%d: Broken\n",dhwkpymnwlhk+1); else phjyppxwblgm (fo,"Case #%d: Broken\n",dhwkpymnwlhk+1);
<operator>.addressOf &n
<operator>.addressOf &pd
<operator>.addressOf &pg
UNKNOWN,),)
UNKNOWN else bebaovnuwwdd (pg==0&&pd>0){phjyppxwblgm(fo,"Case #%d: Broken\n",dhwkpymnwlhk+1);} else bebaovnuwwdd (pg==0&&pd>0){phjyppxwblgm(fo,"Case #%d: Broken\n",dhwkpymnwlhk+1);}
UNKNOWN else bebaovnuwwdd (pd==0&&pg==100){phjyppxwblgm(fo,"Case #%d: Broken\n",dhwkpymnwlhk+1);} else bebaovnuwwdd (pd==0&&pg==100){phjyppxwblgm(fo,"Case #%d: Broken\n",dhwkpymnwlhk+1);}
UNKNOWN else {phjyppxwblgm(fo,"Case #%d: Possible\n",dhwkpymnwlhk+1);} else {phjyppxwblgm(fo,"Case #%d: Possible\n",dhwkpymnwlhk+1);}
UNKNOWN,),)
>>>PDG&46 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->22 0->23 0->26 0->27 0->28 0->30 0->31 0->32 0->33 0->34 0->35 2->1 2->1 2->5 3->1 3->1 3->7 3->27 4->1 4->1 5->1 5->1 5->6 5->9 5->16 6->1 6->1 7->1 7->1 8->1 9->1 9->1 9->1 9->9 9->10 9->10 9->15 9->16 9->17 9->19 9->21 9->23 9->26 9->27 9->27 9->29 9->32 9->34 9->34 9->36 9->37 9->38 9->39 9->40 9->41 9->42 9->43 9->44 10->1 10->9 11->8 12->2 12->2 13->3 13->3 14->1 14->9 15->1 15->26 16->1 16->1 16->1 16->1 16->6 16->19 16->30 16->32 16->33 16->33 17->1 17->1 19->1 19->1 19->1 19->16 19->24 19->25 19->28 19->30 19->30 19->31 19->35 19->45 20->1 20->19 21->1 21->1 23->1 23->19 24->1 24->1 24->35 25->1 25->1 26->1 26->17 26->17 27->1 27->1 27->7 28->1 28->26 29->1 29->1 29->21 29->21 30->1 30->1 30->16 30->24 30->24 30->33 31->1 31->25 31->25 32->1 32->16 32->29 32->29 32->33 32->33 33->1 33->1 33->16 33->16 33->29 33->29 33->30 33->32 35->1 35->31 35->31
>>>Token int main ( ) { FILE * fp ; FILE * fo ; fp = fopen ( " " , " " ) ; fo = fopen ( " " , " " ) ; uhpllujmsznr dhwkpymnwlhk , j , test_case , n , pd , pg , flag = 0 ; long uhpllujmsznra , b ; fscanf ( fp , " \n " , & test_case ) ; for ( dhwkpymnwlhk = 0 ; dhwkpymnwlhk < test_case ; dhwkpymnwlhk ++ ) { flag = 0 ; fscanf ( fp , " \n " , & n , & pd , & pg ) ; for ( j = 1 ; j <= n ; j ++ ) { a = j * pd ; bebaovnuwwdd ( a % 100 == 0 )  { flag = 1 ; break ; } } bebaovnuwwdd ( flag == 1 )  { bebaovnuwwdd ( pg == 100 && pd < pg )  { phjyppxwblgm ( fo , " \n " , dhwkpymnwlhk + 1 ) ; } else bebaovnuwwdd ( pg == 0 && pd > 0 ) { phjyppxwblgm ( fo , " \n " , dhwkpymnwlhk + 1 ) ; } else bebaovnuwwdd ( pd == 0 && pg = = 100 ) { phjyppxwblgm ( fo , " \n " , dhwkpymnwlhk + 1 ) ; } else  { phjyppxwblgm ( fo , " \n " , dhwkpymnwlhk + 1 ) ; } } else phjyppxwblgm ( fo , " \n " , dhwkpymnwlhk + 1 ) ; } fclose ( fp ) ; fclose ( fo ) ; return ( 0 ) ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&hkfopyxdremn)
RETURN return 0; return 0;
<operator>.lessEqualsThan ezolnlfhlujl<=hkfopyxdremn
<operator>.postIncrement ezolnlfhlujl++
LITERAL 0 return 0;
<operator>.assignment ezolnlfhlujl=1
scanf scanf("%d%d%d",&n,&m,&a)
printf printf("Case #%d: ",ezolnlfhlujl)
<operator>.assignment fmnmhlfdwdvg=1
<operator>.greaterThan a>n *m
<operator>.logicalAnd qqurxidysybi<=n&&fmnmhlfdwdvg
<operator>.postIncrement qqurxidysybi++
IDENTIFIER fmnmhlfdwdvg if (fmnmhlfdwdvg)
printf printf("IMPOSSIBLE\n")
<operator>.assignment qqurxidysybi=0
printf printf("IMPOSSIBLE\n")
<operator>.multiplication n *m
<operator>.lessEqualsThan qqurxidysybi<=n
<operator>.logicalAnd xb<=n&&fmnmhlfdwdvg
<operator>.postIncrement xb++
<operator>.assignment xb=0
<operator>.lessEqualsThan xb<=n
<operator>.logicalAnd xc<=n&&fmnmhlfdwdvg
<operator>.postIncrement xc++
<operator>.assignment xc=0
<operator>.lessEqualsThan xc<=n
<operator>.logicalAnd ya<=m&&fmnmhlfdwdvg
<operator>.postIncrement ya++
<operator>.assignment ya=0
<operator>.lessEqualsThan ya<=m
<operator>.logicalAnd yb<=m&&fmnmhlfdwdvg
<operator>.postIncrement yb++
<operator>.assignment yb=0
<operator>.lessEqualsThan yb<=m
<operator>.logicalAnd yc<=m&&fmnmhlfdwdvg
<operator>.postIncrement yc++
<operator>.assignment yc=0
<operator>.assignment rinrrikydqqr=ABS((xb *ya-qqurxidysybi *yb)+(xc *yb-xb *yc)+(qqurxidysybi *yc-xc *ya))
<operator>.lessEqualsThan yc<=m
<operator>.equals rinrrikydqqr==a
ABS ABS((xb *ya-qqurxidysybi *yb)+(xc *yb-xb *yc)+(qqurxidysybi *yc-xc *ya))
printf printf("%d %d %d %d %d %d\n",qqurxidysybi,ya,xb,yb,xc,yc)
<operator>.assignment fmnmhlfdwdvg=0
<operator>.addition (xb *ya-qqurxidysybi *yb)+(xc *yb-xb *yc)+(qqurxidysybi *yc-xc *ya)
<operator>.addition (xb *ya-qqurxidysybi *yb)+(xc *yb-xb *yc)
<operator>.subtraction qqurxidysybi *yc-xc *ya
<operator>.subtraction xb *ya-qqurxidysybi *yb
<operator>.subtraction xc *yb-xb *yc
<operator>.multiplication qqurxidysybi *yc
<operator>.multiplication xc *ya
<operator>.multiplication xb *ya
<operator>.multiplication qqurxidysybi *yb
<operator>.multiplication xc *yb
<operator>.multiplication xb *yc
<operator>.addressOf &n
<operator>.addressOf &m
<operator>.addressOf &a
>>>PDG&59 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->43 0->44 0->50 0->51 0->52 0->53 0->54 0->55 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->9 4->11 4->18 4->56 4->57 4->58 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->18 8->19 8->23 8->27 9->1 9->5 10->1 10->12 11->1 11->1 11->1 11->10 11->12 11->15 11->16 11->17 11->19 11->41 12->1 12->1 12->1 12->12 12->13 12->19 12->20 12->20 12->22 12->23 13->1 13->19 15->1 16->1 16->19 17->1 18->1 18->1 18->8 18->11 18->11 18->19 18->31 19->1 19->1 19->8 19->12 19->12 19->13 19->18 19->23 19->53 20->1 20->1 20->12 20->20 20->21 20->23 20->24 20->24 20->26 20->27 21->1 21->23 22->1 22->23 23->1 23->19 23->20 23->20 23->21 23->27 23->52 24->1 24->1 24->20 24->24 24->25 24->27 24->28 24->28 24->30 24->31 25->1 25->27 26->1 26->27 27->1 27->23 27->24 27->24 27->25 27->54 28->1 28->1 28->24 28->28 28->29 28->31 28->32 28->32 28->34 28->35 29->1 29->31 30->1 30->31 31->1 31->1 31->18 31->28 31->28 31->29 31->35 31->52 32->1 32->1 32->28 32->32 32->33 32->35 32->36 32->36 32->38 32->40 33->1 33->35 34->1 34->35 35->1 35->31 35->32 35->32 35->33 35->40 35->53 36->1 36->1 36->32 36->36 36->37 36->39 36->40 36->41 36->42 36->45 36->46 36->47 36->48 36->49 36->50 36->51 36->52 36->53 36->54 36->55 37->1 37->40 38->1 38->40 39->1 39->1 39->41 40->1 40->35 40->36 40->36 40->55 41->1 41->1 41->1 41->11 41->43 41->44 42->1 42->39 43->1 43->13 43->21 43->25 43->29 43->33 43->37 43->52 43->52 43->53 43->53 43->54 44->1 44->36 45->1 45->1 46->1 46->1 47->1 47->1 47->42 47->42 47->45 47->45 48->1 48->1 48->42 48->42 48->45 48->45 48->46 48->46 49->1 49->1 49->42 49->42 49->45 49->45 49->46 49->46 50->13 50->37 50->43 50->43 50->47 50->47 50->53 51->25 51->29 51->43 51->43 51->47 51->47 51->52 51->54 52->48 52->48 52->51 52->55 53->48 53->48 53->50 53->54 54->33 54->43 54->49 54->49 54->51 54->53 55->21 55->43 55->49 55->49 55->50 55->52
>>>Token int main ( ) { int hkfopyxdremn , n , m , a ; int ezolnlfhlujl ; int qqurxidysybi , ya , xb , yb , xc , yc ; int rinrrikydqqr ; int fmnmhlfdwdvg ; scanf ( " " , & hkfopyxdremn ) ; for ( ezolnlfhlujl = 1 ; ezolnlfhlujl <= hkfopyxdremn ; ezolnlfhlujl ++ ) { scanf ( " " , & n , & m , & a ) ; printf ( " " , ezolnlfhlujl ) ; if ( a > n * m ) { printf ( " \n " ) ; continue ; } fmnmhlfdwdvg = 1 ; for ( qqurxidysybi = 0 ; qqurxidysybi <= n && fmnmhlfdwdvg ; qqurxidysybi ++ ) { for ( xb = 0 ; xb <= n && fmnmhlfdwdvg ; xb ++ ) { for ( xc = 0 ; xc <= n && fmnmhlfdwdvg ; xc ++ ) { for ( ya = 0 ; ya <= m && fmnmhlfdwdvg ; ya ++ ) { for ( yb = 0 ; yb <= m && fmnmhlfdwdvg ; yb ++ ) { for ( yc = 0 ; yc <= m && fmnmhlfdwdvg ; yc ++ ) { rinrrikydqqr = ABS ( ( xb * ya - qqurxidysybi * yb ) + ( xc * yb - xb * yc ) + ( qqurxidysybi * yc - xc * ya ) ) ; if ( rinrrikydqqr == a ) { printf ( " \n " , qqurxidysybi , ya , xb , yb , xc , yc ) ; fmnmhlfdwdvg = 0 ; } } } } } } } if ( fmnmhlfdwdvg ) printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD read_line
METHOD_RETURN char*
PARAM FILE *fd
<operator>.assignment gkyfyxwnxxqi=0
<operator>.assignment *aux=qhaequabhdkw
<operator>.assignment *ykiwdxnwzubj=qhaequabhdkw
<operator>.assignment aux=ykiwdxnwzubj
RETURN return ykiwdxnwzubj; return ykiwdxnwzubj;
<operator>.notEquals (vyaheujgnlpx=(char)fgetc(fd))!=EOF
<operator>.notEquals aux!=qhaequabhdkw
IDENTIFIER ykiwdxnwzubj return ykiwdxnwzubj;
<operator>.assignment ykiwdxnwzubj=(char *)malloc(sizeof(char)*(strlen(aux)+1))
<operator>.assignment ykiwdxnwzubj=strcpy(ykiwdxnwzubj,aux)
free free(aux)
<operator>.assignment vyaheujgnlpx=(char)fgetc(fd)
<operator>.equals (gkyfyxwnxxqi%BUFFER_SIZE)==0
<operator>.equals vyaheujgnlpx=='\ucrkarxcripu'
<operator>.cast (char)fgetc(fd)
<operator>.assignment aux=ykiwdxnwzubj
<operator>.assignment ykiwdxnwzubj=(char *)malloc(sizeof(char)*(gkyfyxwnxxqi+BUFFER_SIZE))
<operator>.assignment ykiwdxnwzubj[gkyfyxwnxxqi]='\0'
<operator>.cast (char *)malloc(sizeof(char)*(strlen(aux)+1))
strcpy strcpy(ykiwdxnwzubj,aux)
fgetc fgetc(fd)
<operator>.modulo gkyfyxwnxxqi%BUFFER_SIZE
<operator>.equals ykiwdxnwzubj==qhaequabhdkw
<operator>.notEquals aux!=qhaequabhdkw
<operator>.assignment ykiwdxnwzubj[gkyfyxwnxxqi++]=vyaheujgnlpx
malloc malloc(sizeof(char)*(strlen(aux)+1))
<operator>.cast (char *)malloc(sizeof(char)*(gkyfyxwnxxqi+BUFFER_SIZE))
perror perror("Critical error")
RETURN return qhaequabhdkw; return qhaequabhdkw;
free free(aux)
<operator>.multiplication sizeof(char)*(strlen(aux)+1)
malloc malloc(sizeof(char)*(gkyfyxwnxxqi+BUFFER_SIZE))
<operator>.notEquals aux!=qhaequabhdkw
IDENTIFIER qhaequabhdkw return qhaequabhdkw;
<operator>.lessThan i<gkyfyxwnxxqi
<operator>.postIncrement i++
<operator>.assignment ykiwdxnwzubj[i]=aux[i]
<operator>.addition strlen(aux)+1
<operator>.multiplication sizeof(char)*(gkyfyxwnxxqi+BUFFER_SIZE)
free free(aux)
<operator>.assignment i=0
<operator>.postIncrement gkyfyxwnxxqi++
strlen strlen(aux)
<operator>.sizeOf sizeof(char)
<operator>.addition gkyfyxwnxxqi+BUFFER_SIZE
UNKNOWN char char
UNKNOWN char * char *
<operator>.indirectIndexAccess ykiwdxnwzubj[gkyfyxwnxxqi]
UNKNOWN char * char *
<operator>.indirectIndexAccess ykiwdxnwzubj[gkyfyxwnxxqi++]
<operator>.sizeOf sizeof(char)
<operator>.indirectIndexAccess ykiwdxnwzubj[i]
<operator>.indirectIndexAccess aux[i]
>>>PDG&56 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->13 0->15 0->16 0->18 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->30 0->32 0->33 0->35 0->36 0->37 0->38 0->40 0->41 0->42 0->43 0->44 0->45 0->47 2->23 3->1 3->24 4->1 5->1 5->6 5->10 5->18 6->9 7->1 8->1 8->1 8->1 8->6 8->7 8->9 8->15 8->24 9->11 9->12 9->13 9->21 9->22 9->28 9->33 9->40 9->45 9->45 9->49 9->53 10->7 11->22 12->10 14->1 14->1 14->8 14->16 15->1 15->1 15->16 15->18 15->19 15->25 15->29 15->34 15->41 15->46 15->47 15->51 16->1 16->6 16->7 16->8 16->9 16->14 16->17 16->20 16->23 16->27 16->27 16->44 16->48 16->50 16->52 17->1 18->1 18->26 18->35 19->1 19->1 19->25 20->6 20->10 20->22 22->12 22->12 22->13 23->1 23->8 23->14 23->17 24->15 24->15 24->37 24->41 24->41 24->44 24->47 24->47 25->1 25->1 25->6 25->10 25->16 25->18 25->26 25->26 25->30 25->31 25->35 25->35 26->9 26->9 26->13 26->22 26->25 26->32 26->32 26->35 26->37 26->39 26->42 26->43 26->45 27->1 27->1 27->6 27->10 27->18 27->22 27->25 28->11 28->21 29->1 30->1 31->1 33->28 34->1 34->19 34->29 35->1 35->1 35->1 35->36 35->42 35->42 36->31 37->1 37->1 37->37 37->38 37->38 37->39 37->44 37->54 37->55 38->1 38->37 39->1 39->1 39->1 39->6 39->10 39->18 39->22 39->25 41->1 41->34 42->1 43->1 43->37 44->24 45->22 45->33 45->40 46->1 47->1 47->1
>>>Token char * read_line ( FILE * fd ) { int ucrkarxcripu , i ; int gkyfyxwnxxqi = 0 ; char vyaheujgnlpx ; char * aux = qhaequabhdkw ; char * ykiwdxnwzubj = qhaequabhdkw ; while ( ( vyaheujgnlpx = ( char ) fgetc ( fd ) ) != EOF ) { if ( ( gkyfyxwnxxqi % BUFFER_SIZE ) == 0 ) { aux = ykiwdxnwzubj ; ykiwdxnwzubj = ( char * ) malloc ( sizeof ( char ) * ( gkyfyxwnxxqi + BUFFER_SIZE ) ) ; if ( ykiwdxnwzubj == qhaequabhdkw ) { if ( aux != qhaequabhdkw ) free ( aux ) ; perror ( " " ) ; return qhaequabhdkw ; } if ( aux != qhaequabhdkw ) { for ( i = 0 ; i < gkyfyxwnxxqi ; i ++ ) ykiwdxnwzubj [ i ] = aux [ i ] ; free ( aux ) ; } } if ( vyaheujgnlpx == ' ucrkarxcripu ' ) { ykiwdxnwzubj [ gkyfyxwnxxqi ] = ' \0 ' ; break ; } else { ykiwdxnwzubj [ gkyfyxwnxxqi ++ ] = vyaheujgnlpx ; } } aux = ykiwdxnwzubj ; if ( aux != qhaequabhdkw ) { ykiwdxnwzubj = ( char * ) malloc ( sizeof ( char ) * ( strlen ( aux ) + 1 ) ) ; ykiwdxnwzubj = strcpy ( ykiwdxnwzubj , aux ) ; free ( aux ) ; } return ykiwdxnwzubj ; }
>>>Func
METHOD rppkxdmtnprj
METHOD_RETURN int
PARAM char *line
<operator>.assignment ugfanvamskqw=0
<operator>.assignment txrmicmgezkl=0
RETURN return ugfanvamskqw; return ugfanvamskqw;
<operator>.logicalAnd line[txrmicmgezkl]>='0'&&line[txrmicmgezkl]<='9'
IDENTIFIER ugfanvamskqw return ugfanvamskqw;
<operator>.assignment ugfanvamskqw=ugfanvamskqw *10
<operator>.assignment ugfanvamskqw=ugfanvamskqw+line[txrmicmgezkl]-'0'
<operator>.assignmentPlus txrmicmgezkl+=1
<operator>.greaterEqualsThan line[txrmicmgezkl]>='0'
<operator>.lessEqualsThan line[txrmicmgezkl]<='9'
<operator>.multiplication ugfanvamskqw *10
<operator>.subtraction ugfanvamskqw+line[txrmicmgezkl]-'0'
<operator>.addition ugfanvamskqw+line[txrmicmgezkl]
<operator>.indirectIndexAccess line[txrmicmgezkl]
<operator>.indirectIndexAccess line[txrmicmgezkl]
<operator>.indirectIndexAccess line[txrmicmgezkl]
>>>PDG&19 0->2 0->3 0->4 0->7 0->10 0->11 0->12 0->13 0->14 0->15 2->1 2->11 2->12 2->14 2->15 3->1 3->1 3->7 3->13 4->1 4->1 4->10 5->1 6->1 6->1 6->1 6->6 6->8 6->9 6->10 6->11 6->13 6->14 6->15 6->16 6->18 7->5 8->1 8->1 8->14 8->15 9->1 9->1 9->1 9->7 9->13 10->1 10->1 11->1 11->6 11->6 11->12 11->12 11->14 11->15 11->17 12->1 12->6 12->6 12->11 12->14 12->15 13->8 13->8 14->1 14->9 14->9
>>>Token int rppkxdmtnprj ( char * line ) { int ugfanvamskqw = 0 ; int txrmicmgezkl = 0 ; while ( line [ txrmicmgezkl ] >= ' ' && line [ txrmicmgezkl ] <= ' ' ) { ugfanvamskqw = ugfanvamskqw * 10 ; ugfanvamskqw = ugfanvamskqw + line [ txrmicmgezkl ] - ' ' ; txrmicmgezkl += 1 ; } return ugfanvamskqw ; }
>>>Func
METHOD main
METHOD_RETURN int
freopen freopen("a1.in","r",stdin)
freopen freopen("a.out","w",stdout)
scanf scanf("%d",&goponyzzkrdn)
<operator>.lessEqualsThan kpbzppnpjvqh<=goponyzzkrdn
<operator>.postIncrement kpbzppnpjvqh++
<operator>.assignment kpbzppnpjvqh=1
memset memset((void *)dulduxibrvab 0 N *sizeof(player))
scanf scanf("%d\n",&n)
printf printf("Case #%d:\n",kpbzppnpjvqh)
<operator>.lessThan cdhwwfmgxfnh<n
<operator>.postIncrement cdhwwfmgxfnh++
<operator>.lessThan cdhwwfmgxfnh<n
<operator>.postIncrement cdhwwfmgxfnh++
<operator>.lessThan cdhwwfmgxfnh<n
<operator>.postIncrement cdhwwfmgxfnh++
<operator>.lessThan cdhwwfmgxfnh<n
<operator>.postIncrement cdhwwfmgxfnh++
<operator>.cast (void *)dulduxibrvab
<operator>.multiplication N *sizeof(player)
<operator>.assignment cdhwwfmgxfnh=0
<operator>.assignment dulduxibrvab[cdhwwfmgxfnh].wp=1.0 *dulduxibrvab[cdhwwfmgxfnh].w/(dulduxibrvab[cdhwwfmgxfnh].w+dulduxibrvab[cdhwwfmgxfnh].l)
scanf scanf("%c",&csadsmslrzon)
<operator>.assignment cdhwwfmgxfnh=0
<operator>.assignment mpluznpuaqkg=0
<operator>.assignment dulduxibrvab[cdhwwfmgxfnh].owp=mpluznpuaqkg/(dulduxibrvab[cdhwwfmgxfnh].w+dulduxibrvab[cdhwwfmgxfnh].l)
<operator>.assignment cdhwwfmgxfnh=0
<operator>.assignment mpluznpuaqkg=0
<operator>.assignment dulduxibrvab[cdhwwfmgxfnh].oowp=mpluznpuaqkg/(dulduxibrvab[cdhwwfmgxfnh].w+dulduxibrvab[cdhwwfmgxfnh].l)
<operator>.assignment cdhwwfmgxfnh=0
<operator>.assignment dulduxibrvab[cdhwwfmgxfnh].rpi=0.25 *dulduxibrvab[cdhwwfmgxfnh].wp+0.5 *dulduxibrvab[cdhwwfmgxfnh].owp+0.25 *dulduxibrvab[cdhwwfmgxfnh].oowp
printf printf("%f\n",dulduxibrvab[cdhwwfmgxfnh].rpi)
<operator>.sizeOf sizeof(player)
<operator>.lessThan psdfceycchuk<n
<operator>.postIncrement psdfceycchuk++
<operator>.lessThan psdfceycchuk<n
<operator>.postIncrement psdfceycchuk++
<operator>.lessThan psdfceycchuk<n
<operator>.postIncrement psdfceycchuk++
<operator>.assignment psdfceycchuk=0
scanf scanf("%c",&csadsmslrzon)
<operator>.assignment ichdznyhcqol[cdhwwfmgxfnh][psdfceycchuk]=csadsmslrzon
<operator>.division 1.0 *dulduxibrvab[cdhwwfmgxfnh].w/(dulduxibrvab[cdhwwfmgxfnh].w+dulduxibrvab[cdhwwfmgxfnh].l)
<operator>.assignment psdfceycchuk=0
<operator>.division mpluznpuaqkg/(dulduxibrvab[cdhwwfmgxfnh].w+dulduxibrvab[cdhwwfmgxfnh].l)
<operator>.assignment psdfceycchuk=0
<operator>.notEquals ichdznyhcqol[cdhwwfmgxfnh][psdfceycchuk]!='.'
<operator>.division mpluznpuaqkg/(dulduxibrvab[cdhwwfmgxfnh].w+dulduxibrvab[cdhwwfmgxfnh].l)
<operator>.addition 0.25 *dulduxibrvab[cdhwwfmgxfnh].wp+0.5 *dulduxibrvab[cdhwwfmgxfnh].owp+0.25 *dulduxibrvab[cdhwwfmgxfnh].oowp
<operator>.equals csadsmslrzon=='1'
<operator>.equals csadsmslrzon=='0'
<operator>.multiplication 1.0 *dulduxibrvab[cdhwwfmgxfnh].w
<operator>.addition dulduxibrvab[cdhwwfmgxfnh].w+dulduxibrvab[cdhwwfmgxfnh].l
<operator>.equals ichdznyhcqol[cdhwwfmgxfnh][psdfceycchuk]=='0'
<operator>.equals ichdznyhcqol[cdhwwfmgxfnh][psdfceycchuk]=='1'
<operator>.assignmentPlus mpluznpuaqkg+=dulduxibrvab[psdfceycchuk].owp
<operator>.addition 0.25 *dulduxibrvab[cdhwwfmgxfnh].wp+0.5 *dulduxibrvab[cdhwwfmgxfnh].owp
<operator>.multiplication 0.25 *dulduxibrvab[cdhwwfmgxfnh].oowp
<operator>.postIncrement dulduxibrvab[cdhwwfmgxfnh].w++
<operator>.postIncrement dulduxibrvab[cdhwwfmgxfnh].l++
<operator>.assignmentPlus mpluznpuaqkg+=(dulduxibrvab[psdfceycchuk].w-1)*1.0/(dulduxibrvab[psdfceycchuk].w+dulduxibrvab[psdfceycchuk].l-1)
<operator>.assignmentPlus mpluznpuaqkg+=dulduxibrvab[psdfceycchuk].w *1.0/(dulduxibrvab[psdfceycchuk].w+dulduxibrvab[psdfceycchuk].l-1)
<operator>.multiplication 0.25 *dulduxibrvab[cdhwwfmgxfnh].wp
<operator>.multiplication 0.5 *dulduxibrvab[cdhwwfmgxfnh].owp
<operator>.division (dulduxibrvab[psdfceycchuk].w-1)*1.0/(dulduxibrvab[psdfceycchuk].w+dulduxibrvab[psdfceycchuk].l-1)
<operator>.division dulduxibrvab[psdfceycchuk].w *1.0/(dulduxibrvab[psdfceycchuk].w+dulduxibrvab[psdfceycchuk].l-1)
<operator>.multiplication (dulduxibrvab[psdfceycchuk].w-1)*1.0
<operator>.subtraction dulduxibrvab[psdfceycchuk].w+dulduxibrvab[psdfceycchuk].l-1
<operator>.multiplication dulduxibrvab[psdfceycchuk].w *1.0
<operator>.subtraction dulduxibrvab[psdfceycchuk].w+dulduxibrvab[psdfceycchuk].l-1
<operator>.subtraction dulduxibrvab[psdfceycchuk].w-1
<operator>.addition dulduxibrvab[psdfceycchuk].w+dulduxibrvab[psdfceycchuk].l
<operator>.addition dulduxibrvab[psdfceycchuk].w+dulduxibrvab[psdfceycchuk].l
<operator>.addressOf &n
UNKNOWN void * void *
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].wp
<operator>.addressOf &csadsmslrzon
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].owp
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].oowp
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].rpi
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].rpi
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER wp wp
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER owp owp
<operator>.addition dulduxibrvab[cdhwwfmgxfnh].w+dulduxibrvab[cdhwwfmgxfnh].l
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER oowp oowp
<operator>.addition dulduxibrvab[cdhwwfmgxfnh].w+dulduxibrvab[cdhwwfmgxfnh].l
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER rpi rpi
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER rpi rpi
<operator>.addressOf &csadsmslrzon
<operator>.indirectIndexAccess ichdznyhcqol[cdhwwfmgxfnh][psdfceycchuk]
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].w
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].w
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].l
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].w
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].l
<operator>.indirectIndexAccess ichdznyhcqol[cdhwwfmgxfnh][psdfceycchuk]
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].w
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].l
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].oowp
<operator>.indirectIndexAccess ichdznyhcqol[cdhwwfmgxfnh]
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER l l
<operator>.indirectIndexAccess ichdznyhcqol[cdhwwfmgxfnh][psdfceycchuk]
<operator>.indirectIndexAccess ichdznyhcqol[cdhwwfmgxfnh][psdfceycchuk]
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER l l
<operator>.indirectIndexAccess ichdznyhcqol[cdhwwfmgxfnh]
<operator>.fieldAccess dulduxibrvab[psdfceycchuk].owp
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER l l
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].wp
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].owp
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER oowp oowp
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].w
<operator>.fieldAccess dulduxibrvab[cdhwwfmgxfnh].l
<operator>.indirectIndexAccess ichdznyhcqol[cdhwwfmgxfnh]
<operator>.indirectIndexAccess ichdznyhcqol[cdhwwfmgxfnh]
<operator>.indirectIndexAccess dulduxibrvab[psdfceycchuk]
FIELD_IDENTIFIER owp owp
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER wp wp
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER owp owp
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess dulduxibrvab[cdhwwfmgxfnh]
FIELD_IDENTIFIER l l
<operator>.fieldAccess dulduxibrvab[psdfceycchuk].w
<operator>.fieldAccess dulduxibrvab[psdfceycchuk].w
<operator>.fieldAccess dulduxibrvab[psdfceycchuk].w
<operator>.fieldAccess dulduxibrvab[psdfceycchuk].l
<operator>.indirectIndexAccess dulduxibrvab[psdfceycchuk]
FIELD_IDENTIFIER w w
<operator>.fieldAccess dulduxibrvab[psdfceycchuk].w
<operator>.fieldAccess dulduxibrvab[psdfceycchuk].l
<operator>.indirectIndexAccess dulduxibrvab[psdfceycchuk]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess dulduxibrvab[psdfceycchuk]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess dulduxibrvab[psdfceycchuk]
FIELD_IDENTIFIER l l
<operator>.indirectIndexAccess dulduxibrvab[psdfceycchuk]
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess dulduxibrvab[psdfceycchuk]
FIELD_IDENTIFIER l l
>>>PDG&160 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->24 0->25 0->27 0->28 0->30 0->32 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->54 0->55 0->56 0->58 0->61 0->62 0->63 0->64 0->67 0->68 0->69 0->70 0->71 2->1 2->1 3->1 3->1 4->1 4->5 5->1 5->1 5->1 5->5 5->6 5->8 5->9 5->10 5->10 5->11 5->13 5->15 5->17 5->19 5->20 5->21 5->24 5->27 5->30 5->33 5->74 5->75 6->1 6->5 7->1 7->5 8->1 8->1 8->1 9->1 9->11 9->13 9->15 9->17 9->34 9->36 9->38 10->1 10->6 11->11 11->12 11->12 11->13 11->22 11->23 11->34 11->34 11->40 11->43 11->52 11->53 11->76 11->77 11->82 11->83 11->96 11->97 11->98 11->106 11->107 11->108 11->109 11->110 11->111 12->1 12->11 13->13 13->14 13->14 13->15 13->25 13->26 13->36 13->36 13->44 13->45 13->78 13->84 13->85 13->86 13->99 13->100 13->114 13->115 13->116 13->117 14->1 14->13 15->15 15->16 15->16 15->17 15->28 15->29 15->38 15->38 15->46 15->48 15->79 15->87 15->88 15->89 15->102 15->103 15->120 15->121 15->122 15->123 16->1 16->15 17->1 17->1 17->1 17->9 17->11 17->17 17->18 17->18 17->31 17->32 17->49 17->57 17->58 17->63 17->64 17->80 17->81 17->90 17->91 17->92 17->93 17->104 17->124 17->125 17->126 17->127 17->134 17->135 17->136 17->137 18->1 18->17 19->1 20->1 20->8 21->11 22->1 22->1 23->1 23->41 23->42 23->50 24->13 25->1 25->45 25->61 25->62 26->1 26->1 27->15 28->1 28->48 28->56 29->1 29->1 30->1 30->17 31->1 31->1 31->32 32->1 33->1 34->1 34->1 34->11 34->34 34->35 34->35 34->41 34->42 34->50 34->51 34->94 34->95 34->105 35->1 35->34 36->1 36->1 36->13 36->36 36->37 36->37 36->54 36->55 36->112 36->113 36->130 36->131 37->1 37->36 38->1 38->1 38->15 38->38 38->39 38->39 38->47 38->101 38->118 39->1 39->38 40->1 40->34 41->23 41->42 41->50 41->51 42->1 42->1 42->47 42->54 43->1 43->1 43->22 43->22 44->1 44->36 45->1 45->1 45->26 45->26 46->1 46->38 47->1 47->1 47->54 47->56 47->119 47->132 47->133 48->1 48->1 48->29 48->29 49->1 49->1 50->1 50->51 50->59 50->128 50->138 50->139 51->1 51->1 51->23 51->41 51->42 51->50 51->60 51->129 51->140 51->141 52->43 52->43 52->53 54->1 54->55 54->61 54->65 54->67 54->68 54->71 54->72 54->143 54->144 54->145 54->150 54->151 54->152 54->153 54->154 54->155 55->1 55->1 55->47 55->54 55->62 55->66 55->69 55->70 55->73 55->142 55->146 55->147 55->148 55->149 55->156 55->157 55->158 55->159 56->1 56->48 57->1 57->1 58->31 58->31 58->49 58->49 59->1 59->52 60->1 60->43 60->53 61->1 61->1 61->45 61->62 62->1 62->1 62->45 62->61 63->31 63->31 63->49 63->49 63->57 63->57 64->31 64->31 64->49 64->49 64->57 64->57 65->1 65->1 65->61 65->61 66->1 66->1 66->62 66->62 67->1 67->65 67->65 68->1 68->65 68->65 69->66 69->66 69->70 69->73 70->1 70->66 70->66 71->67 71->67 71->68 71->69 71->72
>>>Token int main ( ) { int goponyzzkrdn , n ; player dulduxibrvab [ N ] ; char ichdznyhcqol [ N ] [ N ] ; char csadsmslrzon ; freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; scanf ( " " , & goponyzzkrdn ) ; for ( int kpbzppnpjvqh = 1 ; kpbzppnpjvqh <= goponyzzkrdn ; kpbzppnpjvqh ++ ) { memset ( ( void * ) dulduxibrvab , 0 , N * sizeof ( player ) ) ; scanf ( " \n " , & n ) ; for ( int cdhwwfmgxfnh = 0 ; cdhwwfmgxfnh < n ; cdhwwfmgxfnh ++ ) { for ( int psdfceycchuk = 0 ; psdfceycchuk < n ; psdfceycchuk ++ ) { scanf ( " " , & csadsmslrzon ) ; ichdznyhcqol [ cdhwwfmgxfnh ] [ psdfceycchuk ] = csadsmslrzon ; if ( csadsmslrzon == ' ' ) dulduxibrvab [ cdhwwfmgxfnh ] . w ++ ; if ( csadsmslrzon == ' ' ) dulduxibrvab [ cdhwwfmgxfnh ] . l ++ ; } dulduxibrvab [ cdhwwfmgxfnh ] . wp = 1.0 * dulduxibrvab [ cdhwwfmgxfnh ] . w / ( dulduxibrvab [ cdhwwfmgxfnh ] . w + dulduxibrvab [ cdhwwfmgxfnh ] . l ) ; scanf ( " " , & csadsmslrzon ) ; } for ( int cdhwwfmgxfnh = 0 ; cdhwwfmgxfnh < n ; cdhwwfmgxfnh ++ ) { double mpluznpuaqkg = 0 ; for ( int psdfceycchuk = 0 ; psdfceycchuk < n ; psdfceycchuk ++ ) { if ( ichdznyhcqol [ cdhwwfmgxfnh ] [ psdfceycchuk ] == ' ' ) mpluznpuaqkg += ( dulduxibrvab [ psdfceycchuk ] . w - 1 ) * 1.0 / ( dulduxibrvab [ psdfceycchuk ] . w + dulduxibrvab [ psdfceycchuk ] . l - 1 ) ; if ( ichdznyhcqol [ cdhwwfmgxfnh ] [ psdfceycchuk ] == ' ' ) mpluznpuaqkg += dulduxibrvab [ psdfceycchuk ] . w * 1.0 / ( dulduxibrvab [ psdfceycchuk ] . w + dulduxibrvab [ psdfceycchuk ] . l - 1 ) ; } dulduxibrvab [ cdhwwfmgxfnh ] . owp = mpluznpuaqkg / ( dulduxibrvab [ cdhwwfmgxfnh ] . w + dulduxibrvab [ cdhwwfmgxfnh ] . l ) ; } for ( int cdhwwfmgxfnh = 0 ; cdhwwfmgxfnh < n ; cdhwwfmgxfnh ++ ) { double mpluznpuaqkg = 0 ; for ( int psdfceycchuk = 0 ; psdfceycchuk < n ; psdfceycchuk ++ ) if ( ichdznyhcqol [ cdhwwfmgxfnh ] [ psdfceycchuk ] != ' ' ) mpluznpuaqkg += dulduxibrvab [ psdfceycchuk ] . owp ; dulduxibrvab [ cdhwwfmgxfnh ] . oowp = mpluznpuaqkg / ( dulduxibrvab [ cdhwwfmgxfnh ] . w + dulduxibrvab [ cdhwwfmgxfnh ] . l ) ; } printf ( " \n " , kpbzppnpjvqh ) ; for ( int cdhwwfmgxfnh = 0 ; cdhwwfmgxfnh < n ; cdhwwfmgxfnh ++ ) { dulduxibrvab [ cdhwwfmgxfnh ] . rpi = 0.25 * dulduxibrvab [ cdhwwfmgxfnh ] . wp + 0.5 * dulduxibrvab [ cdhwwfmgxfnh ] . owp + 0.25 * dulduxibrvab [ cdhwwfmgxfnh ] . oowp ; printf ( " \n " , dulduxibrvab [ cdhwwfmgxfnh ] . rpi ) ; } } }
>>>Func
METHOD xyvlvmpvaggt
METHOD_RETURN void
PARAM int htwctwjranac
PARAM char rurlyhdxraxe [ ][4]
<operator>.lessThan vheuwzcxnwuv<htwctwjranac
<operator>.postIncrement vheuwzcxnwuv++
<operator>.assignment vheuwzcxnwuv=0
<operator>.assignment elem[IDX(rurlyhdxraxe[vheuwzcxnwuv][0])].opposed_elem=IDX(rurlyhdxraxe[vheuwzcxnwuv][1])
<operator>.assignment elem[IDX(rurlyhdxraxe[vheuwzcxnwuv][1])].opposed_elem=IDX(rurlyhdxraxe[vheuwzcxnwuv][0])
IDX IDX(rurlyhdxraxe[vheuwzcxnwuv][1])
IDX IDX(rurlyhdxraxe[vheuwzcxnwuv][0])
IDX IDX(rurlyhdxraxe[vheuwzcxnwuv][0])
IDX IDX(rurlyhdxraxe[vheuwzcxnwuv][1])
<operator>.fieldAccess elem[IDX(rurlyhdxraxe[vheuwzcxnwuv][0])].opposed_elem
<operator>.fieldAccess elem[IDX(rurlyhdxraxe[vheuwzcxnwuv][1])].opposed_elem
<operator>.indirectIndexAccess elem[IDX(rurlyhdxraxe[vheuwzcxnwuv][0])]
FIELD_IDENTIFIER opposed_elem opposed_elem
<operator>.indirectIndexAccess rurlyhdxraxe[vheuwzcxnwuv][1]
<operator>.indirectIndexAccess elem[IDX(rurlyhdxraxe[vheuwzcxnwuv][1])]
FIELD_IDENTIFIER opposed_elem opposed_elem
<operator>.indirectIndexAccess rurlyhdxraxe[vheuwzcxnwuv][0]
<operator>.indirectIndexAccess rurlyhdxraxe[vheuwzcxnwuv]
<operator>.indirectIndexAccess rurlyhdxraxe[vheuwzcxnwuv]
<operator>.indirectIndexAccess rurlyhdxraxe[vheuwzcxnwuv][0]
<operator>.indirectIndexAccess rurlyhdxraxe[vheuwzcxnwuv][1]
<operator>.indirectIndexAccess rurlyhdxraxe[vheuwzcxnwuv]
<operator>.indirectIndexAccess rurlyhdxraxe[vheuwzcxnwuv]
>>>PDG&27 0->2 0->3 0->4 0->5 0->6 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->7 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->18 4->19 4->20 4->21 4->22 4->23 4->24 4->25 4->26 5->1 5->4 6->1 6->4 9->7 9->12 10->8 10->11 11->10 12->9
>>>Token void xyvlvmpvaggt ( int htwctwjranac , char rurlyhdxraxe [ ] [ 4 ] ) { int vheuwzcxnwuv ; for ( vheuwzcxnwuv = 0 ; vheuwzcxnwuv < htwctwjranac ; vheuwzcxnwuv ++ ) { elem [ IDX ( rurlyhdxraxe [ vheuwzcxnwuv ] [ 0 ] ) ] . opposed_elem = IDX ( rurlyhdxraxe [ vheuwzcxnwuv ] [ 1 ] ) ; elem [ IDX ( rurlyhdxraxe [ vheuwzcxnwuv ] [ 1 ] ) ] . opposed_elem = IDX ( rurlyhdxraxe [ vheuwzcxnwuv ] [ 0 ] ) ; } }
>>>Func
METHOD cnlgtvicclqw
METHOD_RETURN int
PARAM char qfkvqxgmplez
PARAM char uqhuodrouesm
<operator>.assignment pmagtkobetgx=deleteRules[giveIndex(qfkvqxgmplez)][giveIndex(uqhuodrouesm)]
RETURN return pmagtkobetgx; return pmagtkobetgx;
<operator>.logicalAnd (qfkvqxgmplez!='Q')&&(qfkvqxgmplez!='W')&&(qfkvqxgmplez!='E')&&(qfkvqxgmplez!='R')&&(qfkvqxgmplez!='A')&&(qfkvqxgmplez!='S')&&(qfkvqxgmplez!='D')&&(qfkvqxgmplez!='F')
<operator>.logicalAnd (uqhuodrouesm!='Q')&&(uqhuodrouesm!='W')&&(uqhuodrouesm!='E')&&(uqhuodrouesm!='R')&&(uqhuodrouesm!='A')&&(uqhuodrouesm!='S')&&(uqhuodrouesm!='D')&&(uqhuodrouesm!='F')
IDENTIFIER pmagtkobetgx return pmagtkobetgx;
RETURN return 0; return 0;
RETURN return 0; return 0;
<operator>.logicalAnd (qfkvqxgmplez!='Q')&&(qfkvqxgmplez!='W')&&(qfkvqxgmplez!='E')&&(qfkvqxgmplez!='R')&&(qfkvqxgmplez!='A')&&(qfkvqxgmplez!='S')&&(qfkvqxgmplez!='D')
<operator>.notEquals qfkvqxgmplez!='F'
LITERAL 0 return 0;
<operator>.logicalAnd (uqhuodrouesm!='Q')&&(uqhuodrouesm!='W')&&(uqhuodrouesm!='E')&&(uqhuodrouesm!='R')&&(uqhuodrouesm!='A')&&(uqhuodrouesm!='S')&&(uqhuodrouesm!='D')
<operator>.notEquals uqhuodrouesm!='F'
LITERAL 0 return 0;
giveIndex giveIndex(uqhuodrouesm)
<operator>.logicalAnd (qfkvqxgmplez!='Q')&&(qfkvqxgmplez!='W')&&(qfkvqxgmplez!='E')&&(qfkvqxgmplez!='R')&&(qfkvqxgmplez!='A')&&(qfkvqxgmplez!='S')
<operator>.notEquals qfkvqxgmplez!='D'
<operator>.logicalAnd (uqhuodrouesm!='Q')&&(uqhuodrouesm!='W')&&(uqhuodrouesm!='E')&&(uqhuodrouesm!='R')&&(uqhuodrouesm!='A')&&(uqhuodrouesm!='S')
<operator>.notEquals uqhuodrouesm!='D'
giveIndex giveIndex(qfkvqxgmplez)
<operator>.logicalAnd (qfkvqxgmplez!='Q')&&(qfkvqxgmplez!='W')&&(qfkvqxgmplez!='E')&&(qfkvqxgmplez!='R')&&(qfkvqxgmplez!='A')
<operator>.notEquals qfkvqxgmplez!='S'
<operator>.logicalAnd (uqhuodrouesm!='Q')&&(uqhuodrouesm!='W')&&(uqhuodrouesm!='E')&&(uqhuodrouesm!='R')&&(uqhuodrouesm!='A')
<operator>.notEquals uqhuodrouesm!='S'
<operator>.logicalAnd (qfkvqxgmplez!='Q')&&(qfkvqxgmplez!='W')&&(qfkvqxgmplez!='E')&&(qfkvqxgmplez!='R')
<operator>.notEquals qfkvqxgmplez!='A'
<operator>.logicalAnd (uqhuodrouesm!='Q')&&(uqhuodrouesm!='W')&&(uqhuodrouesm!='E')&&(uqhuodrouesm!='R')
<operator>.notEquals uqhuodrouesm!='A'
<operator>.logicalAnd (qfkvqxgmplez!='Q')&&(qfkvqxgmplez!='W')&&(qfkvqxgmplez!='E')
<operator>.notEquals qfkvqxgmplez!='R'
<operator>.logicalAnd (uqhuodrouesm!='Q')&&(uqhuodrouesm!='W')&&(uqhuodrouesm!='E')
<operator>.notEquals uqhuodrouesm!='R'
<operator>.logicalAnd (qfkvqxgmplez!='Q')&&(qfkvqxgmplez!='W')
<operator>.notEquals qfkvqxgmplez!='E'
<operator>.logicalAnd (uqhuodrouesm!='Q')&&(uqhuodrouesm!='W')
<operator>.notEquals uqhuodrouesm!='E'
<operator>.notEquals qfkvqxgmplez!='Q'
<operator>.notEquals qfkvqxgmplez!='W'
<operator>.notEquals uqhuodrouesm!='Q'
<operator>.notEquals uqhuodrouesm!='W'
<operator>.indirectIndexAccess deleteRules[giveIndex(qfkvqxgmplez)][giveIndex(uqhuodrouesm)]
<operator>.indirectIndexAccess deleteRules[giveIndex(qfkvqxgmplez)]
>>>PDG&45 0->2 0->3 0->8 0->9 0->10 0->12 0->13 0->15 0->16 0->17 0->19 0->21 0->22 0->24 0->26 0->28 0->30 0->32 0->34 0->36 0->38 0->39 0->40 0->41 0->42 2->39 3->1 3->41 4->8 5->1 6->1 6->1 6->1 6->7 6->9 6->14 6->20 6->25 6->29 6->33 6->37 6->41 7->4 7->5 7->10 7->17 7->22 7->43 7->44 8->5 9->1 10->1 11->1 11->1 11->6 11->6 11->12 12->1 12->6 12->6 12->22 13->9 14->7 14->7 14->15 15->7 15->7 15->17 16->10 18->1 18->1 18->11 18->11 18->19 19->1 19->11 19->11 19->12 19->22 20->14 20->14 20->21 21->14 21->14 21->15 21->17 23->1 23->1 23->18 23->18 23->24 24->1 24->12 24->18 24->18 24->19 24->22 25->20 25->20 25->26 26->15 26->17 26->20 26->20 26->21 27->1 27->1 27->23 27->23 27->28 28->1 28->12 28->19 28->22 28->23 28->23 28->24 29->25 29->25 29->30 30->15 30->17 30->21 30->25 30->25 30->26 31->1 31->1 31->27 31->27 31->32 32->1 32->12 32->19 32->22 32->24 32->27 32->27 32->28 33->29 33->29 33->34 34->15 34->17 34->21 34->26 34->29 34->29 34->30 35->1 35->1 35->31 35->31 35->36 36->1 36->12 36->19 36->22 36->24 36->28 36->31 36->31 36->32 37->33 37->33 37->38 38->15 38->17 38->21 38->26 38->30 38->33 38->33 38->34 39->1 39->12 39->19 39->22 39->24 39->28 39->32 39->35 39->35 39->36 39->40 39->40 40->1 40->12 40->19 40->22 40->24 40->28 40->32 40->35 40->35 40->36 41->15 41->17 41->21 41->26 41->30 41->34 41->37 41->37 41->38 41->42 41->42 42->15 42->17 42->21 42->26 42->30 42->34 42->37 42->37 42->38
>>>Token int cnlgtvicclqw ( char qfkvqxgmplez , char uqhuodrouesm ) { if ( ( qfkvqxgmplez != ' ' ) && ( qfkvqxgmplez != ' ' ) && ( qfkvqxgmplez != ' ' ) && ( qfkvqxgmplez != ' ' ) && ( qfkvqxgmplez != ' ' ) && ( qfkvqxgmplez != ' ' ) && ( qfkvqxgmplez != ' ' ) && ( qfkvqxgmplez != ' ' ) ) return 0 ; if ( ( uqhuodrouesm != ' ' ) && ( uqhuodrouesm != ' ' ) && ( uqhuodrouesm != ' ' ) && ( uqhuodrouesm != ' ' ) && ( uqhuodrouesm != ' ' ) && ( uqhuodrouesm != ' ' ) && ( uqhuodrouesm != ' ' ) && ( uqhuodrouesm != ' ' ) ) return 0 ; int pmagtkobetgx = deleteRules [ giveIndex ( qfkvqxgmplez ) ] [ giveIndex ( uqhuodrouesm ) ] ; return pmagtkobetgx ; }
>>>Func
METHOD wyyfzefwqrtc
METHOD_RETURN int
PARAM char *s
PARAM int faqfbgjhjiuv
PARAM int vwochimsrofs
PARAM int mmebmuyhoccb
RETURN return mmebmuyhoccb-(vwochimsrofs-faqfbgjhjiuv); return mmebmuyhoccb-(vwochimsrofs-faqfbgjhjiuv);
<operator>.lessEqualsThan vwochimsrofs<=mmebmuyhoccb
<operator>.assignment s[faqfbgjhjiuv++]=s[vwochimsrofs++]
<operator>.subtraction mmebmuyhoccb-(vwochimsrofs-faqfbgjhjiuv)
<operator>.subtraction vwochimsrofs-faqfbgjhjiuv
<operator>.postIncrement faqfbgjhjiuv++
<operator>.postIncrement vwochimsrofs++
<operator>.indirectIndexAccess s[faqfbgjhjiuv++]
<operator>.indirectIndexAccess s[vwochimsrofs++]
>>>PDG&15 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->11 0->12 2->1 2->8 3->10 3->11 4->7 5->7 6->1 7->1 7->7 7->8 7->9 7->10 7->11 7->12 7->12 7->13 7->14 9->1 9->1 9->1 9->6 10->1 10->1 10->9 10->9
>>>Token int wyyfzefwqrtc ( char * s , int faqfbgjhjiuv , int vwochimsrofs , int mmebmuyhoccb ) { while ( vwochimsrofs <= mmebmuyhoccb ) s [ faqfbgjhjiuv ++ ] = s [ vwochimsrofs ++ ] ; return mmebmuyhoccb - ( vwochimsrofs - faqfbgjhjiuv ) ; }
>>>Func
METHOD gltpxiqnurmd
METHOD_RETURN int
PARAM void
RETURN return qvdxvatddiey(qsxgghgtulxn); return qvdxvatddiey(qsxgghgtulxn);
<operator>.logicalOr qsxgghgtulxn<'A'||qsxgghgtulxn>'Z'
qvdxvatddiey qvdxvatddiey(qsxgghgtulxn)
<operator>.assignment qsxgghgtulxn=getchar()
<operator>.lessThan qsxgghgtulxn<'A'
<operator>.greaterThan qsxgghgtulxn>'Z'
getchar getchar()
>>>PDG&10 0->2 0->5 0->6 0->7 0->8 2->1 3->1 4->1 4->1 4->1 4->4 4->6 4->7 4->9 5->1 5->1 5->3 6->1 6->1 6->7 7->4 7->4 7->5 7->8 7->8 8->4 8->4 8->5
>>>Token int gltpxiqnurmd ( void ) { int qsxgghgtulxn ; do { qsxgghgtulxn = getchar ( ) ; } while ( qsxgghgtulxn < ' ' || qsxgghgtulxn > ' ' ) ; return qvdxvatddiey ( qsxgghgtulxn ) ; }
>>>Func
METHOD npqhbnaswbdl
METHOD_RETURN int
<operator>.assignment rxzarxymofnu=0
<operator>.assignment tzcsdibhdokk[rxzarxymofnu]='\0'
<operator>.assignment n=rxzarxymofnu
strcpy strcpy(s,tzcsdibhdokk)
RETURN return 1; return 1;
<operator>.lessThan iostkyyupigy<n
<operator>.postIncrement iostkyyupigy++
<operator>.lessThan iostkyyupigy<n
<operator>.postIncrement iostkyyupigy++
<operator>.equals iostkyyupigy==n
<operator>.lessThan tooghgvfhbxn<iostkyyupigy
<operator>.postIncrement tooghgvfhbxn++
<operator>.assignment tzcsdibhdokk[rxzarxymofnu++]=s[tooghgvfhbxn]
<operator>.logicalAnd fghvijictccy==iostkyyupigy+1&&tab0[s[iostkyyupigy]-'A'][s[fghvijictccy]-'A']>0
<operator>.lessThan tooghgvfhbxn<n
<operator>.postIncrement tooghgvfhbxn++
<operator>.assignment tzcsdibhdokk[rxzarxymofnu++]=s[tooghgvfhbxn]
LITERAL 1 return 1;
<operator>.assignment iostkyyupigy=0
<operator>.assignment ulanxeuzrimk[iostkyyupigy]=-1
<operator>.assignment iostkyyupigy=0
<operator>.assignment fghvijictccy=-1
<operator>.assignment fghvijictccy=ulanxeuzrimk[iostkyyupigy]
RETURN return 0; return 0;
<operator>.assignment tooghgvfhbxn=0
<operator>.assignment tzcsdibhdokk[rxzarxymofnu++]=tab0[s[iostkyyupigy]-'A'][s[fghvijictccy]-'A']
<operator>.assignment tooghgvfhbxn=fghvijictccy+1
<operator>.lessThan tooghgvfhbxn<n
<operator>.postIncrement tooghgvfhbxn++
<operator>.equals ulanxeuzrimk[iostkyyupigy]==-1
LITERAL 1 while (1)
LITERAL 0 return 0;
<operator>.equals fghvijictccy==iostkyyupigy+1
<operator>.greaterThan tab0[s[iostkyyupigy]-'A'][s[fghvijictccy]-'A']>0
<operator>.minus -1
<operator>.assignment tooghgvfhbxn=iostkyyupigy+1
<operator>.minus -1
<operator>.assignment iostkyyupigy=tooghgvfhbxn
<operator>.assignment fghvijictccy=ulanxeuzrimk[iostkyyupigy]
<operator>.postIncrement rxzarxymofnu++
<operator>.addition iostkyyupigy+1
<operator>.addition fghvijictccy+1
<operator>.postIncrement rxzarxymofnu++
<operator>.logicalOr tab0[s[iostkyyupigy]-'A'][s[tooghgvfhbxn]-'A']>0&&tooghgvfhbxn==iostkyyupigy+1||tab1[s[iostkyyupigy]-'A'][s[tooghgvfhbxn]-'A']>0
<operator>.minus -1
<operator>.lessThan tooghgvfhbxn<fghvijictccy
<operator>.postIncrement tooghgvfhbxn++
<operator>.equals tooghgvfhbxn==fghvijictccy
<operator>.subtraction s[fghvijictccy]-'A'
<operator>.postIncrement rxzarxymofnu++
<operator>.subtraction s[fghvijictccy]-'A'
<operator>.addition iostkyyupigy+1
<operator>.assignment ulanxeuzrimk[iostkyyupigy]=tooghgvfhbxn
<operator>.assignment tooghgvfhbxn=iostkyyupigy+1
<operator>.subtraction s[iostkyyupigy]-'A'
<operator>.subtraction s[iostkyyupigy]-'A'
<operator>.logicalAnd tab0[s[iostkyyupigy]-'A'][s[tooghgvfhbxn]-'A']>0&&tooghgvfhbxn==iostkyyupigy+1
<operator>.greaterThan tab1[s[iostkyyupigy]-'A'][s[tooghgvfhbxn]-'A']>0
<operator>.logicalAnd ulanxeuzrimk[tooghgvfhbxn]>0&&ulanxeuzrimk[tooghgvfhbxn]<=fghvijictccy
<operator>.greaterThan tab0[s[iostkyyupigy]-'A'][s[tooghgvfhbxn]-'A']>0
<operator>.equals tooghgvfhbxn==iostkyyupigy+1
<operator>.addition iostkyyupigy+1
<operator>.addition iostkyyupigy+1
<operator>.subtraction s[tooghgvfhbxn]-'A'
<operator>.greaterThan ulanxeuzrimk[tooghgvfhbxn]>0
<operator>.lessEqualsThan ulanxeuzrimk[tooghgvfhbxn]<=fghvijictccy
<operator>.subtraction s[tooghgvfhbxn]-'A'
<operator>.subtraction s[iostkyyupigy]-'A'
<operator>.subtraction s[iostkyyupigy]-'A'
<operator>.indirectIndexAccess tzcsdibhdokk[rxzarxymofnu]
<operator>.indirectIndexAccess tzcsdibhdokk[rxzarxymofnu++]
<operator>.indirectIndexAccess s[tooghgvfhbxn]
<operator>.indirectIndexAccess tzcsdibhdokk[rxzarxymofnu++]
<operator>.indirectIndexAccess s[tooghgvfhbxn]
<operator>.indirectIndexAccess ulanxeuzrimk[iostkyyupigy]
<operator>.indirectIndexAccess ulanxeuzrimk[iostkyyupigy]
<operator>.indirectIndexAccess tab0[s[iostkyyupigy]-'A'][s[fghvijictccy]-'A']
<operator>.indirectIndexAccess tzcsdibhdokk[rxzarxymofnu++]
<operator>.indirectIndexAccess tab0[s[iostkyyupigy]-'A'][s[fghvijictccy]-'A']
<operator>.indirectIndexAccess ulanxeuzrimk[iostkyyupigy]
<operator>.indirectIndexAccess tab0[s[iostkyyupigy]-'A']
<operator>.indirectIndexAccess tab0[s[iostkyyupigy]-'A']
<operator>.indirectIndexAccess ulanxeuzrimk[iostkyyupigy]
<operator>.indirectIndexAccess s[fghvijictccy]
<operator>.indirectIndexAccess s[fghvijictccy]
<operator>.indirectIndexAccess s[iostkyyupigy]
<operator>.indirectIndexAccess s[iostkyyupigy]
<operator>.indirectIndexAccess tab1[s[iostkyyupigy]-'A'][s[tooghgvfhbxn]-'A']
<operator>.indirectIndexAccess ulanxeuzrimk[iostkyyupigy]
<operator>.indirectIndexAccess tab0[s[iostkyyupigy]-'A'][s[tooghgvfhbxn]-'A']
<operator>.indirectIndexAccess tab1[s[iostkyyupigy]-'A']
<operator>.indirectIndexAccess tab0[s[iostkyyupigy]-'A']
<operator>.indirectIndexAccess s[tooghgvfhbxn]
<operator>.indirectIndexAccess ulanxeuzrimk[tooghgvfhbxn]
<operator>.indirectIndexAccess ulanxeuzrimk[tooghgvfhbxn]
<operator>.indirectIndexAccess s[tooghgvfhbxn]
<operator>.indirectIndexAccess s[iostkyyupigy]
<operator>.indirectIndexAccess s[iostkyyupigy]
>>>PDG&100 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->16 0->17 0->19 0->20 0->22 0->25 0->26 0->28 0->29 0->30 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->59 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 2->1 2->1 2->4 2->41 2->44 2->51 3->5 6->1 7->7 7->8 7->8 7->9 7->21 7->29 7->29 7->36 7->37 7->37 7->53 7->53 7->62 7->64 7->76 8->1 8->7 9->1 9->10 9->11 9->11 9->23 9->31 9->38 9->46 9->55 9->63 9->81 10->1 10->9 11->1 11->1 11->1 11->3 11->4 11->5 11->6 11->12 11->12 11->15 11->16 11->16 11->25 11->26 11->28 11->34 11->42 11->43 11->71 12->12 12->13 12->13 12->14 12->34 12->41 12->42 12->72 12->73 13->12 14->5 15->27 15->51 15->52 15->57 15->79 15->80 15->83 15->86 15->88 16->16 16->17 16->17 16->18 16->44 16->74 16->75 17->16 18->5 19->6 20->7 21->1 21->1 21->1 21->31 22->1 22->9 23->1 23->1 23->34 24->1 24->1 24->1 24->34 24->47 25->1 26->12 27->5 28->16 29->1 29->1 29->7 29->30 29->45 29->54 29->58 29->61 29->62 29->68 29->70 29->91 29->93 29->97 29->99 30->1 30->29 31->1 31->1 31->1 31->9 31->10 31->24 31->24 31->40 31->47 31->49 31->55 31->63 31->77 33->25 34->15 34->15 34->28 34->35 34->43 34->50 34->56 34->78 34->82 34->85 34->87 35->15 35->15 35->27 36->21 37->1 37->1 37->29 38->23 39->1 39->1 39->11 39->55 39->63 40->1 40->1 40->1 40->34 40->47 41->4 41->44 41->51 44->4 45->1 45->1 45->1 45->29 45->30 45->54 45->90 46->31 47->1 47->48 47->49 47->49 47->60 47->66 47->67 47->95 48->1 48->47 49->1 49->1 49->1 49->34 49->39 49->39 49->40 49->47 49->49 49->55 49->63 49->84 50->5 50->52 51->4 51->44 52->5 54->1 54->1 54->1 54->31 55->1 55->1 55->47 56->5 56->57 57->5 58->1 58->1 58->45 58->45 58->59 58->65 58->69 58->89 58->92 58->94 58->98 59->1 59->45 59->45 60->1 60->1 60->1 60->47 60->48 61->1 61->58 61->58 61->62 61->64 62->1 62->30 62->54 62->58 62->58 65->1 65->5 65->14 65->18 65->68 66->1 66->60 66->60 66->67 66->67 66->96 67->1 67->47 67->49 67->60 67->60 67->66 68->1 68->5 68->14 68->18 68->65 69->1 69->5 69->56 69->57 69->70 70->1 70->5 70->56 70->57 70->69
>>>Token int npqhbnaswbdl ( ) { int rxzarxymofnu = 0 ; char tzcsdibhdokk [ 110 ] ; int ulanxeuzrimk [ 110 ] ; int iostkyyupigy ; int tooghgvfhbxn ; int fghvijictccy ; for ( iostkyyupigy = 0 ; iostkyyupigy < n ; iostkyyupigy ++ ) { ulanxeuzrimk [ iostkyyupigy ] = -1 ; for ( tooghgvfhbxn = iostkyyupigy + 1 ; tooghgvfhbxn < n ; tooghgvfhbxn ++ ) { if ( tab0 [ s [ iostkyyupigy ] - ' ' ] [ s [ tooghgvfhbxn ] - ' ' ] > 0 && tooghgvfhbxn == iostkyyupigy + 1 || tab1 [ s [ iostkyyupigy ] - ' ' ] [ s [ tooghgvfhbxn ] - ' ' ] > 0 ) { ulanxeuzrimk [ iostkyyupigy ] = tooghgvfhbxn ; break ; } } } for ( iostkyyupigy = 0 ; iostkyyupigy < n ; iostkyyupigy ++ ) { fghvijictccy = -1 ; if ( ulanxeuzrimk [ iostkyyupigy ] == -1 ) continue ; fghvijictccy = ulanxeuzrimk [ iostkyyupigy ] ; while ( 1 ) { for ( tooghgvfhbxn = iostkyyupigy + 1 ; tooghgvfhbxn < fghvijictccy ; tooghgvfhbxn ++ ) { if ( ulanxeuzrimk [ tooghgvfhbxn ] > 0 && ulanxeuzrimk [ tooghgvfhbxn ] <= fghvijictccy ) break ; } if ( tooghgvfhbxn == fghvijictccy ) break ; iostkyyupigy = tooghgvfhbxn ; fghvijictccy = ulanxeuzrimk [ iostkyyupigy ] ; } break ; } if ( iostkyyupigy == n ) return 0 ; for ( tooghgvfhbxn = 0 ; tooghgvfhbxn < iostkyyupigy ; tooghgvfhbxn ++ ) tzcsdibhdokk [ rxzarxymofnu ++ ] = s [ tooghgvfhbxn ] ; if ( fghvijictccy == iostkyyupigy + 1 && tab0 [ s [ iostkyyupigy ] - ' ' ] [ s [ fghvijictccy ] - ' ' ] > 0 ) tzcsdibhdokk [ rxzarxymofnu ++ ] = tab0 [ s [ iostkyyupigy ] - ' ' ] [ s [ fghvijictccy ] - ' ' ] ; for ( tooghgvfhbxn = fghvijictccy + 1 ; tooghgvfhbxn < n ; tooghgvfhbxn ++ ) tzcsdibhdokk [ rxzarxymofnu ++ ] = s [ tooghgvfhbxn ] ; tzcsdibhdokk [ rxzarxymofnu ] = ' \0 ' ; n = rxzarxymofnu ; strcpy ( s , tzcsdibhdokk ) ; return 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&liveewudxyvn)
<operator>.lessThan z<liveewudxyvn
<operator>.postIncrement z++
<operator>.assignment z=0
<operator>.assignment zgzupyxzmvwe=0
scanf scanf("%d",&fhjopcochwil)
scanf scanf("%d",&fhjopcochwil)
scanf scanf("%d",&fhjopcochwil)
scanf scanf(" %s",qcgeyorcsavm)
printf printf("Case #%d: [",z+1)
printf printf("]\n")
<operator>.lessThan fqauqrglczxu<26
<operator>.postIncrement fqauqrglczxu++
<operator>.lessThan fqauqrglczxu<fhjopcochwil
<operator>.postIncrement fqauqrglczxu++
<operator>.lessThan fqauqrglczxu<fhjopcochwil
<operator>.postIncrement fqauqrglczxu++
<operator>.lessThan fqauqrglczxu<fhjopcochwil
<operator>.postIncrement fqauqrglczxu++
<operator>.lessThan fqauqrglczxu<zgzupyxzmvwe
<operator>.postIncrement fqauqrglczxu++
<operator>.assignment fqauqrglczxu=0
<operator>.assignment fqauqrglczxu=0
scanf scanf(" %s",qcgeyorcsavm)
<operator>.assignment mtgkptjoeqtw[qcgeyorcsavm[0]-'A'][qcgeyorcsavm[1]-'A']=qcgeyorcsavm[2]
<operator>.assignment mtgkptjoeqtw[qcgeyorcsavm[1]-'A'][qcgeyorcsavm[0]-'A']=qcgeyorcsavm[2]
<operator>.assignment fqauqrglczxu=0
scanf scanf(" %s",qcgeyorcsavm)
<operator>.assignment hqzvymrqsbsj[qcgeyorcsavm[0]-'A'][qcgeyorcsavm[1]-'A']=1
<operator>.assignment hqzvymrqsbsj[qcgeyorcsavm[1]-'A'][qcgeyorcsavm[0]-'A']=1
<operator>.assignment fqauqrglczxu=0
<operator>.addition z+1
<operator>.assignment fqauqrglczxu=0
printf printf("%c",xfhvavkhdrsy[fqauqrglczxu])
<operator>.lessThan j<26
<operator>.postIncrement j++
<operator>.logicalAnd zgzupyxzmvwe>0&&mtgkptjoeqtw[qcgeyorcsavm[fqauqrglczxu]-'A'][xfhvavkhdrsy[zgzupyxzmvwe-1]-'A']>0
<operator>.lessThan j<zgzupyxzmvwe-1
<operator>.postIncrement j++
<operator>.notEquals fqauqrglczxu!=0
<operator>.assignment j=0
<operator>.assignment mtgkptjoeqtw[fqauqrglczxu][j]=hqzvymrqsbsj[fqauqrglczxu][j]=0
<operator>.assignment xfhvavkhdrsy[zgzupyxzmvwe-1]=mtgkptjoeqtw[qcgeyorcsavm[fqauqrglczxu]-'A'][xfhvavkhdrsy[zgzupyxzmvwe-1]-'A']
<operator>.assignment j=0
printf printf(", ")
<operator>.subtraction qcgeyorcsavm[1]-'A'
<operator>.subtraction qcgeyorcsavm[0]-'A'
<operator>.subtraction qcgeyorcsavm[1]-'A'
<operator>.subtraction qcgeyorcsavm[0]-'A'
<operator>.greaterThan zgzupyxzmvwe>0
<operator>.greaterThan mtgkptjoeqtw[qcgeyorcsavm[fqauqrglczxu]-'A'][xfhvavkhdrsy[zgzupyxzmvwe-1]-'A']>0
<operator>.assignment xfhvavkhdrsy[zgzupyxzmvwe]=qcgeyorcsavm[fqauqrglczxu]
<operator>.postIncrement zgzupyxzmvwe++
<operator>.subtraction zgzupyxzmvwe-1
<operator>.equals hqzvymrqsbsj[xfhvavkhdrsy[j]-'A'][xfhvavkhdrsy[zgzupyxzmvwe-1]-'A']==1
<operator>.assignment hqzvymrqsbsj[fqauqrglczxu][j]=0
<operator>.subtraction qcgeyorcsavm[0]-'A'
<operator>.subtraction qcgeyorcsavm[1]-'A'
<operator>.subtraction qcgeyorcsavm[0]-'A'
<operator>.subtraction qcgeyorcsavm[1]-'A'
<operator>.assignment zgzupyxzmvwe=0
<operator>.subtraction xfhvavkhdrsy[zgzupyxzmvwe-1]-'A'
<operator>.subtraction zgzupyxzmvwe-1
<operator>.subtraction xfhvavkhdrsy[zgzupyxzmvwe-1]-'A'
<operator>.subtraction qcgeyorcsavm[fqauqrglczxu]-'A'
<operator>.subtraction qcgeyorcsavm[fqauqrglczxu]-'A'
<operator>.subtraction xfhvavkhdrsy[zgzupyxzmvwe-1]-'A'
<operator>.subtraction zgzupyxzmvwe-1
<operator>.subtraction zgzupyxzmvwe-1
<operator>.subtraction xfhvavkhdrsy[j]-'A'
<operator>.subtraction zgzupyxzmvwe-1
<operator>.addressOf &fhjopcochwil
<operator>.addressOf &fhjopcochwil
<operator>.addressOf &fhjopcochwil
<operator>.indirectIndexAccess mtgkptjoeqtw[qcgeyorcsavm[0]-'A'][qcgeyorcsavm[1]-'A']
<operator>.indirectIndexAccess qcgeyorcsavm[2]
<operator>.indirectIndexAccess mtgkptjoeqtw[qcgeyorcsavm[1]-'A'][qcgeyorcsavm[0]-'A']
<operator>.indirectIndexAccess qcgeyorcsavm[2]
<operator>.indirectIndexAccess hqzvymrqsbsj[qcgeyorcsavm[0]-'A'][qcgeyorcsavm[1]-'A']
<operator>.indirectIndexAccess hqzvymrqsbsj[qcgeyorcsavm[1]-'A'][qcgeyorcsavm[0]-'A']
<operator>.indirectIndexAccess xfhvavkhdrsy[fqauqrglczxu]
<operator>.indirectIndexAccess mtgkptjoeqtw[qcgeyorcsavm[0]-'A']
<operator>.indirectIndexAccess mtgkptjoeqtw[qcgeyorcsavm[1]-'A']
<operator>.indirectIndexAccess hqzvymrqsbsj[qcgeyorcsavm[0]-'A']
<operator>.indirectIndexAccess hqzvymrqsbsj[qcgeyorcsavm[1]-'A']
<operator>.indirectIndexAccess mtgkptjoeqtw[fqauqrglczxu][j]
<operator>.indirectIndexAccess qcgeyorcsavm[1]
<operator>.indirectIndexAccess qcgeyorcsavm[0]
<operator>.indirectIndexAccess qcgeyorcsavm[1]
<operator>.indirectIndexAccess qcgeyorcsavm[0]
<operator>.indirectIndexAccess mtgkptjoeqtw[qcgeyorcsavm[fqauqrglczxu]-'A'][xfhvavkhdrsy[zgzupyxzmvwe-1]-'A']
<operator>.indirectIndexAccess xfhvavkhdrsy[zgzupyxzmvwe-1]
<operator>.indirectIndexAccess mtgkptjoeqtw[qcgeyorcsavm[fqauqrglczxu]-'A'][xfhvavkhdrsy[zgzupyxzmvwe-1]-'A']
<operator>.indirectIndexAccess mtgkptjoeqtw[fqauqrglczxu]
<operator>.indirectIndexAccess hqzvymrqsbsj[fqauqrglczxu][j]
<operator>.indirectIndexAccess qcgeyorcsavm[0]
<operator>.indirectIndexAccess qcgeyorcsavm[1]
<operator>.indirectIndexAccess qcgeyorcsavm[0]
<operator>.indirectIndexAccess qcgeyorcsavm[1]
<operator>.indirectIndexAccess mtgkptjoeqtw[qcgeyorcsavm[fqauqrglczxu]-'A']
<operator>.indirectIndexAccess mtgkptjoeqtw[qcgeyorcsavm[fqauqrglczxu]-'A']
<operator>.indirectIndexAccess xfhvavkhdrsy[zgzupyxzmvwe]
<operator>.indirectIndexAccess qcgeyorcsavm[fqauqrglczxu]
<operator>.indirectIndexAccess hqzvymrqsbsj[xfhvavkhdrsy[j]-'A'][xfhvavkhdrsy[zgzupyxzmvwe-1]-'A']
<operator>.indirectIndexAccess hqzvymrqsbsj[fqauqrglczxu]
<operator>.indirectIndexAccess xfhvavkhdrsy[zgzupyxzmvwe-1]
<operator>.indirectIndexAccess xfhvavkhdrsy[zgzupyxzmvwe-1]
<operator>.indirectIndexAccess hqzvymrqsbsj[xfhvavkhdrsy[j]-'A']
<operator>.indirectIndexAccess qcgeyorcsavm[fqauqrglczxu]
<operator>.indirectIndexAccess qcgeyorcsavm[fqauqrglczxu]
<operator>.indirectIndexAccess xfhvavkhdrsy[zgzupyxzmvwe-1]
<operator>.indirectIndexAccess xfhvavkhdrsy[j]
>>>PDG&114 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->41 0->42 0->43 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 2->1 2->3 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->7 3->8 3->9 3->10 3->11 3->11 3->12 3->13 3->15 3->17 3->19 3->21 3->23 3->24 3->28 3->32 3->33 3->33 3->34 3->73 3->74 3->75 4->1 4->3 5->1 5->3 6->1 6->21 6->51 7->8 7->15 7->17 8->9 8->17 8->19 9->1 9->7 9->15 9->19 10->1 10->25 10->29 10->53 10->66 10->67 11->1 11->1 12->1 13->1 13->13 13->14 13->14 13->36 13->42 14->1 14->13 15->8 15->15 15->16 15->16 15->17 15->25 15->26 15->27 15->47 15->48 15->58 15->59 15->76 15->77 15->78 15->79 15->83 15->84 15->88 15->89 15->97 15->98 16->1 16->15 17->9 17->17 17->18 17->18 17->19 17->29 17->30 17->31 17->49 17->50 17->60 17->61 17->80 17->81 17->85 17->86 17->90 17->91 17->99 17->100 18->1 18->17 19->1 19->1 19->7 19->15 19->19 19->20 19->20 19->38 19->39 19->45 19->51 19->55 20->1 20->19 21->1 21->1 21->1 21->21 21->22 21->35 21->41 21->41 21->82 22->1 22->21 23->13 24->15 25->10 25->26 25->27 25->29 25->47 25->48 25->58 25->59 26->1 26->1 27->1 27->1 27->1 28->17 29->10 29->49 29->50 29->60 29->61 30->1 30->1 31->1 31->1 32->19 34->1 34->21 35->1 35->1 36->1 36->1 36->36 36->37 36->37 36->43 36->57 36->87 36->95 36->96 36->106 37->1 37->36 38->1 38->1 38->1 38->44 38->53 38->54 38->64 38->65 38->67 38->70 38->93 38->94 38->102 38->103 38->104 38->108 38->111 39->1 39->1 39->1 39->39 39->40 39->40 39->55 39->56 39->68 39->71 39->72 39->105 39->109 39->112 39->113 40->1 40->39 41->1 41->22 41->46 42->1 42->36 43->1 43->1 43->1 44->1 44->1 44->1 44->63 44->65 44->68 45->1 45->39 46->1 47->59 48->1 48->10 48->25 48->29 48->58 48->60 49->61 50->1 50->10 50->25 50->29 50->58 50->60 51->38 51->38 51->52 51->54 51->63 51->64 51->66 51->69 51->69 51->92 51->101 51->107 51->110 52->1 52->38 52->38 52->44 53->1 53->1 53->1 54->1 54->55 55->21 55->39 55->39 55->51 55->72 56->1 56->1 56->62 57->1 57->43 58->48 59->1 59->10 59->25 59->29 59->47 59->49 60->50 61->1 61->10 61->25 61->29 61->47 61->49 62->1 62->55 63->1 63->65 63->68 64->70 66->10 66->25 66->29 66->53 66->67 67->1 67->10 67->25 67->29 67->53 67->66 68->1 68->63 68->65 69->54 69->64 70->55 71->1 72->55
>>>Token int main ( ) { int liveewudxyvn , z ; int mtgkptjoeqtw [ 30 ] [ 30 ] ; int hqzvymrqsbsj [ 30 ] [ 30 ] ; char qcgeyorcsavm [ 10 ] ; int fhjopcochwil ; int fqauqrglczxu , j ; char xfhvavkhdrsy [ 150 ] ; int zgzupyxzmvwe ; scanf ( " " , & liveewudxyvn ) ; for ( z = 0 ; z < liveewudxyvn ; z ++ ) { zgzupyxzmvwe = 0 ; for ( fqauqrglczxu = 0 ; fqauqrglczxu < 26 ; fqauqrglczxu ++ ) { for ( j = 0 ; j < 26 ; j ++ ) { mtgkptjoeqtw [ fqauqrglczxu ] [ j ] = hqzvymrqsbsj [ fqauqrglczxu ] [ j ] = 0 ; } } scanf ( " " , & fhjopcochwil ) ; for ( fqauqrglczxu = 0 ; fqauqrglczxu < fhjopcochwil ; fqauqrglczxu ++ ) { scanf ( " " , qcgeyorcsavm ) ; mtgkptjoeqtw [ qcgeyorcsavm [ 0 ] - ' ' ] [ qcgeyorcsavm [ 1 ] - ' ' ] = qcgeyorcsavm [ 2 ] ; mtgkptjoeqtw [ qcgeyorcsavm [ 1 ] - ' ' ] [ qcgeyorcsavm [ 0 ] - ' ' ] = qcgeyorcsavm [ 2 ] ; } scanf ( " " , & fhjopcochwil ) ; for ( fqauqrglczxu = 0 ; fqauqrglczxu < fhjopcochwil ; fqauqrglczxu ++ ) { scanf ( " " , qcgeyorcsavm ) ; hqzvymrqsbsj [ qcgeyorcsavm [ 0 ] - ' ' ] [ qcgeyorcsavm [ 1 ] - ' ' ] = 1 ; hqzvymrqsbsj [ qcgeyorcsavm [ 1 ] - ' ' ] [ qcgeyorcsavm [ 0 ] - ' ' ] = 1 ; } scanf ( " " , & fhjopcochwil ) ; scanf ( " " , qcgeyorcsavm ) ; for ( fqauqrglczxu = 0 ; fqauqrglczxu < fhjopcochwil ; fqauqrglczxu ++ ) { if ( zgzupyxzmvwe > 0 && mtgkptjoeqtw [ qcgeyorcsavm [ fqauqrglczxu ] - ' ' ] [ xfhvavkhdrsy [ zgzupyxzmvwe - 1 ] - ' ' ] > 0 ) { xfhvavkhdrsy [ zgzupyxzmvwe - 1 ] = mtgkptjoeqtw [ qcgeyorcsavm [ fqauqrglczxu ] - ' ' ] [ xfhvavkhdrsy [ zgzupyxzmvwe - 1 ] - ' ' ] ; } else { xfhvavkhdrsy [ zgzupyxzmvwe ] = qcgeyorcsavm [ fqauqrglczxu ] ; zgzupyxzmvwe ++ ; } for ( j = 0 ; j < zgzupyxzmvwe - 1 ; j ++ ) { if ( hqzvymrqsbsj [ xfhvavkhdrsy [ j ] - ' ' ] [ xfhvavkhdrsy [ zgzupyxzmvwe - 1 ] - ' ' ] == 1 ) { zgzupyxzmvwe = 0 ; } } } printf ( " " , z + 1 ) ; for ( fqauqrglczxu = 0 ; fqauqrglczxu < zgzupyxzmvwe ; fqauqrglczxu ++ ) { if ( fqauqrglczxu != 0 ) printf ( " " ) ; printf ( " " , xfhvavkhdrsy [ fqauqrglczxu ] ) ; } printf ( " \n " ) ; } }
>>>Func
METHOD vbifiyiagvtw
METHOD_RETURN void
PARAM ArrayList *arraylist
PARAM ArrayListCompareFunc bknnewfmmuib
arraylist_sort_internal arraylist_sort_internal(arraylist->data,arraylist->length,bknnewfmmuib)
>>>PDG&5 0->2 0->3 0->4 2->1 3->4 4->1 4->1 4->1 4->1
>>>Token void vbifiyiagvtw ( ArrayList * arraylist , ArrayListCompareFunc bknnewfmmuib ) { arraylist_sort_internal ( arraylist -> data , arraylist -> length , bknnewfmmuib ) ; }
>>>Func
METHOD bprhqcczwyde
METHOD_RETURN int
PARAM char *output
PARAM char **reducematrix
PARAM int nkwzkmhggjto [ ]
<operator>.assignment erkbonckoysf=strlen(output)
<operator>.assignment peakyiosxbim=output[erkbonckoysf-1]
<operator>.assignment gtglffvxxpdx=getBaseIndex(peakyiosxbim)
RETURN return 0; return 0;
<operator>.logicalNot !isBase(peakyiosxbim)
<operator>.lessThan acdfbzqptxdy<8
<operator>.postIncrement acdfbzqptxdy++
LITERAL 0 return 0;
strlen strlen(output)
RETURN return 0; return 0;
getBaseIndex getBaseIndex(peakyiosxbim)
<operator>.assignment acdfbzqptxdy=0
<operator>.subtraction erkbonckoysf-1
isBase isBase(peakyiosxbim)
LITERAL 0 return 0;
<operator>.logicalAnd reducematrix[gtglffvxxpdx][acdfbzqptxdy]==1&&nkwzkmhggjto[acdfbzqptxdy]>0
<operator>.assignment output=realloc(output sizeof(char))
<operator>.assignment output[0]=0
RETURN return 1; return 1;
<operator>.equals reducematrix[gtglffvxxpdx][acdfbzqptxdy]==1
<operator>.greaterThan nkwzkmhggjto[acdfbzqptxdy]>0
LITERAL 1 return 1;
realloc realloc(output sizeof(char))
<operator>.sizeOf sizeof(char)
<operator>.indirectIndexAccess reducematrix[gtglffvxxpdx][acdfbzqptxdy]
<operator>.indirectIndexAccess nkwzkmhggjto[acdfbzqptxdy]
<operator>.indirectIndexAccess output[0]
<operator>.indirectIndexAccess reducematrix[gtglffvxxpdx]
>>>PDG&33 0->2 0->3 0->4 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->22 0->23 0->24 0->25 0->26 0->27 2->13 3->1 4->1 4->25 5->1 5->1 5->17 6->1 6->1 6->18 8->1 9->1 9->1 9->7 9->10 9->14 9->15 9->16 10->8 10->11 10->20 10->24 10->29 10->32 11->10 12->8 13->1 13->5 13->6 13->27 14->1 15->7 16->10 17->1 18->1 18->9 18->15 19->14 20->10 20->11 20->21 20->22 20->23 20->27 20->28 20->31 23->1 24->20 24->20 24->25 24->30 25->20 25->20 26->23 27->21 28->1
>>>Token int bprhqcczwyde ( char * output , char * * reducematrix , int nkwzkmhggjto [ ] ) { int erkbonckoysf = strlen ( output ) ; char peakyiosxbim = output [ erkbonckoysf - 1 ] ; if ( ! isBase ( peakyiosxbim ) ) return 0 ; int gtglffvxxpdx = getBaseIndex ( peakyiosxbim ) ; int acdfbzqptxdy ; for ( acdfbzqptxdy = 0 ; acdfbzqptxdy < 8 ; acdfbzqptxdy ++ ) { if ( reducematrix [ gtglffvxxpdx ] [ acdfbzqptxdy ] == 1 && nkwzkmhggjto [ acdfbzqptxdy ] > 0 ) { output = realloc ( output , sizeof ( char ) ) ; output [ 0 ] = 0 ; return 1 ; } } return 0 ; }
>>>Func
METHOD vsxwhdeqomvc
METHOD_RETURN int
PARAM char tormhglvprkr
RETURN return 0; return 0;
<operator>.lessThan aqtsdmhtodsg<ec
<operator>.postIncrement aqtsdmhtodsg++
LITERAL 0 return 0;
<operator>.assignment aqtsdmhtodsg=0
<operator>.equals el[aqtsdmhtodsg]==tormhglvprkr
RETURN return 1; return 1;
LITERAL 1 return 1;
<operator>.indirectIndexAccess el[aqtsdmhtodsg]
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->8 3->1 4->1 4->1 4->1 4->3 4->5 4->8 4->11 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->4 8->5 8->9 9->1 10->9
>>>Token int vsxwhdeqomvc ( char tormhglvprkr ) { for ( int aqtsdmhtodsg = 0 ; aqtsdmhtodsg < ec ; aqtsdmhtodsg ++ ) { if ( el [ aqtsdmhtodsg ] == tormhglvprkr ) return 1 ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.expressionList yjdfofnxiibg aqhnhgzjifgx max1 max2 num1 num2 tc c d1 s1 t
freopen freopen("aa.in","r",stdin)
freopen freopen("bb.in","w",stdout)
scanf scanf("%lld",&tc)
RETURN return 0; return 0;
<operator>.lessEqualsThan ubhsnceloqfx<=tc
<operator>.postIncrement ubhsnceloqfx++
LITERAL 0 return 0;
<operator>.assignment ubhsnceloqfx=1
scanf scanf("%d%lld%d%lld",&l,&t,&n,&c)
<operator>.assignment d1=t/2
<operator>.assignment s1=0
<operator>.assignment aqhnhgzjifgx=0
zomeuufbmzok zomeuufbmzok(l!=0)
BLOCK <empty> <empty>
<operator>.assignment yjdfofnxiibg=0
<operator>.assignment yjdfofnxiibg=yjdfofnxiibg *2
<operator>.assignmentMinus yjdfofnxiibg-=aqhnhgzjifgx
printf printf("Case #%d: %lld\n",ubhsnceloqfx,yjdfofnxiibg)
<operator>.lessThan i<c
<operator>.postIncrement i++
scanf scanf("%d",&a[i])
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.assignment b[i]=a[i%c]
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.assignment max1=s1-d1
<operator>.assignment num1=i
<operator>.assignment max2=0
<operator>.assignment num2=-1
zomeuufbmzok zomeuufbmzok(b[j]>max1)
BLOCK <empty> <empty>
zomeuufbmzok zomeuufbmzok(l==1)
<operator>.assignment aqhnhgzjifgx=max1
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.assignmentPlus yjdfofnxiibg+=b[i]
<operator>.assignment i=0
<operator>.assignment i=0
<operator>.division t/2
<operator>.assignment i=0
<operator>.assignmentPlus s1+=b[i]
zomeuufbmzok zomeuufbmzok(s1>d1)
<operator>.notEquals l!=0
<operator>.assignment max2=max1
<operator>.assignment num2=num1
<operator>.assignment max1=b[j]
<operator>.assignment num1=j
<operator>.assignment i=0
<operator>.multiplication yjdfofnxiibg *2
<operator>.subtraction s1-d1
<operator>.minus -1
<operator>.greaterThan b[j]>max1
<operator>.equals l==1
<operator>.modulo i%c
<operator>.greaterThan s1>d1
UNKNOWN,),)
<operator>.addressOf &l
<operator>.addressOf &t
<operator>.addressOf &n
<operator>.addressOf &c
UNKNOWN,),)
UNKNOWN else zomeuufbmzok (b[j]>max2){max2=b[j];num2=j;} else zomeuufbmzok (b[j]>max2){max2=b[j];num2=j;}
UNKNOWN,),)
UNKNOWN else aqhnhgzjifgx =max1+max2; else aqhnhgzjifgx =max1+max2;
<operator>.addressOf &a[i]
<operator>.indirectIndexAccess b[i]
<operator>.indirectIndexAccess a[i%c]
UNKNOWN,),)
<operator>.indirectIndexAccess b[i]
<operator>.indirectIndexAccess a[i]
<operator>.indirectIndexAccess b[i]
<operator>.indirectIndexAccess b[j]
<operator>.indirectIndexAccess b[j]
>>>PDG&77 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->16 0->17 0->19 0->20 0->21 0->22 0->24 0->25 0->27 0->30 0->31 0->34 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 2->1 2->1 2->1 2->1 2->1 2->1 2->1 2->1 2->1 2->1 2->1 2->5 2->7 2->21 2->42 3->1 3->1 4->1 4->1 5->1 5->7 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->13 7->14 7->15 7->17 7->18 7->19 7->20 7->20 7->21 7->24 7->27 7->29 7->30 7->31 7->32 7->33 7->35 7->36 7->37 7->40 7->41 7->42 7->43 7->46 7->47 7->48 7->49 7->50 7->51 7->52 7->53 7->54 7->55 7->56 7->59 7->60 7->61 7->62 7->63 7->64 7->65 7->66 7->67 7->75 7->76 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->1 11->1 11->46 11->56 12->1 12->1 12->53 12->58 13->1 13->44 13->53 14->1 15->1 15->1 17->1 17->39 17->52 18->1 18->1 18->19 19->1 19->1 19->20 20->1 20->1 20->8 21->1 21->1 21->21 21->22 21->22 21->23 21->57 21->68 21->73 22->1 22->21 23->1 24->24 24->25 24->26 24->27 24->57 24->57 24->69 24->70 25->1 25->24 26->1 26->1 26->1 26->39 26->44 27->30 27->37 27->44 27->45 27->58 27->71 27->74 28->1 28->27 29->1 29->1 29->55 30->1 30->48 31->1 32->1 32->1 33->1 33->1 35->1 35->1 36->1 36->1 36->19 37->1 37->1 37->1 37->24 37->37 37->38 37->38 37->39 37->72 38->1 38->37 39->1 39->1 39->52 40->21 41->24 42->1 42->12 42->12 43->27 44->1 44->1 44->58 45->1 45->1 46->15 46->15 46->56 47->1 47->1 48->1 48->1 49->1 49->1 49->36 50->1 50->1 50->1 51->1 51->37 52->18 52->18 53->1 53->1 53->29 53->29 54->32 55->33 55->33 55->47 55->49 56->1 56->11 56->35 56->35 56->46 57->1 57->21 57->25 58->45 58->45 58->53 58->53
>>>Token int main ( ) { int ubhsnceloqfx , n , l , h , i , j , cnt , a [ 1100 ] , b [ 1100 ] ; zqrotsmegkbm zqrotsmegkbmint  yjdfofnxiibg , aqhnhgzjifgx , max1 , max2 , num1 , num2 , tc , c , d1 , s1 , t ; freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; scanf ( " " , & tc ) ; for ( ubhsnceloqfx = 1 ; ubhsnceloqfx <= tc ; ubhsnceloqfx ++ ) { scanf ( " " , & l , & t , & n , & c ) ; for ( i = 0 ; i < c ; i ++ ) scanf ( " " , & a [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) b [ i ] = a [ i % c ] ; d1 = t / 2 ; s1 = 0 ; for ( i = 0 ; i < n ; i ++ ) { s1 += b [ i ] ; zomeuufbmzok ( s1 > d1 ) break ; } aqhnhgzjifgx = 0 ; zomeuufbmzok ( l != 0 )  { max1 = s1 - d1 ; num1 = i ; max2 = 0 ; num2 = -1 ; for ( j = i + 1 ; j < n ; j ++ ) zomeuufbmzok ( b [ j ] > max1 )  { max2 = max1 ; num2 = num1 ; max1 = b [ j ] ; num1 = j ; } else zomeuufbmzok ( b [ j ] > max2 ) { max2 = b [ j ] ; num2 = j ; } zomeuufbmzok ( l == 1 )  aqhnhgzjifgx = max1 ; else aqhnhgzjifgx = max1 + max2 ; } yjdfofnxiibg = 0 ; for ( i = 0 ; i < n ; i ++ ) yjdfofnxiibg += b [ i ] ; yjdfofnxiibg = yjdfofnxiibg * 2 ; ; yjdfofnxiibg -= aqhnhgzjifgx ; printf ( " \n " , ubhsnceloqfx , yjdfofnxiibg ) ; } return 0 ; }
>>>Func
METHOD nfrxdhkraxrb
METHOD_RETURN void
PARAM Node *head
IDENTIFIER head if (head)
nfrxdhkraxrb nfrxdhkraxrb(head->next)
free free(head)
free free(head->search_term)
<operator>.indirectFieldAccess head->search_term
<operator>.indirectFieldAccess head->search_term
FIELD_IDENTIFIER search_term search_term
>>>PDG&10 0->2 0->3 0->5 2->5 4->1 4->1 5->1 6->1 7->6 7->8 7->9
>>>Token void nfrxdhkraxrb ( Node * head ) { if ( head ) { if ( head -> search_term ) free ( head -> search_term ) ; nfrxdhkraxrb ( head -> next ) ; free ( head ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&p)
RETURN return 0; return 0;
<operator>.lessThan jcwhzdunbqtk<p
<operator>.postIncrement jcwhzdunbqtk++
LITERAL 0 return 0;
<operator>.assignment jcwhzdunbqtk=0
scanf scanf("%d",&npumetktlfkh)
printf printf("Case #%d:\n",jcwhzdunbqtk+1)
<operator>.lessThan sjnfgfabrivw<npumetktlfkh
<operator>.postIncrement sjnfgfabrivw++
<operator>.lessThan i<npumetktlfkh
<operator>.postIncrement i++
<operator>.lessThan i<npumetktlfkh
<operator>.postIncrement i++
<operator>.lessThan i<npumetktlfkh
<operator>.postIncrement i++
<operator>.assignment sjnfgfabrivw=0
<operator>.assignment vhroeucfhgoi[sjnfgfabrivw]=t[sjnfgfabrivw]=0
scanf scanf("%s",&usrhhnpczkcz[sjnfgfabrivw][0])
<operator>.assignment oowp[sjnfgfabrivw]=fviikpwerzll[sjnfgfabrivw]=owp[sjnfgfabrivw]=0.0
<operator>.assignment i=0
<operator>.assignment i=0
<operator>.assignment ylcnylfnziqs=0
<operator>.assignmentDivision owp[i]/=ylcnylfnziqs
<operator>.addition jcwhzdunbqtk+1
<operator>.assignment i=0
<operator>.assignment ylcnylfnziqs=0
<operator>.assignmentDivision oowp[i]/=ylcnylfnziqs
printf printf("%.12f\n" 0.25 *(oowp[i]+fviikpwerzll[i]/t[i])+0.5 *owp[i])
<operator>.lessThan sjnfgfabrivw<npumetktlfkh
<operator>.postIncrement sjnfgfabrivw++
<operator>.lessThan sjnfgfabrivw<npumetktlfkh
<operator>.postIncrement sjnfgfabrivw++
<operator>.lessThan sjnfgfabrivw<npumetktlfkh
<operator>.postIncrement sjnfgfabrivw++
<operator>.assignment t[sjnfgfabrivw]=0
<operator>.assignment fviikpwerzll[sjnfgfabrivw]=owp[sjnfgfabrivw]=0.0
<operator>.assignment sjnfgfabrivw=0
<operator>.assignment sjnfgfabrivw=0
<operator>.assignment sjnfgfabrivw=0
<operator>.addition 0.25 *(oowp[i]+fviikpwerzll[i]/t[i])+0.5 *owp[i]
<operator>.assignment owp[sjnfgfabrivw]=0.0
<operator>.notEquals usrhhnpczkcz[i][sjnfgfabrivw]!='.'
<operator>.notEquals usrhhnpczkcz[i][sjnfgfabrivw]!='.'
<operator>.notEquals usrhhnpczkcz[i][sjnfgfabrivw]!='.'
<operator>.multiplication 0.25 *(oowp[i]+fviikpwerzll[i]/t[i])
<operator>.multiplication 0.5 *owp[i]
<operator>.postIncrement t[i]++
<operator>.assignmentPlus fviikpwerzll[i]+=usrhhnpczkcz[i][sjnfgfabrivw]-48
<operator>.assignmentPlus owp[i]+=(fviikpwerzll[sjnfgfabrivw]-usrhhnpczkcz[sjnfgfabrivw][i]+48)/(t[sjnfgfabrivw]-1)
<operator>.postIncrement ylcnylfnziqs++
<operator>.postIncrement ylcnylfnziqs++
<operator>.assignmentPlus oowp[i]+=owp[sjnfgfabrivw]
<operator>.addition oowp[i]+fviikpwerzll[i]/t[i]
<operator>.division fviikpwerzll[i]/t[i]
<operator>.subtraction usrhhnpczkcz[i][sjnfgfabrivw]-48
<operator>.division (fviikpwerzll[sjnfgfabrivw]-usrhhnpczkcz[sjnfgfabrivw][i]+48)/(t[sjnfgfabrivw]-1)
<operator>.addition fviikpwerzll[sjnfgfabrivw]-usrhhnpczkcz[sjnfgfabrivw][i]+48
<operator>.subtraction t[sjnfgfabrivw]-1
<operator>.subtraction fviikpwerzll[sjnfgfabrivw]-usrhhnpczkcz[sjnfgfabrivw][i]
<operator>.addressOf &npumetktlfkh
<operator>.indirectIndexAccess vhroeucfhgoi[sjnfgfabrivw]
<operator>.addressOf &usrhhnpczkcz[sjnfgfabrivw][0]
<operator>.indirectIndexAccess oowp[sjnfgfabrivw]
<operator>.indirectIndexAccess owp[i]
<operator>.indirectIndexAccess oowp[i]
<operator>.indirectIndexAccess t[sjnfgfabrivw]
<operator>.indirectIndexAccess usrhhnpczkcz[sjnfgfabrivw][0]
<operator>.indirectIndexAccess fviikpwerzll[sjnfgfabrivw]
<operator>.indirectIndexAccess usrhhnpczkcz[sjnfgfabrivw]
<operator>.indirectIndexAccess owp[sjnfgfabrivw]
<operator>.indirectIndexAccess owp[i]
<operator>.indirectIndexAccess usrhhnpczkcz[i][sjnfgfabrivw]
<operator>.indirectIndexAccess usrhhnpczkcz[i][sjnfgfabrivw]
<operator>.indirectIndexAccess usrhhnpczkcz[i][sjnfgfabrivw]
<operator>.indirectIndexAccess oowp[i]
<operator>.indirectIndexAccess usrhhnpczkcz[i]
<operator>.indirectIndexAccess t[i]
<operator>.indirectIndexAccess fviikpwerzll[i]
<operator>.indirectIndexAccess usrhhnpczkcz[i]
<operator>.indirectIndexAccess owp[i]
<operator>.indirectIndexAccess usrhhnpczkcz[i]
<operator>.indirectIndexAccess oowp[i]
<operator>.indirectIndexAccess owp[sjnfgfabrivw]
<operator>.indirectIndexAccess fviikpwerzll[i]
<operator>.indirectIndexAccess t[i]
<operator>.indirectIndexAccess usrhhnpczkcz[i][sjnfgfabrivw]
<operator>.indirectIndexAccess usrhhnpczkcz[i]
<operator>.indirectIndexAccess t[sjnfgfabrivw]
<operator>.indirectIndexAccess fviikpwerzll[sjnfgfabrivw]
<operator>.indirectIndexAccess usrhhnpczkcz[sjnfgfabrivw][i]
<operator>.indirectIndexAccess usrhhnpczkcz[sjnfgfabrivw]
>>>PDG&94 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->52 0->53 0->57 0->58 0->59 0->60 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->9 4->10 4->12 4->14 4->16 4->18 4->22 4->23 4->26 4->26 4->27 4->62 5->1 5->4 6->3 7->1 7->4 8->1 8->10 8->12 8->14 8->16 8->31 8->33 8->35 9->1 9->1 10->1 10->1 10->10 10->11 10->11 10->12 10->19 10->20 10->21 10->37 10->38 10->43 10->63 10->64 10->65 10->68 10->69 10->70 10->71 10->72 11->1 11->10 12->12 12->13 12->13 12->14 12->31 12->31 12->39 13->1 13->12 14->14 14->15 14->15 14->16 14->24 14->25 14->33 14->33 14->40 14->66 15->1 15->14 16->1 16->1 16->1 16->8 16->10 16->16 16->17 16->17 16->28 16->29 16->30 16->35 16->35 16->41 16->42 16->47 16->48 16->55 16->56 16->67 16->73 16->77 16->86 16->87 17->1 17->16 18->1 18->10 19->1 19->1 19->1 20->1 21->1 21->1 21->1 22->12 23->14 24->1 24->25 24->52 25->1 25->1 25->1 25->48 25->51 27->1 27->16 28->1 28->29 28->53 29->1 29->1 29->47 29->54 29->55 30->1 30->1 31->1 31->1 31->12 31->31 31->32 31->32 31->44 31->74 31->78 32->1 32->31 33->1 33->1 33->14 33->33 33->34 33->34 33->45 33->75 33->81 34->1 34->33 35->1 35->1 35->16 35->35 35->36 35->36 35->46 35->76 35->83 36->1 36->35 37->1 37->19 37->60 38->1 38->1 38->21 38->61 39->1 39->31 40->1 40->33 41->1 41->35 42->1 42->1 43->1 43->21 43->38 43->54 44->1 44->1 44->45 44->46 44->49 44->50 44->57 44->57 44->79 44->80 44->88 44->89 45->1 45->1 45->44 45->46 45->51 45->52 45->58 45->59 45->60 45->61 45->82 45->90 45->91 45->92 45->93 46->1 46->1 46->44 46->45 46->53 46->54 46->84 46->85 47->1 47->30 47->30 47->42 47->42 48->1 48->25 48->30 48->30 48->42 48->42 48->51 49->1 49->1 49->56 50->1 50->1 50->1 50->56 51->1 51->1 51->25 52->1 52->25 53->1 53->29 54->1 54->1 54->29 55->1 55->1 56->1 56->1 56->47 56->47 56->49 56->50 56->55 56->55 57->1 57->44 57->45 57->46 57->50 57->50 58->1 58->1 58->51 58->51 59->1 60->1 60->58 60->58 61->1 61->1 61->58 61->58 61->59 61->59
>>>Token int main ( ) { int npumetktlfkh , p ; char ojcyragnueyc ; scanf ( " " , & p ) ; int jcwhzdunbqtk , i ; for ( jcwhzdunbqtk = 0 ; jcwhzdunbqtk < p ; jcwhzdunbqtk ++ ) { scanf ( " " , & npumetktlfkh ) ; int sjnfgfabrivw ; double fviikpwerzll [ npumetktlfkh ] , owp [ npumetktlfkh ] , oowp [ npumetktlfkh ] ; int vhroeucfhgoi [ npumetktlfkh ] , t [ npumetktlfkh ] ; char usrhhnpczkcz [ npumetktlfkh ] [ npumetktlfkh + 1 ] ; for ( sjnfgfabrivw = 0 ; sjnfgfabrivw < npumetktlfkh ; sjnfgfabrivw ++ ) { vhroeucfhgoi [ sjnfgfabrivw ] = t [ sjnfgfabrivw ] = 0 ; scanf ( " " , & usrhhnpczkcz [ sjnfgfabrivw ] [ 0 ] ) ; oowp [ sjnfgfabrivw ] = fviikpwerzll [ sjnfgfabrivw ] = owp [ sjnfgfabrivw ] = 0.0 ; } for ( i = 0 ; i < npumetktlfkh ; i ++ ) { for ( sjnfgfabrivw = 0 ; sjnfgfabrivw < npumetktlfkh ; sjnfgfabrivw ++ ) { if ( usrhhnpczkcz [ i ] [ sjnfgfabrivw ] != ' ' ) { t [ i ] ++ ; fviikpwerzll [ i ] += usrhhnpczkcz [ i ] [ sjnfgfabrivw ] - 48 ; } } } for ( i = 0 ; i < npumetktlfkh ; i ++ ) { int ylcnylfnziqs = 0 ; for ( sjnfgfabrivw = 0 ; sjnfgfabrivw < npumetktlfkh ; sjnfgfabrivw ++ ) { if ( usrhhnpczkcz [ i ] [ sjnfgfabrivw ] != ' ' ) { owp [ i ] += ( fviikpwerzll [ sjnfgfabrivw ] - usrhhnpczkcz [ sjnfgfabrivw ] [ i ] + 48 ) / ( t [ sjnfgfabrivw ] - 1 ) ; ylcnylfnziqs ++ ; } } owp [ i ] /= ylcnylfnziqs ; } printf ( " \n " , jcwhzdunbqtk + 1 ) ; for ( i = 0 ; i < npumetktlfkh ; i ++ ) { int ylcnylfnziqs = 0 ; for ( sjnfgfabrivw = 0 ; sjnfgfabrivw < npumetktlfkh ; sjnfgfabrivw ++ ) { if ( usrhhnpczkcz [ i ] [ sjnfgfabrivw ] != ' ' ) { ylcnylfnziqs ++ ; oowp [ i ] += owp [ sjnfgfabrivw ] ; } } oowp [ i ] /= ylcnylfnziqs ; printf ( " \n " , 0.25 * ( oowp [ i ] + fviikpwerzll [ i ] / t [ i ] ) + 0.5 * owp [ i ] ) ; } } return 0 ; }
>>>Func
METHOD htmqggmvtsawfmt_paragraph
METHOD_RETURN ANY
PARAM htmqggmvtsaw
<operator>.assignment word_limit->best_cost=0
<operator>.assignment dwnlzjiwuqbh=word_limit->length
<operator>.assignment word_limit->length=max_width
<operator>.assignment word_limit->length=dwnlzjiwuqbh
<operator>.greaterEqualsThan start>=word
<operator>.postDecrement start--
<operator>.assignment start=word_limit-1
<operator>.assignment best=MAXCOST
<operator>.assignment xrkfakpjhlzx=start==word?first_indent:other_indent
<operator>.assignment w=start
<operator>.assignmentPlus xrkfakpjhlzx+=w->length
<operator>.assignment start->best_cost=best+base_cost(start)
<operator>.lessThan xrkfakpjhlzx<max_width
<operator>.subtraction word_limit-1
<operator>.conditional start==word?first_indent:other_indent
<operator>.postIncrement w++
<operator>.assignment vplcseoicnkr=line_cost(w,xrkfakpjhlzx)+w->best_cost
<operator>.assignmentPlus xrkfakpjhlzx+=(w-1)->space+w->length
<operator>.addition best+base_cost(start)
<operator>.equals start==word
<operator>.logicalAnd start==word&&last_line_length>0
<operator>.lessThan vplcseoicnkr<best
<operator>.equals w==word_limit
base_cost base_cost(start)
<operator>.addition line_cost(w,xrkfakpjhlzx)+w->best_cost
<operator>.assignmentPlus vplcseoicnkr+=RAGGED_COST(xrkfakpjhlzx-last_line_length)
<operator>.assignment best=vplcseoicnkr
<operator>.assignment start->next_break=w
<operator>.assignment start->line_length=xrkfakpjhlzx
<operator>.addition (w-1)->space+w->length
line_cost line_cost(w,xrkfakpjhlzx)
<operator>.equals start==word
<operator>.greaterThan last_line_length>0
RAGGED_COST RAGGED_COST(xrkfakpjhlzx-last_line_length)
<operator>.subtraction w-1
<operator>.subtraction xrkfakpjhlzx-last_line_length
<operator>.indirectFieldAccess w->length
<operator>.indirectFieldAccess start->best_cost
FIELD_IDENTIFIER length length
FIELD_IDENTIFIER best_cost best_cost
<operator>.indirectFieldAccess w->best_cost
<operator>.indirectFieldAccess (w-1)->space
<operator>.indirectFieldAccess w->length
FIELD_IDENTIFIER best_cost best_cost
<operator>.indirectFieldAccess start->next_break
<operator>.indirectFieldAccess start->line_length
FIELD_IDENTIFIER space space
FIELD_IDENTIFIER length length
FIELD_IDENTIFIER next_break next_break
FIELD_IDENTIFIER line_length line_length
>>>PDG&53 0->2 0->3 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->21 0->22 0->24 0->25 0->26 0->28 0->29 0->30 0->31 0->33 0->34 0->35 0->37 0->38 2->1 3->1 3->1 4->1 4->6 5->1 5->1 6->1 6->1 6->1 7->1 7->1 7->1 7->7 7->8 7->10 7->11 7->12 7->13 7->14 7->17 7->18 7->19 7->21 7->22 7->22 7->22 7->23 7->24 7->25 7->26 7->27 7->33 7->34 7->39 7->40 7->41 7->42 7->43 7->46 8->1 8->7 9->1 9->1 9->7 10->1 10->1 10->24 11->1 11->1 11->13 12->1 12->18 13->1 13->1 13->33 14->1 14->1 14->1 15->1 15->1 15->1 15->18 15->19 15->23 15->24 15->25 15->27 15->33 15->33 15->34 15->43 15->46 16->1 16->9 16->9 16->25 17->1 17->1 18->1 18->33 19->1 19->1 19->24 19->28 20->1 20->1 20->15 21->1 21->1 22->12 22->34 22->34 23->1 23->1 23->1 23->28 23->36 23->38 24->1 24->1 24->14 24->21 24->29 24->29 24->30 24->31 24->47 24->48 24->51 24->52 25->1 25->1 25->1 25->15 25->20 25->32 25->37 25->37 25->44 25->45 25->49 25->50 26->8 26->14 26->21 27->1 27->1 28->1 28->1 28->24 29->1 29->1 29->14 29->21 29->24 30->1 30->1 31->1 31->1 31->1 32->1 32->1 33->1 33->19 33->19 33->20 33->25 33->27 33->27 33->30 33->31 33->38 34->7 34->23 34->23 34->26 34->35 35->1 35->23 35->23 35->38 36->1 36->28 37->1 37->18 38->1 38->1 38->20 38->31 38->35 38->36 38->36
>>>Token static htmqggmvtsawfmt_paragraph ( htmqggmvtsaw ) { WORD * start , * w ; int xrkfakpjhlzx ; COST vplcseoicnkr , best ; int dwnlzjiwuqbh ; word_limit -> best_cost = 0 ; dwnlzjiwuqbh = word_limit -> length ; word_limit -> length = max_width ; for ( start = word_limit - 1 ; start >= word ; start -- ) { best = MAXCOST ; xrkfakpjhlzx = start == word ? first_indent : other_indent ; w = start ; xrkfakpjhlzx += w -> length ; do { w ++ ; vplcseoicnkr = line_cost ( w , xrkfakpjhlzx ) + w -> best_cost ; if ( start == word && last_line_length > 0 ) vplcseoicnkr += RAGGED_COST ( xrkfakpjhlzx - last_line_length ) ; if ( vplcseoicnkr < best ) { best = vplcseoicnkr ; start -> next_break = w ; start -> line_length = xrkfakpjhlzx ; } if ( w == word_limit ) break ; xrkfakpjhlzx += ( w - 1 ) -> space + w -> length ; } while ( xrkfakpjhlzx < max_width ) ; start -> best_cost = best + base_cost ( start ) ; } word_limit -> length = dwnlzjiwuqbh ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
freopen freopen("input.txt","r",stdin)
scanf scanf("%d",&T)
RETURN return 0; return 0;
<operator>.lessEqualsThan t<=T
<operator>.postIncrement t++
LITERAL 0 return 0;
<operator>.assignment t=1
scanf scanf("%d ",&C)
<operator>.assignment anscnt=0
scanf scanf("%d ",&D)
scanf scanf("%d ",&N)
flwsusyeifdo flwsusyeifdo("Case #%d: [",t)
flwsusyeifdo flwsusyeifdo("]\n")
<operator>.lessThan xuclkudnbiaw<M
<operator>.postIncrement xuclkudnbiaw++
<operator>.postDecrement C--
<operator>.postDecrement D--
<operator>.postDecrement N--
<operator>.lessThan xuclkudnbiaw<anscnt
<operator>.postIncrement xuclkudnbiaw++
<operator>.assignment xuclkudnbiaw=0
<operator>.lessThan j<M
<operator>.postIncrement j++
<operator>.assignment c[xuclkudnbiaw][j]=d[xuclkudnbiaw][j]=0
scanf scanf("%c%c%c ",&b1,&b2,&bc)
<operator>.assignment c[b1][b2]=c[b2][b1]=bc
scanf scanf("%c%c ",&b1,&b2)
<operator>.assignment d[b1][b2]=d[b2][b1]=1
scanf scanf("%c",&bc)
<operator>.assignment xuclkudnbiaw=0
<operator>.assignment j=0
<operator>.logicalAnd anscnt>0&&c[bc][ajpclngqnvhb[anscnt-1]]
<operator>.equals xuclkudnbiaw==0
<operator>.assignment d[xuclkudnbiaw][j]=0
<operator>.assignment c[b2][b1]=bc
<operator>.assignment d[b2][b1]=1
<operator>.assignment ajpclngqnvhb[anscnt-1]=c[bc][ajpclngqnvhb[anscnt-1]]
flwsusyeifdo flwsusyeifdo("%c",ajpclngqnvhb[xuclkudnbiaw])
<operator>.greaterThan anscnt>0
flwsusyeifdo flwsusyeifdo (", %c",ajpclngqnvhb[xuclkudnbiaw])
<operator>.lessThan xuclkudnbiaw<anscnt
<operator>.postIncrement xuclkudnbiaw++
<operator>.notEquals xuclkudnbiaw!=-3
<operator>.subtraction anscnt-1
<operator>.subtraction anscnt-1
<operator>.assignment xuclkudnbiaw=0
<operator>.assignment ajpclngqnvhb[anscnt++]=bc
<operator>.subtraction anscnt-1
<operator>.minus -3
<operator>.assignment anscnt=0
<operator>.assignment xuclkudnbiaw=-3
<operator>.postIncrement anscnt++
<operator>.minus -3
<operator>.addressOf &C
<operator>.addressOf &D
<operator>.addressOf &N
<operator>.indirectIndexAccess c[xuclkudnbiaw][j]
<operator>.addressOf &b1
<operator>.addressOf &b2
<operator>.addressOf &bc
<operator>.indirectIndexAccess c[b1][b2]
<operator>.addressOf &b1
<operator>.addressOf &b2
<operator>.indirectIndexAccess d[b1][b2]
<operator>.addressOf &bc
<operator>.indirectIndexAccess c[xuclkudnbiaw]
<operator>.indirectIndexAccess d[xuclkudnbiaw][j]
<operator>.indirectIndexAccess c[b1]
<operator>.indirectIndexAccess c[b2][b1]
<operator>.indirectIndexAccess d[b1]
<operator>.indirectIndexAccess d[b2][b1]
<operator>.indirectIndexAccess c[bc][ajpclngqnvhb[anscnt-1]]
<operator>.indirectIndexAccess d[xuclkudnbiaw]
<operator>.indirectIndexAccess c[b2]
<operator>.indirectIndexAccess d[b2]
<operator>.indirectIndexAccess c[bc]
<operator>.indirectIndexAccess ajpclngqnvhb[anscnt-1]
<operator>.indirectIndexAccess ajpclngqnvhb[anscnt-1]
<operator>.indirectIndexAccess c[bc][ajpclngqnvhb[anscnt-1]]
<operator>.indirectIndexAccess ajpclngqnvhb[xuclkudnbiaw]
<operator>.indirectIndexAccess c[bc]
<operator>.indirectIndexAccess ajpclngqnvhb[anscnt-1]
<operator>.indirectIndexAccess ajpclngqnvhb[xuclkudnbiaw]
<operator>.indirectIndexAccess d[ajpclngqnvhb[xuclkudnbiaw]][bc]
<operator>.indirectIndexAccess ajpclngqnvhb[anscnt++]
<operator>.indirectIndexAccess d[ajpclngqnvhb[xuclkudnbiaw]]
<operator>.indirectIndexAccess ajpclngqnvhb[xuclkudnbiaw]
>>>PDG&90 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->54 0->55 2->1 3->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->12 6->13 6->14 6->14 6->15 6->16 6->18 6->19 6->20 6->21 6->23 6->32 6->56 6->57 6->58 7->1 7->6 8->5 9->1 9->6 10->1 10->18 11->1 11->21 11->41 12->1 12->19 13->1 13->20 14->1 14->7 15->1 16->1 16->1 16->16 16->17 16->17 16->24 16->24 16->33 17->1 17->16 18->1 18->1 18->10 18->18 18->27 18->28 18->37 18->60 18->61 18->62 18->63 18->70 18->71 18->76 19->1 19->1 19->12 19->19 19->29 19->30 19->38 19->64 19->65 19->66 19->72 19->73 19->77 20->1 20->1 20->13 20->20 20->31 20->34 20->41 20->67 21->1 21->1 21->1 21->21 21->22 21->35 21->35 22->1 22->21 23->16 24->1 24->1 24->16 24->24 24->25 24->25 24->26 24->36 24->59 24->68 24->69 24->75 25->1 25->24 26->1 26->1 26->1 27->1 27->1 27->1 27->29 28->1 28->1 28->1 29->1 29->1 29->27 30->1 30->1 30->1 31->1 31->28 31->37 31->49 32->1 32->21 33->1 33->24 34->1 34->1 34->1 34->39 34->39 34->43 34->45 34->47 34->48 34->50 34->51 34->80 34->81 34->83 34->84 35->1 35->22 35->40 35->42 35->82 35->85 36->1 36->26 37->1 37->1 37->28 38->1 38->30 39->1 39->1 39->1 40->1 40->1 40->42 41->34 41->34 41->43 41->46 41->46 41->47 41->74 41->78 41->79 42->1 42->1 42->40 43->21 43->41 43->44 43->45 43->54 43->86 43->88 43->89 44->1 44->43 45->1 45->1 45->49 45->54 45->87 46->43 46->47 47->50 48->43 49->1 49->1 49->1 50->21 50->41 51->45 52->1 52->21 52->41 52->54 53->1 53->45 54->21 54->41 55->53 86->43 86->44 86->52 86->53 86->55
>>>Token int main ( void ) { freopen ( " " , " " , stdin ) ; int xuclkudnbiaw , j , t , T , C , D , N , anscnt ; char ajpclngqnvhb [ 111 ] , c [ M ] [ M ] , d [ M ] [ M ] , b1 , b2 , bc ; scanf ( " " , & T ) ; for ( t = 1 ; t <= T ; t ++ ) { scanf ( " " , & C ) ; anscnt = 0 ; for ( xuclkudnbiaw = 0 ; xuclkudnbiaw < M ; xuclkudnbiaw ++ ) for ( j = 0 ; j < M ; j ++ ) c [ xuclkudnbiaw ] [ j ] = d [ xuclkudnbiaw ] [ j ] = 0 ; while ( C -- ) { scanf ( " " , & b1 , & b2 , & bc ) ; c [ b1 ] [ b2 ] = c [ b2 ] [ b1 ] = bc ; } scanf ( " " , & D ) ; while ( D -- ) { scanf ( " " , & b1 , & b2 ) ; d [ b1 ] [ b2 ] = d [ b2 ] [ b1 ] = 1 ; } scanf ( " " , & N ) ; while ( N -- ) { scanf ( " " , & bc ) ; if ( anscnt > 0 && c [ bc ] [ ajpclngqnvhb [ anscnt - 1 ] ] ) { ajpclngqnvhb [ anscnt - 1 ] = c [ bc ] [ ajpclngqnvhb [ anscnt - 1 ] ] ; } else { for ( xuclkudnbiaw = 0 ; xuclkudnbiaw < anscnt ; xuclkudnbiaw ++ ) { if ( d [ ajpclngqnvhb [ xuclkudnbiaw ] ] [ bc ] ) { anscnt = 0 ; xuclkudnbiaw = -3 ; break ; } } if ( xuclkudnbiaw != -3 ) { ajpclngqnvhb [ anscnt ++ ] = bc ; } } } flwsusyeifdo ( " " , t ) ; for ( xuclkudnbiaw = 0 ; xuclkudnbiaw < anscnt ; xuclkudnbiaw ++ ) { if ( xuclkudnbiaw == 0 ) flwsusyeifdo ( " " , ajpclngqnvhb [ xuclkudnbiaw ] ) ; else flwsusyeifdo ( " " , ajpclngqnvhb [ xuclkudnbiaw ] ) ; } flwsusyeifdo ( " \n " ) ; } return 0 ; }
>>>Func
METHOD jrcbjctvjlvhset_extend_size
METHOD_RETURN ANY
PARAM uintmax_t ywewuygvgrrt
<operator>.assignment cgbwzddtngez=true
<operator>.assignment extend_size=ywewuygvgrrt
RETURN return cgbwzddtngez; return cgbwzddtngez;
IDENTIFIER extend_size if (extend_size)
IDENTIFIER cgbwzddtngez return cgbwzddtngez;
error error(0 0 _("'/' specifier only allowed"" with the last value"))
<operator>.assignment cgbwzddtngez=false
_ _("'/' specifier only allowed"" with the last value")
>>>PDG&11 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 2->4 3->1 3->1 3->1 3->7 4->1 4->1 4->1 5->1 7->5 8->1 8->1 9->1 9->1 9->1 9->7 10->8
>>>Token static jrcbjctvjlvhset_extend_size ( uintmax_t ywewuygvgrrt )  { jrcbjctvjlvh cgbwzddtngez = true ; if ( extend_size ) { error ( 0 , 0 , _ ( " " " " ) ) ; cgbwzddtngez = false ; } extend_size = ywewuygvgrrt ; return cgbwzddtngez ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment ii=0
<operator>.assignment input=fopen("A-small-attempt2.in","r")
<operator>.assignment output=fopen("test.out","w+")
fscanf fscanf(input," %ld\n",&cases)
fclose fclose(input)
fclose fclose(output)
RETURN return 0; return 0;
<operator>.lessThan ii++<cases
LITERAL 0 return 0;
fopen fopen("A-small-attempt2.in","r")
fopen fopen("test.out","w+")
<operator>.assignment CommonFactor=1
fscanf fscanf(input," %ld %ld %ld",&n,&d,&g)
<operator>.assignment WinMost=g
<operator>.assignment LoseMost=100-g
<operator>.assignment WinMin=d
<operator>.assignment LoseMin=100/CommonFactor-d
<operator>.postIncrement ii++
<operator>.lessThan i<2
<operator>.postIncrement i++
<operator>.lessThan i<2
<operator>.postIncrement i++
<operator>.greaterThan LoseMin+WinMin>n
<operator>.subtraction 100-g
<operator>.assignment i=0
<operator>.assignment i=0
<operator>.subtraction 100/CommonFactor-d
fprintf fprintf(output,"Case #%ld: Broken\n",ii)
<operator>.equals (d%2)==0
<operator>.equals (d%5)==0
<operator>.division 100/CommonFactor
<operator>.addition LoseMin+WinMin
<operator>.assignment d=d/2
<operator>.assignmentMultiplication CommonFactor *=2
<operator>.assignment d=d/5
<operator>.assignmentMultiplication CommonFactor *=5
<operator>.logicalOr ((WinMost==0)&&(WinMin>0))||((LoseMost==0)&&(LoseMin>0))
<operator>.modulo d%2
<operator>.modulo d%5
fprintf fprintf(output,"Case #%ld: Broken\n",ii)
<operator>.division d/2
<operator>.division d/5
<operator>.logicalAnd (WinMost==0)&&(WinMin>0)
<operator>.logicalAnd (LoseMost==0)&&(LoseMin>0)
fprintf fprintf(output,"Case #%ld: Possible\n",ii)
<operator>.equals WinMost==0
<operator>.greaterThan WinMin>0
<operator>.equals LoseMost==0
<operator>.greaterThan LoseMin>0
<operator>.addressOf &n
<operator>.addressOf &d
<operator>.addressOf &g
>>>PDG&54 0->2 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->37 0->39 0->40 0->41 0->42 0->43 0->46 0->47 0->48 0->49 0->50 2->1 2->19 3->1 3->1 3->5 4->1 4->1 4->7 4->29 4->41 4->46 5->1 5->1 5->6 5->9 5->14 6->1 6->1 7->1 7->1 8->1 9->1 9->1 9->1 9->9 9->13 9->14 9->15 9->16 9->17 9->18 9->19 9->20 9->22 9->24 9->25 9->26 9->27 9->28 9->32 9->33 9->51 9->52 9->53 10->8 11->3 11->3 12->4 12->4 13->1 13->32 13->35 13->37 14->1 14->1 14->1 14->1 14->6 14->15 14->17 14->24 14->25 14->28 14->39 14->40 14->42 14->43 15->1 15->1 15->47 16->1 16->1 16->1 16->49 17->1 17->24 17->33 17->48 18->1 18->1 18->24 18->33 18->50 19->1 19->9 19->29 19->41 19->46 20->21 20->30 20->39 21->1 21->20 22->1 22->1 22->23 22->31 22->40 23->1 23->22 24->1 24->1 24->1 24->14 24->29 24->38 24->44 24->47 25->1 25->14 25->15 25->16 25->16 26->20 27->1 27->22 28->1 28->1 28->14 28->17 28->18 28->18 28->39 28->40 29->1 29->7 29->19 29->41 29->46 30->1 30->1 30->20 30->21 30->34 30->35 30->42 31->1 31->1 31->22 31->23 31->36 31->37 31->43 32->1 32->28 32->28 33->1 33->1 34->1 34->1 34->17 34->28 34->39 34->40 35->1 35->32 35->37 36->1 36->1 36->17 36->28 36->40 37->1 37->32 38->1 38->1 38->1 38->41 38->46 39->17 39->28 39->30 39->30 39->40 39->42 40->17 40->28 40->31 40->31 40->43 41->1 41->7 41->19 41->29 41->46 42->34 42->34 43->36 43->36 44->1 44->1 44->38 44->38 44->45 44->49 45->1 45->1 45->38 45->38 46->1 46->7 46->19 46->29 46->41 47->1 47->44 47->44 47->48 48->1 48->44 48->44 49->1 49->45 49->45 49->50 50->1 50->45 50->45
>>>Token int main ( ) { FILE * input , * output ; long crdwyyefrirucases , ii = 0 ; input = fopen ( " " , " " ) ; output = fopen ( " " , " " ) ; fscanf ( input , " \n " , & cases ) ; while ( ii ++ < cases ) { long crdwyyefrirun , d , g , i ; long crdwyyefriruWinMost , LoseMost , WinMin , LoseMin , CommonFactor = 1 ; fscanf ( input , " " , & n , & d , & g ) ; WinMost = g ; LoseMost = 100 - g ; for ( i = 0 ; i < 2 ; i ++ ) { if ( ( d % 2 ) == 0 ) { d = d / 2 ; CommonFactor *= 2 ; } else { break ; } } for ( i = 0 ; i < 2 ; i ++ ) { if ( ( d % 5 ) == 0 ) { d = d / 5 ; CommonFactor *= 5 ; } else { break ; } } WinMin = d ; LoseMin = 100 / CommonFactor - d ; if ( LoseMin + WinMin > n ) { fprintf ( output , " \n " , ii ) ; } else { if ( ( ( WinMost == 0 ) && ( WinMin > 0 ) ) || ( ( LoseMost == 0 ) && ( LoseMin > 0 ) ) ) { fprintf ( output , " \n " , ii ) ; } else { fprintf ( output , " \n " , ii ) ; } } } fclose ( input ) ; fclose ( output ) ; return 0 ; }
>>>Func
METHOD gsxeuwefrtoa
METHOD_RETURN void
PARAM char lzonmtimzlsn
PARAM int obcianlynyfh
<operator>.equals mark==1
<operator>.equals mark==2
<operator>.assignment mark=0
<operator>.logicalAnd markId==0&&lzonmtimzlsn==dstring[0][1]
<operator>.logicalAnd markId==1&&lzonmtimzlsn==dstring[0][0]
<operator>.lessEqualsThan qdgdotmvehab<=obcianlynyfh
<operator>.postIncrement qdgdotmvehab++
<operator>.assignment nstring[qdgdotmvehab]='0'
<operator>.assignment mark=2
<operator>.assignment mark=2
<operator>.equals lzonmtimzlsn==dstring[0][0]
<operator>.equals lzonmtimzlsn==dstring[0][1]
<operator>.assignment qdgdotmvehab=0
<operator>.equals markId==0
<operator>.equals lzonmtimzlsn==dstring[0][1]
<operator>.equals markId==1
<operator>.equals lzonmtimzlsn==dstring[0][0]
<operator>.assignment mark=1
<operator>.assignment markId=0
<operator>.assignment mark=1
<operator>.assignment markId=1
<operator>.indirectIndexAccess nstring[qdgdotmvehab]
<operator>.indirectIndexAccess dstring[0][1]
<operator>.indirectIndexAccess dstring[0][0]
<operator>.indirectIndexAccess dstring[0][0]
<operator>.indirectIndexAccess dstring[0][1]
<operator>.indirectIndexAccess dstring[0]
<operator>.indirectIndexAccess dstring[0]
<operator>.indirectIndexAccess dstring[0]
<operator>.indirectIndexAccess dstring[0]
>>>PDG&34 0->2 0->3 0->4 0->5 0->6 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 2->1 2->14 2->18 2->20 3->9 4->1 4->5 4->7 4->8 4->14 4->15 4->17 4->19 4->28 4->29 4->32 4->33 5->1 5->6 5->9 5->16 6->1 6->1 7->1 7->1 7->1 7->12 8->1 8->1 8->1 8->13 9->1 9->1 9->1 9->9 9->10 9->10 9->11 9->25 10->1 10->9 11->1 11->1 12->1 12->5 13->1 13->5 14->1 14->1 14->15 14->21 14->22 15->1 15->1 15->1 15->23 15->24 16->1 16->9 17->7 17->7 17->18 17->19 17->26 17->30 18->1 18->1 18->7 18->7 18->20 19->1 19->8 19->8 19->20 19->27 19->31 20->1 20->1 20->8 20->8 21->1 21->5 22->1 22->1 23->1 23->5 24->1 24->1
>>>Token void gsxeuwefrtoa ( char lzonmtimzlsn , int obcianlynyfh ) { int qdgdotmvehab ; if ( mark == 1 ) { if ( markId == 0 && lzonmtimzlsn == dstring [ 0 ] [ 1 ] ) mark = 2 ; if ( markId == 1 && lzonmtimzlsn == dstring [ 0 ] [ 0 ] ) mark = 2 ; } else { if ( lzonmtimzlsn == dstring [ 0 ] [ 0 ] ) { mark = 1 ; markId = 0 ; } if ( lzonmtimzlsn == dstring [ 0 ] [ 1 ] ) { mark = 1 ; markId = 1 ; } } if ( mark == 2 ) { for ( qdgdotmvehab = 0 ; qdgdotmvehab <= obcianlynyfh ; qdgdotmvehab ++ ) nstring [ qdgdotmvehab ] = ' ' ; mark = 0 ; } }
>>>Func
METHOD irrjjiydmhid
METHOD_RETURN void
PARAM BSTIterator *obj
free free(obj->values)
free free(obj)
>>>PDG&5 0->2 0->4 2->4 3->1 4->1
>>>Token void irrjjiydmhid ( BSTIterator * obj ) { free ( obj -> values ) ; free ( obj ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment fin=fopen("input.txt","r")
<operator>.assignment fout=fopen("output.txt","w")
fscanf fscanf(fin,"%d",&wsagwxidbpwa)
<operator>.lessThan i<wsagwxidbpwa
<operator>.postIncrement i++
fopen fopen("input.txt","r")
fopen fopen("output.txt","w")
<operator>.assignment i=0
fscanf fscanf(fin,"%c",&ipiearyvwbpo)
<operator>.assignment total_v=0
<operator>.assignment cgeocuapiklt=0
fscanf fscanf(fin,"%d %d",&c,&d)
<operator>.assignment arr=(X *)malloc(c *sizeof(X))
<operator>.assignment pos=(int *)malloc(total_v *sizeof(int))
fprintf fprintf(fout,"Case #%d: %lf\n",i+1,cgeocuapiklt)
<operator>.lessThan j<c
<operator>.postIncrement j++
<operator>.lessThan k<c
<operator>.postIncrement k++
<operator>.lessThan j<total_v
<operator>.postIncrement j++
<operator>.cast (X *)malloc(c *sizeof(X))
<operator>.assignment j=0
fscanf fscanf(fin,"%c",&ipiearyvwbpo)
<operator>.assignment arr[j].min=total_v
fscanf fscanf(fin,"%d %d",&arr[j].p,&arr[j].v)
<operator>.assignmentPlus total_v+=arr[j].v
<operator>.assignment arr[j].max=total_v
<operator>.cast (int *)malloc(total_v *sizeof(int))
<operator>.assignment k=0
<operator>.assignment j=1
<operator>.assignment jbnznlkmasge=pos[j]
<operator>.assignment y=pos[j-1]
<operator>.addition i+1
malloc malloc(c *sizeof(X))
malloc malloc(total_v *sizeof(int))
<operator>.lessThan p<arr[k].max
<operator>.postIncrement p++
<operator>.assignment pos[p]=arr[k].p
<operator>.lessThan jbnznlkmasge-y<d
<operator>.multiplication c *sizeof(X)
<operator>.multiplication total_v *sizeof(int)
<operator>.assignment p=arr[k].min
<operator>.assignmentPlus cgeocuapiklt+=(double)((double)(d-(jbnznlkmasge-y))/2)
<operator>.sizeOf sizeof(X)
<operator>.sizeOf sizeof(int)
<operator>.subtraction j-1
<operator>.subtraction jbnznlkmasge-y
<operator>.cast (double)((double)(d-(jbnznlkmasge-y))/2)
<operator>.division (double)(d-(jbnznlkmasge-y))/2
<operator>.cast (double)(d-(jbnznlkmasge-y))
<operator>.subtraction d-(jbnznlkmasge-y)
<operator>.subtraction jbnznlkmasge-y
<operator>.addressOf &ipiearyvwbpo
<operator>.addressOf &c
<operator>.addressOf &d
UNKNOWN X * X *
UNKNOWN int * int *
<operator>.addressOf &ipiearyvwbpo
<operator>.fieldAccess arr[j].min
<operator>.addressOf &arr[j].p
<operator>.addressOf &arr[j].v
<operator>.fieldAccess arr[j].v
<operator>.fieldAccess arr[j].max
<operator>.indirectIndexAccess pos[j]
<operator>.indirectIndexAccess pos[j-1]
<operator>.indirectIndexAccess arr[j]
FIELD_IDENTIFIER min min
<operator>.fieldAccess arr[j].p
<operator>.fieldAccess arr[j].v
<operator>.indirectIndexAccess arr[j]
FIELD_IDENTIFIER v v
<operator>.indirectIndexAccess arr[j]
FIELD_IDENTIFIER max max
<operator>.fieldAccess arr[k].max
<operator>.indirectIndexAccess pos[p]
<operator>.fieldAccess arr[k].p
<operator>.indirectIndexAccess arr[j]
FIELD_IDENTIFIER p p
<operator>.indirectIndexAccess arr[j]
FIELD_IDENTIFIER v v
<operator>.fieldAccess arr[k].min
<operator>.indirectIndexAccess arr[k]
FIELD_IDENTIFIER max max
<operator>.indirectIndexAccess arr[k]
FIELD_IDENTIFIER p p
<operator>.indirectIndexAccess arr[k]
FIELD_IDENTIFIER min min
UNKNOWN double double
UNKNOWN double double
>>>PDG&92 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->31 0->32 0->35 0->38 0->39 0->41 0->42 0->43 0->45 0->48 0->49 0->51 0->53 0->54 2->1 2->1 2->4 3->1 3->1 3->1 3->16 4->1 4->1 4->1 4->5 4->10 5->1 5->1 5->1 5->5 5->6 5->6 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->16 5->17 5->19 5->21 5->23 5->24 5->30 5->31 5->32 5->35 5->35 5->36 5->37 5->42 5->43 5->46 5->47 5->55 5->56 5->57 5->58 5->59 6->1 6->5 7->2 7->2 8->3 8->3 9->1 9->5 10->1 10->1 10->13 10->25 11->1 11->26 11->28 11->43 12->1 12->16 12->45 13->1 13->1 13->1 13->1 13->10 13->17 13->19 13->25 13->41 13->42 13->53 14->1 14->1 14->1 15->1 15->1 15->1 15->33 15->34 16->1 16->1 16->1 16->1 17->1 17->17 17->18 17->18 17->19 17->25 17->26 17->27 17->28 17->29 17->60 17->61 17->62 17->63 17->64 17->65 17->68 17->69 17->70 17->71 17->72 17->73 17->74 17->75 17->79 17->80 17->81 17->82 18->1 18->17 19->1 19->1 19->1 19->13 19->19 19->20 19->20 19->38 19->42 19->44 19->76 19->83 19->84 19->85 19->88 19->89 20->1 20->19 21->1 21->1 21->1 21->21 21->22 21->33 21->34 21->41 21->48 21->48 21->49 21->66 21->67 22->1 22->21 23->1 24->1 24->17 25->1 25->1 25->10 25->27 26->1 27->1 27->1 27->1 27->1 27->10 27->25 27->28 28->1 28->26 28->29 28->43 29->1 30->1 31->1 31->19 32->1 32->21 33->1 33->1 33->49 34->1 34->1 34->49 36->1 36->14 36->23 37->1 37->15 37->30 38->1 38->1 38->38 38->39 38->39 38->40 38->76 38->77 38->78 38->84 38->85 38->86 38->87 39->1 39->38 40->1 40->1 41->1 41->1 41->1 41->13 41->45 41->50 41->51 41->52 41->53 41->53 41->54 41->90 41->91 42->17 42->36 43->21 43->37 44->1 44->38 45->1 45->1 45->16 46->1 47->1 48->22 49->1 49->1 49->41 49->41 49->54 49->54 50->1 51->1 51->45 51->45 51->50 51->50 52->1 53->1 53->1 53->13 53->41 53->51 53->51 53->52 53->52 54->1 54->1 54->53 54->53
>>>Token int main ( ) { int wsagwxidbpwa , c , d , i , j , k , p , total_v ; int jbnznlkmasge , y , * pos ; double cgeocuapiklt ; char ipiearyvwbpo ; FILE * fin , * fout ; fin = fopen ( " " , " " ) ; fout = fopen ( " " , " " ) ; fscanf ( fin , " " , & wsagwxidbpwa ) ; for ( i = 0 ; i < wsagwxidbpwa ; i ++ ) { fscanf ( fin , " " , & ipiearyvwbpo ) ; total_v = 0 ; cgeocuapiklt = 0 ; fscanf ( fin , " " , & c , & d ) ; arr = ( X * ) malloc ( c * sizeof ( X ) ) ; for ( j = 0 ; j < c ; j ++ ) { fscanf ( fin , " " , & ipiearyvwbpo ) ; arr [ j ] . min = total_v ; fscanf ( fin , " " , & arr [ j ] . p , & arr [ j ] . v ) ; total_v += arr [ j ] . v ; arr [ j ] . max = total_v ; } pos = ( int * ) malloc ( total_v * sizeof ( int ) ) ; for ( k = 0 ; k < c ; k ++ ) { for ( p = arr [ k ] . min ; p < arr [ k ] . max ; p ++ ) pos [ p ] = arr [ k ] . p ; } for ( j = 1 ; j < total_v ; j ++ ) { jbnznlkmasge = pos [ j ] ; y = pos [ j - 1 ] ; if ( jbnznlkmasge - y < d ) cgeocuapiklt += ( double ) ( ( double ) ( d - ( jbnznlkmasge - y ) ) / 2 ) ; } fprintf ( fout , " \n " , i + 1 , cgeocuapiklt ) ; } }
>>>Func
METHOD dhbhskgwoeny
METHOD_RETURN void
<operator>.lessThan tope<2
<operator>.lessThan qmobpnnkqvrb<x
<operator>.postIncrement qmobpnnkqvrb++
RETURN return ; return ;
<operator>.assignment qmobpnnkqvrb=0
<operator>.logicalAnd c[qmobpnnkqvrb][0]==lista[tope-1]&&c[qmobpnnkqvrb][1]==lista[tope-2]
<operator>.logicalAnd c[qmobpnnkqvrb][0]==lista[tope-2]&&c[qmobpnnkqvrb][1]==lista[tope-1]
<operator>.assignment lista[tope-2]=c[qmobpnnkqvrb][2]
<operator>.postDecrement tope--
<operator>.assignment lista[tope-2]=c[qmobpnnkqvrb][2]
<operator>.postDecrement tope--
<operator>.equals c[qmobpnnkqvrb][0]==lista[tope-1]
<operator>.equals c[qmobpnnkqvrb][1]==lista[tope-2]
<operator>.equals c[qmobpnnkqvrb][0]==lista[tope-2]
<operator>.equals c[qmobpnnkqvrb][1]==lista[tope-1]
<operator>.subtraction tope-1
<operator>.subtraction tope-2
<operator>.subtraction tope-2
<operator>.subtraction tope-2
<operator>.subtraction tope-1
<operator>.subtraction tope-2
<operator>.indirectIndexAccess c[qmobpnnkqvrb][0]
<operator>.indirectIndexAccess lista[tope-1]
<operator>.indirectIndexAccess c[qmobpnnkqvrb][1]
<operator>.indirectIndexAccess lista[tope-2]
<operator>.indirectIndexAccess lista[tope-2]
<operator>.indirectIndexAccess c[qmobpnnkqvrb][2]
<operator>.indirectIndexAccess c[qmobpnnkqvrb][0]
<operator>.indirectIndexAccess lista[tope-2]
<operator>.indirectIndexAccess c[qmobpnnkqvrb][1]
<operator>.indirectIndexAccess lista[tope-1]
<operator>.indirectIndexAccess lista[tope-2]
<operator>.indirectIndexAccess c[qmobpnnkqvrb][2]
<operator>.indirectIndexAccess c[qmobpnnkqvrb]
<operator>.indirectIndexAccess c[qmobpnnkqvrb]
<operator>.indirectIndexAccess c[qmobpnnkqvrb]
<operator>.indirectIndexAccess c[qmobpnnkqvrb]
<operator>.indirectIndexAccess c[qmobpnnkqvrb]
<operator>.indirectIndexAccess c[qmobpnnkqvrb]
>>>PDG&41 0->2 0->3 0->4 0->5 0->6 0->10 0->12 0->17 0->18 0->19 0->20 0->21 0->22 2->1 2->1 2->3 2->5 2->6 2->17 3->1 3->3 3->4 3->4 3->7 3->8 3->13 3->15 3->17 3->20 3->23 3->24 3->29 3->30 3->35 3->38 4->3 5->1 6->3 7->9 7->10 7->19 7->27 7->28 7->37 8->11 8->12 8->22 8->33 8->34 8->40 9->15 10->20 11->14 11->15 12->17 13->7 13->7 13->14 13->15 13->16 13->18 13->25 13->26 13->36 14->7 14->7 14->15 14->16 15->8 15->8 15->13 15->14 15->16 15->21 15->31 15->32 15->39 16->8 16->8 16->13 16->14 17->18 17->19 17->20 18->19 18->20 19->10 20->17 20->21 20->22 21->17 21->22 22->12
>>>Token void dhbhskgwoeny ( ) { int qmobpnnkqvrb ; if ( tope < 2 ) return ; for ( qmobpnnkqvrb = 0 ; qmobpnnkqvrb < x ; qmobpnnkqvrb ++ ) { if ( c [ qmobpnnkqvrb ] [ 0 ] == lista [ tope - 1 ] && c [ qmobpnnkqvrb ] [ 1 ] == lista [ tope - 2 ] ) { lista [ tope - 2 ] = c [ qmobpnnkqvrb ] [ 2 ] ; tope -- ; } if ( c [ qmobpnnkqvrb ] [ 0 ] == lista [ tope - 2 ] && c [ qmobpnnkqvrb ] [ 1 ] == lista [ tope - 1 ] ) { lista [ tope - 2 ] = c [ qmobpnnkqvrb ] [ 2 ] ; tope -- ; } } }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&xiqteyycfkke)
RETURN return 0; return 0;
<operator>.lessThan iT<xiqteyycfkke
<operator>.postIncrement iT++
LITERAL 0 return 0;
<operator>.assignment iT=0
scanf scanf("%d %d\n",&pvnvwvofljjt,&M)
<operator>.assignment lgwqoprgajzh=1<<(pvnvwvofljjt *M)
<operator>.assignment cqdvtvmafwij=0
printf printf("Case #%d: %d\n",iT+1,cqdvtvmafwij)
<operator>.lessThan mumcnmzstihi<pvnvwvofljjt
<operator>.postIncrement mumcnmzstihi++
scanf scanf("%s\n",a[mumcnmzstihi])
<operator>.lessThan bssqyhyhhrpk<lgwqoprgajzh
<operator>.postIncrement bssqyhyhhrpk++
<operator>.assignment mumcnmzstihi=0
<operator>.shiftLeft 1<<(pvnvwvofljjt *M)
<operator>.assignment bssqyhyhhrpk=0
<operator>.assignment y=bssqyhyhhrpk
memset memset(b 0 sizeof(b))
<operator>.assignment vpzffmhgvyou=1
<operator>.addition iT+1
<operator>.multiplication pvnvwvofljjt *M
<operator>.lessThan mumcnmzstihi<pvnvwvofljjt
<operator>.postIncrement mumcnmzstihi++
<operator>.lessThan mumcnmzstihi<pvnvwvofljjt
<operator>.postIncrement mumcnmzstihi++
IDENTIFIER vpzffmhgvyou if (vpzffmhgvyou)
<operator>.assignment mumcnmzstihi=0
<operator>.assignment mumcnmzstihi=0
<operator>.postIncrement cqdvtvmafwij++
<operator>.lessThan j<M
<operator>.postIncrement j++
<operator>.lessThan j<M
<operator>.postIncrement j++
<operator>.logicalNot !vpzffmhgvyou
<operator>.assignment j=0
<operator>.assignment d[mumcnmzstihi][j]=y%2
<operator>.assignmentDivision y/=2
<operator>.assignment j=0
<operator>.equals b[mumcnmzstihi][j]==0
<operator>.logicalNot !vpzffmhgvyou
<operator>.modulo y%2
<operator>.assignment jmazbukhrbdd=mumcnmzstihi
<operator>.assignment Y=j
<operator>.logicalOr (jmazbukhrbdd!=mumcnmzstihi)||(Y!=j)
<operator>.assignment b[jmazbukhrbdd][Y]=1
Move Move(jmazbukhrbdd,Y,&NX,&NY,pvnvwvofljjt,M)
<operator>.assignment jmazbukhrbdd=NX
<operator>.assignment Y=NY
<operator>.notEquals jmazbukhrbdd!=mumcnmzstihi
<operator>.notEquals Y!=j
<operator>.assignment vpzffmhgvyou=0
<operator>.addressOf &pvnvwvofljjt
<operator>.addressOf &M
<operator>.indirectIndexAccess a[mumcnmzstihi]
<operator>.sizeOf sizeof(b)
<operator>.indirectIndexAccess d[mumcnmzstihi][j]
<operator>.indirectIndexAccess d[mumcnmzstihi]
<operator>.indirectIndexAccess b[mumcnmzstihi][j]
<operator>.indirectIndexAccess b[mumcnmzstihi]
<operator>.indirectIndexAccess b[jmazbukhrbdd][Y]
<operator>.indirectIndexAccess b[jmazbukhrbdd][Y]
<operator>.addressOf &NX
<operator>.addressOf &NY
<operator>.indirectIndexAccess b[jmazbukhrbdd]
<operator>.indirectIndexAccess b[jmazbukhrbdd]
>>>PDG&69 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->48 0->49 0->50 0->51 0->52 0->53 0->54 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->11 4->12 4->15 4->17 4->18 4->19 4->23 4->23 4->24 4->55 4->56 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->12 8->24 8->25 8->27 8->49 9->1 9->1 9->15 10->1 10->11 10->32 11->1 11->1 11->1 12->1 12->1 12->12 12->13 12->13 12->14 12->24 12->57 13->1 13->12 14->1 15->1 15->1 15->1 15->15 15->16 15->16 15->20 15->20 15->21 15->22 15->25 15->27 15->30 15->31 15->32 15->58 16->1 16->15 17->1 17->12 18->1 18->9 18->9 19->1 19->15 20->1 20->1 20->44 21->1 21->1 22->1 22->1 22->37 22->43 24->1 24->1 24->8 24->12 24->18 24->18 24->25 24->33 24->35 25->25 25->26 25->26 25->27 25->33 25->38 26->1 26->25 27->1 27->1 27->1 27->8 27->12 27->25 27->28 27->35 27->37 27->41 27->45 27->49 27->52 28->1 28->27 30->25 31->1 31->27 32->1 32->11 33->1 33->1 33->1 33->24 33->33 33->34 33->34 33->35 33->39 33->40 33->44 33->59 33->60 34->1 34->33 35->1 35->1 35->1 35->24 35->33 35->36 35->42 35->43 35->46 35->49 35->53 35->61 35->62 36->1 36->35 37->1 37->1 37->27 37->28 37->43 38->1 38->33 39->1 39->1 39->1 40->1 40->1 40->44 41->1 41->35 42->1 42->1 42->45 42->46 42->63 42->67 43->35 43->36 43->37 44->39 44->39 44->40 45->1 45->1 45->1 45->49 46->1 46->1 46->1 46->49 47->1 47->1 47->1 47->63 47->67 48->1 48->1 49->1 49->1 49->1 49->1 49->1 49->8 49->12 49->24 49->25 49->27 49->33 49->35 49->50 49->51 50->1 50->1 50->52 51->1 51->1 51->1 51->49 51->53 52->1 52->1 52->28 52->45 52->47 52->47 52->49 52->53 53->1 53->1 53->36 53->47 53->47 53->49 54->1 54->43 63->47 63->48 63->49 63->50 63->51 63->52 63->54 63->64 63->65 63->66 63->68
>>>Token int main ( ) { int xiqteyycfkke , iT ; scanf ( " " , & xiqteyycfkke ) ; static imyiyhstgbjxb  [ MAXN ] [ MAXN ] ; for ( iT = 0 ; iT < xiqteyycfkke ; iT ++ ) { int pvnvwvofljjt , M ; scanf ( " \n " , & pvnvwvofljjt , & M ) ; int mumcnmzstihi , j ; for ( mumcnmzstihi = 0 ; mumcnmzstihi < pvnvwvofljjt ; mumcnmzstihi ++ ) scanf ( " \n " , a [ mumcnmzstihi ] ) ; int lgwqoprgajzh = 1 << ( pvnvwvofljjt * M ) ; int bssqyhyhhrpk , y ; int cqdvtvmafwij = 0 ; for ( bssqyhyhhrpk = 0 ; bssqyhyhhrpk < lgwqoprgajzh ; bssqyhyhhrpk ++ ) { y = bssqyhyhhrpk ; for ( mumcnmzstihi = 0 ; mumcnmzstihi < pvnvwvofljjt ; mumcnmzstihi ++ ) { for ( j = 0 ; j < M ; j ++ ) { d [ mumcnmzstihi ] [ j ] = y % 2 ; y /= 2 ; } } memset ( b , 0 , sizeof ( b ) ) ; imyiyhstgbjx vpzffmhgvyou = 1 ; for ( mumcnmzstihi = 0 ; mumcnmzstihi < pvnvwvofljjt ; mumcnmzstihi ++ ) { for ( j = 0 ; j < M ; j ++ ) { if ( b [ mumcnmzstihi ] [ j ] == 0 ) { int jmazbukhrbdd , Y , NX , NY ; jmazbukhrbdd = mumcnmzstihi ; Y = j ; do { if ( b [ jmazbukhrbdd ] [ Y ] ) { vpzffmhgvyou = 0 ; break ; } b [ jmazbukhrbdd ] [ Y ] = 1 ; Move ( jmazbukhrbdd , Y , & NX , & NY , pvnvwvofljjt , M ) ; jmazbukhrbdd = NX ; Y = NY ; } while ( ( jmazbukhrbdd != mumcnmzstihi ) || ( Y != j ) ) ; } if ( ! vpzffmhgvyou ) break ; } if ( ! vpzffmhgvyou ) break ; } if ( vpzffmhgvyou ) cqdvtvmafwij ++ ; } printf ( " \n " , iT + 1 , cqdvtvmafwij ) ; } return 0 ; }
>>>Func
METHOD lit_fichier
METHOD_RETURN char*
RETURN return ztbmqbtlzgdt; return ztbmqbtlzgdt;
<operator>.logicalNot !feof(fichier_source)
IDENTIFIER ztbmqbtlzgdt return ztbmqbtlzgdt;
<operator>.assignment kavmblhhnvaq=pb_get_taille()+1
<operator>.assignment *mjwlrnphzxqg=malloc(kavmblhhnvaq *sizeof(char))
feof feof(fichier_source)
<operator>.equals fscanf(fichier_source,"%s",mjwlrnphzxqg)==1
<operator>.addition pb_get_taille()+1
malloc malloc(kavmblhhnvaq *sizeof(char))
RETURN return mjwlrnphzxqg; return mjwlrnphzxqg;
<operator>.multiplication kavmblhhnvaq *sizeof(char)
fscanf fscanf(fichier_source,"%s",mjwlrnphzxqg)
IDENTIFIER mjwlrnphzxqg return mjwlrnphzxqg;
<operator>.sizeOf sizeof(char)
pb_get_taille pb_get_taille()
>>>PDG&17 0->2 0->4 0->5 0->7 0->8 0->9 0->12 0->13 0->14 2->1 3->1 3->1 3->2 3->5 3->6 3->8 3->9 3->10 3->12 3->13 3->15 3->16 4->2 5->1 5->1 5->12 6->1 6->1 6->13 7->3 7->13 8->1 8->1 8->2 8->11 9->1 10->1 10->6 11->1 12->1 12->10 13->1 13->1 13->8 13->8 13->8 13->14 14->11 15->1
>>>Token char * lit_fichier ( ) { if ( ! feof ( fichier_source ) ) { int kavmblhhnvaq = pb_get_taille ( ) + 1 ; char * mjwlrnphzxqg = malloc ( kavmblhhnvaq * sizeof ( char ) ) ; if ( fscanf ( fichier_source , " " , mjwlrnphzxqg ) == 1 ) return mjwlrnphzxqg ; } return ztbmqbtlzgdt ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&gnwqrpknlcfn)
RETURN return 0; return 0;
<operator>.postDecrement gnwqrpknlcfn--
solve solve()
LITERAL 0 return 0;
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 2->4 3->1 4->1 4->1 4->4 4->5 5->1 6->3
>>>Token int main ( ) { int gnwqrpknlcfn ; scanf ( " " , & gnwqrpknlcfn ) ; while ( gnwqrpknlcfn -- ) solve ( ) ; return 0 ; }
>>>Func
METHOD zuytrjuinojo
METHOD_RETURN void
<operator>.assignment spell_length=0
<operator>.postIncrement p++
<operator>.assignment oppose_elements[*p]=0
<operator>.assignment p=base
<operator>.indirection *p
<operator>.indirectIndexAccess oppose_elements[*p]
<operator>.indirection *p
>>>PDG&9 0->2 0->3 0->4 0->5 2->1 2->1 3->1 3->1 4->1 4->1 5->1 5->1 5->1 5->3 6->3 6->4 6->6 6->7 6->8
>>>Token void zuytrjuinojo ( ) { char * p ; for ( p = base ; * p ; p ++ ) oppose_elements [ * p ] = 0 ; spell_length = 0 ; }
>>>Func
METHOD vobpfzhwxjfcfactorial
METHOD_RETURN long
PARAM vobpfzhwxjfc puxoxvurnpdw
<operator>.assignment gwzlvwyzwjyi=puxoxvurnpdw
RETURN return gwzlvwyzwjyi; return gwzlvwyzwjyi;
<operator>.lessThan psojoskibtdw<puxoxvurnpdw
<operator>.postIncrement psojoskibtdw++
IDENTIFIER gwzlvwyzwjyi return gwzlvwyzwjyi;
<operator>.assignment psojoskibtdw=1
<operator>.assignment gwzlvwyzwjyi=gwzlvwyzwjyi *(puxoxvurnpdw-psojoskibtdw)
<operator>.multiplication gwzlvwyzwjyi *(puxoxvurnpdw-psojoskibtdw)
<operator>.subtraction puxoxvurnpdw-psojoskibtdw
>>>PDG&12 0->2 0->3 0->5 0->6 0->7 0->8 0->10 0->11 2->3 2->5 3->1 3->1 3->7 3->10 4->1 5->1 5->1 5->1 5->5 5->6 5->9 5->10 5->11 5->11 5->11 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->1 9->7 9->10 10->1 10->9 10->9 11->5 11->6 11->10 11->10
>>>Token long vobpfzhwxjfcfactorial ( vobpfzhwxjfc puxoxvurnpdw ) { vobpfzhwxjfc psojoskibtdw ; long vobpfzhwxjfcgwzlvwyzwjyi ; gwzlvwyzwjyi = puxoxvurnpdw ; for ( psojoskibtdw = 1 ; psojoskibtdw < puxoxvurnpdw ; psojoskibtdw ++ ) { gwzlvwyzwjyi = gwzlvwyzwjyi * ( puxoxvurnpdw - psojoskibtdw ) ; } return gwzlvwyzwjyi ; }
>>>Func
METHOD ncifzwesxhna
METHOD_RETURN int
PARAM char qhmhnznikhit
IDENTIFIER qhmhnznikhit switch(qhmhnznikhit)
LITERAL 'Q' <empty>
RETURN return 0; return 0;
LITERAL 'W' <empty>
RETURN return 1; return 1;
LITERAL 'E' <empty>
RETURN return 2; return 2;
LITERAL 'R' <empty>
RETURN return 3; return 3;
LITERAL 'A' <empty>
RETURN return 4; return 4;
LITERAL 'S' <empty>
RETURN return 5; return 5;
LITERAL 'D' <empty>
RETURN return 6; return 6;
LITERAL 'F' <empty>
RETURN return 7; return 7;
LITERAL 0 return 0;
LITERAL 1 return 1;
LITERAL 2 return 2;
LITERAL 3 return 3;
LITERAL 4 return 4;
LITERAL 5 return 5;
LITERAL 6 return 6;
LITERAL 7 return 7;
>>>PDG&28 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->1 5->1 7->1 9->1 11->1 13->1 15->1 17->1 19->1 20->5 21->7 22->9 23->11 24->13 25->15 26->17 27->19
>>>Token int ncifzwesxhna ( char qhmhnznikhit ) { switch ( qhmhnznikhit ) { case ' ' : return 0 ; case ' ' : return 1 ; case ' ' : return 2 ; case ' ' : return 3 ; case ' ' : return 4 ; case ' ' : return 5 ; case ' ' : return 6 ; case ' ' : return 7 ; } }
>>>Func
METHOD rghwwjpqunen
METHOD_RETURN int
PARAM int *tewrqolsopvz
PARAM int sldcyejlgvuj
PARAM int qvvockibcxsn
qsort qsort(tewrqolsopvz sldcyejlgvuj sizeof(int),cmpval)
RETURN return tewrqolsopvz[qvvockibcxsn-1]; return tewrqolsopvz[qvvockibcxsn-1];
<operator>.sizeOf sizeof(int)
<operator>.subtraction qvvockibcxsn-1
>>>PDG&9 0->2 0->3 0->4 0->5 0->8 2->5 3->5 4->8 5->1 5->1 5->1 5->1 6->1 7->1 8->1
>>>Token int rghwwjpqunen ( int * tewrqolsopvz , int sldcyejlgvuj , int qvvockibcxsn ) { qsort ( tewrqolsopvz , sldcyejlgvuj , sizeof ( int ) , cmpval ) ; return tewrqolsopvz [ qvvockibcxsn - 1 ] ; }
>>>Func
METHOD skipTK
METHOD_RETURN ulleaeyszahxchar
PARAM char *igukqqncuxhx
<operator>.assignment igpkvfzeuyom=0
RETURN return igukqqncuxhx+igpkvfzeuyom; return igukqqncuxhx+igpkvfzeuyom;
<operator>.logicalAnd igukqqncuxhx[igpkvfzeuyom]!=''&&igukqqncuxhx[igpkvfzeuyom]!=0
<operator>.postIncrement igpkvfzeuyom++
<operator>.logicalAnd igukqqncuxhx[igpkvfzeuyom]==''&&igukqqncuxhx[igpkvfzeuyom]!=0
<operator>.postIncrement igpkvfzeuyom++
<operator>.addition igukqqncuxhx+igpkvfzeuyom
<operator>.notEquals igukqqncuxhx[igpkvfzeuyom]!=''
<operator>.notEquals igukqqncuxhx[igpkvfzeuyom]!=0
<operator>.equals igukqqncuxhx[igpkvfzeuyom]==''
<operator>.notEquals igukqqncuxhx[igpkvfzeuyom]!=0
<operator>.indirectIndexAccess igukqqncuxhx[igpkvfzeuyom]
<operator>.indirectIndexAccess igukqqncuxhx[igpkvfzeuyom]
<operator>.indirectIndexAccess igukqqncuxhx[igpkvfzeuyom]
<operator>.indirectIndexAccess igukqqncuxhx[igpkvfzeuyom]
>>>PDG&18 0->2 0->3 0->6 0->8 0->9 0->10 0->11 0->12 0->13 2->9 2->10 2->11 2->12 2->13 3->1 3->6 3->8 3->9 4->1 5->1 5->1 5->5 5->6 5->7 5->10 5->14 6->1 6->8 6->9 7->1 7->1 7->1 7->7 7->8 7->12 7->16 8->1 8->9 9->1 9->1 9->1 9->4 10->5 10->5 10->11 10->11 10->12 10->15 11->5 11->5 11->10 11->12 12->1 12->7 12->7 12->9 12->13 12->13 12->17 13->1 13->7 13->7 13->9 13->12
>>>Token def bydjfjowayogulleaeyszahx  xeqrhwwfeprhLARGE ulleaeyszahxchar * skipTK ( char * igukqqncuxhx ) { int igpkvfzeuyom ; igpkvfzeuyom = 0 ; while ( igukqqncuxhx [ igpkvfzeuyom ] != ' ' && igukqqncuxhx [ igpkvfzeuyom ] != 0 ) igpkvfzeuyom ++ ; while ( igukqqncuxhx [ igpkvfzeuyom ] == ' ' && igukqqncuxhx [ igpkvfzeuyom ] != 0 ) igpkvfzeuyom ++ ; return igukqqncuxhx + igpkvfzeuyom ; }
>>>Func
METHOD vmcexctmbkac
METHOD_RETURN void
<operator>.assignment rn=0
<operator>.lessThan pnehwzxtsqes<n
<operator>.postIncrement pnehwzxtsqes++
<operator>.assignment pnehwzxtsqes=0
<operator>.assignment res[rn++]=invoke[pnehwzxtsqes]
<operator>.greaterThan rn>1
<operator>.greaterThan rn>1
<operator>.assignment jebobyvdropy=combine[(int)res[rn-1]][(int)res[rn-2]]
<operator>.assignment opp=res[rn-1]
<operator>.postIncrement rn++
IDENTIFIER jebobyvdropy if (jebobyvdropy)
<operator>.lessThan j<rn-1
<operator>.postIncrement j++
<operator>.assignment res[rn-2]=jebobyvdropy
<operator>.postDecrement rn--
<operator>.assignment j=0
<operator>.cast (int)res[rn-2]
<operator>.subtraction rn-1
<operator>.subtraction rn-1
<operator>.assignment rn=0
<operator>.cast (int)res[rn-1]
<operator>.subtraction rn-2
<operator>.subtraction rn-2
<operator>.cast (int)res[j]
<operator>.subtraction rn-1
<operator>.indirectIndexAccess res[rn++]
<operator>.indirectIndexAccess invoke[pnehwzxtsqes]
<operator>.indirectIndexAccess combine[(int)res[rn-1]][(int)res[rn-2]]
<operator>.indirectIndexAccess res[rn-1]
<operator>.indirectIndexAccess combine[(int)res[rn-1]]
<operator>.indirectIndexAccess oppose[(int)res[j]][opp]
UNKNOWN int int
<operator>.indirectIndexAccess res[rn-2]
<operator>.indirectIndexAccess res[rn-2]
<operator>.indirectIndexAccess oppose[(int)res[j]]
UNKNOWN int int
<operator>.indirectIndexAccess res[rn-1]
UNKNOWN int int
<operator>.indirectIndexAccess res[j]
>>>PDG&41 0->2 0->3 0->4 0->5 0->7 0->8 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->23 0->24 0->26 2->1 2->1 2->11 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->7 3->11 3->27 3->28 4->1 4->3 5->1 5->3 6->1 6->1 6->1 7->1 7->8 7->8 7->9 7->15 7->16 7->18 7->22 7->23 7->24 7->26 7->26 7->29 7->31 7->33 7->34 7->35 7->37 7->38 8->1 8->1 8->10 8->11 8->13 8->17 8->19 8->19 8->20 8->30 9->1 9->1 9->1 9->15 10->1 10->1 10->1 11->7 13->1 13->1 13->1 13->14 13->25 13->32 13->36 13->39 13->40 14->1 14->13 15->1 15->1 15->1 15->18 16->1 16->1 16->11 17->1 17->13 18->1 19->20 20->1 20->11 20->13 20->13 21->1 21->1 21->11 22->1 23->8 23->24 24->16 25->1 26->23 32->13 32->14 32->20 32->21
>>>Token void vmcexctmbkac ( ) { int pnehwzxtsqes , opp , j ; char jebobyvdropy ; rn = 0 ; for ( pnehwzxtsqes = 0 ; pnehwzxtsqes < n ; pnehwzxtsqes ++ ) { res [ rn ++ ] = invoke [ pnehwzxtsqes ] ; if ( rn > 1 ) { jebobyvdropy = combine [ ( int ) res [ rn - 1 ] ] [ ( int ) res [ rn - 2 ] ] ; if ( jebobyvdropy ) { res [ rn - 2 ] = jebobyvdropy ; rn -- ; continue ; } } if ( rn > 1 ) { opp = res [ rn - 1 ] ; for ( j = 0 ; j < rn - 1 ; j ++ ) if ( oppose [ ( int ) res [ j ] ] [ opp ] ) { rn = 0 ; break ; } } } }
>>>Func
METHOD hfwxbabltfce
METHOD_RETURN void
PARAM HashTable *hash_table
PARAM HashTableKeyFreeFunc kvduzpihskch
PARAM HashTableValueFreeFunc gffarzemffsk
<operator>.assignment hash_table->kvduzpihskch=kvduzpihskch
<operator>.assignment hash_table->gffarzemffsk=gffarzemffsk
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->5 4->6 5->1 5->1 5->1 6->1 6->1 6->1
>>>Token void hfwxbabltfce ( HashTable * hash_table , HashTableKeyFreeFunc kvduzpihskch , HashTableValueFreeFunc gffarzemffsk ) { hash_table -> kvduzpihskch = kvduzpihskch ; hash_table -> gffarzemffsk = gffarzemffsk ; }
>>>Func
METHOD frjavwkgngaj
METHOD_RETURN int
scanf scanf("%d",&grclmiladloi)
RETURN return grclmiladloi; return grclmiladloi;
IDENTIFIER grclmiladloi return grclmiladloi;
>>>PDG&5 0->2 0->4 2->1 2->4 3->1 4->3
>>>Token int frjavwkgngaj ( ) { int grclmiladloi ; scanf ( " " , & grclmiladloi ) ; return grclmiladloi ; }
>>>Func
METHOD bzdsotixqvbi
METHOD_RETURN void
clear clear()
<operator>.postIncrement i++
<operator>.assignment i=base
<operator>.postIncrement j++
<operator>.assignment j=base
<operator>.assignment combine[*i][*j]=0
<operator>.assignment oppose[*i][*j]=0
<operator>.indirection *i
<operator>.indirection *j
<operator>.indirectIndexAccess combine[*i][*j]
<operator>.indirectIndexAccess oppose[*i][*j]
<operator>.indirectIndexAccess combine[*i]
<operator>.indirection *j
<operator>.indirectIndexAccess oppose[*i]
<operator>.indirection *j
<operator>.indirection *i
<operator>.indirection *i
>>>PDG&19 0->2 0->3 0->4 0->5 0->6 0->7 0->8 2->1 3->1 3->1 4->1 4->1 4->1 4->3 5->1 5->1 6->1 6->1 6->1 6->5 7->1 7->1 8->1 8->1 9->3 9->6 9->9 9->10 10->5 10->7 10->8 10->10 10->11 10->12 10->13 10->14 10->15 10->16 10->17 10->18
>>>Token void bzdsotixqvbi ( ) { char * i , * j ; for ( i = base ; * i ; i ++ ) for ( j = base ; * j ; j ++ ) { combine [ * i ] [ * j ] = 0 ; oppose [ * i ] [ * j ] = 0 ; } clear ( ) ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf("Enter octal value: ")
scanf scanf("%d",&vjfaegdwkpna)
<operator>.assignment cpuyfwzahoajresult=toDecimal(vjfaegdwkpna)
printf printf("%d in decimal is %lld\n",vjfaegdwkpna,result)
RETURN return 0; return 0;
LITERAL 0 return 0;
toDecimal toDecimal(vjfaegdwkpna)
>>>PDG&9 0->2 0->3 0->5 0->6 0->7 0->8 2->1 3->1 3->5 3->8 4->1 4->1 4->1 5->1 5->1 5->1 6->1 7->6 8->4 8->5
>>>Token int main ( ) { printf ( " " ) ; int vjfaegdwkpna ; scanf ( " " , & vjfaegdwkpna ) ; cpuyfwzahoaj cpuyfwzahoajresult = toDecimal ( vjfaegdwkpna ) ; printf ( " \n " , vjfaegdwkpna , result ) ; return 0 ; }
>>>Func
METHOD htmpzvssqvwk
METHOD_RETURN int
printf printf("\n")
printf printf(" +-------------------------------------+\n")
printf printf(" |                                     |\n")
printf printf(" |               C Array               |\n")
printf printf(" |                                     |\n")
printf printf(" +-------------------------------------+\n")
printf printf("\n")
<operator>.assignment *tvvqnjlqxkuk=getCArray(10)
<operator>.lessThan zvexiyzncbvk<tvvqnjlqxkuk->size
<operator>.postIncrement zvexiyzncbvk++
printf printf("Entered array is:\n")
displayCArray displayCArray(tvvqnjlqxkuk)
printf printf("\nCode: %d\n" pushValueCArray(tvvqnjlqxkuk,11))
<operator>.lessThan zvexiyzncbvk<tvvqnjlqxkuk->size
<operator>.postIncrement zvexiyzncbvk++
displayCArray displayCArray(tvvqnjlqxkuk)
printf printf("\nCode: %d" removeValueCArray(tvvqnjlqxkuk,-1))
printf printf("\nCode: %d\n" insertValueCArray(tvvqnjlqxkuk,-1,1))
<operator>.lessThan zvexiyzncbvk<tvvqnjlqxkuk->size
<operator>.postIncrement zvexiyzncbvk++
eraseCArray eraseCArray(tvvqnjlqxkuk)
displayCArray displayCArray(tvvqnjlqxkuk)
<operator>.assignment *arr=getCArray(13)
<operator>.lessThan zvexiyzncbvk<arr->size
<operator>.postIncrement zvexiyzncbvk++
displayCArray displayCArray(arr)
<operator>.lessThan zvexiyzncbvk<arr->size/2
<operator>.postIncrement zvexiyzncbvk++
displayCArray displayCArray(arr)
reverseCArray reverseCArray(arr)
displayCArray displayCArray(arr)
srand srand(nnzgydzwiuxy(NULL))
<operator>.assignment *barray=getCArray(20)
<operator>.lessThan zvexiyzncbvk<barray->size
<operator>.postIncrement zvexiyzncbvk++
<operator>.assignment *carray=getCopyCArray(barray)
<operator>.assignment *darray=getCopyCArray(barray)
printf printf("\nNot sorted Array:")
displayCArray displayCArray(barray)
printf printf("\nBubble Sort:")
<operator>.assignment ihwkbbgafcxt=clock()
bubbleSortCArray bubbleSortCArray(barray)
<operator>.assignment ixnulwtpdnvq=clock()
<operator>.assignment erwtrexxhrhc=(double)(ixnulwtpdnvq-ihwkbbgafcxt)/CLOCKS_PER_SEC
displayCArray displayCArray(barray)
printf printf("\nSelection Sort:")
<operator>.assignment eayzkyzpdhvs=clock()
selectionSortCArray selectionSortCArray(carray)
<operator>.assignment lbdhhnnezjdo=clock()
<operator>.assignment vgkqqblatlil=(double)(lbdhhnnezjdo-eayzkyzpdhvs)/CLOCKS_PER_SEC
displayCArray displayCArray(carray)
printf printf("\nInsertion Sort:")
<operator>.assignment fxecivdsrsfa=clock()
insertionSortCArray insertionSortCArray(darray)
<operator>.assignment iguvaybmykdm=clock()
<operator>.assignment zvedwpjowzcy=(double)(iguvaybmykdm-fxecivdsrsfa)/CLOCKS_PER_SEC
displayCArray displayCArray(carray)
reverseCArray reverseCArray(barray)
printf printf("\nTotal time spent for bubble sort: %lf seconds",erwtrexxhrhc)
printf printf("\nTotal time spent for selection sort: %lf seconds",vgkqqblatlil)
printf printf("\nTotal time spent for insertion sort: %lf seconds",zvedwpjowzcy)
<operator>.assignment *aarray=getCArray(1000)
<operator>.lessThan zvexiyzncbvk<aarray->size
<operator>.postIncrement zvexiyzncbvk++
<operator>.assignment sblydyxagbrr=24
printf printf("\nOccurrences of the number %d in the array: %d" sblydyxagbrr valueOcurranceCArray(aarray,sblydyxagbrr))
printf printf("\nAnd its positions:\n")
<operator>.assignment *positions=valuePositionsCArray(aarray,sblydyxagbrr)
displayCArray displayCArray(positions)
printf printf("\nAll %d s",sblydyxagbrr)
<operator>.lessThan zvexiyzncbvk<positions->size
<operator>.postIncrement zvexiyzncbvk++
printf printf("\nThe list has a minimum value of %d and a maximum value of %d" findMinCArray(aarray) findMaxCArray(aarray))
insertionSortCArray insertionSortCArray(aarray)
free free(arr)
free free(tvvqnjlqxkuk)
free free(aarray)
free free(barray)
free free(carray)
free free(darray)
printf printf("\n")
RETURN return 0; return 0;
LITERAL 0 return 0;
getCArray getCArray(10)
pushValueCArray pushValueCArray(tvvqnjlqxkuk,11)
removeValueCArray removeValueCArray(tvvqnjlqxkuk,-1)
insertValueCArray insertValueCArray(tvvqnjlqxkuk,-1,1)
getCArray getCArray(13)
<operator>.division arr->size/2
nnzgydzwiuxy nnzgydzwiuxy(NULL)
getCArray getCArray(20)
getCopyCArray getCopyCArray(barray)
getCopyCArray getCopyCArray(barray)
<operator>.division (double)(ixnulwtpdnvq-ihwkbbgafcxt)/CLOCKS_PER_SEC
<operator>.division (double)(lbdhhnnezjdo-eayzkyzpdhvs)/CLOCKS_PER_SEC
<operator>.division (double)(iguvaybmykdm-fxecivdsrsfa)/CLOCKS_PER_SEC
getCArray getCArray(1000)
valueOcurranceCArray valueOcurranceCArray(aarray,sblydyxagbrr)
valuePositionsCArray valuePositionsCArray(aarray,sblydyxagbrr)
findMinCArray findMinCArray(aarray)
findMaxCArray findMaxCArray(aarray)
<operator>.minus -1
<operator>.minus -1
<operator>.cast (double)(ixnulwtpdnvq-ihwkbbgafcxt)
<operator>.cast (double)(lbdhhnnezjdo-eayzkyzpdhvs)
<operator>.cast (double)(iguvaybmykdm-fxecivdsrsfa)
<operator>.subtraction ixnulwtpdnvq-ihwkbbgafcxt
<operator>.subtraction lbdhhnnezjdo-eayzkyzpdhvs
<operator>.subtraction iguvaybmykdm-fxecivdsrsfa
>>>PDG&111 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->35 0->36 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->56 0->58 0->59 0->60 0->61 0->62 0->64 0->65 0->66 0->67 0->68 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->108 0->109 0->110 5->1 6->1 7->1 9->1 9->1 9->13 10->11 10->15 11->15 12->1 13->86 14->1 14->1 15->16 15->20 16->20 17->87 18->1 18->1 19->1 19->1 20->1 20->1 20->21 21->25 22->1 22->23 23->1 23->77 24->1 24->1 24->27 25->1 25->26 25->90 26->28 27->30 28->1 28->1 28->29 29->35 30->31 31->1 31->32 32->1 32->76 33->1 33->1 34->1 34->1 34->93 35->1 35->1 35->36 36->64 37->1 37->49 38->1 38->1 38->55 39->1 40->43 41->1 42->1 42->108 43->1 43->46 44->1 44->108 45->1 45->1 45->60 46->1 46->59 47->1 48->1 48->109 49->1 49->52 50->1 50->109 51->1 51->1 51->61 52->58 53->1 54->1 54->110 55->1 55->81 56->1 56->110 57->1 57->1 57->62 58->1 58->80 59->1 59->79 60->1 60->1 61->1 61->1 62->1 62->1 63->1 63->1 63->99 64->1 64->1 64->65 65->72 66->1 66->99 67->1 67->1 67->100 68->1 69->1 69->1 69->70 70->1 70->1 71->1 71->1 72->1 72->1 72->73 73->1 73->1 74->1 74->1 74->1 75->1 75->78 76->1 77->1 78->1 79->1 80->1 81->1 82->1 83->1 84->83 85->9 86->14 86->14 86->17 87->18 87->18 87->88 88->1 88->19 88->19 88->19 88->22 89->24 90->1 90->28 90->28 91->1 91->33 92->34 93->37 93->94 94->38 94->40 95->1 95->45 95->45 95->96 96->1 96->51 96->51 96->97 97->1 97->1 97->57 97->57 98->63 99->67 99->67 99->100 100->69 100->69 100->71 100->101 101->74 101->102 102->74 102->75 103->87 104->88 105->1 106->1 107->1 108->1 108->1 108->95 108->95 108->105 108->105 109->1 109->1 109->96 109->96 109->106 109->106 110->1 110->1 110->97 110->97 110->107 110->107
>>>Token int htmpzvssqvwk ( ) { printf ( " \n " ) ; printf ( " \n " ) ; printf ( " \n " ) ; printf ( " \n " ) ; printf ( " \n " ) ; printf ( " \n " ) ; printf ( " \n " ) ; CArray * tvvqnjlqxkuk = getCArray ( 10 ) ; int zvexiyzncbvk ; norpzssjfzkz ( zvexiyzncbvk = 0  ; zvexiyzncbvk < tvvqnjlqxkuk -> size ; zvexiyzncbvk ++ ) { insertValueCArray ( tvvqnjlqxkuk , zvexiyzncbvk , zvexiyzncbvk + 1 ) ; } printf ( " \n " ) ; displayCArray ( tvvqnjlqxkuk ) ; printf ( " \n \n " , pushValueCArray ( tvvqnjlqxkuk , 11 ) ) ; norpzssjfzkz ( zvexiyzncbvk = 0  ; zvexiyzncbvk < tvvqnjlqxkuk -> size ; zvexiyzncbvk ++ ) { removeValueCArray ( tvvqnjlqxkuk , zvexiyzncbvk ) ; } displayCArray ( tvvqnjlqxkuk ) ; printf ( " \n " , removeValueCArray ( tvvqnjlqxkuk , -1 ) ) ; printf ( " \n \n " , insertValueCArray ( tvvqnjlqxkuk , -1 , 1 ) ) ; norpzssjfzkz ( zvexiyzncbvk = 0  ; zvexiyzncbvk < tvvqnjlqxkuk -> size ; zvexiyzncbvk ++ ) { insertValueCArray ( tvvqnjlqxkuk , zvexiyzncbvk , zvexiyzncbvk + 1 ) ; } eraseCArray ( tvvqnjlqxkuk ) ; displayCArray ( tvvqnjlqxkuk ) ; CArray * arr = getCArray ( 13 ) ; norpzssjfzkz ( zvexiyzncbvk = 0  ; zvexiyzncbvk < arr -> size ; zvexiyzncbvk ++ ) { insertValueCArray ( arr , zvexiyzncbvk , zvexiyzncbvk + 1 ) ; } displayCArray ( arr ) ; norpzssjfzkz ( zvexiyzncbvk = 0  ; zvexiyzncbvk < arr -> size / 2 ; zvexiyzncbvk ++ ) { switchValuesCArray ( arr , zvexiyzncbvk , arr -> size - zvexiyzncbvk - 1 ) ; } displayCArray ( arr ) ; reverseCArray ( arr ) ; displayCArray ( arr ) ; srand ( nnzgydzwiuxy ( NULL ) ) ; CArray * barray = getCArray ( 20 ) ; norpzssjfzkz ( zvexiyzncbvk = 0  ; zvexiyzncbvk < barray -> size ; zvexiyzncbvk ++ ) { insertValueCArray ( barray , zvexiyzncbvk , rand ( ) ) ; } CArray * carray = getCopyCArray ( barray ) ; CArray * darray = getCopyCArray ( barray ) ; printf ( " \n " ) ; displayCArray ( barray ) ; printf ( " \n " ) ; clock_t ihwkbbgafcxt = clock ( ) ; bubbleSortCArray ( barray ) ; clock_t ixnulwtpdnvq = clock ( ) ; double erwtrexxhrhc = ( double ) ( ixnulwtpdnvq - ihwkbbgafcxt ) / CLOCKS_PER_SEC ; displayCArray ( barray ) ; printf ( " \n " ) ; clock_t eayzkyzpdhvs = clock ( ) ; selectionSortCArray ( carray ) ; clock_t lbdhhnnezjdo = clock ( ) ; double vgkqqblatlil = ( double ) ( lbdhhnnezjdo - eayzkyzpdhvs ) / CLOCKS_PER_SEC ; displayCArray ( carray ) ; printf ( " \n " ) ; clock_t fxecivdsrsfa = clock ( ) ; insertionSortCArray ( darray ) ; clock_t iguvaybmykdm = clock ( ) ; double zvedwpjowzcy = ( double ) ( iguvaybmykdm - fxecivdsrsfa ) / CLOCKS_PER_SEC ; displayCArray ( carray ) ; reverseCArray ( barray ) ; printf ( " \n " , erwtrexxhrhc ) ; printf ( " \n " , vgkqqblatlil ) ; printf ( " \n " , zvedwpjowzcy ) ; CArray * aarray = getCArray ( 1000 ) ; norpzssjfzkz ( zvexiyzncbvk = 0  ; zvexiyzncbvk < aarray -> size ; zvexiyzncbvk ++ ) { insertValueCArray ( aarray , zvexiyzncbvk , rand ( ) % 100 ) ; } int sblydyxagbrr = 24 ; printf ( " \n " , sblydyxagbrr , valueOcurranceCArray ( aarray , sblydyxagbrr ) ) ; printf ( " \n \n " ) ; CArray * positions = valuePositionsCArray ( aarray , sblydyxagbrr ) ; displayCArray ( positions ) ; printf ( " \n " , sblydyxagbrr ) ; norpzssjfzkz ( zvexiyzncbvk = 0  ; zvexiyzncbvk < positions -> size ; zvexiyzncbvk ++ ) { printf ( " \n " , positions -> tvvqnjlqxkuk [ zvexiyzncbvk ] , aarray -> tvvqnjlqxkuk [ positions -> tvvqnjlqxkuk [ zvexiyzncbvk ] ] ) ; } printf ( " \n " , findMinCArray ( aarray ) , findMaxCArray ( aarray ) ) ; insertionSortCArray ( aarray ) ; free ( arr ) ; free ( tvvqnjlqxkuk ) ; free ( aarray ) ; free ( barray ) ; free ( carray ) ; free ( darray ) ; printf ( " \n " ) ; return 0 ; }
>>>Func
METHOD tkeopyudyutw
METHOD_RETURN void
scanf scanf("%d\n",&n)
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.assignment i=0
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.assignment j=0
scanf scanf("%c",&glqxzravzmkk)
<operator>.equals glqxzravzmkk=='.'
<operator>.assignment a[i][j]=-1
<operator>.assignment a[i][j]=glqxzravzmkk-'0'
<operator>.minus -1
<operator>.subtraction glqxzravzmkk-'0'
scanf scanf("\n")
<operator>.addressOf &glqxzravzmkk
<operator>.indirectIndexAccess a[i][j]
<operator>.indirectIndexAccess a[i]
<operator>.indirectIndexAccess a[i][j]
<operator>.indirectIndexAccess a[i]
>>>PDG&21 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->13 0->14 2->1 2->3 2->6 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->6 3->8 3->15 4->1 4->3 5->1 5->3 6->1 6->1 6->3 6->6 6->7 6->7 6->9 6->10 6->16 7->1 7->6 8->1 8->6 9->1 9->10 9->14 10->1 10->1 10->9 10->11 10->12 10->13 10->14 10->14 10->17 10->18 10->19 10->20 11->1 11->1 11->1 12->1 12->1 12->1 13->11 14->1 14->9 14->10 14->12 14->12
>>>Token void tkeopyudyutw ( ) { char glqxzravzmkk ; scanf ( " \n " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { scanf ( " " , & glqxzravzmkk ) ; if ( glqxzravzmkk == ' ' ) { a [ i ] [ j ] = -1 ; } else { a [ i ] [ j ] = glqxzravzmkk - ' ' ; } } scanf ( " \n " ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&qummyadyecpz)
RETURN return 0; return 0;
<operator>.lessThan i<qummyadyecpz
<operator>.postIncrement i++
LITERAL 0 return 0;
<operator>.assignment i=0
printf printf("Case #%d: ",i+1)
solveCase solveCase()
<operator>.addition i+1
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->8 4->9 4->10 4->10 5->1 5->4 6->3 7->1 7->4 8->1 8->1 9->1
>>>Token int main ( ) { int qummyadyecpz , i ; scanf ( " " , & qummyadyecpz ) ; for ( i = 0 ; i < qummyadyecpz ; i ++ ) { printf ( " " , i + 1 ) ; solveCase ( ) ; } return 0 ; }
>>>Func
METHOD tsdtyisngzht
METHOD_RETURN void
PARAM Graph ikwwgodsylxe
PARAM Edge wgqjmcihjzqg
assert assert(ikwwgodsylxe!=NULL&&validV(ikwwgodsylxe,wgqjmcihjzqg.v)&&validV(ikwwgodsylxe,wgqjmcihjzqg.w))
<operator>.logicalNot !ikwwgodsylxe->edges[wgqjmcihjzqg.v][wgqjmcihjzqg.w]
<operator>.logicalAnd ikwwgodsylxe!=NULL&&validV(ikwwgodsylxe,wgqjmcihjzqg.v)&&validV(ikwwgodsylxe,wgqjmcihjzqg.w)
<operator>.assignment ikwwgodsylxe->edges[wgqjmcihjzqg.v][wgqjmcihjzqg.w]=1
<operator>.assignment ikwwgodsylxe->edges[wgqjmcihjzqg.w][wgqjmcihjzqg.v]=1
<operator>.postIncrement ikwwgodsylxe->nE++
<operator>.logicalAnd ikwwgodsylxe!=NULL&&validV(ikwwgodsylxe,wgqjmcihjzqg.v)
validV validV(ikwwgodsylxe,wgqjmcihjzqg.w)
<operator>.notEquals ikwwgodsylxe!=NULL
validV validV(ikwwgodsylxe,wgqjmcihjzqg.v)
<operator>.fieldAccess wgqjmcihjzqg.w
<operator>.indirectIndexAccess ikwwgodsylxe->edges[wgqjmcihjzqg.v][wgqjmcihjzqg.w]
<operator>.indirectIndexAccess ikwwgodsylxe->edges[wgqjmcihjzqg.w][wgqjmcihjzqg.v]
<operator>.indirectFieldAccess ikwwgodsylxe->nE
<operator>.fieldAccess wgqjmcihjzqg.v
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess ikwwgodsylxe->edges[wgqjmcihjzqg.v]
<operator>.fieldAccess wgqjmcihjzqg.w
<operator>.indirectIndexAccess ikwwgodsylxe->edges[wgqjmcihjzqg.w]
<operator>.fieldAccess wgqjmcihjzqg.v
FIELD_IDENTIFIER nE nE
FIELD_IDENTIFIER v v
<operator>.indirectFieldAccess ikwwgodsylxe->edges
<operator>.fieldAccess wgqjmcihjzqg.v
FIELD_IDENTIFIER w w
<operator>.indirectFieldAccess ikwwgodsylxe->edges
<operator>.fieldAccess wgqjmcihjzqg.w
FIELD_IDENTIFIER v v
FIELD_IDENTIFIER edges edges
FIELD_IDENTIFIER v v
FIELD_IDENTIFIER edges edges
FIELD_IDENTIFIER w w
>>>PDG&36 0->2 0->3 0->7 0->8 0->11 0->12 0->13 2->12 3->1 3->11 3->13 4->1 4->1 5->1 5->7 5->8 5->9 5->15 5->16 5->17 5->20 5->21 5->22 5->23 5->24 5->26 5->27 5->28 5->29 5->30 5->31 5->32 5->33 5->34 5->35 6->1 6->1 6->4 6->4 7->1 7->1 8->1 8->1 9->1 9->1 10->1 10->1 10->6 10->6 10->11 10->14 10->19 11->1 11->1 11->6 11->6 12->1 12->1 12->10 12->10 12->11 12->13 12->13 12->18 12->25 13->1 13->1 13->10 13->10 13->11
>>>Token void tsdtyisngzht ( Graph ikwwgodsylxe , Edge wgqjmcihjzqg ) { assert ( ikwwgodsylxe != NULL && validV ( ikwwgodsylxe , wgqjmcihjzqg . v ) && validV ( ikwwgodsylxe , wgqjmcihjzqg . w ) ) ; if ( ! ikwwgodsylxe -> edges [ wgqjmcihjzqg . v ] [ wgqjmcihjzqg . w ] ) { ikwwgodsylxe -> edges [ wgqjmcihjzqg . v ] [ wgqjmcihjzqg . w ] = 1 ; ikwwgodsylxe -> edges [ wgqjmcihjzqg . w ] [ wgqjmcihjzqg . v ] = 1 ; ikwwgodsylxe -> nE ++ ; } }
>>>Func
METHOD qakrpzltynhr
METHOD_RETURN void
PARAM FILE *fd
PARAM TypeDataSet *pDataSet
fprintf fprintf(fd "%d\n" (pDataSet->t))
fprintf fprintf(fd "%d %d\n" (pDataSet->numA) (pDataSet->numB))
<operator>.lessThan bfwvjxmkogki<pDataSet->numA
<operator>.postIncrement bfwvjxmkogki++
fprintf fprintf(fd "%2d:%2d %2d:%2d\n" (pDataSet->departureA[bfwvjxmkogki].Hr) (pDataSet->departureA[bfwvjxmkogki].Min) (pDataSet->arrivalB[bfwvjxmkogki].Hr) (pDataSet->arrivalB[bfwvjxmkogki].Min))
<operator>.lessThan bfwvjxmkogki<pDataSet->numB
<operator>.postIncrement bfwvjxmkogki++
fprintf fprintf(fd "%2d:%2d %2d:%2d\n" (pDataSet->departureB[bfwvjxmkogki].Hr) (pDataSet->departureB[bfwvjxmkogki].Min) (pDataSet->arrivalA[bfwvjxmkogki].Hr) (pDataSet->arrivalA[bfwvjxmkogki].Min))
<operator>.assignment bfwvjxmkogki=0
<operator>.assignment bfwvjxmkogki=0
<operator>.indirectFieldAccess pDataSet->numA
<operator>.fieldAccess pDataSet->departureA[bfwvjxmkogki].Hr
<operator>.fieldAccess pDataSet->departureA[bfwvjxmkogki].Min
<operator>.fieldAccess pDataSet->arrivalB[bfwvjxmkogki].Hr
<operator>.fieldAccess pDataSet->arrivalB[bfwvjxmkogki].Min
<operator>.indirectFieldAccess pDataSet->numB
<operator>.fieldAccess pDataSet->departureB[bfwvjxmkogki].Hr
<operator>.fieldAccess pDataSet->departureB[bfwvjxmkogki].Min
<operator>.fieldAccess pDataSet->arrivalA[bfwvjxmkogki].Hr
<operator>.fieldAccess pDataSet->arrivalA[bfwvjxmkogki].Min
FIELD_IDENTIFIER numA numA
<operator>.indirectIndexAccess pDataSet->departureA[bfwvjxmkogki]
FIELD_IDENTIFIER Hr Hr
<operator>.indirectIndexAccess pDataSet->departureA[bfwvjxmkogki]
FIELD_IDENTIFIER Min Min
<operator>.indirectIndexAccess pDataSet->arrivalB[bfwvjxmkogki]
FIELD_IDENTIFIER Hr Hr
<operator>.indirectIndexAccess pDataSet->arrivalB[bfwvjxmkogki]
FIELD_IDENTIFIER Min Min
FIELD_IDENTIFIER numB numB
<operator>.indirectIndexAccess pDataSet->departureB[bfwvjxmkogki]
FIELD_IDENTIFIER Hr Hr
<operator>.indirectIndexAccess pDataSet->departureB[bfwvjxmkogki]
FIELD_IDENTIFIER Min Min
<operator>.indirectIndexAccess pDataSet->arrivalA[bfwvjxmkogki]
FIELD_IDENTIFIER Hr Hr
<operator>.indirectIndexAccess pDataSet->arrivalA[bfwvjxmkogki]
FIELD_IDENTIFIER Min Min
<operator>.indirectFieldAccess pDataSet->departureA
<operator>.indirectFieldAccess pDataSet->departureA
<operator>.indirectFieldAccess pDataSet->arrivalB
<operator>.indirectFieldAccess pDataSet->arrivalB
<operator>.indirectFieldAccess pDataSet->departureB
<operator>.indirectFieldAccess pDataSet->departureB
<operator>.indirectFieldAccess pDataSet->arrivalA
<operator>.indirectFieldAccess pDataSet->arrivalA
FIELD_IDENTIFIER departureA departureA
FIELD_IDENTIFIER departureA departureA
FIELD_IDENTIFIER arrivalB arrivalB
FIELD_IDENTIFIER arrivalB arrivalB
FIELD_IDENTIFIER departureB departureB
FIELD_IDENTIFIER departureB departureB
FIELD_IDENTIFIER arrivalA arrivalA
FIELD_IDENTIFIER arrivalA arrivalA
>>>PDG&58 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->4 3->1 4->1 4->1 4->5 5->1 5->1 5->6 5->8 5->9 5->11 6->1 6->1 6->6 6->7 6->7 6->8 6->14 6->15 6->16 6->17 6->18 6->24 6->25 6->26 6->27 6->28 6->29 6->30 6->31 6->32 6->42 6->43 6->44 6->45 6->50 6->51 6->52 6->53 7->1 7->6 8->11 9->1 9->1 9->1 9->9 9->10 9->10 9->11 9->19 9->20 9->21 9->22 9->23 9->33 9->34 9->35 9->36 9->37 9->38 9->39 9->40 9->41 9->46 9->47 9->48 9->49 9->54 9->55 9->56 9->57 10->1 10->9 12->6 13->1 13->9
>>>Token void qakrpzltynhr ( FILE * fd , TypeDataSet * pDataSet ) { unsigned bfwvjxmkogki ; fprintf ( fd , " \n " , ( pDataSet -> t ) ) ; fprintf ( fd , " \n " , ( pDataSet -> numA ) , ( pDataSet -> numB ) ) ; for ( bfwvjxmkogki = 0 ; bfwvjxmkogki < pDataSet -> numA ; bfwvjxmkogki ++ ) fprintf ( fd , " \n " , ( pDataSet -> departureA [ bfwvjxmkogki ] . Hr ) , ( pDataSet -> departureA [ bfwvjxmkogki ] . Min ) , ( pDataSet -> arrivalB [ bfwvjxmkogki ] . Hr ) , ( pDataSet -> arrivalB [ bfwvjxmkogki ] . Min ) ) ; for ( bfwvjxmkogki = 0 ; bfwvjxmkogki < pDataSet -> numB ; bfwvjxmkogki ++ ) fprintf ( fd , " \n " , ( pDataSet -> departureB [ bfwvjxmkogki ] . Hr ) , ( pDataSet -> departureB [ bfwvjxmkogki ] . Min ) , ( pDataSet -> arrivalA [ bfwvjxmkogki ] . Hr ) , ( pDataSet -> arrivalA [ bfwvjxmkogki ] . Min ) ) ; }
>>>Func
METHOD oyvogvhjiaxf
METHOD_RETURN void
PARAM char *str
<operator>.assignment dvnbzhgkugvw=0
<operator>.assignment vptsgvahgbrh=strlen(str)
<operator>.notEquals str[dvnbzhgkugvw]!='9'
strlen strlen(str)
<operator>.assignmentPlus str[dvnbzhgkugvw]+=1
<operator>.assignment str[dvnbzhgkugvw]=str[dvnbzhgkugvw]+1
<operator>.postIncrement dvnbzhgkugvw++
<operator>.assignment str[vptsgvahgbrh]='\0'
<operator>.equals str[dvnbzhgkugvw]=='9'
<operator>.assignment str[dvnbzhgkugvw]='0'
<operator>.postIncrement dvnbzhgkugvw++
<operator>.addition str[dvnbzhgkugvw]+1
<operator>.equals str[dvnbzhgkugvw]=='\0'
<operator>.assignment str[dvnbzhgkugvw]='1'
<operator>.assignment str[dvnbzhgkugvw+1]='\0'
RETURN return ; return ;
<operator>.addition dvnbzhgkugvw+1
<operator>.indirectIndexAccess str[dvnbzhgkugvw]
<operator>.indirectIndexAccess str[dvnbzhgkugvw]
<operator>.indirectIndexAccess str[vptsgvahgbrh]
<operator>.indirectIndexAccess str[dvnbzhgkugvw]
<operator>.indirectIndexAccess str[dvnbzhgkugvw]
<operator>.indirectIndexAccess str[dvnbzhgkugvw]
<operator>.indirectIndexAccess str[dvnbzhgkugvw]
<operator>.indirectIndexAccess str[dvnbzhgkugvw]
<operator>.indirectIndexAccess str[dvnbzhgkugvw+1]
>>>PDG&29 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 2->6 3->1 3->9 3->13 4->1 4->1 4->1 5->1 5->7 5->7 5->11 5->11 5->20 5->23 6->1 6->4 6->5 6->7 6->8 6->11 6->14 6->15 11->1 11->8 11->8 11->9 11->10 11->12 11->13 11->14 11->14 11->15 11->21 11->22 11->24 11->25 11->26 12->1 12->15 13->1 13->9 13->19 15->1 15->11 15->11 15->16 15->17 15->18 15->19 15->23 15->27 15->28 16->1 16->1 17->1 17->1 18->1 19->1
>>>Token void oyvogvhjiaxf ( char * str ) { int dvnbzhgkugvw = 0 ; int vptsgvahgbrh = strlen ( str ) ; char miulxzgljccw ; if ( str [ dvnbzhgkugvw ] != ' ' ) str [ dvnbzhgkugvw ] += 1 ; else { while ( str [ dvnbzhgkugvw ] == ' ' ) { str [ dvnbzhgkugvw ] = ' ' ; dvnbzhgkugvw ++ ; if ( str [ dvnbzhgkugvw ] == ' \0 ' ) { str [ dvnbzhgkugvw ] = ' ' ; str [ dvnbzhgkugvw + 1 ] = ' \0 ' ; return ; } } str [ dvnbzhgkugvw ] = str [ dvnbzhgkugvw ] + 1 ; dvnbzhgkugvw ++ ; str [ vptsgvahgbrh ] = ' \0 ' ; } }
>>>Func
METHOD createGraph
METHOD_RETURN struct yzkjelktatmc
PARAM int ajbxkafgzjem
<operator>.assignment *evbbuebwzngw=malloc(sizeof(struct yzkjelktatmc))
<operator>.assignment evbbuebwzngw->numVertices=ajbxkafgzjem
<operator>.assignment evbbuebwzngw->adjLists=malloc(ajbxkafgzjem *sizeof(struct kisboztsdndi*))
<operator>.assignment evbbuebwzngw->visited=malloc(ajbxkafgzjem *sizeof(int))
RETURN return evbbuebwzngw; return evbbuebwzngw;
<operator>.lessThan qgdhurtpfegd<ajbxkafgzjem
<operator>.postIncrement qgdhurtpfegd++
IDENTIFIER evbbuebwzngw return evbbuebwzngw;
malloc malloc(ajbxkafgzjem *sizeof(struct kisboztsdndi*))
malloc malloc(ajbxkafgzjem *sizeof(int))
<operator>.assignment qgdhurtpfegd=0
<operator>.assignment evbbuebwzngw->adjLists[qgdhurtpfegd]=NULL
<operator>.assignment evbbuebwzngw->visited[qgdhurtpfegd]=0
<operator>.sizeOf sizeof(struct yzkjelktatmc)
<operator>.multiplication ajbxkafgzjem *sizeof(struct kisboztsdndi*)
<operator>.multiplication ajbxkafgzjem *sizeof(int)
<operator>.sizeOf sizeof(struct kisboztsdndi*)
<operator>.sizeOf sizeof(int)
<operator>.indirectIndexAccess evbbuebwzngw->adjLists[qgdhurtpfegd]
<operator>.indirectIndexAccess evbbuebwzngw->visited[qgdhurtpfegd]
<operator>.indirectFieldAccess evbbuebwzngw->adjLists
<operator>.indirectFieldAccess evbbuebwzngw->visited
FIELD_IDENTIFIER adjLists adjLists
FIELD_IDENTIFIER visited visited
>>>PDG&27 0->2 0->4 0->8 0->9 0->10 0->13 0->14 0->15 0->17 0->18 2->4 2->17 3->1 3->1 3->1 3->10 4->1 4->1 5->1 5->1 5->1 6->1 6->1 6->1 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->14 8->15 8->21 8->22 8->23 8->24 8->25 8->26 9->1 9->8 10->7 11->1 11->5 12->1 12->6 13->1 13->8 14->1 14->1 14->1 15->1 15->1 16->1 17->11 17->18 18->8 18->12 19->1 20->1
>>>Token struct yzkjelktatmc * createGraph ( int ajbxkafgzjem ) { struct yzkjelktatmc * evbbuebwzngw = malloc ( sizeof ( struct yzkjelktatmc ) ) ; evbbuebwzngw -> numVertices = ajbxkafgzjem ; evbbuebwzngw -> adjLists = malloc ( ajbxkafgzjem * sizeof ( struct kisboztsdndi * ) ) ; evbbuebwzngw -> visited = malloc ( ajbxkafgzjem * sizeof ( int ) ) ; int qgdhurtpfegd ; for ( qgdhurtpfegd = 0 ; qgdhurtpfegd < ajbxkafgzjem ; qgdhurtpfegd ++ ) { evbbuebwzngw -> adjLists [ qgdhurtpfegd ] = NULL ; evbbuebwzngw -> visited [ qgdhurtpfegd ] = 0 ; } return evbbuebwzngw ; }
>>>Func
METHOD pwflmdqpgmnt
METHOD_RETURN void
<operator>.assignment hxovszrwvtly=0
<operator>.assignment q=0
ngpqiantsjyg ngpqiantsjyg(n<1)
RETURN return ; return ;
<operator>.lessThan n<1
<operator>.lessThan q<c
<operator>.postIncrement q++
ngpqiantsjyg ngpqiantsjyg(str[n-1]==comb[q][0])
UNKNOWN,),)
UNKNOWN else ngpqiantsjyg (str[n-1]==comb[q][1]){ngpqiantsjyg(str[n]==comb[q][0]){str[n-1]=comb[q][2];str[n]='\0';n--;}} else ngpqiantsjyg (str[n-1]==comb[q][1]){ngpqiantsjyg(str[n]==comb[q][0]){str[n-1]=comb[q][2];str[n]='\0';n--;}}
<operator>.equals str[n-1]==comb[q][0]
ngpqiantsjyg ngpqiantsjyg(str[n]==comb[q][1])
UNKNOWN,),)
<operator>.indirectIndexAccess str[n-1]
<operator>.indirectIndexAccess comb[q][0]
<operator>.equals str[n]==comb[q][1]
<operator>.assignment str[n-1]=comb[q][2]
<operator>.assignment str[n]='\0'
<operator>.postDecrement n--
<operator>.subtraction n-1
<operator>.indirectIndexAccess comb[q]
<operator>.indirectIndexAccess str[n]
<operator>.indirectIndexAccess comb[q][1]
<operator>.indirectIndexAccess str[n-1]
<operator>.indirectIndexAccess comb[q][2]
<operator>.indirectIndexAccess str[n]
<operator>.indirectIndexAccess comb[q]
<operator>.subtraction n-1
<operator>.indirectIndexAccess comb[q]
>>>PDG&31 0->2 0->3 0->5 0->6 2->1 2->1 3->1 3->1 4->1 4->1 5->1 6->1 6->4 6->4 7->1 7->7 7->8 7->9 7->10 7->11 7->12 7->13 7->14 7->15 7->16 7->17 7->18 7->19 7->20 7->21 7->22 7->23 7->24 7->25 7->26 7->27 7->28 7->29 7->30
>>>Token void pwflmdqpgmnt ( ) { int hxovszrwvtly = 0 , q = 0 ; ngpqiantsjyg ( n < 1 ) return ; for ( q = 0 ; q < c ; q ++ ) { ngpqiantsjyg ( str [ n - 1 ] == comb [ q ] [ 0 ] )  { ngpqiantsjyg ( str [ n ] == comb [ q ] [ 1 ] )  { str [ n - 1 ] = comb [ q ] [ 2 ] ; str [ n ] = ' \0 ' ; n -- ; } } else ngpqiantsjyg ( str [ n - 1 ] = = comb [ q ] [ 1 ] ) { ngpqiantsjyg ( str [ n ] == comb [ q ] [ 0 ] )  { str [ n - 1 ] = comb [ q ] [ 2 ] ; str [ n ] = ' \0 ' ; n -- ; } } } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment inputFile=fopen("./B-small-attempt0.in","rb")
<operator>.assignment outputFile=fopen("./output.txt","w")
<operator>.assignment testCount=0
<operator>.assignment *inputString=NULL
fscanf fscanf(inputFile,"%d",&kyazszsgbaag)
fclose fclose(inputFile)
fclose fclose(outputFile)
RETURN return (EXIT_SUCCESS); return (EXIT_SUCCESS);
IDENTIFIER kyazszsgbaag while (kyazszsgbaag)
IDENTIFIER EXIT_SUCCESS return (EXIT_SUCCESS);
fopen fopen("./B-small-attempt0.in","rb")
fopen fopen("./output.txt","w")
<operator>.assignment *combination=NULL
fscanf fscanf(inputFile,"%d",&combinationCount)
fgetc fgetc(inputFile)
<operator>.assignment *oppose=NULL
fscanf fscanf(inputFile,"%d",&opposeCount)
fgetc fgetc(inputFile)
fscanf fscanf(inputFile,"%d",&inputLength)
fgetc fgetc(inputFile)
<operator>.assignment inputString=(char *)calloc(inputLength+1,1)
fscanf fscanf(inputFile,"%s",inputString)
<operator>.assignment evbknzbqnymc=0
fprintf fprintf(outputFile,"Case #%d: [",++testCount)
fprintf fprintf(outputFile,"]\n")
<operator>.postDecrement kyazszsgbaag--
IDENTIFIER combinationCount if (combinationCount)
IDENTIFIER opposeCount if (opposeCount)
<operator>.lessThan geledvsjpzly<inputLength
<operator>.postIncrement geledvsjpzly++
<operator>.lessThan geledvsjpzly<evbknzbqnymc
<operator>.postIncrement geledvsjpzly++
IDENTIFIER combination if (combination)
IDENTIFIER oppose if (oppose)
IDENTIFIER inputString if (inputString)
<operator>.assignment combination=(combinationList *)calloc(26 sizeof(combinationList))
<operator>.assignment oppose=(opposeList *)calloc(26 sizeof(opposeList))
<operator>.cast (char *)calloc(inputLength+1,1)
<operator>.assignment geledvsjpzly=0
<operator>.assignment kpbclchkvluz[evbknzbqnymc]=inputString[geledvsjpzly]
<operator>.postIncrement evbknzbqnymc++
<operator>.preIncrement ++testCount
<operator>.assignment geledvsjpzly=0
fprintf fprintf(outputFile,"%c",kpbclchkvluz[geledvsjpzly])
free free(combination)
free free(oppose)
free free(inputString)
IDENTIFIER combinationCount while (combinationCount)
IDENTIFIER opposeCount while (opposeCount)
calloc calloc(inputLength+1,1)
<operator>.logicalNot !evbknzbqnymc
IDENTIFIER combination if (combination)
IDENTIFIER oppose if (oppose)
<operator>.notEquals geledvsjpzly!=evbknzbqnymc-1
<operator>.cast (combinationList *)calloc(26 sizeof(combinationList))
fgetc fgetc(inputFile)
fscanf fscanf(inputFile,"%s",uehymueljuwu)
<operator>.postIncrement combination[uehymueljuwu[0]-'A'].rows++
<operator>.assignment combination[uehymueljuwu[0]-'A'].combination_list[combination[uehymueljuwu[0]-'A'].rows-1][0]=uehymueljuwu[1]-'A'
<operator>.assignment combination[uehymueljuwu[0]-'A'].combination_list[combination[uehymueljuwu[0]-'A'].rows-1][1]=uehymueljuwu[2]-'A'
<operator>.postIncrement combination[uehymueljuwu[1]-'A'].rows++
<operator>.assignment combination[uehymueljuwu[1]-'A'].combination_list[combination[uehymueljuwu[1]-'A'].rows-1][0]=uehymueljuwu[0]-'A'
<operator>.assignment combination[uehymueljuwu[1]-'A'].combination_list[combination[uehymueljuwu[1]-'A'].rows-1][1]=uehymueljuwu[2]-'A'
<operator>.postDecrement combinationCount--
<operator>.cast (opposeList *)calloc(26 sizeof(opposeList))
fgetc fgetc(inputFile)
fscanf fscanf(inputFile,"%s",uehymueljuwu)
<operator>.assignment oppose[uehymueljuwu[0]-'A'].en=-1
<operator>.assignment oppose[uehymueljuwu[0]-'A'].opposer=uehymueljuwu[1]-'A'
<operator>.assignment oppose[uehymueljuwu[1]-'A'].en=-1
<operator>.assignment oppose[uehymueljuwu[1]-'A'].opposer=uehymueljuwu[0]-'A'
<operator>.postDecrement opposeCount--
<operator>.addition inputLength+1
<operator>.postIncrement evbknzbqnymc++
fprintf fprintf(outputFile,", ")
calloc calloc(26 sizeof(combinationList))
<operator>.notEquals combination[uehymueljuwu[0]-'A'].en!=-1
<operator>.notEquals combination[uehymueljuwu[1]-'A'].en!=-1
calloc calloc(26 sizeof(opposeList))
<operator>.equals combination[kpbclchkvluz[evbknzbqnymc]-'A'].en==-1
<operator>.equals oppose[kpbclchkvluz[evbknzbqnymc]-'A'].en==-1
<operator>.subtraction evbknzbqnymc-1
<operator>.sizeOf sizeof(combinationList)
<operator>.assignment combination[uehymueljuwu[0]-'A'].en=-1
<operator>.assignment combination[uehymueljuwu[0]-'A'].rows=0
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.subtraction uehymueljuwu[2]-'A'
<operator>.assignment combination[uehymueljuwu[1]-'A'].en=-1
<operator>.assignment combination[uehymueljuwu[1]-'A'].rows=0
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction uehymueljuwu[2]-'A'
<operator>.sizeOf sizeof(opposeList)
<operator>.minus -1
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.minus -1
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.assignment uehymueljuwu=oppose[kpbclchkvluz[evbknzbqnymc]-'A'].opposer+'A'
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.lessThan ugoqaiekzujl<combination[kpbclchkvluz[evbknzbqnymc]-'A'].rows
<operator>.postIncrement ugoqaiekzujl++
<operator>.minus -1
<operator>.greaterEqualsThan ugoqaiekzujl>=0
<operator>.postDecrement ugoqaiekzujl--
<operator>.minus -1
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction combination[uehymueljuwu[0]-'A'].rows-1
<operator>.subtraction combination[uehymueljuwu[0]-'A'].rows-1
<operator>.minus -1
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.subtraction combination[uehymueljuwu[1]-'A'].rows-1
<operator>.subtraction combination[uehymueljuwu[1]-'A'].rows-1
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.assignment ugoqaiekzujl=0
<operator>.addition oppose[kpbclchkvluz[evbknzbqnymc]-'A'].opposer+'A'
<operator>.assignment ugoqaiekzujl=evbknzbqnymc-1
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.subtraction kpbclchkvluz[evbknzbqnymc]-'A'
<operator>.equals combination[kpbclchkvluz[evbknzbqnymc]-'A'].combination_list[ugoqaiekzujl][0]==(kpbclchkvluz[evbknzbqnymc-1]-'A')
<operator>.subtraction kpbclchkvluz[evbknzbqnymc]-'A'
<operator>.equals kpbclchkvluz[ugoqaiekzujl]==uehymueljuwu
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.postDecrement evbknzbqnymc--
<operator>.assignment kpbclchkvluz[evbknzbqnymc]=combination[kpbclchkvluz[evbknzbqnymc]-'A'].combination_list[ugoqaiekzujl][1]+'A'
<operator>.subtraction evbknzbqnymc-1
<operator>.assignment evbknzbqnymc=-1
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction uehymueljuwu[0]-'A'
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.subtraction uehymueljuwu[1]-'A'
<operator>.subtraction kpbclchkvluz[evbknzbqnymc]-'A'
<operator>.subtraction kpbclchkvluz[evbknzbqnymc-1]-'A'
IDENTIFIER evbknzbqnymc if (evbknzbqnymc)
<operator>.subtraction kpbclchkvluz[evbknzbqnymc]-'A'
<operator>.addition combination[kpbclchkvluz[evbknzbqnymc]-'A'].combination_list[ugoqaiekzujl][1]+'A'
<operator>.minus -1
<operator>.subtraction evbknzbqnymc-1
<operator>.subtraction kpbclchkvluz[evbknzbqnymc]-'A'
<operator>.subtraction kpbclchkvluz[evbknzbqnymc]-'A'
<operator>.indirectIndexAccess kpbclchkvluz[evbknzbqnymc]
<operator>.indirectIndexAccess inputString[geledvsjpzly]
<operator>.indirectIndexAccess kpbclchkvluz[geledvsjpzly]
<operator>.fieldAccess combination[kpbclchkvluz[evbknzbqnymc]-'A'].en
<operator>.fieldAccess oppose[kpbclchkvluz[evbknzbqnymc]-'A'].en
<operator>.fieldAccess combination[uehymueljuwu[0]-'A'].en
<operator>.fieldAccess combination[uehymueljuwu[0]-'A'].rows
<operator>.fieldAccess combination[uehymueljuwu[1]-'A'].en
<operator>.fieldAccess combination[uehymueljuwu[1]-'A'].rows
<operator>.indirectIndexAccess combination[kpbclchkvluz[evbknzbqnymc]-'A']
FIELD_IDENTIFIER en en
<operator>.indirectIndexAccess oppose[kpbclchkvluz[evbknzbqnymc]-'A']
FIELD_IDENTIFIER en en
<operator>.indirectIndexAccess combination[uehymueljuwu[0]-'A']
FIELD_IDENTIFIER en en
<operator>.indirectIndexAccess combination[uehymueljuwu[0]-'A']
FIELD_IDENTIFIER rows rows
<operator>.indirectIndexAccess combination[uehymueljuwu[1]-'A']
FIELD_IDENTIFIER en en
<operator>.indirectIndexAccess combination[uehymueljuwu[1]-'A']
FIELD_IDENTIFIER rows rows
<operator>.fieldAccess combination[kpbclchkvluz[evbknzbqnymc]-'A'].rows
<operator>.fieldAccess oppose[kpbclchkvluz[evbknzbqnymc]-'A'].opposer
<operator>.indirectIndexAccess kpbclchkvluz[evbknzbqnymc]
<operator>.indirectIndexAccess combination[kpbclchkvluz[evbknzbqnymc]-'A']
FIELD_IDENTIFIER rows rows
<operator>.indirectIndexAccess kpbclchkvluz[evbknzbqnymc]
<operator>.indirectIndexAccess oppose[kpbclchkvluz[evbknzbqnymc]-'A']
FIELD_IDENTIFIER opposer opposer
<operator>.indirectIndexAccess uehymueljuwu[0]
<operator>.indirectIndexAccess uehymueljuwu[0]
<operator>.indirectIndexAccess uehymueljuwu[1]
<operator>.indirectIndexAccess uehymueljuwu[1]
<operator>.indirectIndexAccess combination[kpbclchkvluz[evbknzbqnymc]-'A'].combination_list[ugoqaiekzujl][0]
<operator>.indirectIndexAccess kpbclchkvluz[ugoqaiekzujl]
<operator>.indirectIndexAccess kpbclchkvluz[evbknzbqnymc]
<operator>.indirectIndexAccess combination[kpbclchkvluz[evbknzbqnymc]-'A'].combination_list[ugoqaiekzujl]
<operator>.indirectIndexAccess kpbclchkvluz[evbknzbqnymc-1]
<operator>.indirectIndexAccess kpbclchkvluz[evbknzbqnymc]
<operator>.indirectIndexAccess kpbclchkvluz[evbknzbqnymc]
<operator>.fieldAccess combination[kpbclchkvluz[evbknzbqnymc]-'A'].combination_list
<operator>.indirectIndexAccess combination[kpbclchkvluz[evbknzbqnymc]-'A'].combination_list[ugoqaiekzujl][1]
<operator>.indirectIndexAccess combination[kpbclchkvluz[evbknzbqnymc]-'A']
FIELD_IDENTIFIER combination_list combination_list
<operator>.indirectIndexAccess combination[kpbclchkvluz[evbknzbqnymc]-'A'].combination_list[ugoqaiekzujl]
<operator>.fieldAccess combination[kpbclchkvluz[evbknzbqnymc]-'A'].combination_list
<operator>.indirectIndexAccess kpbclchkvluz[evbknzbqnymc]
<operator>.indirectIndexAccess combination[kpbclchkvluz[evbknzbqnymc]-'A']
FIELD_IDENTIFIER combination_list combination_list
<operator>.indirectIndexAccess kpbclchkvluz[evbknzbqnymc]
>>>PDG&203 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->65 0->66 0->67 0->68 0->73 0->74 0->75 0->76 0->77 0->80 0->83 0->86 0->87 0->88 0->90 0->91 0->92 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->114 0->115 0->116 0->117 0->118 0->119 0->120 0->122 0->123 0->124 0->126 0->127 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->138 0->140 0->141 0->142 0->143 0->144 0->145 0->146 0->147 0->148 0->149 0->150 0->151 0->152 2->1 2->1 2->6 3->1 3->1 3->8 3->25 4->1 4->1 4->43 5->1 5->1 5->1 6->1 6->1 6->7 6->15 6->27 7->1 7->1 8->1 8->1 9->1 11->9 12->2 12->2 13->3 13->3 14->1 14->1 14->46 15->1 15->1 15->16 15->57 15->65 16->18 17->1 17->1 17->1 17->47 18->1 18->1 18->19 18->67 18->73 19->20 20->1 20->1 20->21 20->22 20->30 20->39 20->51 20->74 21->1 21->23 22->1 22->1 22->23 23->1 23->1 23->7 23->15 23->41 23->48 24->1 24->32 24->52 25->1 25->1 25->26 25->45 26->1 26->8 26->25 27->1 27->1 30->1 30->1 30->20 30->22 30->30 30->31 30->31 30->39 30->41 30->51 30->52 30->74 30->153 30->154 31->1 31->30 32->1 32->1 32->1 32->32 32->33 32->45 32->55 32->55 32->83 32->83 32->155 33->1 33->32 37->1 37->1 37->1 37->46 38->1 38->1 38->1 38->47 39->1 40->30 41->1 41->1 41->1 41->124 41->126 42->1 42->32 42->52 43->1 43->25 44->1 44->32 45->1 45->1 45->26 45->76 46->1 47->1 48->1 51->1 52->1 52->42 52->42 52->75 52->75 52->81 52->82 52->101 52->104 52->124 52->126 52->138 52->150 52->156 52->157 52->162 52->163 52->164 52->165 52->176 52->179 55->1 55->1 55->33 55->76 56->1 57->58 58->1 58->1 58->16 58->57 58->68 58->87 58->88 58->91 58->92 58->108 58->112 58->122 58->123 58->128 58->129 58->130 58->131 58->132 58->133 58->134 58->135 58->140 58->141 58->142 58->143 59->1 59->109 60->1 60->1 61->1 61->1 62->1 62->113 63->1 63->1 63->1 64->1 64->1 64->1 65->1 65->1 65->15 66->1 67->68 68->1 68->1 68->19 68->58 68->67 68->95 68->97 68->115 68->116 68->117 68->118 69->1 69->1 70->1 70->1 71->1 71->1 71->1 72->1 72->1 72->1 73->1 73->1 73->18 75->1 75->32 75->52 76->1 76->26 76->45 78->1 78->1 78->85 78->86 78->107 78->128 78->129 78->158 78->159 78->166 78->167 78->168 78->169 78->182 78->183 79->1 79->1 79->1 79->89 79->90 79->111 79->132 79->133 79->160 79->161 79->170 79->171 79->172 79->173 79->184 79->185 81->1 81->1 81->102 81->119 81->144 81->174 81->177 81->178 81->188 82->1 82->1 82->98 82->105 82->120 82->121 82->138 82->147 82->175 82->180 82->181 82->192 83->32 83->55 83->55 84->1 85->1 85->1 86->1 86->59 87->60 87->60 87->123 88->61 88->61 88->92 89->1 89->1 89->1 90->1 90->62 91->1 91->58 91->63 91->63 91->68 91->115 91->122 91->127 92->1 92->58 92->64 92->64 92->68 92->88 92->127 93->1 94->69 95->70 95->70 95->117 96->71 97->1 97->58 97->68 97->72 97->72 97->115 97->122 97->127 98->1 98->1 98->1 98->58 98->68 98->127 99->78 100->79 101->81 102->1 102->1 102->103 102->125 102->145 102->150 102->151 102->186 102->189 102->190 102->193 102->195 102->196 102->199 103->1 103->102 104->82 105->1 105->1 105->106 105->127 105->187 106->1 106->105 107->85 108->130 109->110 110->1 111->89 112->134 113->114 114->1 115->116 116->97 117->118 118->1 118->58 118->68 118->87 118->95 118->127 119->1 119->102 121->1 121->1 121->105 122->108 122->128 123->112 123->132 124->1 124->126 124->144 125->1 125->1 125->1 125->81 125->101 125->102 125->103 125->124 125->136 125->137 125->144 125->148 125->152 125->156 125->162 125->163 125->174 125->176 125->177 125->178 125->188 125->191 125->194 125->197 125->198 125->200 125->201 125->202 126->1 126->147 127->1 127->1 127->1 127->58 127->68 127->105 127->106 127->139 127->149 128->129 129->108 130->140 131->141 132->133 133->112 134->142 135->143 136->1 136->42 136->138 136->150 137->1 137->1 137->1 137->124 137->126 137->144 138->42 138->121 138->121 139->1 139->1 139->42 140->131 141->91 142->135 143->1 143->58 143->68 143->87 143->95 143->127 144->1 144->126 144->151 145->1 145->125 145->125 147->1 148->1 149->139 150->42 150->136 150->138 151->144 151->152
>>>Token int main ( ) { FILE * inputFile , * outputFile ; inputFile = fopen ( " " , " " ) ; outputFile = fopen ( " " , " " ) ; int kyazszsgbaag , combinationCount , opposeCount , inputLength , testCount = 0 ; char * inputString = NULL ; fscanf ( inputFile , " " , & kyazszsgbaag ) ; while ( kyazszsgbaag ) { combinationList * combination = NULL ; fscanf ( inputFile , " " , & combinationCount ) ; if ( combinationCount ) { combination = ( combinationList * ) calloc ( 26 , sizeof ( combinationList ) ) ; while ( combinationCount ) { char uehymueljuwu [ 4 ] ; fgetc ( inputFile ) ; fscanf ( inputFile , " " , uehymueljuwu ) ; if ( combination [ uehymueljuwu [ 0 ] - ' ' ] . en != -1 ) { combination [ uehymueljuwu [ 0 ] - ' ' ] . en = -1 ; combination [ uehymueljuwu [ 0 ] - ' ' ] . rows = 0 ; } combination [ uehymueljuwu [ 0 ] - ' ' ] . rows ++ ; combination [ uehymueljuwu [ 0 ] - ' ' ] . combination_list [ combination [ uehymueljuwu [ 0 ] - ' ' ] . rows - 1 ] [ 0 ] = uehymueljuwu [ 1 ] - ' ' ; combination [ uehymueljuwu [ 0 ] - ' ' ] . combination_list [ combination [ uehymueljuwu [ 0 ] - ' ' ] . rows - 1 ] [ 1 ] = uehymueljuwu [ 2 ] - ' ' ; if ( combination [ uehymueljuwu [ 1 ] - ' ' ] . en != -1 ) { combination [ uehymueljuwu [ 1 ] - ' ' ] . en = -1 ; combination [ uehymueljuwu [ 1 ] - ' ' ] . rows = 0 ; } combination [ uehymueljuwu [ 1 ] - ' ' ] . rows ++ ; combination [ uehymueljuwu [ 1 ] - ' ' ] . combination_list [ combination [ uehymueljuwu [ 1 ] - ' ' ] . rows - 1 ] [ 0 ] = uehymueljuwu [ 0 ] - ' ' ; combination [ uehymueljuwu [ 1 ] - ' ' ] . combination_list [ combination [ uehymueljuwu [ 1 ] - ' ' ] . rows - 1 ] [ 1 ] = uehymueljuwu [ 2 ] - ' ' ; combinationCount -- ; } } fgetc ( inputFile ) ; opposeList * oppose = NULL ; fscanf ( inputFile , " " , & opposeCount ) ; if ( opposeCount ) { oppose = ( opposeList * ) calloc ( 26 , sizeof ( opposeList ) ) ; while ( opposeCount ) { char uehymueljuwu [ 3 ] ; fgetc ( inputFile ) ; fscanf ( inputFile , " " , uehymueljuwu ) ; oppose [ uehymueljuwu [ 0 ] - ' ' ] . en = -1 ; oppose [ uehymueljuwu [ 0 ] - ' ' ] . opposer = uehymueljuwu [ 1 ] - ' ' ; oppose [ uehymueljuwu [ 1 ] - ' ' ] . en = -1 ; oppose [ uehymueljuwu [ 1 ] - ' ' ] . opposer = uehymueljuwu [ 0 ] - ' ' ; opposeCount -- ; } } fgetc ( inputFile ) ; fscanf ( inputFile , " " , & inputLength ) ; fgetc ( inputFile ) ; inputString = ( char * ) calloc ( inputLength + 1 , 1 ) ; fscanf ( inputFile , " " , inputString ) ; char kpbclchkvluz [ inputLength ] ; int evbknzbqnymc = 0 ; for ( int geledvsjpzly = 0 ; geledvsjpzly < inputLength ; geledvsjpzly ++ ) { kpbclchkvluz [ evbknzbqnymc ] = inputString [ geledvsjpzly ] ; if ( ! evbknzbqnymc ) { evbknzbqnymc ++ ; continue ; } qgokuvwckaoo : if ( combination ) { if ( combination [ kpbclchkvluz [ evbknzbqnymc ] - ' ' ] . en == -1 ) { for ( int ugoqaiekzujl = 0 ; ugoqaiekzujl < combination [ kpbclchkvluz [ evbknzbqnymc ] - ' ' ] . rows ; ugoqaiekzujl ++ ) { if ( combination [ kpbclchkvluz [ evbknzbqnymc ] - ' ' ] . combination_list [ ugoqaiekzujl ] [ 0 ] == ( kpbclchkvluz [ evbknzbqnymc - 1 ] - ' ' ) ) { evbknzbqnymc -- ; kpbclchkvluz [ evbknzbqnymc ] = combination [ kpbclchkvluz [ evbknzbqnymc ] - ' ' ] . combination_list [ ugoqaiekzujl ] [ 1 ] + ' ' ; if ( evbknzbqnymc ) goto qgokuvwckaoo ; } } } } if ( oppose ) { if ( oppose [ kpbclchkvluz [ evbknzbqnymc ] - ' ' ] . en == -1 ) { char uehymueljuwu = oppose [ kpbclchkvluz [ evbknzbqnymc ] - ' ' ] . opposer + ' ' ; for ( int ugoqaiekzujl = evbknzbqnymc - 1 ; ugoqaiekzujl >= 0 ; ugoqaiekzujl -- ) { if ( kpbclchkvluz [ ugoqaiekzujl ] == uehymueljuwu ) { evbknzbqnymc = -1 ; break ; } } } } evbknzbqnymc ++ ; } fprintf ( outputFile , " " , ++ testCount ) ; for ( int geledvsjpzly = 0 ; geledvsjpzly < evbknzbqnymc ; geledvsjpzly ++ ) { fprintf ( outputFile , " " , kpbclchkvluz [ geledvsjpzly ] ) ; if ( geledvsjpzly != evbknzbqnymc - 1 ) fprintf ( outputFile , " " ) ; } fprintf ( outputFile , " \n " ) ; kyazszsgbaag -- ; if ( combination ) free ( combination ) ; if ( oppose ) free ( oppose ) ; if ( inputString ) free ( inputString ) ; } fclose ( inputFile ) ; fclose ( outputFile ) ; return ( EXIT_SUCCESS ) ; }
>>>Func
METHOD yzacdieeyuyr
METHOD_RETURN usbizhyqmtpnvoid
PARAM int hllcipxvjexu
PARAM int ngbxhfsxybmx
PARAM int qtjfggueqpvg [ ]
init_p init_p(ngbxhfsxybmx,qtjfggueqpvg)
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 3->5 4->5 5->1 5->1 5->1
>>>Token static usbizhyqmtpnvoid yzacdieeyuyr ( int hllcipxvjexu , int ngbxhfsxybmx , int qtjfggueqpvg [ ] ) { init_p ( ngbxhfsxybmx , qtjfggueqpvg ) ; }
>>>Func
METHOD carqwcvqhioy
METHOD_RETURN bool
PARAM struct vvzwgjvtfotr*root
RETURN return carqwcvqhioy(root->left)&&carqwcvqhioy(root->right); return carqwcvqhioy(root->left)&&carqwcvqhioy(root->right);
<operator>.equals root==NULL
<operator>.logicalAnd carqwcvqhioy(root->left)&&carqwcvqhioy(root->right)
RETURN return 1; return 1;
LITERAL 1 return 1;
<operator>.notEquals root->left->val!=root->val
<operator>.notEquals root->right->val!=root->val
carqwcvqhioy carqwcvqhioy(root->left)
carqwcvqhioy carqwcvqhioy(root->right)
RETURN return 0; return 0;
RETURN return 0; return 0;
LITERAL 0 return 0;
LITERAL 0 return 0;
<operator>.indirectFieldAccess root->left
<operator>.indirectFieldAccess root->right
FIELD_IDENTIFIER left left
FIELD_IDENTIFIER right right
<operator>.indirectFieldAccess root->left
<operator>.indirectFieldAccess root->right
<operator>.indirectFieldAccess root->left->val
<operator>.indirectFieldAccess root->val
<operator>.indirectFieldAccess root->right->val
<operator>.indirectFieldAccess root->val
FIELD_IDENTIFIER left left
FIELD_IDENTIFIER right right
<operator>.indirectFieldAccess root->left
FIELD_IDENTIFIER val val
FIELD_IDENTIFIER val val
<operator>.indirectFieldAccess root->right
FIELD_IDENTIFIER val val
FIELD_IDENTIFIER val val
FIELD_IDENTIFIER left left
FIELD_IDENTIFIER right right
>>>PDG&36 0->2 0->4 0->6 0->7 0->12 0->13 0->14 0->15 2->4 3->1 4->1 4->1 4->1 4->6 4->16 4->18 5->3 6->1 7->6 8->9 8->12 8->17 8->19 9->3 9->5 9->10 9->13 9->20 9->26 10->5 10->11 10->21 10->27 11->5 12->1 13->1 14->12 15->13 16->8 16->17 16->19 16->22 16->23 16->28 16->29 16->30 16->34 17->3 17->5 17->9 17->10 17->20 17->24 17->25 17->26 17->31 17->32 17->33 17->35
>>>Token bool carqwcvqhioy ( struct vvzwgjvtfotr * root ) { if ( root == NULL ) return 1 ; if ( root -> left ) { if ( root -> left -> val != root -> val ) return 0 ; } if ( root -> right ) { if ( root -> right -> val != root -> val ) return 0 ; } return carqwcvqhioy ( root -> left ) && carqwcvqhioy ( root -> right ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment l=1
scanf scanf("%d",&bzhmkkmxdfao)
<operator>.assignment *fp=fopen("output1.out","w")
RETURN return 0; return 0;
<operator>.lessEqualsThan l<=bzhmkkmxdfao
<operator>.postIncrement l++
LITERAL 0 return 0;
fopen fopen("output1.out","w")
<operator>.assignment q=1
<operator>.assignment tycpwutebxra[4]={'\0'}
<operator>.assignment ds[4]={'\0'}
scanf scanf("%d",&c)
scanf scanf("%d",&d)
<operator>.assignment lsecznejwcuu[15]={'\0'}
scanf scanf("%d%s",&n,lsecznejwcuu)
<operator>.assignment ilbzzsavbbny[15]={'\0'}
<operator>.assignment ilbzzsavbbny[0]=lsecznejwcuu[0]
<operator>.assignment tmubvjsrlaep[45]={'\0'}
<operator>.assignment tmubvjsrlaep[0]='['
<operator>.assignment vipfeijdyfkz=0
<operator>.assignment w=1
<operator>.assignment tmubvjsrlaep[w++]=ilbzzsavbbny[vipfeijdyfkz]
fprintf fprintf(fp,"Case #%d: %s]\n",l,tmubvjsrlaep)
<operator>.lessThan drlrwoyofabt<c
<operator>.postIncrement drlrwoyofabt++
scanf scanf("%s",tycpwutebxra)
<operator>.lessThan drlrwoyofabt<d
<operator>.postIncrement drlrwoyofabt++
scanf scanf("%s",ds)
<operator>.logicalAnd drlrwoyofabt<n&&q<n
<operator>.expressionList drlrwoyofabt++ q++
<operator>.lessThan vipfeijdyfkz<strlen(ilbzzsavbbny)-1
<operator>.arrayInitializer {'\0'}
<operator>.arrayInitializer {'\0'}
<operator>.assignment drlrwoyofabt=0
<operator>.assignment drlrwoyofabt=0
<operator>.arrayInitializer {'\0'}
<operator>.arrayInitializer {'\0'}
<operator>.assignment drlrwoyofabt=1
<operator>.assignment rpwtubvtdbce=1
<operator>.assignment ilbzzsavbbny[q]=lsecznejwcuu[drlrwoyofabt]
<operator>.arrayInitializer {'\0'}
<operator>.assignment tmubvjsrlaep[w++]=ilbzzsavbbny[vipfeijdyfkz]
<operator>.assignment tmubvjsrlaep[w++]=' '
<operator>.assignment tmubvjsrlaep[w++]=''
<operator>.postIncrement vipfeijdyfkz++
<operator>.lessThan drlrwoyofabt<n
<operator>.lessThan q<n
<operator>.postIncrement drlrwoyofabt++
<operator>.postIncrement q++
<operator>.logicalAnd rpwtubvtdbce&&q>0
<operator>.subtraction strlen(ilbzzsavbbny)-1
<operator>.postIncrement w++
rwkbiyllnoia rwkbiyllnoia((q>0&&ilbzzsavbbny[q]==tycpwutebxra[0]&&ilbzzsavbbny[q-1]==tycpwutebxra[1])||(q>0&&ilbzzsavbbny[q]==tycpwutebxra[1]&&ilbzzsavbbny[q-1]==tycpwutebxra[0]))
BLOCK <empty> <empty>
strlen strlen(ilbzzsavbbny)
<operator>.greaterThan q>0
<operator>.assignment ilbzzsavbbny[q-1]=tycpwutebxra[2]
<operator>.assignment ilbzzsavbbny[q]='\0'
<operator>.assignment q=q-1
<operator>.postIncrement w++
<operator>.postIncrement w++
<operator>.postIncrement w++
<operator>.logicalOr (q>0&&ilbzzsavbbny[q]==tycpwutebxra[0]&&ilbzzsavbbny[q-1]==tycpwutebxra[1])||(q>0&&ilbzzsavbbny[q]==tycpwutebxra[1]&&ilbzzsavbbny[q-1]==tycpwutebxra[0])
<operator>.logicalAnd q>0&&ilbzzsavbbny[q]==tycpwutebxra[0]&&ilbzzsavbbny[q-1]==tycpwutebxra[1]
<operator>.logicalAnd q>0&&ilbzzsavbbny[q]==tycpwutebxra[1]&&ilbzzsavbbny[q-1]==tycpwutebxra[0]
<operator>.subtraction q-1
<operator>.logicalAnd q>0&&ilbzzsavbbny[q]==tycpwutebxra[0]
<operator>.equals ilbzzsavbbny[q-1]==tycpwutebxra[1]
<operator>.logicalAnd q>0&&ilbzzsavbbny[q]==tycpwutebxra[1]
<operator>.equals ilbzzsavbbny[q-1]==tycpwutebxra[0]
<operator>.subtraction q-1
<operator>.greaterThan q>0
<operator>.equals ilbzzsavbbny[q]==tycpwutebxra[0]
<operator>.greaterThan q>0
<operator>.equals ilbzzsavbbny[q]==tycpwutebxra[1]
<operator>.subtraction q-1
<operator>.subtraction q-1
<operator>.addressOf &c
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.indirectIndexAccess ilbzzsavbbny[0]
<operator>.indirectIndexAccess lsecznejwcuu[0]
<operator>.indirectIndexAccess tmubvjsrlaep[0]
<operator>.indirectIndexAccess tmubvjsrlaep[w++]
<operator>.indirectIndexAccess ilbzzsavbbny[vipfeijdyfkz]
<operator>.indirectIndexAccess ilbzzsavbbny[q]
<operator>.indirectIndexAccess lsecznejwcuu[drlrwoyofabt]
<operator>.indirectIndexAccess tmubvjsrlaep[w++]
<operator>.indirectIndexAccess ilbzzsavbbny[vipfeijdyfkz]
<operator>.indirectIndexAccess tmubvjsrlaep[w++]
<operator>.indirectIndexAccess tmubvjsrlaep[w++]
UNKNOWN,),)
UNKNOWN else rwkbiyllnoia (q>0&&ilbzzsavbbny[q]==ds[0]&&search(ilbzzsavbbny,ds[1])){memset(ilbzzsavbbny '\0' sizeof(ilbzzsavbbny));q=-1;} else rwkbiyllnoia (q>0&&ilbzzsavbbny[q]==ds[0]&&search(ilbzzsavbbny,ds[1])){memset(ilbzzsavbbny '\0' sizeof(ilbzzsavbbny));q=-1;}
UNKNOWN else rwkbiyllnoia (q>0&&ilbzzsavbbny[q]==ds[1]&&search(ilbzzsavbbny,ds[0])){memset(ilbzzsavbbny '\0' sizeof(ilbzzsavbbny));q=-1;} else rwkbiyllnoia (q>0&&ilbzzsavbbny[q]==ds[1]&&search(ilbzzsavbbny,ds[0])){memset(ilbzzsavbbny '\0' sizeof(ilbzzsavbbny));q=-1;}
UNKNOWN else rpwtubvtdbce =0; else rpwtubvtdbce =0;
<operator>.indirectIndexAccess ilbzzsavbbny[q-1]
<operator>.indirectIndexAccess tycpwutebxra[2]
<operator>.indirectIndexAccess ilbzzsavbbny[q]
<operator>.indirectIndexAccess ilbzzsavbbny[q-1]
<operator>.indirectIndexAccess tycpwutebxra[1]
<operator>.indirectIndexAccess ilbzzsavbbny[q-1]
<operator>.indirectIndexAccess tycpwutebxra[0]
<operator>.indirectIndexAccess ilbzzsavbbny[q]
<operator>.indirectIndexAccess tycpwutebxra[0]
<operator>.indirectIndexAccess ilbzzsavbbny[q]
<operator>.indirectIndexAccess tycpwutebxra[1]
>>>PDG&109 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->13 0->14 0->16 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->43 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->56 0->57 0->58 0->60 0->62 0->63 0->64 0->68 0->73 0->74 0->76 0->78 0->79 2->1 2->6 3->1 3->6 4->1 4->1 4->1 4->24 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->20 6->21 6->22 6->23 6->24 6->24 6->25 6->28 6->31 6->33 6->34 6->35 6->36 6->37 6->38 6->39 6->40 6->43 6->48 6->53 6->54 6->57 6->80 6->81 6->82 6->83 6->84 6->85 6->86 6->87 7->1 7->6 8->5 9->4 9->4 10->1 10->1 10->49 10->51 10->58 10->74 11->1 11->1 11->27 11->59 11->70 11->72 11->75 11->77 12->1 12->1 12->30 13->1 13->25 14->1 14->28 15->1 16->1 16->1 16->48 16->49 17->1 17->57 17->70 17->72 17->75 17->77 18->1 18->1 18->1 18->57 19->1 19->1 19->24 20->1 20->1 20->24 21->1 21->33 22->1 22->54 22->62 23->1 23->1 23->1 23->24 24->1 24->1 24->1 24->7 25->1 25->1 25->13 25->25 25->26 25->26 25->27 26->1 26->25 27->1 27->59 27->70 27->72 27->75 27->77 28->1 28->1 28->14 28->28 28->29 28->29 28->30 29->1 29->28 30->1 31->1 31->1 31->1 31->31 31->32 31->41 31->42 31->48 31->50 31->51 31->52 31->58 31->88 31->89 32->1 32->1 32->1 33->1 33->1 33->1 33->33 33->44 33->45 33->46 33->47 33->47 33->53 33->57 33->62 33->63 33->64 33->90 33->91 33->92 33->93 34->11 35->12 36->25 37->1 37->28 38->15 39->17 40->1 40->48 41->1 41->52 42->1 42->1 42->1 42->57 42->75 42->77 43->19 45->1 46->1 47->1 47->33 48->1 48->1 48->16 48->31 48->31 48->49 48->49 48->50 49->1 49->1 49->16 49->31 49->31 49->48 49->51 49->58 49->74 50->32 50->48 51->1 51->32 51->49 51->58 51->74 52->1 52->1 52->1 52->52 52->55 52->58 52->59 52->60 52->61 52->65 52->66 52->68 52->69 52->73 52->74 52->94 52->95 52->96 52->97 52->98 52->99 52->100 53->1 53->33 53->33 54->1 55->1 55->1 57->1 57->23 57->44 57->53 58->51 58->52 58->52 58->74 59->1 59->1 59->1 59->57 59->70 59->72 60->1 60->1 60->57 60->75 60->77 61->1 61->1 61->51 61->58 61->74 62->63 63->64 64->54 64->62 65->1 65->1 65->55 65->55 66->1 66->1 66->65 66->65 66->67 66->71 66->76 67->1 67->1 67->65 67->65 68->61 68->61 69->1 69->52 69->66 69->66 69->70 69->78 69->101 69->102 70->1 70->27 70->66 70->66 70->72 70->77 71->1 71->52 71->67 71->67 71->72 71->79 71->103 71->104 72->1 72->27 72->67 72->67 72->75 73->68 74->69 74->69 74->73 74->75 74->76 74->78 74->105 74->106 75->1 75->27 75->69 75->69 75->72 75->77 76->71 76->71 76->73 76->77 76->79 76->107 76->108 77->1 77->27 77->70 77->71 77->71 78->73 78->76 79->73
>>>Token int main ( ) { int bzhmkkmxdfao , l = 1 ; scanf ( " " , & bzhmkkmxdfao ) ; FILE * fp = fopen ( " " , " " ) ; for ( ; l <= bzhmkkmxdfao ; l ++ ) { int drlrwoyofabt , c , d , n ; q = 1 ; char tycpwutebxra [ 4 ] = { ' \0 ' } , ds [ 4 ] = { ' \0 ' } ; scanf ( " " , & c ) ; for ( drlrwoyofabt = 0 ; drlrwoyofabt < c ; drlrwoyofabt ++ ) scanf ( " " , tycpwutebxra ) ; scanf ( " " , & d ) ; for ( drlrwoyofabt = 0 ; drlrwoyofabt < d ; drlrwoyofabt ++ ) scanf ( " " , ds ) ; char lsecznejwcuu [ 15 ] = { ' \0 ' } ; scanf ( " " , & n , lsecznejwcuu ) ; char ilbzzsavbbny [ 15 ] = { ' \0 ' } ; ilbzzsavbbny [ 0 ] = lsecznejwcuu [ 0 ] ; for ( drlrwoyofabt = 1 ; drlrwoyofabt < n && q < n ; drlrwoyofabt ++ , q ++ ) { int rpwtubvtdbce = 1 ; ilbzzsavbbny [ q ] = lsecznejwcuu [ drlrwoyofabt ] ; while ( rpwtubvtdbce && q > 0 ) { rwkbiyllnoia ( ( q > 0 && ilbzzsavbbny [ q ] == tycpwutebxra [ 0 ] && ilbzzsavbbny [ q - 1 ] == tycpwutebxra [ 1 ] ) || ( q > 0 && ilbzzsavbbny [ q ] == tycpwutebxra [ 1 ] && ilbzzsavbbny [ q - 1 ] == tycpwutebxra [ 0 ] ) )  { ilbzzsavbbny [ q - 1 ] = tycpwutebxra [ 2 ] ; ilbzzsavbbny [ q ] = ' \0 ' ; q = q - 1 ; } else rwkbiyllnoia ( q > 0 && ilbzzsavbbny [ q ] = = ds [ 0 ] & & search ( ilbzzsavbbny , ds [ 1 ] ) ) { memset ( ilbzzsavbbny , ' \0 ' , sizeof ( ilbzzsavbbny ) ) ; q = -1 ; } else rwkbiyllnoia ( q > 0 && ilbzzsavbbny [ q ] = = ds [ 1 ] & & search ( ilbzzsavbbny , ds [ 0 ] ) ) { memset ( ilbzzsavbbny , ' \0 ' , sizeof ( ilbzzsavbbny ) ) ; q = -1 ; } else rpwtubvtdbce = 0 ; } } char tmubvjsrlaep [ 45 ] = { ' \0 ' } ; tmubvjsrlaep [ 0 ] = ' ' ; int vipfeijdyfkz = 0 , w = 1 ; while ( vipfeijdyfkz < strlen ( ilbzzsavbbny ) - 1 ) { tmubvjsrlaep [ w ++ ] = ilbzzsavbbny [ vipfeijdyfkz ] ; tmubvjsrlaep [ w ++ ] = ' ' ; tmubvjsrlaep [ w ++ ] = ' ' ; vipfeijdyfkz ++ ; } tmubvjsrlaep [ w ++ ] = ilbzzsavbbny [ vipfeijdyfkz ] ; fprintf ( fp , " \n " , l , tmubvjsrlaep ) ; } return 0 ; }
>>>Func
METHOD ftrkwupoaevq
METHOD_RETURN int
PARAM int rtzoiywlnjsk
PARAM FILE *fp
PARAM char dzbnxzlauvtn [ ][102]
RETURN return 0; return 0;
<operator>.lessThan ofcixkmwjgtc<rtzoiywlnjsk
<operator>.postIncrement ofcixkmwjgtc++
LITERAL 0 return 0;
<operator>.assignment ofcixkmwjgtc=0
fgets fgets(dzbnxzlauvtn[ofcixkmwjgtc] sizeof(dzbnxzlauvtn[ofcixkmwjgtc]),fp)
<operator>.assignment dzbnxzlauvtn[ofcixkmwjgtc][strlen(dzbnxzlauvtn[ofcixkmwjgtc])-1]='\0'
<operator>.subtraction strlen(dzbnxzlauvtn[ofcixkmwjgtc])-1
strlen strlen(dzbnxzlauvtn[ofcixkmwjgtc])
<operator>.indirectIndexAccess dzbnxzlauvtn[ofcixkmwjgtc]
<operator>.sizeOf sizeof(dzbnxzlauvtn[ofcixkmwjgtc])
<operator>.indirectIndexAccess dzbnxzlauvtn[ofcixkmwjgtc][strlen(dzbnxzlauvtn[ofcixkmwjgtc])-1]
<operator>.indirectIndexAccess dzbnxzlauvtn[ofcixkmwjgtc]
<operator>.indirectIndexAccess dzbnxzlauvtn[ofcixkmwjgtc]
<operator>.indirectIndexAccess dzbnxzlauvtn[ofcixkmwjgtc]
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->6 3->1 3->10 4->1 4->10 4->13 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->13 11->1 11->1 11->10 11->13 12->1 13->1 13->12
>>>Token int ftrkwupoaevq ( int rtzoiywlnjsk , FILE * fp , char dzbnxzlauvtn [ ] [ 102 ] ) { int ofcixkmwjgtc ; for ( ofcixkmwjgtc = 0 ; ofcixkmwjgtc < rtzoiywlnjsk ; ofcixkmwjgtc ++ ) { fgets ( dzbnxzlauvtn [ ofcixkmwjgtc ] , sizeof ( dzbnxzlauvtn [ ofcixkmwjgtc ] ) , fp ) ; dzbnxzlauvtn [ ofcixkmwjgtc ] [ strlen ( dzbnxzlauvtn [ ofcixkmwjgtc ] ) - 1 ] = ' \0 ' ; } return 0 ; }
>>>Func
METHOD crkxobvjvoen
METHOD_RETURN int
PARAM int yddpefwogefa [ ]
PARAM int euhkknvlxajq
PARAM int lgcjwtjzierl
<operator>.assignment owkzspvkgdrs=0
<operator>.assignment ztvdfcdnsfsf=1
<operator>.assignment fzhgwjavzgws=owkzspvkgdrs+ztvdfcdnsfsf
<operator>.assignment pgmweqtvtccv=-1
zajhqlfrbheh zajhqlfrbheh(ztvdfcdnsfsf&&yddpefwogefa[pgmweqtvtccv+1]==euhkknvlxajq)
<operator>.plus +1
<operator>.subtraction pjdrqlxxmdbd-1
<operator>.lessThan fzhgwjavzgws<lgcjwtjzierl
<operator>.greaterThan fzhgwjavzgws>1
<operator>.addition owkzspvkgdrs+ztvdfcdnsfsf
<operator>.assignment owkzspvkgdrs=ztvdfcdnsfsf
<operator>.assignment ztvdfcdnsfsf=fzhgwjavzgws
<operator>.assignment fzhgwjavzgws=owkzspvkgdrs+ztvdfcdnsfsf
<operator>.minus -1
<operator>.assignment kcnsgisjkiko=((pgmweqtvtccv+owkzspvkgdrs)<(lgcjwtjzierl-1))?(pgmweqtvtccv+owkzspvkgdrs):(lgcjwtjzierl-1)
zajhqlfrbheh zajhqlfrbheh(yddpefwogefa[kcnsgisjkiko]<euhkknvlxajq)
BLOCK <empty> <empty>
<operator>.logicalAnd ztvdfcdnsfsf&&yddpefwogefa[pgmweqtvtccv+1]==euhkknvlxajq
<operator>.assignment fzhgwjavzgws=ztvdfcdnsfsf
<operator>.assignment ztvdfcdnsfsf=owkzspvkgdrs
<operator>.assignment owkzspvkgdrs=fzhgwjavzgws-ztvdfcdnsfsf
<operator>.assignment pgmweqtvtccv=kcnsgisjkiko
<operator>.equals yddpefwogefa[pgmweqtvtccv+1]==euhkknvlxajq
<operator>.addition owkzspvkgdrs+ztvdfcdnsfsf
<operator>.conditional ((pgmweqtvtccv+owkzspvkgdrs)<(lgcjwtjzierl-1))?(pgmweqtvtccv+owkzspvkgdrs):(lgcjwtjzierl-1)
<operator>.lessThan yddpefwogefa[kcnsgisjkiko]<euhkknvlxajq
<operator>.lessThan (pgmweqtvtccv+owkzspvkgdrs)<(lgcjwtjzierl-1)
<operator>.addition pgmweqtvtccv+owkzspvkgdrs
<operator>.subtraction lgcjwtjzierl-1
<operator>.subtraction fzhgwjavzgws-ztvdfcdnsfsf
<operator>.addition pgmweqtvtccv+1
<operator>.addition pgmweqtvtccv+owkzspvkgdrs
<operator>.subtraction lgcjwtjzierl-1
UNKNOWN,),)
UNKNOWN else zajhqlfrbheh (yddpefwogefa[kcnsgisjkiko]>euhkknvlxajq){fzhgwjavzgws=owkzspvkgdrs;ztvdfcdnsfsf=ztvdfcdnsfsf-owkzspvkgdrs;owkzspvkgdrs=fzhgwjavzgws-ztvdfcdnsfsf;} else zajhqlfrbheh (yddpefwogefa[kcnsgisjkiko]>euhkknvlxajq){fzhgwjavzgws=owkzspvkgdrs;ztvdfcdnsfsf=ztvdfcdnsfsf-owkzspvkgdrs;owkzspvkgdrs=fzhgwjavzgws-ztvdfcdnsfsf;}
UNKNOWN else pjdrqlxxmdbd kcnsgisjkiko; else pjdrqlxxmdbd kcnsgisjkiko;
<operator>.indirectIndexAccess yddpefwogefa[kcnsgisjkiko]
>>>PDG&42 0->2 0->3 0->4 0->5 0->6 0->7 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->21 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 2->1 2->27 2->30 3->1 3->27 3->30 4->12 5->1 5->7 5->14 5->19 5->24 5->29 5->31 5->32 5->36 6->1 6->7 6->14 6->15 6->22 6->23 7->1 7->1 7->12 8->1 8->1 8->1 8->19 8->29 8->31 8->32 8->35 8->36 9->1 9->1 10->1 11->1 11->1 12->1 12->1 12->12 12->13 12->15 12->16 12->16 12->17 12->28 12->37 13->1 13->1 13->13 13->19 13->20 13->23 13->24 13->25 13->26 13->29 13->30 13->31 13->34 13->36 13->37 13->38 13->39 13->40 13->41 14->1 15->1 15->17 15->19 15->24 15->28 15->29 15->31 15->32 15->36 16->1 16->15 16->17 16->22 16->23 16->28 17->1 17->1 17->12 18->8 19->1 19->1 19->26 20->1 20->1 22->1 22->1 22->9 22->9 23->1 23->34 24->1 24->34 25->1 25->1 25->1 25->19 25->24 25->29 25->31 25->32 25->36 26->1 26->1 26->1 26->19 26->29 26->31 26->32 26->35 26->36 27->1 27->1 27->22 27->22 28->1 29->1 29->1 29->1 30->1 30->1 30->20 30->20 30->27 31->19 31->19 31->29 31->29 31->32 31->33 33->1 33->19 33->19 33->29 33->29 33->37 34->13 34->22 34->23 34->25 34->25 35->1 37->1 37->31 37->31 37->33
>>>Token int crkxobvjvoen ( int yddpefwogefa [ ] , int euhkknvlxajq , int lgcjwtjzierl ) { int owkzspvkgdrs = 0 ; int ztvdfcdnsfsf = 1 ; int fzhgwjavzgws = owkzspvkgdrs + ztvdfcdnsfsf ; while ( fzhgwjavzgws < lgcjwtjzierl ) { owkzspvkgdrs = ztvdfcdnsfsf ; ztvdfcdnsfsf = fzhgwjavzgws ; fzhgwjavzgws = owkzspvkgdrs + ztvdfcdnsfsf ; } int pgmweqtvtccv = -1 ; while ( fzhgwjavzgws > 1 ) { int kcnsgisjkiko = ( ( pgmweqtvtccv + owkzspvkgdrs ) < ( lgcjwtjzierl - 1 ) ) ? ( pgmweqtvtccv + owkzspvkgdrs ) : ( lgcjwtjzierl - 1 ) ; zajhqlfrbheh ( yddpefwogefa [ kcnsgisjkiko ] < euhkknvlxajq )  { fzhgwjavzgws = ztvdfcdnsfsf ; ztvdfcdnsfsf = owkzspvkgdrs ; owkzspvkgdrs = fzhgwjavzgws - ztvdfcdnsfsf ; pgmweqtvtccv = kcnsgisjkiko ; } else zajhqlfrbheh ( yddpefwogefa [ kcnsgisjkiko ] > euhkknvlxajq ) { fzhgwjavzgws = owkzspvkgdrs ; ztvdfcdnsfsf = ztvdfcdnsfsf - owkzspvkgdrs ; owkzspvkgdrs = fzhgwjavzgws - ztvdfcdnsfsf ; } else pjdrqlxxmdbd  kcnsgisjkiko ; } zajhqlfrbheh ( ztvdfcdnsfsf && yddpefwogefa [ pgmweqtvtccv + 1 ] == euhkknvlxajq )  pjdrqlxxmdbd pgmweqtvtccv +1 ; pjdrqlxxmdbd - 1 ; }
>>>Func
METHOD bqdxlitmtxwy
METHOD_RETURN void
PARAM int gmlpshxoevrz
<operator>.lessThan xjtzwdpehfna<gmlpshxoevrz
<operator>.postIncrement xjtzwdpehfna++
<operator>.assignment xjtzwdpehfna=0
<operator>.assignment wk[xjtzwdpehfna].wp=0
<operator>.assignment wk[xjtzwdpehfna].owp=0
<operator>.assignment wk[xjtzwdpehfna].oowp=0
<operator>.assignment wk[xjtzwdpehfna].nb=0
<operator>.assignment wk[xjtzwdpehfna].wp_c=wk[xjtzwdpehfna].wp
<operator>.assignmentDivision wk[xjtzwdpehfna].wp/=wk[xjtzwdpehfna].nb
<operator>.lessThan evuymenumfbz<gmlpshxoevrz
<operator>.postIncrement evuymenumfbz++
<operator>.assignment evuymenumfbz=0
IDENTIFIER std <empty>
<operator>.assignment wk[xjtzwdpehfna].otable[evuymenumfbz]=0
<operator>.notEquals kijwjbenylfa!='.'
<operator>.postIncrement wk[xjtzwdpehfna].nb++
<operator>.equals kijwjbenylfa=='1'
<operator>.assignmentPlus wk[xjtzwdpehfna].wp+=1
<operator>.assignment wk[xjtzwdpehfna].otable[evuymenumfbz]=WI
<operator>.assignment wk[xjtzwdpehfna].otable[evuymenumfbz]=LO
<operator>.fieldAccess wk[xjtzwdpehfna].wp
<operator>.fieldAccess wk[xjtzwdpehfna].owp
<operator>.fieldAccess wk[xjtzwdpehfna].oowp
<operator>.fieldAccess wk[xjtzwdpehfna].nb
<operator>.fieldAccess wk[xjtzwdpehfna].wp_c
<operator>.fieldAccess wk[xjtzwdpehfna].wp
<operator>.fieldAccess wk[xjtzwdpehfna].wp
<operator>.fieldAccess wk[xjtzwdpehfna].nb
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER wp wp
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER owp owp
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER oowp oowp
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER nb nb
UNKNOWN d d
UNKNOWN ::cin>>kijwjbenylfa; ::cin>>kijwjbenylfa;
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER wp_c wp_c
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER wp wp
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER wp wp
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER nb nb
<operator>.indirectIndexAccess wk[xjtzwdpehfna].otable[evuymenumfbz]
<operator>.fieldAccess wk[xjtzwdpehfna].otable
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER otable otable
<operator>.fieldAccess wk[xjtzwdpehfna].nb
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER nb nb
<operator>.fieldAccess wk[xjtzwdpehfna].wp
<operator>.indirectIndexAccess wk[xjtzwdpehfna].otable[evuymenumfbz]
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER wp wp
<operator>.fieldAccess wk[xjtzwdpehfna].otable
<operator>.indirectIndexAccess wk[xjtzwdpehfna].otable[evuymenumfbz]
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER otable otable
<operator>.fieldAccess wk[xjtzwdpehfna].otable
<operator>.indirectIndexAccess wk[xjtzwdpehfna]
FIELD_IDENTIFIER otable otable
>>>PDG&67 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->22 2->3 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->7 3->8 3->9 3->10 3->11 3->12 3->12 3->14 3->23 3->24 3->25 3->26 3->27 3->28 3->29 3->30 3->31 3->32 3->33 3->34 3->35 3->36 3->37 3->38 3->41 3->42 3->43 3->44 3->45 3->46 3->47 3->48 4->1 4->3 5->1 5->3 6->10 6->11 6->20 9->11 9->18 12->3 12->12 12->13 12->13 12->16 12->17 12->39 12->40 12->49 12->50 12->51 12->52 13->12 14->12 17->18 17->19 17->19 17->53 17->54 17->55 18->11 19->17 19->20 19->21 19->22 19->56 19->57 19->58 19->59 19->60 19->61 19->62 19->63 19->64 19->65 19->66 20->10 20->11 21->1 22->1
>>>Token void bqdxlitmtxwy ( int gmlpshxoevrz ) { for ( int xjtzwdpehfna = 0 ; xjtzwdpehfna < gmlpshxoevrz ; xjtzwdpehfna ++ ) { wk [ xjtzwdpehfna ] . wp = 0 ; wk [ xjtzwdpehfna ] . owp = 0 ; wk [ xjtzwdpehfna ] . oowp = 0 ; wk [ xjtzwdpehfna ] . nb = 0 ; for ( int evuymenumfbz = 0 ; evuymenumfbz < gmlpshxoevrz ; evuymenumfbz ++ ) { char kijwjbenylfa ; std : : cin >> kijwjbenylfa ; wk [ xjtzwdpehfna ] . otable [ evuymenumfbz ] = 0 ; if ( kijwjbenylfa != ' ' ) { if ( kijwjbenylfa == ' ' ) { wk [ xjtzwdpehfna ] . wp += 1 ; wk [ xjtzwdpehfna ] . otable [ evuymenumfbz ] = WI ; } else { wk [ xjtzwdpehfna ] . otable [ evuymenumfbz ] = LO ; } wk [ xjtzwdpehfna ] . nb ++ ; } } wk [ xjtzwdpehfna ] . wp_c = wk [ xjtzwdpehfna ] . wp ; wk [ xjtzwdpehfna ] . wp /= wk [ xjtzwdpehfna ] . nb ; } }
>>>Func
METHOD nzklhhaeegrx
METHOD_RETURN int
PARAM char zvjlewhwiojv
PARAM char rgbtgqmcwxax[101]
PARAM char voandxjzlcti[28][2]
PARAM int tablrptsjwoj
RETURN return 0; return 0;
<operator>.lessThan graupcmewsxq<tablrptsjwoj
<operator>.postIncrement graupcmewsxq++
LITERAL 0 return 0;
<operator>.assignment graupcmewsxq=0
bbgdzeeedunh bbgdzeeedunh(zvjlewhwiojv==voandxjzlcti[graupcmewsxq][0])
bbgdzeeedunh bbgdzeeedunh(NULL!=strchr(rgbtgqmcwxax,voandxjzlcti[graupcmewsxq][1]))
<operator>.equals zvjlewhwiojv==voandxjzlcti[graupcmewsxq][0]
RETURN return 1; return 1;
<operator>.notEquals NULL!=strchr(rgbtgqmcwxax,voandxjzlcti[graupcmewsxq][1])
LITERAL 1 return 1;
strchr strchr(rgbtgqmcwxax,voandxjzlcti[graupcmewsxq][1])
UNKNOWN,),)
UNKNOWN,),)
<operator>.indirectIndexAccess voandxjzlcti[graupcmewsxq][0]
<operator>.indirectIndexAccess voandxjzlcti[graupcmewsxq]
<operator>.indirectIndexAccess voandxjzlcti[graupcmewsxq][1]
<operator>.indirectIndexAccess voandxjzlcti[graupcmewsxq]
>>>PDG&24 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->13 0->14 0->15 0->16 0->17 2->13 3->17 4->1 5->7 6->1 7->1 7->1 7->1 7->6 7->11 7->12 7->13 7->14 7->15 7->17 7->18 7->19 7->20 7->21 7->22 7->23 8->1 8->7 9->6 10->1 10->7 11->1 11->1 12->1 12->1 13->1 13->1 13->11 13->11 14->1 15->1 15->1 15->12 15->12 16->14 17->1 17->1 17->15 17->15
>>>Token int nzklhhaeegrx ( char zvjlewhwiojv , char rgbtgqmcwxax [ 101 ] , char voandxjzlcti [ 28 ] [ 2 ] , int tablrptsjwoj ) { int graupcmewsxq ; for ( graupcmewsxq = 0 ; graupcmewsxq < tablrptsjwoj ; graupcmewsxq ++ ) { bbgdzeeedunh ( zvjlewhwiojv == voandxjzlcti [ graupcmewsxq ] [ 0 ] )  { bbgdzeeedunh ( NULL != strchr ( rgbtgqmcwxax , voandxjzlcti [ graupcmewsxq ] [ 1 ] ) )  { return 1 ; } } else bbgdzeeedunh ( zvjlewhwiojv == voandxjzlcti [ graupcmewsxq ] [ 1 ] ) { bbgdzeeedunh ( NULL != strchr ( rgbtgqmcwxax , voandxjzlcti [ graupcmewsxq ] [ 0 ] ) )  { return 1 ; } } } return 0 ; }
>>>Func
METHOD lpgdauxdfugd
METHOD_RETURN T
PARAM T grogyepecylh
RETURN return grogyepecylh<0?-grogyepecylh:grogyepecylh; return grogyepecylh<0?-grogyepecylh:grogyepecylh;
<operator>.conditional grogyepecylh<0?-grogyepecylh:grogyepecylh
<operator>.lessThan grogyepecylh<0
<operator>.minus -grogyepecylh
>>>PDG&7 0->2 0->4 0->5 0->6 2->5 3->1 4->1 4->1 4->1 4->1 4->3 5->4 5->6 5->6 6->4
>>>Token T lpgdauxdfugd ( T grogyepecylh ) { return grogyepecylh < 0 ? - grogyepecylh : grogyepecylh ; }
>>>Func
METHOD qljahtqaykhw
METHOD_RETURN int
PARAM char *team
PARAM int lfuvjoosrvqa
<operator>.assignment tpdifdnxlkue=0
RETURN return tpdifdnxlkue; return tpdifdnxlkue;
<operator>.lessThan kchgijdiafrg<lfuvjoosrvqa
<operator>.postIncrement kchgijdiafrg++
IDENTIFIER tpdifdnxlkue return tpdifdnxlkue;
<operator>.assignment kchgijdiafrg=0
<operator>.equals team[kchgijdiafrg]=='1'
<operator>.postIncrement tpdifdnxlkue++
<operator>.indirectIndexAccess team[kchgijdiafrg]
>>>PDG&13 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 2->1 2->10 3->6 4->1 4->1 4->8 4->11 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->12 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->11 11->1 11->1 11->8
>>>Token int qljahtqaykhw ( char * team , int lfuvjoosrvqa ) { int kchgijdiafrg ; int tpdifdnxlkue = 0 ; for ( kchgijdiafrg = 0 ; kchgijdiafrg < lfuvjoosrvqa ; kchgijdiafrg ++ ) { if ( team [ kchgijdiafrg ] == ' ' ) { tpdifdnxlkue ++ ; } } return tpdifdnxlkue ; }
>>>Func
METHOD ezltioyajzbm
METHOD_RETURN int
PARAM int tbbvqqqecmtp
PARAM int xmeomrvbwuqu
PARAM int yiacnerrpyve
<operator>.assignment nqwtjrjsmwjy=100-xmeomrvbwuqu
<operator>.assignment loseG=100-yiacnerrpyve
<operator>.assignment jfvevodacdzi=euclid(xmeomrvbwuqu)
<operator>.assignment pqwzvbbelnde=100/jfvevodacdzi
<operator>.assignment winD=xmeomrvbwuqu/jfvevodacdzi
RETURN return 0; return 0;
<operator>.logicalAnd xmeomrvbwuqu>0&&yiacnerrpyve==0
<operator>.logicalAnd loseG==0&&nqwtjrjsmwjy>0
<operator>.logicalOr (loseG==0&&nqwtjrjsmwjy==0)||(yiacnerrpyve==0&&xmeomrvbwuqu==0)
<operator>.lessEqualsThan pqwzvbbelnde<=tbbvqqqecmtp
LITERAL 0 return 0;
RETURN return 0; return 0;
<operator>.subtraction 100-xmeomrvbwuqu
<operator>.subtraction 100-yiacnerrpyve
RETURN return 0; return 0;
RETURN return 1; return 1;
euclid euclid(xmeomrvbwuqu)
<operator>.division 100/jfvevodacdzi
<operator>.division xmeomrvbwuqu/jfvevodacdzi
RETURN return 1; return 1;
<operator>.greaterThan xmeomrvbwuqu>0
<operator>.equals yiacnerrpyve==0
LITERAL 0 return 0;
<operator>.equals loseG==0
<operator>.greaterThan nqwtjrjsmwjy>0
LITERAL 0 return 0;
<operator>.logicalAnd loseG==0&&nqwtjrjsmwjy==0
<operator>.logicalAnd yiacnerrpyve==0&&xmeomrvbwuqu==0
LITERAL 1 return 1;
LITERAL 1 return 1;
<operator>.equals loseG==0
<operator>.equals nqwtjrjsmwjy==0
<operator>.equals yiacnerrpyve==0
<operator>.equals xmeomrvbwuqu==0
>>>PDG&39 0->2 0->3 0->4 0->10 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->33 0->34 0->35 0->36 0->37 0->38 2->1 2->14 3->25 4->1 4->18 4->26 5->29 5->36 6->28 7->22 8->14 10->1 11->1 11->1 11->1 11->5 11->6 11->12 11->16 11->17 11->18 11->28 12->13 12->19 12->31 12->35 13->7 13->8 13->9 13->14 13->20 13->21 13->22 13->23 14->10 14->24 15->10 16->1 17->5 17->5 17->21 17->38 18->6 18->6 18->37 19->1 20->1 21->7 21->23 22->8 22->8 22->23 23->9 23->9 24->1 25->1 25->11 25->11 25->17 25->26 26->1 26->11 26->11 26->18 27->16 28->12 28->12 28->29 28->35 29->12 29->12 29->36 30->19 31->13 31->13 31->32 31->37 32->13 32->13 33->20 34->24 35->31 35->31 35->36 36->31 36->31 37->32 37->32 37->38 38->21 38->32 38->32
>>>Token int ezltioyajzbm ( int tbbvqqqecmtp , int xmeomrvbwuqu , int yiacnerrpyve ) { if ( xmeomrvbwuqu > 0 && yiacnerrpyve == 0 ) return 0 ; int nqwtjrjsmwjy = 100 - xmeomrvbwuqu , loseG = 100 - yiacnerrpyve ; if ( loseG == 0 && nqwtjrjsmwjy > 0 ) return 0 ; if ( ( loseG == 0 && nqwtjrjsmwjy == 0 ) || ( yiacnerrpyve == 0 && xmeomrvbwuqu == 0 ) ) return 1 ; int jfvevodacdzi = euclid ( xmeomrvbwuqu ) ; int pqwzvbbelnde = 100 / jfvevodacdzi , winD = xmeomrvbwuqu / jfvevodacdzi ; if ( pqwzvbbelnde <= tbbvqqqecmtp ) return 1 ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf("Enter size of array:\n")
scanf scanf("%d",&pxgaputoshgl)
printf printf("Enter the elements of the array\n")
<operator>.assignment *arr=(int *)malloc(pxgaputoshgl *sizeof(int))
printf printf("Original array: ")
display display(arr,pxgaputoshgl)
cycleSort cycleSort(arr,pxgaputoshgl)
printf printf("Sorted array: ")
display display(arr,pxgaputoshgl)
free free(arr)
RETURN return 0; return 0;
<operator>.lessThan waynxykjagps<pxgaputoshgl
<operator>.postIncrement waynxykjagps++
LITERAL 0 return 0;
<operator>.cast (int *)malloc(pxgaputoshgl *sizeof(int))
<operator>.assignment waynxykjagps=0
scanf scanf("%d",&arr[waynxykjagps])
malloc malloc(pxgaputoshgl *sizeof(int))
<operator>.multiplication pxgaputoshgl *sizeof(int)
<operator>.sizeOf sizeof(int)
<operator>.addressOf &arr[waynxykjagps]
<operator>.indirectIndexAccess arr[waynxykjagps]
>>>PDG&24 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->20 2->1 3->1 3->7 3->8 3->10 3->13 3->20 4->1 5->1 5->1 5->7 5->8 5->10 5->11 5->18 6->1 7->8 7->8 8->1 8->10 8->10 9->1 10->1 10->1 10->11 11->1 12->1 13->1 13->1 13->7 13->13 13->14 13->14 13->18 13->22 13->23 14->1 14->13 15->12 16->1 17->1 17->13 18->1 18->7 18->8 18->10 18->11 19->1 19->5 19->16 20->13 20->19 21->1
>>>Token int main ( ) { int pxgaputoshgl ; printf ( " \n " ) ; scanf ( " " , & pxgaputoshgl ) ; printf ( " \n " ) ; int waynxykjagps ; int * arr = ( int * ) malloc ( pxgaputoshgl * sizeof ( int ) ) ; for ( waynxykjagps = 0 ; waynxykjagps < pxgaputoshgl ; waynxykjagps ++ ) { scanf ( " " , & arr [ waynxykjagps ] ) ; } printf ( " " ) ; display ( arr , pxgaputoshgl ) ; cycleSort ( arr , pxgaputoshgl ) ; printf ( " " ) ; display ( arr , pxgaputoshgl ) ; free ( arr ) ; return 0 ; }
>>>Func
METHOD yhfdczzzepfp
METHOD_RETURN void
PARAM Heap *heap
PARAM int ktkdecakpbfe
<operator>.assignment nanzttftljxg=ktkdecakpbfe *2+1
<operator>.assignment ywzxpkawszyw=ktkdecakpbfe *2+2
<operator>.assignment irndkfqojhli=0
<operator>.assignment rightflag=0
<operator>.assignment wszuxtmupvbe=*((heap->p)+ktkdecakpbfe)
<operator>.greaterEqualsThan ktkdecakpbfe>=heap->count
<operator>.logicalAnd nanzttftljxg<heap->count&&wszuxtmupvbe<*((heap->p)+nanzttftljxg)
<operator>.logicalAnd ywzxpkawszyw<heap->count&&wszuxtmupvbe<*((heap->p)+ywzxpkawszyw)
IDENTIFIER irndkfqojhli if (irndkfqojhli)
IDENTIFIER rightflag if (rightflag)
RETURN return ; return ;
<operator>.addition ktkdecakpbfe *2+1
<operator>.addition ktkdecakpbfe *2+2
<operator>.assignment wszuxtmupvbe=*((heap->p)+nanzttftljxg)
<operator>.assignment irndkfqojhli=1
<operator>.assignment wszuxtmupvbe=*((heap->p)+ywzxpkawszyw)
<operator>.assignment irndkfqojhli=0
<operator>.assignment rightflag=1
<operator>.assignment *((heap->p)+nanzttftljxg)=*((heap->p)+ktkdecakpbfe)
<operator>.assignment *((heap->p)+ktkdecakpbfe)=wszuxtmupvbe
yhfdczzzepfp yhfdczzzepfp(heap,nanzttftljxg)
<operator>.assignment *((heap->p)+ywzxpkawszyw)=*((heap->p)+ktkdecakpbfe)
<operator>.assignment *((heap->p)+ktkdecakpbfe)=wszuxtmupvbe
yhfdczzzepfp yhfdczzzepfp(heap,ywzxpkawszyw)
<operator>.multiplication ktkdecakpbfe *2
<operator>.multiplication ktkdecakpbfe *2
<operator>.addition (heap->p)+ktkdecakpbfe
<operator>.lessThan nanzttftljxg<heap->count
<operator>.lessThan wszuxtmupvbe<*((heap->p)+nanzttftljxg)
<operator>.lessThan ywzxpkawszyw<heap->count
<operator>.lessThan wszuxtmupvbe<*((heap->p)+ywzxpkawszyw)
<operator>.addition (heap->p)+nanzttftljxg
<operator>.addition (heap->p)+nanzttftljxg
<operator>.addition (heap->p)+ywzxpkawszyw
<operator>.addition (heap->p)+ywzxpkawszyw
<operator>.addition (heap->p)+nanzttftljxg
<operator>.addition (heap->p)+ktkdecakpbfe
<operator>.addition (heap->p)+ktkdecakpbfe
<operator>.addition (heap->p)+ywzxpkawszyw
<operator>.addition (heap->p)+ktkdecakpbfe
<operator>.addition (heap->p)+ktkdecakpbfe
<operator>.indirection *((heap->p)+ktkdecakpbfe)
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->count
<operator>.indirection *((heap->p)+nanzttftljxg)
<operator>.indirection *((heap->p)+nanzttftljxg)
<operator>.indirectFieldAccess heap->count
<operator>.indirection *((heap->p)+ywzxpkawszyw)
<operator>.indirection *((heap->p)+ywzxpkawszyw)
<operator>.indirection *((heap->p)+nanzttftljxg)
<operator>.indirection *((heap->p)+ktkdecakpbfe)
<operator>.indirection *((heap->p)+ktkdecakpbfe)
<operator>.indirection *((heap->p)+ywzxpkawszyw)
<operator>.indirection *((heap->p)+ktkdecakpbfe)
<operator>.indirection *((heap->p)+ktkdecakpbfe)
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER count count
FIELD_IDENTIFIER count count
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
>>>PDG&82 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->12 0->13 0->14 0->15 0->16 0->18 0->20 0->21 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 2->1 2->24 2->27 3->9 4->31 5->33 8->23 8->26 8->32 8->34 9->1 9->1 9->1 9->4 9->5 9->6 9->7 9->8 9->10 9->11 9->14 9->15 9->16 9->22 9->23 9->24 9->25 9->26 9->27 9->28 9->28 9->29 9->30 9->31 9->31 9->33 9->39 9->40 9->41 9->42 9->43 9->44 9->45 9->46 9->47 9->50 9->53 9->54 9->55 9->56 9->57 9->58 9->59 9->60 9->61 9->66 9->67 9->68 9->69 9->70 9->71 9->76 9->77 9->78 9->79 9->80 9->81 10->17 10->18 10->36 10->49 10->63 10->73 11->19 11->20 11->21 11->38 11->52 11->65 11->75 14->1 17->23 17->26 17->34 19->23 19->26 24->27 28->4 28->4 28->15 28->15 28->29 29->5 29->5 29->16 29->16 29->30 29->40 29->41 29->43 29->44 31->10 31->10 31->24 31->32 31->33 31->35 31->35 31->36 31->39 31->48 31->62 31->72 32->10 32->10 32->23 32->26 32->34 33->11 33->11 33->27 33->34 33->37 33->37 33->38 33->42 33->51 33->64 33->74 34->11 34->11 34->23 34->26
>>>Token void yhfdczzzepfp ( Heap * heap , int ktkdecakpbfe ) { if ( ktkdecakpbfe >= heap -> count ) return ; int nanzttftljxg = ktkdecakpbfe * 2 + 1 ; int ywzxpkawszyw = ktkdecakpbfe * 2 + 2 ; int irndkfqojhli = 0 , rightflag = 0 ; int wszuxtmupvbe = * ( ( heap -> p ) + ktkdecakpbfe ) ; if ( nanzttftljxg < heap -> count && wszuxtmupvbe < * ( ( heap -> p ) + nanzttftljxg ) ) { wszuxtmupvbe = * ( ( heap -> p ) + nanzttftljxg ) ; irndkfqojhli = 1 ; } if ( ywzxpkawszyw < heap -> count && wszuxtmupvbe < * ( ( heap -> p ) + ywzxpkawszyw ) ) { wszuxtmupvbe = * ( ( heap -> p ) + ywzxpkawszyw ) ; irndkfqojhli = 0 ; rightflag = 1 ; } if ( irndkfqojhli ) { * ( ( heap -> p ) + nanzttftljxg ) = * ( ( heap -> p ) + ktkdecakpbfe ) ; * ( ( heap -> p ) + ktkdecakpbfe ) = wszuxtmupvbe ; yhfdczzzepfp ( heap , nanzttftljxg ) ; } if ( rightflag ) { * ( ( heap -> p ) + ywzxpkawszyw ) = * ( ( heap -> p ) + ktkdecakpbfe ) ; * ( ( heap -> p ) + ktkdecakpbfe ) = wszuxtmupvbe ; yhfdczzzepfp ( heap , ywzxpkawszyw ) ; } }
>>>Func
METHOD uzdezhogngxy
METHOD_RETURN int
PARAM char azsyovoxgbmy
RETURN return 0; return 0;
<operator>.notEquals set[bpmagozsogjf]!='\0'
<operator>.postIncrement bpmagozsogjf++
LITERAL 0 return 0;
<operator>.assignment bpmagozsogjf=0
<operator>.lessThan j<d
<operator>.postIncrement j++
<operator>.assignment j=0
<operator>.logicalOr (set[bpmagozsogjf]==diss[j][0]&&azsyovoxgbmy==diss[j][1])||(set[bpmagozsogjf]==diss[j][1]&&azsyovoxgbmy==diss[j][0])
<operator>.assignment set[0]='\0'
RETURN return 1; return 1;
<operator>.logicalAnd set[bpmagozsogjf]==diss[j][0]&&azsyovoxgbmy==diss[j][1]
<operator>.logicalAnd set[bpmagozsogjf]==diss[j][1]&&azsyovoxgbmy==diss[j][0]
LITERAL 1 return 1;
<operator>.equals set[bpmagozsogjf]==diss[j][0]
<operator>.equals azsyovoxgbmy==diss[j][1]
<operator>.equals set[bpmagozsogjf]==diss[j][1]
<operator>.equals azsyovoxgbmy==diss[j][0]
<operator>.indirectIndexAccess set[bpmagozsogjf]
<operator>.indirectIndexAccess set[0]
<operator>.indirectIndexAccess set[bpmagozsogjf]
<operator>.indirectIndexAccess diss[j][0]
<operator>.indirectIndexAccess diss[j][1]
<operator>.indirectIndexAccess set[bpmagozsogjf]
<operator>.indirectIndexAccess diss[j][1]
<operator>.indirectIndexAccess diss[j][0]
<operator>.indirectIndexAccess diss[j]
<operator>.indirectIndexAccess diss[j]
<operator>.indirectIndexAccess diss[j]
<operator>.indirectIndexAccess diss[j]
>>>PDG&33 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->16 0->18 0->20 2->1 2->18 2->20 3->1 4->1 4->3 4->8 4->10 4->17 5->1 5->1 6->3 7->1 7->1 7->5 8->1 8->1 8->1 8->4 8->5 8->9 8->11 8->14 8->17 8->21 8->23 8->24 8->29 9->1 9->8 10->1 10->8 11->1 11->1 11->1 11->8 11->9 11->12 11->13 11->22 12->1 12->1 13->1 14->1 14->1 14->11 14->11 14->15 14->19 14->26 14->27 14->31 15->1 15->1 15->11 15->11 16->13 17->1 17->1 17->4 17->14 17->14 17->18 17->19 17->20 17->25 17->30 18->1 18->1 18->14 18->14 18->19 18->20 19->1 19->1 19->4 19->15 19->15 19->17 19->18 19->20 19->28 19->32 20->1 20->1 20->15 20->15 20->17 20->18
>>>Token int uzdezhogngxy ( char azsyovoxgbmy ) { int bpmagozsogjf , j ; for ( bpmagozsogjf = 0 ; set [ bpmagozsogjf ] != ' \0 ' ; bpmagozsogjf ++ ) { for ( j = 0 ; j < d ; j ++ ) if ( ( set [ bpmagozsogjf ] == diss [ j ] [ 0 ] && azsyovoxgbmy == diss [ j ] [ 1 ] ) || ( set [ bpmagozsogjf ] == diss [ j ] [ 1 ] && azsyovoxgbmy == diss [ j ] [ 0 ] ) ) { set [ 0 ] = ' \0 ' ; return 1 ; } } return 0 ; }
>>>Func
METHOD vxfapsppfhzg
METHOD_RETURN int
PARAM const dnqzhjjhhtrg*head
RETURN return (head->next==head); return (head->next==head);
<operator>.equals head->next==head
>>>PDG&5 0->2 0->4 2->4 3->1 4->1 4->1 4->1 4->3
>>>Token int vxfapsppfhzg ( const dnqzhjjhhtrg * head ) { return ( head -> next == head ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int wiatrnlsyvjt
PARAM char *argv [ ]
ParseInput ParseInput(argv[1])
<operator>.notEquals 2!=wiatrnlsyvjt
printf printf("Program expects input file as argument.\n")
RETURN return 0; return 0;
LITERAL 0 return 0;
<operator>.indirectIndexAccess argv[1]
>>>PDG&10 0->2 0->3 0->5 0->6 0->7 0->8 2->5 3->1 3->4 5->1 5->1 5->4 5->6 5->7 5->9 6->1 7->1 8->7
>>>Token int main ( int wiatrnlsyvjt , char * argv [ ] ) { if ( 2 != wiatrnlsyvjt ) { printf ( " \n " ) ; return 0 ; } ParseInput ( argv [ 1 ] ) ; }
>>>Func
METHOD nshgzerutzch
METHOD_RETURN void
PARAM int *numbers
PARAM int gcrowzglcteq
<operator>.assignment fnipofkhoeqc=gcrowzglcteq
<operator>.greaterThan fnipofkhoeqc>1
<operator>.assignment fnipofkhoeqc=fnipofkhoeqc/SHRINK
<operator>.assignment ymhzkroqlgqf=0
<operator>.lessThan (ymhzkroqlgqf+fnipofkhoeqc)<gcrowzglcteq
<operator>.division fnipofkhoeqc/SHRINK
<operator>.postIncrement ymhzkroqlgqf++
<operator>.addition ymhzkroqlgqf+fnipofkhoeqc
<operator>.greaterThan numbers[ymhzkroqlgqf]>numbers[ymhzkroqlgqf+fnipofkhoeqc]
<operator>.assignment sqqyailfpqdi=numbers[ymhzkroqlgqf]
<operator>.assignment numbers[ymhzkroqlgqf]=numbers[ymhzkroqlgqf+fnipofkhoeqc]
<operator>.assignment numbers[ymhzkroqlgqf+fnipofkhoeqc]=sqqyailfpqdi
<operator>.addition ymhzkroqlgqf+fnipofkhoeqc
<operator>.addition ymhzkroqlgqf+fnipofkhoeqc
<operator>.addition ymhzkroqlgqf+fnipofkhoeqc
<operator>.indirectIndexAccess numbers[ymhzkroqlgqf]
<operator>.indirectIndexAccess numbers[ymhzkroqlgqf+fnipofkhoeqc]
<operator>.indirectIndexAccess numbers[ymhzkroqlgqf]
<operator>.indirectIndexAccess numbers[ymhzkroqlgqf]
<operator>.indirectIndexAccess numbers[ymhzkroqlgqf+fnipofkhoeqc]
<operator>.indirectIndexAccess numbers[ymhzkroqlgqf+fnipofkhoeqc]
>>>PDG&25 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->15 0->16 0->17 0->18 2->1 2->12 2->13 2->14 3->4 3->8 4->1 4->1 4->5 5->1 5->1 5->5 5->6 5->7 5->8 5->9 5->9 5->11 6->5 6->8 6->11 7->8 7->10 7->11 7->16 7->17 7->18 8->1 8->1 8->1 8->8 8->10 8->11 8->12 8->16 8->19 8->20 9->1 9->6 9->6 10->8 10->11 10->16 10->17 10->18 12->13 12->13 12->14 12->14 12->15 12->17 12->18 12->21 12->22 12->23 12->24 13->15 14->12 15->12
>>>Token void nshgzerutzch ( int * numbers , int gcrowzglcteq ) { int fnipofkhoeqc = gcrowzglcteq ; while ( fnipofkhoeqc > 1 ) { fnipofkhoeqc = fnipofkhoeqc / SHRINK ; int ymhzkroqlgqf = 0 ; while ( ( ymhzkroqlgqf + fnipofkhoeqc ) < gcrowzglcteq ) { if ( numbers [ ymhzkroqlgqf ] > numbers [ ymhzkroqlgqf + fnipofkhoeqc ] ) { int sqqyailfpqdi = numbers [ ymhzkroqlgqf ] ; numbers [ ymhzkroqlgqf ] = numbers [ ymhzkroqlgqf + fnipofkhoeqc ] ; numbers [ ymhzkroqlgqf + fnipofkhoeqc ] = sqqyailfpqdi ; } ymhzkroqlgqf ++ ; } } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment *fp=fopen("input.txt","r")
<operator>.assignment *ft=fopen("output.txt","w")
fscanf fscanf(fp,"%d",&test)
RETURN return 0; return 0;
<operator>.lessEqualsThan izqgiidxtlhn<=test
<operator>.postIncrement izqgiidxtlhn++
LITERAL 0 return 0;
fopen fopen("input.txt","r")
fopen fopen("output.txt","w")
<operator>.assignment izqgiidxtlhn=1
fscanf fscanf(fp,"%d",&c)
fscanf fscanf(fp,"%d",&d)
fscanf fscanf(fp,"%d",&n)
fscanf fscanf(fp,"%s",str)
<operator>.assignment dots=0
<operator>.assignment commas=n-dots-1
fprintf fprintf(ft,"Case #%d: [",izqgiidxtlhn)
fprintf fprintf(ft,"]\n")
<operator>.lessThan j<2627
<operator>.postIncrement j++
<operator>.lessThan j<c
<operator>.postIncrement j++
<operator>.lessThan j<d
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.assignment j=11
<operator>.assignment hash_com[j]=0
<operator>.assignment hash_opp[j]=0
<operator>.assignment j=0
fscanf fscanf(fp,"%s",str)
<operator>.assignment index=((str[0]-'A'+1)*10)+(str[1]-'A'+1)
<operator>.assignment hash_com[index]=(str[2]-'A'+1)
<operator>.assignment index=((str[1]-'A'+1)*10)+(str[0]-'A'+1)
<operator>.assignment hash_com[index]=(str[2]-'A'+1)
<operator>.assignment j=0
fscanf fscanf(fp,"%s",str)
<operator>.assignment index=((str[0]-'A'+1)*10)+(str[1]-'A'+1)
<operator>.assignment hash_opp[index]=1
<operator>.assignment index=((str[1]-'A'+1)*10)+(str[0]-'A'+1)
<operator>.assignment hash_opp[index]=1
<operator>.assignment j=1
combine combine(j)
opposed opposed(j)
<operator>.assignment j=0
<operator>.subtraction n-dots-1
<operator>.assignment j=0
fprintf fprintf(ft,"%c",str[j])
<operator>.equals str[j]=='.'
<operator>.subtraction n-dots
<operator>.equals str[j]=='.'
IDENTIFIER commas if (commas)
<operator>.addition ((str[0]-'A'+1)*10)+(str[1]-'A'+1)
<operator>.addition str[2]-'A'+1
<operator>.addition ((str[1]-'A'+1)*10)+(str[0]-'A'+1)
<operator>.addition str[2]-'A'+1
<operator>.addition ((str[0]-'A'+1)*10)+(str[1]-'A'+1)
<operator>.addition ((str[1]-'A'+1)*10)+(str[0]-'A'+1)
<operator>.postIncrement dots++
<operator>.postDecrement dots--
fprintf fprintf(ft,", ")
<operator>.postDecrement commas--
<operator>.multiplication (str[0]-'A'+1)*10
<operator>.addition str[1]-'A'+1
<operator>.subtraction str[2]-'A'
<operator>.multiplication (str[1]-'A'+1)*10
<operator>.addition str[0]-'A'+1
<operator>.subtraction str[2]-'A'
<operator>.multiplication (str[0]-'A'+1)*10
<operator>.addition str[1]-'A'+1
<operator>.multiplication (str[1]-'A'+1)*10
<operator>.addition str[0]-'A'+1
<operator>.addition str[0]-'A'+1
<operator>.subtraction str[1]-'A'
<operator>.addition str[1]-'A'+1
<operator>.subtraction str[0]-'A'
<operator>.addition str[0]-'A'+1
<operator>.subtraction str[1]-'A'
<operator>.addition str[1]-'A'+1
<operator>.subtraction str[0]-'A'
<operator>.subtraction str[0]-'A'
<operator>.subtraction str[1]-'A'
<operator>.subtraction str[0]-'A'
<operator>.subtraction str[1]-'A'
<operator>.addressOf &c
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.indirectIndexAccess hash_com[j]
<operator>.indirectIndexAccess hash_opp[j]
<operator>.indirectIndexAccess hash_com[index]
<operator>.indirectIndexAccess hash_com[index]
<operator>.indirectIndexAccess hash_opp[index]
<operator>.indirectIndexAccess hash_opp[index]
<operator>.indirectIndexAccess str[j]
<operator>.indirectIndexAccess str[j]
<operator>.indirectIndexAccess str[j]
<operator>.indirectIndexAccess str[2]
<operator>.indirectIndexAccess str[2]
<operator>.indirectIndexAccess str[1]
<operator>.indirectIndexAccess str[0]
<operator>.indirectIndexAccess str[1]
<operator>.indirectIndexAccess str[0]
<operator>.indirectIndexAccess str[0]
<operator>.indirectIndexAccess str[1]
<operator>.indirectIndexAccess str[0]
<operator>.indirectIndexAccess str[1]
>>>PDG&112 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 2->1 2->1 2->4 3->1 3->1 3->1 3->18 4->1 4->1 4->1 4->6 4->12 5->1 6->1 6->1 6->1 6->6 6->7 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->18 6->19 6->20 6->22 6->24 6->26 6->28 6->30 6->32 6->35 6->41 6->47 6->50 6->51 6->52 6->55 6->90 6->91 6->92 7->1 7->6 8->5 9->2 9->2 10->3 10->3 11->1 11->6 12->1 12->1 12->13 12->22 12->36 13->1 13->1 13->14 13->24 13->42 14->1 14->1 14->15 14->26 14->28 14->30 14->55 15->1 15->1 15->1 15->12 15->36 15->42 15->53 15->54 15->56 16->1 16->55 16->64 17->1 17->1 17->1 17->67 18->1 18->7 18->19 18->53 19->1 19->1 19->18 20->1 20->20 20->21 20->21 20->33 20->34 20->93 20->94 21->1 21->20 22->1 22->1 22->12 22->22 22->23 22->23 22->36 22->37 22->38 22->39 22->40 22->58 22->59 22->60 22->61 22->68 22->69 22->70 22->71 22->72 22->73 22->78 22->79 22->80 22->81 22->86 22->87 22->95 22->96 22->102 22->103 22->104 22->105 22->108 22->109 23->1 23->22 24->1 24->1 24->13 24->24 24->25 24->25 24->42 24->43 24->44 24->45 24->46 24->62 24->63 24->74 24->75 24->76 24->77 24->82 24->83 24->84 24->85 24->88 24->89 24->97 24->98 24->106 24->107 24->110 24->111 25->1 25->24 26->26 26->27 26->28 26->48 26->48 26->49 27->1 27->26 28->28 28->29 28->29 28->54 28->55 28->100 29->1 29->28 30->1 30->1 30->1 30->14 30->26 30->30 30->31 30->31 30->56 30->101 31->1 31->30 32->1 32->20 33->1 33->1 34->1 34->1 35->22 36->13 36->15 36->42 36->70 36->73 36->79 36->81 36->86 36->87 37->1 37->1 39->1 39->1 39->1 40->1 40->1 40->1 41->24 42->14 42->15 42->83 42->85 42->88 42->89 43->1 43->1 45->1 45->1 45->1 46->1 46->1 47->1 47->26 48->1 48->49 49->1 49->27 50->28 51->1 51->17 51->17 52->1 52->30 53->1 53->1 53->15 53->19 53->36 53->42 53->54 53->56 53->66 54->1 54->1 54->15 54->36 54->42 54->56 54->64 55->1 55->30 55->51 55->51 55->65 56->1 56->1 56->15 56->36 56->42 56->53 56->53 56->54 56->65 56->66 56->67 56->99 58->1 60->1 60->1 61->1 62->1 63->1 63->1 64->1 64->55 65->1 65->1 66->1 66->19 66->53 67->1 67->1 68->37 68->37 68->58 68->58 70->38 70->38 70->59 70->59 70->73 71->1 71->39 71->39 71->60 71->60 72->1 73->1 73->15 73->36 73->40 73->40 73->42 73->61 73->61 73->70 74->43 74->43 74->62 74->62 76->1 76->45 76->45 76->63 76->63 77->1 79->37 79->37 79->58 79->58 79->69 79->69 79->87 80->1 81->1 81->15 81->36 81->39 81->39 81->42 81->60 81->60 81->72 81->72 81->86 81->88 83->43 83->43 83->62 83->62 83->75 83->75 83->89 84->1 85->1 85->15 85->36 85->42 85->45 85->45 85->63 85->63 85->77 85->77 85->86 85->88 86->68 86->68 86->78 86->78 86->81 87->1 87->15 87->36 87->42 87->71 87->71 87->79 87->80 87->80 87->83 88->74 88->74 88->82 88->82 88->85 89->1 89->15 89->36 89->42 89->76 89->76 89->79 89->83 89->84 89->84
>>>Token int main ( ) { int izqgiidxtlhn , j , test , c , d , n , index , dots , commas ; FILE * fp = fopen ( " " , " " ) ; FILE * ft = fopen ( " " , " " ) ; fscanf ( fp , " " , & test ) ; for ( izqgiidxtlhn = 1 ; izqgiidxtlhn <= test ; izqgiidxtlhn ++ ) { for ( j = 11 ; j < 2627 ; j ++ ) { hash_com [ j ] = 0 ; hash_opp [ j ] = 0 ; } fscanf ( fp , " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) { fscanf ( fp , " " , str ) ; index = ( ( str [ 0 ] - ' ' + 1 ) * 10 ) + ( str [ 1 ] - ' ' + 1 ) ; hash_com [ index ] = ( str [ 2 ] - ' ' + 1 ) ; index = ( ( str [ 1 ] - ' ' + 1 ) * 10 ) + ( str [ 0 ] - ' ' + 1 ) ; hash_com [ index ] = ( str [ 2 ] - ' ' + 1 ) ; } fscanf ( fp , " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) { fscanf ( fp , " " , str ) ; index = ( ( str [ 0 ] - ' ' + 1 ) * 10 ) + ( str [ 1 ] - ' ' + 1 ) ; hash_opp [ index ] = 1 ; index = ( ( str [ 1 ] - ' ' + 1 ) * 10 ) + ( str [ 0 ] - ' ' + 1 ) ; hash_opp [ index ] = 1 ; } fscanf ( fp , " " , & n ) ; fscanf ( fp , " " , str ) ; for ( j = 1 ; j < n ; j ++ ) { combine ( j ) ; opposed ( j ) ; } dots = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( str [ j ] == ' ' ) dots ++ ; } commas = n - dots - 1 ; fprintf ( ft , " " , izqgiidxtlhn ) ; for ( j = 0 ; j < n ; j ++ ) { if ( str [ j ] == ' ' ) { dots -- ; continue ; } fprintf ( ft , " " , str [ j ] ) ; if ( commas ) { fprintf ( ft , " " ) ; commas -- ; } } fprintf ( ft , " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
freopen freopen("input.txt","r",stdin)
freopen freopen("output.txt","w",stdout)
scanf scanf("%d ",&ljvmcppwtjbu)
RETURN return 0; return 0;
<operator>.lessThan mnjkyojajxoc<ljvmcppwtjbu
<operator>.postIncrement mnjkyojajxoc++
LITERAL 0 return 0;
<operator>.assignment mnjkyojajxoc=0
printf printf("Case #%d:\n",mnjkyojajxoc+1)
handleCase handleCase()
<operator>.addition mnjkyojajxoc+1
>>>PDG&13 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 2->1 3->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->10 6->11 6->12 6->12 7->1 7->6 8->5 9->1 9->6 10->1 10->1 11->1
>>>Token int main ( ) { freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; int ljvmcppwtjbu ; scanf ( " " , & ljvmcppwtjbu ) ; int mnjkyojajxoc ; for ( mnjkyojajxoc = 0 ; mnjkyojajxoc < ljvmcppwtjbu ; mnjkyojajxoc ++ ) { printf ( " \n " , mnjkyojajxoc + 1 ) ; handleCase ( ) ; } return 0 ; }
>>>Func
METHOD fcvhaldqtizs
METHOD_RETURN void
<operator>.assignment bt=0
<operator>.lessThan owwuwdemcrpt<len
<operator>.postIncrement owwuwdemcrpt++
IDENTIFIER bt if (bt)
<operator>.assignment owwuwdemcrpt=0
<operator>.assignment len=0
<operator>.lessThan j<len
<operator>.postIncrement j++
IDENTIFIER bt if (bt)
<operator>.assignment j=owwuwdemcrpt+1
<operator>.assignment bt=1
<operator>.addition owwuwdemcrpt+1
<operator>.subtraction out[j]-'A'
<operator>.subtraction out[owwuwdemcrpt]-'A'
<operator>.indirectIndexAccess D[out[owwuwdemcrpt]-'A'][out[j]-'A']
<operator>.indirectIndexAccess D[out[owwuwdemcrpt]-'A']
<operator>.indirectIndexAccess out[j]
<operator>.indirectIndexAccess out[owwuwdemcrpt]
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->1 2->1 3->1 3->1 3->3 3->4 3->4 3->8 3->8 3->11 3->11 3->13 3->13 4->1 4->3 6->1 6->3 7->1 7->1 8->1 8->1 8->3 8->9 8->14 8->15 8->16 8->17 8->18 8->19 9->1 9->8 11->1 11->1 11->8 12->1 12->1 13->1 14->1 15->1 16->8 16->9 16->12
>>>Token void fcvhaldqtizs ( ) { int owwuwdemcrpt , j , bt ; bt = 0 ; for ( owwuwdemcrpt = 0 ; owwuwdemcrpt < len ; owwuwdemcrpt ++ ) { for ( j = owwuwdemcrpt + 1 ; j < len ; j ++ ) if ( D [ out [ owwuwdemcrpt ] - ' ' ] [ out [ j ] - ' ' ] ) { bt = 1 ; break ; } if ( bt ) break ; } if ( bt ) len = 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
scanf scanf("%d",&ubmvkmhtaahb)
<operator>.assignment tqomtrcslqhg=0
RETURN return 0; return 0;
<operator>.postDecrement ubmvkmhtaahb--
LITERAL 0 return 0;
scanf scanf("%d",&pbcyvmrmuroi)
scanf scanf("%d",&d)
scanf scanf("%d",&n)
scanf scanf("%s",vxqhigvvcnls)
memset memset(dfqdmjjpkxod 0 sizeof(dfqdmjjpkxod))
<operator>.assignment count=0
printf printf("Case #%d: [",++tqomtrcslqhg)
kxkaihokmluf kxkaihokmluf(count>0)
printf printf("%c",ntqdabeftckr[0])
printf printf("]\n")
<operator>.lessThan garmqxwpywcp<pbcyvmrmuroi
<operator>.preIncrement ++garmqxwpywcp
scanf scanf("%s",snjqgximrfqs[garmqxwpywcp])
<operator>.lessThan garmqxwpywcp<d
<operator>.preIncrement ++garmqxwpywcp
scanf scanf("%s",rslkioibaqgx[garmqxwpywcp])
<operator>.lessThan garmqxwpywcp<n
<operator>.preIncrement ++garmqxwpywcp
<operator>.lessThan garmqxwpywcp<count
<operator>.preIncrement ++garmqxwpywcp
printf printf(", %c",ntqdabeftckr[garmqxwpywcp])
<operator>.assignment garmqxwpywcp=0
<operator>.assignment garmqxwpywcp=0
<operator>.assignment garmqxwpywcp=0
kxkaihokmluf kxkaihokmluf(count==0)
BLOCK <empty> <empty>
<operator>.preIncrement ++tqomtrcslqhg
<operator>.greaterThan count>0
<operator>.assignment garmqxwpywcp=1
<operator>.assignment ntqdabeftckr[count++]=vxqhigvvcnls[garmqxwpywcp]
<operator>.assignmentPlus dfqdmjjpkxod[vxqhigvvcnls[garmqxwpywcp]]+=1
<operator>.equals count==0
<operator>.postIncrement count++
UNKNOWN,),)
<operator>.addressOf &pbcyvmrmuroi
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.sizeOf sizeof(dfqdmjjpkxod)
<operator>.indirectIndexAccess ntqdabeftckr[0]
<operator>.indirectIndexAccess snjqgximrfqs[garmqxwpywcp]
<operator>.indirectIndexAccess rslkioibaqgx[garmqxwpywcp]
UNKNOWN,),)
UNKNOWN else   kxkaihokmluf ((nxemkgfmxppo=find(snjqgximrfqs,pbcyvmrmuroi,ntqdabeftckr[count-1],vxqhigvvcnls[garmqxwpywcp]))!=0){dfqdmjjpkxod[ntqdabeftckr[count-1]]-=1;ntqdabeftckr[count-1]=nxemkgfmxppo;dfqdmjjpkxod[nxemkgfmxppo]+=1;} else   kxkaihokmluf ((nxemkgfmxppo=find(snjqgximrfqs,pbcyvmrmuroi,ntqdabeftckr[count-1],vxqhigvvcnls[garmqxwpywcp]))!=0){dfqdmjjpkxod[ntqdabeftckr[count-1]]-=1;ntqdabeftckr[count-1]=nxemkgfmxppo;dfqdmjjpkxod[nxemkgfmxppo]+=1;}
UNKNOWN else  {for(j=0;j<d;++j){kxkaihokmluf((rslkioibaqgx[j][0]==vxqhigvvcnls[garmqxwpywcp]&&dfqdmjjpkxod[rslkioibaqgx[j][1]])||(rslkioibaqgx[j][1]==vxqhigvvcnls[garmqxwpywcp]&&dfqdmjjpkxod[rslkioibaqgx[j][0]]))break;}kxkaihokmluf(j!=d){memset(dfqdmjjpkxod 0 sizeof(dfqdmjjpkxod));count=0;}else  {ntqdabeftckr[count++]=vxqhigvvcnls[garmqxwpywcp];dfqdmjjpkxod[vxqhigvvcnls[garmqxwpywcp]]+=1;}} else  {for(j=0;j<d;++j){kxkaihokmluf((rslkioibaqgx[j][0]==vxqhigvvcnls[garmqxwpywcp]&&dfqdmjjpkxod[rslkioibaqgx[j][1]])||(rslkioibaqgx[j][1]==vxqhigvvcnls[garmqxwpywcp]&&dfqdmjjpkxod[rslkioibaqgx[j][0]]))break;}kxkaihokmluf(j!=d){memset(dfqdmjjpkxod 0 sizeof(dfqdmjjpkxod));count=0;}else  {ntqdabeftckr[count++]=vxqhigvvcnls[garmqxwpywcp];dfqdmjjpkxod[vxqhigvvcnls[garmqxwpywcp]]+=1;}}
<operator>.indirectIndexAccess ntqdabeftckr[garmqxwpywcp]
<operator>.indirectIndexAccess ntqdabeftckr[count++]
<operator>.indirectIndexAccess vxqhigvvcnls[garmqxwpywcp]
<operator>.indirectIndexAccess dfqdmjjpkxod[vxqhigvvcnls[garmqxwpywcp]]
<operator>.indirectIndexAccess vxqhigvvcnls[garmqxwpywcp]
>>>PDG&57 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->34 0->35 0->36 0->38 0->39 0->40 2->1 3->1 3->6 4->1 4->1 4->34 5->1 6->1 6->1 6->6 6->8 6->9 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->21 6->24 6->26 6->29 6->30 6->31 6->34 6->35 6->36 6->41 6->42 6->43 6->44 6->45 6->46 7->5 8->1 8->18 9->1 9->21 10->1 10->24 11->1 11->37 12->1 12->1 12->38 13->1 13->35 13->39 14->1 14->1 15->1 15->1 16->1 16->1 17->1 18->1 18->1 18->8 18->18 18->19 18->19 18->20 18->47 19->1 19->18 20->1 21->1 21->1 21->9 21->21 21->22 21->22 21->23 21->48 22->1 22->21 23->1 24->1 24->1 24->10 24->24 24->25 24->25 24->32 24->37 24->38 24->39 24->40 24->49 24->50 24->51 24->53 24->54 24->55 24->56 25->1 25->24 26->1 26->1 26->1 26->26 26->27 26->27 26->28 26->52 27->1 27->26 28->1 28->1 29->18 30->21 31->1 31->24 32->1 32->1 34->1 34->14 35->15 35->15 35->26 36->1 36->26 37->1 37->1 37->1 38->1 38->1 38->12 39->32 39->32 39->40 40->35 40->39
>>>Token int main ( void ) { int ubmvkmhtaahb ; int tqomtrcslqhg ; int nxemkgfmxppo ; int pbcyvmrmuroi , d , n , count ; char snjqgximrfqs [ 50 ] [ 5 ] ; char rslkioibaqgx [ 50 ] [ 5 ] ; char vxqhigvvcnls [ 200 ] ; char ntqdabeftckr [ 200 ] ; int dfqdmjjpkxod [ 256 ] ; int garmqxwpywcp , j ; scanf ( " " , & ubmvkmhtaahb ) ; tqomtrcslqhg = 0 ; while ( ubmvkmhtaahb -- ) { scanf ( " " , & pbcyvmrmuroi ) ; for ( garmqxwpywcp = 0 ; garmqxwpywcp < pbcyvmrmuroi ; ++ garmqxwpywcp ) scanf ( " " , snjqgximrfqs [ garmqxwpywcp ] ) ; scanf ( " " , & d ) ; for ( garmqxwpywcp = 0 ; garmqxwpywcp < d ; ++ garmqxwpywcp ) scanf ( " " , rslkioibaqgx [ garmqxwpywcp ] ) ; scanf ( " " , & n ) ; scanf ( " " , vxqhigvvcnls ) ; memset ( dfqdmjjpkxod , 0 , sizeof ( dfqdmjjpkxod ) ) ; count = 0 ; for ( garmqxwpywcp = 0 ; garmqxwpywcp < n ; ++ garmqxwpywcp ) { kxkaihokmluf ( count == 0 )  { ntqdabeftckr [ count ++ ] = vxqhigvvcnls [ garmqxwpywcp ] ; dfqdmjjpkxod [ vxqhigvvcnls [ garmqxwpywcp ] ] += 1 ; } else kxkaihokmluf ( ( nxemkgfmxppo = find ( snjqgximrfqs , pbcyvmrmuroi , ntqdabeftckr [ count - 1 ] , vxqhigvvcnls [ garmqxwpywcp ] ) ) != 0 ) { dfqdmjjpkxod [ ntqdabeftckr [ count - 1 ] ] -= 1 ; ntqdabeftckr [ count - 1 ] = nxemkgfmxppo ; dfqdmjjpkxod [ nxemkgfmxppo ] += 1 ; } else  { for ( j = 0 ; j < d ; ++ j ) { kxkaihokmluf ( ( rslkioibaqgx [ j ] [ 0 ] == vxqhigvvcnls [ garmqxwpywcp ] && dfqdmjjpkxod [ rslkioibaqgx [ j ] [ 1 ] ] ) || ( rslkioibaqgx [ j ] [ 1 ] == vxqhigvvcnls [ garmqxwpywcp ] && dfqdmjjpkxod [ rslkioibaqgx [ j ] [ 0 ] ] ) ) break ; } kxkaihokmluf ( j != d )  { memset ( dfqdmjjpkxod , 0 , sizeof ( dfqdmjjpkxod ) ) ; count = 0 ; } else { ntqdabeftckr [ count ++ ] = vxqhigvvcnls [ garmqxwpywcp ] ; dfqdmjjpkxod [ vxqhigvvcnls [ garmqxwpywcp ] ] += 1 ; } } } printf ( " " , ++ tqomtrcslqhg ) ; kxkaihokmluf ( count > 0 )  printf ( " " , ntqdabeftckr [ 0 ] ) ; for ( garmqxwpywcp = 1 ; garmqxwpywcp < count ; ++ garmqxwpywcp ) printf ( " " , ntqdabeftckr [ garmqxwpywcp ] ) ; printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment ii=0
<operator>.assignment input=fopen("A-small-attempt0.in","r")
<operator>.assignment output=fopen("test.out","w+")
fscanf fscanf(input," %d\n",&qnldjpgkoqer)
fclose fclose(input)
fclose fclose(output)
RETURN return 0; return 0;
<operator>.lessThan ii++<qnldjpgkoqer
LITERAL 0 return 0;
fopen fopen("A-small-attempt0.in","r")
fopen fopen("test.out","w+")
<operator>.assignment ddttctzczjln[100][100]={0}
<operator>.assignment obmymzqlncly[100]={0}
<operator>.assignment khqeptmfvvjp[100]={0}
<operator>.assignment oldxpjzkemvo[100]={0}
<operator>.assignment ywjwntvvurcs[100]={0}
<operator>.assignment vlwehuduynfb[100]={0}
fscanf fscanf(input," %d",&ecpcleiuvcyu)
fprintf fprintf(output,"Case #%d:\n",ii)
<operator>.postIncrement ii++
<operator>.lessThan i<ecpcleiuvcyu
<operator>.postIncrement i++
<operator>.lessThan i<ecpcleiuvcyu
<operator>.postIncrement i++
<operator>.lessThan i<ecpcleiuvcyu
<operator>.postIncrement i++
<operator>.lessThan i<ecpcleiuvcyu
<operator>.postIncrement i++
<operator>.arrayInitializer {0}
<operator>.arrayInitializer {0}
<operator>.arrayInitializer {0}
<operator>.arrayInitializer {0}
<operator>.arrayInitializer {0}
<operator>.arrayInitializer {0}
<operator>.assignment i=0
fscanf fscanf(input,"\n")
<operator>.assignment obmymzqlncly[i]=ywjwntvvurcs[i]/(ywjwntvvurcs[i]+vlwehuduynfb[i])
<operator>.assignment i=0
<operator>.assignment rfrocteuftgz=0
<operator>.assignment wpTotal=0
<operator>.assignment khqeptmfvvjp[i]=wpTotal/rfrocteuftgz
<operator>.assignment i=0
<operator>.assignment rfrocteuftgz=0
<operator>.assignment owpTotal=0
<operator>.assignment oldxpjzkemvo[i]=owpTotal/rfrocteuftgz
<operator>.assignment i=0
fprintf fprintf(output,"%f\n",0.25 *obmymzqlncly[i]+0.50 *khqeptmfvvjp[i]+0.25 *oldxpjzkemvo[i])
<operator>.lessThan j<ecpcleiuvcyu
<operator>.postIncrement j++
<operator>.lessThan j<ecpcleiuvcyu
<operator>.postIncrement j++
<operator>.lessThan j<ecpcleiuvcyu
<operator>.postIncrement j++
<operator>.assignment j=0
fscanf fscanf(input,"%c",&ddttctzczjln[i][j])
nzrbwajpsrah nzrbwajpsrah(ddttctzczjln[i][j]=='1')
BLOCK <empty> <empty>
<operator>.division ywjwntvvurcs[i]/(ywjwntvvurcs[i]+vlwehuduynfb[i])
<operator>.assignment j=0
nzrbwajpsrah nzrbwajpsrah(ddttctzczjln[i][j]=='.')
<operator>.assignmentPlus wpTotal+=(ywjwntvvurcs[j]-1)/(ywjwntvvurcs[j]+vlwehuduynfb[j]-1)
<operator>.division wpTotal/rfrocteuftgz
<operator>.assignment j=0
nzrbwajpsrah nzrbwajpsrah(ddttctzczjln[i][j]=='.')
<operator>.assignmentPlus owpTotal+=khqeptmfvvjp[j]
<operator>.division owpTotal/rfrocteuftgz
<operator>.addition 0.25 *obmymzqlncly[i]+0.50 *khqeptmfvvjp[i]+0.25 *oldxpjzkemvo[i]
<operator>.postIncrement ywjwntvvurcs[i]++
<operator>.addition ywjwntvvurcs[i]+vlwehuduynfb[i]
<operator>.addition 0.25 *obmymzqlncly[i]+0.50 *khqeptmfvvjp[i]
<operator>.multiplication 0.25 *oldxpjzkemvo[i]
<operator>.equals ddttctzczjln[i][j]=='1'
<operator>.equals ddttctzczjln[i][j]=='.'
<operator>.equals ddttctzczjln[i][j]=='.'
<operator>.multiplication 0.25 *obmymzqlncly[i]
<operator>.multiplication 0.50 *khqeptmfvvjp[i]
<operator>.addressOf &ecpcleiuvcyu
<operator>.indirectIndexAccess obmymzqlncly[i]
<operator>.indirectIndexAccess khqeptmfvvjp[i]
<operator>.indirectIndexAccess oldxpjzkemvo[i]
UNKNOWN,),)
UNKNOWN else nzrbwajpsrah (ddttctzczjln[i][j]=='0'){vlwehuduynfb[i]++;} else nzrbwajpsrah (ddttctzczjln[i][j]=='0'){vlwehuduynfb[i]++;}
<operator>.indirectIndexAccess ywjwntvvurcs[i]
UNKNOWN,),)
UNKNOWN,),)
<operator>.addressOf &ddttctzczjln[i][j]
<operator>.indirectIndexAccess ywjwntvvurcs[i]
<operator>.indirectIndexAccess vlwehuduynfb[i]
<operator>.indirectIndexAccess oldxpjzkemvo[i]
<operator>.indirectIndexAccess ddttctzczjln[i][j]
<operator>.indirectIndexAccess ddttctzczjln[i][j]
<operator>.indirectIndexAccess ywjwntvvurcs[i]
<operator>.indirectIndexAccess ddttctzczjln[i][j]
<operator>.indirectIndexAccess ddttctzczjln[i][j]
<operator>.indirectIndexAccess obmymzqlncly[i]
<operator>.indirectIndexAccess khqeptmfvvjp[i]
<operator>.indirectIndexAccess ddttctzczjln[i]
<operator>.indirectIndexAccess ddttctzczjln[i]
<operator>.indirectIndexAccess ddttctzczjln[i]
<operator>.indirectIndexAccess ddttctzczjln[i]
>>>PDG&102 0->2 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->41 0->43 0->44 0->45 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->58 0->60 0->63 0->64 0->67 0->72 0->73 0->74 0->75 0->76 0->77 2->1 2->21 3->1 3->1 3->5 4->1 4->1 4->7 4->20 5->1 5->1 5->6 5->9 5->19 6->1 6->1 7->1 7->1 8->1 9->1 9->1 9->1 9->9 9->13 9->14 9->15 9->16 9->17 9->18 9->19 9->20 9->21 9->22 9->24 9->26 9->28 9->30 9->31 9->32 9->33 9->34 9->35 9->36 9->39 9->43 9->47 9->78 10->8 11->3 11->3 12->4 12->4 13->1 13->1 14->1 14->1 14->76 15->1 15->1 15->77 16->1 16->1 16->72 17->1 17->1 17->59 17->69 17->70 18->1 18->1 18->1 18->59 18->70 19->1 19->1 19->6 19->22 19->24 19->26 19->28 19->37 19->49 19->51 19->53 20->1 20->7 20->21 20->48 21->1 21->9 21->20 22->22 22->23 22->23 22->24 22->37 22->38 22->49 22->49 22->55 22->59 22->70 22->79 22->84 22->88 22->89 23->1 23->22 24->24 24->25 24->25 24->26 24->40 24->41 24->42 24->51 24->51 24->60 24->63 24->80 25->1 25->24 26->26 26->27 26->27 26->28 26->44 26->45 26->46 26->53 26->53 26->64 26->67 26->81 27->1 27->26 28->1 28->1 28->1 28->19 28->22 28->28 28->29 28->29 28->48 28->68 28->71 28->72 28->76 28->77 28->90 28->96 28->97 29->1 29->28 30->13 31->14 32->15 33->16 34->17 35->18 36->22 37->1 37->6 37->19 37->56 38->1 38->1 38->1 38->76 39->24 40->1 40->63 41->1 41->63 42->1 42->1 42->1 42->77 43->26 44->1 44->67 45->1 45->67 46->1 46->1 46->1 46->72 47->1 47->28 48->1 48->1 48->7 48->20 49->1 49->1 49->22 49->49 49->50 49->50 49->56 49->57 49->69 49->73 49->82 49->83 49->87 49->91 49->92 49->93 49->98 49->99 50->1 50->49 51->1 51->1 51->24 51->51 51->52 51->52 51->61 51->74 51->85 51->94 51->100 52->1 52->51 53->1 53->1 53->26 53->53 53->54 53->54 53->65 53->75 53->86 53->95 53->101 54->1 54->53 55->1 55->49 56->1 56->1 56->6 56->19 56->37 56->73 56->74 56->75 57->1 57->1 59->1 59->1 59->38 59->38 59->69 59->70 60->1 60->51 61->1 61->1 62->1 62->1 62->63 63->1 63->1 63->42 63->42 64->1 64->53 65->1 65->1 66->1 66->1 66->67 67->1 67->1 67->46 67->46 68->1 68->1 69->1 69->59 69->70 70->1 71->1 71->1 72->1 72->48 72->48 72->68 72->68 73->1 73->56 73->57 73->57 73->74 73->75 74->1 74->56 74->61 74->61 74->73 74->75 75->1 75->56 75->65 75->65 75->73 75->74 76->1 76->48 76->48 76->68 76->68 76->71 76->71 77->1 77->48 77->48 77->68 77->68 77->71 77->71
>>>Token int main ( ) { FILE * input , * output ; int qnldjpgkoqer , ii = 0 ; input = fopen ( " " , " " ) ; output = fopen ( " " , " " ) ; fscanf ( input , " \n " , & qnldjpgkoqer ) ; while ( ii ++ < qnldjpgkoqer ) { char ddttctzczjln [ 100 ] [ 100 ] = { 0 } ; double obmymzqlncly [ 100 ] = { 0 } ; double khqeptmfvvjp [ 100 ] = { 0 } ; double oldxpjzkemvo [ 100 ] = { 0 } ; double ywjwntvvurcs [ 100 ] = { 0 } ; double vlwehuduynfb [ 100 ] = { 0 } ; int ecpcleiuvcyu , i , j ; fscanf ( input , " " , & ecpcleiuvcyu ) ; for ( i = 0 ; i < ecpcleiuvcyu ; i ++ ) { fscanf ( input , " \n " ) ; for ( j = 0 ; j < ecpcleiuvcyu ; j ++ ) { fscanf ( input , " " , & ddttctzczjln [ i ] [ j ] ) ; nzrbwajpsrah ( ddttctzczjln [ i ] [ j ] == ' ' )  { ywjwntvvurcs [ i ] ++ ; } else nzrbwajpsrah ( ddttctzczjln [ i ] [ j ] = = ' ' ) { vlwehuduynfb [ i ] ++ ; } } obmymzqlncly [ i ] = ywjwntvvurcs [ i ] / ( ywjwntvvurcs [ i ] + vlwehuduynfb [ i ] ) ; } for ( i = 0 ; i < ecpcleiuvcyu ; i ++ ) { double rfrocteuftgz = 0 , wpTotal = 0 ; for ( j = 0 ; j < ecpcleiuvcyu ; j ++ ) { nzrbwajpsrah ( ddttctzczjln [ i ] [ j ] == ' ' )  { continue ; } rfrocteuftgz ++ ; nzrbwajpsrah ( ddttctzczjln [ i ] [ j ] == ' ' ) wpTotal += ywjwntvvurcs [ j ] / ( ywjwntvvurcs [ j ] + vlwehuduynfb [ j ] - 1 ) ; nzrbwajpsrah ( ddttctzczjln [ i ] [ j ] == ' ' ) wpTotal += ( ywjwntvvurcs [ j ] - 1 ) / ( ywjwntvvurcs [ j ] + vlwehuduynfb [ j ] - 1 ) ; } khqeptmfvvjp [ i ] = wpTotal / rfrocteuftgz ; } for ( i = 0 ; i < ecpcleiuvcyu ; i ++ ) { double rfrocteuftgz = 0 , owpTotal = 0 ; for ( j = 0 ; j < ecpcleiuvcyu ; j ++ ) { nzrbwajpsrah ( ddttctzczjln [ i ] [ j ] == ' ' )  { continue ; } rfrocteuftgz ++ ; owpTotal += khqeptmfvvjp [ j ] ; } oldxpjzkemvo [ i ] = owpTotal / rfrocteuftgz ; } fprintf ( output , " \n " , ii ) ; for ( i = 0 ; i < ecpcleiuvcyu ; i ++ ) { fprintf ( output , " \n " , 0.25 * obmymzqlncly [ i ] + 0.50 * khqeptmfvvjp [ i ] + 0.25 * oldxpjzkemvo [ i ] ) ; } } fclose ( input ) ; fclose ( output ) ; return 0 ; }
>>>Func
METHOD ovidemrzjdxd
METHOD_RETURN int
PARAM char oartcbfzegag
RETURN return -1; return -1;
IDENTIFIER oartcbfzegag switch(oartcbfzegag)
<operator>.minus -1
LITERAL 'Q' <empty>
RETURN return  0; return  0;
LITERAL 'W' <empty>
RETURN return  1; return  1;
LITERAL 'E' <empty>
RETURN return  2; return  2;
LITERAL 'R' <empty>
RETURN return  3; return  3;
LITERAL 'A' <empty>
RETURN return  4; return  4;
LITERAL 'S' <empty>
RETURN return  5; return  5;
LITERAL 'D' <empty>
RETURN return  6; return  6;
LITERAL 'F' <empty>
RETURN return  7; return  7;
LITERAL 0 return  0;
LITERAL 1 return  1;
LITERAL 2 return  2;
LITERAL 3 return  3;
LITERAL 4 return  4;
LITERAL 5 return  5;
LITERAL 6 return  6;
LITERAL 7 return  7;
>>>PDG&30 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 2->1 3->1 5->3 7->1 9->1 11->1 13->1 15->1 17->1 19->1 21->1 22->7 23->9 24->11 25->13 26->15 27->17 28->19 29->21
>>>Token int ovidemrzjdxd ( char oartcbfzegag ) { switch ( oartcbfzegag ) { case ' ' : return 0 ; case ' ' : return 1 ; case ' ' : return 2 ; case ' ' : return 3 ; case ' ' : return 4 ; case ' ' : return 5 ; case ' ' : return 6 ; case ' ' : return 7 ; } return -1 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int dmelccumtlmf
PARAM char *argv [ ]
scanf scanf("%d",&tc)
RETURN return scbsvsrqdqdw; return scbsvsrqdqdw;
<operator>.lessThan smwcblcvapkf<tc
<operator>.postIncrement smwcblcvapkf++
IDENTIFIER scbsvsrqdqdw return scbsvsrqdqdw;
<operator>.assignment smwcblcvapkf=0
scanf scanf("%lld%d%d",&n,&xvzdnbqbkfda,&g)
oarkswjpmybw oarkswjpmybw("Case #%d: ",smwcblcvapkf+1)
<operator>.logicalAnd n>=100/gcd(xvzdnbqbkfda,100)&&((xvzdnbqbkfda==100&&g==100)||(xvzdnbqbkfda==0&&g==0)||(g<100&&g>0))
<operator>.addition smwcblcvapkf+1
oarkswjpmybw oarkswjpmybw("Possible\n")
<operator>.greaterEqualsThan n>=100/gcd(xvzdnbqbkfda,100)
<operator>.logicalOr (xvzdnbqbkfda==100&&g==100)||(xvzdnbqbkfda==0&&g==0)||(g<100&&g>0)
oarkswjpmybw oarkswjpmybw ("Broken\n")
<operator>.division 100/gcd(xvzdnbqbkfda,100)
<operator>.logicalOr (xvzdnbqbkfda==100&&g==100)||(xvzdnbqbkfda==0&&g==0)
<operator>.logicalAnd g<100&&g>0
gcd gcd(xvzdnbqbkfda,100)
<operator>.logicalAnd xvzdnbqbkfda==100&&g==100
<operator>.logicalAnd xvzdnbqbkfda==0&&g==0
<operator>.lessThan g<100
<operator>.greaterThan g>0
<operator>.equals xvzdnbqbkfda==100
<operator>.equals g==100
<operator>.equals xvzdnbqbkfda==0
<operator>.equals g==0
<operator>.addressOf &n
<operator>.addressOf &xvzdnbqbkfda
<operator>.addressOf &g
>>>PDG&33 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->17 0->18 0->21 0->24 0->25 0->26 0->27 0->28 0->29 2->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->11 6->11 6->12 6->13 6->13 6->15 6->18 6->21 6->30 6->31 6->32 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->1 10->15 11->1 11->1 12->1 12->1 12->1 12->14 12->17 14->1 15->1 15->1 15->10 15->12 15->12 15->16 15->19 15->22 15->26 16->1 16->1 16->12 16->12 17->1 18->1 18->15 18->15 19->1 19->1 19->16 19->16 19->20 19->24 20->1 20->1 20->16 20->16 21->1 21->18 21->18 21->26 22->1 22->1 22->19 22->19 22->23 22->28 23->1 23->1 23->19 23->19 24->1 24->20 24->20 24->25 24->25 24->27 24->29 25->1 25->20 25->20 25->24 25->27 25->29 26->1 26->21 26->22 26->22 26->27 26->28 27->1 27->22 27->22 27->24 27->29 28->1 28->21 28->23 28->23 28->29 29->1 29->23 29->23 29->24 29->27
>>>Token int main ( int dmelccumtlmf , char * argv [ ] ) { int smwcblcvapkf , tc ; ybkuuaivcbju ybkuuaivcbjun ; int xvzdnbqbkfda , g ; scanf ( " " , & tc ) ; for ( smwcblcvapkf = 0 ; smwcblcvapkf < tc ; smwcblcvapkf ++ ) { scanf ( " " , & n , & xvzdnbqbkfda , & g ) ; oarkswjpmybw ( " " , smwcblcvapkf + 1 ) ; if ( n >= 100 / gcd ( xvzdnbqbkfda , 100 ) && ( ( xvzdnbqbkfda == 100 && g == 100 ) || ( xvzdnbqbkfda == 0 && g == 0 ) || ( g < 100 && g > 0 ) ) ) oarkswjpmybw ( " \n " ) ; else oarkswjpmybw ( " \n " ) ; } return scbsvsrqdqdw ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment r=scanf("%d",&vsolpwmrelxk)
RETURN return 0; return 0;
<operator>.lessThan k<vsolpwmrelxk
<operator>.postIncrement k++
<operator>.lessThan k<vsolpwmrelxk
<operator>.postIncrement k++
LITERAL 0 return 0;
scanf scanf("%d",&vsolpwmrelxk)
<operator>.assignment k=0
<operator>.assignment r=scanf("%d",&n)
<operator>.assignment len[k]=n
<operator>.assignment sum=0
<operator>.assignment yxfzojvvxkqf=1
<operator>.assignment smax=32767
<operator>.assignment tw=sum+1
<operator>.assignment k=0
printf printf("Case #%d:",k+1)
printf printf("\n")
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.greaterThan tw>sum
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<len[k]
<operator>.postIncrement i++
scanf scanf("%d",&n)
<operator>.assignment i=0
<operator>.assignment r=scanf("%d",&hhhecbnjiogj[i])
<operator>.assignment sum=sum+hhhecbnjiogj[i]
<operator>.addition sum+1
<operator>.assignment tw=0
<operator>.assignment max=-1
<operator>.assignment count=0
<operator>.assignment smax=max
<operator>.assignment i=0
<operator>.assignment badsvvufqjnx[k][i]=(max-hhhecbnjiogj[i])/(double)sum
<operator>.assignment yxfzojvvxkqf=yxfzojvvxkqf-badsvvufqjnx[k][i]
<operator>.assignment i=0
<operator>.addition k+1
<operator>.assignment i=0
printf printf(" %lf",badsvvufqjnx[k][i]*100)
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan badsvvufqjnx[k][i]<0
<operator>.lessEqualsThan hhhecbnjiogj[i]<=max
scanf scanf("%d",&hhhecbnjiogj[i])
<operator>.addition sum+hhhecbnjiogj[i]
<operator>.minus -1
<operator>.assignment i=0
<operator>.assignment i=0
<operator>.assignment weight[i]=max-hhhecbnjiogj[i]
<operator>.assignment tw=tw+weight[i]
<operator>.division (max-hhhecbnjiogj[i])/(double)sum
<operator>.assignment badsvvufqjnx[k][i]=0
<operator>.subtraction yxfzojvvxkqf-badsvvufqjnx[k][i]
<operator>.assignment badsvvufqjnx[k][i]=badsvvufqjnx[k][i]+yxfzojvvxkqf/count
<operator>.multiplication badsvvufqjnx[k][i]*100
<operator>.lessThan hhhecbnjiogj[i]<smax
<operator>.lessThan weight[i]<0
<operator>.subtraction max-hhhecbnjiogj[i]
<operator>.cast (double)sum
<operator>.postIncrement count++
<operator>.subtraction max-hhhecbnjiogj[i]
<operator>.assignment weight[i]=0
<operator>.addition tw+weight[i]
<operator>.addition badsvvufqjnx[k][i]+yxfzojvvxkqf/count
<operator>.greaterThan hhhecbnjiogj[i]>max
<operator>.division yxfzojvvxkqf/count
<operator>.assignment max=hhhecbnjiogj[i]
<operator>.assignment maxi=i
<operator>.indirectIndexAccess len[k]
<operator>.addressOf &n
<operator>.indirectIndexAccess len[k]
<operator>.indirectIndexAccess badsvvufqjnx[k][i]
<operator>.addressOf &hhhecbnjiogj[i]
<operator>.indirectIndexAccess hhhecbnjiogj[i]
<operator>.indirectIndexAccess badsvvufqjnx[k]
<operator>.indirectIndexAccess badsvvufqjnx[k][i]
<operator>.indirectIndexAccess badsvvufqjnx[k][i]
<operator>.indirectIndexAccess hhhecbnjiogj[i]
<operator>.indirectIndexAccess badsvvufqjnx[k][i]
<operator>.indirectIndexAccess hhhecbnjiogj[i]
<operator>.indirectIndexAccess weight[i]
<operator>.indirectIndexAccess hhhecbnjiogj[i]
UNKNOWN double double
<operator>.indirectIndexAccess badsvvufqjnx[k]
<operator>.indirectIndexAccess badsvvufqjnx[k][i]
<operator>.indirectIndexAccess badsvvufqjnx[k]
<operator>.indirectIndexAccess badsvvufqjnx[k][i]
<operator>.indirectIndexAccess badsvvufqjnx[k]
<operator>.indirectIndexAccess hhhecbnjiogj[i]
<operator>.indirectIndexAccess hhhecbnjiogj[i]
<operator>.indirectIndexAccess weight[i]
<operator>.indirectIndexAccess weight[i]
<operator>.indirectIndexAccess badsvvufqjnx[k]
<operator>.indirectIndexAccess badsvvufqjnx[k]
<operator>.indirectIndexAccess badsvvufqjnx[k][i]
<operator>.indirectIndexAccess weight[i]
<operator>.indirectIndexAccess badsvvufqjnx[k]
<operator>.indirectIndexAccess hhhecbnjiogj[i]
<operator>.indirectIndexAccess hhhecbnjiogj[i]
>>>PDG&107 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->34 0->36 0->37 0->38 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->57 0->58 0->59 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->72 0->73 0->75 2->1 2->1 3->1 4->4 4->5 4->5 4->6 4->11 4->12 4->13 4->14 4->15 4->16 4->20 4->22 4->23 4->25 4->29 4->30 4->33 4->38 4->41 4->76 4->77 5->1 5->4 6->1 6->1 6->1 6->6 6->7 6->7 6->18 6->18 6->19 6->27 6->42 6->42 6->43 6->78 7->1 7->6 8->3 9->1 9->2 9->4 9->6 10->4 11->1 11->1 12->1 12->1 12->27 13->1 13->16 13->22 13->32 13->33 13->52 14->1 14->1 14->60 14->73 15->1 15->1 15->63 16->1 16->1 16->22 17->1 17->6 18->1 18->1 19->1 20->20 20->21 20->21 20->23 20->31 20->32 20->45 20->51 20->52 20->80 20->81 20->87 21->1 21->20 22->1 22->1 22->1 22->22 22->34 22->35 22->36 22->37 22->45 22->47 22->53 22->54 22->55 22->58 22->66 23->23 23->24 23->24 23->25 23->39 23->40 23->49 23->58 23->60 23->65 23->66 23->79 23->82 23->83 23->84 23->89 23->90 23->91 23->93 24->1 24->23 25->1 25->1 25->1 25->12 25->20 25->25 25->26 25->26 25->29 25->50 25->85 26->1 26->25 27->1 27->1 27->1 27->27 27->28 27->28 27->44 27->62 27->78 27->86 27->95 28->1 28->27 29->1 29->11 29->12 29->20 29->23 29->25 29->45 29->47 30->20 31->1 31->1 32->1 32->1 32->16 32->22 32->33 32->52 34->1 34->22 34->57 34->70 35->1 35->1 35->37 35->50 35->65 35->68 35->72 36->1 36->1 36->67 36->73 37->1 37->1 37->1 37->63 38->23 39->1 39->1 39->49 40->1 40->1 40->1 40->60 40->73 41->1 41->25 43->1 43->27 44->1 44->1 45->45 45->46 45->46 45->47 45->63 45->75 45->96 46->1 46->45 47->23 47->45 47->47 47->48 47->48 47->56 47->57 47->64 47->68 47->70 47->88 47->97 47->98 47->99 48->1 48->47 49->1 49->59 49->60 49->92 49->100 50->1 50->1 50->1 50->32 50->51 50->52 50->61 50->63 50->65 50->65 50->68 50->71 50->73 50->94 50->101 50->102 50->104 51->1 51->31 51->32 51->50 51->52 51->63 51->65 51->68 51->72 51->74 52->1 53->35 54->45 55->47 56->1 56->1 56->64 57->1 57->1 57->22 57->70 58->1 58->1 58->39 58->39 59->1 59->60 60->1 60->40 60->40 60->61 60->62 60->71 61->1 61->1 61->1 61->62 61->71 62->1 62->44 62->44 63->1 63->1 63->32 63->50 63->51 63->52 63->65 63->67 63->68 63->72 63->72 63->105 64->1 64->57 64->69 64->70 64->103 65->1 65->1 65->32 65->50 65->50 65->51 65->52 65->58 65->58 65->63 65->68 66->1 67->1 67->1 67->73 68->1 68->32 68->37 68->50 68->50 68->51 68->52 68->56 68->56 68->63 68->65 68->65 69->1 69->57 69->70 70->1 71->1 72->1 72->1 72->32 72->37 72->50 72->50 72->51 72->52 72->63 72->65 72->65 72->68 72->68 72->74 72->74 72->75 72->106 73->1 73->1 73->61 73->61 73->71 73->71 74->1 74->1 74->37 74->50 74->65 74->68 74->72 75->1 75->1
>>>Token int main ( ) { int vsolpwmrelxk , i , j , sum , max , k , n , r , weight [ 201 ] , tw , maxi , smax , count ; int hhhecbnjiogj [ 201 ] , len [ 51 ] ; double badsvvufqjnx [ 51 ] [ 201 ] ; double yxfzojvvxkqf ; r = scanf ( " " , & vsolpwmrelxk ) ; for ( k = 0 ; k < vsolpwmrelxk ; k ++ ) { r = scanf ( " " , & n ) ; len [ k ] = n ; sum = 0 ; yxfzojvvxkqf = 1 ; smax = 32767 ; for ( i = 0 ; i < n ; i ++ ) { r = scanf ( " " , & hhhecbnjiogj [ i ] ) ; sum = sum + hhhecbnjiogj [ i ] ; } tw = sum + 1 ; while ( tw > sum ) { tw = 0 ; max = -1 ; count = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( hhhecbnjiogj [ i ] < smax ) { if ( hhhecbnjiogj [ i ] > max ) { max = hhhecbnjiogj [ i ] ; maxi = i ; } count ++ ; } } for ( i = 0 ; i < n ; i ++ ) { weight [ i ] = max - hhhecbnjiogj [ i ] ; if ( weight [ i ] < 0 ) weight [ i ] = 0 ; tw = tw + weight [ i ] ; } smax = max ; } for ( i = 0 ; i < n ; i ++ ) { badsvvufqjnx [ k ] [ i ] = ( max - hhhecbnjiogj [ i ] ) / ( double ) sum ; if ( badsvvufqjnx [ k ] [ i ] < 0 ) badsvvufqjnx [ k ] [ i ] = 0 ; yxfzojvvxkqf = yxfzojvvxkqf - badsvvufqjnx [ k ] [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { if ( hhhecbnjiogj [ i ] <= max ) badsvvufqjnx [ k ] [ i ] = badsvvufqjnx [ k ] [ i ] + yxfzojvvxkqf / count ; } } for ( k = 0 ; k < vsolpwmrelxk ; k ++ ) { printf ( " " , k + 1 ) ; for ( i = 0 ; i < len [ k ] ; i ++ ) { printf ( " " , badsvvufqjnx [ k ] [ i ] * 100 ) ; ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int msqpkzwbogpp
PARAM tgaxxexnlzjx *argv [ ]
<operator>.assignment c=argv[1][0]
RETURN return 0; return 0;
<operator>.greaterThan c>63
LITERAL 0 return 0;
twsbzndwijag twsbzndwijag("if-1-win ")
<operator>.assignment x=(c/3)*2
<operator>.equals x==127
twsbzndwijag twsbzndwijag("if-1-lose\n")
<operator>.multiplication (c/3)*2
twsbzndwijag twsbzndwijag("if-2-win\n")
<operator>.division c/3
twsbzndwijag twsbzndwijag ("if-2-lose\n")
UNKNOWN x x
>>>PDG&17 0->2 0->3 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 2->1 3->1 4->1 4->1 4->6 5->1 6->1 6->1 6->8 6->9 6->10 6->11 6->12 6->14 6->14 6->16 7->5 8->1 9->1 9->1 9->10 10->1 10->1 10->13 10->15 11->1 12->1 12->9 12->9 13->1 14->1 14->12 14->12 15->1
>>>Token int main ( int msqpkzwbogpp , tgaxxexnlzjx * argv [ ] ) { unsigned tgaxxexnlzjx c = argv [ 1 ] [ 0 ] ; if ( c > 63 ) { twsbzndwijag ( " " ) ; unsigned tgaxxexnlzjx x = ( c / 3 ) * 2 ; if ( x == 127 ) twsbzndwijag ( " \n " ) ; else twsbzndwijag ( " \n " ) ; } else { twsbzndwijag ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN void
scanf scanf("%d",&aelmmybvsitl)
<operator>.assignment a=(int **)malloc(100 *sizeof(int *))
<operator>.assignment cnt1=(int *)malloc(100 *sizeof(int))
<operator>.assignment cnt2=(int *)malloc(100 *sizeof(int))
<operator>.assignment wp=(double *)malloc(100 *sizeof(double))
<operator>.assignment owp=(double *)malloc(100 *sizeof(double))
<operator>.assignment oowp=(double *)malloc(100 *sizeof(double))
<operator>.lessThan tvmefppjcmyg<100
<operator>.postIncrement tvmefppjcmyg++
<operator>.lessThan tvmefppjcmyg<aelmmybvsitl
<operator>.postIncrement tvmefppjcmyg++
<operator>.cast (int **)malloc(100 *sizeof(int *))
<operator>.assignment tvmefppjcmyg=0
<operator>.assignment a[tvmefppjcmyg]=(int *)malloc(100 *sizeof(int))
<operator>.cast (int *)malloc(100 *sizeof(int))
<operator>.cast (int *)malloc(100 *sizeof(int))
<operator>.cast (double *)malloc(100 *sizeof(double))
<operator>.cast (double *)malloc(100 *sizeof(double))
<operator>.cast (double *)malloc(100 *sizeof(double))
<operator>.assignment tvmefppjcmyg=0
scanf scanf("%d",&xrwbtkjsmvzt)
<operator>.assignment scjfzrejnyvy=0.0
printf printf("Case #%d:\n",tvmefppjcmyg+1)
malloc malloc(100 *sizeof(int *))
malloc malloc(100 *sizeof(int))
malloc malloc(100 *sizeof(int))
malloc malloc(100 *sizeof(double))
malloc malloc(100 *sizeof(double))
malloc malloc(100 *sizeof(double))
<operator>.lessThan j<xrwbtkjsmvzt
<operator>.postIncrement j++
<operator>.lessThan j<xrwbtkjsmvzt
<operator>.postIncrement j++
<operator>.lessThan j<xrwbtkjsmvzt
<operator>.postIncrement j++
<operator>.lessThan j<xrwbtkjsmvzt
<operator>.postIncrement j++
<operator>.lessThan j<xrwbtkjsmvzt
<operator>.postIncrement j++
<operator>.multiplication 100 *sizeof(int *)
<operator>.cast (int *)malloc(100 *sizeof(int))
<operator>.multiplication 100 *sizeof(int)
<operator>.multiplication 100 *sizeof(int)
<operator>.multiplication 100 *sizeof(double)
<operator>.multiplication 100 *sizeof(double)
<operator>.multiplication 100 *sizeof(double)
<operator>.assignment j=0
scanf scanf("%c",&tuevctxvxrtf)
<operator>.assignment j=0
<operator>.assignment fuawkqobedix=0
<operator>.assignment hbwisozafvim=0
<operator>.assignment cnt1[j]=fuawkqobedix
<operator>.assignment cnt2[j]=hbwisozafvim
<operator>.assignment wp[j]=(double)fuawkqobedix/(double)hbwisozafvim
<operator>.assignment j=0
<operator>.assignment scjfzrejnyvy=0.0
<operator>.assignment owp[j]=scjfzrejnyvy/(double)cnt2[j]
<operator>.assignment j=0
<operator>.assignment scjfzrejnyvy=0.0
<operator>.assignment oowp[j]=scjfzrejnyvy/(double)cnt2[j]
<operator>.addition tvmefppjcmyg+1
<operator>.assignment j=0
<operator>.assignment scjfzrejnyvy=0.25 *wp[j]+0.5 *owp[j]+0.25 *oowp[j]
printf printf("%.9g\n",scjfzrejnyvy)
malloc malloc(100 *sizeof(int))
<operator>.sizeOf sizeof(int)
<operator>.sizeOf sizeof(double)
<operator>.lessThan k<xrwbtkjsmvzt
<operator>.postIncrement k++
<operator>.lessThan k<xrwbtkjsmvzt
<operator>.postIncrement k++
<operator>.lessThan k<xrwbtkjsmvzt
<operator>.postIncrement k++
<operator>.lessThan k<xrwbtkjsmvzt
<operator>.postIncrement k++
<operator>.multiplication 100 *sizeof(int)
<operator>.assignment k=0
scanf scanf("%c",&tuevctxvxrtf)
<operator>.assignment k=0
<operator>.division (double)fuawkqobedix/(double)hbwisozafvim
<operator>.assignment k=0
<operator>.division scjfzrejnyvy/(double)cnt2[j]
<operator>.assignment k=0
<operator>.division scjfzrejnyvy/(double)cnt2[j]
<operator>.addition 0.25 *wp[j]+0.5 *owp[j]+0.25 *oowp[j]
<operator>.equals tuevctxvxrtf=='.'
<operator>.equals tuevctxvxrtf=='1'
<operator>.equals tuevctxvxrtf=='0'
<operator>.equals a[j][k]==1
<operator>.notEquals a[j][k]!=-1
<operator>.cast (double)fuawkqobedix
<operator>.cast (double)hbwisozafvim
<operator>.notEquals a[j][k]!=-1
<operator>.cast (double)cnt2[j]
<operator>.notEquals a[j][k]!=-1
<operator>.cast (double)cnt2[j]
<operator>.addition 0.25 *wp[j]+0.5 *owp[j]
<operator>.multiplication 0.25 *oowp[j]
<operator>.assignment a[j][k]=-1
<operator>.assignment a[j][k]=1
<operator>.assignment a[j][k]=0
<operator>.postIncrement fuawkqobedix++
<operator>.postIncrement hbwisozafvim++
<operator>.assignment scjfzrejnyvy=scjfzrejnyvy+owp[k]
<operator>.multiplication 0.25 *wp[j]
<operator>.multiplication 0.5 *owp[j]
<operator>.minus -1
<operator>.minus -1
<operator>.equals a[j][k]==0
<operator>.minus -1
<operator>.minus -1
<operator>.assignment scjfzrejnyvy=scjfzrejnyvy+(double)(cnt1[k]-1)/(double)(cnt2[k]-1)
<operator>.addition scjfzrejnyvy+owp[k]
<operator>.assignment scjfzrejnyvy =scjfzrejnyvy+(double)(cnt1[k])/(double)(cnt2[k]-1)
<operator>.addition scjfzrejnyvy+(double)(cnt1[k]-1)/(double)(cnt2[k]-1)
<operator>.division (double)(cnt1[k]-1)/(double)(cnt2[k]-1)
<operator>.addition scjfzrejnyvy+(double)(cnt1[k])/(double)(cnt2[k]-1)
<operator>.cast (double)(cnt1[k]-1)
<operator>.cast (double)(cnt2[k]-1)
<operator>.division (double)(cnt1[k])/(double)(cnt2[k]-1)
<operator>.subtraction cnt1[k]-1
<operator>.subtraction cnt2[k]-1
<operator>.cast (double)(cnt1[k])
<operator>.cast (double)(cnt2[k]-1)
<operator>.subtraction cnt2[k]-1
<operator>.indirectIndexAccess a[tvmefppjcmyg]
<operator>.addressOf &xrwbtkjsmvzt
UNKNOWN int * int *
<operator>.addressOf &tuevctxvxrtf
<operator>.indirectIndexAccess cnt1[j]
<operator>.indirectIndexAccess cnt2[j]
<operator>.indirectIndexAccess wp[j]
<operator>.indirectIndexAccess owp[j]
<operator>.indirectIndexAccess oowp[j]
<operator>.sizeOf sizeof(int)
<operator>.addressOf &tuevctxvxrtf
UNKNOWN double double
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess cnt2[j]
UNKNOWN double double
<operator>.indirectIndexAccess cnt2[j]
<operator>.indirectIndexAccess oowp[j]
<operator>.indirectIndexAccess a[j][k]
<operator>.indirectIndexAccess a[j][k]
<operator>.indirectIndexAccess a[j][k]
<operator>.indirectIndexAccess a[j][k]
<operator>.indirectIndexAccess wp[j]
<operator>.indirectIndexAccess owp[j]
<operator>.indirectIndexAccess a[j][k]
<operator>.indirectIndexAccess a[j][k]
<operator>.indirectIndexAccess a[j][k]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess a[j][k]
<operator>.indirectIndexAccess owp[k]
<operator>.indirectIndexAccess a[j]
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess cnt1[k]
<operator>.indirectIndexAccess cnt2[k]
UNKNOWN double double
<operator>.indirectIndexAccess cnt1[k]
UNKNOWN double double
<operator>.indirectIndexAccess cnt2[k]
>>>PDG&172 0->2 0->9 0->10 0->11 0->12 0->14 0->21 0->22 0->23 0->24 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->56 0->57 0->59 0->60 0->62 0->63 0->65 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->87 0->88 0->89 0->90 0->92 0->93 0->99 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->114 0->115 0->116 0->118 0->122 0->123 0->126 2->1 2->11 3->1 3->1 3->1 4->1 4->1 4->121 4->122 4->124 5->1 5->1 5->1 5->83 5->85 5->95 5->97 5->123 5->126 6->1 6->1 6->106 7->1 7->1 7->105 7->107 7->114 8->1 8->1 8->1 8->99 9->1 9->9 9->10 9->10 9->15 9->42 9->66 9->77 9->127 9->129 9->136 10->1 10->9 11->1 11->1 11->1 11->11 11->12 11->12 11->22 11->23 11->24 11->24 11->31 11->33 11->35 11->37 11->39 11->48 11->50 11->56 11->59 11->62 11->62 11->63 11->128 12->1 12->11 13->1 14->9 15->1 15->1 17->1 20->1 21->1 21->11 22->1 22->31 22->33 22->35 22->37 22->39 22->69 22->71 22->73 22->75 23->1 23->1 24->1 24->1 25->1 25->3 25->13 26->4 26->16 27->1 27->5 27->17 28->6 28->18 29->7 29->19 30->1 30->8 30->20 31->31 31->32 31->32 31->33 31->49 31->69 31->69 31->78 31->130 32->1 32->31 33->33 33->34 33->34 33->35 33->51 33->52 33->53 33->54 33->55 33->71 33->71 33->80 33->81 33->92 33->93 33->131 33->132 33->133 33->138 33->139 34->1 34->33 35->35 35->36 35->36 35->37 35->57 35->58 35->73 35->73 35->82 35->83 35->95 35->134 35->140 35->141 36->1 36->35 37->37 37->38 37->38 37->39 37->60 37->61 37->75 37->75 37->84 37->85 37->97 37->135 37->142 37->143 38->1 38->37 39->1 39->1 39->1 39->22 39->31 39->39 39->40 39->40 39->64 39->65 39->86 39->98 39->99 39->106 39->107 39->144 39->149 39->150 40->1 40->39 41->25 43->26 44->27 45->28 46->29 47->30 48->31 49->1 49->79 49->87 50->33 51->1 51->53 51->81 51->92 51->103 52->1 52->54 52->81 52->93 52->104 53->1 53->1 54->1 54->1 54->83 54->85 54->95 54->97 55->1 55->1 55->1 55->106 56->35 57->1 57->83 57->113 57->115 57->116 57->118 58->1 58->1 58->1 58->107 59->37 60->1 60->85 60->105 60->114 61->1 61->1 61->1 61->99 63->1 63->39 64->1 64->1 64->65 65->1 65->1 66->15 66->42 67->1 68->1 69->1 69->1 69->31 69->69 69->70 69->70 69->79 69->87 69->88 69->89 69->137 70->1 70->69 71->1 71->1 71->33 71->71 71->72 71->72 71->90 71->91 71->108 71->145 71->146 71->154 71->155 72->1 72->71 73->1 73->1 73->35 73->73 73->74 73->74 73->94 73->109 73->147 73->156 74->1 74->73 75->1 75->1 75->37 75->75 75->76 75->76 75->96 75->111 75->148 75->157 76->1 76->75 77->66 78->1 78->69 79->1 79->49 79->87 79->88 79->89 80->1 80->71 81->1 81->1 81->55 81->55 82->1 82->73 83->1 83->1 83->58 83->58 84->1 84->75 85->1 85->1 85->61 85->61 86->1 86->1 87->1 87->88 87->100 87->112 87->151 87->158 88->1 88->89 88->101 88->152 88->159 89->1 89->1 89->49 89->79 89->87 89->102 89->153 89->160 90->1 90->91 90->103 91->1 91->1 91->1 91->90 91->94 91->96 91->104 92->1 93->1 94->1 94->1 94->1 94->90 94->96 94->110 94->110 94->161 94->163 95->1 96->1 96->1 96->1 96->90 96->94 96->105 96->114 96->162 97->1 98->1 98->1 99->1 99->64 99->64 99->86 99->86 100->1 100->1 100->1 100->90 100->94 100->96 101->1 101->1 101->90 101->94 101->96 102->1 102->1 102->90 102->94 102->96 103->1 103->53 103->81 103->92 104->1 104->54 104->81 104->93 105->1 105->1 105->85 105->114 106->1 106->64 106->64 106->86 106->86 106->98 106->98 107->1 107->64 107->64 107->86 107->86 107->98 107->98 108->91 109->94 110->1 110->1 110->90 110->94 110->96 110->113 110->115 110->116 110->117 110->118 110->119 110->120 110->121 110->122 110->123 110->124 110->125 110->126 110->164 110->165 110->166 110->167 110->168 110->169 110->170 110->171 111->96 112->100 113->1 113->1 113->83 113->115 113->116 113->118 114->1 115->1 115->1 115->83 115->113 115->116 115->118 116->1 117->1 117->1 117->113 117->113 117->116 117->116 118->1 119->1 120->1 121->1 121->1 121->115 121->115 121->118 121->118 122->1 122->117 122->117 122->119 122->119 122->121 122->124 123->1 123->117 123->117 123->120 123->120 123->126 124->1 125->1 126->1 126->121 126->121 126->123 126->125 126->125
>>>Token void main ( ) { int aelmmybvsitl ; scanf ( " " , & aelmmybvsitl ) ; int tvmefppjcmyg , j , k ; char tuevctxvxrtf ; int * * a ; a = ( int * * ) malloc ( 100 * sizeof ( int * ) ) ; for ( tvmefppjcmyg = 0 ; tvmefppjcmyg < 100 ; tvmefppjcmyg ++ ) { a [ tvmefppjcmyg ] = ( int * ) malloc ( 100 * sizeof ( int ) ) ; } int * cnt2 ; int * cnt1 ; cnt1 = ( int * ) malloc ( 100 * sizeof ( int ) ) ; cnt2 = ( int * ) malloc ( 100 * sizeof ( int ) ) ; double * wp ; wp = ( double * ) malloc ( 100 * sizeof ( double ) ) ; double * owp ; owp = ( double * ) malloc ( 100 * sizeof ( double ) ) ; double * oowp ; oowp = ( double * ) malloc ( 100 * sizeof ( double ) ) ; double scjfzrejnyvy ; int fuawkqobedix ; int hbwisozafvim ; for ( tvmefppjcmyg = 0 ; tvmefppjcmyg < aelmmybvsitl ; tvmefppjcmyg ++ ) { int xrwbtkjsmvzt ; scanf ( " " , & xrwbtkjsmvzt ) ; for ( j = 0 ; j < xrwbtkjsmvzt ; j ++ ) { scanf ( " " , & tuevctxvxrtf ) ; for ( k = 0 ; k < xrwbtkjsmvzt ; k ++ ) { scanf ( " " , & tuevctxvxrtf ) ; if ( tuevctxvxrtf == ' ' ) a [ j ] [ k ] = -1 ; if ( tuevctxvxrtf == ' ' ) a [ j ] [ k ] = 1 ; if ( tuevctxvxrtf == ' ' ) a [ j ] [ k ] = 0 ; } } for ( j = 0 ; j < xrwbtkjsmvzt ; j ++ ) { fuawkqobedix = 0 ; hbwisozafvim = 0 ; for ( k = 0 ; k < xrwbtkjsmvzt ; k ++ ) { if ( a [ j ] [ k ] == 1 ) fuawkqobedix ++ ; if ( a [ j ] [ k ] != -1 ) hbwisozafvim ++ ; } cnt1 [ j ] = fuawkqobedix ; cnt2 [ j ] = hbwisozafvim ; wp [ j ] = ( double ) fuawkqobedix / ( double ) hbwisozafvim ; } scjfzrejnyvy = 0.0 ; for ( j = 0 ; j < xrwbtkjsmvzt ; j ++ ) { scjfzrejnyvy = 0.0 ; for ( k = 0 ; k < xrwbtkjsmvzt ; k ++ ) { if ( a [ j ] [ k ] != -1 ) { if ( a [ j ] [ k ] == 0 ) scjfzrejnyvy = scjfzrejnyvy + ( double ) ( cnt1 [ k ] - 1 ) / ( double ) ( cnt2 [ k ] - 1 ) ; else scjfzrejnyvy = scjfzrejnyvy + ( double ) ( cnt1 [ k ] ) / ( double ) ( cnt2 [ k ] - 1 ) ; } } owp [ j ] = scjfzrejnyvy / ( double ) cnt2 [ j ] ; } for ( j = 0 ; j < xrwbtkjsmvzt ; j ++ ) { scjfzrejnyvy = 0.0 ; for ( k = 0 ; k < xrwbtkjsmvzt ; k ++ ) { if ( a [ j ] [ k ] != -1 ) scjfzrejnyvy = scjfzrejnyvy + owp [ k ] ; } oowp [ j ] = scjfzrejnyvy / ( double ) cnt2 [ j ] ; } printf ( " \n " , tvmefppjcmyg + 1 ) ; for ( j = 0 ; j < xrwbtkjsmvzt ; j ++ ) { scjfzrejnyvy = 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ] ; printf ( " \n " , scjfzrejnyvy ) ; } } }
>>>Func
METHOD main
METHOD_RETURN int
freopen freopen("B-small-attempt3.in","r",stdin)
freopen freopen("A.out","w",stdout)
scanf scanf("%d\n",&hcvjombytxuw)
scanf scanf("%d",&i)
RETURN return 0; return 0;
<operator>.lessThan i<hcvjombytxuw
<operator>.postIncrement i++
LITERAL 0 return 0;
<operator>.assignment i=0
gets gets(ltdgikjvcjei)
ParseInput ParseInput(ltdgikjvcjei)
FindSoln FindSoln(i)
>>>PDG&14 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->1 2->1 3->1 3->1 4->1 4->7 5->1 6->1 7->1 7->1 7->1 7->5 7->7 7->8 7->11 7->12 7->13 7->13 8->1 8->7 9->6 10->1 10->7 11->1 11->12 12->1 12->1 12->11 13->1 13->8
>>>Token int main ( ) { freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; int hcvjombytxuw , i ; char ltdgikjvcjei [ 1000 ] ; scanf ( " \n " , & hcvjombytxuw ) ; for ( i = 0 ; i < hcvjombytxuw ; i ++ ) { gets ( ltdgikjvcjei ) ; ParseInput ( ltdgikjvcjei ) ; FindSoln ( i ) ; } scanf ( " " , & i ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
<operator>.assignment input=fopen("B-small.in","r")
<operator>.assignment output=fopen("B-small.out","w")
fscanf fscanf(input,"%d",&testCases)
fclose fclose(input)
fclose fclose(output)
RETURN return 0; return 0;
<operator>.greaterEqualsThan testCases>=k
<operator>.preIncrement ++k
LITERAL 0 return 0;
fopen fopen("B-small.in","r")
fopen fopen("B-small.out","w")
<operator>.assignment k=1
fscanf fscanf(input,"%d",&c)
fscanf fscanf(input,"%d",&d)
fscanf fscanf(input,"%d",&n)
fprintf fprintf(output,"Case #%d: [",k)
fprintf fprintf(output,"]")
<operator>.lessThan fdhogcavfnbk<c
<operator>.preIncrement ++fdhogcavfnbk
fscanf fscanf(input " %c%c%c" &(combination[fdhogcavfnbk].element1) &(combination[fdhogcavfnbk].element2) &(combination[fdhogcavfnbk].elementResult))
<operator>.lessThan fdhogcavfnbk<d
<operator>.preIncrement ++fdhogcavfnbk
fscanf fscanf(input " %c%c" &(opposed[fdhogcavfnbk].element1) &(opposed[fdhogcavfnbk].element2))
<operator>.lessThan fdhogcavfnbk<n
<operator>.preIncrement ++fdhogcavfnbk
fscanf fscanf(input," %c",invoked+fdhogcavfnbk)
<operator>.lessThan fdhogcavfnbk<n
<operator>.preIncrement ++fdhogcavfnbk
<operator>.greaterEqualsThan p>=0
<operator>.preDecrement --p
<operator>.greaterEqualsThan p>=0
<operator>.lessThan k<testCases
<operator>.assignment fdhogcavfnbk=0
<operator>.assignment fdhogcavfnbk=0
<operator>.assignment fdhogcavfnbk=0
<operator>.assignment fdhogcavfnbk=0
<operator>.assignment p=n-1
fprintf fprintf(output,"\n")
<operator>.addition invoked+fdhogcavfnbk
<operator>.logicalAnd j>=0&&!invoked[j]
<operator>.preDecrement --j
<operator>.greaterEqualsThan j>=0
<operator>.lessEqualsThan fdhogcavfnbk<=p
<operator>.preIncrement ++fdhogcavfnbk
<operator>.assignment j=fdhogcavfnbk-1
<operator>.subtraction n-1
<operator>.assignment fdhogcavfnbk=0
<operator>.greaterEqualsThan j>=0
<operator>.logicalNot !invoked[j]
<operator>.greaterEqualsThan (result=areCombining(invoked[fdhogcavfnbk],invoked[j]))>=0
fprintf fprintf(output,"%c",invoked[fdhogcavfnbk])
<operator>.subtraction fdhogcavfnbk-1
<operator>.assignment invoked[fdhogcavfnbk]=combination[result].elementResult
<operator>.assignment invoked[j]=0
<operator>.lessThan fdhogcavfnbk<p
<operator>.assignment result=areCombining(invoked[fdhogcavfnbk],invoked[j])
fprintf fprintf(output,", ")
areCombining areCombining(invoked[fdhogcavfnbk],invoked[j])
<operator>.lessThan p<fdhogcavfnbk
<operator>.preIncrement ++p
<operator>.assignment p=0
<operator>.logicalAnd invoked[p]&&areOpposed(invoked[fdhogcavfnbk],invoked[p])
areOpposed areOpposed(invoked[fdhogcavfnbk],invoked[p])
<operator>.lessEqualsThan q<=fdhogcavfnbk
<operator>.preIncrement ++q
<operator>.assignment invoked[q]=0
<operator>.assignment q=0
<operator>.addressOf &c
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.addressOf &(combination[fdhogcavfnbk].element1)
<operator>.addressOf &(combination[fdhogcavfnbk].element2)
<operator>.addressOf &(combination[fdhogcavfnbk].elementResult)
<operator>.addressOf &(opposed[fdhogcavfnbk].element1)
<operator>.addressOf &(opposed[fdhogcavfnbk].element2)
<operator>.indirectIndexAccess invoked[p]
<operator>.fieldAccess combination[fdhogcavfnbk].element1
<operator>.fieldAccess combination[fdhogcavfnbk].element2
<operator>.fieldAccess combination[fdhogcavfnbk].elementResult
<operator>.fieldAccess opposed[fdhogcavfnbk].element1
<operator>.fieldAccess opposed[fdhogcavfnbk].element2
<operator>.indirectIndexAccess combination[fdhogcavfnbk]
FIELD_IDENTIFIER element1 element1
<operator>.indirectIndexAccess combination[fdhogcavfnbk]
FIELD_IDENTIFIER element2 element2
<operator>.indirectIndexAccess combination[fdhogcavfnbk]
FIELD_IDENTIFIER elementResult elementResult
<operator>.indirectIndexAccess opposed[fdhogcavfnbk]
FIELD_IDENTIFIER element1 element1
<operator>.indirectIndexAccess opposed[fdhogcavfnbk]
FIELD_IDENTIFIER element2 element2
<operator>.indirectIndexAccess invoked[fdhogcavfnbk]
<operator>.indirectIndexAccess invoked[j]
<operator>.indirectIndexAccess invoked[fdhogcavfnbk]
<operator>.indirectIndexAccess invoked[fdhogcavfnbk]
<operator>.fieldAccess combination[result].elementResult
<operator>.indirectIndexAccess invoked[j]
<operator>.indirectIndexAccess invoked[fdhogcavfnbk]
<operator>.indirectIndexAccess invoked[j]
<operator>.indirectIndexAccess combination[result]
FIELD_IDENTIFIER elementResult elementResult
<operator>.indirectIndexAccess invoked[p]
<operator>.indirectIndexAccess invoked[fdhogcavfnbk]
<operator>.indirectIndexAccess invoked[p]
<operator>.indirectIndexAccess invoked[q]
>>>PDG&108 0->2 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->41 0->43 0->44 0->45 0->46 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->56 0->57 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 2->1 3->1 3->1 3->5 4->1 4->1 4->7 4->18 5->1 5->1 5->6 5->9 5->15 5->34 6->1 6->1 7->1 7->1 8->1 9->1 9->1 9->1 9->9 9->10 9->15 9->16 9->17 9->18 9->18 9->19 9->20 9->23 9->26 9->29 9->31 9->33 9->34 9->34 9->35 9->36 9->37 9->38 9->39 9->48 9->70 9->71 9->72 10->1 10->9 11->8 12->3 12->3 13->4 13->4 14->1 14->9 15->1 15->1 15->16 15->20 15->22 16->1 16->1 16->17 16->23 16->25 17->1 17->1 17->6 17->15 17->26 17->28 17->29 17->48 18->1 18->19 18->34 18->53 19->1 19->7 19->18 19->40 20->1 20->1 20->15 20->20 20->21 20->21 20->22 20->73 20->74 20->75 20->79 20->80 20->81 20->84 20->85 20->86 20->87 20->88 20->89 21->1 21->20 22->1 22->1 22->1 22->1 22->16 23->1 23->1 23->16 23->23 23->24 23->24 23->25 23->76 23->77 23->82 23->83 23->90 23->91 23->92 23->93 24->1 24->23 25->1 25->1 25->1 25->17 26->26 26->27 26->27 26->28 26->28 26->29 26->41 26->41 27->1 27->26 28->1 28->1 28->6 28->15 29->1 29->1 29->29 29->30 29->42 29->44 29->47 29->48 29->50 29->54 29->54 30->1 30->29 31->32 31->33 31->78 32->1 32->31 33->1 33->1 33->45 33->45 33->49 34->1 34->9 34->10 34->40 35->20 36->23 37->26 38->1 38->29 39->1 39->1 39->31 40->1 40->7 40->18 41->1 42->1 42->1 42->42 42->43 42->50 43->1 43->50 44->1 44->1 44->52 44->58 44->60 44->100 44->101 45->1 45->1 45->1 45->45 45->46 45->46 45->57 45->57 45->94 46->1 46->45 47->1 47->1 47->50 48->1 48->17 48->26 48->39 48->39 49->1 49->45 50->42 50->42 50->43 50->44 50->51 50->95 51->1 51->28 51->41 51->42 51->53 51->60 51->64 51->65 52->1 52->1 52->55 52->56 52->61 52->63 52->97 52->98 52->99 52->102 52->103 53->1 53->1 53->19 53->28 53->41 53->51 53->59 53->60 53->64 53->65 54->30 54->47 54->47 54->61 55->1 55->1 55->1 55->28 55->41 55->51 55->53 55->60 55->64 55->65 56->1 56->1 56->28 56->41 56->51 56->53 56->60 56->64 56->65 57->1 57->45 57->46 57->59 58->1 58->1 58->52 59->1 59->19 59->53 60->1 60->1 60->28 60->28 60->41 60->41 60->51 60->51 60->52 60->52 60->53 60->53 60->58 60->58 60->64 60->64 60->65 60->65 61->1 61->30 61->62 61->64 61->66 61->104 62->1 62->61 63->1 63->61 64->1 64->1 64->1 64->28 64->41 64->51 64->53 64->60 64->61 64->62 64->65 64->66 64->69 65->1 65->28 65->41 65->51 65->53 65->60 65->64 65->64 66->1 66->1 66->30 66->66 66->67 66->67 66->68 66->107 67->1 67->66 68->1 68->1 68->28 68->41 68->51 68->53 68->60 68->64 68->65 69->1 69->66 78->31 78->32 94->53 94->57 94->96 104->65 104->105 104->106
>>>Token int main ( void ) { int fdhogcavfnbk , j , k , p , q , result , testCases ; FILE * input , * output ; input = fopen ( " " , " " ) ; output = fopen ( " " , " " ) ; fscanf ( input , " " , & testCases ) ; for ( k = 1 ; testCases >= k ; ++ k ) { fscanf ( input , " " , & c ) ; for ( fdhogcavfnbk = 0 ; fdhogcavfnbk < c ; ++ fdhogcavfnbk ) fscanf ( input , " " , & ( combination [ fdhogcavfnbk ] . element1 ) , & ( combination [ fdhogcavfnbk ] . element2 ) , & ( combination [ fdhogcavfnbk ] . elementResult ) ) ; fscanf ( input , " " , & d ) ; for ( fdhogcavfnbk = 0 ; fdhogcavfnbk < d ; ++ fdhogcavfnbk ) fscanf ( input , " " , & ( opposed [ fdhogcavfnbk ] . element1 ) , & ( opposed [ fdhogcavfnbk ] . element2 ) ) ; fscanf ( input , " " , & n ) ; for ( fdhogcavfnbk = 0 ; fdhogcavfnbk < n ; ++ fdhogcavfnbk ) fscanf ( input , " " , invoked + fdhogcavfnbk ) ; for ( fdhogcavfnbk = 0 ; fdhogcavfnbk < n ; ++ fdhogcavfnbk ) { for ( j = fdhogcavfnbk - 1 ; j >= 0 && ! invoked [ j ] ; -- j ) ; if ( j >= 0 ) { if ( ( result = areCombining ( invoked [ fdhogcavfnbk ] , invoked [ j ] ) ) >= 0 ) { invoked [ fdhogcavfnbk ] = combination [ result ] . elementResult ; invoked [ j ] = 0 ; } else { for ( p = 0 ; p < fdhogcavfnbk ; ++ p ) { if ( invoked [ p ] && areOpposed ( invoked [ fdhogcavfnbk ] , invoked [ p ] ) ) { for ( q = 0 ; q <= fdhogcavfnbk ; ++ q ) invoked [ q ] = 0 ; break ; } } } } } fprintf ( output , " " , k ) ; for ( p = n - 1 ; p >= 0 ; -- p ) if ( invoked [ p ] ) break ; if ( p >= 0 ) { for ( fdhogcavfnbk = 0 ; fdhogcavfnbk <= p ; ++ fdhogcavfnbk ) if ( invoked [ fdhogcavfnbk ] ) { fprintf ( output , " " , invoked [ fdhogcavfnbk ] ) ; if ( fdhogcavfnbk < p ) fprintf ( output , " " ) ; } } fprintf ( output , " " ) ; if ( k < testCases ) fprintf ( output , " \n " ) ; } fclose ( input ) ; fclose ( output ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment fp=fopen("B-small-attempt1.in","r")
<operator>.assignment fp1=fopen("B-small-attempt1.out","w")
fscanf fscanf(fp,"%d",&doeewgmeazyg)
RETURN return 0; return 0;
<operator>.lessThan xdlkazwuervt<doeewgmeazyg
<operator>.postIncrement xdlkazwuervt++
LITERAL 0 return 0;
fopen fopen("B-small-attempt1.in","r")
fopen fopen("B-small-attempt1.out","w")
<operator>.assignment xdlkazwuervt=0
fscanf fscanf(fp,"%d",&c)
fscanf fscanf(fp,"%d",&d)
<operator>.assignment kkltbneydhvg=length2=0
fscanf fscanf(fp,"%d",&n)
fscanf fscanf(fp,"%c",&ch)
fprintf fprintf(fp1,"Case #%d: [",xdlkazwuervt+1)
fprintf fprintf(fp1,"]\n")
<operator>.lessThan j<c
<operator>.postIncrement j++
fscanf fscanf(fp,"%c%c%c%c",&ch,&pair1[j].sspzzqinxuvs,&pair1[j].y,&pair1[j].z)
<operator>.lessThan j<d
<operator>.postIncrement j++
fscanf fscanf(fp,"%c%c%c",&ch,&pair2[j].sspzzqinxuvs,&pair2[j].y)
<operator>.lessThan j<n
<operator>.postIncrement j++
fscanf fscanf(fp,"%c",&kkkpocewuqyd[j])
<operator>.lessThan kkltbneydhvg<n
<operator>.postIncrement kkltbneydhvg++
<operator>.lessThan k<length2-1
<operator>.postIncrement k++
fprintf fprintf(fp1,"%c, ",output[k])
<operator>.notEquals length2!=0
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.assignment length2=0
<operator>.assignment j=0
<operator>.assignment kkltbneydhvg=0
<operator>.assignment ch=kkkpocewuqyd[kkltbneydhvg]
<operator>.assignment flag=0
<operator>.assignment ch2=output[length2-1]
<operator>.assignment flag=0
<operator>.assignment output[length2]=ch
<operator>.postIncrement length2++
<operator>.addition xdlkazwuervt+1
<operator>.assignment k=0
fprintf fprintf(fp1,"%c",output[length2-1])
<operator>.equals length2==0
<operator>.lessThan k<c
<operator>.postIncrement k++
<operator>.equals flag==1
<operator>.lessThan j<length2
<operator>.postIncrement j++
<operator>.equals flag==1
<operator>.subtraction length2-1
<operator>.assignment output[length2]=ch
<operator>.postIncrement length2++
<operator>.assignment k=0
<operator>.assignment j=0
<operator>.assignment ch2=output[j]
<operator>.subtraction length2-1
<operator>.logicalOr pair1[k].sspzzqinxuvs==ch&&pair1[k].y==ch2||pair1[k].sspzzqinxuvs==ch2&&pair1[k].y==ch
<operator>.lessThan k<d
<operator>.postIncrement k++
<operator>.equals flag==1
<operator>.subtraction length2-1
<operator>.assignment output[length2-1]=pair1[k].z
<operator>.assignment flag=1
<operator>.assignment k=0
<operator>.logicalAnd pair1[k].sspzzqinxuvs==ch&&pair1[k].y==ch2
<operator>.logicalAnd pair1[k].sspzzqinxuvs==ch2&&pair1[k].y==ch
<operator>.logicalOr pair2[k].sspzzqinxuvs==ch&&pair2[k].y==ch2||pair2[k].sspzzqinxuvs==ch2&&pair2[k].y==ch
<operator>.equals pair1[k].sspzzqinxuvs==ch
<operator>.equals pair1[k].y==ch2
<operator>.equals pair1[k].sspzzqinxuvs==ch2
<operator>.equals pair1[k].y==ch
<operator>.assignment length2=0
<operator>.assignment flag=1
<operator>.subtraction length2-1
<operator>.logicalAnd pair2[k].sspzzqinxuvs==ch&&pair2[k].y==ch2
<operator>.logicalAnd pair2[k].sspzzqinxuvs==ch2&&pair2[k].y==ch
<operator>.equals pair2[k].sspzzqinxuvs==ch
<operator>.equals pair2[k].y==ch2
<operator>.equals pair2[k].sspzzqinxuvs==ch2
<operator>.equals pair2[k].y==ch
<operator>.addressOf &c
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.addressOf &ch
<operator>.addressOf &ch
<operator>.addressOf &pair1[j].sspzzqinxuvs
<operator>.addressOf &pair1[j].y
<operator>.addressOf &pair1[j].z
<operator>.addressOf &ch
<operator>.addressOf &pair2[j].sspzzqinxuvs
<operator>.addressOf &pair2[j].y
<operator>.addressOf &kkkpocewuqyd[j]
<operator>.indirectIndexAccess output[k]
<operator>.fieldAccess pair1[j].sspzzqinxuvs
<operator>.fieldAccess pair1[j].y
<operator>.fieldAccess pair1[j].z
<operator>.fieldAccess pair2[j].sspzzqinxuvs
<operator>.fieldAccess pair2[j].y
<operator>.indirectIndexAccess kkkpocewuqyd[j]
<operator>.indirectIndexAccess kkkpocewuqyd[kkltbneydhvg]
<operator>.indirectIndexAccess output[length2-1]
<operator>.indirectIndexAccess output[length2]
<operator>.indirectIndexAccess output[length2-1]
<operator>.indirectIndexAccess pair1[j]
FIELD_IDENTIFIER sspzzqinxuvs sspzzqinxuvs
<operator>.indirectIndexAccess pair1[j]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess pair1[j]
FIELD_IDENTIFIER z z
<operator>.indirectIndexAccess pair2[j]
FIELD_IDENTIFIER sspzzqinxuvs sspzzqinxuvs
<operator>.indirectIndexAccess pair2[j]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess output[length2]
<operator>.indirectIndexAccess output[j]
<operator>.indirectIndexAccess output[length2-1]
<operator>.fieldAccess pair1[k].z
<operator>.fieldAccess pair1[k].sspzzqinxuvs
<operator>.fieldAccess pair1[k].y
<operator>.fieldAccess pair1[k].sspzzqinxuvs
<operator>.fieldAccess pair1[k].y
<operator>.indirectIndexAccess pair1[k]
FIELD_IDENTIFIER z z
<operator>.indirectIndexAccess pair1[k]
FIELD_IDENTIFIER sspzzqinxuvs sspzzqinxuvs
<operator>.indirectIndexAccess pair1[k]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess pair1[k]
FIELD_IDENTIFIER sspzzqinxuvs sspzzqinxuvs
<operator>.indirectIndexAccess pair1[k]
FIELD_IDENTIFIER y y
<operator>.fieldAccess pair2[k].sspzzqinxuvs
<operator>.fieldAccess pair2[k].y
<operator>.fieldAccess pair2[k].sspzzqinxuvs
<operator>.fieldAccess pair2[k].y
<operator>.indirectIndexAccess pair2[k]
FIELD_IDENTIFIER sspzzqinxuvs sspzzqinxuvs
<operator>.indirectIndexAccess pair2[k]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess pair2[k]
FIELD_IDENTIFIER sspzzqinxuvs sspzzqinxuvs
<operator>.indirectIndexAccess pair2[k]
FIELD_IDENTIFIER y y
>>>PDG&149 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->40 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->61 0->63 0->64 0->65 0->66 0->68 0->69 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->82 0->83 0->84 0->85 2->1 2->1 2->4 3->1 3->1 3->1 3->17 4->1 4->1 4->1 4->6 4->12 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->12 6->13 6->14 6->15 6->16 6->17 6->17 6->18 6->19 6->22 6->25 6->28 6->30 6->33 6->34 6->35 6->36 6->37 6->38 6->45 6->45 6->46 6->55 6->86 6->87 6->88 6->89 7->1 7->6 8->5 9->2 9->2 10->3 10->3 11->1 11->6 12->1 12->1 12->13 12->19 12->21 12->49 13->1 13->1 13->15 13->22 13->24 13->63 14->1 14->1 15->1 15->1 15->16 15->25 15->28 16->1 16->1 16->1 16->12 16->21 16->24 16->27 16->43 16->56 16->73 16->76 16->82 16->85 17->1 17->1 17->18 17->32 17->47 18->1 18->1 18->17 19->1 19->1 19->12 19->19 19->20 19->20 19->21 19->49 19->90 19->91 19->92 19->93 19->99 19->100 19->101 19->109 19->110 19->111 19->112 19->113 19->114 20->1 20->19 21->1 21->1 21->1 21->1 21->13 21->16 21->24 22->1 22->1 22->13 22->22 22->23 22->23 22->24 22->63 22->94 22->95 22->96 22->102 22->103 22->115 22->116 22->117 22->118 23->1 23->22 24->1 24->1 24->1 24->15 24->16 25->1 25->1 25->25 25->26 25->26 25->27 25->28 25->97 25->104 26->1 26->25 27->1 27->1 27->1 27->12 28->1 28->1 28->1 28->15 28->25 28->28 28->29 28->29 28->39 28->48 28->105 29->1 29->28 30->1 30->1 30->1 30->30 30->31 30->31 30->32 30->55 30->98 31->1 31->30 32->1 32->1 32->18 32->47 33->1 33->1 33->47 33->66 33->66 33->108 34->19 35->22 36->14 36->48 36->55 37->1 37->25 38->1 38->28 39->1 39->1 39->1 39->16 39->21 39->24 39->43 39->56 39->73 39->82 40->1 40->51 41->1 41->1 41->1 41->74 41->75 42->1 42->54 42->65 43->1 43->1 43->1 44->1 44->48 44->55 46->1 46->30 47->1 47->1 47->18 47->41 48->1 48->40 48->41 48->49 48->51 48->56 48->57 48->57 48->58 48->61 48->61 48->106 48->119 49->1 49->1 49->12 49->19 49->50 49->62 49->70 49->73 49->123 49->129 49->130 50->1 50->49 51->1 51->1 51->42 51->52 51->54 51->59 52->1 52->1 52->44 52->48 52->53 52->55 52->60 52->63 52->65 52->69 52->120 53->1 53->52 54->1 54->1 54->43 54->44 54->107 55->30 55->30 55->33 56->1 56->1 56->1 57->1 57->48 57->55 58->49 59->1 59->52 60->1 60->1 60->1 60->83 60->84 61->48 61->52 61->55 61->79 62->1 62->1 62->1 62->49 62->50 62->67 62->68 62->79 62->121 62->122 62->127 62->128 63->1 63->1 63->13 63->22 63->64 63->72 63->80 63->82 63->137 63->141 63->142 64->1 64->63 65->52 65->53 65->54 66->1 67->1 67->1 67->41 67->47 68->1 68->51 69->63 70->1 70->1 70->62 70->62 70->71 70->75 70->125 70->133 70->134 71->1 71->1 71->62 71->62 72->1 72->1 72->1 72->63 72->64 72->77 72->78 73->1 73->16 73->21 73->24 73->43 73->70 73->70 73->74 73->75 73->76 73->82 73->124 73->131 73->132 74->1 74->70 74->70 74->75 74->76 75->1 75->71 75->71 75->74 75->76 75->126 75->135 75->136 76->1 76->16 76->21 76->24 76->43 76->71 76->71 76->73 76->82 77->1 77->44 77->48 77->52 77->55 78->1 78->65 79->48 79->52 79->55 80->1 80->1 80->72 80->72 80->81 80->84 80->139 80->145 80->146 81->1 81->1 81->72 81->72 82->1 82->16 82->21 82->24 82->43 82->80 82->80 82->83 82->84 82->85 82->138 82->143 82->144 83->1 83->80 83->80 83->84 83->85 84->1 84->81 84->81 84->83 84->85 84->140 84->147 84->148 85->1 85->16 85->21 85->24 85->43 85->81 85->81 85->82
>>>Token int main ( ) { int doeewgmeazyg , c , d , n ; int xdlkazwuervt , j , k ; struct { char sspzzqinxuvs , y , z ; } pair1 [ 100 ] ; struct { char sspzzqinxuvs , y ; } pair2 [ 100 ] ; char kkkpocewuqyd [ 100 ] , output [ 100 ] , ch , ch2 ; int kkltbneydhvg , length2 , flag ; FILE * fp ; FILE * fp1 ; fp = fopen ( " " , " " ) ; fp1 = fopen ( " " , " " ) ; fscanf ( fp , " " , & doeewgmeazyg ) ; for ( xdlkazwuervt = 0 ; xdlkazwuervt < doeewgmeazyg ; xdlkazwuervt ++ ) { fscanf ( fp , " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) fscanf ( fp , " " , & ch , & pair1 [ j ] . sspzzqinxuvs , & pair1 [ j ] . y , & pair1 [ j ] . z ) ; fscanf ( fp , " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) fscanf ( fp , " " , & ch , & pair2 [ j ] . sspzzqinxuvs , & pair2 [ j ] . y ) ; kkltbneydhvg = length2 = 0 ; fscanf ( fp , " " , & n ) ; fscanf ( fp , " " , & ch ) ; for ( j = 0 ; j < n ; j ++ ) fscanf ( fp , " " , & kkkpocewuqyd [ j ] ) ; for ( kkltbneydhvg = 0 ; kkltbneydhvg < n ; kkltbneydhvg ++ ) { ch = kkkpocewuqyd [ kkltbneydhvg ] ; if ( length2 == 0 ) { output [ length2 ] = ch ; length2 ++ ; continue ; } flag = 0 ; ch2 = output [ length2 - 1 ] ; for ( k = 0 ; k < c ; k ++ ) { if ( pair1 [ k ] . sspzzqinxuvs == ch && pair1 [ k ] . y == ch2 || pair1 [ k ] . sspzzqinxuvs == ch2 && pair1 [ k ] . y == ch ) { output [ length2 - 1 ] = pair1 [ k ] . z ; flag = 1 ; break ; } } if ( flag == 1 ) continue ; flag = 0 ; for ( j = 0 ; j < length2 ; j ++ ) { ch2 = output [ j ] ; for ( k = 0 ; k < d ; k ++ ) { if ( pair2 [ k ] . sspzzqinxuvs == ch && pair2 [ k ] . y == ch2 || pair2 [ k ] . sspzzqinxuvs == ch2 && pair2 [ k ] . y == ch ) { length2 = 0 ; flag = 1 ; break ; } } if ( flag == 1 ) break ; } if ( flag == 1 ) continue ; output [ length2 ] = ch ; length2 ++ ; } fprintf ( fp1 , " " , xdlkazwuervt + 1 ) ; for ( k = 0 ; k < length2 - 1 ; k ++ ) fprintf ( fp1 , " " , output [ k ] ) ; if ( length2 != 0 ) fprintf ( fp1 , " " , output [ length2 - 1 ] ) ; fprintf ( fp1 , " \n " ) ; } return 0 ; }
>>>Func
METHOD xdhefpsudbvm
METHOD_RETURN void
PARAM int tlgxkeghpzes
RETURN return ; return ;
<operator>.lessThan bbnarlizsehy<tlgxkeghpzes
<operator>.postIncrement bbnarlizsehy++
<operator>.assignment table[bbnarlizsehy]=0
<operator>.lessEqualsThan bbnarlizsehy<=tlgxkeghpzes
<operator>.postIncrement bbnarlizsehy++
<operator>.assignment bbnarlizsehy=0
<operator>.expressionList bbnarlizsehy=1 tqatbcebbemi=-1
<operator>.assignment table[tqatbcebbemi]=bbnarlizsehy
<operator>.lessThan counter<bbnarlizsehy
<operator>.postIncrement counter++
<operator>.assignment bbnarlizsehy=1
<operator>.assignment tqatbcebbemi=-1
<operator>.assignment counter=0
<operator>.minus -1
<operator>.assignment tqatbcebbemi=(tqatbcebbemi+1)%tlgxkeghpzes
<operator>.modulo (tqatbcebbemi+1)%tlgxkeghpzes
<operator>.addition tqatbcebbemi+1
<operator>.indirectIndexAccess table[bbnarlizsehy]
<operator>.indirectIndexAccess table[tqatbcebbemi]
<operator>.indirectIndexAccess table[tqatbcebbemi]
>>>PDG&24 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->19 0->20 2->4 3->1 4->1 4->4 4->5 4->5 4->6 4->7 4->21 5->1 5->4 6->1 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->12 7->16 7->19 7->22 8->1 8->7 9->1 9->4 10->1 10->1 10->1 11->1 11->1 12->1 12->1 12->8 12->11 12->12 12->13 12->13 12->18 12->19 12->20 12->23 13->1 13->12 14->7 14->10 15->1 15->1 15->10 15->19 15->20 16->1 16->12 17->10 17->15 18->1 18->1 18->1 18->19 18->20 19->1 19->7 19->18 19->18 23->18 23->19 23->20 23->23
>>>Token void xdhefpsudbvm ( int tlgxkeghpzes ) { int bbnarlizsehy , tqatbcebbemi , counter ; for ( bbnarlizsehy = 0 ; bbnarlizsehy < tlgxkeghpzes ; bbnarlizsehy ++ ) table [ bbnarlizsehy ] = 0 ; for ( bbnarlizsehy = 1 , tqatbcebbemi = -1 ; bbnarlizsehy <= tlgxkeghpzes ; bbnarlizsehy ++ ) { for ( counter = 0 ; counter < bbnarlizsehy ; counter ++ ) { do tqatbcebbemi = ( tqatbcebbemi + 1 ) % tlgxkeghpzes ; while ( table [ tqatbcebbemi ] ) ; } table [ tqatbcebbemi ] = bbnarlizsehy ; } return ; }
>>>Func
METHOD osamtpfrabad
METHOD_RETURN char
PARAM char rialufhxnpzl
PARAM char obnwiyqgwbae
PARAM trio xkmrrcfetitl[36]
PARAM int wqetliochzrp
RETURN return '!'; return '!';
<operator>.lessThan mcfcwnmlmbue<wqetliochzrp
<operator>.postIncrement mcfcwnmlmbue++
LITERAL '!' return '!';
<operator>.assignment mcfcwnmlmbue=0
printf printf("ANTES RETORNO: %c",xkmrrcfetitl[mcfcwnmlmbue][1],xkmrrcfetitl[mcfcwnmlmbue][0])
<operator>.logicalOr ((rialufhxnpzl==xkmrrcfetitl[mcfcwnmlmbue][0])&&(obnwiyqgwbae==xkmrrcfetitl[mcfcwnmlmbue][1]))||((rialufhxnpzl==xkmrrcfetitl[mcfcwnmlmbue][1])&&(obnwiyqgwbae==xkmrrcfetitl[mcfcwnmlmbue][0]))
printf printf("RETORNO: %c",xkmrrcfetitl[mcfcwnmlmbue][2])
RETURN return  xkmrrcfetitl[mcfcwnmlmbue][2]; return  xkmrrcfetitl[mcfcwnmlmbue][2];
<operator>.logicalAnd (rialufhxnpzl==xkmrrcfetitl[mcfcwnmlmbue][0])&&(obnwiyqgwbae==xkmrrcfetitl[mcfcwnmlmbue][1])
<operator>.logicalAnd (rialufhxnpzl==xkmrrcfetitl[mcfcwnmlmbue][1])&&(obnwiyqgwbae==xkmrrcfetitl[mcfcwnmlmbue][0])
<operator>.equals rialufhxnpzl==xkmrrcfetitl[mcfcwnmlmbue][0]
<operator>.equals obnwiyqgwbae==xkmrrcfetitl[mcfcwnmlmbue][1]
<operator>.equals rialufhxnpzl==xkmrrcfetitl[mcfcwnmlmbue][1]
<operator>.equals obnwiyqgwbae==xkmrrcfetitl[mcfcwnmlmbue][0]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue][1]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue][0]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue][2]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue][2]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue][0]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue][1]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue][1]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue][0]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue]
<operator>.indirectIndexAccess xkmrrcfetitl[mcfcwnmlmbue]
>>>PDG&37 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->17 0->18 0->19 0->20 2->17 3->1 3->18 3->20 4->1 5->7 6->1 7->1 7->1 7->1 7->6 7->8 7->11 7->12 7->15 7->17 7->21 7->22 7->23 7->24 7->27 7->33 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->17 11->18 11->19 12->1 12->1 12->1 12->7 12->8 12->13 12->14 12->25 12->26 12->31 12->32 13->1 13->1 14->1 15->1 15->1 15->12 15->12 15->16 15->19 15->29 15->35 16->1 16->1 16->12 16->12 17->1 17->1 17->11 17->15 17->15 17->18 17->19 17->20 17->28 17->34 18->1 18->1 18->11 18->15 18->15 18->19 18->20 19->1 19->1 19->11 19->16 19->16 19->17 19->20 19->30 19->36 20->1 20->1 20->11 20->16 20->16 20->18
>>>Token char osamtpfrabad ( char rialufhxnpzl , char obnwiyqgwbae , trio xkmrrcfetitl [ 36 ] , int wqetliochzrp ) { int mcfcwnmlmbue ; for ( mcfcwnmlmbue = 0 ; mcfcwnmlmbue < wqetliochzrp ; mcfcwnmlmbue ++ ) { printf ( " " , xkmrrcfetitl [ mcfcwnmlmbue ] [ 1 ] , xkmrrcfetitl [ mcfcwnmlmbue ] [ 0 ] ) ; if ( ( ( rialufhxnpzl == xkmrrcfetitl [ mcfcwnmlmbue ] [ 0 ] ) && ( obnwiyqgwbae == xkmrrcfetitl [ mcfcwnmlmbue ] [ 1 ] ) ) || ( ( rialufhxnpzl == xkmrrcfetitl [ mcfcwnmlmbue ] [ 1 ] ) && ( obnwiyqgwbae == xkmrrcfetitl [ mcfcwnmlmbue ] [ 0 ] ) ) ) { printf ( " " , xkmrrcfetitl [ mcfcwnmlmbue ] [ 2 ] ) ; return xkmrrcfetitl [ mcfcwnmlmbue ] [ 2 ] ; } } return ' ' ; }
>>>Func
METHOD aitqvubdkgwq
METHOD_RETURN int
PARAM HashTableIterator *rhvqfdceyhtn
RETURN return rhvqfdceyhtn->next_entry!=NULL; return rhvqfdceyhtn->next_entry!=NULL;
<operator>.notEquals rhvqfdceyhtn->next_entry!=NULL
>>>PDG&5 0->2 0->4 2->1 3->1 4->1 4->1 4->1 4->3
>>>Token int aitqvubdkgwq ( HashTableIterator * rhvqfdceyhtn ) { return rhvqfdceyhtn -> next_entry != NULL ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&T)
RETURN return 0; return 0;
<operator>.lessThan kyutkmcnqbiy<T
<operator>.postIncrement kyutkmcnqbiy++
LITERAL 0 return 0;
<operator>.assignment kyutkmcnqbiy=0
scanf scanf("%d",&C)
scanf scanf("%d",&D)
scanf scanf("%d",&N)
scanf scanf("%s",ylhlyvqegeyy)
<operator>.assignment top=-1
<operator>.assignment xpabdtcdghkp=-1
<operator>.assignment fopp2=-1
cuxticimkahf cuxticimkahf("Case #%d: [",kyutkmcnqbiy+1)
<operator>.equals C==1
<operator>.equals D==1
<operator>.equals C==0
<operator>.equals D==0
<operator>.lessThan cur<N
<operator>.postIncrement cur++
<operator>.lessThan pr<top
<operator>.postIncrement pr++
<operator>.notEquals top!=-1
scanf scanf("%s",comb)
scanf scanf("%s",opp)
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.assignment comb[0]='0'
<operator>.equals opp[0]=='1'
<operator>.assignment cur=0
<operator>.assignment ch=ylhlyvqegeyy[cur]
<operator>.assignment stack[++top]=ch
<operator>.addition kyutkmcnqbiy+1
<operator>.assignment pr=0
cuxticimkahf cuxticimkahf("%c, ",stack[pr])
cuxticimkahf cuxticimkahf("%c]\n",stack[top])
<operator>.logicalOr (stack[top]==comb[0]&&stack[top-1]==comb[1]&&top!=0)||(stack[top]==comb[1]&&stack[top-1]==comb[0]&&top!=0)
<operator>.logicalAnd stack[top]==opp[0]&&xpabdtcdghkp==-1
<operator>.logicalAnd stack[top]==opp[1]&&fopp2==-1
<operator>.logicalAnd xpabdtcdghkp!=-1&&fopp2!=-1
<operator>.minus -1
cuxticimkahf cuxticimkahf ("]\n")
<operator>.assignment stack[top]=0
<operator>.postDecrement top--
<operator>.assignment stack[top]=comb[2]
<operator>.assignment xpabdtcdghkp=top
<operator>.assignment fopp2=top
<operator>.assignment top=-1
<operator>.assignment xpabdtcdghkp=-1
<operator>.assignment fopp2=-1
<operator>.preIncrement ++top
<operator>.logicalAnd stack[top]==comb[0]&&stack[top-1]==comb[1]&&top!=0
<operator>.logicalAnd stack[top]==comb[1]&&stack[top-1]==comb[0]&&top!=0
<operator>.equals xpabdtcdghkp==top
<operator>.equals fopp2==top
<operator>.equals stack[top]==opp[0]
<operator>.equals xpabdtcdghkp==-1
<operator>.equals stack[top]==opp[1]
<operator>.equals fopp2==-1
<operator>.notEquals xpabdtcdghkp!=-1
<operator>.notEquals fopp2!=-1
<operator>.logicalAnd stack[top]==comb[0]&&stack[top-1]==comb[1]
<operator>.notEquals top!=0
<operator>.logicalAnd stack[top]==comb[1]&&stack[top-1]==comb[0]
<operator>.notEquals top!=0
<operator>.assignment xpabdtcdghkp=-1
<operator>.assignment fopp2=-1
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.equals stack[top]==comb[0]
<operator>.equals stack[top-1]==comb[1]
<operator>.equals stack[top]==comb[1]
<operator>.equals stack[top-1]==comb[0]
<operator>.minus -1
<operator>.minus -1
<operator>.subtraction top-1
<operator>.subtraction top-1
<operator>.addressOf &C
<operator>.addressOf &D
<operator>.addressOf &N
<operator>.indirectIndexAccess comb[0]
<operator>.indirectIndexAccess opp[0]
<operator>.indirectIndexAccess ylhlyvqegeyy[cur]
<operator>.indirectIndexAccess stack[++top]
<operator>.indirectIndexAccess stack[pr]
<operator>.indirectIndexAccess stack[top]
<operator>.indirectIndexAccess stack[top]
<operator>.indirectIndexAccess stack[top]
<operator>.indirectIndexAccess comb[2]
<operator>.indirectIndexAccess stack[top]
<operator>.indirectIndexAccess opp[0]
<operator>.indirectIndexAccess stack[top]
<operator>.indirectIndexAccess opp[1]
<operator>.indirectIndexAccess stack[top]
<operator>.indirectIndexAccess comb[0]
<operator>.indirectIndexAccess stack[top-1]
<operator>.indirectIndexAccess comb[1]
<operator>.indirectIndexAccess stack[top]
<operator>.indirectIndexAccess comb[1]
<operator>.indirectIndexAccess stack[top-1]
<operator>.indirectIndexAccess comb[0]
>>>PDG&109 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->34 0->35 0->36 0->37 0->38 0->43 0->44 0->45 0->46 0->48 0->49 0->53 0->56 0->57 0->59 0->61 0->62 0->63 0->65 0->67 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->81 0->82 0->83 0->84 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->15 4->16 4->17 4->18 4->19 4->20 4->22 4->24 4->27 4->28 4->29 4->32 4->35 4->35 4->36 4->43 4->85 4->86 4->87 5->1 5->4 6->3 7->1 7->4 8->1 8->16 8->18 9->1 9->17 9->19 10->1 10->20 11->1 11->33 12->1 12->22 12->53 13->1 13->1 13->56 13->59 13->62 14->1 14->1 14->57 14->61 14->63 15->1 15->1 16->1 16->18 16->25 17->1 17->19 17->26 18->1 18->1 18->8 18->16 18->30 18->88 19->1 19->1 19->9 19->17 19->31 19->89 20->1 20->1 20->1 20->10 20->20 20->21 20->21 20->33 20->34 20->39 20->40 20->41 20->42 20->53 20->54 20->58 20->60 20->62 20->64 20->72 20->77 20->90 20->91 20->97 20->98 20->99 20->100 20->101 20->102 21->1 21->20 22->1 22->1 22->22 22->23 22->23 22->24 22->37 22->92 23->1 23->22 24->1 24->1 24->1 24->38 24->44 24->93 25->1 25->47 25->77 25->78 25->79 25->80 26->1 26->31 26->58 26->60 27->12 28->13 29->14 30->1 30->1 30->25 30->77 31->1 31->1 31->26 31->58 32->1 32->20 33->1 33->1 33->34 34->1 34->1 34->1 36->1 36->22 37->1 37->1 38->1 38->1 38->77 39->1 39->1 39->1 39->45 39->46 39->47 39->56 39->57 39->94 39->95 39->96 40->1 40->1 40->1 40->48 41->1 41->1 41->1 41->49 42->1 42->1 42->1 42->50 42->51 42->52 42->74 42->75 42->76 43->24 44->1 45->1 46->1 46->56 47->1 47->1 47->58 48->1 48->62 49->1 49->1 49->57 49->61 49->63 50->1 50->22 50->53 51->1 51->1 51->56 51->59 51->62 52->1 52->1 52->57 52->61 52->63 53->22 53->46 53->48 53->49 53->65 53->67 53->83 53->84 54->1 54->1 54->39 54->39 54->55 54->55 54->66 54->79 54->105 54->106 55->1 55->1 55->39 55->39 55->54 56->1 56->57 56->59 56->62 56->68 56->81 57->1 57->1 57->22 57->48 57->49 57->53 57->61 57->63 57->69 57->82 58->1 58->26 58->31 58->40 58->40 58->59 58->60 58->70 59->40 59->40 59->62 60->1 60->1 60->26 60->38 60->41 60->41 60->61 60->71 60->77 61->1 61->41 61->41 61->57 61->63 62->1 62->42 62->42 62->56 62->59 62->63 62->73 63->1 63->42 63->42 63->57 63->61 64->1 64->1 64->54 64->54 64->65 65->22 65->46 65->48 65->49 65->53 65->54 65->54 65->67 65->84 66->1 66->1 66->55 66->55 66->67 67->22 67->46 67->48 67->49 67->53 67->55 67->55 68->1 68->59 68->62 69->1 69->1 69->57 69->61 69->63 70->59 71->61 72->62 73->63 74->50 75->51 76->52 77->1 77->25 77->58 77->64 77->64 77->78 77->79 77->80 77->83 77->103 77->104 78->1 78->1 78->25 78->64 78->64 78->79 78->80 79->1 79->25 79->58 79->66 79->66 79->78 79->80 79->84 79->107 79->108 80->1 80->1 80->25 80->66 80->66 80->77 80->78 81->68 82->69 83->22 83->46 83->48 83->49 83->53 83->65 83->67 83->84 84->22 84->46 84->48 84->49 84->53 84->67
>>>Token int main ( ) { char ylhlyvqegeyy [ 20 ] , stack [ 20 ] , ch , comb [ 3 ] , opp [ 2 ] ; int xpabdtcdghkp , fopp2 , top , N , C , T , D ; int kyutkmcnqbiy , cur , pr ; scanf ( " " , & T ) ; for ( kyutkmcnqbiy = 0 ; kyutkmcnqbiy < T ; kyutkmcnqbiy ++ ) { scanf ( " " , & C ) ; if ( C == 1 ) { scanf ( " " , comb ) ; } scanf ( " " , & D ) ; if ( D == 1 ) { scanf ( " " , opp ) ; } scanf ( " " , & N ) ; scanf ( " " , ylhlyvqegeyy ) ; top = -1 ; xpabdtcdghkp = -1 ; fopp2 = -1 ; if ( C == 0 ) { comb [ 0 ] = ' ' ; } if ( D == 0 ) { opp [ 0 ] == ' ' ; } for ( cur = 0 ; cur < N ; cur ++ ) { ch = ylhlyvqegeyy [ cur ] ; stack [ ++ top ] = ch ; if ( ( stack [ top ] == comb [ 0 ] && stack [ top - 1 ] == comb [ 1 ] && top != 0 ) || ( stack [ top ] == comb [ 1 ] && stack [ top - 1 ] == comb [ 0 ] && top != 0 ) ) { stack [ top ] = 0 ; top -- ; stack [ top ] = comb [ 2 ] ; if ( xpabdtcdghkp == top ) { xpabdtcdghkp = -1 ; } if ( fopp2 == top ) { fopp2 = -1 ; } } if ( stack [ top ] == opp [ 0 ] && xpabdtcdghkp == -1 ) { xpabdtcdghkp = top ; } if ( stack [ top ] == opp [ 1 ] && fopp2 == -1 ) { fopp2 = top ; } if ( xpabdtcdghkp != -1 && fopp2 != -1 ) { top = -1 ; xpabdtcdghkp = -1 ; fopp2 = -1 ; } } cuxticimkahf ( " " , kyutkmcnqbiy + 1 ) ; for ( pr = 0 ; pr < top ; pr ++ ) { cuxticimkahf ( " " , stack [ pr ] ) ; } if ( top != -1 ) cuxticimkahf ( " \n " , stack [ top ] ) ; else cuxticimkahf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD lgpleqebqkgw
METHOD_RETURN void
PARAM char *element_list
PARAM int sznqujiheqbm
printf printf("[")
printf printf("%c]",element_list[sznqujiheqbm-1])
<operator>.lessThan rrdsczhyjxzf<sznqujiheqbm-1
<operator>.preIncrement ++rrdsczhyjxzf
<operator>.assignment rrdsczhyjxzf=0
printf printf("%c, ",element_list[rrdsczhyjxzf])
<operator>.subtraction sznqujiheqbm-1
<operator>.subtraction sznqujiheqbm-1
<operator>.indirectIndexAccess element_list[rrdsczhyjxzf]
>>>PDG&13 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->1 2->5 2->9 3->10 4->1 5->1 5->1 6->1 6->1 6->6 6->7 6->7 6->9 6->10 6->12 7->1 7->6 8->1 8->6 9->1 9->1 10->6 10->6 10->11 11->1
>>>Token void lgpleqebqkgw ( char * element_list , int sznqujiheqbm ) { short rrdsczhyjxzf ; printf ( " " ) ; for ( rrdsczhyjxzf = 0 ; rrdsczhyjxzf < sznqujiheqbm - 1 ; ++ rrdsczhyjxzf ) { printf ( " " , element_list [ rrdsczhyjxzf ] ) ; } printf ( " " , element_list [ sznqujiheqbm - 1 ] ) ; }
>>>Func
METHOD cvjovwaoquqr
METHOD_RETURN void
<operator>.assignment *in_file=NULL
<operator>.assignment *out_file=NULL
<operator>.assignment *test_file=NULL
<operator>.assignment cdzhuuexxkbt=0
<operator>.assignment jeefwrkxtaff=0
<operator>.assignment xydqhbxzjaekN=0
<operator>.assignment zspmiyekdzhq=0
<operator>.assignment wqqeoftnhrpa=0
<operator>.assignment ieouwnzkjipm=0
<operator>.assignment in_file=fopen("source/input.txt","r")
nvoslogufhmj nvoslogufhmj(NULL==in_file)
printf printf("error while opening input file.")
RETURN return ; return ;
fopen fopen("source/input.txt","r")
<operator>.equals NULL==in_file
<operator>.lessThan jeefwrkxtaff<cdzhuuexxkbt
<operator>.postIncrement jeefwrkxtaff++
fscanf fscanf(in_file,"%I64d %d %d\n",&N,&zspmiyekdzhq,&wqqeoftnhrpa)
nvoslogufhmj nvoslogufhmj((zspmiyekdzhq!=100)&&(wqqeoftnhrpa==100))
UNKNOWN,),)
UNKNOWN else  nvoslogufhmj ((zspmiyekdzhq!=0)&&(wqqeoftnhrpa==0)){ieouwnzkjipm=0;} else  nvoslogufhmj ((zspmiyekdzhq!=0)&&(wqqeoftnhrpa==0)){ieouwnzkjipm=0;}
UNKNOWN else  nvoslogufhmj (zspmiyekdzhq==0){ieouwnzkjipm=1;} else  nvoslogufhmj (zspmiyekdzhq==0){ieouwnzkjipm=1;}
UNKNOWN else  nvoslogufhmj (100/hcf_tab[zspmiyekdzhq]>N){ieouwnzkjipm=0;} else  nvoslogufhmj (100/hcf_tab[zspmiyekdzhq]>N){ieouwnzkjipm=0;}
UNKNOWN else {ieouwnzkjipm=1;} else {ieouwnzkjipm=1;}
fprintf fprintf(out_file,"Case #%d: ",jeefwrkxtaff+1)
nvoslogufhmj nvoslogufhmj(ieouwnzkjipm)
UNKNOWN,),)
UNKNOWN else {fprintf(out_file,"Broken\n");} else {fprintf(out_file,"Broken\n");}
<operator>.addressOf &N
<operator>.addressOf &zspmiyekdzhq
<operator>.addressOf &wqqeoftnhrpa
<operator>.logicalAnd (zspmiyekdzhq!=100)&&(wqqeoftnhrpa==100)
<operator>.assignment ieouwnzkjipm=0
<operator>.addition jeefwrkxtaff+1
fprintf fprintf(out_file,"Possible\n")
<operator>.notEquals zspmiyekdzhq!=100
<operator>.equals wqqeoftnhrpa==100
>>>PDG&39 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->13 0->14 0->15 0->16 2->1 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 9->1 9->1 10->1 10->1 11->1 11->1 11->16 12->1 12->1 13->1 14->1 15->11 15->11 16->1 16->1 16->12 16->12 17->17 17->18 17->19 17->20 17->21 17->22 17->23 17->24 17->25 17->26 17->27 17->28 17->29 17->30 17->31 17->32 17->33 17->34 17->35 17->36 17->37 37->38
>>>Token void cvjovwaoquqr ( ) { FILE * in_file = NULL ; FILE * out_file = NULL ; FILE * test_file = NULL ; int cdzhuuexxkbt = 0 ; int jeefwrkxtaff = 0 ; xydqhbxzjaek xydqhbxzjaekN = 0 ; int zspmiyekdzhq = 0 ; int wqqeoftnhrpa = 0 ; int ieouwnzkjipm = 0 ; in_file = fopen ( " " , " " ) ; nvoslogufhmj ( NULL == in_file )  { printf ( " " ) ; return ; } out_file = fopen ( " " , " " ) ; nvoslogufhmj ( NULL == out_file )  { printf ( " " ) ; return ; } test_file = fopen ( " " , " " ) ; fflush ( in_file ) ; fscanf ( in_file , " " , & cdzhuuexxkbt ) ; for ( jeefwrkxtaff = 0 ; jeefwrkxtaff < cdzhuuexxkbt ; jeefwrkxtaff ++ ) { fscanf ( in_file , " \n " , & N , & zspmiyekdzhq , & wqqeoftnhrpa ) ; nvoslogufhmj ( ( zspmiyekdzhq != 100 ) && ( wqqeoftnhrpa == 100 ) )  { ieouwnzkjipm = 0 ; } else nvoslogufhmj ( ( zspmiyekdzhq != 0 ) && ( wqqeoftnhrpa = = 0 ) ) { ieouwnzkjipm = 0  ; } else nvoslogufhmj ( zspmiyekdzhq == 0 ) { ieouwnzkjipm = 1 ; } else nvoslogufhmj ( 100 / hcf_tab [ zspmiyekdzhq ] > N ) { ieouwnzkjipm = 0 ; } else { ieouwnzkjipm = 1 ; } fprintf ( out_file , " " , jeefwrkxtaff + 1 ) ; nvoslogufhmj ( ieouwnzkjipm ) { fprintf ( out_file , " \n " ) ; } else  { fprintf ( out_file , " \n " ) ; } } return ; }
>>>Func
METHOD hktivbjxxggi
METHOD_RETURN char
PARAM long djrwtnccmouw
PARAM long bqcopayyhrfp
PARAM long kawwdpqadxia
<operator>.assignment rexzfotoecmr=0
RETURN return rexzfotoecmr; return rexzfotoecmr;
<operator>.logicalAnd kawwdpqadxia==100&&bqcopayyhrfp!=100
<operator>.lessThan azhzlwiytwzb<djrwtnccmouw+1
<operator>.postIncrement azhzlwiytwzb++
IDENTIFIER rexzfotoecmr return rexzfotoecmr;
RETURN return 0; return 0;
<operator>.assignment azhzlwiytwzb=1
<operator>.equals kawwdpqadxia==100
<operator>.notEquals bqcopayyhrfp!=100
LITERAL 0 return 0;
<operator>.addition djrwtnccmouw+1
<operator>.modulo 100%azhzlwiytwzb
<operator>.lessThan m<djrwtnccmouw+1
<operator>.postIncrement m++
<operator>.assignment m=0
<operator>.assignment base=100 *m/azhzlwiytwzb
<operator>.addition djrwtnccmouw+1
<operator>.notEquals base!=bqcopayyhrfp
<operator>.equals bqcopayyhrfp==kawwdpqadxia
<operator>.logicalAnd kawwdpqadxia!=100&&kawwdpqadxia!=0
<operator>.division 100 *m/azhzlwiytwzb
<operator>.assignment rexzfotoecmr=1
<operator>.assignment rexzfotoecmr=1
<operator>.multiplication 100 *m
<operator>.notEquals kawwdpqadxia!=100
<operator>.notEquals kawwdpqadxia!=0
>>>PDG&32 0->2 0->3 0->4 0->5 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->31 2->1 2->8 2->16 3->1 3->14 3->23 4->13 5->1 5->1 5->10 6->1 7->1 7->1 7->1 7->6 7->8 7->11 7->12 7->16 8->8 8->9 8->16 8->17 8->17 9->8 10->6 11->1 12->8 13->1 13->7 13->7 13->14 13->24 14->1 14->7 14->7 14->23 15->11 17->9 17->18 17->20 17->22 17->26 18->21 18->23 18->26 18->29 18->29 19->18 20->18 21->23 23->18 23->19 23->22 23->24 23->24 24->23 24->25 24->27 24->30 24->30 25->18 25->19 25->22 25->28 26->9 26->21 26->21 27->10 28->10 29->19 29->26 29->26 30->24 30->25 30->25 30->31 30->31 31->24 31->25 31->25
>>>Token char hktivbjxxggi ( long djrwtnccmouw , long bqcopayyhrfp , long kawwdpqadxia ) { char rexzfotoecmr = 0 ; long azhzlwiytwzb , m , d , g , base ; int muwiqnpajljv ; if ( kawwdpqadxia == 100 && bqcopayyhrfp != 100 ) return 0 ; for ( azhzlwiytwzb = 1 ; azhzlwiytwzb < djrwtnccmouw + 1 ; azhzlwiytwzb ++ ) { if ( 100 % azhzlwiytwzb ) continue ; for ( m = 0 ; m < djrwtnccmouw + 1 ; m ++ ) { base = 100 * m / azhzlwiytwzb ; if ( base != bqcopayyhrfp ) continue ; if ( bqcopayyhrfp == kawwdpqadxia ) { rexzfotoecmr = 1 ; break ; } if ( kawwdpqadxia != 100 && kawwdpqadxia != 0 ) { rexzfotoecmr = 1 ; break ; } } } return rexzfotoecmr ; }
>>>Func
METHOD gzccspiypipt
METHOD_RETURN void
<operator>.assignment z=100
<operator>.assignment opzludvduxdh=1
scanf scanf("%d %d %d ",&rgqzgfdsozzr,&pnciavsoasyo,&Gp)
<operator>.assignment odbcqnygfgxg=pnciavsoasyo
del del(&odbcqnygfgxg,&z)
<operator>.assignment opzludvduxdh=z<=rgqzgfdsozzr&&Gp!=100&&Gp!=0
printf printf("Case #%d: ",caseCtr+1)
printf printf(opzludvduxdh?"Possible":"Broken")
printf printf("\n")
<operator>.logicalAnd !opzludvduxdh&&pnciavsoasyo==0&&Gp==0
<operator>.logicalAnd !opzludvduxdh&&pnciavsoasyo==100&&Gp==100
<operator>.logicalAnd z<=rgqzgfdsozzr&&Gp!=100&&Gp!=0
<operator>.assignment opzludvduxdh=1
<operator>.assignment opzludvduxdh=1
<operator>.addition caseCtr+1
<operator>.conditional opzludvduxdh?"Possible":"Broken"
<operator>.logicalAnd z<=rgqzgfdsozzr&&Gp!=100
<operator>.notEquals Gp!=0
<operator>.logicalAnd !opzludvduxdh&&pnciavsoasyo==0
<operator>.equals Gp==0
<operator>.logicalAnd !opzludvduxdh&&pnciavsoasyo==100
<operator>.equals Gp==100
<operator>.lessEqualsThan z<=rgqzgfdsozzr
<operator>.notEquals Gp!=100
<operator>.logicalNot !opzludvduxdh
<operator>.equals pnciavsoasyo==0
<operator>.logicalNot !opzludvduxdh
<operator>.equals pnciavsoasyo==100
>>>PDG&30 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->14 0->15 0->16 0->17 0->19 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->29 2->1 2->6 2->24 3->1 4->1 4->1 4->1 4->24 5->1 5->1 5->1 5->6 6->1 6->1 6->1 6->24 7->1 7->1 7->26 8->1 8->1 9->1 9->1 10->1 11->1 11->1 11->1 11->14 12->1 12->1 12->1 12->15 13->1 13->1 13->7 13->7 14->1 14->28 15->1 16->1 17->1 18->1 18->1 18->13 18->13 18->19 19->1 19->13 19->13 19->21 19->23 20->1 20->11 20->11 20->21 21->1 21->11 21->11 21->23 22->1 22->1 22->12 22->12 22->23 23->1 23->12 23->12 24->1 24->1 24->18 24->18 24->25 25->1 25->18 25->18 25->19 25->21 25->23 26->20 26->27 26->28 27->1 27->20 27->20 27->29 28->22 28->29 29->1 29->22 29->22
>>>Token void gzccspiypipt ( ) { int dwcrkqxmnqcp ; int rgqzgfdsozzr ; int pnciavsoasyo , Gp ; int odbcqnygfgxg , z = 100 ; int opzludvduxdh = 1 ; scanf ( " " , & rgqzgfdsozzr , & pnciavsoasyo , & Gp ) ; odbcqnygfgxg = pnciavsoasyo ; del ( & odbcqnygfgxg , & z ) ; opzludvduxdh = z <= rgqzgfdsozzr && Gp != 100 && Gp != 0 ; if ( ! opzludvduxdh && pnciavsoasyo == 0 && Gp == 0 ) opzludvduxdh = 1 ; if ( ! opzludvduxdh && pnciavsoasyo == 100 && Gp == 100 ) opzludvduxdh = 1 ; printf ( " " , caseCtr + 1 ) ; printf ( opzludvduxdh ? " " : " " ) ; printf ( " \n " ) ; }
>>>Func
METHOD getline
METHOD_RETURN dlvxaykpnvrzklvkcwuicbqj
PARAM klvkcwuicbqj *buffer
<operator>.assignment *fwtulylbvupj=buffer?buffer:private_buffer
<operator>.assignment *p=fwtulylbvupj
LITERAL 1 while (1)
<operator>.conditional buffer?buffer:private_buffer
<operator>.assignment *p++=xncbekackyjy
<operator>.assignment xncbekackyjy=getchar()
LITERAL '\r' <empty>
LITERAL '\n' <empty>
<operator>.assignment *p=0
RETURN return fwtulylbvupj; return fwtulylbvupj;
IDENTIFIER cqgsgknkbmqj <empty>
RETURN return spdjwbgzcdhp; return spdjwbgzcdhp;
IDENTIFIER fwtulylbvupj return fwtulylbvupj;
IDENTIFIER spdjwbgzcdhp return spdjwbgzcdhp;
<operator>.postIncrement p++
<operator>.indirection *p++
getchar getchar()
<operator>.indirection *p
>>>PDG&21 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->16 0->17 2->3 2->6 3->1 3->1 3->4 3->15 4->1 4->1 4->1 4->17 6->1 6->1 7->1 7->1 8->1 8->1 8->1 8->7 8->7 8->8 8->11 8->12 8->14 8->17 8->18 8->19 8->20 11->1 11->1 12->1 14->1 15->12 16->14 17->1
>>>Token lse dlvxaykpnvrzklvkcwuicbqj * getline ( klvkcwuicbqj * buffer ) { static klvkcwuicbqjprivate_buffer  [ BUFFER_SZ ] ; klvkcwuicbqj * fwtulylbvupj = buffer ? buffer : private_buffer ; klvkcwuicbqj * p = fwtulylbvupj ; int xncbekackyjy ; while ( 1 ) { switch ( ( xncbekackyjy = getchar ( ) ) ) { case ' \r ' : case ' \n ' : * p = 0 ; return fwtulylbvupj ; case cqgsgknkbmqj : return spdjwbgzcdhp ; } * p ++ = xncbekackyjy ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment x=0
freopen freopen("A-small-attempt0.in","r",stdin)
freopen freopen("A-small-attempt0.out","w",stdout)
scanf scanf("%d",&t)
RETURN return 0; return 0;
<operator>.postDecrement t--
LITERAL 0 return 0;
<operator>.postIncrement x++
scanf scanf("%I64d%d%d",&lmnihxfrkmxf,&egqzesjjdcjp,&pg)
<operator>.logicalOr egqzesjjdcjp!=100&&pg==100||egqzesjjdcjp!=0&&pg==0
<operator>.lessEqualsThan i<=lmnihxfrkmxf
<operator>.postIncrement i++
<operator>.equals i==lmnihxfrkmxf+1
printf printf("Case #%d: Broken\n",x)
<operator>.assignment i=1
printf printf("Case #%d: Broken\n",x)
<operator>.logicalAnd egqzesjjdcjp!=100&&pg==100
<operator>.logicalAnd egqzesjjdcjp!=0&&pg==0
<operator>.equals i *egqzesjjdcjp%100==0
<operator>.addition lmnihxfrkmxf+1
printf printf("Case #%d: Possible\n",x)
<operator>.notEquals egqzesjjdcjp!=100
<operator>.equals pg==100
<operator>.notEquals egqzesjjdcjp!=0
<operator>.equals pg==0
<operator>.modulo i *egqzesjjdcjp%100
<operator>.multiplication i *egqzesjjdcjp
<operator>.addressOf &lmnihxfrkmxf
<operator>.addressOf &egqzesjjdcjp
<operator>.addressOf &pg
>>>PDG&32 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 2->1 2->1 2->9 3->1 3->1 4->1 4->1 5->1 5->7 6->1 7->1 7->1 7->7 7->9 7->10 7->11 7->18 7->23 7->29 7->30 7->31 8->6 9->1 9->15 9->17 9->22 10->1 10->1 10->1 10->12 10->14 10->21 11->1 11->1 11->1 11->12 11->14 11->15 11->16 11->21 12->1 12->10 12->14 12->14 12->20 12->21 12->27 12->28 12->28 13->1 13->12 14->1 14->1 14->1 14->17 14->22 15->1 15->1 15->9 16->1 16->12 17->1 17->1 17->9 18->1 18->1 18->11 18->11 18->19 18->25 19->1 19->1 19->11 19->11 20->1 20->1 20->12 20->13 21->1 22->1 22->1 22->9 23->1 23->18 23->18 23->24 23->25 23->28 24->1 24->18 24->18 24->26 25->1 25->19 25->19 25->23 25->26 25->28 26->1 26->19 26->19 26->24 27->1 27->20 27->20 28->1 28->13 28->14 28->23 28->27 28->27
>>>Token int main ( ) { int egqzesjjdcjp , pg , t , x = 0 ; __int64 lmnihxfrkmxf , i , j , k ; freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; scanf ( " " , & t ) ; while ( t -- ) { x ++ ; scanf ( " " , & lmnihxfrkmxf , & egqzesjjdcjp , & pg ) ; if ( egqzesjjdcjp != 100 && pg == 100 || egqzesjjdcjp != 0 && pg == 0 ) { printf ( " \n " , x ) ; continue ; } for ( i = 1 ; i <= lmnihxfrkmxf ; i ++ ) { if ( i * egqzesjjdcjp % 100 == 0 ) break ; } if ( i == lmnihxfrkmxf + 1 ) { printf ( " \n " , x ) ; continue ; } else { printf ( " \n " , x ) ; continue ; } } return 0 ; }
>>>Func
METHOD ziesoqoyjwzdload_and_init_magicka_data
METHOD_RETURN ANY
PARAM FILE *fp
PARAM char rfjeabusufam[9][9]
PARAM int oymoufafjtnp[9][9]
<operator>.assignment itkmmedwxxnx=0
<operator>.assignment atbpmibeyrim=0
fscanf fscanf(fp,"%d \n",&itkmmedwxxnx)
fscanf fscanf(fp,"%d \n",&atbpmibeyrim)
<operator>.lessThan mepgdrbgwcwl<itkmmedwxxnx
<operator>.postIncrement mepgdrbgwcwl++
<operator>.lessThan mepgdrbgwcwl<atbpmibeyrim
<operator>.postIncrement mepgdrbgwcwl++
<operator>.assignment mepgdrbgwcwl=0
fscanf fscanf(fp,"%c%c%c ",&kkcnqtwkcimv,&c2,&c3)
<operator>.assignment rfjeabusufam[char_idx[kkcnqtwkcimv-'A']][char_idx[c2-'A']]=c3
<operator>.assignment rfjeabusufam[char_idx[c2-'A']][char_idx[kkcnqtwkcimv-'A']]=c3
<operator>.assignment mepgdrbgwcwl=0
fscanf fscanf(fp,"%c%c ",&kkcnqtwkcimv,&c2)
<operator>.assignment oymoufafjtnp[char_idx[kkcnqtwkcimv-'A']][char_idx[c2-'A']]=1
<operator>.assignment oymoufafjtnp[char_idx[c2-'A']][char_idx[kkcnqtwkcimv-'A']]=1
<operator>.subtraction c2-'A'
<operator>.subtraction kkcnqtwkcimv-'A'
<operator>.subtraction c2-'A'
<operator>.subtraction kkcnqtwkcimv-'A'
<operator>.subtraction kkcnqtwkcimv-'A'
<operator>.subtraction c2-'A'
<operator>.subtraction kkcnqtwkcimv-'A'
<operator>.subtraction c2-'A'
<operator>.addressOf &kkcnqtwkcimv
<operator>.addressOf &c2
<operator>.addressOf &c3
<operator>.indirectIndexAccess rfjeabusufam[char_idx[kkcnqtwkcimv-'A']][char_idx[c2-'A']]
<operator>.indirectIndexAccess rfjeabusufam[char_idx[c2-'A']][char_idx[kkcnqtwkcimv-'A']]
<operator>.addressOf &kkcnqtwkcimv
<operator>.addressOf &c2
<operator>.indirectIndexAccess oymoufafjtnp[char_idx[kkcnqtwkcimv-'A']][char_idx[c2-'A']]
<operator>.indirectIndexAccess oymoufafjtnp[char_idx[c2-'A']][char_idx[kkcnqtwkcimv-'A']]
<operator>.indirectIndexAccess rfjeabusufam[char_idx[kkcnqtwkcimv-'A']]
<operator>.indirectIndexAccess char_idx[c2-'A']
<operator>.indirectIndexAccess rfjeabusufam[char_idx[c2-'A']]
<operator>.indirectIndexAccess char_idx[kkcnqtwkcimv-'A']
<operator>.indirectIndexAccess oymoufafjtnp[char_idx[kkcnqtwkcimv-'A']]
<operator>.indirectIndexAccess char_idx[c2-'A']
<operator>.indirectIndexAccess oymoufafjtnp[char_idx[c2-'A']]
<operator>.indirectIndexAccess char_idx[kkcnqtwkcimv-'A']
<operator>.indirectIndexAccess char_idx[kkcnqtwkcimv-'A']
<operator>.indirectIndexAccess char_idx[c2-'A']
<operator>.indirectIndexAccess char_idx[kkcnqtwkcimv-'A']
<operator>.indirectIndexAccess char_idx[c2-'A']
>>>PDG&50 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 2->7 3->1 4->1 5->1 5->7 5->9 6->1 6->8 6->11 7->1 7->1 7->8 7->9 7->14 8->1 8->1 8->1 8->11 8->18 9->1 9->1 9->9 9->10 9->10 9->14 9->15 9->16 9->21 9->22 9->25 9->26 9->29 9->30 9->31 9->32 9->33 9->38 9->39 9->40 9->41 9->46 9->47 10->1 10->9 11->1 11->1 11->1 11->11 11->12 11->12 11->18 11->19 11->20 11->23 11->24 11->27 11->28 11->34 11->35 11->36 11->37 11->42 11->43 11->44 11->45 11->48 11->49 12->1 12->11 13->9 14->8 14->15 14->16 14->18 14->18 14->21 14->22 14->23 14->25 14->26 14->27 17->1 17->11 18->23 18->24 18->27 18->28 21->26 22->14 22->18 22->25 22->27 23->28 24->18 24->27 25->22 26->14 26->18 26->21 26->23 27->24 28->18 28->23
>>>Token static ziesoqoyjwzdload_and_init_magicka_data ( FILE *  fp , char rfjeabusufam [ 9 ] [ 9 ] , int oymoufafjtnp [ 9 ] [ 9 ] ) { int itkmmedwxxnx = 0 ; int mepgdrbgwcwl ; char kkcnqtwkcimv , c2 , c3 ; int atbpmibeyrim = 0 ; fscanf ( fp , " \n " , & itkmmedwxxnx ) ; for ( mepgdrbgwcwl = 0 ; mepgdrbgwcwl < itkmmedwxxnx ; mepgdrbgwcwl ++ ) { fscanf ( fp , " " , & kkcnqtwkcimv , & c2 , & c3 ) ; rfjeabusufam [ char_idx [ kkcnqtwkcimv - ' ' ] ] [ char_idx [ c2 - ' ' ] ] = c3 ; rfjeabusufam [ char_idx [ c2 - ' ' ] ] [ char_idx [ kkcnqtwkcimv - ' ' ] ] = c3 ; } fscanf ( fp , " \n " , & atbpmibeyrim ) ; for ( mepgdrbgwcwl = 0 ; mepgdrbgwcwl < atbpmibeyrim ; mepgdrbgwcwl ++ ) { fscanf ( fp , " " , & kkcnqtwkcimv , & c2 ) ; oymoufafjtnp [ char_idx [ kkcnqtwkcimv - ' ' ] ] [ char_idx [ c2 - ' ' ] ] = 1 ; oymoufafjtnp [ char_idx [ c2 - ' ' ] ] [ char_idx [ kkcnqtwkcimv - ' ' ] ] = 1 ; } }
>>>Func
METHOD ugikkrkaclbp
METHOD_RETURN void
PARAM int tayhmvunueww
PARAM char ynwstuurbbol
<operator>.assignment out[tayhmvunueww]=ynwstuurbbol
<operator>.postDecrement N_ans--
<operator>.lessEqualsThan (kwgvcuvsoxxj+1)<=N_ans
<operator>.postIncrement kwgvcuvsoxxj++
<operator>.assignment kwgvcuvsoxxj=tayhmvunueww+1
<operator>.assignment out[kwgvcuvsoxxj]=out[kwgvcuvsoxxj+1]
<operator>.addition kwgvcuvsoxxj+1
<operator>.addition tayhmvunueww+1
<operator>.addition kwgvcuvsoxxj+1
<operator>.indirectIndexAccess out[kwgvcuvsoxxj]
<operator>.indirectIndexAccess out[kwgvcuvsoxxj+1]
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 2->8 2->11 3->4 4->1 4->1 4->1 5->1 5->1 6->1 6->1 6->5 6->6 6->7 6->9 6->10 6->12 6->13 6->14 7->1 7->6 7->10 7->12 8->1 8->1 8->6 8->7 8->10 8->12 9->1 9->1 9->1 10->1 11->1
>>>Token void ugikkrkaclbp ( int tayhmvunueww , char ynwstuurbbol ) { int kwgvcuvsoxxj ; out [ tayhmvunueww ] = ynwstuurbbol ; for ( kwgvcuvsoxxj = tayhmvunueww + 1 ; ( kwgvcuvsoxxj + 1 ) <= N_ans ; kwgvcuvsoxxj ++ ) { out [ kwgvcuvsoxxj ] = out [ kwgvcuvsoxxj + 1 ] ; } N_ans -- ; }
>>>Func
METHOD lqshqwngqvpb
METHOD_RETURN void
<operator>.assignment N=200
<operator>.assignment pwwqhnpdhfew=3
<operator>.assignment viyqnxyzbdue=20
<operator>.assignment **X=(double **)malloc(N *sizeof(double *))
<operator>.assignment **W=(double **)malloc(viyqnxyzbdue *sizeof(double *))
<operator>.lessThan fqfqmchqgkfp<max(viyqnxyzbdue,N)
<operator>.postIncrement fqfqmchqgkfp++
test_3d_classes test_3d_classes(X,N)
save_nd_data save_nd_data("test3.csv",X,N,pwwqhnpdhfew)
save_nd_data save_nd_data("w31.csv",W,viyqnxyzbdue,pwwqhnpdhfew)
kohonen_som_tracer kohonen_som_tracer(X,W,N,pwwqhnpdhfew,viyqnxyzbdue,0.01)
save_nd_data save_nd_data("w32.csv",W,viyqnxyzbdue,pwwqhnpdhfew)
<operator>.lessThan fqfqmchqgkfp<max(viyqnxyzbdue,N)
<operator>.postIncrement fqfqmchqgkfp++
free free(X)
free free(W)
<operator>.cast (double **)malloc(N *sizeof(double *))
<operator>.cast (double **)malloc(viyqnxyzbdue *sizeof(double *))
max max(viyqnxyzbdue,N)
max max(viyqnxyzbdue,N)
malloc malloc(N *sizeof(double *))
malloc malloc(viyqnxyzbdue *sizeof(double *))
<operator>.multiplication N *sizeof(double *)
<operator>.multiplication viyqnxyzbdue *sizeof(double *)
<operator>.sizeOf sizeof(double *)
>>>PDG&27 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->20 0->21 0->24 0->25 2->1 2->24 3->1 3->10 4->1 4->25 5->1 5->1 5->9 6->1 6->1 6->11 7->8 8->14 9->1 9->10 9->10 10->1 10->11 10->12 10->12 11->1 11->12 11->12 11->12 12->1 12->13 12->13 12->13 12->16 12->21 13->1 13->1 13->17 13->21 14->1 14->1 14->15 15->1 15->1 16->1 17->1 18->1 19->1 20->7 20->7 20->9 20->11 21->1 21->1 21->14 21->14 22->1 22->5 22->18 23->1 23->6 23->19 24->20 24->22 25->20 25->23 26->1
>>>Token void lqshqwngqvpb ( ) { int amrazncsvcpq , N = 200 ; int pwwqhnpdhfew = 3 ; int viyqnxyzbdue = 20 ; double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; double * * W = ( double * * ) malloc ( viyqnxyzbdue * sizeof ( double * ) ) ; crswyjlbafku ( int  fqfqmchqgkfp = 0 ; fqfqmchqgkfp < max ( viyqnxyzbdue , N ) ; fqfqmchqgkfp ++ ) { if ( fqfqmchqgkfp < N ) X [ fqfqmchqgkfp ] = ( double * ) malloc ( pwwqhnpdhfew * sizeof ( double ) ) ; if ( fqfqmchqgkfp < viyqnxyzbdue ) { W [ fqfqmchqgkfp ] = ( double * ) malloc ( pwwqhnpdhfew * sizeof ( double ) ) ; def odgnxtdtnkyxndif  crswyjlbafku ( amrazncsvcpq < missing ' ' >= 0  ; amrazncsvcpq < pwwqhnpdhfew ; amrazncsvcpq ++ ) W [ fqfqmchqgkfp ] [ amrazncsvcpq ] = _random ( -1 , 1 ) ; } } test_3d_classes ( X , N ) ; save_nd_data ( " " , X , N , pwwqhnpdhfew ) ; save_nd_data ( " " , W , viyqnxyzbdue , pwwqhnpdhfew ) ; kohonen_som_tracer ( X , W , N , pwwqhnpdhfew , viyqnxyzbdue , 0.01 ) ; save_nd_data ( " " , W , viyqnxyzbdue , pwwqhnpdhfew ) ; crswyjlbafku ( int  fqfqmchqgkfp = 0 ; fqfqmchqgkfp < max ( viyqnxyzbdue , N ) ; fqfqmchqgkfp ++ ) { if ( fqfqmchqgkfp < N ) free ( X [ fqfqmchqgkfp ] ) ; if ( fqfqmchqgkfp < viyqnxyzbdue ) free ( W [ fqfqmchqgkfp ] ) ; } free ( X ) ; free ( W ) ; }
>>>Func
METHOD ipltittsnqjx
METHOD_RETURN char
PARAM char xoajqrnoeria
PARAM char sighezbjukwe
PARAM int bngkxquenjrz
RETURN return 0; return 0;
<operator>.lessThan dlfbkauarmjy<bngkxquenjrz
<operator>.postIncrement dlfbkauarmjy++
LITERAL 0 return 0;
<operator>.assignment dlfbkauarmjy=0
<operator>.logicalOr (xoajqrnoeria==tgzgwobsmwgh[dlfbkauarmjy][0]&&sighezbjukwe==tgzgwobsmwgh[dlfbkauarmjy][1])||(xoajqrnoeria==tgzgwobsmwgh[dlfbkauarmjy][1]&&sighezbjukwe==tgzgwobsmwgh[dlfbkauarmjy][0])
RETURN return tgzgwobsmwgh[dlfbkauarmjy][2]; return tgzgwobsmwgh[dlfbkauarmjy][2];
<operator>.logicalAnd xoajqrnoeria==tgzgwobsmwgh[dlfbkauarmjy][0]&&sighezbjukwe==tgzgwobsmwgh[dlfbkauarmjy][1]
<operator>.logicalAnd xoajqrnoeria==tgzgwobsmwgh[dlfbkauarmjy][1]&&sighezbjukwe==tgzgwobsmwgh[dlfbkauarmjy][0]
<operator>.equals xoajqrnoeria==tgzgwobsmwgh[dlfbkauarmjy][0]
<operator>.equals sighezbjukwe==tgzgwobsmwgh[dlfbkauarmjy][1]
<operator>.equals xoajqrnoeria==tgzgwobsmwgh[dlfbkauarmjy][1]
<operator>.equals sighezbjukwe==tgzgwobsmwgh[dlfbkauarmjy][0]
<operator>.indirectIndexAccess tgzgwobsmwgh[dlfbkauarmjy][2]
<operator>.indirectIndexAccess tgzgwobsmwgh[dlfbkauarmjy][0]
<operator>.indirectIndexAccess tgzgwobsmwgh[dlfbkauarmjy][1]
<operator>.indirectIndexAccess tgzgwobsmwgh[dlfbkauarmjy][1]
<operator>.indirectIndexAccess tgzgwobsmwgh[dlfbkauarmjy][0]
<operator>.indirectIndexAccess tgzgwobsmwgh[dlfbkauarmjy]
<operator>.indirectIndexAccess tgzgwobsmwgh[dlfbkauarmjy]
<operator>.indirectIndexAccess tgzgwobsmwgh[dlfbkauarmjy]
<operator>.indirectIndexAccess tgzgwobsmwgh[dlfbkauarmjy]
<operator>.indirectIndexAccess tgzgwobsmwgh[dlfbkauarmjy]
>>>PDG&28 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->14 0->15 0->16 0->17 2->14 3->1 3->15 3->17 4->6 5->1 6->1 6->1 6->1 6->5 6->7 6->10 6->12 6->14 6->19 6->24 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->1 10->6 10->7 10->11 10->18 10->23 11->1 12->1 12->1 12->10 12->10 12->13 12->16 12->21 12->26 13->1 13->1 13->10 13->10 14->1 14->1 14->12 14->12 14->15 14->16 14->17 14->20 14->25 15->1 15->1 15->12 15->12 15->16 15->17 16->1 16->1 16->13 16->13 16->14 16->15 16->17 16->22 16->27 17->1 17->1 17->13 17->13 17->14 17->15
>>>Token char ipltittsnqjx ( char xoajqrnoeria , char sighezbjukwe , int bngkxquenjrz ) { int dlfbkauarmjy ; for ( dlfbkauarmjy = 0 ; dlfbkauarmjy < bngkxquenjrz ; dlfbkauarmjy ++ ) { if ( ( xoajqrnoeria == tgzgwobsmwgh [ dlfbkauarmjy ] [ 0 ] && sighezbjukwe == tgzgwobsmwgh [ dlfbkauarmjy ] [ 1 ] ) || ( xoajqrnoeria == tgzgwobsmwgh [ dlfbkauarmjy ] [ 1 ] && sighezbjukwe == tgzgwobsmwgh [ dlfbkauarmjy ] [ 0 ] ) ) return tgzgwobsmwgh [ dlfbkauarmjy ] [ 2 ] ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&tebcrlpvlbti)
RETURN return 0; return 0;
<operator>.lessThan vrmzgomssdfk<tebcrlpvlbti
<operator>.postIncrement vrmzgomssdfk++
LITERAL 0 return 0;
<operator>.assignment vrmzgomssdfk=0
scanf scanf("%d",&mpfkqjhceule)
printf printf("Case #%d:\n",vrmzgomssdfk+1)
<operator>.lessThan utcbuwxjcpld<mpfkqjhceule
<operator>.postIncrement utcbuwxjcpld++
<operator>.lessThan utcbuwxjcpld<mpfkqjhceule
<operator>.postIncrement utcbuwxjcpld++
<operator>.lessThan utcbuwxjcpld<mpfkqjhceule
<operator>.postIncrement utcbuwxjcpld++
<operator>.lessThan utcbuwxjcpld<mpfkqjhceule
<operator>.postIncrement utcbuwxjcpld++
<operator>.lessThan utcbuwxjcpld<mpfkqjhceule
<operator>.postIncrement utcbuwxjcpld++
printf printf("%.12lf\n",0.25 *myholvbemtoy[utcbuwxjcpld]+0.5 *uujdboxgatfc[utcbuwxjcpld]+0.25 *bmpknwhysura[utcbuwxjcpld])
<operator>.assignment utcbuwxjcpld=0
<operator>.assignment fqtlimlavjgo=0
<operator>.assignment aysbqnzqdkco=0
scanf scanf("%s",&cipzfnaloqec[utcbuwxjcpld])
<operator>.assignmentPlus aysbqnzqdkco+=fqtlimlavjgo
<operator>.assignment myholvbemtoy[utcbuwxjcpld]=(double)fqtlimlavjgo/(double)aysbqnzqdkco
<operator>.assignment utcbuwxjcpld=0
<operator>.assignment aysbqnzqdkco=0
<operator>.assignment fqtlimlavjgo=0
<operator>.assignmentPlus aysbqnzqdkco+=fqtlimlavjgo
<operator>.assignment utcbuwxjcpld=0
<operator>.assignment uujdboxgatfc[utcbuwxjcpld]=0.0
<operator>.assignment aysbqnzqdkco=0
<operator>.assignmentDivision uujdboxgatfc[utcbuwxjcpld]/=aysbqnzqdkco
<operator>.assignment utcbuwxjcpld=0
<operator>.assignment bmpknwhysura[utcbuwxjcpld]=0.0
<operator>.assignment aysbqnzqdkco=0
<operator>.assignmentDivision bmpknwhysura[utcbuwxjcpld]/=aysbqnzqdkco
<operator>.addition vrmzgomssdfk+1
<operator>.assignment utcbuwxjcpld=0
<operator>.lessThan j<mpfkqjhceule
<operator>.postIncrement j++
<operator>.lessThan j<mpfkqjhceule
<operator>.postIncrement j++
<operator>.lessThan j<mpfkqjhceule
<operator>.postIncrement j++
<operator>.lessThan j<mpfkqjhceule
<operator>.postIncrement j++
<operator>.lessThan j<mpfkqjhceule
<operator>.postIncrement j++
<operator>.addition 0.25 *myholvbemtoy[utcbuwxjcpld]+0.5 *uujdboxgatfc[utcbuwxjcpld]+0.25 *bmpknwhysura[utcbuwxjcpld]
<operator>.assignment j=0
<operator>.division (double)fqtlimlavjgo/(double)aysbqnzqdkco
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.assignment ulvkcrpgxllk[utcbuwxjcpld][j]=0
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.addition 0.25 *myholvbemtoy[utcbuwxjcpld]+0.5 *uujdboxgatfc[utcbuwxjcpld]
<operator>.multiplication 0.25 *bmpknwhysura[utcbuwxjcpld]
<operator>.equals cipzfnaloqec[utcbuwxjcpld][j]=='1'
<operator>.equals cipzfnaloqec[utcbuwxjcpld][j]=='0'
<operator>.cast (double)fqtlimlavjgo
<operator>.cast (double)aysbqnzqdkco
<operator>.equals cipzfnaloqec[utcbuwxjcpld][j]=='1'
<operator>.equals cipzfnaloqec[utcbuwxjcpld][j]=='0'
<operator>.equals cipzfnaloqec[utcbuwxjcpld][j]=='1'
<operator>.equals cipzfnaloqec[utcbuwxjcpld][j]=='0'
<operator>.equals cipzfnaloqec[utcbuwxjcpld][j]=='1'
<operator>.equals cipzfnaloqec[utcbuwxjcpld][j]=='0'
<operator>.equals cipzfnaloqec[utcbuwxjcpld][j]=='0'
<operator>.equals cipzfnaloqec[utcbuwxjcpld][j]=='1'
<operator>.multiplication 0.25 *myholvbemtoy[utcbuwxjcpld]
<operator>.multiplication 0.5 *uujdboxgatfc[utcbuwxjcpld]
<operator>.postIncrement fqtlimlavjgo++
<operator>.postIncrement aysbqnzqdkco++
<operator>.postIncrement fqtlimlavjgo++
<operator>.postIncrement aysbqnzqdkco++
<operator>.assignment ulvkcrpgxllk[utcbuwxjcpld][j]=(double)(fqtlimlavjgo-1)/(double)(aysbqnzqdkco-1)
<operator>.assignment ulvkcrpgxllk[utcbuwxjcpld][j]=(double)(fqtlimlavjgo)/(double)(aysbqnzqdkco-1)
<operator>.postIncrement aysbqnzqdkco++
<operator>.assignmentPlus uujdboxgatfc[utcbuwxjcpld]+=ulvkcrpgxllk[j][utcbuwxjcpld]
<operator>.postIncrement aysbqnzqdkco++
<operator>.assignmentPlus uujdboxgatfc[utcbuwxjcpld]+=ulvkcrpgxllk[j][utcbuwxjcpld]
<operator>.postIncrement aysbqnzqdkco++
<operator>.assignmentPlus bmpknwhysura[utcbuwxjcpld]+=uujdboxgatfc[j]
<operator>.postIncrement aysbqnzqdkco++
<operator>.assignmentPlus bmpknwhysura[utcbuwxjcpld]+=uujdboxgatfc[j]
<operator>.division (double)(fqtlimlavjgo-1)/(double)(aysbqnzqdkco-1)
<operator>.division (double)(fqtlimlavjgo)/(double)(aysbqnzqdkco-1)
<operator>.cast (double)(fqtlimlavjgo-1)
<operator>.cast (double)(aysbqnzqdkco-1)
<operator>.cast (double)(fqtlimlavjgo)
<operator>.cast (double)(aysbqnzqdkco-1)
<operator>.subtraction fqtlimlavjgo-1
<operator>.subtraction aysbqnzqdkco-1
<operator>.subtraction aysbqnzqdkco-1
<operator>.addressOf &mpfkqjhceule
<operator>.addressOf &cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess myholvbemtoy[utcbuwxjcpld]
<operator>.indirectIndexAccess uujdboxgatfc[utcbuwxjcpld]
<operator>.indirectIndexAccess uujdboxgatfc[utcbuwxjcpld]
<operator>.indirectIndexAccess bmpknwhysura[utcbuwxjcpld]
<operator>.indirectIndexAccess bmpknwhysura[utcbuwxjcpld]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess bmpknwhysura[utcbuwxjcpld]
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess ulvkcrpgxllk[utcbuwxjcpld][j]
<operator>.indirectIndexAccess myholvbemtoy[utcbuwxjcpld]
<operator>.indirectIndexAccess uujdboxgatfc[utcbuwxjcpld]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld][j]
<operator>.indirectIndexAccess ulvkcrpgxllk[utcbuwxjcpld]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess ulvkcrpgxllk[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess ulvkcrpgxllk[utcbuwxjcpld][j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess uujdboxgatfc[utcbuwxjcpld]
<operator>.indirectIndexAccess ulvkcrpgxllk[j][utcbuwxjcpld]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess uujdboxgatfc[utcbuwxjcpld]
<operator>.indirectIndexAccess ulvkcrpgxllk[j][utcbuwxjcpld]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess bmpknwhysura[utcbuwxjcpld]
<operator>.indirectIndexAccess uujdboxgatfc[j]
<operator>.indirectIndexAccess cipzfnaloqec[utcbuwxjcpld]
<operator>.indirectIndexAccess bmpknwhysura[utcbuwxjcpld]
<operator>.indirectIndexAccess uujdboxgatfc[j]
<operator>.indirectIndexAccess ulvkcrpgxllk[utcbuwxjcpld]
<operator>.indirectIndexAccess ulvkcrpgxllk[utcbuwxjcpld]
<operator>.indirectIndexAccess ulvkcrpgxllk[j]
<operator>.indirectIndexAccess ulvkcrpgxllk[j]
UNKNOWN double double
UNKNOWN double double
UNKNOWN double double
UNKNOWN double double
>>>PDG&151 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->81 0->83 0->85 0->87 0->90 0->93 0->95 0->96 0->97 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->9 4->10 4->12 4->14 4->16 4->18 4->21 4->27 4->31 4->35 4->39 4->39 4->40 4->98 5->1 5->4 6->3 7->1 7->4 8->1 8->10 8->12 8->14 8->16 8->18 8->41 8->43 8->45 8->47 8->49 9->1 9->1 10->10 10->11 10->11 10->12 10->22 10->23 10->24 10->25 10->26 10->41 10->41 10->52 10->53 10->63 10->64 10->99 10->100 10->105 10->107 10->108 11->1 11->10 12->12 12->13 12->13 12->14 12->28 12->29 12->30 12->43 12->43 12->45 12->54 12->55 13->1 13->12 14->14 14->15 14->15 14->16 14->32 14->33 14->34 14->47 14->47 14->57 14->101 14->102 15->1 15->14 16->16 16->17 16->17 16->18 16->36 16->37 16->38 16->49 16->49 16->58 16->103 16->104 17->1 17->16 18->1 18->1 18->1 18->8 18->10 18->18 18->19 18->19 18->20 18->51 18->59 18->60 18->73 18->74 18->106 18->110 18->111 19->1 19->18 20->1 20->1 21->10 22->1 22->25 22->53 22->63 22->75 23->1 23->25 23->76 24->1 25->1 25->53 25->64 26->1 26->1 26->1 26->73 27->12 28->1 28->30 28->78 29->1 29->30 29->77 29->90 29->93 29->95 30->1 30->1 30->1 30->96 30->97 31->14 32->1 32->34 32->82 32->84 33->1 33->34 33->81 33->83 34->1 34->1 34->1 34->74 35->16 36->1 36->38 36->86 36->88 37->1 37->38 37->85 37->87 38->1 38->1 38->1 38->60 40->1 40->18 41->1 41->1 41->10 41->41 41->42 41->42 41->61 41->62 41->112 41->113 41->123 41->124 42->1 42->41 43->43 43->44 43->44 43->45 43->65 43->66 43->114 43->115 43->125 43->126 44->1 44->43 45->1 45->1 45->12 45->45 45->46 45->46 45->56 45->67 45->68 45->109 45->116 45->117 45->118 45->127 45->129 46->1 46->45 47->1 47->1 47->14 47->47 47->48 47->48 47->69 47->70 47->119 47->120 47->131 47->134 48->1 48->47 49->1 49->1 49->16 49->49 49->50 49->50 49->71 49->72 49->121 49->122 49->137 49->140 50->1 50->49 51->1 51->1 52->1 52->41 53->1 53->1 53->26 53->26 54->43 55->1 55->45 56->1 56->1 57->1 57->47 58->1 58->49 59->1 59->1 60->1 60->20 60->20 60->51 60->51 61->1 61->62 61->75 62->1 62->1 62->24 62->61 62->65 62->67 62->69 62->71 62->76 63->1 64->1 65->1 65->66 65->77 66->1 66->1 66->24 66->61 66->65 66->67 66->69 66->71 66->78 67->1 67->68 67->79 67->89 67->91 67->92 67->95 67->96 67->128 67->143 67->147 67->148 68->1 68->1 68->24 68->61 68->65 68->67 68->69 68->71 68->80 68->90 68->93 68->94 68->97 68->130 68->144 68->149 68->150 69->1 69->70 69->81 69->82 69->132 69->133 69->145 70->1 70->1 70->24 70->61 70->65 70->67 70->69 70->71 70->83 70->84 70->135 70->136 70->146 71->1 71->72 71->85 71->86 71->138 71->139 72->1 72->1 72->24 72->61 72->65 72->67 72->69 72->71 72->87 72->88 72->141 72->142 73->1 73->20 73->20 73->51 73->51 73->59 73->59 74->1 74->20 74->20 74->51 74->51 74->59 74->59 75->1 75->25 75->53 75->63 76->1 76->25 77->1 77->30 77->90 77->93 77->95 78->1 78->30 79->1 79->1 79->1 80->1 80->1 80->1 81->1 81->34 81->83 82->1 82->1 82->34 82->84 83->1 83->34 83->81 84->1 84->1 84->34 84->82 85->1 85->38 85->87 86->1 86->1 86->38 86->88 87->1 87->38 87->85 88->1 88->1 88->38 88->86 89->1 89->1 89->79 89->79 90->1 90->1 90->80 90->80 91->1 92->1 93->1 94->1 95->1 95->89 95->89 95->90 95->91 95->91 95->93 96->1 96->89 96->89 96->92 96->92 96->97 97->1 97->90 97->90 97->94 97->94 97->96
>>>Token int main ( ) { int tebcrlpvlbti ; int vrmzgomssdfk ; double myholvbemtoy [ 102 ] ; double uujdboxgatfc [ 102 ] ; double bmpknwhysura [ 102 ] ; int mpfkqjhceule ; int utcbuwxjcpld , j ; int fqtlimlavjgo ; int aysbqnzqdkco ; char cipzfnaloqec [ 128 ] [ 128 ] ; double ulvkcrpgxllk [ 128 ] [ 128 ] ; scanf ( " " , & tebcrlpvlbti ) ; for ( vrmzgomssdfk = 0 ; vrmzgomssdfk < tebcrlpvlbti ; vrmzgomssdfk ++ ) { scanf ( " " , & mpfkqjhceule ) ; for ( utcbuwxjcpld = 0 ; utcbuwxjcpld < mpfkqjhceule ; utcbuwxjcpld ++ ) { fqtlimlavjgo = 0 ; aysbqnzqdkco = 0 ; scanf ( " " , & cipzfnaloqec [ utcbuwxjcpld ] ) ; for ( j = 0 ; j < mpfkqjhceule ; j ++ ) { if ( cipzfnaloqec [ utcbuwxjcpld ] [ j ] == ' ' ) fqtlimlavjgo ++ ; if ( cipzfnaloqec [ utcbuwxjcpld ] [ j ] == ' ' ) aysbqnzqdkco ++ ; } aysbqnzqdkco += fqtlimlavjgo ; myholvbemtoy [ utcbuwxjcpld ] = ( double ) fqtlimlavjgo / ( double ) aysbqnzqdkco ; } for ( utcbuwxjcpld = 0 ; utcbuwxjcpld < mpfkqjhceule ; utcbuwxjcpld ++ ) { aysbqnzqdkco = 0 ; fqtlimlavjgo = 0 ; for ( j = 0 ; j < mpfkqjhceule ; j ++ ) { if ( cipzfnaloqec [ utcbuwxjcpld ] [ j ] == ' ' ) fqtlimlavjgo ++ ; if ( cipzfnaloqec [ utcbuwxjcpld ] [ j ] == ' ' ) aysbqnzqdkco ++ ; } aysbqnzqdkco += fqtlimlavjgo ; for ( j = 0 ; j < mpfkqjhceule ; j ++ ) { ulvkcrpgxllk [ utcbuwxjcpld ] [ j ] = 0 ; if ( cipzfnaloqec [ utcbuwxjcpld ] [ j ] == ' ' ) ulvkcrpgxllk [ utcbuwxjcpld ] [ j ] = ( double ) ( fqtlimlavjgo - 1 ) / ( double ) ( aysbqnzqdkco - 1 ) ; if ( cipzfnaloqec [ utcbuwxjcpld ] [ j ] == ' ' ) ulvkcrpgxllk [ utcbuwxjcpld ] [ j ] = ( double ) ( fqtlimlavjgo ) / ( double ) ( aysbqnzqdkco - 1 ) ; } } for ( utcbuwxjcpld = 0 ; utcbuwxjcpld < mpfkqjhceule ; utcbuwxjcpld ++ ) { uujdboxgatfc [ utcbuwxjcpld ] = 0.0 ; aysbqnzqdkco = 0 ; for ( j = 0 ; j < mpfkqjhceule ; j ++ ) { if ( cipzfnaloqec [ utcbuwxjcpld ] [ j ] == ' ' ) { aysbqnzqdkco ++ ; uujdboxgatfc [ utcbuwxjcpld ] += ulvkcrpgxllk [ j ] [ utcbuwxjcpld ] ; } if ( cipzfnaloqec [ utcbuwxjcpld ] [ j ] == ' ' ) { aysbqnzqdkco ++ ; uujdboxgatfc [ utcbuwxjcpld ] += ulvkcrpgxllk [ j ] [ utcbuwxjcpld ] ; } } uujdboxgatfc [ utcbuwxjcpld ] /= aysbqnzqdkco ; } for ( utcbuwxjcpld = 0 ; utcbuwxjcpld < mpfkqjhceule ; utcbuwxjcpld ++ ) { bmpknwhysura [ utcbuwxjcpld ] = 0.0 ; aysbqnzqdkco = 0 ; for ( j = 0 ; j < mpfkqjhceule ; j ++ ) { if ( cipzfnaloqec [ utcbuwxjcpld ] [ j ] == ' ' ) { aysbqnzqdkco ++ ; bmpknwhysura [ utcbuwxjcpld ] += uujdboxgatfc [ j ] ; } if ( cipzfnaloqec [ utcbuwxjcpld ] [ j ] == ' ' ) { aysbqnzqdkco ++ ; bmpknwhysura [ utcbuwxjcpld ] += uujdboxgatfc [ j ] ; } } bmpknwhysura [ utcbuwxjcpld ] /= aysbqnzqdkco ; } printf ( " \n " , vrmzgomssdfk + 1 ) ; for ( utcbuwxjcpld = 0 ; utcbuwxjcpld < mpfkqjhceule ; utcbuwxjcpld ++ ) printf ( " \n " , 0.25 * myholvbemtoy [ utcbuwxjcpld ] + 0.5 * uujdboxgatfc [ utcbuwxjcpld ] + 0.25 * bmpknwhysura [ utcbuwxjcpld ] ) ; } return 0 ; }
>>>Func
METHOD ntartozbefdc
METHOD_RETURN void
PARAM Heap *heap
PARAM int zqegikiaqzjn
<operator>.assignment sgnujzmafntu=(zqegikiaqzjn-1)/2
<operator>.lessThan sgnujzmafntu<0
<operator>.greaterThan *((heap->p)+zqegikiaqzjn)>*((heap->p)+sgnujzmafntu)
<operator>.division (zqegikiaqzjn-1)/2
RETURN return ; return ;
<operator>.assignment uxepftefeykt=*((heap->p)+zqegikiaqzjn)
<operator>.assignment *((heap->p)+zqegikiaqzjn)=*((heap->p)+sgnujzmafntu)
<operator>.assignment *((heap->p)+sgnujzmafntu)=uxepftefeykt
ntartozbefdc ntartozbefdc(heap,sgnujzmafntu)
<operator>.subtraction zqegikiaqzjn-1
<operator>.addition (heap->p)+zqegikiaqzjn
<operator>.addition (heap->p)+sgnujzmafntu
<operator>.addition (heap->p)+zqegikiaqzjn
<operator>.addition (heap->p)+zqegikiaqzjn
<operator>.addition (heap->p)+sgnujzmafntu
<operator>.addition (heap->p)+sgnujzmafntu
<operator>.indirection *((heap->p)+zqegikiaqzjn)
<operator>.indirection *((heap->p)+sgnujzmafntu)
<operator>.indirection *((heap->p)+zqegikiaqzjn)
<operator>.indirection *((heap->p)+zqegikiaqzjn)
<operator>.indirection *((heap->p)+sgnujzmafntu)
<operator>.indirection *((heap->p)+sgnujzmafntu)
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
<operator>.indirectFieldAccess heap->p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
FIELD_IDENTIFIER p p
>>>PDG&38 0->2 0->3 0->5 0->7 0->8 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 2->1 2->12 3->13 4->1 4->1 4->5 5->1 5->1 5->6 5->8 5->12 5->14 5->15 5->15 5->18 5->19 5->20 5->21 5->26 5->27 5->28 5->29 6->9 6->10 6->11 6->12 6->16 6->17 6->18 6->19 6->22 6->23 6->24 6->25 6->30 6->31 6->32 6->33 6->34 6->35 6->36 6->37 7->1 7->4 7->4 8->1 9->11 13->1 13->7 13->7 13->14 13->16 13->17
>>>Token void ntartozbefdc ( Heap * heap , int zqegikiaqzjn ) { int sgnujzmafntu = ( zqegikiaqzjn - 1 ) / 2 ; if ( sgnujzmafntu < 0 ) return ; if ( * ( ( heap -> p ) + zqegikiaqzjn ) > * ( ( heap -> p ) + sgnujzmafntu ) ) { int uxepftefeykt = * ( ( heap -> p ) + zqegikiaqzjn ) ; * ( ( heap -> p ) + zqegikiaqzjn ) = * ( ( heap -> p ) + sgnujzmafntu ) ; * ( ( heap -> p ) + sgnujzmafntu ) = uxepftefeykt ; ntartozbefdc ( heap , sgnujzmafntu ) ; } }
>>>Func
METHOD kwvnwiinyswhis_ancestor
METHOD_RETURN hlnpulfqzmjsstatic
PARAM const kriuxbxhhxuhstat *sb
PARAM const kriuxbxhhxuhdir_list *ancestors
RETURN return yjhfmkirjihr; return yjhfmkirjihr;
<operator>.notEquals ancestors!=0
IDENTIFIER yjhfmkirjihr return yjhfmkirjihr;
<operator>.assignment ancestors=ancestors->parent
<operator>.logicalAnd ancestors->ino==sb->st_ino&&ancestors->dev==sb->st_dev
RETURN return kvgatobvoxkc; return kvgatobvoxkc;
<operator>.equals ancestors->ino==sb->st_ino
<operator>.equals ancestors->dev==sb->st_dev
IDENTIFIER kvgatobvoxkc return kvgatobvoxkc;
<operator>.indirectFieldAccess ancestors->parent
FIELD_IDENTIFIER parent parent
<operator>.indirectFieldAccess ancestors->ino
<operator>.indirectFieldAccess sb->st_ino
<operator>.indirectFieldAccess ancestors->dev
<operator>.indirectFieldAccess sb->st_dev
FIELD_IDENTIFIER ino ino
FIELD_IDENTIFIER st_ino st_ino
FIELD_IDENTIFIER dev dev
FIELD_IDENTIFIER st_dev st_dev
>>>PDG&23 0->2 0->3 0->4 0->5 0->6 0->9 0->12 2->1 3->5 4->1 5->1 5->1 5->4 5->8 5->10 5->15 5->16 5->19 5->20 6->4 8->1 8->1 8->1 8->5 8->7 8->9 8->13 8->14 9->1 10->1 10->1 10->8 10->8 10->11 10->17 10->18 10->21 10->22 11->1 11->1 11->8 11->8 12->9
>>>Token ndif hlnpulfqzmjsstatic kwvnwiinyswhis_ancestor ( const kriuxbxhhxuhstat * sb , const kriuxbxhhxuhdir_list * ancestors ) { while ( ancestors != 0 ) { if ( ancestors -> ino == sb -> st_ino && ancestors -> dev == sb -> st_dev ) return kvgatobvoxkc ; ancestors = ancestors -> parent ; } return yjhfmkirjihr ; }
>>>Func
METHOD cwcbtldgrrjo
METHOD_RETURN int
PARAM const tvsmzaexmxtb*data1
PARAM const tvsmzaexmxtb*data2
<operator>.assignment *I1=(double *)data1
<operator>.assignment *I2=(double *)data2
RETURN return 0; return 0;
<operator>.greaterThan I1[1]>I2[1]
<operator>.lessThan I1[1]<I2[1]
LITERAL 0 return 0;
<operator>.cast (double *)data1
<operator>.cast (double *)data2
RETURN return  1; return  1;
RETURN return -1; return -1;
LITERAL 1 return  1;
<operator>.minus -1
<operator>.indirectIndexAccess I1[1]
<operator>.indirectIndexAccess I2[1]
>>>PDG&18 0->2 0->3 0->4 0->5 0->6 0->9 0->10 0->11 0->12 0->14 0->15 2->4 2->10 3->5 3->11 4->1 4->1 4->1 4->7 4->8 5->1 5->1 5->1 5->7 5->8 6->1 7->1 7->1 7->1 7->8 7->8 7->8 7->12 7->16 7->17 8->6 8->13 8->15 9->6 10->1 11->1 12->1 13->1 14->12 15->13
>>>Token int cwcbtldgrrjo ( const tvsmzaexmxtb * data1 , const tvsmzaexmxtb * data2 ) { double * I1 = ( double * ) data1 ; double * I2 = ( double * ) data2 ; if ( I1 [ 1 ] > I2 [ 1 ] ) return 1 ; if ( I1 [ 1 ] < I2 [ 1 ] ) return -1 ; return 0 ; }
>>>Func
METHOD fuzmiuksldaq
METHOD_RETURN int
PARAM int kidbsprolsqj
PARAM char **argv
<operator>.assignment ls_mode=LS_LONG_FORMAT
RETURN return unvileitkgov(kidbsprolsqj,argv); return unvileitkgov(kidbsprolsqj,argv);
unvileitkgov unvileitkgov(kidbsprolsqj,argv)
>>>PDG&7 0->2 0->3 0->4 0->6 2->6 3->6 4->1 4->1 4->1 5->1 6->1 6->1 6->1 6->5
>>>Token int fuzmiuksldaq ( int kidbsprolsqj , char * * argv ) { ls_mode = LS_LONG_FORMAT ; return unvileitkgov ( kidbsprolsqj , argv ) ; }
>>>Func
METHOD makeargv
METHOD_RETURN char**
PARAM const sogurnpygald *input
PARAM int *argc
<operator>.assignment nhtqjvvwxvky=0
<operator>.assignment *token=nptsitqxovyu
<operator>.assignment *copy=nptsitqxovyu
<operator>.assignment **bbprrpediquf=nptsitqxovyu
<operator>.assignment copy=(sogurnpygald *)malloc(sizeof(sogurnpygald)*(strlen(input)+1))
<operator>.assignment copy=strcpy(copy,input)
<operator>.assignment token=strtok(copy," ")
<operator>.assignment bbprrpediquf=(sogurnpygald **)malloc(sizeof(sogurnpygald *)*(nhtqjvvwxvky+1))
<operator>.assignment copy=strcpy(copy,input)
<operator>.assignment token=strtok(copy," ")
<operator>.assignment bbprrpediquf[nhtqjvvwxvky]=nptsitqxovyu
free free(copy)
<operator>.assignment *argc=nhtqjvvwxvky
RETURN return bbprrpediquf; return bbprrpediquf;
<operator>.equals input==nptsitqxovyu
<operator>.notEquals token!=nptsitqxovyu
<operator>.lessThan nhtqjvvwxvky<0
<operator>.equals bbprrpediquf==nptsitqxovyu
<operator>.lessThan vzdsacptiujw<nhtqjvvwxvky
<operator>.postIncrement vzdsacptiujw++
IDENTIFIER bbprrpediquf return bbprrpediquf;
RETURN return nptsitqxovyu; return nptsitqxovyu;
<operator>.cast (sogurnpygald *)malloc(sizeof(sogurnpygald)*(strlen(input)+1))
strcpy strcpy(copy,input)
strtok strtok(copy," ")
<operator>.postIncrement nhtqjvvwxvky++
<operator>.assignment token=strtok(nptsitqxovyu," ")
fprintf fprintf(stderr,"Too much parameters\n")
RETURN return nptsitqxovyu; return nptsitqxovyu;
<operator>.cast (sogurnpygald **)malloc(sizeof(sogurnpygald *)*(nhtqjvvwxvky+1))
free free(copy)
free free(bbprrpediquf)
perror perror("Critical error")
RETURN return nptsitqxovyu; return nptsitqxovyu;
strcpy strcpy(copy,input)
strtok strtok(copy," ")
<operator>.assignment vzdsacptiujw=0
<operator>.assignment bbprrpediquf[vzdsacptiujw]=(sogurnpygald *)malloc(sizeof(sogurnpygald)*(strlen(token)+1))
<operator>.assignment bbprrpediquf[vzdsacptiujw]=strcpy(bbprrpediquf[vzdsacptiujw],token)
<operator>.assignment token=strtok(nptsitqxovyu," ")
IDENTIFIER nptsitqxovyu return nptsitqxovyu;
malloc malloc(sizeof(sogurnpygald)*(strlen(input)+1))
IDENTIFIER nptsitqxovyu return nptsitqxovyu;
malloc malloc(sizeof(sogurnpygald *)*(nhtqjvvwxvky+1))
IDENTIFIER nptsitqxovyu return nptsitqxovyu;
<operator>.multiplication sizeof(sogurnpygald)*(strlen(input)+1)
strtok strtok(nptsitqxovyu," ")
<operator>.multiplication sizeof(sogurnpygald *)*(nhtqjvvwxvky+1)
<operator>.cast (sogurnpygald *)malloc(sizeof(sogurnpygald)*(strlen(token)+1))
strcpy strcpy(bbprrpediquf[vzdsacptiujw],token)
strtok strtok(nptsitqxovyu," ")
<operator>.addition strlen(input)+1
<operator>.addition nhtqjvvwxvky+1
malloc malloc(sizeof(sogurnpygald)*(strlen(token)+1))
strlen strlen(input)
<operator>.multiplication sizeof(sogurnpygald)*(strlen(token)+1)
<operator>.addition strlen(token)+1
strlen strlen(token)
<operator>.indirectIndexAccess bbprrpediquf[nhtqjvvwxvky]
<operator>.indirection *argc
UNKNOWN sogurnpygald * sogurnpygald *
UNKNOWN sogurnpygald ** sogurnpygald **
<operator>.indirectIndexAccess bbprrpediquf[vzdsacptiujw]
<operator>.indirectIndexAccess bbprrpediquf[vzdsacptiujw]
<operator>.sizeOf sizeof(sogurnpygald)
<operator>.sizeOf sizeof(sogurnpygald *)
UNKNOWN sogurnpygald * sogurnpygald *
<operator>.indirectIndexAccess bbprrpediquf[vzdsacptiujw]
<operator>.sizeOf sizeof(sogurnpygald)
>>>PDG&73 0->2 0->3 0->4 0->5 0->6 0->7 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->27 0->28 0->29 0->31 0->34 0->35 0->36 0->38 0->39 0->40 0->44 0->46 0->48 0->49 0->50 0->51 0->53 0->54 0->55 0->56 0->58 0->59 0->60 0->61 2->18 3->1 4->1 4->1 4->20 4->29 5->1 5->1 6->1 6->1 7->1 7->1 8->27 9->28 10->19 11->21 12->39 13->61 14->24 17->1 18->1 18->1 18->1 18->8 18->9 18->10 18->19 18->19 18->20 18->25 18->26 18->27 18->28 18->44 18->45 18->49 18->55 18->58 18->58 18->64 18->68 19->19 19->21 19->29 19->30 19->46 19->50 19->50 20->11 20->21 20->22 20->31 20->32 20->33 20->47 20->51 20->51 20->56 20->56 20->65 20->69 21->12 21->13 21->14 21->14 21->15 21->16 21->17 21->22 21->24 21->34 21->35 21->35 21->36 21->37 21->38 21->39 21->40 21->48 21->53 21->54 21->62 21->63 22->16 22->22 22->23 22->23 22->41 22->42 22->43 22->52 22->53 22->54 22->57 22->59 22->60 22->61 22->66 22->67 22->70 22->71 22->72 23->22 24->17 25->1 27->9 27->9 27->38 28->10 28->10 28->34 28->38 29->20 30->19 31->1 32->1 37->1 38->12 38->12 39->13 39->13 39->15 40->22 41->53 42->24 43->61 44->25 45->8 45->26 46->32 47->11 47->33 48->37 49->45 50->19 50->30 50->30 51->47 53->42 53->42 54->14 54->43 54->43 57->41 57->52 58->27 58->49 58->55 59->57 61->53 61->59 61->60
>>>Token char * * makeargv ( const sogurnpygald * input , int * argc ) { int vzdsacptiujw ; int nhtqjvvwxvky = 0 ; sogurnpygald * token = nptsitqxovyu ; sogurnpygald * copy = nptsitqxovyu ; sogurnpygald * * bbprrpediquf = nptsitqxovyu ; if ( input == nptsitqxovyu ) return nptsitqxovyu ; copy = ( sogurnpygald * ) malloc ( sizeof ( sogurnpygald ) * ( strlen ( input ) + 1 ) ) ; copy = strcpy ( copy , input ) ; token = strtok ( copy , " " ) ; while ( token != nptsitqxovyu ) { nhtqjvvwxvky ++ ; token = strtok ( nptsitqxovyu , " " ) ; } if ( nhtqjvvwxvky < 0 ) { fprintf ( stderr , " \n " ) ; return nptsitqxovyu ; } bbprrpediquf = ( sogurnpygald * * ) malloc ( sizeof ( sogurnpygald * ) * ( nhtqjvvwxvky + 1 ) ) ; if ( bbprrpediquf == nptsitqxovyu ) { free ( copy ) ; free ( bbprrpediquf ) ; perror ( " " ) ; return nptsitqxovyu ; } copy = strcpy ( copy , input ) ; token = strtok ( copy , " " ) ; for ( vzdsacptiujw = 0 ; vzdsacptiujw < nhtqjvvwxvky ; vzdsacptiujw ++ ) { bbprrpediquf [ vzdsacptiujw ] = ( sogurnpygald * ) malloc ( sizeof ( sogurnpygald ) * ( strlen ( token ) + 1 ) ) ; bbprrpediquf [ vzdsacptiujw ] = strcpy ( bbprrpediquf [ vzdsacptiujw ] , token ) ; token = strtok ( nptsitqxovyu , " " ) ; } bbprrpediquf [ nhtqjvvwxvky ] = nptsitqxovyu ; free ( copy ) ; * argc = nhtqjvvwxvky ; return bbprrpediquf ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
<operator>.assignment qgzndpjevzhttemp=0
scanf scanf("%lld ",&t)
RETURN return 1; return 1;
<operator>.lessThan i<t
<operator>.postIncrement i++
LITERAL 1 return 1;
<operator>.assignment i=0
scanf scanf("%lld ",&l)
scanf scanf("%lld ",&time)
scanf scanf("%lld ",&n)
scanf scanf("%lld ",&c)
<operator>.assignment temp=0
<operator>.assignment temp=0
<operator>.assignment temp2=0
<operator>.assignment temp3=0
<operator>.assignment temp3=temp3-temp+(temp/2)
printf printf("Case #%lld: %lld\n",i+1,temp3)
<operator>.lessThan j<c
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.notEquals l!=0
<operator>.logicalAnd j<n&&(temp!=0)
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.notEquals l!=0
<operator>.assignment j=0
scanf scanf("%lld",&star_dist[j])
<operator>.assignmentMultiplication star_dist[j]*=2
<operator>.assignment j=0
<operator>.assignment star_dist[j]=star_dist[j%c]
<operator>.assignment temp=time
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.assignmentPlus temp3+=star_dist[j]
<operator>.assignmentPlus temp3+=time
<operator>.addition temp3-temp+(temp/2)
<operator>.addition i+1
<operator>.lessThan j<n
<operator>.notEquals temp!=0
<operator>.lessEqualsThan star_dist[j]<=temp
<operator>.lessThan (n-1-j)<l
<operator>.subtraction temp3-temp
<operator>.division temp/2
<operator>.assignmentMinus temp-=star_dist[j]
<operator>.assignment star_dist[j]=0
<operator>.assignmentPlus temp+=star_dist[j]
<operator>.modulo j%c
<operator>.assignmentMinus star_dist[j]-=temp
<operator>.assignment temp=0
<operator>.subtraction n-1-j
<operator>.subtraction n-1
UNKNOWN qsort(star_dist n sizeof(qgzndpjevzht qgzndpjevzht),&cmpr); qsort(star_dist n sizeof(qgzndpjevzht qgzndpjevzht),&cmpr);
<operator>.addressOf &l
<operator>.addressOf &time
<operator>.addressOf &n
<operator>.addressOf &c
<operator>.addressOf &star_dist[j]
<operator>.indirectIndexAccess star_dist[j]
<operator>.indirectIndexAccess star_dist[j]
<operator>.indirectIndexAccess star_dist[j%c]
<operator>.indirectIndexAccess star_dist[j]
<operator>.indirectIndexAccess star_dist[j]
<operator>.indirectIndexAccess star_dist[j]
<operator>.indirectIndexAccess star_dist[j]
<operator>.indirectIndexAccess star_dist[j]
<operator>.indirectIndexAccess star_dist[j]
<operator>.indirectIndexAccess star_dist[j]
>>>PDG&72 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 2->1 3->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->19 6->20 6->22 6->24 6->25 6->27 6->29 6->30 6->33 6->36 6->37 6->40 6->41 6->41 6->42 6->46 6->47 6->56 6->57 6->58 6->59 6->60 7->1 7->6 8->5 9->1 9->6 10->1 10->24 10->29 10->45 11->1 11->35 11->39 12->1 12->22 12->27 12->42 12->55 13->1 13->20 13->51 14->43 14->44 15->1 15->46 15->50 16->1 16->1 17->1 17->38 17->39 17->46 18->1 18->1 18->19 19->1 19->1 19->1 20->1 20->1 20->13 20->20 20->21 20->21 20->31 20->32 20->51 20->61 20->62 20->66 21->1 21->20 22->22 22->23 22->34 22->42 22->51 22->51 22->63 22->64 23->1 23->22 24->29 24->35 24->45 25->1 25->1 25->25 25->26 25->42 25->44 25->67 26->1 26->42 27->1 27->1 27->1 27->12 27->22 27->27 27->28 27->38 27->45 27->54 27->54 27->55 27->55 27->65 28->1 28->27 29->1 29->1 29->10 29->24 29->39 30->20 31->1 31->32 31->38 31->44 31->48 31->50 31->52 32->1 32->1 32->31 32->38 32->44 33->22 34->1 34->1 34->1 34->31 34->32 34->38 34->44 35->1 35->1 35->43 35->44 36->42 37->1 37->27 38->1 38->1 38->39 38->46 39->1 39->1 39->46 40->1 40->1 42->25 42->25 42->26 42->27 42->43 43->25 43->25 43->44 44->1 44->48 44->48 44->48 44->49 44->52 44->52 44->52 44->53 44->68 44->69 44->71 45->1 45->1 45->29 45->50 45->70 46->18 46->18 46->40 46->40 46->47 47->1 47->18 47->18 47->40 47->40 48->1 48->43 48->44 49->1 49->1 49->31 49->32 49->38 49->44 50->1 50->1 50->46 51->1 51->13 51->20 51->23 52->1 52->1 52->31 52->32 52->38 52->44 53->43 53->44 54->1 54->28 54->45 54->45 55->27 55->54 55->54
>>>Token int main ( void ) { qgzndpjevzht qgzndpjevzhtt , l , time , n , c ; qgzndpjevzht qgzndpjevzhttemp = 0 , temp1 , temp2 , temp3 ; qgzndpjevzht qgzndpjevzhti , j , k ; scanf ( " " , & t ) ; for ( i = 0 ; i < t ; i ++ ) { scanf ( " " , & l ) ; scanf ( " " , & time ) ; scanf ( " " , & n ) ; scanf ( " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) { scanf ( " " , & star_dist [ j ] ) ; star_dist [ j ] *= 2 ; } for ( j = 0 ; j < n ; j ++ ) { star_dist [ j ] = star_dist [ j % c ] ; } temp = 0 ; if ( l != 0 ) temp = time ; for ( j = 0 ; j < n && ( temp != 0 ) ; j ++ ) { if ( star_dist [ j ] <= temp ) { temp -= star_dist [ j ] ; star_dist [ j ] = 0 ; } else { star_dist [ j ] -= temp ; temp = 0 ; } } temp = 0 ; temp2 = 0 ; temp3 = 0 ; qsort ( star_dist , n , sizeof ( qgzndpjevzht qgzndpjevzht ) , & cmpr ) ; for ( j = 0 ; j < n ; j ++ ) { temp3 += star_dist [ j ] ; if ( ( n - 1 - j ) < l ) temp += star_dist [ j ] ; } if ( l != 0 ) temp3 += time ; temp3 = temp3 - temp + ( temp / 2 ) ; printf ( " \n " , i + 1 , temp3 ) ; } return 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int rmyglunhjnmg
PARAM char **argv
<operator>.assignment yfpytbtuhbwu=1
scanf scanf("%d\n",&ertatytvjjoc)
RETURN return 0; return 0;
<operator>.lessThan hexocvhkdyzd<40
<operator>.postIncrement hexocvhkdyzd++
<operator>.lessEqualsThan yfpytbtuhbwu<=ertatytvjjoc
<operator>.postIncrement yfpytbtuhbwu++
<operator>.lessThan hexocvhkdyzd<40
<operator>.postIncrement hexocvhkdyzd++
LITERAL 0 return 0;
<operator>.assignment hexocvhkdyzd=0
<operator>.assignment combinations[hexocvhkdyzd]=malloc(sizeof(char)*3)
<operator>.assignment destructions[hexocvhkdyzd]=malloc(sizeof(char)*2)
<operator>.assignment yfpytbtuhbwu=1
printf printf("Case #%d: ",yfpytbtuhbwu)
scanf scanf("%d",&xwtqaqqmcspq)
scanf scanf("%d",&kwxmnxtzldhi)
scanf scanf("%d",&rynchsndacyj)
scanf scanf("%s",ymlvdqcakvrl)
PrintResult PrintResult(rynchsndacyj,ymlvdqcakvrl,kwxmnxtzldhi,destructions,xwtqaqqmcspq,combinations)
<operator>.assignment hexocvhkdyzd=0
free free(combinations[hexocvhkdyzd])
free free(destructions[hexocvhkdyzd])
<operator>.lessThan hexocvhkdyzd<xwtqaqqmcspq
<operator>.postIncrement hexocvhkdyzd++
<operator>.lessThan hexocvhkdyzd<kwxmnxtzldhi
<operator>.postIncrement hexocvhkdyzd++
malloc malloc(sizeof(char)*3)
malloc malloc(sizeof(char)*2)
<operator>.assignment hexocvhkdyzd=0
scanf scanf("%s",combinations[hexocvhkdyzd])
<operator>.assignment hexocvhkdyzd=0
scanf scanf("%s",destructions[hexocvhkdyzd])
<operator>.multiplication sizeof(char)*3
<operator>.multiplication sizeof(char)*2
<operator>.sizeOf sizeof(char)
<operator>.indirectIndexAccess combinations[hexocvhkdyzd]
<operator>.indirectIndexAccess destructions[hexocvhkdyzd]
<operator>.addressOf &xwtqaqqmcspq
<operator>.addressOf &kwxmnxtzldhi
<operator>.addressOf &rynchsndacyj
<operator>.indirectIndexAccess combinations[hexocvhkdyzd]
<operator>.indirectIndexAccess destructions[hexocvhkdyzd]
<operator>.sizeOf sizeof(char)
<operator>.indirectIndexAccess combinations[hexocvhkdyzd]
<operator>.indirectIndexAccess destructions[hexocvhkdyzd]
>>>PDG&50 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->27 0->28 0->29 0->30 0->33 0->35 0->37 0->38 2->1 3->1 5->1 5->9 6->1 7->7 7->8 7->8 7->15 7->16 7->31 7->32 7->37 7->38 7->39 7->40 7->41 7->47 8->1 8->7 9->1 9->1 9->1 9->9 9->10 9->18 9->18 9->19 9->20 9->21 9->22 9->23 9->27 9->29 9->33 9->35 9->42 9->43 9->44 10->1 10->9 11->1 11->1 11->11 11->12 11->12 11->25 11->26 11->45 11->46 12->1 12->11 13->6 14->7 15->1 15->1 15->1 15->23 15->25 15->34 16->1 16->1 16->1 16->23 16->26 16->36 17->1 17->9 18->1 18->10 19->1 19->23 19->27 20->1 20->23 20->29 21->1 21->23 22->23 23->1 23->1 23->1 23->1 23->1 23->1 23->1 23->19 23->20 23->21 23->22 23->25 23->26 23->27 23->29 23->34 23->36 24->1 24->11 25->1 26->1 27->1 27->23 27->27 27->28 27->28 27->34 27->48 28->1 28->27 29->1 29->23 29->29 29->30 29->30 29->36 29->49 30->1 30->29 31->1 31->15 32->1 32->16 33->27 34->1 34->23 34->25 35->29 36->1 36->23 36->26 37->31 38->32 39->1
>>>Token int main ( int rmyglunhjnmg , char * * argv ) { char * destructions [ 40 ] ; char * combinations [ 40 ] ; char ymlvdqcakvrl [ 100 ] ; int kwxmnxtzldhi ; int xwtqaqqmcspq ; int rynchsndacyj ; int ertatytvjjoc ; int yfpytbtuhbwu = 1 ; int hexocvhkdyzd ; scanf ( " \n " , & ertatytvjjoc ) ; for ( hexocvhkdyzd = 0 ; hexocvhkdyzd < 40 ; hexocvhkdyzd ++ ) { combinations [ hexocvhkdyzd ] = malloc ( sizeof ( char ) * 3 ) ; destructions [ hexocvhkdyzd ] = malloc ( sizeof ( char ) * 2 ) ; } for ( yfpytbtuhbwu = 1 ; yfpytbtuhbwu <= ertatytvjjoc ; yfpytbtuhbwu ++ ) { printf ( " " , yfpytbtuhbwu ) ; scanf ( " " , & xwtqaqqmcspq ) ; for ( hexocvhkdyzd = 0 ; hexocvhkdyzd < xwtqaqqmcspq ; hexocvhkdyzd ++ ) { scanf ( " " , combinations [ hexocvhkdyzd ] ) ; } scanf ( " " , & kwxmnxtzldhi ) ; for ( hexocvhkdyzd = 0 ; hexocvhkdyzd < kwxmnxtzldhi ; hexocvhkdyzd ++ ) { scanf ( " " , destructions [ hexocvhkdyzd ] ) ; } scanf ( " " , & rynchsndacyj ) ; scanf ( " " , ymlvdqcakvrl ) ; PrintResult ( rynchsndacyj , ymlvdqcakvrl , kwxmnxtzldhi , destructions , xwtqaqqmcspq , combinations ) ; } for ( hexocvhkdyzd = 0 ; hexocvhkdyzd < 40 ; hexocvhkdyzd ++ ) { free ( combinations [ hexocvhkdyzd ] ) ; free ( destructions [ hexocvhkdyzd ] ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
freopen freopen("B.in","r",stdin)
freopen freopen("B.txt","w",stdout)
scanf scanf("%d",&test)
<operator>.lessEqualsThan j<=test
<operator>.postIncrement j++
<operator>.assignment j=1
<operator>.assignment arr1[0]='\0'
scanf scanf("%d",&c)
scanf scanf("%d",&d)
scanf scanf("%d",&n)
scanf scanf("%s",str)
hjxfmprezfnw hjxfmprezfnw("Case #%d: [",j)
hjxfmprezfnw hjxfmprezfnw("]\n")
<operator>.lessThan i<c
<operator>.postIncrement i++
scanf scanf("%s",comb[i])
<operator>.lessThan i<d
<operator>.postIncrement i++
scanf scanf("%s",arr2[i])
<operator>.notEquals str[i]!='\0'
<operator>.postIncrement i++
<operator>.notEquals arr1[i]!='\0'
<operator>.postIncrement i++
<operator>.assignment i=0
<operator>.assignment i=0
<operator>.assignment i=0
<operator>.assignment adeimbcofqrq=strlen(arr1)
<operator>.assignment i=0
<operator>.logicalNot !check(str[i])
<operator>.equals i==0
strlen strlen(arr1)
hjxfmprezfnw hjxfmprezfnw("%c",arr1[i])
check check(str[i])
<operator>.logicalNot !dissolve(str[i])
hjxfmprezfnw hjxfmprezfnw (", %c",arr1[i])
<operator>.assignment arr1[adeimbcofqrq]=str[i]
<operator>.assignment arr1[adeimbcofqrq+1]='\0'
dissolve dissolve(str[i])
<operator>.addition adeimbcofqrq+1
<operator>.indirectIndexAccess arr1[0]
<operator>.addressOf &c
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.indirectIndexAccess comb[i]
<operator>.indirectIndexAccess arr2[i]
<operator>.indirectIndexAccess str[i]
<operator>.indirectIndexAccess arr1[i]
<operator>.indirectIndexAccess str[i]
<operator>.indirectIndexAccess arr1[i]
<operator>.indirectIndexAccess arr1[i]
<operator>.indirectIndexAccess str[i]
<operator>.indirectIndexAccess arr1[adeimbcofqrq]
<operator>.indirectIndexAccess str[i]
<operator>.indirectIndexAccess arr1[adeimbcofqrq+1]
>>>PDG&56 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->31 0->32 0->33 0->36 0->38 0->40 2->1 2->1 3->1 3->1 4->1 4->5 5->1 5->1 5->1 5->5 5->6 5->8 5->9 5->10 5->11 5->12 5->13 5->13 5->14 5->15 5->18 5->21 5->23 5->25 5->26 5->27 5->29 5->41 5->42 5->43 5->44 5->47 5->48 6->1 6->5 7->1 7->5 8->1 8->1 8->32 9->1 9->15 10->1 10->18 11->1 12->1 12->21 12->34 12->37 12->39 13->1 13->6 14->1 15->1 15->1 15->9 15->15 15->16 15->16 15->17 15->45 16->1 16->15 17->1 18->1 18->1 18->10 18->18 18->19 18->19 18->20 18->46 19->1 19->18 20->1 21->1 21->1 21->12 21->21 21->22 21->28 21->30 21->32 21->34 21->34 21->47 21->49 22->1 23->1 23->1 23->23 23->24 23->31 23->32 23->33 23->36 23->48 24->1 24->1 24->31 25->15 26->18 27->22 28->1 28->1 28->1 28->40 29->1 29->1 29->31 30->1 30->1 30->35 30->39 30->52 31->1 31->24 31->33 31->36 31->50 31->51 32->1 32->23 32->28 32->33 32->36 33->1 33->23 34->21 34->30 34->39 35->1 35->1 35->37 35->38 35->40 35->53 35->54 35->55 36->1 36->23 37->1 37->1 37->32 38->1 38->1 38->32 39->21 39->35 39->37 40->1
>>>Token int main ( ) { int adeimbcofqrq , i , n , test , j ; freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; scanf ( " " , & test ) ; for ( j = 1 ; j <= test ; j ++ ) { arr1 [ 0 ] = ' \0 ' ; scanf ( " " , & c ) ; for ( i = 0 ; i < c ; i ++ ) scanf ( " " , comb [ i ] ) ; scanf ( " " , & d ) ; for ( i = 0 ; i < d ; i ++ ) scanf ( " " , arr2 [ i ] ) ; scanf ( " " , & n ) ; scanf ( " " , str ) ; for ( i = 0 ; str [ i ] != ' \0 ' ; i ++ ) { adeimbcofqrq = strlen ( arr1 ) ; if ( ! check ( str [ i ] ) ) if ( ! dissolve ( str [ i ] ) ) { arr1 [ adeimbcofqrq ] = str [ i ] ; arr1 [ adeimbcofqrq + 1 ] = ' \0 ' ; } } hjxfmprezfnw ( " " , j ) ; for ( i = 0 ; arr1 [ i ] != ' \0 ' ; i ++ ) { if ( i == 0 ) hjxfmprezfnw ( " " , arr1 [ i ] ) ; else hjxfmprezfnw ( " " , arr1 [ i ] ) ; } hjxfmprezfnw ( " \n " ) ; } }
>>>Func
METHOD chuyapiwzhcu
METHOD_RETURN int
PARAM char *pcszFileName
<operator>.assignment fp=fopen(pcszFileName,"r")
fscanf fscanf(fp,"%d ",&rmaxzbizvfsd)
<operator>.assignment fout=fopen(OUT_FILE_NAME,"w")
fclose fclose(fp)
fclose fclose(fout)
RETURN return 0; return 0;
<operator>.equals NULL==pcszFileName
<operator>.equals NULL==fp
<operator>.equals NULL==fout
<operator>.lessEqualsThan uikjvsibuukc<=rmaxzbizvfsd
<operator>.preIncrement ++uikjvsibuukc
LITERAL 0 return 0;
RETURN return -1; return -1;
fopen fopen(pcszFileName,"r")
printf printf("\nAccess denied file: %s",pcszFileName)
RETURN return -1; return -1;
fopen fopen(OUT_FILE_NAME,"w")
printf printf("\nCannot create new file.")
RETURN return -1; return -1;
<operator>.assignment uikjvsibuukc=1
<operator>.assignment max=0
fscanf fscanf(fp,"%lld %lld %lld %lld",&uhjudsckdiqe,&t,&n,&c)
<operator>.assignment aIndex=n%c
fprintf fprintf(fout,"Case #%d: ",uikjvsibuukc)
<operator>.assignment time=0
<operator>.assignment BoosterUsed=uhjudsckdiqe
<operator>.assignment jhyvkkchusin=0
fprintf fprintf(fout,"%lld\n",time)
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.lessThan k<N
<operator>.preIncrement ++k
<operator>.assignment stars[k][0]=stars[k][1]=0
<operator>.lessThan j<c
<operator>.preIncrement ++j
<operator>.equals aIndex==0
<operator>.lessThan j<aIndex
<operator>.preIncrement ++j
<operator>.lessThan k<n
<operator>.expressionList ++k j=(j+1)%c
<operator>.lessThan k<n
<operator>.preIncrement ++k
<operator>.assignment k=0
<operator>.assignment j=0
fscanf fscanf(fp,"%d ",&a[j])
<operator>.modulo n%c
<operator>.assignment aIndex=c
<operator>.assignment j=0
<operator>.expressionList k=0 j=0
<operator>.assignment stars[k][0]=a[j]
<operator>.assignment k=0
<operator>.assignment stars[k][1]=0
<operator>.greaterThan a[j]>max
<operator>.preIncrement ++k
<operator>.assignment j=(j+1)%c
<operator>.equals max==a[j]
<operator>.logicalAnd (time>=t||t<=stars[k][0])&&BoosterUsed!=0
<operator>.assignment max=a[j]
<operator>.assignment k=0
<operator>.assignment j=0
<operator>.modulo (j+1)%c
<operator>.assignment stars[k][1]=1
<operator>.addition j+1
<operator>.logicalOr time>=t||t<=stars[k][0]
<operator>.notEquals BoosterUsed!=0
<operator>.equals jhyvkkchusin==0
<operator>.assignmentPlus time+=(stars[k][0]*2)
<operator>.greaterEqualsThan time>=t
<operator>.lessEqualsThan t<=stars[k][0]
<operator>.assignment jhyvkkchusin=1
<operator>.postDecrement BoosterUsed--
<operator>.assignment dvczixfqwiuq=k+c
<operator>.lessEqualsThan t<=stars[k][0]
<operator>.multiplication stars[k][0]*2
<operator>.assignmentPlus time+=t
<operator>.assignmentPlus time+=(stars[k][0]-(t/2))
<operator>.addition k+c
<operator>.equals k==dvczixfqwiuq
<operator>.assignmentPlus time+=stars[k][0]
<operator>.postDecrement BoosterUsed--
<operator>.subtraction stars[k][0]-(t/2)
<operator>.lessEqualsThan t<=stars[k][0]
<operator>.assignmentPlus time+=(stars[k][0]*2)
<operator>.division t/2
<operator>.assignmentPlus time+=t
<operator>.assignmentPlus time+=(stars[k][0]-(t/2))
<operator>.assignmentPlus time+=stars[k][0]
<operator>.multiplication stars[k][0]*2
<operator>.subtraction stars[k][0]-(t/2)
<operator>.division t/2
<operator>.addressOf &rmaxzbizvfsd
<operator>.addressOf &uhjudsckdiqe
<operator>.addressOf &t
<operator>.addressOf &n
<operator>.addressOf &c
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess stars[k][1]
<operator>.addressOf &a[j]
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess stars[k][1]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess stars[k][0]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess stars[k]
<operator>.indirectIndexAccess stars[k]
>>>PDG&131 0->2 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->19 0->20 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->59 0->62 0->63 0->64 0->65 0->66 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->93 2->9 3->10 4->6 4->12 4->24 5->11 8->1 9->1 9->1 9->1 9->3 9->10 9->10 9->15 9->16 9->16 9->31 10->4 10->4 10->5 10->11 10->11 10->17 10->18 10->19 10->32 10->94 11->6 11->7 11->7 11->8 11->12 11->20 11->21 11->22 11->26 11->33 12->12 12->13 12->23 12->24 12->25 12->26 12->26 12->27 12->28 12->29 12->30 12->34 12->37 12->39 12->40 12->42 12->44 12->46 12->47 12->49 12->51 12->52 12->54 12->62 12->63 12->95 12->96 12->97 12->98 13->12 14->8 15->1 16->3 16->3 16->17 18->1 19->1 19->5 19->5 21->1 22->12 23->56 23->59 24->6 24->28 24->37 24->42 24->44 24->48 24->49 24->49 24->50 24->64 24->71 24->72 24->75 24->76 24->78 24->80 24->85 24->87 24->88 24->93 25->39 26->13 26->30 27->30 27->71 28->68 28->74 28->83 29->69 30->7 30->26 31->1 31->15 32->18 33->21 34->1 34->34 34->35 34->35 34->36 34->55 34->99 34->100 34->101 34->105 35->34 36->72 36->76 36->77 36->85 36->91 37->37 37->38 37->38 37->48 37->49 37->102 37->106 38->37 39->40 39->50 40->40 40->41 40->41 40->56 40->107 41->40 42->42 42->43 42->44 42->53 42->57 42->57 42->58 42->59 42->64 42->66 42->103 42->104 42->108 42->109 44->24 44->44 44->45 44->45 44->49 44->60 44->67 44->71 44->75 44->80 44->81 45->44 46->34 47->37 48->6 48->24 48->53 48->56 48->59 48->61 49->24 49->25 49->25 49->37 49->42 49->50 49->64 49->75 49->80 50->40 51->40 53->72 53->76 53->77 53->85 53->91 54->44 55->36 56->48 56->53 56->59 56->59 56->61 56->61 56->110 57->42 57->43 58->43 58->64 58->66 59->48 59->53 59->56 59->65 59->111 59->112 60->69 60->70 60->77 60->115 60->117 61->56 61->59 62->42 62->52 63->52 63->64 63->66 64->24 64->37 64->43 64->43 64->58 64->58 64->75 64->80 67->60 67->60 67->68 68->60 68->60 68->74 68->83 69->73 69->74 69->75 69->76 69->80 69->81 69->116 69->118 70->30 70->71 71->24 71->67 71->67 71->70 71->72 71->72 71->76 71->78 71->82 71->85 71->86 71->88 71->90 71->113 71->114 72->24 72->67 72->67 72->71 72->76 72->76 72->77 72->85 72->85 72->91 73->69 74->68 74->83 75->81 76->24 76->67 76->71 76->72 76->77 76->78 76->78 76->79 76->82 76->82 76->84 76->84 76->85 76->87 76->87 76->91 76->119 76->120 76->121 76->122 77->70 77->70 77->72 77->76 77->85 77->91 78->79 79->30 79->71 81->45 81->83 81->85 81->86 81->91 81->123 81->124 81->125 81->128 82->30 82->71 83->68 83->74 84->72 84->76 84->77 84->79 84->79 84->85 84->91 85->24 85->67 85->71 85->72 85->76 85->77 85->88 85->88 85->89 85->90 85->90 85->91 85->92 85->92 85->93 85->93 85->126 85->127 85->129 85->130 86->30 86->71 87->24 87->71 87->84 87->84 88->89 89->30 89->71 90->30 90->71 91->72 91->76 91->77 91->85 91->86 91->86 92->72 92->76 92->77 92->85 92->89 92->89 92->91 93->24 93->71 93->92 93->92
>>>Token int chuyapiwzhcu ( char * pcszFileName ) { gulugheqncht rmaxzbizvfsd ; gulugheqncht uikjvsibuukc , j , k ; FILE * fp ; jyiztaufcyaj gulugheqnchtmax ; jyiztaufcyaj jyiztaufcyaj  gulugheqncht uhjudsckdiqe , t , c , BoosterUsed , time , aIndex ; if ( NULL == pcszFileName ) return -1 ; fp = fopen ( pcszFileName , " " ) ; if ( NULL == fp ) { printf ( " \n " , pcszFileName ) ; return -1 ; } fscanf ( fp , " " , & rmaxzbizvfsd ) ; fout = fopen ( OUT_FILE_NAME , " " ) ; if ( NULL == fout ) { printf ( " \n " ) ; return -1 ; } for ( uikjvsibuukc = 1 ; uikjvsibuukc <= rmaxzbizvfsd ; ++ uikjvsibuukc ) { max = 0 ; for ( k = 0 ; k < N ; ++ k ) stars [ k ] [ 0 ] = stars [ k ] [ 1 ] = 0 ; fscanf ( fp , " " , & uhjudsckdiqe , & t , & n , & c ) ; for ( j = 0 ; j < c ; ++ j ) { fscanf ( fp , " " , & a [ j ] ) ; } aIndex = n % c ; if ( aIndex == 0 ) aIndex = c ; for ( j = 0 ; j < aIndex ; ++ j ) { if ( a [ j ] > max ) max = a [ j ] ; } for ( k = 0 , j = 0 ; k < n ; ++ k , j = ( j + 1 ) % c ) { stars [ k ] [ 0 ] = a [ j ] ; if ( max == a [ j ] ) stars [ k ] [ 1 ] = 1 ; } fprintf ( fout , " " , uikjvsibuukc ) ; time = 0 ; BoosterUsed = uhjudsckdiqe ; gulugheqncht jhyvkkchusin = 0 ; gulugheqncht dvczixfqwiuq ; for ( k = 0 ; k < n ; ++ k ) { if ( ( time >= t || t <= stars [ k ] [ 0 ] ) && BoosterUsed != 0 ) { if ( jhyvkkchusin == 0 ) { jhyvkkchusin = 1 ; if ( t <= stars [ k ] [ 0 ] ) { time += t ; time += ( stars [ k ] [ 0 ] - ( t / 2 ) ) ; } else { time += stars [ k ] [ 0 ] ; } BoosterUsed -- ; dvczixfqwiuq = k + c ; } else { if ( k == dvczixfqwiuq ) { if ( t <= stars [ k ] [ 0 ] ) { time += t ; time += ( stars [ k ] [ 0 ] - ( t / 2 ) ) ; } else { time += stars [ k ] [ 0 ] ; } BoosterUsed -- ; } else { time += ( stars [ k ] [ 0 ] * 2 ) ; } } } else { time += ( stars [ k ] [ 0 ] * 2 ) ; } } fprintf ( fout , " \n " , time ) ; } fclose ( fp ) ; fclose ( fout ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment zxjrxngnsltu [ ]="AABCAB12AFAABCABFFEGABCAB"
<operator>.assignment oexgqrkrwmuw [ ]="ABCAB"
<operator>.assignment ckrsjhphetzu [ ]="FFF"
<operator>.assignment zoqhgdndphdh [ ]="CAB"
printf printf("String test: %s\n",zxjrxngnsltu)
printf printf("Test1: search pattern %s\n",oexgqrkrwmuw)
naive_search naive_search(zxjrxngnsltu,oexgqrkrwmuw)
printf printf("Test2: search pattern %s\n",ckrsjhphetzu)
naive_search naive_search(zxjrxngnsltu,ckrsjhphetzu)
printf printf("Test3: search pattern %s\n",zoqhgdndphdh)
naive_search naive_search(zxjrxngnsltu,zoqhgdndphdh)
RETURN return 0; return 0;
LITERAL 0 return 0;
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 2->6 3->1 3->7 4->1 4->9 5->1 5->11 6->1 6->8 7->1 7->8 8->1 8->1 8->10 9->1 9->10 10->1 10->1 10->12 11->1 11->12 12->1 12->1 12->1 13->1 14->13
>>>Token int main ( ) { char zxjrxngnsltu [ ] = " " ; char oexgqrkrwmuw [ ] = " " ; char ckrsjhphetzu [ ] = " " ; char zoqhgdndphdh [ ] = " " ; printf ( " \n " , zxjrxngnsltu ) ; printf ( " \n " , oexgqrkrwmuw ) ; naive_search ( zxjrxngnsltu , oexgqrkrwmuw ) ; printf ( " \n " , ckrsjhphetzu ) ; naive_search ( zxjrxngnsltu , ckrsjhphetzu ) ; printf ( " \n " , zoqhgdndphdh ) ; naive_search ( zxjrxngnsltu , zoqhgdndphdh ) ; return 0 ; }
>>>Func
METHOD rand_string
METHOD_RETURN char*
PARAM wfvmuolmdylf *jtitlejoplte
PARAM size_t auiwidptxdiu
<operator>.assignment wfvmuolmdylfexbuvaykkmbv [ ]="abcdefghijklmnopqrstuvwxyz1234567890"
RETURN return jtitlejoplte; return jtitlejoplte;
IDENTIFIER auiwidptxdiu if (auiwidptxdiu)
IDENTIFIER jtitlejoplte return jtitlejoplte;
<operator>.preDecrement --auiwidptxdiu
<operator>.assignment jtitlejoplte[auiwidptxdiu]='\0'
<operator>.lessThan eyagflzlmrji<auiwidptxdiu
<operator>.postIncrement eyagflzlmrji++
<operator>.assignment eyagflzlmrji=0
<operator>.assignment rwgqmkgnzgnl=rand()%(int)(sizeof exbuvaykkmbv-1)
<operator>.assignment jtitlejoplte[eyagflzlmrji]=exbuvaykkmbv[rwgqmkgnzgnl]
<operator>.modulo rand()%(int)(sizeof exbuvaykkmbv-1)
<operator>.cast (int)(sizeof exbuvaykkmbv-1)
<operator>.subtraction sizeof exbuvaykkmbv-1
<operator>.sizeOf sizeof exbuvaykkmbv
<operator>.indirectIndexAccess jtitlejoplte[eyagflzlmrji]
<operator>.indirectIndexAccess exbuvaykkmbv[rwgqmkgnzgnl]
rand rand()
UNKNOWN int int
>>>PDG&23 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->15 0->17 2->1 2->7 3->1 3->8 4->1 4->1 5->1 7->5 8->1 8->10 9->1 9->1 9->7 10->1 10->1 10->1 10->10 10->11 10->11 10->13 10->14 10->15 10->16 10->17 10->18 10->19 10->20 10->21 10->22 11->1 11->10 12->1 12->10 13->1 13->1 13->1 14->1 14->1 14->1 14->7 15->1 15->1 15->13 15->13 16->1 17->15 17->16 18->1
>>>Token char * rand_string ( wfvmuolmdylf * jtitlejoplte , size_t auiwidptxdiu ) { const wfvmuolmdylfexbuvaykkmbv  [ ] = " " ; if ( auiwidptxdiu ) { -- auiwidptxdiu ; for ( size_t eyagflzlmrji = 0 ; eyagflzlmrji < auiwidptxdiu ; eyagflzlmrji ++ ) { int rwgqmkgnzgnl = rand ( ) % ( int ) ( sizeof exbuvaykkmbv - 1 ) ; jtitlejoplte [ eyagflzlmrji ] = exbuvaykkmbv [ rwgqmkgnzgnl ] ; } jtitlejoplte [ auiwidptxdiu ] = ' \0 ' ; } return jtitlejoplte ; }
>>>Func
METHOD cpdmkxxkriju
METHOD_RETURN double
PARAM k
PARAM j
<operator>.assignment achbksufhdss=0
<operator>.assignment games_won=0
RETURN return (games_won/achbksufhdss); return (games_won/achbksufhdss);
<operator>.lessThan hybrgbbibkdc<N
<operator>.postIncrement hybrgbbibkdc++
<operator>.division games_won/achbksufhdss
<operator>.assignment hybrgbbibkdc=0
<operator>.equals hybrgbbibkdc==j
<operator>.notEquals A[k][hybrgbbibkdc]!='.'
<operator>.postIncrement achbksufhdss++
<operator>.equals A[k][hybrgbbibkdc]=='1'
<operator>.postIncrement games_won++
<operator>.indirectIndexAccess A[k][hybrgbbibkdc]
<operator>.indirectIndexAccess A[k]
<operator>.indirectIndexAccess A[k][hybrgbbibkdc]
<operator>.indirectIndexAccess A[k]
>>>PDG&20 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->1 3->1 3->11 4->1 4->9 4->13 5->1 5->9 5->15 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->11 8->1 8->7 9->1 9->1 9->1 9->6 10->1 10->7 11->1 11->1 11->8 11->12 11->16 11->17 12->1 12->1 12->13 12->14 12->14 12->18 12->19 13->1 13->9 14->1 14->1 14->12 14->15 15->1 15->9
>>>Token double cpdmkxxkriju ( k , j ) { int hybrgbbibkdc ; double achbksufhdss = 0 , games_won = 0 ; for ( hybrgbbibkdc = 0 ; hybrgbbibkdc < N ; hybrgbbibkdc ++ ) { if ( hybrgbbibkdc == j ) { continue ; } if ( A [ k ] [ hybrgbbibkdc ] != ' ' ) { achbksufhdss ++ ; if ( A [ k ] [ hybrgbbibkdc ] == ' ' ) { games_won ++ ; } } } return ( games_won / achbksufhdss ) ; }
>>>Func
METHOD wrdeogneekjf
METHOD_RETURN void
PARAM char kajpmcomwqgp
<operator>.assignment vastus[vlength++]=kajpmcomwqgp
<operator>.assignment vastus[vlength]=0
<operator>.postIncrement count[kajpmcomwqgp-'A']++
<operator>.postIncrement vlength++
<operator>.subtraction kajpmcomwqgp-'A'
>>>PDG&8 0->2 0->3 0->4 0->6 0->7 2->3 2->7 3->1 3->1 4->1 4->1 5->1 5->1 6->1 7->1
>>>Token void wrdeogneekjf ( char kajpmcomwqgp ) { vastus [ vlength ++ ] = kajpmcomwqgp ; vastus [ vlength ] = 0 ; count [ kajpmcomwqgp - ' ' ] ++ ; }
>>>Func
METHOD vtdyvwjynuzr
METHOD_RETURN void
PARAM char *combo
<operator>.assignment ektxoeaoytoy=baseElementToInt(combo[0])
<operator>.assignment iElement2=baseElementToInt(combo[1])
assert assert(ektxoeaoytoy!=-1&&iElement2!=-1)
<operator>.assignment comboChart[ektxoeaoytoy][iElement2]=combo[2]
<operator>.assignment comboChart[iElement2][ektxoeaoytoy]=combo[2]
baseElementToInt baseElementToInt(combo[0])
baseElementToInt baseElementToInt(combo[1])
<operator>.logicalAnd ektxoeaoytoy!=-1&&iElement2!=-1
<operator>.notEquals ektxoeaoytoy!=-1
<operator>.notEquals iElement2!=-1
<operator>.minus -1
<operator>.minus -1
>>>PDG&15 0->2 0->11 0->12 0->13 0->14 2->1 2->6 2->7 2->8 2->9 3->1 3->1 3->11 4->1 4->1 4->1 4->12 5->1 5->1 6->1 6->1 7->1 7->1 7->1 8->1 8->3 9->1 9->4 10->1 10->1 10->5 10->5 11->1 11->1 11->10 11->10 11->12 11->14 12->1 12->1 12->10 12->10 13->11 14->12
>>>Token void vtdyvwjynuzr ( char * combo ) { int ektxoeaoytoy , iElement2 ; ektxoeaoytoy = baseElementToInt ( combo [ 0 ] ) ; iElement2 = baseElementToInt ( combo [ 1 ] ) ; assert ( ektxoeaoytoy != -1 && iElement2 != -1 ) ; comboChart [ ektxoeaoytoy ] [ iElement2 ] = combo [ 2 ] ; comboChart [ iElement2 ] [ ektxoeaoytoy ] = combo [ 2 ] ; }
>>>Func
METHOD iibsljmstetp
METHOD_RETURN int
PARAM int *nums
PARAM int kdzvaxiaqugk
PARAM int lvpuldlcjmim
<operator>.assignment gxyueubaqfbg=0
RETURN return gxyueubaqfbg; return gxyueubaqfbg;
<operator>.lessThan bfldqmeboqhp<kdzvaxiaqugk
<operator>.postIncrement bfldqmeboqhp++
IDENTIFIER gxyueubaqfbg return gxyueubaqfbg;
<operator>.assignment bfldqmeboqhp=0
<operator>.notEquals nums[bfldqmeboqhp]!=lvpuldlcjmim
<operator>.assignment nums[gxyueubaqfbg++]=nums[bfldqmeboqhp]
<operator>.postIncrement gxyueubaqfbg++
<operator>.indirectIndexAccess nums[bfldqmeboqhp]
<operator>.indirectIndexAccess nums[gxyueubaqfbg++]
<operator>.indirectIndexAccess nums[bfldqmeboqhp]
>>>PDG&17 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->13 2->1 2->11 2->12 3->7 4->1 4->11 5->1 5->1 5->9 5->13 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->11 7->14 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->1 11->12 11->12 11->13 11->15 11->16 12->1 12->1 12->1 13->1 13->9
>>>Token int iibsljmstetp ( int * nums , int kdzvaxiaqugk , int lvpuldlcjmim ) { int bfldqmeboqhp , gxyueubaqfbg = 0 ; for ( bfldqmeboqhp = 0 ; bfldqmeboqhp < kdzvaxiaqugk ; bfldqmeboqhp ++ ) { if ( nums [ bfldqmeboqhp ] != lvpuldlcjmim ) nums [ gxyueubaqfbg ++ ] = nums [ bfldqmeboqhp ] ; } return gxyueubaqfbg ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int ncdslafkydmr
PARAM char **argv
init_data init_data()
fgets fgets(iyysitbjdsuz,100,stdin)
assert assert(1==sscanf(iyysitbjdsuz,"%d\n",&mcejansiytcq))
RETURN return 0; return 0;
<operator>.lessEqualsThan cnum<=mcejansiytcq
<operator>.postIncrement cnum++
LITERAL 0 return 0;
<operator>.equals 1==sscanf(iyysitbjdsuz,"%d\n",&mcejansiytcq)
<operator>.assignment cnum=1
do_one_case do_one_case(cnum)
fflush fflush(stdout)
sscanf sscanf(iyysitbjdsuz,"%d\n",&mcejansiytcq)
>>>PDG&16 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->1 3->1 4->1 5->1 5->1 5->15 6->1 6->1 7->1 8->1 8->1 8->1 8->8 8->9 8->13 8->13 8->14 9->1 9->8 10->7 11->1 11->6 11->6 12->1 12->8 13->1 13->9 14->1 14->1 15->1 15->1 15->8 15->11 15->11 15->11
>>>Token int main ( int ncdslafkydmr , char * * argv ) { int mcejansiytcq , cnum ; char iyysitbjdsuz [ 100 ] ; init_data ( ) ; fgets ( iyysitbjdsuz , 100 , stdin ) ; assert ( 1 == sscanf ( iyysitbjdsuz , " \n " , & mcejansiytcq ) ) ; for ( cnum = 1 ; cnum <= mcejansiytcq ; cnum ++ ) { do_one_case ( cnum ) ; fflush ( stdout ) ; } return 0 ; }
>>>Func
METHOD mbbejxrsrvtu
METHOD_RETURN void
PARAM int aiqdrvuqsdrs
<operator>.assignment nr_used=0
<operator>.lessThan xiycdjeyzmcp<aiqdrvuqsdrs
<operator>.postIncrement xiycdjeyzmcp++
<operator>.assignment used[xiycdjeyzmcp]=0
<operator>.assignment xiycdjeyzmcp=0
<operator>.indirectIndexAccess used[xiycdjeyzmcp]
>>>PDG&9 0->2 0->3 0->4 0->5 0->6 0->7 2->4 3->1 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->6 4->8 5->1 5->4 6->1 6->1 7->1 7->4
>>>Token void mbbejxrsrvtu ( int aiqdrvuqsdrs ) { int xiycdjeyzmcp ; for ( xiycdjeyzmcp = 0 ; xiycdjeyzmcp < aiqdrvuqsdrs ; xiycdjeyzmcp ++ ) used [ xiycdjeyzmcp ] = 0 ; nr_used = 0 ; }
>>>Func
METHOD suhfhmigpgfr
METHOD_RETURN int
PARAM const fftjrvevsqff*arr
PARAM fftjrvevsqff glxkjqcngovo
PARAM fftjrvevsqff dctgcmncnbxx
PARAM fftjrvevsqff fruaphqzwstd
<operator>.assignment fdoowsvtmute=glxkjqcngovo+(dctgcmncnbxx-glxkjqcngovo)/2
RETURN return fdoowsvtmute; return fdoowsvtmute;
<operator>.notEquals arr[fdoowsvtmute]!=fruaphqzwstd
IDENTIFIER fdoowsvtmute return fdoowsvtmute;
<operator>.addition glxkjqcngovo+(dctgcmncnbxx-glxkjqcngovo)/2
<operator>.assignment fdoowsvtmute=glxkjqcngovo+(dctgcmncnbxx-glxkjqcngovo)/2
<operator>.division (dctgcmncnbxx-glxkjqcngovo)/2
<operator>.logicalOr dctgcmncnbxx<=glxkjqcngovo||dctgcmncnbxx<0
<operator>.greaterThan arr[fdoowsvtmute]>fruaphqzwstd
<operator>.subtraction dctgcmncnbxx-glxkjqcngovo
RETURN return -1; return -1;
<operator>.assignment dctgcmncnbxx=fdoowsvtmute-1
<operator>.addition glxkjqcngovo+(dctgcmncnbxx-glxkjqcngovo)/2
<operator>.lessEqualsThan dctgcmncnbxx<=glxkjqcngovo
<operator>.lessThan dctgcmncnbxx<0
<operator>.minus -1
<operator>.assignment glxkjqcngovo =fdoowsvtmute+1
<operator>.division (dctgcmncnbxx-glxkjqcngovo)/2
<operator>.subtraction fdoowsvtmute-1
<operator>.subtraction dctgcmncnbxx-glxkjqcngovo
<operator>.addition fdoowsvtmute+1
<operator>.indirectIndexAccess arr[fdoowsvtmute]
<operator>.indirectIndexAccess arr[fdoowsvtmute]
>>>PDG&29 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 2->1 2->8 2->14 3->15 4->15 5->8 6->1 6->1 6->1 6->9 6->22 6->24 6->26 7->1 8->1 8->1 8->1 8->7 8->13 8->14 8->14 8->19 9->7 10->1 11->1 11->1 11->1 11->9 11->22 11->24 11->26 12->1 12->6 12->6 12->10 12->10 13->1 13->1 13->1 13->8 13->11 13->14 13->16 13->18 13->21 13->23 13->25 13->27 13->28 14->1 14->8 14->8 14->17 14->22 14->24 14->26 15->6 15->10 15->12 15->12 15->19 15->19 16->1 17->1 17->1 17->25 18->1 19->1 19->1 19->13 19->13 19->20 19->20 19->25 19->25 20->1 20->13 20->13 20->25 21->1 21->16 22->1 22->1 22->25 23->1 23->11 23->11 23->18 23->18 24->17 24->17 25->11 25->18 25->19 25->19 25->23 25->23
>>>Token int suhfhmigpgfr ( const fftjrvevsqff * arr , fftjrvevsqff glxkjqcngovo , fftjrvevsqff dctgcmncnbxx , fftjrvevsqff fruaphqzwstd ) { fftjrvevsqff fdoowsvtmute = glxkjqcngovo + ( dctgcmncnbxx - glxkjqcngovo ) / 2 ; while ( arr [ fdoowsvtmute ] != fruaphqzwstd ) { if ( dctgcmncnbxx <= glxkjqcngovo || dctgcmncnbxx < 0 ) return -1 ; if ( arr [ fdoowsvtmute ] > fruaphqzwstd ) dctgcmncnbxx = fdoowsvtmute - 1 ; else glxkjqcngovo = fdoowsvtmute + 1 ; fdoowsvtmute = glxkjqcngovo + ( dctgcmncnbxx - glxkjqcngovo ) / 2 ; } return fdoowsvtmute ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment in=fopen("input_1.txt","r")
<operator>.assignment out=fopen("output_1.txt","w")
fscanf fscanf(in,"%d",&vtzlainrrryx)
RETURN return 0; return 0;
<operator>.lessEqualsThan t<=vtzlainrrryx
<operator>.postIncrement t++
LITERAL 0 return 0;
fopen fopen("input_1.txt","r")
fopen fopen("output_1.txt","w")
<operator>.assignment t=1
fprintf fprintf(out,"Case #%d:\n",t)
solve solve()
>>>PDG&14 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->1 2->1 2->4 3->1 3->1 3->1 3->12 4->1 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->12 6->12 6->13 7->1 7->6 8->5 9->2 9->2 10->3 10->3 11->1 11->6 12->1 12->1 12->7 13->1
>>>Token int main ( ) { int vtzlainrrryx , t ; in = fopen ( " " , " " ) ; out = fopen ( " " , " " ) ; fscanf ( in , " " , & vtzlainrrryx ) ; for ( t = 1 ; t <= vtzlainrrryx ; t ++ ) { fprintf ( out , " \n " , t ) ; solve ( ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
freopen freopen("output.txt","w",stdout)
scanf scanf("%d",&hyuuuinfujrp)
RETURN return 0; return 0;
<operator>.lessEqualsThan mrlvtgngixjy<=hyuuuinfujrp
<operator>.postIncrement mrlvtgngixjy++
LITERAL 0 return 0;
<operator>.assignment mrlvtgngixjy=1
<operator>.assignment pmqzscxnaxoc=make()
printf printf("Case #%d: %d\n",mrlvtgngixjy,pmqzscxnaxoc)
make make()
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->9 5->10 5->10 5->11 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->10 10->1 10->1 10->6
>>>Token int main ( ) { int mrlvtgngixjy ; int hyuuuinfujrp ; freopen ( " " , " " , stdout ) ; scanf ( " " , & hyuuuinfujrp ) ; for ( mrlvtgngixjy = 1 ; mrlvtgngixjy <= hyuuuinfujrp ; mrlvtgngixjy ++ ) { int pmqzscxnaxoc = make ( ) ; printf ( " \n " , mrlvtgngixjy , pmqzscxnaxoc ) ; } return 0 ; }
>>>Func
METHOD tqutxkmlyybc
METHOD_RETURN void
PARAM int *a
PARAM size_t bwkdejettctx
<operator>.assignment beads=calloc(1,max *bwkdejettctx)
free free(beads)
<operator>.lessThan matsgxmmwmad<bwkdejettctx
<operator>.postIncrement matsgxmmwmad++
<operator>.lessThan matsgxmmwmad<bwkdejettctx
<operator>.postIncrement matsgxmmwmad++
<operator>.lessThan j<max
<operator>.postIncrement j++
<operator>.lessThan matsgxmmwmad<bwkdejettctx
<operator>.postIncrement matsgxmmwmad++
<operator>.expressionList matsgxmmwmad=1 max=a[0]
<operator>.greaterThan a[matsgxmmwmad]>max
calloc calloc(1,max *bwkdejettctx)
<operator>.assignment matsgxmmwmad=0
<operator>.lessThan j<a[matsgxmmwmad]
<operator>.postIncrement j++
<operator>.assignment BEAD(matsgxmmwmad,j)=1
<operator>.assignment j=0
<operator>.assignment matsgxmmwmad=0
<operator>.assignment a[matsgxmmwmad]=j
<operator>.assignment max=a[matsgxmmwmad]
<operator>.multiplication max *bwkdejettctx
<operator>.assignment j=0
<operator>.lessThan matsgxmmwmad<bwkdejettctx
<operator>.postIncrement matsgxmmwmad++
<operator>.lessThan matsgxmmwmad<bwkdejettctx
<operator>.postIncrement matsgxmmwmad++
<operator>.assignment BEAD(matsgxmmwmad,j)=1
<operator>.logicalAnd j<max&&BEAD(matsgxmmwmad,j)
<operator>.postIncrement j++
<operator>.assignment matsgxmmwmad=1
<operator>.assignment max=a[0]
BEAD BEAD(matsgxmmwmad,j)
<operator>.assignment sum=matsgxmmwmad=0
<operator>.assignmentPlus sum+=BEAD(matsgxmmwmad,j)
<operator>.assignment BEAD(matsgxmmwmad,j)=0
<operator>.assignment matsgxmmwmad=bwkdejettctx-sum
<operator>.assignment j=0
BEAD BEAD(matsgxmmwmad,j)
<operator>.lessThan j<max
BEAD BEAD(matsgxmmwmad,j)
<operator>.assignment matsgxmmwmad=0
BEAD BEAD(matsgxmmwmad,j)
BEAD BEAD(matsgxmmwmad,j)
<operator>.subtraction bwkdejettctx-sum
<operator>.indirectIndexAccess a[matsgxmmwmad]
<operator>.indirectIndexAccess a[matsgxmmwmad]
<operator>.indirectIndexAccess a[matsgxmmwmad]
<operator>.indirectIndexAccess a[matsgxmmwmad]
>>>PDG&53 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->34 0->36 0->37 0->38 0->39 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 2->1 2->14 2->15 2->18 2->24 2->35 3->6 4->1 4->1 4->5 5->1 6->6 6->7 6->7 6->15 6->25 6->49 7->1 7->6 8->8 8->9 8->9 8->12 8->18 8->26 8->27 8->36 8->50 9->1 9->8 10->1 10->1 10->1 10->10 10->11 10->11 10->27 10->29 10->37 10->40 10->42 10->43 10->45 10->46 10->48 11->1 11->10 12->1 12->1 12->1 12->12 12->13 12->13 12->23 12->32 12->41 12->43 12->44 12->51 13->1 13->12 14->1 14->1 14->1 15->1 15->1 15->18 15->24 15->24 15->25 15->52 16->1 17->8 18->1 18->1 18->18 18->19 18->20 18->36 18->36 18->50 19->1 19->18 20->1 20->1 20->32 21->1 21->10 22->1 22->12 23->1 23->1 23->1 24->1 24->1 24->15 24->25 25->4 25->4 25->8 25->10 25->16 25->16 26->18 27->27 27->28 27->38 27->39 27->46 27->46 27->47 27->48 28->1 28->27 29->12 29->27 29->29 29->30 29->31 29->42 29->42 30->1 30->29 31->1 31->1 31->32 32->1 32->1 32->1 32->32 32->33 32->43 33->1 33->43 34->6 34->14 35->1 35->14 35->15 35->25 36->9 36->19 37->1 37->38 37->48 38->1 38->48 39->1 39->1 39->32 40->1 40->1 40->29 41->1 41->43 42->11 42->30 43->1 43->23 43->32 43->32 43->33 43->44 43->44 44->13 44->23 44->32 44->32 44->33 45->27 45->37 46->38 46->38 46->47 46->47 47->11 47->28 47->42 47->46 48->1 48->29 48->40 48->40
>>>Token void tqutxkmlyybc ( int * a , size_t bwkdejettctx ) { int matsgxmmwmad , j , max , sum ; unsigned gdclqfouwlfc * beads ; for ( matsgxmmwmad = 1 , max = a [ 0 ] ; matsgxmmwmad < bwkdejettctx ; matsgxmmwmad ++ ) if ( a [ matsgxmmwmad ] > max ) max = a [ matsgxmmwmad ] ; beads = calloc ( 1 , max * bwkdejettctx ) ; for ( matsgxmmwmad = 0 ; matsgxmmwmad < bwkdejettctx ; matsgxmmwmad ++ ) for ( j = 0 ; j < a [ matsgxmmwmad ] ; j ++ ) BEAD ( matsgxmmwmad , j ) = 1 ; for ( j = 0 ; j < max ; j ++ ) { for ( sum = matsgxmmwmad = 0 ; matsgxmmwmad < bwkdejettctx ; matsgxmmwmad ++ ) { sum += BEAD ( matsgxmmwmad , j ) ; BEAD ( matsgxmmwmad , j ) = 0 ; } for ( matsgxmmwmad = bwkdejettctx - sum ; matsgxmmwmad < bwkdejettctx ; matsgxmmwmad ++ ) BEAD ( matsgxmmwmad , j ) = 1 ; } for ( matsgxmmwmad = 0 ; matsgxmmwmad < bwkdejettctx ; matsgxmmwmad ++ ) { for ( j = 0 ; j < max && BEAD ( matsgxmmwmad , j ) ; j ++ ) ; a [ matsgxmmwmad ] = j ; } free ( beads ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment ncase=1
IDENTIFIER oppositions <empty>
<operator>.assignment base2id['Q']=0
<operator>.assignment base2id['W']=1
<operator>.assignment base2id['E']=2
<operator>.assignment base2id['R']=3
<operator>.assignment base2id['A']=4
<operator>.assignment base2id['S']=5
<operator>.assignment base2id['D']=6
<operator>.assignment base2id['F']=7
scanf scanf("%d",&nanjxcwoviwr)
RETURN return 0; return 0;
<operator>.lessEqualsThan disrkxigxfrg<='Z'
<operator>.postIncrement disrkxigxfrg++
<operator>.assignment base2id[disrkxigxfrg]=-1
<operator>.lessEqualsThan ncase<=nanjxcwoviwr
LITERAL 0 return 0;
<operator>.assignment disrkxigxfrg='A'
<operator>.assignment rnjtezifyqgv=0
<operator>.assignment oppositions=0
scanf scanf("%d ",&wnlmiyrfrwjh)
scanf scanf("%d ",&d)
scanf scanf("%d %s",&n,adglhlszpktg)
printf printf("Case #%d: [",ncase++)
printf printf("]\n")
<operator>.minus -1
<operator>.lessThan disrkxigxfrg<8
<operator>.postIncrement disrkxigxfrg++
<operator>.lessThan disrkxigxfrg<wnlmiyrfrwjh
<operator>.postIncrement disrkxigxfrg++
<operator>.lessThan disrkxigxfrg<d
<operator>.postIncrement disrkxigxfrg++
<operator>.lessThan disrkxigxfrg<n
<operator>.postIncrement disrkxigxfrg++
<operator>.greaterThan rnjtezifyqgv>0
<operator>.assignment disrkxigxfrg=0
<operator>.assignment opposed[disrkxigxfrg]=0
<operator>.assignment disrkxigxfrg=0
scanf scanf("%s ",adglhlszpktg)
<operator>.assignment qqukhquzrepj=base2id[adglhlszpktg[0]]
<operator>.assignment e2=base2id[adglhlszpktg[1]]
<operator>.assignment combos[qqukhquzrepj][e2]=adglhlszpktg[2]
<operator>.assignment combos[e2][qqukhquzrepj]=adglhlszpktg[2]
<operator>.assignment disrkxigxfrg=0
scanf scanf("%s ",adglhlszpktg)
<operator>.assignment qqukhquzrepj=base2id[adglhlszpktg[0]]
<operator>.assignment e2=base2id[adglhlszpktg[1]]
<operators>.assignmentOr opposed[qqukhquzrepj]|=1<<e2
<operators>.assignmentOr opposed[e2]|=1<<qqukhquzrepj
<operator>.assignment disrkxigxfrg=0
<operator>.assignment whkcmusaamxi[rnjtezifyqgv++]=adglhlszpktg[disrkxigxfrg]
<operator>.postIncrement ncase++
printf printf("%c",whkcmusaamxi[disrkxigxfrg])
<operator>.lessThan j<8
<operator>.postIncrement j++
<operator>.assignment combos[disrkxigxfrg][j]=0
<operator>.logicalOr qqukhquzrepj<0||e2<0
<operator>.logicalOr qqukhquzrepj<0||e2<0
<operator>.greaterThan rnjtezifyqgv>1
<operator>.logicalAnd rnjtezifyqgv>0&&(e2=base2id[whkcmusaamxi[rnjtezifyqgv-1]])>=0
<operator>.lessThan disrkxigxfrg<rnjtezifyqgv-1
<operator>.postIncrement disrkxigxfrg++
printf printf("%c, ",whkcmusaamxi[disrkxigxfrg])
<operator>.assignment j=0
fprintf fprintf(stderr,"Not base1 %d %d %c %c\n",qqukhquzrepj,e2,adglhlszpktg[0],adglhlszpktg[1])
fprintf fprintf(stderr,"Not base2 %d %d %c %c\n",qqukhquzrepj,e2,adglhlszpktg[0],adglhlszpktg[1])
<operator>.shiftLeft 1<<e2
<operator>.shiftLeft 1<<qqukhquzrepj
<operators>.assignmentOr oppositions|=opposed[e2]
<operator>.assignment disrkxigxfrg=0
<operator>.lessThan qqukhquzrepj<0
<operator>.lessThan e2<0
<operator>.lessThan qqukhquzrepj<0
<operator>.lessThan e2<0
<operator>.postIncrement rnjtezifyqgv++
<operator>.logicalAnd (e2=base2id[whkcmusaamxi[rnjtezifyqgv-1]])>=0&&(qqukhquzrepj=base2id[whkcmusaamxi[rnjtezifyqgv-2]])>=0&&(uqvybygizwrf=combos[qqukhquzrepj][e2])!=0
<operator>.logicalAnd (e2=base2id[whkcmusaamxi[rnjtezifyqgv-1]])>=0&&(oppositions&(1<<e2))!=0
<operator>.greaterThan rnjtezifyqgv>0
<operator>.greaterEqualsThan (e2=base2id[whkcmusaamxi[rnjtezifyqgv-1]])>=0
<operator>.subtraction rnjtezifyqgv-1
<operator>.assignment whkcmusaamxi[rnjtezifyqgv-2]=uqvybygizwrf
<operator>.postDecrement rnjtezifyqgv--
<operator>.assignment oppositions=rnjtezifyqgv=0
<operator>.assignment e2=base2id[whkcmusaamxi[rnjtezifyqgv-1]]
<operator>.logicalAnd (e2=base2id[whkcmusaamxi[rnjtezifyqgv-1]])>=0&&(qqukhquzrepj=base2id[whkcmusaamxi[rnjtezifyqgv-2]])>=0
<operator>.notEquals (uqvybygizwrf=combos[qqukhquzrepj][e2])!=0
<operator>.greaterEqualsThan (e2=base2id[whkcmusaamxi[rnjtezifyqgv-1]])>=0
<operator>.notEquals (oppositions&(1<<e2))!=0
<operator>.greaterEqualsThan (e2=base2id[whkcmusaamxi[rnjtezifyqgv-1]])>=0
<operator>.greaterEqualsThan (qqukhquzrepj=base2id[whkcmusaamxi[rnjtezifyqgv-2]])>=0
<operator>.assignment uqvybygizwrf=combos[qqukhquzrepj][e2]
<operator>.assignment e2=base2id[whkcmusaamxi[rnjtezifyqgv-1]]
<operator>.and oppositions&(1<<e2)
<operator>.assignment rnjtezifyqgv=0
<operator>.assignment e2=base2id[whkcmusaamxi[rnjtezifyqgv-1]]
<operator>.assignment qqukhquzrepj=base2id[whkcmusaamxi[rnjtezifyqgv-2]]
<operator>.subtraction rnjtezifyqgv-2
<operator>.shiftLeft 1<<e2
<operator>.subtraction rnjtezifyqgv-1
<operator>.subtraction rnjtezifyqgv-1
<operator>.subtraction rnjtezifyqgv-1
<operator>.subtraction rnjtezifyqgv-2
<operator>.indirectIndexAccess base2id[disrkxigxfrg]
<operator>.addressOf &wnlmiyrfrwjh
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.indirectIndexAccess opposed[disrkxigxfrg]
<operator>.indirectIndexAccess base2id[adglhlszpktg[0]]
<operator>.indirectIndexAccess base2id[adglhlszpktg[1]]
<operator>.indirectIndexAccess combos[qqukhquzrepj][e2]
<operator>.indirectIndexAccess adglhlszpktg[2]
<operator>.indirectIndexAccess combos[e2][qqukhquzrepj]
<operator>.indirectIndexAccess adglhlszpktg[2]
<operator>.indirectIndexAccess base2id[adglhlszpktg[0]]
<operator>.indirectIndexAccess base2id[adglhlszpktg[1]]
<operator>.indirectIndexAccess opposed[qqukhquzrepj]
<operator>.indirectIndexAccess opposed[e2]
<operator>.indirectIndexAccess whkcmusaamxi[rnjtezifyqgv++]
<operator>.indirectIndexAccess adglhlszpktg[disrkxigxfrg]
<operator>.indirectIndexAccess whkcmusaamxi[disrkxigxfrg]
<operator>.indirectIndexAccess combos[disrkxigxfrg][j]
<operator>.indirectIndexAccess adglhlszpktg[0]
<operator>.indirectIndexAccess adglhlszpktg[1]
<operator>.indirectIndexAccess combos[qqukhquzrepj]
<operator>.indirectIndexAccess combos[e2]
<operator>.indirectIndexAccess adglhlszpktg[0]
<operator>.indirectIndexAccess adglhlszpktg[1]
<operator>.indirectIndexAccess whkcmusaamxi[disrkxigxfrg]
<operator>.indirectIndexAccess combos[disrkxigxfrg]
<operator>.indirectIndexAccess adglhlszpktg[0]
<operator>.indirectIndexAccess adglhlszpktg[1]
<operator>.indirectIndexAccess adglhlszpktg[0]
<operator>.indirectIndexAccess adglhlszpktg[1]
<operator>.indirectIndexAccess opposed[e2]
<operator>.indirectIndexAccess base2id[whkcmusaamxi[rnjtezifyqgv-1]]
<operator>.indirectIndexAccess whkcmusaamxi[rnjtezifyqgv-2]
<operator>.indirectIndexAccess whkcmusaamxi[rnjtezifyqgv-1]
<operator>.indirectIndexAccess combos[qqukhquzrepj][e2]
<operator>.indirectIndexAccess base2id[whkcmusaamxi[rnjtezifyqgv-1]]
<operator>.indirectIndexAccess base2id[whkcmusaamxi[rnjtezifyqgv-1]]
<operator>.indirectIndexAccess base2id[whkcmusaamxi[rnjtezifyqgv-2]]
<operator>.indirectIndexAccess combos[qqukhquzrepj]
<operator>.indirectIndexAccess whkcmusaamxi[rnjtezifyqgv-1]
<operator>.indirectIndexAccess whkcmusaamxi[rnjtezifyqgv-1]
<operator>.indirectIndexAccess whkcmusaamxi[rnjtezifyqgv-2]
>>>PDG&147 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->45 0->46 0->51 0->53 0->54 0->55 0->56 0->57 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->79 0->80 0->81 0->82 0->83 0->84 0->87 0->88 0->89 0->90 0->91 0->94 0->95 0->98 0->99 0->100 0->101 0->102 0->103 2->1 2->17 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 9->1 9->1 10->1 10->1 11->1 11->1 12->1 12->17 13->1 14->1 14->1 14->14 14->15 14->15 14->16 14->27 14->104 15->1 15->14 16->1 16->1 16->1 17->1 17->1 17->1 17->17 17->20 17->21 17->22 17->23 17->24 17->25 17->26 17->28 17->30 17->32 17->34 17->36 17->37 17->39 17->45 17->51 17->53 17->53 17->105 17->106 17->107 18->13 19->1 19->14 20->1 20->36 20->76 21->1 21->1 21->70 21->94 22->1 22->30 23->1 23->32 24->1 24->1 24->34 25->1 25->1 26->1 27->16 28->1 28->28 28->29 28->29 28->38 28->55 28->65 28->108 29->1 29->28 30->1 30->1 30->22 30->30 30->31 30->31 30->40 30->41 30->42 30->43 30->44 30->58 30->72 30->109 30->110 30->111 30->112 30->113 30->114 30->123 30->124 30->125 30->126 31->1 31->30 32->1 32->1 32->23 32->32 32->33 32->33 32->46 32->47 32->48 32->49 32->50 32->59 32->68 32->69 32->74 32->115 32->116 32->117 32->118 32->127 32->128 33->1 33->32 34->1 34->1 34->1 34->24 34->34 34->35 34->35 34->52 34->60 34->61 34->76 34->79 34->119 34->120 35->1 35->34 36->1 36->1 36->54 36->62 36->71 36->81 36->81 36->121 37->28 38->1 38->1 39->30 40->43 40->44 40->46 40->66 41->1 41->1 41->72 42->1 42->1 42->1 42->66 42->73 43->1 43->1 43->87 43->92 44->1 44->1 44->1 45->32 46->67 47->1 47->1 47->74 48->1 48->1 48->67 48->68 48->75 49->1 49->1 50->1 50->1 50->70 51->1 51->34 52->1 52->1 52->1 53->17 53->25 54->1 54->1 54->64 55->1 55->1 55->55 55->56 55->56 55->57 55->122 55->130 56->1 56->55 57->1 57->1 58->1 58->1 58->1 58->59 58->66 58->131 58->132 59->1 59->1 59->1 59->58 59->67 59->133 59->134 60->1 60->77 60->78 60->79 60->86 60->88 60->90 60->93 60->96 60->101 60->102 60->102 60->140 60->141 60->144 60->145 61->1 61->1 61->70 61->135 62->1 62->1 62->1 62->62 62->63 62->63 62->64 62->81 62->129 63->1 63->62 64->1 64->54 65->1 65->55 66->1 66->1 66->1 66->1 66->1 66->1 66->40 66->40 66->46 66->46 66->67 66->67 66->67 67->1 67->1 67->1 67->1 67->40 67->40 67->46 67->46 67->66 67->66 67->66 67->68 67->69 68->1 68->49 68->49 69->1 69->50 69->50 70->1 70->1 70->94 71->1 71->62 72->1 72->58 72->58 72->66 72->73 73->1 73->58 73->58 73->66 74->59 74->59 74->67 74->69 74->75 75->59 75->59 75->67 75->68 76->60 77->1 77->1 77->1 77->77 77->82 77->83 77->86 77->90 77->96 77->98 77->102 77->137 77->141 77->145 78->1 78->1 78->61 78->84 78->95 79->36 79->61 79->61 79->76 79->80 79->85 79->100 79->100 79->136 79->138 80->1 80->61 80->61 81->1 81->62 81->62 82->1 82->1 82->1 83->1 83->102 84->1 84->1 84->1 84->70 84->94 85->1 85->1 85->80 86->1 86->77 86->77 86->87 86->92 86->139 86->143 87->1 87->77 87->77 88->1 88->78 88->78 88->89 88->94 88->99 89->1 89->78 89->78 90->86 90->86 90->91 90->97 90->103 90->142 90->146 91->1 91->86 91->86 92->1 92->1 92->82 92->87 93->1 93->1 93->88 93->99 94->1 94->1 94->70 94->89 94->89 95->79 95->84 96->90 97->1 97->1 97->91 98->83 99->1 99->94 99->94 100->36 100->76 101->79 102->98 102->101 102->103 103->98 103->101
>>>Token int main ( ) { int nanjxcwoviwr , ncase = 1 ; int wnlmiyrfrwjh , d , n ; pmopjxczhszz adglhlszpktg [ 101 ] ; pmopjxczhszz whkcmusaamxi [ 101 ] ; int rnjtezifyqgv ; int disrkxigxfrg , j ; int qqukhquzrepj , e2 ; pmopjxczhszz uqvybygizwrf ; unsigned pmopjxczhszz oppositions ; for ( disrkxigxfrg = ' ' ; disrkxigxfrg <= ' ' ; disrkxigxfrg ++ ) base2id [ disrkxigxfrg ] = -1 ; base2id [ ' ' ] = 0 ; base2id [ ' ' ] = 1 ; base2id [ ' ' ] = 2 ; base2id [ ' ' ] = 3 ; base2id [ ' ' ] = 4 ; base2id [ ' ' ] = 5 ; base2id [ ' ' ] = 6 ; base2id [ ' ' ] = 7 ; scanf ( " " , & nanjxcwoviwr ) ; while ( ncase <= nanjxcwoviwr ) { for ( disrkxigxfrg = 0 ; disrkxigxfrg < 8 ; disrkxigxfrg ++ ) { opposed [ disrkxigxfrg ] = 0 ; for ( j = 0 ; j < 8 ; j ++ ) combos [ disrkxigxfrg ] [ j ] = 0 ; } rnjtezifyqgv = 0 ; oppositions = 0 ; scanf ( " " , & wnlmiyrfrwjh ) ; for ( disrkxigxfrg = 0 ; disrkxigxfrg < wnlmiyrfrwjh ; disrkxigxfrg ++ ) { scanf ( " " , adglhlszpktg ) ; qqukhquzrepj = base2id [ adglhlszpktg [ 0 ] ] ; e2 = base2id [ adglhlszpktg [ 1 ] ] ; if ( qqukhquzrepj < 0 || e2 < 0 ) fprintf ( stderr , " \n " , qqukhquzrepj , e2 , adglhlszpktg [ 0 ] , adglhlszpktg [ 1 ] ) ; combos [ qqukhquzrepj ] [ e2 ] = adglhlszpktg [ 2 ] ; combos [ e2 ] [ qqukhquzrepj ] = adglhlszpktg [ 2 ] ; } scanf ( " " , & d ) ; for ( disrkxigxfrg = 0 ; disrkxigxfrg < d ; disrkxigxfrg ++ ) { scanf ( " " , adglhlszpktg ) ; qqukhquzrepj = base2id [ adglhlszpktg [ 0 ] ] ; e2 = base2id [ adglhlszpktg [ 1 ] ] ; if ( qqukhquzrepj < 0 || e2 < 0 ) fprintf ( stderr , " \n " , qqukhquzrepj , e2 , adglhlszpktg [ 0 ] , adglhlszpktg [ 1 ] ) ; opposed [ qqukhquzrepj ] |= 1 << e2 ; opposed [ e2 ] |= 1 << qqukhquzrepj ; } scanf ( " " , & n , adglhlszpktg ) ; for ( disrkxigxfrg = 0 ; disrkxigxfrg < n ; disrkxigxfrg ++ ) { whkcmusaamxi [ rnjtezifyqgv ++ ] = adglhlszpktg [ disrkxigxfrg ] ; if ( rnjtezifyqgv > 1 ) { while ( ( e2 = base2id [ whkcmusaamxi [ rnjtezifyqgv - 1 ] ] ) >= 0 && ( qqukhquzrepj = base2id [ whkcmusaamxi [ rnjtezifyqgv - 2 ] ] ) >= 0 && ( uqvybygizwrf = combos [ qqukhquzrepj ] [ e2 ] ) != 0 ) { whkcmusaamxi [ rnjtezifyqgv - 2 ] = uqvybygizwrf ; rnjtezifyqgv -- ; } if ( ( e2 = base2id [ whkcmusaamxi [ rnjtezifyqgv - 1 ] ] ) >= 0 && ( oppositions & ( 1 << e2 ) ) != 0 ) { oppositions = rnjtezifyqgv = 0 ; } } if ( rnjtezifyqgv > 0 && ( e2 = base2id [ whkcmusaamxi [ rnjtezifyqgv - 1 ] ] ) >= 0 ) oppositions |= opposed [ e2 ] ; } printf ( " " , ncase ++ ) ; if ( rnjtezifyqgv > 0 ) { for ( disrkxigxfrg = 0 ; disrkxigxfrg < rnjtezifyqgv - 1 ; disrkxigxfrg ++ ) printf ( " " , whkcmusaamxi [ disrkxigxfrg ] ) ; printf ( " " , whkcmusaamxi [ disrkxigxfrg ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD dxcxynrvpnyw
METHOD_RETURN int
PARAM int xcktjlcpwpbm
PARAM int ruvzchdchavy
RETURN return dxcxynrvpnyw(ruvzchdchavy,xcktjlcpwpbm%ruvzchdchavy); return dxcxynrvpnyw(ruvzchdchavy,xcktjlcpwpbm%ruvzchdchavy);
<operator>.equals ruvzchdchavy==0
dxcxynrvpnyw dxcxynrvpnyw(ruvzchdchavy,xcktjlcpwpbm%ruvzchdchavy)
RETURN return xcktjlcpwpbm; return xcktjlcpwpbm;
IDENTIFIER xcktjlcpwpbm return xcktjlcpwpbm;
<operator>.modulo xcktjlcpwpbm%ruvzchdchavy
>>>PDG&10 0->2 0->3 0->5 0->6 0->8 0->9 2->1 2->8 2->9 3->5 4->1 5->1 5->1 5->4 5->6 5->7 5->9 5->9 6->4 7->1 8->7 9->6 9->6
>>>Token int dxcxynrvpnyw ( int xcktjlcpwpbm , int ruvzchdchavy ) { if ( ruvzchdchavy == 0 ) return xcktjlcpwpbm ; return dxcxynrvpnyw ( ruvzchdchavy , xcktjlcpwpbm % ruvzchdchavy ) ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&rrnxlqckoijc)
RETURN return 0; return 0;
<operator>.lessEqualsThan cvuboktyyqje<=rrnxlqckoijc
<operator>.postIncrement cvuboktyyqje++
LITERAL 0 return 0;
<operator>.assignment cvuboktyyqje=1
scanf scanf("%d",&pisltyybxdoa)
scanf scanf("%d",&wfxunwhwxstt)
scanf scanf("%d",&pxbjsniatlci)
scanf scanf(" %s",cqlriiehtjvi)
<operator>.assignment cqlriiehtjvi[pxbjsniatlci]='\0'
IDENTIFIER std <empty>
fprintf fprintf(stderr "S = %s\n" hpsxxpitcaot.c_str())
<operator>.assignment cspbqhidqzci=0
printf printf("Case #%d: [",cvuboktyyqje)
printf printf("]\n")
<operator>.lessThan ibpfathacuum<pisltyybxdoa
<operator>.postIncrement ibpfathacuum++
<operator>.lessThan hmsfbunznltb<wfxunwhwxstt
<operator>.postIncrement hmsfbunznltb++
<operator>.lessThan dhezmabmneon<wfxunwhwxstt
<operator>.postIncrement dhezmabmneon++
<operator>.lessThan cspbqhidqzci<hpsxxpitcaot.length()
<operator>.lessThan cspbqhidqzci<hpsxxpitcaot.length()
<operator>.postIncrement cspbqhidqzci++
<operator>.assignment ibpfathacuum=0
scanf scanf(" %s",cqlriiehtjvi)
<operator>.assignment xsstlubcgzhw[ibpfathacuum].x=cqlriiehtjvi[0]
<operator>.assignment xsstlubcgzhw[ibpfathacuum].y=cqlriiehtjvi[1]
<operator>.assignment xsstlubcgzhw[ibpfathacuum].z=cqlriiehtjvi[2]
fprintf fprintf(stderr,"- Cs[%d] = %c%c%c\n",ibpfathacuum,xsstlubcgzhw[ibpfathacuum].x,xsstlubcgzhw[ibpfathacuum].y,xsstlubcgzhw[ibpfathacuum].z)
<operator>.assignment hmsfbunznltb=0
scanf scanf(" %s",cqlriiehtjvi)
<operator>.assignment twsclficdnzc[hmsfbunznltb].x=cqlriiehtjvi[0]
<operator>.assignment twsclficdnzc[hmsfbunznltb].y=cqlriiehtjvi[1]
fprintf fprintf(stderr,"- Ds[%d] = %c%c\n",hmsfbunznltb,twsclficdnzc[hmsfbunznltb].x,twsclficdnzc[hmsfbunznltb].y)
c_str hpsxxpitcaot.c_str()
<operator>.assignment dhezmabmneon=0
<operator>.assignment uuaieytcldzr[dhezmabmneon]=-1
fprintf fprintf(stderr,"!!! S[%d]=%c\n",cspbqhidqzci,hpsxxpitcaot[cspbqhidqzci])
<operator>.assignment htcwoxuxnuap=false
<operator>.assignment dxuwowmhmwir=(cspbqhidqzci>0)
<operator>.postIncrement cspbqhidqzci++
<operator>.assignment cspbqhidqzci=0
printf printf("%c",hpsxxpitcaot[cspbqhidqzci])
<operator>.notEquals xsstlubcgzhw[ibpfathacuum].x!=xsstlubcgzhw[ibpfathacuum].y
<operator>.notEquals twsclficdnzc[hmsfbunznltb].x!=twsclficdnzc[hmsfbunznltb].y
length hpsxxpitcaot.length()
<operator>.lessThan dhezmabmneon<wfxunwhwxstt
<operator>.postIncrement dhezmabmneon++
IDENTIFIER dxuwowmhmwir while (dxuwowmhmwir)
IDENTIFIER htcwoxuxnuap if (htcwoxuxnuap)
<operator>.lessThan hmsfbunznltb<wfxunwhwxstt
<operator>.postIncrement hmsfbunznltb++
IDENTIFIER htcwoxuxnuap if (htcwoxuxnuap)
<operator>.lessThan hmsfbunznltb<wfxunwhwxstt
<operator>.postIncrement hmsfbunznltb++
length hpsxxpitcaot.length()
<operator>.greaterThan cspbqhidqzci>0
<operator>.postIncrement ibpfathacuum++
<operator>.postIncrement pisltyybxdoa++
<operator>.assignment xsstlubcgzhw[ibpfathacuum].x=cqlriiehtjvi[1]
<operator>.assignment xsstlubcgzhw[ibpfathacuum].y=cqlriiehtjvi[0]
<operator>.assignment xsstlubcgzhw[ibpfathacuum].z=cqlriiehtjvi[2]
fprintf fprintf(stderr,"+ Cs[%d] = %c%c%c\n",ibpfathacuum,xsstlubcgzhw[ibpfathacuum].x,xsstlubcgzhw[ibpfathacuum].y,xsstlubcgzhw[ibpfathacuum].z)
<operator>.postIncrement hmsfbunznltb++
<operator>.postIncrement wfxunwhwxstt++
<operator>.assignment twsclficdnzc[hmsfbunznltb].x=cqlriiehtjvi[1]
<operator>.assignment twsclficdnzc[hmsfbunznltb].y=cqlriiehtjvi[0]
fprintf fprintf(stderr,"+ Ds[%d] = %c%c\n",hmsfbunznltb,twsclficdnzc[hmsfbunznltb].x,twsclficdnzc[hmsfbunznltb].y)
<operator>.minus -1
<operator>.assignment dhezmabmneon=0
<operator>.greaterThan cspbqhidqzci>0
<operator>.assignment dxuwowmhmwir=false
<operator>.assignment cspbqhidqzci=0
<operator>.assignment hmsfbunznltb=0
<operator>.assignment cspbqhidqzci=0
<operator>.assignment hmsfbunznltb=0
printf printf(", ")
<operator>.greaterEqualsThan uuaieytcldzr[dhezmabmneon]>=cspbqhidqzci
<operator>.lessThan ibpfathacuum<pisltyybxdoa
<operator>.postIncrement ibpfathacuum++
<operator>.logicalAnd twsclficdnzc[hmsfbunznltb].y==hpsxxpitcaot[cspbqhidqzci]&&uuaieytcldzr[hmsfbunznltb]>=0
<operator>.logicalAnd twsclficdnzc[hmsfbunznltb].x==hpsxxpitcaot[cspbqhidqzci]&&uuaieytcldzr[hmsfbunznltb]<0
<operator>.assignment uuaieytcldzr[dhezmabmneon]=-1
<operator>.assignment ibpfathacuum=0
fprintf fprintf(stderr "!!! %s (Db[%d]=%d, n=%d) -> " hpsxxpitcaot.c_str(),hmsfbunznltb,uuaieytcldzr[hmsfbunznltb],cspbqhidqzci)
erase hpsxxpitcaot.erase(0,cspbqhidqzci+1)
fprintf fprintf(stderr "%s\n" hpsxxpitcaot.c_str())
<operator>.assignment cspbqhidqzci=0
<operator>.assignment htcwoxuxnuap=true
<operator>.assignment uuaieytcldzr[hmsfbunznltb]=cspbqhidqzci
fprintf fprintf(stderr,"!!! Db[%d]=%d\n",hmsfbunznltb,uuaieytcldzr[hmsfbunznltb])
<operator>.logicalAnd xsstlubcgzhw[ibpfathacuum].x==hpsxxpitcaot[cspbqhidqzci-1]&&xsstlubcgzhw[ibpfathacuum].y==hpsxxpitcaot[cspbqhidqzci]
<operator>.equals twsclficdnzc[hmsfbunznltb].y==hpsxxpitcaot[cspbqhidqzci]
<operator>.greaterEqualsThan uuaieytcldzr[hmsfbunznltb]>=0
<operator>.equals twsclficdnzc[hmsfbunznltb].x==hpsxxpitcaot[cspbqhidqzci]
<operator>.lessThan uuaieytcldzr[hmsfbunznltb]<0
<operator>.minus -1
fprintf fprintf(stderr "!!! %s (Cs[%d]=%c%c%c, n=%d) -> " hpsxxpitcaot.c_str(),ibpfathacuum,xsstlubcgzhw[ibpfathacuum].x,xsstlubcgzhw[ibpfathacuum].y,xsstlubcgzhw[ibpfathacuum].z,cspbqhidqzci)
erase hpsxxpitcaot.erase(cspbqhidqzci,1)
<operator>.postDecrement cspbqhidqzci--
<operator>.assignment hpsxxpitcaot[cspbqhidqzci]=xsstlubcgzhw[ibpfathacuum].z
fprintf fprintf(stderr "%s\n" hpsxxpitcaot.c_str())
<operator>.assignment htcwoxuxnuap=true
c_str hpsxxpitcaot.c_str()
<operator>.addition cspbqhidqzci+1
c_str hpsxxpitcaot.c_str()
<operator>.equals xsstlubcgzhw[ibpfathacuum].x==hpsxxpitcaot[cspbqhidqzci-1]
<operator>.equals xsstlubcgzhw[ibpfathacuum].y==hpsxxpitcaot[cspbqhidqzci]
c_str hpsxxpitcaot.c_str()
c_str hpsxxpitcaot.c_str()
<operator>.subtraction cspbqhidqzci-1
UNKNOWN d d
UNKNOWN ::string hpsxxpitcaot=cqlriiehtjvi; ::string hpsxxpitcaot=cqlriiehtjvi;
<operator>.addressOf &pisltyybxdoa
<operator>.addressOf &wfxunwhwxstt
<operator>.addressOf &pxbjsniatlci
<operator>.indirectIndexAccess cqlriiehtjvi[pxbjsniatlci]
<operator>.fieldAccess hpsxxpitcaot.c_str
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].x
<operator>.indirectIndexAccess cqlriiehtjvi[0]
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].y
<operator>.indirectIndexAccess cqlriiehtjvi[1]
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].z
<operator>.indirectIndexAccess cqlriiehtjvi[2]
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].x
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].y
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].z
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].x
<operator>.indirectIndexAccess cqlriiehtjvi[0]
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].y
<operator>.indirectIndexAccess cqlriiehtjvi[1]
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].x
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].y
FIELD_IDENTIFIER c_str c_str
<operator>.indirectIndexAccess uuaieytcldzr[dhezmabmneon]
<operator>.fieldAccess hpsxxpitcaot.length
<operator>.indirectIndexAccess hpsxxpitcaot[cspbqhidqzci]
<operator>.fieldAccess hpsxxpitcaot.length
<operator>.indirectIndexAccess hpsxxpitcaot[cspbqhidqzci]
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER z z
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER z z
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].x
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].y
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER y y
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].x
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].y
FIELD_IDENTIFIER length length
FIELD_IDENTIFIER length length
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER y y
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].x
<operator>.indirectIndexAccess cqlriiehtjvi[1]
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].y
<operator>.indirectIndexAccess cqlriiehtjvi[0]
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].z
<operator>.indirectIndexAccess cqlriiehtjvi[2]
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].x
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].y
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].z
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER y y
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].x
<operator>.indirectIndexAccess cqlriiehtjvi[1]
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].y
<operator>.indirectIndexAccess cqlriiehtjvi[0]
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].x
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].y
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER z z
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER z z
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess uuaieytcldzr[dhezmabmneon]
<operator>.indirectIndexAccess uuaieytcldzr[dhezmabmneon]
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].y
<operator>.indirectIndexAccess hpsxxpitcaot[cspbqhidqzci]
<operator>.indirectIndexAccess uuaieytcldzr[hmsfbunznltb]
<operator>.indirectIndexAccess uuaieytcldzr[hmsfbunznltb]
<operator>.fieldAccess hpsxxpitcaot.erase
<operator>.fieldAccess twsclficdnzc[hmsfbunznltb].x
<operator>.indirectIndexAccess hpsxxpitcaot[cspbqhidqzci]
<operator>.indirectIndexAccess uuaieytcldzr[hmsfbunznltb]
<operator>.indirectIndexAccess uuaieytcldzr[hmsfbunznltb]
<operator>.indirectIndexAccess uuaieytcldzr[hmsfbunznltb]
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER y y
<operator>.fieldAccess hpsxxpitcaot.c_str
FIELD_IDENTIFIER erase erase
<operator>.fieldAccess hpsxxpitcaot.c_str
<operator>.indirectIndexAccess twsclficdnzc[hmsfbunznltb]
FIELD_IDENTIFIER x x
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].x
<operator>.indirectIndexAccess hpsxxpitcaot[cspbqhidqzci-1]
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].y
<operator>.indirectIndexAccess hpsxxpitcaot[cspbqhidqzci]
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].x
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].y
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].z
<operator>.fieldAccess hpsxxpitcaot.erase
<operator>.indirectIndexAccess hpsxxpitcaot[cspbqhidqzci]
<operator>.fieldAccess xsstlubcgzhw[ibpfathacuum].z
FIELD_IDENTIFIER c_str c_str
FIELD_IDENTIFIER c_str c_str
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER y y
<operator>.fieldAccess hpsxxpitcaot.c_str
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER z z
FIELD_IDENTIFIER erase erase
<operator>.indirectIndexAccess xsstlubcgzhw[ibpfathacuum]
FIELD_IDENTIFIER z z
<operator>.fieldAccess hpsxxpitcaot.c_str
FIELD_IDENTIFIER c_str c_str
FIELD_IDENTIFIER c_str c_str
>>>PDG&260 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->32 0->33 0->34 0->37 0->39 0->41 0->42 0->44 0->45 0->46 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->60 0->61 0->62 0->66 0->67 0->68 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->97 0->99 0->100 0->101 0->102 0->103 0->105 0->106 0->108 0->114 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->14 4->15 4->16 4->16 4->17 4->18 4->20 4->22 4->24 4->25 4->27 4->33 4->38 4->39 4->45 4->49 4->59 4->115 4->116 4->117 4->118 4->119 4->120 4->121 4->137 4->139 4->141 4->167 4->168 5->1 5->4 6->3 7->1 7->4 8->1 8->18 8->62 8->82 9->1 9->20 9->22 9->50 9->54 9->57 9->68 10->1 11->1 11->28 11->34 12->1 12->1 12->11 12->28 12->34 14->1 14->1 14->1 14->32 14->37 14->41 15->24 16->1 16->5 17->1 18->1 18->1 18->1 18->8 18->18 18->19 18->28 18->29 18->30 18->31 18->32 18->32 18->47 18->62 18->82 18->122 18->123 18->124 18->125 18->126 18->127 18->128 18->129 18->130 18->143 18->144 18->145 18->146 18->147 18->148 18->149 18->150 18->151 18->152 18->153 18->154 18->155 18->156 18->169 18->170 18->171 18->172 19->1 19->18 20->1 20->1 20->20 20->21 20->22 20->34 20->35 20->36 20->37 20->37 20->48 20->68 20->131 20->132 20->133 20->134 20->135 20->136 20->157 20->158 20->159 20->160 20->161 20->162 20->163 20->164 20->165 20->166 20->182 20->183 20->184 20->185 21->1 21->20 22->1 22->1 22->1 22->9 22->20 22->22 22->23 22->23 22->40 22->50 22->72 22->138 23->1 23->22 24->24 24->41 24->41 24->42 24->43 24->44 24->49 24->50 24->54 24->57 24->73 24->74 24->75 24->76 24->77 24->78 24->79 24->82 24->87 24->139 24->140 24->167 25->1 25->1 25->1 25->25 25->26 25->46 25->59 25->60 25->60 25->141 25->142 25->168 26->1 26->25 27->1 27->18 28->11 28->29 28->30 28->31 28->34 28->35 28->36 28->63 28->64 28->65 29->1 29->1 29->32 30->1 30->1 30->32 31->1 31->1 31->32 32->1 32->14 32->19 32->37 32->47 32->47 32->61 32->66 33->1 33->20 34->11 34->28 34->29 34->30 34->35 34->36 34->69 34->70 35->1 35->1 35->37 36->1 36->1 36->37 37->1 37->14 37->21 37->48 37->48 37->67 37->71 38->1 38->14 38->107 38->112 39->1 39->22 40->1 40->1 40->1 40->81 41->1 41->1 41->1 41->14 41->32 41->37 41->46 41->74 41->81 41->88 41->94 41->96 41->98 41->101 41->111 42->1 42->1 42->1 43->1 43->1 43->1 44->1 44->24 45->1 45->25 46->1 46->1 46->41 47->1 47->61 47->62 47->63 47->64 47->65 47->66 47->173 47->174 47->175 47->176 47->177 47->178 47->179 47->180 47->181 47->192 47->193 47->194 47->195 47->196 47->197 47->198 47->199 47->200 47->201 47->202 47->203 48->1 48->67 48->68 48->69 48->70 48->71 48->186 48->187 48->188 48->189 48->190 48->191 48->204 48->205 48->206 48->207 48->208 48->209 48->210 48->211 49->24 49->59 50->1 50->1 50->1 50->9 50->20 50->50 50->51 50->51 50->54 50->81 50->212 51->1 51->50 54->1 54->1 54->1 54->9 54->20 54->50 54->55 54->57 54->84 54->88 54->96 54->214 54->215 54->224 54->225 55->1 55->54 57->1 57->1 57->1 57->9 57->20 57->50 57->57 57->58 57->58 57->85 57->94 57->98 57->219 57->220 57->229 57->230 58->1 58->57 59->1 59->25 59->49 60->1 60->26 60->80 61->66 62->1 62->18 63->1 63->1 63->66 64->1 64->1 64->66 65->1 65->1 65->66 66->1 66->14 66->19 66->32 66->37 67->71 68->1 68->20 69->1 69->1 69->71 70->1 70->1 70->71 71->1 71->14 71->21 71->37 72->40 73->1 73->50 74->43 74->43 74->44 74->88 74->93 74->114 75->1 75->1 75->1 76->24 77->1 77->54 78->24 79->1 79->57 80->1 81->1 81->1 81->74 81->86 81->100 81->213 82->1 82->1 82->1 82->8 82->18 82->82 82->83 82->83 82->95 82->101 82->110 82->114 82->231 82->232 82->243 82->244 83->1 83->82 84->1 84->1 84->1 84->54 84->55 84->88 84->89 84->90 84->91 84->92 84->107 84->108 84->109 84->217 84->218 84->226 84->227 84->228 84->241 84->242 85->1 85->1 85->1 85->93 85->94 85->222 85->223 86->1 86->1 86->1 86->81 87->1 87->82 88->1 88->1 88->1 88->89 88->90 88->97 88->99 88->108 89->1 89->1 89->1 89->102 90->1 90->1 90->1 90->14 90->32 90->37 90->41 90->94 91->44 91->93 92->1 92->1 92->1 93->1 93->94 94->1 94->1 94->1 94->14 94->32 94->37 94->41 94->58 94->88 94->97 94->99 95->1 95->1 95->1 95->101 95->102 95->103 95->104 95->105 95->106 95->112 95->113 95->235 95->236 95->237 95->238 95->239 95->240 95->247 95->248 95->249 95->250 95->251 95->252 95->253 95->254 95->255 95->256 95->257 95->258 95->259 96->1 96->41 96->46 96->84 96->84 96->97 96->98 96->216 97->1 97->84 97->84 97->88 97->99 98->1 98->41 98->46 98->85 98->85 98->99 98->221 99->1 99->85 99->85 99->88 99->97 100->86 101->1 101->83 101->102 101->104 101->105 102->1 102->1 102->89 102->103 103->1 103->44 103->88 103->93 103->114 104->1 104->1 104->41 104->46 104->96 104->98 104->111 105->1 105->1 105->1 105->14 105->32 105->37 105->41 105->88 105->94 105->101 106->1 106->1 106->1 107->88 107->109 109->1 109->38 109->90 109->107 109->112 110->1 110->95 110->95 110->101 110->111 110->233 110->234 110->245 110->246 111->1 111->41 111->46 111->95 111->95 111->96 111->98 111->101 112->101 112->113 113->1 113->38 113->105 113->107 113->112 114->44 114->88 114->93 114->101
>>>Token int main ( ) { int rrnxlqckoijc ; scanf ( " " , & rrnxlqckoijc ) ; for ( int cvuboktyyqje = 1 ; cvuboktyyqje <= rrnxlqckoijc ; cvuboktyyqje ++ ) { int pisltyybxdoa ; scanf ( " " , & pisltyybxdoa ) ; Comb xsstlubcgzhw [ 2 * pisltyybxdoa ] ; for ( int ibpfathacuum = 0 ; ibpfathacuum < pisltyybxdoa ; ibpfathacuum ++ ) { char cqlriiehtjvi [ 2 ] ; scanf ( " " , cqlriiehtjvi ) ; xsstlubcgzhw [ ibpfathacuum ] . x = cqlriiehtjvi [ 0 ] ; xsstlubcgzhw [ ibpfathacuum ] . y = cqlriiehtjvi [ 1 ] ; xsstlubcgzhw [ ibpfathacuum ] . z = cqlriiehtjvi [ 2 ] ; fprintf ( stderr , " \n " , ibpfathacuum , xsstlubcgzhw [ ibpfathacuum ] . x , xsstlubcgzhw [ ibpfathacuum ] . y , xsstlubcgzhw [ ibpfathacuum ] . z ) ; if ( xsstlubcgzhw [ ibpfathacuum ] . x != xsstlubcgzhw [ ibpfathacuum ] . y ) { ibpfathacuum ++ ; pisltyybxdoa ++ ; xsstlubcgzhw [ ibpfathacuum ] . x = cqlriiehtjvi [ 1 ] ; xsstlubcgzhw [ ibpfathacuum ] . y = cqlriiehtjvi [ 0 ] ; xsstlubcgzhw [ ibpfathacuum ] . z = cqlriiehtjvi [ 2 ] ; fprintf ( stderr , " \n " , ibpfathacuum , xsstlubcgzhw [ ibpfathacuum ] . x , xsstlubcgzhw [ ibpfathacuum ] . y , xsstlubcgzhw [ ibpfathacuum ] . z ) ; } } int wfxunwhwxstt ; scanf ( " " , & wfxunwhwxstt ) ; Opos twsclficdnzc [ 2 * wfxunwhwxstt ] ; for ( int hmsfbunznltb = 0 ; hmsfbunznltb < wfxunwhwxstt ; hmsfbunznltb ++ ) { char cqlriiehtjvi [ 3 ] ; scanf ( " " , cqlriiehtjvi ) ; twsclficdnzc [ hmsfbunznltb ] . x = cqlriiehtjvi [ 0 ] ; twsclficdnzc [ hmsfbunznltb ] . y = cqlriiehtjvi [ 1 ] ; fprintf ( stderr , " \n " , hmsfbunznltb , twsclficdnzc [ hmsfbunznltb ] . x , twsclficdnzc [ hmsfbunznltb ] . y ) ; if ( twsclficdnzc [ hmsfbunznltb ] . x != twsclficdnzc [ hmsfbunznltb ] . y ) { hmsfbunznltb ++ ; wfxunwhwxstt ++ ; twsclficdnzc [ hmsfbunznltb ] . x = cqlriiehtjvi [ 1 ] ; twsclficdnzc [ hmsfbunznltb ] . y = cqlriiehtjvi [ 0 ] ; fprintf ( stderr , " \n " , hmsfbunznltb , twsclficdnzc [ hmsfbunznltb ] . x , twsclficdnzc [ hmsfbunznltb ] . y ) ; } } int pxbjsniatlci ; scanf ( " " , & pxbjsniatlci ) ; char cqlriiehtjvi [ pxbjsniatlci + 1 ] ; scanf ( " " , cqlriiehtjvi ) ; cqlriiehtjvi [ pxbjsniatlci ] = ' \0 ' ; std : : string hpsxxpitcaot = cqlriiehtjvi ; fprintf ( stderr , " \n " , hpsxxpitcaot . c_str ( ) ) ; int uuaieytcldzr [ wfxunwhwxstt ] ; for ( int dhezmabmneon = 0 ; dhezmabmneon < wfxunwhwxstt ; dhezmabmneon ++ ) { uuaieytcldzr [ dhezmabmneon ] = -1 ; } int cspbqhidqzci = 0 ; while ( cspbqhidqzci < hpsxxpitcaot . length ( ) ) { fprintf ( stderr , " \n " , cspbqhidqzci , hpsxxpitcaot [ cspbqhidqzci ] ) ; for ( int dhezmabmneon = 0 ; dhezmabmneon < wfxunwhwxstt ; dhezmabmneon ++ ) { if ( uuaieytcldzr [ dhezmabmneon ] >= cspbqhidqzci ) uuaieytcldzr [ dhezmabmneon ] = -1 ; } bool htcwoxuxnuap = false ; bool dxuwowmhmwir = ( cspbqhidqzci > 0 ) ; while ( dxuwowmhmwir ) { dxuwowmhmwir = false ; for ( int ibpfathacuum = 0 ; ibpfathacuum < pisltyybxdoa ; ibpfathacuum ++ ) { if ( xsstlubcgzhw [ ibpfathacuum ] . x == hpsxxpitcaot [ cspbqhidqzci - 1 ] && xsstlubcgzhw [ ibpfathacuum ] . y == hpsxxpitcaot [ cspbqhidqzci ] ) { fprintf ( stderr , " " , hpsxxpitcaot . c_str ( ) , ibpfathacuum , xsstlubcgzhw [ ibpfathacuum ] . x , xsstlubcgzhw [ ibpfathacuum ] . y , xsstlubcgzhw [ ibpfathacuum ] . z , cspbqhidqzci ) ; hpsxxpitcaot . erase ( cspbqhidqzci , 1 ) ; cspbqhidqzci -- ; hpsxxpitcaot [ cspbqhidqzci ] = xsstlubcgzhw [ ibpfathacuum ] . z ; fprintf ( stderr , " \n " , hpsxxpitcaot . c_str ( ) ) ; htcwoxuxnuap = true ; } } } if ( htcwoxuxnuap ) { cspbqhidqzci = 0 ; continue ; } for ( int hmsfbunznltb = 0 ; hmsfbunznltb < wfxunwhwxstt ; hmsfbunznltb ++ ) { if ( twsclficdnzc [ hmsfbunznltb ] . y == hpsxxpitcaot [ cspbqhidqzci ] && uuaieytcldzr [ hmsfbunznltb ] >= 0 ) { fprintf ( stderr , " " , hpsxxpitcaot . c_str ( ) , hmsfbunznltb , uuaieytcldzr [ hmsfbunznltb ] , cspbqhidqzci ) ; hpsxxpitcaot . erase ( 0 , cspbqhidqzci + 1 ) ; fprintf ( stderr , " \n " , hpsxxpitcaot . c_str ( ) ) ; cspbqhidqzci = 0 ; htcwoxuxnuap = true ; break ; } } if ( htcwoxuxnuap ) { cspbqhidqzci = 0 ; continue ; } for ( int hmsfbunznltb = 0 ; hmsfbunznltb < wfxunwhwxstt ; hmsfbunznltb ++ ) { if ( twsclficdnzc [ hmsfbunznltb ] . x == hpsxxpitcaot [ cspbqhidqzci ] && uuaieytcldzr [ hmsfbunznltb ] < 0 ) { uuaieytcldzr [ hmsfbunznltb ] = cspbqhidqzci ; fprintf ( stderr , " \n " , hmsfbunznltb , uuaieytcldzr [ hmsfbunznltb ] ) ; } } cspbqhidqzci ++ ; } printf ( " " , cvuboktyyqje ) ; for ( int cspbqhidqzci = 0 ; cspbqhidqzci < hpsxxpitcaot . length ( ) ; cspbqhidqzci ++ ) { if ( cspbqhidqzci > 0 ) printf ( " " ) ; printf ( " " , hpsxxpitcaot [ cspbqhidqzci ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.lessThan sca(anhjuxedbnxc)<missing
<operator>.lessThan forr(ii,anhjuxedbnxc)<missing
sca sca(anhjuxedbnxc)
forr forr(ii,anhjuxedbnxc)
>>>PDG&6 0->2 0->3 0->4 0->5 2->1 2->1 2->3 3->1 3->1 3->1 4->2 4->5 5->1 5->1 5->3 5->3
>>>Token int main ( ) { int anhjuxedbnxc , n , ii , flag , m , i , j , k , sum ; int byemjfbsrijj , b ; char tstxvrneunew [ 15 ] , temp [ 15 ] ; sca ( anhjuxedbnxc ) < missing ' ' > int mvubksmhnszq [ 36 ] [ 36 ] ; int sseglhvhnhxq [ 36 ] [ 36 ] ; forr ( ii , anhjuxedbnxc ) < missing ' ; ' { sca ( byemjfbsrijj ) forr ( j , 26 ) < missing ' ; ' > forr ( k , 26 ) < missing ' ; ' > { mvubksmhnszq [ j ] [ k ] = -1 ; sseglhvhnhxq [ j ] [ k ] = 0 ; } forr ( j , byemjfbsrijj ) < missing ' ; ' > { scanf ( " % s " , tstxvrneunew ) ; mvubksmhnszq [ tstxvrneunew [ 0 ] - 65 ] [ tstxvrneunew [ 1 ] - 65 ] = tstxvrneunew [ 2 ] -65 ; mvubksmhnszq [ tstxvrneunew [ 1 ] - 65 ] [ tstxvrneunew [ 0 ] - 65 ] = tstxvrneunew [ 2 ] -65 ; } sca ( byemjfbsrijj ) forr ( j , byemjfbsrijj ) < missing ' ; ' > { scanf ( " % s " , tstxvrneunew ) ; sseglhvhnhxq [ tstxvrneunew [ 0 ] - 65 ] [ tstxvrneunew [ 1 ] - 65 ] = 1 ; sseglhvhnhxq [ tstxvrneunew [ 1 ] - 65 ] [ tstxvrneunew [ 0 ] - 65 ] = 1 ; } sca ( n ) scanf ( " " , tstxvrneunew ) ; temp [ 0 ] = tstxvrneunew [ 0 ] ; k = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( k == -1 ) { temp [ 0 ] = tstxvrneunew [ i ] ; k = 0 ; continue ; } if ( ( mvubksmhnszq [ tstxvrneunew [ i ] - 65 ] [ temp [ k ] - 65 ] >= 0 ) || ( mvubksmhnszq [ temp [ k ] - 65 ] [ tstxvrneunew [ i ] - 65 ] >= 0 ) ) { temp [ k ] = mvubksmhnszq [ tstxvrneunew [ i ] - 65 ] [ temp [ k ] - 65 ] + 65 ; continue ; } j = k ; flag = 0 ; for ( j = k ; j >= 0 ; j -- ) { if ( sseglhvhnhxq [ tstxvrneunew [ i ] - 65 ] [ temp [ j ] - 65 ] ) { flag = 1 ; k = -1 ; break ; } } if ( flag == 0 ) { temp [ k + 1 ] = tstxvrneunew [ i ] ; k ++ ; } } printf ( " " , ii + 1 ) ; forr ( i , k + 1 ) < missing ' ; ' { printf ( " " , temp [ i ] ) ; if ( i != k ) printf ( " " ) ; } printf ( " \n " ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&udfxydxauhjb)
RETURN return 0; return 0;
<operator>.lessEqualsThan cn<=udfxydxauhjb
<operator>.postIncrement cn++
LITERAL 0 return 0;
<operator>.assignment cn=1
scanf scanf("%d%I64d%d%d",&l,&t,&n,&c)
<operator>.assignment bsvnnexoxwud=0
<operator>.assignment hcmaevpbcxlu=p2=-1
iirfixzdrxve iirfixzdrxve(hcmaevpbcxlu==n)
<operator>.assignment hcmaevpbcxlu=-1
iirfixzdrxve iirfixzdrxve(p2==n)
<operator>.assignment p2=-1
iirfixzdrxve iirfixzdrxve(hcmaevpbcxlu>=0&&p2==-1)
<operator>.assignment l=1
iirfixzdrxve iirfixzdrxve(hcmaevpbcxlu==-1&&p2==-1)
<operator>.assignment l=0
<operator>.assignment bsvnnexoxwud=0
<operator>.assignment cum[0]=num[0]
iirfixzdrxve iirfixzdrxve(l==0)
BLOCK <empty> <empty>
<operator>.lessThan pkzgwbjhvvtb<c
<operator>.postIncrement pkzgwbjhvvtb++
<operator>.lessThan pkzgwbjhvvtb<n
<operator>.expressionList pkzgwbjhvvtb++ j++
<operator>.lessThan pkzgwbjhvvtb<n
<operator>.postIncrement pkzgwbjhvvtb++
<operator>.lessThan pkzgwbjhvvtb<n
<operator>.postIncrement pkzgwbjhvvtb++
<operator>.lessThan pkzgwbjhvvtb<n
<operator>.postIncrement pkzgwbjhvvtb++
printf printf("Case #%d: %I64d\n",cn,bsvnnexoxwud *2)
<operator>.assignment pkzgwbjhvvtb=0
scanf scanf("%I64d",&aa[pkzgwbjhvvtb])
<operator>.expressionList pkzgwbjhvvtb=0 j=0
<operator>.assignment num[pkzgwbjhvvtb]=aa[pkzgwbjhvvtb%c]
<operator>.assignment p2=-1
<operator>.assignment pkzgwbjhvvtb=0
iirfixzdrxve iirfixzdrxve(bsvnnexoxwud+num[pkzgwbjhvvtb]*2==t)
<operator>.equals hcmaevpbcxlu==n
<operator>.minus -1
<operator>.equals p2==n
<operator>.minus -1
<operator>.logicalAnd hcmaevpbcxlu>=0&&p2==-1
<operator>.logicalAnd hcmaevpbcxlu==-1&&p2==-1
<operator>.assignment pkzgwbjhvvtb=0
<operator>.assignmentPlus bsvnnexoxwud+=num[pkzgwbjhvvtb]
<operator>.assignment pkzgwbjhvvtb=1
<operator>.assignment cum[pkzgwbjhvvtb]=cum[pkzgwbjhvvtb-1]+num[pkzgwbjhvvtb]
<operator>.equals l==0
<operator>.postIncrement pkzgwbjhvvtb++
<operator>.postIncrement j++
<operator>.minus -1
<operator>.assignment hcmaevpbcxlu=pkzgwbjhvvtb+1
<operator>.assignment p2=pkzgwbjhvvtb+1
<operator>.greaterEqualsThan hcmaevpbcxlu>=0
<operator>.equals p2==-1
<operator>.equals hcmaevpbcxlu==-1
<operator>.equals p2==-1
<operator>.multiplication bsvnnexoxwud *2
<operator>.assignment pkzgwbjhvvtb=0
<operator>.assignment j=0
<operator>.equals bsvnnexoxwud+num[pkzgwbjhvvtb]*2==t
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.addition cum[pkzgwbjhvvtb-1]+num[pkzgwbjhvvtb]
<operator>.modulo pkzgwbjhvvtb%c
<operator>.addition bsvnnexoxwud+num[pkzgwbjhvvtb]*2
<operator>.addition pkzgwbjhvvtb+1
<operator>.addition pkzgwbjhvvtb+1
<operator>.multiplication num[pkzgwbjhvvtb]*2
<operator>.subtraction pkzgwbjhvvtb-1
UNKNOWN,),)
UNKNOWN,),)
UNKNOWN,),)
UNKNOWN,),)
UNKNOWN,),)
UNKNOWN else  iirfixzdrxve (l==1){min1=cum[n-1]*2;for(pkzgwbjhvvtb=hcmaevpbcxlu;pkzgwbjhvvtb<n;pkzgwbjhvvtb++){bsvnnexoxwud=0;for(j=0;j<pkzgwbjhvvtb;j++){bsvnnexoxwud+=num[j]*2;}left=t-bsvnnexoxwud;for(j=pkzgwbjhvvtb+1;j<n;j++){bsvnnexoxwud+=num[j]*2;}iirfixzdrxve(p2!=-1&&pkzgwbjhvvtb>=p2){bsvnnexoxwud+=num[pkzgwbjhvvtb];}else {bsvnnexoxwud+=left;left=num[pkzgwbjhvvtb]*2-left;bsvnnexoxwud+=left/2;}iirfixzdrxve(bsvnnexoxwud<min1){min1=bsvnnexoxwud;}}printf("Case #%d: %I64d\n",cn,min1);} else  iirfixzdrxve (l==1){min1=cum[n-1]*2;for(pkzgwbjhvvtb=hcmaevpbcxlu;pkzgwbjhvvtb<n;pkzgwbjhvvtb++){bsvnnexoxwud=0;for(j=0;j<pkzgwbjhvvtb;j++){bsvnnexoxwud+=num[j]*2;}left=t-bsvnnexoxwud;for(j=pkzgwbjhvvtb+1;j<n;j++){bsvnnexoxwud+=num[j]*2;}iirfixzdrxve(p2!=-1&&pkzgwbjhvvtb>=p2){bsvnnexoxwud+=num[pkzgwbjhvvtb];}else {bsvnnexoxwud+=left;left=num[pkzgwbjhvvtb]*2-left;bsvnnexoxwud+=left/2;}iirfixzdrxve(bsvnnexoxwud<min1){min1=bsvnnexoxwud;}}printf("Case #%d: %I64d\n",cn,min1);}
UNKNOWN else  iirfixzdrxve (l==2){min1=cum[n-1]*2;for(pkzgwbjhvvtb=hcmaevpbcxlu;pkzgwbjhvvtb<n;pkzgwbjhvvtb++){for(j=pkzgwbjhvvtb+1;j<n;j++){bsvnnexoxwud=0;for(k=0;k<pkzgwbjhvvtb;k++){bsvnnexoxwud+=num[k]*2;}left=t-bsvnnexoxwud;for(k=pkzgwbjhvvtb+1;k<n;k++){iirfixzdrxve(k==j)bsvnnexoxwud+=num[k];else  bsvnnexoxwud +=num[k]*2;}iirfixzdrxve(pkzgwbjhvvtb>=p2){bsvnnexoxwud+=num[pkzgwbjhvvtb];}else {bsvnnexoxwud+=left;left=num[pkzgwbjhvvtb]*2-left;bsvnnexoxwud+=left/2;}iirfixzdrxve(min1>bsvnnexoxwud){min1=bsvnnexoxwud;}}}printf("Case #%d: %I64d\n",cn,min1);} else  iirfixzdrxve (l==2){min1=cum[n-1]*2;for(pkzgwbjhvvtb=hcmaevpbcxlu;pkzgwbjhvvtb<n;pkzgwbjhvvtb++){for(j=pkzgwbjhvvtb+1;j<n;j++){bsvnnexoxwud=0;for(k=0;k<pkzgwbjhvvtb;k++){bsvnnexoxwud+=num[k]*2;}left=t-bsvnnexoxwud;for(k=pkzgwbjhvvtb+1;k<n;k++){iirfixzdrxve(k==j)bsvnnexoxwud+=num[k];else  bsvnnexoxwud +=num[k]*2;}iirfixzdrxve(pkzgwbjhvvtb>=p2){bsvnnexoxwud+=num[pkzgwbjhvvtb];}else {bsvnnexoxwud+=left;left=num[pkzgwbjhvvtb]*2-left;bsvnnexoxwud+=left/2;}iirfixzdrxve(min1>bsvnnexoxwud){min1=bsvnnexoxwud;}}}printf("Case #%d: %I64d\n",cn,min1);}
<operator>.addressOf &l
<operator>.addressOf &t
<operator>.addressOf &n
<operator>.addressOf &c
<operator>.indirectIndexAccess cum[0]
<operator>.indirectIndexAccess num[0]
UNKNOWN,),)
<operator>.addressOf &aa[pkzgwbjhvvtb]
<operator>.indirectIndexAccess num[pkzgwbjhvvtb]
<operator>.indirectIndexAccess aa[pkzgwbjhvvtb%c]
<operator>.indirectIndexAccess num[pkzgwbjhvvtb]
<operator>.indirectIndexAccess cum[pkzgwbjhvvtb]
<operator>.indirectIndexAccess aa[pkzgwbjhvvtb]
<operator>.indirectIndexAccess cum[pkzgwbjhvvtb-1]
<operator>.indirectIndexAccess num[pkzgwbjhvvtb]
<operator>.indirectIndexAccess num[pkzgwbjhvvtb]
>>>PDG&98 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->16 0->18 0->19 0->22 0->23 0->24 0->25 0->27 0->29 0->30 0->31 0->32 0->33 0->34 0->36 0->39 0->41 0->42 0->43 0->44 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->69 0->70 0->71 0->72 0->73 0->74 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->18 4->19 4->20 4->21 4->23 4->25 4->27 4->29 4->31 4->33 4->33 4->34 4->36 4->38 4->39 4->41 4->42 4->43 4->44 4->45 4->46 4->47 4->49 4->51 4->54 4->57 4->59 4->61 4->62 4->63 4->66 4->75 4->76 4->77 4->78 4->79 4->80 4->81 4->82 4->83 4->84 4->85 4->86 4->87 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->1 8->1 8->51 9->64 9->70 10->1 10->41 11->1 11->1 12->1 12->57 13->1 13->1 14->1 14->1 14->58 14->60 15->1 15->1 16->1 17->1 17->1 18->1 18->51 19->1 19->48 19->61 20->1 20->1 20->1 21->1 21->1 23->1 23->1 23->23 23->24 23->24 23->35 23->69 23->89 23->94 24->1 24->23 25->25 25->26 25->27 25->37 25->52 25->53 25->69 25->69 25->90 25->91 26->1 26->1 26->1 27->40 27->41 27->55 27->55 27->56 27->56 27->64 27->70 27->71 27->71 27->72 27->72 27->73 27->88 27->97 28->1 28->27 29->29 29->30 29->30 29->31 29->48 29->92 30->1 30->29 31->1 31->1 31->1 31->25 31->31 31->32 31->50 31->68 31->74 31->74 31->93 31->95 31->96 32->1 32->31 33->1 33->1 33->5 34->23 35->1 36->1 36->1 37->1 37->1 37->1 37->48 37->50 37->68 37->73 38->10 38->43 39->27 40->1 40->1 41->11 41->11 41->43 42->12 43->13 43->13 43->29 44->14 45->1 45->15 45->15 45->46 46->1 46->1 46->17 46->17 46->45 47->1 47->29 48->1 48->1 48->61 49->1 49->31 50->1 50->1 50->1 51->1 51->8 51->21 51->21 52->25 52->26 53->1 53->26 54->10 54->38 55->1 55->41 56->1 56->1 56->43 57->45 57->45 57->58 57->59 57->65 58->1 58->45 58->45 58->60 59->1 59->1 59->46 59->46 59->60 59->67 60->1 60->1 60->46 60->46 61->1 61->33 61->33 62->25 62->36 63->1 63->36 63->53 64->1 64->1 64->40 64->40 65->58 66->59 67->60 68->1 68->1 69->1 69->23 69->52 70->1 73->1 73->48 73->50 73->64 73->64 73->68 73->70 73->70 74->32
>>>Token int main ( ) { int udfxydxauhjb , cn ; int pkzgwbjhvvtb , j , k ; int hcmaevpbcxlu , p2 ; qfwaiprdgecf qfwaiprdgecfleft ; qfwaiprdgecf qfwaiprdgecfbsvnnexoxwud , min1 ; scanf ( " " , & udfxydxauhjb ) ; for ( cn = 1 ; cn <= udfxydxauhjb ; cn ++ ) { scanf ( " " , & l , & t , & n , & c ) ; for ( pkzgwbjhvvtb = 0 ; pkzgwbjhvvtb < c ; pkzgwbjhvvtb ++ ) { scanf ( " " , & aa [ pkzgwbjhvvtb ] ) ; } for ( pkzgwbjhvvtb = 0 , j = 0 ; pkzgwbjhvvtb < n ; pkzgwbjhvvtb ++ , j ++ ) { num [ pkzgwbjhvvtb ] = aa [ pkzgwbjhvvtb % c ] ; } bsvnnexoxwud = 0 ; hcmaevpbcxlu = p2 = -1 ; for ( pkzgwbjhvvtb = 0 ; pkzgwbjhvvtb < n ; pkzgwbjhvvtb ++ ) { iirfixzdrxve ( bsvnnexoxwud + num [ pkzgwbjhvvtb ] * 2 == t )  { hcmaevpbcxlu = pkzgwbjhvvtb + 1 ; p2 = pkzgwbjhvvtb + 1 ; break ; } else iirfixzdrxve ( bsvnnexoxwud + num [ pkzgwbjhvvtb ] * 2 > t ) { hcmaevpbcxlu = pkzgwbjhvvtb ; p2 = pkzgwbjhvvtb + 1 ; break ; } else  { bsvnnexoxwud += num [ pkzgwbjhvvtb ] * 2 ; } } iirfixzdrxve ( hcmaevpbcxlu == n )  hcmaevpbcxlu = -1 ; iirfixzdrxve ( p2 == n ) p2 = -1 ; iirfixzdrxve ( hcmaevpbcxlu >= 0 && p2 == -1 ) l = 1 ; iirfixzdrxve ( hcmaevpbcxlu == -1 && p2 == -1 ) l = 0 ; bsvnnexoxwud = 0 ; for ( pkzgwbjhvvtb = 0 ; pkzgwbjhvvtb < n ; pkzgwbjhvvtb ++ ) { bsvnnexoxwud += num [ pkzgwbjhvvtb ] ; } cum [ 0 ] = num [ 0 ] ; for ( pkzgwbjhvvtb = 1 ; pkzgwbjhvvtb < n ; pkzgwbjhvvtb ++ ) { cum [ pkzgwbjhvvtb ] = cum [ pkzgwbjhvvtb - 1 ] + num [ pkzgwbjhvvtb ] ; } iirfixzdrxve ( l == 0 )  { printf ( " \n " , cn , bsvnnexoxwud * 2 ) ; } else iirfixzdrxve ( l == 1 ) { min1 = cum [ n - 1 ] * 2 ; for ( pkzgwbjhvvtb = hcmaevpbcxlu ; pkzgwbjhvvtb < n ; pkzgwbjhvvtb ++ ) { bsvnnexoxwud = 0 ; for ( j = 0 ; j < pkzgwbjhvvtb ; j ++ ) { bsvnnexoxwud += num [ j ] * 2 ; } left = t - bsvnnexoxwud ; for ( j = pkzgwbjhvvtb + 1 ; j < n ; j ++ ) { bsvnnexoxwud += num [ j ] * 2 ; } iirfixzdrxve ( p2 != -1 && pkzgwbjhvvtb >= p2 )  { bsvnnexoxwud += num [ pkzgwbjhvvtb ] ; } else  { bsvnnexoxwud += left ; left = num [ pkzgwbjhvvtb ] * 2 - left ; bsvnnexoxwud += left / 2 ; } iirfixzdrxve ( bsvnnexoxwud < min1 )  { min1 = bsvnnexoxwud ; } } printf ( " \n " , cn , min1 ) ; } else iirfixzdrxve ( l == 2 ) { min1 = cum [ n - 1 ] * 2 ; for ( pkzgwbjhvvtb = hcmaevpbcxlu ; pkzgwbjhvvtb < n ; pkzgwbjhvvtb ++ ) { for ( j = pkzgwbjhvvtb + 1 ; j < n ; j ++ ) { bsvnnexoxwud = 0 ; for ( k = 0 ; k < pkzgwbjhvvtb ; k ++ ) { bsvnnexoxwud += num [ k ] * 2 ; } left = t - bsvnnexoxwud ; for ( k = pkzgwbjhvvtb + 1 ; k < n ; k ++ ) { iirfixzdrxve ( k == j )  bsvnnexoxwud += num [ k ] ; else bsvnnexoxwud + = num [ k ] * 2 ; } iirfixzdrxve ( pkzgwbjhvvtb >= p2 )  { bsvnnexoxwud += num [ pkzgwbjhvvtb ] ; } else  { bsvnnexoxwud += left ; left = num [ pkzgwbjhvvtb ] * 2 - left ; bsvnnexoxwud += left / 2 ; } iirfixzdrxve ( min1 > bsvnnexoxwud )  { min1 = bsvnnexoxwud ; } } } printf ( " \n " , cn , min1 ) ; } } return 0 ; }
>>>Func
METHOD gwlmcfvhrcyn
METHOD_RETURN bool
PARAM const wsdcvddwrkbi*alphabet
<operator>.assignment uiwukejuyjva=strlen(alphabet)
RETURN return nrpluihebghs; return nrpluihebghs;
<operator>.lessThan uiwukejuyjva<2
<operator>.lessThan jhnoaordjwxe<uiwukejuyjva
<operator>.postIncrement jhnoaordjwxe++
IDENTIFIER nrpluihebghs return nrpluihebghs;
strlen strlen(alphabet)
RETURN return ecumxoicshuq; return ecumxoicshuq;
<operator>.assignment jhnoaordjwxe=0
IDENTIFIER ecumxoicshuq return ecumxoicshuq;
strchr strchr(alphabet+jhnoaordjwxe+1,alphabet[jhnoaordjwxe])
RETURN return ecumxoicshuq; return ecumxoicshuq;
<operator>.addition alphabet+jhnoaordjwxe+1
IDENTIFIER ecumxoicshuq return ecumxoicshuq;
<operator>.addition alphabet+jhnoaordjwxe
<operator>.indirectIndexAccess alphabet[jhnoaordjwxe]
>>>PDG&19 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->9 3->1 3->1 3->5 4->1 5->1 5->1 5->6 5->6 5->10 5->11 6->4 6->7 6->13 6->13 6->15 6->15 6->17 6->17 6->18 7->6 8->4 9->1 9->3 9->13 9->15 9->17 10->1 11->6 12->10 13->6 13->7 13->14 13->15 13->17 14->1 16->14
>>>Token bool gwlmcfvhrcyn ( const wsdcvddwrkbi * alphabet ) { uint64_t uiwukejuyjva = strlen ( alphabet ) ; if ( uiwukejuyjva < 2 ) { return ecumxoicshuq ; } for ( int jhnoaordjwxe = 0 ; jhnoaordjwxe < uiwukejuyjva ; jhnoaordjwxe ++ ) { if ( strchr ( alphabet + jhnoaordjwxe + 1 , alphabet [ jhnoaordjwxe ] ) ) return ecumxoicshuq ; } return nrpluihebghs ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int jfdodwbpbpyh
PARAM char **argv
<operator>.assignment *fi=fopen(argv[1],"rt")
<operator>.assignment *fo=fopen("result","wt")
fscanf fscanf(fi,"%d",&sckbyotqqqox)
fclose fclose(fi)
fclose fclose(fo)
RETURN return 0; return 0;
<operator>.lessThan jxnypvpclxzo<sckbyotqqqox
<operator>.postIncrement jxnypvpclxzo++
LITERAL 0 return 0;
fopen fopen(argv[1],"rt")
fopen fopen("result","wt")
<operator>.assignment jxnypvpclxzo=0
memset memset(COMBINES 0 sizeof(COMBINES))
memset memset(OPPOSES 0 sizeof(OPPOSES))
fscanf fscanf(fi,"%d",&combines)
fscanf fscanf(fi,"%d",&opposes)
fscanf fscanf(fi,"%d",&input_length)
solve solve(fo,jxnypvpclxzo+1,input_length)
<operator>.lessThan oxynzwexxeti<combines
<operator>.postIncrement oxynzwexxeti++
<operator>.lessThan oxynzwexxeti<opposes
<operator>.postIncrement oxynzwexxeti++
<operator>.lessThan oxynzwexxeti<input_length
<operator>.postIncrement oxynzwexxeti++
<operator>.assignment oxynzwexxeti=0
<operator>.assignment COMBINES[uiqsbiuvstlx][comb_2]=comb_result
<operator>.assignment COMBINES[comb_2][uiqsbiuvstlx]=comb_result
<operator>.assignment oxynzwexxeti=0
<operators>.assignmentOr OPPOSES[avahxoqekevf]|=(1U<<(opp_2-'A'))
<operators>.assignmentOr OPPOSES[opp_2]|=(1U<<(avahxoqekevf-'A'))
<operator>.assignment oxynzwexxeti=0
<operator>.addition jxnypvpclxzo+1
<operator>.equals uiqsbiuvstlx==''
<operator>.equals comb_2==''
<operator>.equals comb_result==''
<operator>.equals avahxoqekevf==''
<operator>.equals opp_2==''
<operator>.equals INPUT[oxynzwexxeti]==''
<operator>.assignment uiqsbiuvstlx=fgetc(fi)
<operator>.assignment comb_2=fgetc(fi)
<operator>.assignment comb_result=fgetc(fi)
<operator>.assignment avahxoqekevf=fgetc(fi)
<operator>.assignment opp_2=fgetc(fi)
<operator>.shiftLeft 1U<<(opp_2-'A')
<operator>.shiftLeft 1U<<(avahxoqekevf-'A')
<operator>.assignment INPUT[oxynzwexxeti]=fgetc(fi)
<operator>.subtraction opp_2-'A'
<operator>.subtraction avahxoqekevf-'A'
fgetc fgetc(fi)
fgetc fgetc(fi)
fgetc fgetc(fi)
fgetc fgetc(fi)
fgetc fgetc(fi)
fgetc fgetc(fi)
<operator>.sizeOf sizeof(COMBINES)
<operator>.sizeOf sizeof(OPPOSES)
<operator>.addressOf &combines
<operator>.addressOf &opposes
<operator>.addressOf &input_length
<operator>.indirectIndexAccess COMBINES[uiqsbiuvstlx][comb_2]
<operator>.indirectIndexAccess COMBINES[comb_2][uiqsbiuvstlx]
<operator>.indirectIndexAccess OPPOSES[avahxoqekevf]
<operator>.indirectIndexAccess OPPOSES[opp_2]
<operator>.indirectIndexAccess COMBINES[uiqsbiuvstlx]
<operator>.indirectIndexAccess COMBINES[comb_2]
<operator>.indirectIndexAccess INPUT[oxynzwexxeti]
<operator>.indirectIndexAccess INPUT[oxynzwexxeti]
>>>PDG&71 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->47 0->48 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 2->1 3->1 3->13 4->1 4->1 4->6 5->1 5->1 5->8 5->21 6->1 6->1 6->7 6->10 6->18 7->1 7->1 8->1 8->1 9->1 10->1 10->1 10->1 10->10 10->11 10->11 10->16 10->17 10->18 10->19 10->20 10->21 10->21 10->22 10->24 10->26 10->28 10->31 10->34 10->35 10->35 10->58 10->59 10->60 10->61 10->62 11->1 11->10 12->9 13->1 13->4 13->4 14->5 14->5 15->1 15->10 16->1 16->1 17->1 17->1 17->32 17->33 18->1 18->1 18->19 18->22 18->52 19->1 19->1 19->20 19->24 19->55 20->1 20->1 20->7 20->18 20->21 20->26 20->57 21->1 21->1 21->1 21->8 21->20 21->26 22->1 22->1 22->18 22->22 22->23 22->23 22->29 22->30 22->36 22->37 22->38 22->42 22->43 22->44 22->52 22->53 22->54 22->63 22->64 22->67 22->68 23->1 23->22 24->1 24->1 24->19 24->24 24->25 24->25 24->32 24->33 24->39 24->40 24->45 24->46 24->47 24->48 24->50 24->51 24->55 24->56 24->65 24->66 25->1 25->24 26->1 26->1 26->21 26->26 26->27 26->27 26->41 26->49 26->57 26->69 26->70 27->1 27->26 28->22 29->1 29->1 30->1 30->1 30->1 31->24 32->1 32->1 32->17 33->1 33->1 33->17 34->1 34->26 36->1 36->1 36->36 36->42 36->52 37->1 37->1 37->37 37->43 37->53 38->1 38->29 38->30 38->38 38->44 38->54 39->1 39->39 39->45 39->51 39->55 40->1 40->40 40->46 40->50 40->56 41->1 41->1 41->41 41->49 41->57 41->69 41->70 42->1 42->36 43->1 43->37 44->1 44->1 44->38 45->1 45->39 46->1 46->1 46->40 47->1 47->32 47->32 48->1 48->33 48->33 49->1 49->1 49->41 50->1 50->47 50->47 51->1 51->48 51->48 52->42 52->53 53->43 53->54 54->19 54->44 54->52 55->45 55->56 56->20 56->46 56->55 57->7 57->18 57->49
>>>Token int main ( int jfdodwbpbpyh , char * * argv ) { int jxnypvpclxzo ; int sckbyotqqqox ; FILE * fi = fopen ( argv [ 1 ] , " " ) ; FILE * fo = fopen ( " " , " " ) ; fscanf ( fi , " " , & sckbyotqqqox ) ; for ( jxnypvpclxzo = 0 ; jxnypvpclxzo < sckbyotqqqox ; jxnypvpclxzo ++ ) { int oxynzwexxeti , combines , opposes , input_length ; memset ( COMBINES , 0 , sizeof ( COMBINES ) ) ; memset ( OPPOSES , 0 , sizeof ( OPPOSES ) ) ; fscanf ( fi , " " , & combines ) ; for ( oxynzwexxeti = 0 ; oxynzwexxeti < combines ; oxynzwexxeti ++ ) { char uiqsbiuvstlx , comb_2 , comb_result ; do { uiqsbiuvstlx = fgetc ( fi ) ; } while ( uiqsbiuvstlx == ' ' ) ; do { comb_2 = fgetc ( fi ) ; } while ( comb_2 == ' ' ) ; do { comb_result = fgetc ( fi ) ; } while ( comb_result == ' ' ) ; COMBINES [ uiqsbiuvstlx ] [ comb_2 ] = comb_result ; COMBINES [ comb_2 ] [ uiqsbiuvstlx ] = comb_result ; } fscanf ( fi , " " , & opposes ) ; for ( oxynzwexxeti = 0 ; oxynzwexxeti < opposes ; oxynzwexxeti ++ ) { char avahxoqekevf , opp_2 ; do { avahxoqekevf = fgetc ( fi ) ; } while ( avahxoqekevf == ' ' ) ; do { opp_2 = fgetc ( fi ) ; } while ( opp_2 == ' ' ) ; OPPOSES [ avahxoqekevf ] |= ( 1U << ( opp_2 - ' ' ) ) ; OPPOSES [ opp_2 ] |= ( 1U << ( avahxoqekevf - ' ' ) ) ; } fscanf ( fi , " " , & input_length ) ; for ( oxynzwexxeti = 0 ; oxynzwexxeti < input_length ; oxynzwexxeti ++ ) { do { INPUT [ oxynzwexxeti ] = fgetc ( fi ) ; } while ( INPUT [ oxynzwexxeti ] == ' ' ) ; } solve ( fo , jxnypvpclxzo + 1 , input_length ) ; } fclose ( fi ) ; fclose ( fo ) ; return 0 ; }
>>>Func
METHOD wxcbjgbrieiz
METHOD_RETURN char
PARAM char omifqnubived[29][2]
PARAM int gnkdhykvoozn
PARAM char grvzboqhiryk[101]
PARAM int gzmcfzgbmjre
PARAM char nitzigvzdgll
<operator>.assignment solbxjgilceo='0'
leasjpzryupw leasjpzryupw(omifqnubived[jmsjctwkkiwr][0]==nitzigvzdgll)
<operator>.assignment solbxjgilceo=omifqnubived[jmsjctwkkiwr][1]
leasjpzryupw leasjpzryupw(solbxjgilceo=='0')
RETURN return 0; return 0;
LITERAL 0 return 0;
<operator>.equals omifqnubived[jmsjctwkkiwr][0]==nitzigvzdgll
<operator>.equals solbxjgilceo=='0'
>>>PDG&15 0->2 0->3 0->4 0->5 0->6 0->7 0->11 0->12 0->13 0->14 2->1 3->1 4->1 5->1 6->13 7->1 8->1 8->1 9->1 9->1 9->14 10->1 10->1 11->1 12->11 13->1 13->1 13->8 13->8 14->1 14->10 14->10
>>>Token char wxcbjgbrieiz ( char omifqnubived [ 29 ] [ 2 ] , int gnkdhykvoozn , char grvzboqhiryk [ 101 ] , int gzmcfzgbmjre , char nitzigvzdgll ) { int jmsjctwkkiwr ; char solbxjgilceo = ' ' ; for ( jmsjctwkkiwr = 0 ; jmsjctwkkiwr < gnkdhykvoozn ; jmsjctwkkiwr ++ ) leasjpzryupw ( omifqnubived [ jmsjctwkkiwr ] [ 0 ] == nitzigvzdgll )  solbxjgilceo = omifqnubived [ jmsjctwkkiwr ] [ 1 ] ; else leasjpzryupw ( omifqnubived [ jmsjctwkkiwr ] [ 1 ] = = nitzigvzdgll )  solbxjgilceo = omifqnubived [ jmsjctwkkiwr ] [ 0 ] ; leasjpzryupw ( solbxjgilceo == ' ' )  return 0 ; for ( jmsjctwkkiwr = 0 ; jmsjctwkkiwr < gzmcfzgbmjre ; jmsjctwkkiwr ++ ) leasjpzryupw ( grvzboqhiryk [ jmsjctwkkiwr ] == solbxjgilceo )  return 1 ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment array['Q'-'A']=0
<operator>.assignment array['W'-'A']=1
<operator>.assignment array['E'-'A']=2
<operator>.assignment array['R'-'A']=3
<operator>.assignment array['A'-'A']=4
<operator>.assignment array['S'-'A']=5
<operator>.assignment array['D'-'A']=6
<operator>.assignment array['F'-'A']=7
scanf scanf("%d",&testCases)
<operator>.lessThan uaxurhkebgjp<26
<operator>.postIncrement uaxurhkebgjp++
<operator>.lessEqualsThan uaxurhkebgjp<=testCases
<operator>.postIncrement uaxurhkebgjp++
<operator>.assignment uaxurhkebgjp=0
<operator>.assignment array[uaxurhkebgjp]=-1
<operator>.assignment uaxurhkebgjp=1
scanf scanf("%d",&lrwadxtpgrgi)
scanf scanf("%d",&d)
scanf scanf("%d",&ytzjieclvuuy)
scanf scanf("%s",ysygtbamvqec)
<operator>.assignment pos=0
printf printf("Case #%d: [",uaxurhkebgjp)
printf printf("]\n")
<operator>.subtraction 'Q'-'A'
<operator>.subtraction 'W'-'A'
<operator>.subtraction 'E'-'A'
<operator>.subtraction 'R'-'A'
<operator>.subtraction 'A'-'A'
<operator>.subtraction 'S'-'A'
<operator>.subtraction 'D'-'A'
<operator>.subtraction 'F'-'A'
<operator>.lessThan j<lrwadxtpgrgi
<operator>.postIncrement j++
<operator>.lessThan j<d
<operator>.postIncrement j++
<operator>.lessThan j<ytzjieclvuuy
<operator>.postIncrement j++
<operator>.greaterThan pos>0
<operator>.lessThan j<pos
<operator>.postIncrement j++
<operator>.lessThan j<8
<operator>.postIncrement j++
<operator>.minus -1
<operator>.assignment j=0
scanf scanf("%s",ofgfsqewblhf)
<operator>.assignment combine[array[ofgfsqewblhf[0]-'A']][array[ofgfsqewblhf[1]-'A']]=ofgfsqewblhf[2]
<operator>.assignment combine[array[ofgfsqewblhf[1]-'A']][array[ofgfsqewblhf[0]-'A']]=ofgfsqewblhf[2]
<operator>.assignment j=0
scanf scanf("%s",ofgfsqewblhf)
<operator>.assignment destruct[array[ofgfsqewblhf[0]-'A']][array[ofgfsqewblhf[1]-'A']]=1
<operator>.assignment destruct[array[ofgfsqewblhf[1]-'A']][array[ofgfsqewblhf[0]-'A']]=1
<operator>.assignment j=0
<operator>.assignment flag=1
printf printf("%c",jecndzctbbbe[0])
<operator>.assignment j=1
printf printf(", %c",jecndzctbbbe[j])
<operator>.assignment j=0
<operator>.logicalAnd pos>0&&array[jecndzctbbbe[pos-1]-'A']!=-1
<operator>.lessThan k<pos
<operator>.postIncrement k++
IDENTIFIER flag if (flag)
<operator>.lessThan k<8
<operator>.postIncrement k++
<operator>.assignment k=0
<operator>.assignment jecndzctbbbe[pos++]=ysygtbamvqec[j]
<operator>.assignment k=0
<operator>.assignment combine[j][k]=0
<operator>.assignment destruct[j][k]=0
<operator>.greaterThan pos>0
<operator>.notEquals array[jecndzctbbbe[pos-1]-'A']!=-1
<operator>.assignment zkaltmdwygdk=combine[array[jecndzctbbbe[pos-1]-'A']][array[ysygtbamvqec[j]-'A']]
<operator>.notEquals array[jecndzctbbbe[k]-'A']!=-1
<operator>.subtraction ofgfsqewblhf[1]-'A'
<operator>.subtraction ofgfsqewblhf[0]-'A'
<operator>.subtraction ofgfsqewblhf[1]-'A'
<operator>.subtraction ofgfsqewblhf[0]-'A'
<operator>.minus -1
<operator>.assignment jecndzctbbbe[pos-1]=zkaltmdwygdk
<operator>.subtraction ofgfsqewblhf[0]-'A'
<operator>.subtraction ofgfsqewblhf[1]-'A'
<operator>.subtraction ofgfsqewblhf[0]-'A'
<operator>.subtraction ofgfsqewblhf[1]-'A'
<operator>.subtraction jecndzctbbbe[pos-1]-'A'
<operator>.minus -1
<operator>.postIncrement pos++
<operator>.subtraction jecndzctbbbe[k]-'A'
<operator>.assignment pos=0
<operator>.assignment flag=0
<operator>.subtraction pos-1
<operator>.subtraction ysygtbamvqec[j]-'A'
<operator>.subtraction pos-1
<operator>.subtraction jecndzctbbbe[pos-1]-'A'
<operator>.subtraction ysygtbamvqec[j]-'A'
<operator>.subtraction jecndzctbbbe[k]-'A'
<operator>.subtraction pos-1
<operator>.indirectIndexAccess array[uaxurhkebgjp]
<operator>.addressOf &lrwadxtpgrgi
<operator>.addressOf &d
<operator>.addressOf &ytzjieclvuuy
<operator>.indirectIndexAccess combine[array[ofgfsqewblhf[0]-'A']][array[ofgfsqewblhf[1]-'A']]
<operator>.indirectIndexAccess ofgfsqewblhf[2]
<operator>.indirectIndexAccess combine[array[ofgfsqewblhf[1]-'A']][array[ofgfsqewblhf[0]-'A']]
<operator>.indirectIndexAccess ofgfsqewblhf[2]
<operator>.indirectIndexAccess destruct[array[ofgfsqewblhf[0]-'A']][array[ofgfsqewblhf[1]-'A']]
<operator>.indirectIndexAccess destruct[array[ofgfsqewblhf[1]-'A']][array[ofgfsqewblhf[0]-'A']]
<operator>.indirectIndexAccess jecndzctbbbe[0]
<operator>.indirectIndexAccess jecndzctbbbe[j]
<operator>.indirectIndexAccess combine[array[ofgfsqewblhf[0]-'A']]
<operator>.indirectIndexAccess array[ofgfsqewblhf[1]-'A']
<operator>.indirectIndexAccess combine[array[ofgfsqewblhf[1]-'A']]
<operator>.indirectIndexAccess array[ofgfsqewblhf[0]-'A']
<operator>.indirectIndexAccess destruct[array[ofgfsqewblhf[0]-'A']]
<operator>.indirectIndexAccess array[ofgfsqewblhf[1]-'A']
<operator>.indirectIndexAccess destruct[array[ofgfsqewblhf[1]-'A']]
<operator>.indirectIndexAccess array[ofgfsqewblhf[0]-'A']
<operator>.indirectIndexAccess array[ofgfsqewblhf[0]-'A']
<operator>.indirectIndexAccess array[ofgfsqewblhf[1]-'A']
<operator>.indirectIndexAccess array[ofgfsqewblhf[0]-'A']
<operator>.indirectIndexAccess array[ofgfsqewblhf[1]-'A']
<operator>.indirectIndexAccess array[jecndzctbbbe[pos-1]-'A']
<operator>.indirectIndexAccess jecndzctbbbe[pos++]
<operator>.indirectIndexAccess ysygtbamvqec[j]
<operator>.indirectIndexAccess combine[j][k]
<operator>.indirectIndexAccess destruct[j][k]
<operator>.indirectIndexAccess ofgfsqewblhf[1]
<operator>.indirectIndexAccess ofgfsqewblhf[0]
<operator>.indirectIndexAccess ofgfsqewblhf[1]
<operator>.indirectIndexAccess ofgfsqewblhf[0]
<operator>.indirectIndexAccess combine[array[jecndzctbbbe[pos-1]-'A']][array[ysygtbamvqec[j]-'A']]
<operator>.indirectIndexAccess array[jecndzctbbbe[k]-'A']
<operator>.indirectIndexAccess combine[j]
<operator>.indirectIndexAccess destruct[j]
<operator>.indirectIndexAccess ofgfsqewblhf[0]
<operator>.indirectIndexAccess ofgfsqewblhf[1]
<operator>.indirectIndexAccess ofgfsqewblhf[0]
<operator>.indirectIndexAccess ofgfsqewblhf[1]
<operator>.indirectIndexAccess jecndzctbbbe[pos-1]
<operator>.indirectIndexAccess combine[array[jecndzctbbbe[pos-1]-'A']]
<operator>.indirectIndexAccess array[ysygtbamvqec[j]-'A']
<operator>.indirectIndexAccess jecndzctbbbe[pos-1]
<operator>.indirectIndexAccess destruct[array[jecndzctbbbe[k]-'A']][array[ysygtbamvqec[j]-'A']]
<operator>.indirectIndexAccess array[jecndzctbbbe[pos-1]-'A']
<operator>.indirectIndexAccess jecndzctbbbe[k]
<operator>.indirectIndexAccess destruct[array[jecndzctbbbe[k]-'A']]
<operator>.indirectIndexAccess array[ysygtbamvqec[j]-'A']
<operator>.indirectIndexAccess ysygtbamvqec[j]
<operator>.indirectIndexAccess array[jecndzctbbbe[k]-'A']
<operator>.indirectIndexAccess jecndzctbbbe[pos-1]
<operator>.indirectIndexAccess ysygtbamvqec[j]
<operator>.indirectIndexAccess jecndzctbbbe[k]
>>>PDG&152 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->60 0->61 0->62 0->63 0->64 0->65 0->67 0->68 0->69 0->70 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 2->1 2->1 3->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 9->1 9->1 10->1 10->13 11->1 11->11 11->12 11->12 11->16 11->44 11->97 12->1 12->11 13->1 13->1 13->1 13->13 13->14 13->18 13->19 13->20 13->21 13->22 13->23 13->23 13->24 13->33 13->35 13->37 13->39 13->40 13->42 13->45 13->49 13->53 13->56 13->58 13->98 13->99 13->100 14->1 14->13 15->1 15->11 16->1 16->1 16->1 17->1 17->13 18->1 18->33 19->1 19->35 20->1 20->37 21->1 21->66 21->91 21->94 22->1 22->39 22->70 23->1 23->14 24->1 33->1 33->1 33->18 33->33 33->34 33->34 33->46 33->47 33->48 33->74 33->75 33->80 33->81 33->101 33->102 33->103 33->104 33->109 33->110 33->111 33->112 33->117 33->118 33->126 33->127 33->134 33->135 34->1 34->33 35->1 35->1 35->19 35->35 35->36 35->36 35->50 35->51 35->52 35->76 35->77 35->82 35->83 35->105 35->106 35->113 35->114 35->115 35->116 35->119 35->120 35->128 35->129 35->136 35->137 36->1 36->35 37->1 37->1 37->20 37->37 37->38 37->38 37->59 37->70 38->1 38->37 39->1 39->40 39->55 39->107 40->1 40->1 40->40 40->41 40->41 40->57 40->108 41->1 41->40 42->1 42->1 42->42 42->43 42->43 42->63 42->67 43->1 43->42 44->16 45->33 46->1 46->47 46->48 46->50 46->74 46->75 46->80 46->81 47->1 47->1 48->1 48->1 48->1 49->35 50->1 50->46 50->76 50->77 50->82 50->83 51->1 51->1 52->1 52->1 53->37 54->1 54->1 55->1 55->1 56->1 56->40 57->1 57->1 58->1 58->42 59->1 59->1 59->54 59->60 59->65 59->66 59->72 59->86 59->91 59->93 59->96 59->122 59->123 59->130 59->139 59->140 59->143 59->147 59->149 60->1 60->1 60->39 60->61 60->70 60->73 60->85 60->86 60->87 60->131 60->144 61->1 61->60 63->1 63->1 63->63 63->64 63->64 63->68 63->69 63->124 63->125 63->132 63->133 64->1 64->63 65->1 65->60 66->1 66->1 66->1 67->1 67->63 68->1 68->1 69->1 69->1 70->59 70->59 70->60 70->71 70->78 70->84 70->90 70->90 70->96 70->121 70->138 71->1 71->1 71->59 71->59 72->1 72->1 72->1 72->54 72->60 72->65 72->66 72->79 72->79 72->86 72->92 72->122 72->123 72->141 73->1 73->1 73->1 73->60 73->61 73->94 73->95 73->142 73->145 73->146 73->148 73->150 73->151 74->81 75->1 75->46 75->50 75->80 75->82 76->83 77->1 77->46 77->50 77->80 77->82 78->71 79->1 79->1 79->1 79->84 79->93 80->75 81->1 81->46 81->50 81->74 81->76 82->77 83->1 83->46 83->50 83->74 83->76 84->1 84->93 85->73 86->39 86->70 87->1 87->95 88->1 88->39 88->70 88->86 89->1 89->1 90->60 90->96 91->1 91->21 91->66 91->94 92->39 92->70 93->1 93->84 94->1 94->21 94->66 94->91 95->1 95->87 96->60 96->92 142->60 142->61 142->88 142->89
>>>Token int main ( ) { int uaxurhkebgjp , j , k , testCases ; int lrwadxtpgrgi , d ; char ofgfsqewblhf [ 10 ] ; char ysygtbamvqec [ 200 ] ; char jecndzctbbbe [ 200 ] ; int ytzjieclvuuy , pos , flag ; char zkaltmdwygdk ; for ( uaxurhkebgjp = 0 ; uaxurhkebgjp < 26 ; uaxurhkebgjp ++ ) { array [ uaxurhkebgjp ] = -1 ; } array [ ' ' - ' ' ] = 0 ; array [ ' ' - ' ' ] = 1 ; array [ ' ' - ' ' ] = 2 ; array [ ' ' - ' ' ] = 3 ; array [ ' ' - ' ' ] = 4 ; array [ ' ' - ' ' ] = 5 ; array [ ' ' - ' ' ] = 6 ; array [ ' ' - ' ' ] = 7 ; scanf ( " " , & testCases ) ; for ( uaxurhkebgjp = 1 ; uaxurhkebgjp <= testCases ; uaxurhkebgjp ++ ) { scanf ( " " , & lrwadxtpgrgi ) ; for ( j = 0 ; j < lrwadxtpgrgi ; j ++ ) { scanf ( " " , ofgfsqewblhf ) ; combine [ array [ ofgfsqewblhf [ 0 ] - ' ' ] ] [ array [ ofgfsqewblhf [ 1 ] - ' ' ] ] = ofgfsqewblhf [ 2 ] ; combine [ array [ ofgfsqewblhf [ 1 ] - ' ' ] ] [ array [ ofgfsqewblhf [ 0 ] - ' ' ] ] = ofgfsqewblhf [ 2 ] ; } scanf ( " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) { scanf ( " " , ofgfsqewblhf ) ; destruct [ array [ ofgfsqewblhf [ 0 ] - ' ' ] ] [ array [ ofgfsqewblhf [ 1 ] - ' ' ] ] = 1 ; destruct [ array [ ofgfsqewblhf [ 1 ] - ' ' ] ] [ array [ ofgfsqewblhf [ 0 ] - ' ' ] ] = 1 ; } scanf ( " " , & ytzjieclvuuy ) ; scanf ( " " , ysygtbamvqec ) ; pos = 0 ; for ( j = 0 ; j < ytzjieclvuuy ; j ++ ) { if ( pos > 0 && array [ jecndzctbbbe [ pos - 1 ] - ' ' ] != -1 ) { if ( zkaltmdwygdk = combine [ array [ jecndzctbbbe [ pos - 1 ] - ' ' ] ] [ array [ ysygtbamvqec [ j ] - ' ' ] ] ) { jecndzctbbbe [ pos - 1 ] = zkaltmdwygdk ; continue ; } } flag = 1 ; for ( k = 0 ; k < pos ; k ++ ) { if ( array [ jecndzctbbbe [ k ] - ' ' ] != -1 ) { if ( destruct [ array [ jecndzctbbbe [ k ] - ' ' ] ] [ array [ ysygtbamvqec [ j ] - ' ' ] ] ) { pos = 0 ; flag = 0 ; break ; } } } if ( flag ) { jecndzctbbbe [ pos ++ ] = ysygtbamvqec [ j ] ; } } printf ( " " , uaxurhkebgjp ) ; if ( pos > 0 ) { printf ( " " , jecndzctbbbe [ 0 ] ) ; } for ( j = 1 ; j < pos ; j ++ ) { printf ( " " , jecndzctbbbe [ j ] ) ; } printf ( " \n " ) ; for ( j = 0 ; j < 8 ; j ++ ) { for ( k = 0 ; k < 8 ; k ++ ) { combine [ j ] [ k ] = 0 ; destruct [ j ] [ k ] = 0 ; } } } }
>>>Func
METHOD avl_tree_lookup_node
METHOD_RETURN AVLTreeNode
PARAM AVLTree *tree
PARAM AVLTreeKey wwbfbsvpvupu
<operator>.assignment kadmvzvspvkj=tree->root_node
RETURN return rhtswneamkrh; return rhtswneamkrh;
<operator>.notEquals kadmvzvspvkj!=rhtswneamkrh
IDENTIFIER rhtswneamkrh return rhtswneamkrh;
<operator>.assignment tcsvkxzbhrwe=tree->compare_func(wwbfbsvpvupu,kadmvzvspvkj->wwbfbsvpvupu)
hmynxcdankne hmynxcdankne(tcsvkxzbhrwe==0)
RETURN return kadmvzvspvkj; return kadmvzvspvkj;
compare_func tree->compare_func(wwbfbsvpvupu,kadmvzvspvkj->wwbfbsvpvupu)
<operator>.equals tcsvkxzbhrwe==0
IDENTIFIER kadmvzvspvkj return kadmvzvspvkj;
UNKNOWN,),)
<operator>.indirectFieldAccess tree->compare_func
<operator>.indirectFieldAccess kadmvzvspvkj->wwbfbsvpvupu
FIELD_IDENTIFIER compare_func compare_func
FIELD_IDENTIFIER wwbfbsvpvupu wwbfbsvpvupu
>>>PDG&19 0->2 0->3 0->5 0->6 0->7 0->11 0->12 0->13 2->1 3->11 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->5 6->8 6->9 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 7->5 8->1 8->1 8->12 9->1 9->1 10->1 11->1 11->1 11->1 11->8 11->8 11->8 12->1 12->9 12->9 13->10
>>>Token AVLTreeNode * avl_tree_lookup_node ( AVLTree * tree , AVLTreeKey wwbfbsvpvupu ) { AVLTreeNode * kadmvzvspvkj ; int tcsvkxzbhrwe ; kadmvzvspvkj = tree -> root_node ; while ( kadmvzvspvkj != rhtswneamkrh ) { tcsvkxzbhrwe = tree -> compare_func ( wwbfbsvpvupu , kadmvzvspvkj -> wwbfbsvpvupu ) ; hmynxcdankne ( tcsvkxzbhrwe == 0 )  { return kadmvzvspvkj ; } else hmynxcdankne ( tcsvkxzbhrwe < 0 ) { kadmvzvspvkj = kadmvzvspvkj -> children [ AVL_TREE_NODE_LEFT ] ; } else  { kadmvzvspvkj = kadmvzvspvkj -> children [ AVL_TREE_NODE_RIGHT ] ; } } return rhtswneamkrh ; }
>>>Func
METHOD ymtrtmocajtp
METHOD_RETURN int
PARAM char nrznieabtbac [ ]
PARAM int koucznepukas
PARAM char jznitejqznrf[NUM_CHARACTERS][NUM_CHARACTERS]
PARAM bool bklosidnpovl[NUM_CHARACTERS][NUM_CHARACTERS]
<operator>.assignment lhksyjkxcntb='\0'
<operator>.assignment miymshgipgwz=0
RETURN return 0; return 0;
<operator>.equals koucznepukas==0
<operator>.notEquals (lhksyjkxcntb=jznitejqznrf[(unsigned)nrznieabtbac[koucznepukas]][(unsigned)nrznieabtbac[koucznepukas-1]])!='\0'
LITERAL 0 return 0;
RETURN return 0; return 0;
<operator>.assignment nrznieabtbac[koucznepukas-1]=lhksyjkxcntb
<operator>.assignment nrznieabtbac[koucznepukas]='\0'
RETURN return 1+ymtrtmocajtp(nrznieabtbac,koucznepukas-1,jznitejqznrf,bklosidnpovl); return 1+ymtrtmocajtp(nrznieabtbac,koucznepukas-1,jznitejqznrf,bklosidnpovl);
LITERAL 0 return 0;
<operator>.assignment lhksyjkxcntb=jznitejqznrf[(unsigned)nrznieabtbac[koucznepukas]][(unsigned)nrznieabtbac[koucznepukas-1]]
<operator>.addition 1+ymtrtmocajtp(nrznieabtbac,koucznepukas-1,jznitejqznrf,bklosidnpovl)
<operator>.lessThan miymshgipgwz<koucznepukas
<operator>.postIncrement miymshgipgwz++
<operator>.cast (unsigned)nrznieabtbac[koucznepukas-1]
<operator>.subtraction koucznepukas-1
ymtrtmocajtp ymtrtmocajtp(nrznieabtbac,koucznepukas-1,jznitejqznrf,bklosidnpovl)
<operator>.assignment miymshgipgwz=0
<operator>.cast (unsigned)nrznieabtbac[koucznepukas]
<operator>.subtraction koucznepukas-1
<operator>.subtraction koucznepukas-1
RETURN return koucznepukas+1; return koucznepukas+1;
<operator>.cast (unsigned)nrznieabtbac[miymshgipgwz]
<operator>.lessEqualsThan miymshgipgwz<=koucznepukas
<operator>.postIncrement miymshgipgwz++
<operator>.addition koucznepukas+1
<operator>.cast (unsigned)nrznieabtbac[koucznepukas]
<operator>.assignment miymshgipgwz=0
<operator>.assignment nrznieabtbac[miymshgipgwz]='\0'
<operator>.indirectIndexAccess jznitejqznrf[(unsigned)nrznieabtbac[koucznepukas]][(unsigned)nrznieabtbac[koucznepukas-1]]
<operator>.indirectIndexAccess nrznieabtbac[koucznepukas-1]
<operator>.indirectIndexAccess nrznieabtbac[koucznepukas]
<operator>.indirectIndexAccess jznitejqznrf[(unsigned)nrznieabtbac[koucznepukas]]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess nrznieabtbac[koucznepukas-1]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess nrznieabtbac[koucznepukas]
<operator>.indirectIndexAccess bklosidnpovl[(unsigned)nrznieabtbac[koucznepukas]][(unsigned)nrznieabtbac[miymshgipgwz]]
<operator>.indirectIndexAccess bklosidnpovl[(unsigned)nrznieabtbac[koucznepukas]]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess nrznieabtbac[miymshgipgwz]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess nrznieabtbac[koucznepukas]
<operator>.indirectIndexAccess nrznieabtbac[miymshgipgwz]
>>>PDG&51 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->18 0->19 0->20 0->22 0->23 0->24 0->26 0->27 0->30 0->31 0->32 0->34 0->35 2->1 2->21 2->23 2->25 2->29 2->33 3->9 4->1 4->23 5->1 5->23 8->1 9->1 9->1 9->6 9->7 9->10 9->12 9->17 9->21 9->25 9->27 9->27 9->36 9->39 9->40 9->41 9->42 9->43 10->13 10->14 10->15 10->18 10->19 10->22 10->23 10->24 10->26 10->37 10->38 11->8 12->1 13->23 14->23 15->1 16->12 17->10 17->13 18->15 19->8 19->20 19->29 19->30 19->33 19->44 19->45 19->46 19->47 19->48 19->49 20->19 22->26 23->18 23->18 23->18 23->18 24->19 26->23 26->23 27->19 27->22 28->1 30->30 30->31 30->31 30->32 30->35 30->50 31->30 32->28 34->30 44->19 44->20 44->28 44->30 44->32 44->34
>>>Token int ymtrtmocajtp ( char nrznieabtbac [ ] , int koucznepukas , char jznitejqznrf [ NUM_CHARACTERS ] [ NUM_CHARACTERS ] , bool bklosidnpovl [ NUM_CHARACTERS ] [ NUM_CHARACTERS ] ) { if ( koucznepukas == 0 ) { return 0 ; } char lhksyjkxcntb = ' \0 ' ; int miymshgipgwz = 0 ; if ( ( lhksyjkxcntb = jznitejqznrf [ ( unsigned ) nrznieabtbac [ koucznepukas ] ] [ ( unsigned ) nrznieabtbac [ koucznepukas - 1 ] ] ) != ' \0 ' ) { nrznieabtbac [ koucznepukas - 1 ] = lhksyjkxcntb ; nrznieabtbac [ koucznepukas ] = ' \0 ' ; return 1 + ymtrtmocajtp ( nrznieabtbac , koucznepukas - 1 , jznitejqznrf , bklosidnpovl ) ; } else { for ( miymshgipgwz = 0 ; miymshgipgwz < koucznepukas ; miymshgipgwz ++ ) { if ( bklosidnpovl [ ( unsigned ) nrznieabtbac [ koucznepukas ] ] [ ( unsigned ) nrznieabtbac [ miymshgipgwz ] ] ) { for ( miymshgipgwz = 0 ; miymshgipgwz <= koucznepukas ; miymshgipgwz ++ ) { nrznieabtbac [ miymshgipgwz ] = ' \0 ' ; } return koucznepukas + 1 ; } } } return 0 ; }
>>>Func
METHOD etmokcbkknjc
METHOD_RETURN void
PARAM char mamdlmlnijao
PARAM char vtoxjpvimcjf
<operator>.assignmentMinus mamdlmlnijao-='A'
<operator>.assignmentMinus vtoxjpvimcjf-='A'
<operator>.assignment opp[mamdlmlnijao][vtoxjpvimcjf]=1
<operator>.assignment opp[vtoxjpvimcjf][mamdlmlnijao]=1
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->4 3->5 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1
>>>Token void etmokcbkknjc ( char mamdlmlnijao , char vtoxjpvimcjf ) { mamdlmlnijao -= ' ' ; vtoxjpvimcjf -= ' ' ; opp [ mamdlmlnijao ] [ vtoxjpvimcjf ] = 1 ; opp [ vtoxjpvimcjf ] [ mamdlmlnijao ] = 1 ; }
>>>Func
METHOD ngcprwfrvbnh
METHOD_RETURN void
PARAM struct qtjsmeuuikqv*graph
<operator>.assignment bohequwzumuv=graph->bohequwzumuv
<operator>.assignment zttzhcwlpcrr=0
<operator>.assignment odvxdijuudle=0
qsort qsort(graph->edge graph->E sizeof(graph->edge[0]),myComp)
<operator>.assignment *subsets=(struct dfgewoyfmjnc*)malloc(bohequwzumuv *sizeof(struct dfgewoyfmjnc))
printf printf("Following are the edges in the constructed MST\n")
RETURN return ; return ;
<operator>.lessThan rsfhxxsjcdic<bohequwzumuv
<operator>.preIncrement ++rsfhxxsjcdic
<operator>.logicalAnd zttzhcwlpcrr<bohequwzumuv-1&&odvxdijuudle<graph->E
<operator>.lessThan odvxdijuudle<zttzhcwlpcrr
<operator>.preIncrement ++odvxdijuudle
printf printf("%d -- %d == %d\n",result[odvxdijuudle].src,result[odvxdijuudle].dest,result[odvxdijuudle].weight)
<operator>.sizeOf sizeof(graph->edge[0])
<operator>.cast (struct dfgewoyfmjnc*)malloc(bohequwzumuv *sizeof(struct dfgewoyfmjnc))
<operator>.assignment rsfhxxsjcdic=0
<operator>.assignment subsets[rsfhxxsjcdic].parent=rsfhxxsjcdic
<operator>.assignment subsets[rsfhxxsjcdic].rank=0
<operator>.assignment kqjlgjlweqlw=find(subsets,next_edge.src)
<operator>.assignment yfshqgetmrxb=find(subsets,next_edge.dest)
<operator>.assignment odvxdijuudle=0
malloc malloc(bohequwzumuv *sizeof(struct dfgewoyfmjnc))
<operator>.lessThan zttzhcwlpcrr<bohequwzumuv-1
<operator>.lessThan odvxdijuudle<graph->E
<operator>.notEquals kqjlgjlweqlw!=yfshqgetmrxb
<operator>.multiplication bohequwzumuv *sizeof(struct dfgewoyfmjnc)
<operator>.subtraction bohequwzumuv-1
find find(subsets,next_edge.src)
find find(subsets,next_edge.dest)
<operator>.assignment result[zttzhcwlpcrr++]=next_edge
Union Union(subsets,kqjlgjlweqlw,yfshqgetmrxb)
<operator>.sizeOf sizeof(struct dfgewoyfmjnc)
<operator>.postIncrement zttzhcwlpcrr++
UNKNOWN e e
UNKNOWN =graph->edge[odvxdijuudle++]; =graph->edge[odvxdijuudle++];
<operator>.fieldAccess result[odvxdijuudle].src
<operator>.fieldAccess result[odvxdijuudle].dest
<operator>.fieldAccess result[odvxdijuudle].weight
<operator>.fieldAccess subsets[rsfhxxsjcdic].parent
<operator>.fieldAccess subsets[rsfhxxsjcdic].rank
<operator>.indirectFieldAccess graph->E
<operator>.indirectIndexAccess result[odvxdijuudle]
FIELD_IDENTIFIER src src
<operator>.indirectIndexAccess result[odvxdijuudle]
FIELD_IDENTIFIER dest dest
<operator>.indirectIndexAccess result[odvxdijuudle]
FIELD_IDENTIFIER weight weight
<operator>.indirectIndexAccess subsets[rsfhxxsjcdic]
FIELD_IDENTIFIER parent parent
<operator>.indirectIndexAccess subsets[rsfhxxsjcdic]
FIELD_IDENTIFIER rank rank
FIELD_IDENTIFIER E E
<operator>.fieldAccess next_edge.src
<operator>.fieldAccess next_edge.dest
FIELD_IDENTIFIER src src
FIELD_IDENTIFIER dest dest
<operator>.indirectIndexAccess result[zttzhcwlpcrr++]
>>>PDG&60 0->2 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->13 0->14 0->15 0->18 0->19 0->20 0->23 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 2->1 3->1 3->1 3->28 4->1 4->25 5->26 6->1 6->1 6->1 6->1 6->26 7->1 7->1 7->1 7->30 8->1 9->1 10->1 10->1 10->10 10->11 10->11 10->19 10->19 10->20 10->29 10->41 10->42 10->50 10->51 10->52 10->53 11->1 11->10 12->1 12->1 12->1 12->12 12->21 12->22 12->25 12->27 12->29 12->30 12->31 12->36 12->37 12->55 12->56 12->57 12->58 13->1 13->1 13->1 13->13 13->14 13->14 13->15 13->38 13->39 13->40 13->44 13->45 13->46 13->47 13->48 13->49 14->1 14->13 15->1 16->1 17->1 18->1 18->10 19->1 20->1 21->1 21->1 21->27 22->1 22->1 22->27 23->1 23->13 24->1 24->7 24->17 25->1 25->12 25->12 25->13 25->26 25->35 25->43 25->54 26->1 26->12 26->12 27->1 27->1 27->1 27->32 27->33 27->33 27->33 27->35 27->59 28->10 28->24 29->1 29->25 29->25 30->1 30->21 30->21 30->31 30->31 30->32 31->1 31->1 31->22 31->22 31->30 31->30 31->32 31->33 32->1 32->1 32->1 33->1 33->1 33->1 33->1 33->30 34->1 35->25
>>>Token void ngcprwfrvbnh ( struct qtjsmeuuikqv * graph ) { int bohequwzumuv = graph -> bohequwzumuv ; struct zzngvvebvvgbresult  [ bohequwzumuv ] ; int zttzhcwlpcrr = 0 ; int odvxdijuudle = 0 ; qsort ( graph -> edge , graph -> E , sizeof ( graph -> edge [ 0 ] ) , myComp ) ; struct dfgewoyfmjnc * subsets = ( struct dfgewoyfmjnc * ) malloc ( bohequwzumuv * sizeof ( struct dfgewoyfmjnc ) ) ; for ( int rsfhxxsjcdic = 0 ; rsfhxxsjcdic < bohequwzumuv ; ++ rsfhxxsjcdic ) { subsets [ rsfhxxsjcdic ] . parent = rsfhxxsjcdic ; subsets [ rsfhxxsjcdic ] . rank = 0 ; } while ( zttzhcwlpcrr < bohequwzumuv - 1 && odvxdijuudle < graph -> E ) { struct zzngvvebvvgbnext_edge  = graph -> edge [ odvxdijuudle ++ ] ; int kqjlgjlweqlw = find ( subsets , next_edge . src ) ; int yfshqgetmrxb = find ( subsets , next_edge . dest ) ; if ( kqjlgjlweqlw != yfshqgetmrxb ) { result [ zttzhcwlpcrr ++ ] = next_edge ; Union ( subsets , kqjlgjlweqlw , yfshqgetmrxb ) ; } } printf ( " \n " ) ; for ( odvxdijuudle = 0 ; odvxdijuudle < zttzhcwlpcrr ; ++ odvxdijuudle ) printf ( " \n " , result [ odvxdijuudle ] . src , result [ odvxdijuudle ] . dest , result [ odvxdijuudle ] . weight ) ; return ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&wyihmunsmtsf)
RETURN return 0; return 0;
<operator>.lessEqualsThan ti<=wyihmunsmtsf
<operator>.postIncrement ti++
LITERAL 0 return 0;
<operator>.assignment ti=1
printf printf("Case #%d:\n",ti)
scanf scanf("%d",&n)
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
printf printf("%.12f\n",0.25 *zhxipwwbbwis[i]+0.5 *owp[i]+0.25 *oowp[i])
<operator>.assignment i=0
<operator>.assignment zhxipwwbbwis[i]=0
<operator>.assignment owp[i]=0
<operator>.assignment oowp[i]=0
<operator>.assignment i=0
scanf scanf("%c",&smwyjpiolrqy)
<operator>.assignment i=0
<operator>.assignment ktrxvrsobvqm[i]=0
<operator>.assignment k2[i]=0
<operator>.assignment zhxipwwbbwis[i]=1.0 *ktrxvrsobvqm[i]/(ktrxvrsobvqm[i]+k2[i])
<operator>.assignment i=0
<operator>.assignmentDivision owp[i]/=ktrxvrsobvqm[i]+k2[i]
<operator>.assignment i=0
<operator>.assignmentDivision oowp[i]/=ktrxvrsobvqm[i]+k2[i]
<operator>.assignment i=0
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.addition 0.25 *zhxipwwbbwis[i]+0.5 *owp[i]+0.25 *oowp[i]
<operator>.assignment j=0
scanf scanf("%c",&smwyjpiolrqy)
<operator>.assignment j=0
<operator>.division 1.0 *ktrxvrsobvqm[i]/(ktrxvrsobvqm[i]+k2[i])
<operator>.assignment j=0
<operator>.notEquals oglfakpukbhg[i][j]!=-1
<operator>.addition ktrxvrsobvqm[i]+k2[i]
<operator>.assignment j=0
<operator>.notEquals oglfakpukbhg[i][j]!=-1
<operator>.addition ktrxvrsobvqm[i]+k2[i]
<operator>.addition 0.25 *zhxipwwbbwis[i]+0.5 *owp[i]
<operator>.multiplication 0.25 *oowp[i]
<operator>.equals smwyjpiolrqy=='1'
<operator>.equals smwyjpiolrqy=='0'
<operator>.equals smwyjpiolrqy=='.'
<operator>.equals oglfakpukbhg[i][j]==1
<operator>.equals oglfakpukbhg[i][j]==0
<operator>.multiplication 1.0 *ktrxvrsobvqm[i]
<operator>.addition ktrxvrsobvqm[i]+k2[i]
<operator>.assignmentPlus owp[i]+=(zhxipwwbbwis[j]*(ktrxvrsobvqm[j]+k2[j])-oglfakpukbhg[j][i])/(ktrxvrsobvqm[j]+k2[j]-1)
<operator>.assignmentPlus oowp[i]+=owp[j]
<operator>.multiplication 0.25 *zhxipwwbbwis[i]
<operator>.multiplication 0.5 *owp[i]
<operator>.assignment oglfakpukbhg[i][j]=1
<operator>.assignment oglfakpukbhg[i][j]=0
<operator>.assignment oglfakpukbhg[i][j]=-1
<operator>.postIncrement ktrxvrsobvqm[i]++
<operator>.postIncrement k2[i]++
<operator>.minus -1
<operator>.minus -1
<operator>.division (zhxipwwbbwis[j]*(ktrxvrsobvqm[j]+k2[j])-oglfakpukbhg[j][i])/(ktrxvrsobvqm[j]+k2[j]-1)
<operator>.minus -1
<operator>.subtraction zhxipwwbbwis[j]*(ktrxvrsobvqm[j]+k2[j])-oglfakpukbhg[j][i]
<operator>.subtraction ktrxvrsobvqm[j]+k2[j]-1
<operator>.multiplication zhxipwwbbwis[j]*(ktrxvrsobvqm[j]+k2[j])
<operator>.addition ktrxvrsobvqm[j]+k2[j]
<operator>.addressOf &n
<operator>.indirectIndexAccess zhxipwwbbwis[i]
<operator>.indirectIndexAccess owp[i]
<operator>.indirectIndexAccess oowp[i]
<operator>.addressOf &smwyjpiolrqy
<operator>.indirectIndexAccess ktrxvrsobvqm[i]
<operator>.indirectIndexAccess k2[i]
<operator>.indirectIndexAccess zhxipwwbbwis[i]
<operator>.indirectIndexAccess owp[i]
<operator>.indirectIndexAccess oowp[i]
<operator>.indirectIndexAccess ktrxvrsobvqm[i]
<operator>.indirectIndexAccess k2[i]
<operator>.indirectIndexAccess ktrxvrsobvqm[i]
<operator>.indirectIndexAccess k2[i]
<operator>.indirectIndexAccess oowp[i]
<operator>.addressOf &smwyjpiolrqy
<operator>.indirectIndexAccess ktrxvrsobvqm[i]
<operator>.indirectIndexAccess ktrxvrsobvqm[i]
<operator>.indirectIndexAccess k2[i]
<operator>.indirectIndexAccess oglfakpukbhg[i][j]
<operator>.indirectIndexAccess oglfakpukbhg[i][j]
<operator>.indirectIndexAccess zhxipwwbbwis[i]
<operator>.indirectIndexAccess owp[i]
<operator>.indirectIndexAccess oglfakpukbhg[i][j]
<operator>.indirectIndexAccess oglfakpukbhg[i][j]
<operator>.indirectIndexAccess oglfakpukbhg[i]
<operator>.indirectIndexAccess owp[i]
<operator>.indirectIndexAccess oglfakpukbhg[i]
<operator>.indirectIndexAccess oowp[i]
<operator>.indirectIndexAccess owp[j]
<operator>.indirectIndexAccess oglfakpukbhg[i][j]
<operator>.indirectIndexAccess oglfakpukbhg[i][j]
<operator>.indirectIndexAccess oglfakpukbhg[i][j]
<operator>.indirectIndexAccess oglfakpukbhg[i]
<operator>.indirectIndexAccess ktrxvrsobvqm[i]
<operator>.indirectIndexAccess oglfakpukbhg[i]
<operator>.indirectIndexAccess k2[i]
<operator>.indirectIndexAccess oglfakpukbhg[i]
<operator>.indirectIndexAccess oglfakpukbhg[i]
<operator>.indirectIndexAccess oglfakpukbhg[i]
<operator>.indirectIndexAccess oglfakpukbhg[j][i]
<operator>.indirectIndexAccess zhxipwwbbwis[j]
<operator>.addition ktrxvrsobvqm[j]+k2[j]
<operator>.indirectIndexAccess oglfakpukbhg[j]
<operator>.indirectIndexAccess ktrxvrsobvqm[j]
<operator>.indirectIndexAccess k2[j]
<operator>.indirectIndexAccess ktrxvrsobvqm[j]
<operator>.indirectIndexAccess k2[j]
>>>PDG&131 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->35 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->47 0->48 0->49 0->51 0->54 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->68 0->69 0->70 0->71 0->75 0->76 0->78 0->80 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->8 4->9 4->10 4->12 4->14 4->16 4->18 4->20 4->23 4->27 4->29 4->33 4->35 4->37 4->83 5->1 5->4 6->3 7->1 7->4 8->1 8->5 9->1 9->10 9->12 9->14 9->16 9->18 9->20 9->38 9->40 9->42 9->44 10->10 10->11 10->11 10->12 10->24 10->25 10->26 10->84 10->85 10->86 11->1 11->10 12->12 12->13 12->13 12->14 12->28 12->38 12->38 12->47 12->87 13->1 13->12 14->14 14->15 14->15 14->16 14->30 14->31 14->32 14->40 14->40 14->49 14->50 14->64 14->65 14->88 14->89 14->90 14->99 14->100 14->101 15->1 15->14 16->16 16->17 16->17 16->18 16->34 16->42 16->42 16->51 16->53 16->91 16->93 16->94 17->1 17->16 18->18 18->19 18->19 18->20 18->36 18->44 18->44 18->54 18->56 18->92 18->95 18->96 19->1 19->18 20->1 20->1 20->1 20->9 20->10 20->20 20->21 20->21 20->22 20->46 20->57 20->58 20->68 20->69 20->97 20->104 20->105 21->1 21->20 22->1 22->1 23->10 24->1 24->1 24->68 25->1 25->1 25->34 25->66 25->69 26->1 26->1 26->36 26->58 26->67 27->12 28->1 28->48 28->59 29->14 30->1 30->64 30->73 31->1 31->34 31->36 31->50 31->53 31->56 31->65 31->74 32->1 32->1 32->1 32->68 33->16 34->1 34->1 34->1 34->66 34->69 35->18 36->1 36->1 36->1 36->58 36->67 37->1 37->20 38->1 38->1 38->12 38->38 38->39 38->39 38->48 38->59 38->60 38->61 38->98 39->1 39->38 40->1 40->1 40->14 40->40 40->41 40->41 40->62 40->63 40->106 40->107 40->116 40->118 41->1 41->40 42->1 42->1 42->16 42->42 42->43 42->43 42->52 42->75 42->102 42->108 43->1 43->42 44->1 44->1 44->18 44->44 44->45 44->45 44->55 44->76 44->103 44->110 45->1 45->44 46->1 46->1 47->1 47->38 48->1 48->28 48->59 48->60 48->61 49->1 49->40 50->1 50->1 50->32 50->32 51->1 51->42 52->1 52->1 52->1 52->55 52->62 52->66 52->77 52->79 52->80 52->81 52->82 52->109 52->123 52->124 52->125 52->126 52->127 52->128 52->129 52->130 53->1 53->1 54->1 54->44 55->1 55->1 55->1 55->52 55->62 55->67 55->111 55->112 56->1 56->1 57->1 57->1 58->1 58->22 58->22 58->36 58->46 58->46 58->67 59->1 59->60 59->70 59->113 59->120 60->1 60->61 60->71 60->114 60->121 61->1 61->1 61->28 61->48 61->59 61->72 61->78 61->115 61->122 62->1 62->63 62->73 62->117 63->1 63->1 63->52 63->55 63->62 63->74 63->119 64->34 64->36 64->50 64->50 64->53 64->56 64->65 65->1 65->1 66->1 66->1 66->34 67->1 67->1 67->36 68->1 68->22 68->22 68->46 68->46 68->57 68->57 69->1 69->22 69->22 69->34 69->46 69->46 69->57 69->57 69->66 70->1 70->1 70->52 70->55 70->62 71->1 71->1 71->52 71->55 71->62 72->1 72->1 72->1 72->52 72->55 72->62 73->1 73->64 74->1 74->34 74->36 74->50 74->53 74->56 74->65 75->52 76->55 77->1 77->1 77->66 77->66 78->72 79->1 79->1 79->77 79->77 80->1 80->77 80->77 81->1 81->79 81->79 82->1 82->1
>>>Token int main ( ) { double zhxipwwbbwis [ 100 ] , owp [ 100 ] , oowp [ 100 ] ; int wyihmunsmtsf , ti , n , i , j ; int oglfakpukbhg [ 100 ] [ 100 ] ; char smwyjpiolrqy ; int ktrxvrsobvqm [ 100 ] , k2 [ 100 ] , k3 ; scanf ( " " , & wyihmunsmtsf ) ; for ( ti = 1 ; ti <= wyihmunsmtsf ; ti ++ ) { printf ( " \n " , ti ) ; scanf ( " " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { zhxipwwbbwis [ i ] = 0 ; owp [ i ] = 0 ; oowp [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { scanf ( " " , & smwyjpiolrqy ) ; for ( j = 0 ; j < n ; j ++ ) { scanf ( " " , & smwyjpiolrqy ) ; if ( smwyjpiolrqy == ' ' ) oglfakpukbhg [ i ] [ j ] = 1 ; if ( smwyjpiolrqy == ' ' ) oglfakpukbhg [ i ] [ j ] = 0 ; if ( smwyjpiolrqy == ' ' ) oglfakpukbhg [ i ] [ j ] = -1 ; } } for ( i = 0 ; i < n ; i ++ ) { ktrxvrsobvqm [ i ] = 0 ; k2 [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( oglfakpukbhg [ i ] [ j ] == 1 ) ktrxvrsobvqm [ i ] ++ ; if ( oglfakpukbhg [ i ] [ j ] == 0 ) k2 [ i ] ++ ; } zhxipwwbbwis [ i ] = 1.0 * ktrxvrsobvqm [ i ] / ( ktrxvrsobvqm [ i ] + k2 [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) if ( oglfakpukbhg [ i ] [ j ] != -1 ) owp [ i ] += ( zhxipwwbbwis [ j ] * ( ktrxvrsobvqm [ j ] + k2 [ j ] ) - oglfakpukbhg [ j ] [ i ] ) / ( ktrxvrsobvqm [ j ] + k2 [ j ] - 1 ) ; owp [ i ] /= ktrxvrsobvqm [ i ] + k2 [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) if ( oglfakpukbhg [ i ] [ j ] != -1 ) oowp [ i ] += owp [ j ] ; oowp [ i ] /= ktrxvrsobvqm [ i ] + k2 [ i ] ; } for ( i = 0 ; i < n ; i ++ ) printf ( " \n " , 0.25 * zhxipwwbbwis [ i ] + 0.5 * owp [ i ] + 0.25 * oowp [ i ] ) ; } return 0 ; }
>>>Func
METHOD zdjhyqwqsnvj
METHOD_RETURN char
PARAM char wjqsssunxhzl
PARAM int yefwjorscjlg
RETURN return 0; return 0;
<operator>.lessThan tggbzpfudnok<yefwjorscjlg
<operator>.postIncrement tggbzpfudnok++
LITERAL 0 return 0;
<operator>.assignment tggbzpfudnok=0
<operator>.equals oojsflxedyox[tggbzpfudnok][0]==wjqsssunxhzl
<operator>.equals oojsflxedyox[tggbzpfudnok][1]==wjqsssunxhzl
RETURN return oojsflxedyox[tggbzpfudnok][1]; return oojsflxedyox[tggbzpfudnok][1];
RETURN return oojsflxedyox[tggbzpfudnok][0]; return oojsflxedyox[tggbzpfudnok][0];
<operator>.indirectIndexAccess oojsflxedyox[tggbzpfudnok][0]
<operator>.indirectIndexAccess oojsflxedyox[tggbzpfudnok][1]
<operator>.indirectIndexAccess oojsflxedyox[tggbzpfudnok]
<operator>.indirectIndexAccess oojsflxedyox[tggbzpfudnok][1]
<operator>.indirectIndexAccess oojsflxedyox[tggbzpfudnok]
<operator>.indirectIndexAccess oojsflxedyox[tggbzpfudnok][0]
<operator>.indirectIndexAccess oojsflxedyox[tggbzpfudnok]
<operator>.indirectIndexAccess oojsflxedyox[tggbzpfudnok]
>>>PDG&21 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->9 3->5 4->1 5->1 5->1 5->1 5->4 5->6 5->9 5->13 5->15 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->1 9->10 9->10 9->11 9->14 9->16 9->17 9->19 10->1 10->1 10->5 10->6 10->9 10->12 10->18 10->20 11->1 12->1
>>>Token char zdjhyqwqsnvj ( char wjqsssunxhzl , int yefwjorscjlg ) { int tggbzpfudnok ; for ( tggbzpfudnok = 0 ; tggbzpfudnok < yefwjorscjlg ; tggbzpfudnok ++ ) { if ( oojsflxedyox [ tggbzpfudnok ] [ 0 ] == wjqsssunxhzl ) return oojsflxedyox [ tggbzpfudnok ] [ 1 ] ; if ( oojsflxedyox [ tggbzpfudnok ] [ 1 ] == wjqsssunxhzl ) return oojsflxedyox [ tggbzpfudnok ] [ 0 ] ; } return 0 ; }
>>>Func
METHOD svvfypotkanw
METHOD_RETURN void
PARAM ArrayList *arraylist
<operator>.assignment arraylist->length=0
>>>PDG&4 0->2 0->3 2->1 3->1 3->1
>>>Token void svvfypotkanw ( ArrayList * arraylist ) { arraylist -> length = 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int rrvlltfauwnh
PARAM char **argv
freopen freopen("input","r",stdin)
<operator>.assignment olqhyqechqbf=0
scanf scanf("%d",&qjhfsmgbpskq)
<operator>.assignment neczmwuqlbns=0
RETURN return 0; return 0;
<operator>.postDecrement qjhfsmgbpskq--
LITERAL 0 return 0;
<operator>.preIncrement ++neczmwuqlbns
scanf scanf("%d%d%d",&n,&tlbnpxisffua,&pg)
<operator>.assignment neskgltoofli=tlbnpxisffua
<operator>.assignment down=100
printf printf("Case #%d: Possible\n",neczmwuqlbns)
IDENTIFIER debug if (debug)
<operator>.logicalAnd pg==0&&tlbnpxisffua==0
<operator>.logicalAnd pg==100&&tlbnpxisffua==100
<operator>.logicalAnd pg==0&&tlbnpxisffua!=0
<operator>.logicalAnd pg==100&&tlbnpxisffua!=100
<operator>.lessThan olqhyqechqbf<clen
<operator>.preIncrement ++olqhyqechqbf
IDENTIFIER debug if (debug)
<operator>.greaterThan down>n
printf printf("n: %d, pd: %d, pg: %d\t",n,tlbnpxisffua,pg)
printf printf("Case #%d: Possible\n",neczmwuqlbns)
printf printf("Case #%d: Possible\n",neczmwuqlbns)
printf printf("Case #%d: Broken\n",neczmwuqlbns)
printf printf("Case #%d: Broken\n",neczmwuqlbns)
<operator>.assignment olqhyqechqbf=0
printf printf("up: %d, down: %d\t\t",neskgltoofli,down)
printf printf("Case #%d: Broken\n",neczmwuqlbns)
<operator>.equals pg==0
<operator>.equals tlbnpxisffua==0
<operator>.equals pg==100
<operator>.equals tlbnpxisffua==100
<operator>.equals pg==0
<operator>.notEquals tlbnpxisffua!=0
<operator>.equals pg==100
<operator>.notEquals tlbnpxisffua!=100
<operator>.logicalAnd neskgltoofli%c[olqhyqechqbf]==0&&down%c[olqhyqechqbf]==0&&neskgltoofli!=0
IDENTIFIER debug if (debug)
printf printf("down > n ")
<operator>.logicalAnd neskgltoofli%c[olqhyqechqbf]==0&&down%c[olqhyqechqbf]==0
<operator>.notEquals neskgltoofli!=0
<operator>.logicalAnd neskgltoofli%c[olqhyqechqbf]==0&&down%c[olqhyqechqbf]==0
<operator>.equals neskgltoofli%c[olqhyqechqbf]==0
<operator>.equals down%c[olqhyqechqbf]==0
<operator>.assignmentDivision neskgltoofli/=c[olqhyqechqbf]
<operator>.assignmentDivision down/=c[olqhyqechqbf]
<operator>.modulo neskgltoofli%c[olqhyqechqbf]
<operator>.modulo down%c[olqhyqechqbf]
<operator>.equals neskgltoofli%c[olqhyqechqbf]==0
<operator>.equals down%c[olqhyqechqbf]==0
<operator>.modulo neskgltoofli%c[olqhyqechqbf]
<operator>.modulo down%c[olqhyqechqbf]
<operator>.addressOf &n
<operator>.addressOf &tlbnpxisffua
<operator>.addressOf &pg
<operator>.indirectIndexAccess c[olqhyqechqbf]
<operator>.indirectIndexAccess c[olqhyqechqbf]
<operator>.indirectIndexAccess c[olqhyqechqbf]
<operator>.indirectIndexAccess c[olqhyqechqbf]
<operator>.indirectIndexAccess c[olqhyqechqbf]
<operator>.indirectIndexAccess c[olqhyqechqbf]
>>>PDG&66 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->42 0->43 0->45 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 2->1 3->1 4->1 4->1 5->1 5->1 6->1 6->9 7->1 7->1 7->11 8->1 9->1 9->1 9->9 9->11 9->12 9->17 9->25 9->33 9->57 9->58 9->59 10->8 11->1 11->15 11->26 11->27 11->28 11->29 11->32 12->1 12->1 12->1 12->24 12->25 13->1 13->1 13->1 13->31 13->51 14->1 14->24 14->31 14->50 14->52 14->56 15->1 15->1 15->11 17->1 17->1 17->1 17->18 17->26 17->35 18->1 18->1 18->1 18->19 18->27 18->37 19->1 19->1 19->1 19->20 19->28 19->39 20->1 20->1 20->1 20->13 20->14 20->21 20->24 20->29 20->30 20->31 21->1 21->1 21->1 21->21 21->22 21->22 21->41 21->44 21->47 21->51 21->60 22->1 22->21 24->1 24->1 24->1 24->12 24->15 24->25 24->32 24->43 25->1 25->1 25->1 25->12 25->13 25->24 25->33 25->34 25->36 25->38 25->40 26->1 26->1 26->11 27->1 27->1 27->11 28->1 28->1 28->11 29->1 29->1 29->11 30->1 30->21 31->1 31->1 31->24 32->1 32->1 32->11 33->1 33->17 33->17 33->25 33->34 33->35 34->1 34->13 34->17 34->17 34->25 34->36 34->38 34->40 35->1 35->18 35->18 35->25 35->33 35->36 35->37 36->1 36->13 36->18 36->18 36->25 36->34 36->38 36->40 37->1 37->19 37->19 37->25 37->33 37->38 37->39 38->1 38->13 38->19 38->19 38->25 38->34 38->36 38->40 39->1 39->20 39->20 39->25 39->33 39->40 40->1 40->13 40->20 40->20 40->25 40->34 40->36 40->38 41->1 41->1 41->1 41->46 41->53 41->55 41->64 43->1 44->1 44->1 44->41 44->41 44->45 44->46 45->1 45->31 45->41 45->41 45->51 45->55 46->1 46->1 46->1 46->44 46->46 46->49 46->50 46->53 46->55 46->62 46->63 46->64 47->1 47->44 47->44 47->48 47->52 47->61 48->1 48->44 48->44 49->1 49->55 50->1 50->24 50->31 50->52 50->56 51->1 51->1 51->31 51->45 51->47 51->47 51->52 51->55 51->55 52->1 52->24 52->31 52->48 52->48 52->50 52->51 52->55 52->56 53->1 53->46 53->46 53->54 53->56 53->65 54->1 54->46 54->46 55->1 55->1 55->31 55->49 55->49 55->50 55->51 55->51 55->53 55->53 55->56 56->1 56->24 56->31 56->49 56->50 56->50 56->51 56->52 56->54 56->54 56->55
>>>Token int main ( int rrvlltfauwnh , char * * argv ) { freopen ( " " , " " , stdin ) ; int qjhfsmgbpskq , n ; int tlbnpxisffua , pg ; int neskgltoofli , down ; int olqhyqechqbf = 0 ; scanf ( " " , & qjhfsmgbpskq ) ; int neczmwuqlbns = 0 ; while ( qjhfsmgbpskq -- ) { ++ neczmwuqlbns ; scanf ( " " , & n , & tlbnpxisffua , & pg ) ; if ( debug ) { printf ( " \t " , n , tlbnpxisffua , pg ) ; } if ( pg == 0 && tlbnpxisffua == 0 ) { printf ( " \n " , neczmwuqlbns ) ; continue ; } if ( pg == 100 && tlbnpxisffua == 100 ) { printf ( " \n " , neczmwuqlbns ) ; continue ; } if ( pg == 0 && tlbnpxisffua != 0 ) { printf ( " \n " , neczmwuqlbns ) ; continue ; } if ( pg == 100 && tlbnpxisffua != 100 ) { printf ( " \n " , neczmwuqlbns ) ; continue ; } neskgltoofli = tlbnpxisffua ; down = 100 ; for ( olqhyqechqbf = 0 ; olqhyqechqbf < clen ; ++ olqhyqechqbf ) { if ( neskgltoofli % c [ olqhyqechqbf ] == 0 && down % c [ olqhyqechqbf ] == 0 && neskgltoofli != 0 ) { while ( neskgltoofli % c [ olqhyqechqbf ] == 0 && down % c [ olqhyqechqbf ] == 0 ) { neskgltoofli /= c [ olqhyqechqbf ] ; down /= c [ olqhyqechqbf ] ; } } } if ( debug ) { printf ( " \t \t " , neskgltoofli , down ) ; } if ( down > n ) { if ( debug ) { printf ( " " ) ; } printf ( " \n " , neczmwuqlbns ) ; continue ; } printf ( " \n " , neczmwuqlbns ) ; } return 0 ; }
>>>Func
METHOD uuhdpgfqgsuo
METHOD_RETURN int
PARAM string olbharzulbwo
<operator>.shiftLeft vector<<missing
StringSplit2Int StringSplit2Int(olbharzulbwo,":",tmp_int)
RETURN return ((tmp_int[0]*60)+tmp_int[1]); return ((tmp_int[0]*60)+tmp_int[1]);
<operator>.addition (tmp_int[0]*60)+tmp_int[1]
<operator>.multiplication tmp_int[0]*60
>>>PDG&8 0->2 0->3 0->4 0->7 2->4 3->1 3->1 3->1 4->1 4->1 4->1 4->6 4->7 5->1 6->1 6->1 6->1 6->5 7->1 7->6 7->6
>>>Token int uuhdpgfqgsuo ( string olbharzulbwo ) { vector << missing ' ' > int > tmp_int ; StringSplit2Int ( olbharzulbwo , " " , tmp_int ) ; return ( ( tmp_int [ 0 ] * 60 ) + tmp_int [ 1 ] ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment teste=1
scanf scanf("%d",&n)
RETURN return 0; return 0;
<operator>.lessThan i<256
<operator>.postIncrement i++
<operator>.assignment v[i]=10
<operator>.lessThan i<8
<operator>.postIncrement i++
<operator>.assignment v[ch[i]]=i
<operator>.postDecrement n--
LITERAL 0 return 0;
<operator>.assignment i=0
<operator>.assignment i=0
memset memset(comb 0 sizeof(comb))
memset memset(opp 0 sizeof(opp))
memset memset(str 0 sizeof(str))
scanf scanf("%d",&kprlhjxqzbnf)
scanf scanf("%d",&kprlhjxqzbnf)
scanf scanf("%d",&kprlhjxqzbnf)
getchar getchar()
<operator>.assignment i=-1
<operator>.assignment str[++i]=0
<operator>.assignment str[++i]=0
printf printf("Case #%d: [",teste++)
printf printf("]\n")
<operator>.postDecrement kprlhjxqzbnf--
<operator>.postDecrement kprlhjxqzbnf--
<operator>.postDecrement kprlhjxqzbnf--
<operator>.notEquals str[0]!=0
<operator>.notEquals str[i]!=0
<operator>.postIncrement i++
printf printf(", %c",str[i])
scanf scanf(" %c%c%c",&efcnpooxwjsq,&b,&f)
<operator>.assignment comb[v[efcnpooxwjsq]][v[b]]=f
<operator>.assignment comb[v[b]][v[efcnpooxwjsq]]=f
scanf scanf(" %c%c",&efcnpooxwjsq,&b)
<operator>.assignment opp[v[efcnpooxwjsq]][v[b]]=1
<operator>.assignment opp[v[b]][v[efcnpooxwjsq]]=1
<operator>.minus -1
<operator>.assignment aux=getchar()
<operator>.postIncrement teste++
printf printf("%c",str[0])
<operator>.assignment i=1
<operator>.equals i==-1
<operator>.preIncrement ++i
<operator>.preIncrement ++i
<operator>.assignment str[++i]=aux
<operator>.minus -1
<operator>.notEquals comb[v[str[i]]][v[aux]]!=0
<operator>.preIncrement ++i
<operator>.assignment str[i]=comb[v[str[i]]][v[aux]]
<operator>.lessEqualsThan k<=i
<operator>.postIncrement k++
<operator>.logicalAnd (k>i)&&(i!=-1)
<operator>.assignment k=0
<operator>.assignment str[++i]=aux
<operator>.greaterThan k>i
<operator>.notEquals i!=-1
<operator>.assignment i=-1
<operator>.minus -1
<operator>.preIncrement ++i
<operator>.minus -1
<operator>.indirectIndexAccess v[i]
<operator>.indirectIndexAccess v[ch[i]]
<operator>.indirectIndexAccess ch[i]
<operator>.sizeOf sizeof(comb)
<operator>.sizeOf sizeof(opp)
<operator>.sizeOf sizeof(str)
<operator>.addressOf &kprlhjxqzbnf
<operator>.addressOf &kprlhjxqzbnf
<operator>.addressOf &kprlhjxqzbnf
<operator>.indirectIndexAccess str[++i]
<operator>.indirectIndexAccess str[++i]
<operator>.indirectIndexAccess str[0]
<operator>.indirectIndexAccess str[i]
<operator>.indirectIndexAccess str[i]
<operator>.addressOf &efcnpooxwjsq
<operator>.addressOf &b
<operator>.addressOf &f
<operator>.indirectIndexAccess comb[v[efcnpooxwjsq]][v[b]]
<operator>.indirectIndexAccess comb[v[b]][v[efcnpooxwjsq]]
<operator>.addressOf &efcnpooxwjsq
<operator>.addressOf &b
<operator>.indirectIndexAccess opp[v[efcnpooxwjsq]][v[b]]
<operator>.indirectIndexAccess opp[v[b]][v[efcnpooxwjsq]]
getchar getchar()
<operator>.indirectIndexAccess str[0]
<operator>.indirectIndexAccess comb[v[efcnpooxwjsq]]
<operator>.indirectIndexAccess v[b]
<operator>.indirectIndexAccess comb[v[b]]
<operator>.indirectIndexAccess v[efcnpooxwjsq]
<operator>.indirectIndexAccess opp[v[efcnpooxwjsq]]
<operator>.indirectIndexAccess v[b]
<operator>.indirectIndexAccess opp[v[b]]
<operator>.indirectIndexAccess v[efcnpooxwjsq]
<operator>.indirectIndexAccess v[efcnpooxwjsq]
<operator>.indirectIndexAccess v[b]
<operator>.indirectIndexAccess v[efcnpooxwjsq]
<operator>.indirectIndexAccess v[b]
<operator>.indirectIndexAccess str[++i]
<operator>.indirectIndexAccess comb[v[str[i]]][v[aux]]
<operator>.indirectIndexAccess comb[v[str[i]]]
<operator>.indirectIndexAccess v[aux]
<operator>.indirectIndexAccess str[i]
<operator>.indirectIndexAccess comb[v[str[i]]][v[aux]]
<operator>.indirectIndexAccess v[str[i]]
<operator>.indirectIndexAccess comb[v[str[i]]]
<operator>.indirectIndexAccess v[aux]
<operator>.indirectIndexAccess str[i]
<operator>.indirectIndexAccess v[str[i]]
<operator>.indirectIndexAccess str[i]
<operator>.indirectIndexAccess opp[v[aux]][v[str[k]]]
<operator>.indirectIndexAccess str[++i]
<operator>.indirectIndexAccess opp[v[aux]]
<operator>.indirectIndexAccess v[str[k]]
<operator>.indirectIndexAccess v[aux]
<operator>.indirectIndexAccess str[k]
>>>PDG&119 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->53 0->54 0->56 0->57 0->58 0->59 0->61 0->62 0->63 2->1 2->1 2->42 3->1 3->11 4->1 5->1 5->5 5->6 5->6 5->7 5->64 6->1 6->5 7->1 7->1 8->1 8->1 8->8 8->9 8->9 8->10 8->10 8->65 8->66 9->1 9->8 10->1 10->1 11->1 11->1 11->11 11->15 11->16 11->17 11->18 11->19 11->20 11->21 11->22 11->23 11->24 11->25 11->26 11->27 11->28 11->29 11->30 11->31 11->40 11->42 11->44 11->46 11->47 11->67 11->68 11->69 11->70 11->71 11->72 11->73 11->74 11->75 11->76 12->4 13->5 14->1 14->8 15->1 15->1 16->1 16->1 17->1 17->1 17->30 17->31 17->33 17->43 18->19 18->27 18->28 19->20 19->28 19->29 20->1 20->18 20->27 20->29 21->1 22->1 22->1 22->45 22->46 24->1 24->1 24->17 25->1 25->1 26->1 27->19 27->27 27->28 27->34 27->35 27->36 27->78 27->79 27->80 27->81 27->82 27->89 27->90 27->91 27->92 27->97 27->98 28->20 28->28 28->29 28->37 28->38 28->39 28->83 28->84 28->85 28->86 28->93 28->94 28->95 28->96 28->99 28->100 29->1 29->1 29->18 29->27 29->29 29->41 29->45 29->49 29->87 30->1 30->1 30->17 30->43 30->43 30->88 31->1 31->1 31->17 31->31 31->32 31->33 31->33 31->76 31->77 32->1 32->1 33->1 33->31 34->1 34->1 34->1 34->37 35->1 35->1 36->1 36->1 36->1 37->1 37->1 37->34 38->1 38->1 39->1 39->1 40->22 41->1 41->1 41->1 41->48 41->57 42->1 42->25 43->1 43->1 43->17 43->30 44->1 44->1 44->32 45->1 45->1 45->46 45->48 45->50 45->51 45->51 45->53 45->101 45->102 45->103 45->104 45->107 45->110 46->47 48->1 48->1 49->45 50->1 50->1 50->52 50->52 50->53 50->55 50->56 50->58 50->105 50->106 50->108 50->109 50->111 50->112 51->45 51->46 52->1 52->1 52->31 53->1 53->54 53->58 53->58 53->113 53->115 53->116 53->117 53->118 54->1 54->53 55->1 55->1 55->1 55->57 55->62 55->114 56->1 56->53 57->1 57->1 58->1 58->45 58->46 58->55 58->55 58->59 58->59 58->61 58->62 59->1 59->45 59->46 59->55 59->55 59->62 60->1 60->1 60->58 61->59 62->45 62->46 63->60 113->53 113->54 113->60 113->63
>>>Token int main ( ) { int kprlhjxqzbnf , n , i , j , k , l , teste = 1 , index ; char efcnpooxwjsq , b , f , aux ; for ( i = 0 ; i < 256 ; i ++ ) v [ i ] = 10 ; for ( i = 0 ; i < 8 ; i ++ ) v [ ch [ i ] ] = i ; scanf ( " " , & n ) ; while ( n -- ) { memset ( comb , 0 , sizeof ( comb ) ) ; memset ( opp , 0 , sizeof ( opp ) ) ; memset ( str , 0 , sizeof ( str ) ) ; scanf ( " " , & kprlhjxqzbnf ) ; while ( kprlhjxqzbnf -- ) { scanf ( " " , & efcnpooxwjsq , & b , & f ) ; comb [ v [ efcnpooxwjsq ] ] [ v [ b ] ] = f ; comb [ v [ b ] ] [ v [ efcnpooxwjsq ] ] = f ; } scanf ( " " , & kprlhjxqzbnf ) ; while ( kprlhjxqzbnf -- ) { scanf ( " " , & efcnpooxwjsq , & b ) ; opp [ v [ efcnpooxwjsq ] ] [ v [ b ] ] = 1 ; opp [ v [ b ] ] [ v [ efcnpooxwjsq ] ] = 1 ; } scanf ( " " , & kprlhjxqzbnf ) ; getchar ( ) ; i = -1 ; while ( kprlhjxqzbnf -- ) { aux = getchar ( ) ; if ( i == -1 ) { str [ ++ i ] = aux ; } else { if ( comb [ v [ str [ i ] ] ] [ v [ aux ] ] != 0 ) { str [ i ] = comb [ v [ str [ i ] ] ] [ v [ aux ] ] ; } else { for ( k = 0 ; k <= i ; k ++ ) { if ( opp [ v [ aux ] ] [ v [ str [ k ] ] ] ) { i = -1 ; break ; } } if ( ( k > i ) && ( i != -1 ) ) str [ ++ i ] = aux ; } } } str [ ++ i ] = 0 ; str [ ++ i ] = 0 ; printf ( " " , teste ++ ) ; if ( str [ 0 ] != 0 ) printf ( " " , str [ 0 ] ) ; for ( i = 1 ; str [ i ] != 0 ; i ++ ) printf ( " " , str [ i ] ) ; printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD xorrkggufoqq
METHOD_RETURN int
PARAM int azjlheozqrum
PARAM int kncepqhxnfpy
IDENTIFIER nulyeqebmopn <empty>
xorrkggufoqq xorrkggufoqq(kncepqhxnfpy,azjlheozqrum%kncepqhxnfpy)
<operator>.modulo azjlheozqrum%kncepqhxnfpy
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->6 3->6 5->1 5->1 5->1 6->1 6->5 6->5
>>>Token int xorrkggufoqq ( int azjlheozqrum , int kncepqhxnfpy ) { if ( ! kncepqhxnfpy ) nulyeqebmopn  azjlheozqrum ; else nulyeqebmopn  xorrkggufoqq ( kncepqhxnfpy , azjlheozqrum % kncepqhxnfpy ) ; }
>>>Func
METHOD ubpumeoqkrbs
METHOD_RETURN void
PARAM int *a
PARAM int wfhredtbwkpv
<operator>.greaterEqualsThan gcitnorovaix>=2
<operator>.postDecrement gcitnorovaix--
<operator>.assignment gcitnorovaix=wfhredtbwkpv
<operator>.assignment temp=a[gcitnorovaix]
<operator>.assignment a[gcitnorovaix]=a[1]
<operator>.assignment a[1]=temp
max_heapify max_heapify(a,1,gcitnorovaix-1)
<operator>.subtraction gcitnorovaix-1
<operator>.indirectIndexAccess a[gcitnorovaix]
<operator>.indirectIndexAccess a[gcitnorovaix]
<operator>.indirectIndexAccess a[1]
<operator>.indirectIndexAccess a[1]
>>>PDG&16 0->2 0->3 0->4 0->5 0->6 0->9 0->10 0->11 2->1 2->7 2->8 2->10 3->6 4->1 4->1 4->4 4->5 4->7 4->8 4->9 4->10 4->11 4->11 4->12 4->13 4->14 4->15 5->1 5->4 6->1 6->1 6->4 7->9 8->7 8->10 9->8 9->10 10->7 10->8 11->5 11->10 11->10
>>>Token void ubpumeoqkrbs ( int * a , int wfhredtbwkpv ) { int gcitnorovaix , temp ; for ( gcitnorovaix = wfhredtbwkpv ; gcitnorovaix >= 2 ; gcitnorovaix -- ) { temp = a [ gcitnorovaix ] ; a [ gcitnorovaix ] = a [ 1 ] ; a [ 1 ] = temp ; max_heapify ( a , 1 , gcitnorovaix - 1 ) ; } }
>>>Func
METHOD ubfeuvgdydfc
METHOD_RETURN void
PARAM int wwdenayrnpfu
<operator>.notEquals head[edtdtcozausw]!=edtdtcozausw
<operator>.assignment edtdtcozausw=head[edtdtcozausw]
<operator>.notEquals head[y]!=y
<operator>.assignment edtdtcozausw=wwdenayrnpfu
<operator>.assignment y=wwdenayrnpfu
<operator>.assignment z=head[y]
<operator>.assignment head[y]=edtdtcozausw
<operator>.assignment y=z
<operator>.indirectIndexAccess head[edtdtcozausw]
<operator>.indirectIndexAccess head[edtdtcozausw]
<operator>.indirectIndexAccess head[y]
<operator>.indirectIndexAccess head[y]
<operator>.indirectIndexAccess head[y]
>>>PDG&16 0->2 0->3 0->5 0->6 0->7 0->9 0->10 2->6 2->7 3->1 3->1 3->1 3->3 3->4 3->4 3->9 3->11 3->12 4->1 4->3 5->1 5->1 5->1 5->5 5->8 5->8 5->9 5->10 5->13 5->14 5->15 6->1 6->3 7->1 7->1 7->5 8->10 9->5 10->1 10->1 10->5
>>>Token void ubfeuvgdydfc ( int wwdenayrnpfu ) { int edtdtcozausw , y , z ; for ( edtdtcozausw = wwdenayrnpfu ; head [ edtdtcozausw ] != edtdtcozausw ; ) edtdtcozausw = head [ edtdtcozausw ] ; for ( y = wwdenayrnpfu ; head [ y ] != y ; ) { z = head [ y ] ; head [ y ] = edtdtcozausw ; y = z ; } }
>>>Func
METHOD jxntdoqzvzcg
METHOD_RETURN void
PARAM Graph gnhbaddikyyv
PARAM Edge amkjlczzkaph
assert assert(gnhbaddikyyv!=NULL&&validV(gnhbaddikyyv,amkjlczzkaph.v)&&validV(gnhbaddikyyv,amkjlczzkaph.w))
<operator>.logicalAnd gnhbaddikyyv!=NULL&&validV(gnhbaddikyyv,amkjlczzkaph.v)&&validV(gnhbaddikyyv,amkjlczzkaph.w)
<operator>.assignment gnhbaddikyyv->edges[amkjlczzkaph.v][amkjlczzkaph.w]=0
<operator>.assignment gnhbaddikyyv->edges[amkjlczzkaph.w][amkjlczzkaph.v]=0
<operator>.postDecrement gnhbaddikyyv->nE--
<operator>.logicalAnd gnhbaddikyyv!=NULL&&validV(gnhbaddikyyv,amkjlczzkaph.v)
validV validV(gnhbaddikyyv,amkjlczzkaph.w)
<operator>.notEquals gnhbaddikyyv!=NULL
validV validV(gnhbaddikyyv,amkjlczzkaph.v)
<operator>.indirectIndexAccess gnhbaddikyyv->edges[amkjlczzkaph.v][amkjlczzkaph.w]
<operator>.fieldAccess amkjlczzkaph.w
<operator>.indirectIndexAccess gnhbaddikyyv->edges[amkjlczzkaph.v][amkjlczzkaph.w]
<operator>.indirectIndexAccess gnhbaddikyyv->edges[amkjlczzkaph.w][amkjlczzkaph.v]
<operator>.indirectFieldAccess gnhbaddikyyv->nE
<operator>.fieldAccess amkjlczzkaph.v
FIELD_IDENTIFIER w w
<operator>.indirectIndexAccess gnhbaddikyyv->edges[amkjlczzkaph.v]
<operator>.fieldAccess amkjlczzkaph.w
<operator>.indirectIndexAccess gnhbaddikyyv->edges[amkjlczzkaph.w]
<operator>.fieldAccess amkjlczzkaph.v
FIELD_IDENTIFIER nE nE
FIELD_IDENTIFIER v v
<operator>.indirectFieldAccess gnhbaddikyyv->edges
<operator>.fieldAccess amkjlczzkaph.v
FIELD_IDENTIFIER w w
<operator>.indirectFieldAccess gnhbaddikyyv->edges
<operator>.fieldAccess amkjlczzkaph.w
FIELD_IDENTIFIER v v
FIELD_IDENTIFIER edges edges
FIELD_IDENTIFIER v v
FIELD_IDENTIFIER edges edges
FIELD_IDENTIFIER w w
>>>PDG&36 0->2 0->3 0->6 0->7 0->10 0->11 0->12 2->11 3->1 3->10 3->12 4->1 4->1 5->1 5->1 5->4 5->4 6->1 6->1 7->1 7->1 8->1 8->1 9->1 9->1 9->5 9->5 9->10 9->14 9->19 10->1 10->1 10->5 10->5 11->1 11->1 11->9 11->9 11->10 11->12 11->12 11->18 11->25 12->1 12->1 12->9 12->9 12->10 13->6 13->7 13->8 13->15 13->16 13->17 13->20 13->21 13->22 13->23 13->24 13->26 13->27 13->28 13->29 13->30 13->31 13->32 13->33 13->34 13->35
>>>Token void jxntdoqzvzcg ( Graph gnhbaddikyyv , Edge amkjlczzkaph ) { assert ( gnhbaddikyyv != NULL && validV ( gnhbaddikyyv , amkjlczzkaph . v ) && validV ( gnhbaddikyyv , amkjlczzkaph . w ) ) ; if ( gnhbaddikyyv -> edges [ amkjlczzkaph . v ] [ amkjlczzkaph . w ] ) { gnhbaddikyyv -> edges [ amkjlczzkaph . v ] [ amkjlczzkaph . w ] = 0 ; gnhbaddikyyv -> edges [ amkjlczzkaph . w ] [ amkjlczzkaph . v ] = 0 ; gnhbaddikyyv -> nE -- ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment count=0
scanf scanf("%d\n",&t)
RETURN return 0; return 0;
<operator>.lessEqualsThan f<=t
<operator>.postIncrement f++
LITERAL 0 return 0;
<operator>.assignment f=1
scanf scanf("%d\n",&n)
printf printf("Case #%d:\n",f)
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.lessThan i<n
<operator>.postIncrement i++
<operator>.assignment i=0
<operator>.assignment i=0
<operator>.assignment win=0
<operator>.assignment total=0
<operator>.assignment win1[i]=win
<operator>.assignment total1[i]=total
<operator>.assignment i=0
<operator>.assignment count=0
<operator>.assignment wgmyybtiufxs=0
<operator>.assignment i=0
<operator>.assignment wgmyybtiufxs=0
<operator>.assignment count=0
<operator>.assignment i=0
<operator>.assignment rpi=(0.25 *wp[i])+(0.50 *owp[i])+(0.25 *oowp[i])
printf printf("%0.12Lf\n",rpi)
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.assignment j=0
scanf scanf("%c",&wmgmrpfkkrku)
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.addition (0.25 *wp[i])+(0.50 *owp[i])+(0.25 *oowp[i])
<operator>.equals wmgmrpfkkrku=='.'
<operator>.equals wmgmrpfkkrku=='0'
<operator>.equals wmgmrpfkkrku=='1'
<operator>.notEquals idcfgggvynvp[i][j]!=-1
<operator>.notEquals idcfgggvynvp[i][j]!=-1
<operator>.notEquals idcfgggvynvp[i][j]!=-1
<operator>.addition (0.25 *wp[i])+(0.50 *owp[i])
<operator>.multiplication 0.25 *oowp[i]
<operator>.assignment idcfgggvynvp[i][j]=-1
<operator>.assignment idcfgggvynvp[i][j]=0
<operator>.assignment idcfgggvynvp[i][j]=1
<operator>.postIncrement total++
<operator>.postIncrement count++
<operator>.postIncrement count++
<operator>.assignmentPlus wgmyybtiufxs+=owp[j]
<operator>.multiplication 0.25 *wp[i]
<operator>.multiplication 0.50 *owp[i]
<operator>.minus -1
<operator>.equals idcfgggvynvp[i][j]==1
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.postIncrement win++
<operator>.addressOf &n
scanf scanf("\n")
UNKNOWN wp[i]=(long dyavxqnagqrc)win/total; wp[i]=(long dyavxqnagqrc)win/total;
UNKNOWN owp[i]=(long dyavxqnagqrc)wgmyybtiufxs/count; owp[i]=(long dyavxqnagqrc)wgmyybtiufxs/count;
UNKNOWN oowp[i]=(long dyavxqnagqrc)wgmyybtiufxs/count; oowp[i]=(long dyavxqnagqrc)wgmyybtiufxs/count;
<operator>.indirectIndexAccess win1[i]
<operator>.indirectIndexAccess total1[i]
<operator>.addressOf &wmgmrpfkkrku
<operator>.indirectIndexAccess oowp[i]
<operator>.indirectIndexAccess idcfgggvynvp[i][j]
<operator>.indirectIndexAccess idcfgggvynvp[i][j]
UNKNOWN if(idcfgggvynvp[i][j]==0)wgmyybtiufxs+=(long dyavxqnagqrc)(win1[j]-1)/(total1[j]-1); if(idcfgggvynvp[i][j]==0)wgmyybtiufxs+=(long dyavxqnagqrc)(win1[j]-1)/(total1[j]-1);
UNKNOWN else wgmyybtiufxs +=(long dyavxqnagqrc)(win1[j])/(total1[j]-1); else wgmyybtiufxs +=(long dyavxqnagqrc)(win1[j])/(total1[j]-1);
<operator>.indirectIndexAccess idcfgggvynvp[i][j]
<operator>.indirectIndexAccess wp[i]
<operator>.indirectIndexAccess owp[i]
<operator>.indirectIndexAccess idcfgggvynvp[i][j]
<operator>.indirectIndexAccess idcfgggvynvp[i][j]
<operator>.indirectIndexAccess idcfgggvynvp[i][j]
<operator>.indirectIndexAccess idcfgggvynvp[i]
<operator>.indirectIndexAccess idcfgggvynvp[i]
<operator>.indirectIndexAccess idcfgggvynvp[i]
<operator>.indirectIndexAccess owp[j]
<operator>.indirectIndexAccess idcfgggvynvp[i]
<operator>.indirectIndexAccess idcfgggvynvp[i]
<operator>.indirectIndexAccess idcfgggvynvp[i]
<operator>.indirectIndexAccess idcfgggvynvp[i][j]
<operator>.indirectIndexAccess idcfgggvynvp[i]
>>>PDG&101 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->57 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 2->1 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->9 5->10 5->10 5->11 5->13 5->15 5->17 5->19 5->21 5->22 5->27 5->30 5->33 5->73 6->1 6->5 7->4 8->1 8->5 9->1 9->11 9->13 9->15 9->17 9->19 9->36 9->38 9->40 9->42 10->1 10->6 11->11 11->12 11->12 11->13 11->36 11->36 11->44 11->74 12->1 12->11 13->13 13->14 13->14 13->15 13->23 13->24 13->25 13->26 13->38 13->38 13->46 13->75 13->78 13->79 14->1 14->13 15->15 15->16 15->16 15->17 15->28 15->29 15->40 15->40 15->47 15->76 16->1 16->15 17->17 17->18 17->18 17->19 17->31 17->32 17->42 17->42 17->48 17->77 18->1 18->17 19->1 19->1 19->1 19->9 19->11 19->19 19->20 19->20 19->34 19->35 19->49 19->56 19->57 19->65 19->66 19->81 19->87 19->88 20->1 20->19 21->11 22->13 23->1 23->25 23->72 24->1 24->26 24->61 25->1 25->1 25->1 26->1 26->1 26->1 27->15 28->1 28->1 28->62 29->1 29->1 30->17 31->1 31->1 31->64 32->1 32->1 32->63 33->1 33->19 34->1 34->1 34->35 35->1 35->1 36->1 36->1 36->11 36->36 36->37 36->37 36->45 36->50 36->51 36->52 36->80 37->1 37->36 38->1 38->1 38->13 38->38 38->39 38->39 38->53 38->67 38->82 38->92 39->1 39->38 40->1 40->1 40->15 40->40 40->41 40->41 40->54 40->69 40->83 40->93 41->1 41->40 42->1 42->1 42->17 42->42 42->43 42->43 42->55 42->70 42->86 42->94 43->1 43->42 44->1 44->36 45->1 45->50 45->51 45->52 46->1 46->38 47->1 47->40 48->1 48->42 49->1 49->1 50->1 50->51 50->58 50->71 50->89 50->96 51->1 51->52 51->59 51->90 51->97 52->1 52->1 52->45 52->50 52->60 52->91 52->98 53->1 53->1 53->1 53->54 53->55 53->61 53->68 53->68 53->99 53->100 54->1 54->1 54->1 54->53 54->55 54->62 54->84 54->85 55->1 55->1 55->1 55->53 55->54 55->63 55->64 55->95 56->1 56->1 57->1 57->34 57->34 57->49 57->49 58->1 58->1 58->1 58->53 58->54 58->55 59->1 59->1 59->53 59->54 59->55 60->1 60->1 60->53 60->54 60->55 61->1 61->26 62->1 62->1 63->1 63->1 64->1 64->1 64->1 65->1 65->34 65->34 65->49 65->49 65->56 65->56 66->1 66->34 66->34 66->49 66->49 66->56 66->56 67->53 68->1 68->1 68->53 68->54 68->55 68->72 69->54 70->55 71->58 72->1 72->25
>>>Token int main ( ) { int idcfgggvynvp [ 100 ] [ 100 ] , t , n , win , total , win1 [ 100 ] , total1 [ 100 ] , i , j , f , count = 0 ; long dyavxqnagqrcwp [ 100 ] , owp [ 100 ] , oowp [ 100 ] , wgmyybtiufxs , rpi ; char wmgmrpfkkrku ; scanf ( " \n " , & t ) ; for ( f = 1 ; f <= t ; f ++ ) { scanf ( " \n " , & n ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { scanf ( " " , & wmgmrpfkkrku ) ; if ( wmgmrpfkkrku == ' ' ) idcfgggvynvp [ i ] [ j ] = -1 ; if ( wmgmrpfkkrku == ' ' ) idcfgggvynvp [ i ] [ j ] = 0 ; if ( wmgmrpfkkrku == ' ' ) idcfgggvynvp [ i ] [ j ] = 1 ; } scanf ( " \n " ) ; } for ( i = 0 ; i < n ; i ++ ) { win = 0 ; total = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( idcfgggvynvp [ i ] [ j ] != -1 ) { total ++ ; if ( idcfgggvynvp [ i ] [ j ] == 1 ) win ++ ; } } win1 [ i ] = win ; total1 [ i ] = total ; wp [ i ] = ( long dyavxqnagqrc ) win / total ; } for ( i = 0 ; i < n ; i ++ ) { count = 0 ; wgmyybtiufxs = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( idcfgggvynvp [ i ] [ j ] != -1 ) { count ++ ; if ( idcfgggvynvp [ i ] [ j ] == 0 ) wgmyybtiufxs += ( long dyavxqnagqrc ) ( win1 [ j ] - 1 ) / ( total1 [ j ] - 1 ) ; else wgmyybtiufxs += ( long dyavxqnagqrc ) ( win1 [ j ] ) / ( total1 [ j ] - 1 ) ; } } owp [ i ] = ( long dyavxqnagqrc ) wgmyybtiufxs / count ; } for ( i = 0 ; i < n ; i ++ ) { wgmyybtiufxs = 0 ; count = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( idcfgggvynvp [ i ] [ j ] != -1 ) { count ++ ; wgmyybtiufxs += owp [ j ] ; } } oowp [ i ] = ( long dyavxqnagqrc ) wgmyybtiufxs / count ; } printf ( " \n " , f ) ; for ( i = 0 ; i < n ; i ++ ) { rpi = ( 0.25 * wp [ i ] ) + ( 0.50 * owp [ i ] ) + ( 0.25 * oowp [ i ] ) ; printf ( " \n " , rpi ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&xyilztxmqmns)
RETURN return 0; return 0;
<operator>.lessEqualsThan rwteqhaxmfrh<=xyilztxmqmns
<operator>.postIncrement rwteqhaxmfrh++
LITERAL 0 return 0;
<operator>.assignment rwteqhaxmfrh=1
scanf scanf("%d ",&c)
scanf scanf("%d ",&d)
scanf scanf("%d ",&n)
scanf scanf("%c",&in[n-1])
comput comput(rwteqhaxmfrh,c,d,n)
<operator>.lessThan j<c
<operator>.postIncrement j++
<operator>.lessThan j<d
<operator>.postIncrement j++
<operator>.lessThan j<n-1
<operator>.postIncrement j++
scanf scanf("%c ",&in[j])
<operator>.assignment j=0
scanf scanf("%c ",&combArr[j].first)
scanf scanf("%c ",&combArr[j].second)
scanf scanf("%c ",&combArr[j].third)
<operator>.assignment j=0
scanf scanf("%c ",&opposArr[j].first)
scanf scanf("%c ",&opposArr[j].second)
<operator>.assignment j=0
<operator>.subtraction n-1
<operator>.subtraction n-1
<operator>.addressOf &c
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.addressOf &in[n-1]
<operator>.addressOf &in[j]
<operator>.indirectIndexAccess in[n-1]
<operator>.addressOf &combArr[j].first
<operator>.addressOf &combArr[j].second
<operator>.addressOf &combArr[j].third
<operator>.addressOf &opposArr[j].first
<operator>.addressOf &opposArr[j].second
<operator>.indirectIndexAccess in[j]
<operator>.fieldAccess combArr[j].first
<operator>.fieldAccess combArr[j].second
<operator>.fieldAccess combArr[j].third
<operator>.fieldAccess opposArr[j].first
<operator>.fieldAccess opposArr[j].second
<operator>.indirectIndexAccess combArr[j]
FIELD_IDENTIFIER first first
<operator>.indirectIndexAccess combArr[j]
FIELD_IDENTIFIER second second
<operator>.indirectIndexAccess combArr[j]
FIELD_IDENTIFIER third third
<operator>.indirectIndexAccess opposArr[j]
FIELD_IDENTIFIER first first
<operator>.indirectIndexAccess opposArr[j]
FIELD_IDENTIFIER second second
>>>PDG&57 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->24 0->27 0->28 0->29 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->15 4->17 4->20 4->24 4->27 4->28 4->29 4->30 4->31 4->32 4->33 4->35 5->1 5->4 6->3 7->1 7->4 8->1 8->12 8->13 9->1 9->12 9->15 10->1 10->12 10->28 10->29 11->1 12->1 12->1 12->1 12->1 12->5 12->8 12->9 12->10 12->13 12->15 12->28 13->1 13->12 13->13 13->14 13->14 13->21 13->22 13->23 13->36 13->37 13->38 13->42 13->43 13->44 13->47 13->48 13->49 13->50 13->51 13->52 14->1 14->13 15->1 15->12 15->15 15->16 15->16 15->25 15->26 15->39 15->40 15->45 15->46 15->53 15->54 15->55 15->56 16->1 16->15 17->1 17->1 17->17 17->18 17->18 17->19 17->28 17->34 17->41 18->1 18->17 19->1 20->13 21->1 22->1 23->1 24->15 25->1 26->1 27->1 27->17 28->17 28->17 28->29 29->12
>>>Token int main ( ) { int xyilztxmqmns , c , d , n ; scanf ( " " , & xyilztxmqmns ) ; int rwteqhaxmfrh , j , k ; for ( rwteqhaxmfrh = 1 ; rwteqhaxmfrh <= xyilztxmqmns ; rwteqhaxmfrh ++ ) { scanf ( " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) { scanf ( " " , & combArr [ j ] . first ) ; scanf ( " " , & combArr [ j ] . second ) ; scanf ( " " , & combArr [ j ] . third ) ; } scanf ( " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) { scanf ( " " , & opposArr [ j ] . first ) ; scanf ( " " , & opposArr [ j ] . second ) ; } scanf ( " " , & n ) ; for ( j = 0 ; j < n - 1 ; j ++ ) scanf ( " " , & in [ j ] ) ; scanf ( " " , & in [ n - 1 ] ) ; comput ( rwteqhaxmfrh , c , d , n ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int goihifrzdsup
PARAM char *argv [ ]
<operator>.assignment uzhhzfbxtduo=0
printf printf("Sum is: %d\n",uzhhzfbxtduo)
RETURN return 0; return 0;
<operator>.lessThan kpdxmykydtzj<goihifrzdsup
<operator>.postIncrement kpdxmykydtzj++
<operator>.lessEqualsThan kpdxmykydtzj<=4
<operator>.postIncrement kpdxmykydtzj++
LITERAL 0 return 0;
<operator>.assignment kpdxmykydtzj=0
<operator>.assignmentPlus uzhhzfbxtduo+=kpdxmykydtzj
<operator>.assignment kpdxmykydtzj=1
<operator>.assignmentPlus uzhhzfbxtduo+=uzhhzfbxtduo
>>>PDG&16 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->7 3->1 4->1 4->5 4->13 4->15 5->1 5->1 6->1 7->1 7->1 7->7 7->8 7->8 7->13 7->13 8->1 8->7 9->1 9->1 9->9 9->10 9->10 9->15 10->1 10->9 11->6 12->1 12->7 13->1 13->5 13->15 14->1 14->9 15->1 15->5
>>>Token int main ( int goihifrzdsup , char * argv [ ] ) { int kpdxmykydtzj ; int uzhhzfbxtduo = 0 ; for ( kpdxmykydtzj = 0 ; kpdxmykydtzj < goihifrzdsup ; kpdxmykydtzj ++ ) { uzhhzfbxtduo += kpdxmykydtzj ; } for ( kpdxmykydtzj = 1 ; kpdxmykydtzj <= 4 ; kpdxmykydtzj ++ ) { uzhhzfbxtduo += uzhhzfbxtduo ; } printf ( " \n " , uzhhzfbxtduo ) ; return 0 ; }
>>>Func
METHOD rhiqyfvdyvok
METHOD_RETURN gksrlwqvabzointmax_t
PARAM long tfrrcfeodzfjval
RETURN return -simple_round_ceiling(-val); return -simple_round_ceiling(-val);
<operator>.minus -simple_round_ceiling(-val)
simple_round_ceiling simple_round_ceiling(-val)
<operator>.minus -val
>>>PDG&7 0->2 0->6 2->1 3->1 4->1 4->1 4->3 5->1 5->4 6->1 6->5
>>>Token static gksrlwqvabzointmax_t rhiqyfvdyvok ( long tfrrcfeodzfjval ) { return - simple_round_ceiling ( - val ) ; }
>>>Func
METHOD fjxuakmqbafh
METHOD_RETURN int
PARAM avlNode *node
<operator>.equals node==NULL
IDENTIFIER okwknunyuedf0 <empty>
okwknunyuedf okwknunyuedf (nodeHeight(node->left)-nodeHeight(node->right))
<operator>.subtraction nodeHeight(node->left)-nodeHeight(node->right)
nodeHeight nodeHeight(node->left)
nodeHeight nodeHeight(node->right)
<operator>.indirectFieldAccess node->left
<operator>.indirectFieldAccess node->right
FIELD_IDENTIFIER left left
FIELD_IDENTIFIER right right
>>>PDG&13 0->2 0->3 0->4 2->3 3->1 3->1 3->1 3->5 3->6 3->7 3->8 3->9 3->10 3->11 3->12 6->5 6->5 7->6 8->6
>>>Token int fjxuakmqbafh ( avlNode * node ) { if ( node == NULL ) okwknunyuedf0 ; else okwknunyuedf ( nodeHeight ( node -> left ) - nodeHeight ( node -> right ) ) ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&bbpuqezxtyvi)
RETURN return 0; return 0;
<operator>.lessEqualsThan caseno<=bbpuqezxtyvi
<operator>.postIncrement caseno++
LITERAL 0 return 0;
<operator>.assignment caseno=1
memset memset(combine 0 sizeof(combine))
memset memset(opposed 0 sizeof(opposed))
memset memset(toOppose 0 sizeof(toOppose))
scanf scanf("%d",&dqcmzufmhvlt)
scanf scanf("%d",&iD)
scanf scanf("%d",&iN)
getchar getchar()
<operator>.assignment listEnd=1
<operator>.assignment list[0]=-1
printf printf("Case #%d: [",caseno)
kfwfcwcbzmyt kfwfcwcbzmyt(listEnd>1)
printf printf("%c",list[listEnd-1])
printf printf("]\n")
<operator>.lessThan aveevdxnhhjw<dqcmzufmhvlt
<operator>.postIncrement aveevdxnhhjw++
<operator>.lessThan aveevdxnhhjw<iD
<operator>.postIncrement aveevdxnhhjw++
<operator>.lessEqualsThan aveevdxnhhjw<=iN
<operator>.postIncrement aveevdxnhhjw++
<operator>.lessThan aveevdxnhhjw<listEnd-1
<operator>.postIncrement aveevdxnhhjw++
printf printf("%c, ",list[aveevdxnhhjw])
<operator>.assignment aveevdxnhhjw=0
scanf scanf(" %c%c%c",&epjjgenocdwb,&b,&c)
<operator>.assignment combine[0][epjjgenocdwb]=b
<operator>.assignment combine[1][epjjgenocdwb]=c
<operator>.assignment combine[0][b]=epjjgenocdwb
<operator>.assignment combine[1][b]=c
<operator>.assignment aveevdxnhhjw=0
scanf scanf(" %c%c",&epjjgenocdwb,&b)
<operator>.assignment opposed[epjjgenocdwb]=b
<operator>.assignment opposed[b]=epjjgenocdwb
<operator>.minus -1
<operator>.assignment aveevdxnhhjw=1
scanf scanf("%c",&epjjgenocdwb)
kfwfcwcbzmyt kfwfcwcbzmyt(combine[0][epjjgenocdwb]==list[listEnd-1])
BLOCK <empty> <empty>
<operator>.assignment aveevdxnhhjw=1
<operator>.greaterThan listEnd>1
<operator>.postDecrement toOppose[list[listEnd-1]]--
<operator>.assignment list[listEnd-1]=combine[1][epjjgenocdwb]
<operator>.postIncrement toOppose[list[listEnd-1]]++
<operator>.subtraction listEnd-1
<operator>.subtraction listEnd-1
<operator>.equals combine[0][epjjgenocdwb]==list[listEnd-1]
<operator>.subtraction listEnd-1
<operator>.subtraction listEnd-1
<operator>.subtraction listEnd-1
<operator>.subtraction listEnd-1
UNKNOWN,),)
<operator>.sizeOf sizeof(combine)
<operator>.sizeOf sizeof(opposed)
<operator>.sizeOf sizeof(toOppose)
<operator>.addressOf &dqcmzufmhvlt
<operator>.addressOf &iD
<operator>.addressOf &iN
<operator>.indirectIndexAccess list[0]
<operator>.indirectIndexAccess list[listEnd-1]
UNKNOWN,),)
UNKNOWN else  kfwfcwcbzmyt (toOppose[opposed[epjjgenocdwb]]>0){memset(toOppose 0 sizeof(toOppose));listEnd=1;} else  kfwfcwcbzmyt (toOppose[opposed[epjjgenocdwb]]>0){memset(toOppose 0 sizeof(toOppose));listEnd=1;}
UNKNOWN else {list[listEnd++]=epjjgenocdwb;toOppose[list[listEnd-1]]++;} else {list[listEnd++]=epjjgenocdwb;toOppose[list[listEnd-1]]++;}
<operator>.indirectIndexAccess list[aveevdxnhhjw]
<operator>.addressOf &epjjgenocdwb
<operator>.addressOf &b
<operator>.addressOf &c
<operator>.indirectIndexAccess combine[0][epjjgenocdwb]
<operator>.indirectIndexAccess combine[1][epjjgenocdwb]
<operator>.indirectIndexAccess combine[0][b]
<operator>.indirectIndexAccess combine[1][b]
<operator>.addressOf &epjjgenocdwb
<operator>.addressOf &b
<operator>.indirectIndexAccess opposed[epjjgenocdwb]
<operator>.indirectIndexAccess opposed[b]
<operator>.addressOf &epjjgenocdwb
<operator>.indirectIndexAccess combine[0]
<operator>.indirectIndexAccess combine[1]
<operator>.indirectIndexAccess combine[0]
<operator>.indirectIndexAccess combine[1]
<operator>.indirectIndexAccess combine[0][epjjgenocdwb]
<operator>.indirectIndexAccess list[listEnd-1]
<operator>.indirectIndexAccess toOppose[list[listEnd-1]]
<operator>.indirectIndexAccess list[listEnd-1]
<operator>.indirectIndexAccess combine[1][epjjgenocdwb]
<operator>.indirectIndexAccess toOppose[list[listEnd-1]]
<operator>.indirectIndexAccess combine[0]
<operator>.indirectIndexAccess list[listEnd-1]
<operator>.indirectIndexAccess combine[1]
<operator>.indirectIndexAccess list[listEnd-1]
>>>PDG&96 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->50 0->51 0->53 0->54 0->55 0->56 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->17 4->18 4->19 4->20 4->21 4->23 4->25 4->27 4->30 4->36 4->40 4->41 4->45 4->46 4->50 4->51 4->57 4->58 4->59 4->60 4->61 4->62 4->63 4->64 4->65 5->1 5->4 6->3 7->1 7->4 8->1 8->1 9->1 9->1 10->1 10->1 10->47 10->49 11->1 11->21 12->1 12->23 13->1 13->25 14->1 15->1 15->50 15->53 16->1 16->1 16->1 17->1 17->5 18->1 18->1 19->1 19->1 19->52 20->1 21->1 21->1 21->11 21->21 21->22 21->22 21->31 21->32 21->33 21->34 21->35 21->70 21->71 21->72 21->73 21->74 21->75 21->76 21->82 21->83 21->84 21->85 22->1 22->21 23->1 23->1 23->12 23->23 23->24 23->24 23->37 23->38 23->39 23->77 23->78 23->79 23->80 24->1 24->23 25->1 25->1 25->13 25->25 25->26 25->26 25->42 25->43 25->47 25->48 25->49 25->52 25->53 25->54 25->55 25->56 25->66 25->67 25->68 25->81 25->86 25->87 25->88 25->89 25->90 25->91 25->92 25->93 25->94 25->95 26->1 26->25 27->1 27->1 27->27 27->28 27->28 27->29 27->50 27->69 28->1 28->27 29->1 29->1 30->21 31->1 31->1 31->1 31->34 31->37 31->39 31->42 32->1 32->1 32->1 32->52 33->1 33->1 33->48 34->1 34->1 34->1 35->1 35->1 35->1 36->1 36->23 37->1 37->1 37->31 37->34 37->39 37->42 38->1 38->1 38->1 38->9 39->1 39->1 39->1 39->9 40->16 41->25 42->1 42->31 42->34 42->37 42->39 43->1 43->1 45->1 45->27 46->18 46->18 46->51 47->1 47->49 48->1 48->1 48->19 48->52 49->1 49->1 49->10 49->47 50->27 50->27 50->46 51->1 52->1 52->43 52->43 53->55 54->56 55->54 56->50 56->53
>>>Token int main ( ) { int bbpuqezxtyvi , caseno ; int aveevdxnhhjw , listEnd ; char epjjgenocdwb , b , c ; int dqcmzufmhvlt , iD , iN ; scanf ( " " , & bbpuqezxtyvi ) ; for ( caseno = 1 ; caseno <= bbpuqezxtyvi ; caseno ++ ) { memset ( combine , 0 , sizeof ( combine ) ) ; memset ( opposed , 0 , sizeof ( opposed ) ) ; memset ( toOppose , 0 , sizeof ( toOppose ) ) ; scanf ( " " , & dqcmzufmhvlt ) ; for ( aveevdxnhhjw = 0 ; aveevdxnhhjw < dqcmzufmhvlt ; aveevdxnhhjw ++ ) { scanf ( " " , & epjjgenocdwb , & b , & c ) ; combine [ 0 ] [ epjjgenocdwb ] = b ; combine [ 1 ] [ epjjgenocdwb ] = c ; combine [ 0 ] [ b ] = epjjgenocdwb ; combine [ 1 ] [ b ] = c ; } scanf ( " " , & iD ) ; for ( aveevdxnhhjw = 0 ; aveevdxnhhjw < iD ; aveevdxnhhjw ++ ) { scanf ( " " , & epjjgenocdwb , & b ) ; opposed [ epjjgenocdwb ] = b ; opposed [ b ] = epjjgenocdwb ; } scanf ( " " , & iN ) ; getchar ( ) ; listEnd = 1 ; list [ 0 ] = -1 ; for ( aveevdxnhhjw = 1 ; aveevdxnhhjw <= iN ; aveevdxnhhjw ++ ) { scanf ( " " , & epjjgenocdwb ) ; kfwfcwcbzmyt ( combine [ 0 ] [ epjjgenocdwb ] == list [ listEnd - 1 ] )  { toOppose [ list [ listEnd - 1 ] ] -- ; list [ listEnd - 1 ] = combine [ 1 ] [ epjjgenocdwb ] ; toOppose [ list [ listEnd - 1 ] ] ++ ; } else kfwfcwcbzmyt ( toOppose [ opposed [ epjjgenocdwb ] ] > 0 ) { memset ( toOppose , 0 , sizeof ( toOppose ) ) ; listEnd = 1 ; } else { list [ listEnd ++ ] = epjjgenocdwb ; toOppose [ list [ listEnd - 1 ] ] ++ ; } } printf ( " " , caseno ) ; for ( aveevdxnhhjw = 1 ; aveevdxnhhjw < listEnd - 1 ; aveevdxnhhjw ++ ) printf ( " " , list [ aveevdxnhhjw ] ) ; kfwfcwcbzmyt ( listEnd > 1 )  printf ( " " , list [ listEnd - 1 ] ) ; printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD dayaptjhirmt
METHOD_RETURN int
PARAM char phpxfbtpchnm
<operator>.assignment hfgundyszqja=0
<operator>.assignment xlmouvwtkqrz=list_index
RETURN return -1; return -1;
<operator>.lessThan hfgundyszqja<num_opps
<operator>.minus -1
<operator>.postIncrement hfgundyszqja++
<operator>.assignment xlmouvwtkqrz=list_index
<operator>.equals oppositions[hfgundyszqja][0]==phpxfbtpchnm
<operator>.greaterEqualsThan xlmouvwtkqrz>=0
<operator>.postDecrement xlmouvwtkqrz--
<operator>.equals oppositions[hfgundyszqja][1]==phpxfbtpchnm
<operator>.equals element_list[xlmouvwtkqrz]==oppositions[hfgundyszqja][1]
RETURN return  xlmouvwtkqrz; return  xlmouvwtkqrz;
<operator>.greaterEqualsThan xlmouvwtkqrz>=0
IDENTIFIER xlmouvwtkqrz return  xlmouvwtkqrz;
<operator>.postDecrement xlmouvwtkqrz--
<operator>.equals element_list[xlmouvwtkqrz]==oppositions[hfgundyszqja][0]
RETURN return  xlmouvwtkqrz; return  xlmouvwtkqrz;
IDENTIFIER xlmouvwtkqrz return  xlmouvwtkqrz;
<operator>.indirectIndexAccess oppositions[hfgundyszqja][0]
<operator>.indirectIndexAccess oppositions[hfgundyszqja]
<operator>.indirectIndexAccess oppositions[hfgundyszqja][1]
<operator>.indirectIndexAccess element_list[xlmouvwtkqrz]
<operator>.indirectIndexAccess oppositions[hfgundyszqja][1]
<operator>.indirectIndexAccess oppositions[hfgundyszqja]
<operator>.indirectIndexAccess oppositions[hfgundyszqja]
<operator>.indirectIndexAccess element_list[xlmouvwtkqrz]
<operator>.indirectIndexAccess oppositions[hfgundyszqja][0]
<operator>.indirectIndexAccess oppositions[hfgundyszqja]
>>>PDG&32 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->16 0->17 0->18 0->21 2->10 3->1 3->6 4->1 4->1 4->11 4->16 5->1 6->1 6->1 6->1 6->5 6->7 6->8 6->10 6->22 6->23 7->5 8->1 8->6 9->1 9->1 9->11 9->16 10->1 10->1 10->1 10->11 10->13 10->13 10->19 10->24 10->27 11->1 11->1 11->6 11->8 11->9 11->12 11->14 11->17 11->25 11->26 11->28 12->1 12->11 13->1 13->6 13->8 13->9 13->10 13->14 13->16 14->1 14->1 14->1 14->11 14->12 14->13 14->15 14->19 15->1 16->6 16->8 16->9 16->18 16->19 16->21 16->29 16->30 16->31 17->15 18->1 18->16 19->1 19->10 19->14 19->16 19->18 19->20 20->1 21->20
>>>Token int dayaptjhirmt ( char phpxfbtpchnm ) { int hfgundyszqja = 0 ; int xlmouvwtkqrz = list_index ; while ( hfgundyszqja < num_opps ) { if ( oppositions [ hfgundyszqja ] [ 0 ] == phpxfbtpchnm ) { while ( xlmouvwtkqrz >= 0 ) { if ( element_list [ xlmouvwtkqrz ] == oppositions [ hfgundyszqja ] [ 1 ] ) return xlmouvwtkqrz ; xlmouvwtkqrz -- ; } } else { if ( oppositions [ hfgundyszqja ] [ 1 ] == phpxfbtpchnm ) { while ( xlmouvwtkqrz >= 0 ) { if ( element_list [ xlmouvwtkqrz ] == oppositions [ hfgundyszqja ] [ 0 ] ) { return xlmouvwtkqrz ; } xlmouvwtkqrz -- ; } } } hfgundyszqja ++ ; xlmouvwtkqrz = list_index ; } return -1 ; }
>>>Func
METHOD xkavayihjcfl
METHOD_RETURN int
PARAM Graph wqbwsmrwgeeh
PARAM int duvptgzsjini
PARAM Vertex toxtfsqbxdlk
<operator>.assignment dzyfynxwqvai=0
RETURN return dzyfynxwqvai; return dzyfynxwqvai;
<operator>.lessThan deuzlbjlxais<duvptgzsjini
<operator>.postIncrement deuzlbjlxais++
IDENTIFIER dzyfynxwqvai return dzyfynxwqvai;
<operator>.assignment deuzlbjlxais=0
adjacent adjacent(wqbwsmrwgeeh,toxtfsqbxdlk,deuzlbjlxais)
<operator>.postIncrement dzyfynxwqvai++
>>>PDG&13 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 2->1 2->11 3->7 4->1 4->11 5->1 5->1 5->9 5->12 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->11 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->1 11->8 11->12 12->1 12->1 12->9
>>>Token int xkavayihjcfl ( Graph wqbwsmrwgeeh , int duvptgzsjini , Vertex toxtfsqbxdlk ) { int dzyfynxwqvai = 0 ; Vertex deuzlbjlxais ; for ( deuzlbjlxais = 0 ; deuzlbjlxais < duvptgzsjini ; deuzlbjlxais ++ ) if ( adjacent ( wqbwsmrwgeeh , toxtfsqbxdlk , deuzlbjlxais ) ) dzyfynxwqvai ++ ; return dzyfynxwqvai ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int donuxyqyuqbx
PARAM const bthigtwccjoc*argv [ ]
scanf scanf("%s",eodgxrrrpbaa)
strcpy strcpy(bchgnwkyfsxy,eodgxrrrpbaa)
strcpy strcpy(outfile,eodgxrrrpbaa)
strcat strcat(bchgnwkyfsxy,".in")
strcat strcat(outfile,".out")
<operator>.assignment *fp=fopen(bchgnwkyfsxy,"r")
<operator>.assignment *ofp=fopen(outfile,"w")
fscanf fscanf(fp,"%d",&T)
RETURN return 0; return 0;
<operator>.lessEqualsThan i<=T
<operator>.postIncrement i++
LITERAL 0 return 0;
fopen fopen(bchgnwkyfsxy,"r")
fopen fopen(outfile,"w")
<operator>.assignment i=1
fscanf fscanf(fp,"%d",&N)
memset memset(in 0 sizeof(in))
memset memset(OWP 0 sizeof(OWP))
memset memset(OOWP 0 sizeof(OOWP))
fprintf fprintf(ofp,"Case #%d:\n",i)
<operator>.lessEqualsThan j<=N
<operator>.postIncrement j++
<operator>.lessEqualsThan j<=N
<operator>.postIncrement j++
<operator>.lessEqualsThan j<=N
<operator>.postIncrement j++
<operator>.lessEqualsThan j<=N
<operator>.postIncrement j++
<operator>.assignment j=1
<operator>.assignment n_cnt=0
<operator>.assignment w_cnt=0
<operator>.assignment l_cnt=0
fscanf fscanf(fp,"%s",&L[1])
<operator>.assignment in[j][N+1]=n_cnt
<operator>.assignment in[j][N+2]=w_cnt
<operator>.assignment in[j][N+3]=l_cnt
<operator>.assignment WP[j]=w_cnt *1.0/(w_cnt+l_cnt)
<operator>.assignment j=1
<operator>.assignment ohznsemyxlkl=0
<operator>.assignment OWP[j]=OWP[j]*1.0/ohznsemyxlkl
<operator>.assignment j=1
<operator>.assignment vsjrcnvpawlk=0
<operator>.assignment OOWP[j]=OOWP[j]*1.0/vsjrcnvpawlk
<operator>.assignment j=1
<operator>.assignment RPI=0.25 *WP[j]+0.5 *OWP[j]+0.25 *OOWP[j]
fprintf fprintf(ofp,"%f\n",RPI)
<operator>.lessEqualsThan k<=N
<operator>.postIncrement k++
<operator>.lessEqualsThan k<=N
<operator>.postIncrement k++
<operator>.lessEqualsThan k<=N
<operator>.postIncrement k++
<operator>.assignment k=1
vkiawrlyvgfx vkiawrlyvgfx((L[k]-'.')==0)
BLOCK <empty> <empty>
<operator>.division w_cnt *1.0/(w_cnt+l_cnt)
<operator>.assignment k=1
vkiawrlyvgfx vkiawrlyvgfx(in[j][k]>=0)
BLOCK <empty> <empty>
<operator>.division OWP[j]*1.0/ohznsemyxlkl
<operator>.assignment k=1
vkiawrlyvgfx vkiawrlyvgfx(in[j][k]>=0)
BLOCK <empty> <empty>
<operator>.division OOWP[j]*1.0/vsjrcnvpawlk
<operator>.addition 0.25 *WP[j]+0.5 *OWP[j]+0.25 *OOWP[j]
<operator>.assignment in[j][k]=-1
<operator>.postIncrement n_cnt++
<operator>.addition N+1
<operator>.addition N+2
<operator>.addition N+3
<operator>.multiplication w_cnt *1.0
<operator>.addition w_cnt+l_cnt
<operator>.assignment n_cnt=in[k][N+1]
<operator>.assignment w_cnt=in[k][N+2]
<operator>.assignment l_cnt=in[k][N+3]
vkiawrlyvgfx vkiawrlyvgfx(in[k][j]<0)
BLOCK <empty> <empty>
<operator>.multiplication OWP[j]*1.0
<operator>.postIncrement vsjrcnvpawlk++
<operator>.assignmentPlus OOWP[j]+=OWP[k]
<operator>.multiplication OOWP[j]*1.0
<operator>.addition 0.25 *WP[j]+0.5 *OWP[j]
<operator>.multiplication 0.25 *OOWP[j]
<operator>.equals (L[k]-'.')==0
<operator>.greaterEqualsThan in[j][k]>=0
<operator>.assignmentPlus OWP[j]+=(w_cnt *1.0/(w_cnt+l_cnt))
<operator>.greaterEqualsThan in[j][k]>=0
<operator>.multiplication 0.25 *WP[j]
<operator>.multiplication 0.5 *OWP[j]
<operator>.subtraction L[k]-'.'
<operator>.minus -1
<operator>.lessThan in[k][j]<0
<operator>.addition N+1
<operator>.addition N+2
<operator>.addition N+3
<operator>.division w_cnt *1.0/(w_cnt+l_cnt)
<operator>.multiplication w_cnt *1.0
<operator>.addition w_cnt+l_cnt
<operator>.addressOf &N
<operator>.sizeOf sizeof(in)
<operator>.sizeOf sizeof(OWP)
<operator>.sizeOf sizeof(OOWP)
<operator>.addressOf &L[1]
<operator>.indirectIndexAccess in[j][N+1]
<operator>.indirectIndexAccess in[j][N+2]
<operator>.indirectIndexAccess in[j][N+3]
<operator>.indirectIndexAccess WP[j]
<operator>.indirectIndexAccess OWP[j]
<operator>.indirectIndexAccess OOWP[j]
<operator>.indirectIndexAccess L[1]
UNKNOWN,),)
UNKNOWN else   {in[j][k]=L[k]-'0';vkiawrlyvgfx(in[j][k]==0){l_cnt++;}else   {w_cnt++;}} else   {in[j][k]=L[k]-'0';vkiawrlyvgfx(in[j][k]==0){l_cnt++;}else   {w_cnt++;}}
<operator>.indirectIndexAccess in[j]
<operator>.indirectIndexAccess in[j]
<operator>.indirectIndexAccess in[j]
UNKNOWN,),)
UNKNOWN,),)
UNKNOWN,),)
UNKNOWN else   vkiawrlyvgfx(in[k][j]==0){l_cnt--;OWP[j]+=(w_cnt *1.0/(w_cnt+l_cnt));ohznsemyxlkl++;} else   vkiawrlyvgfx(in[k][j]==0){l_cnt--;OWP[j]+=(w_cnt *1.0/(w_cnt+l_cnt));ohznsemyxlkl++;}
UNKNOWN else   {w_cnt--;OWP[j]+=(w_cnt *1.0/(w_cnt+l_cnt));ohznsemyxlkl++;} else   {w_cnt--;OWP[j]+=(w_cnt *1.0/(w_cnt+l_cnt));ohznsemyxlkl++;}
<operator>.indirectIndexAccess OWP[j]
<operator>.indirectIndexAccess OOWP[j]
<operator>.indirectIndexAccess OOWP[j]
<operator>.indirectIndexAccess in[j][k]
<operator>.indirectIndexAccess in[j][k]
<operator>.indirectIndexAccess in[k][N+1]
<operator>.indirectIndexAccess in[k][N+2]
<operator>.indirectIndexAccess in[k][N+3]
<operator>.indirectIndexAccess in[j][k]
<operator>.indirectIndexAccess OOWP[j]
<operator>.indirectIndexAccess OWP[k]
<operator>.indirectIndexAccess WP[j]
<operator>.indirectIndexAccess OWP[j]
<operator>.indirectIndexAccess L[k]
<operator>.indirectIndexAccess in[j]
<operator>.indirectIndexAccess in[j]
<operator>.indirectIndexAccess in[k]
<operator>.indirectIndexAccess in[k]
<operator>.indirectIndexAccess in[k]
<operator>.indirectIndexAccess in[k][j]
<operator>.indirectIndexAccess OWP[j]
<operator>.indirectIndexAccess in[j]
<operator>.indirectIndexAccess in[k]
>>>PDG&147 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->41 0->42 0->44 0->45 0->47 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->58 0->59 0->60 0->62 0->63 0->64 0->66 0->67 0->70 0->71 0->72 0->73 0->74 0->75 0->80 0->81 0->82 0->84 0->86 0->87 0->88 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 2->1 3->1 4->5 5->1 5->6 5->7 6->1 6->1 6->8 7->1 7->16 8->1 8->17 9->1 9->1 9->11 10->1 10->1 10->1 10->23 11->1 11->1 11->1 11->13 11->19 12->1 13->1 13->1 13->1 13->13 13->14 13->19 13->20 13->21 13->22 13->23 13->23 13->24 13->26 13->28 13->30 13->32 13->41 13->44 13->47 13->102 13->103 13->104 13->105 14->1 14->13 15->12 16->1 16->9 16->9 17->1 17->10 17->10 18->1 18->13 19->1 19->1 19->1 19->24 19->26 19->28 19->30 19->36 19->50 19->52 19->54 19->71 19->72 19->73 19->96 19->97 19->98 20->1 20->1 21->1 21->1 21->81 21->83 21->89 21->92 22->1 22->1 22->83 22->84 22->86 23->1 23->1 23->14 23->49 24->24 24->25 24->25 24->26 24->33 24->34 24->35 24->36 24->37 24->38 24->39 24->40 24->50 24->50 24->56 24->59 24->71 24->72 24->73 24->74 24->75 24->106 24->107 24->108 24->109 24->110 24->113 24->116 24->117 24->118 25->1 25->24 26->26 26->27 26->27 26->28 26->42 26->43 26->52 26->52 26->60 26->63 26->81 26->111 26->124 27->1 27->26 28->28 28->29 28->29 28->30 28->45 28->46 28->54 28->54 28->64 28->67 28->84 28->112 28->125 29->1 29->28 30->1 30->1 30->1 30->19 30->24 30->30 30->31 30->31 30->48 30->49 30->68 30->85 30->86 30->91 30->92 30->126 30->135 30->136 31->1 31->30 32->24 33->1 33->37 33->70 34->1 34->38 34->74 35->1 35->39 35->59 35->75 36->1 36->1 36->1 36->19 37->1 37->1 37->1 38->1 38->1 39->1 39->1 40->1 40->1 40->1 40->91 41->26 42->1 42->63 43->1 43->1 43->1 43->21 43->81 43->89 43->92 44->28 45->1 45->67 45->82 46->1 46->1 46->1 46->22 46->83 46->84 46->86 47->1 47->30 48->1 48->1 48->49 49->1 49->1 49->1 49->23 50->1 50->1 50->24 50->50 50->51 50->51 50->57 50->69 50->70 50->71 50->72 50->73 50->87 50->93 50->94 50->114 50->115 50->127 50->137 50->138 51->1 51->50 52->1 52->1 52->26 52->52 52->53 52->53 52->61 52->76 52->77 52->78 52->79 52->88 52->89 52->95 52->96 52->96 52->97 52->97 52->98 52->98 52->99 52->100 52->101 52->119 52->121 52->122 52->123 52->128 52->129 52->130 52->131 52->139 52->140 52->141 52->142 52->143 52->144 52->146 53->1 53->52 54->1 54->1 54->28 54->54 54->55 54->55 54->65 54->82 54->83 54->90 54->120 54->132 54->133 54->134 54->145 55->1 55->54 56->1 56->50 57->1 57->1 59->1 59->1 59->40 59->40 60->1 60->52 61->1 61->1 63->1 63->1 63->43 63->43 64->1 64->54 65->1 65->1 67->1 67->1 67->46 67->46 68->1 68->1 69->1 69->1 69->1 69->88 69->90 70->1 70->37 74->59 74->59 74->75 75->1 75->1 76->1 76->1 76->1 77->1 77->1 77->100 78->1 78->1 78->99 78->101 79->1 79->1 81->63 81->63 82->1 82->67 83->1 83->1 83->84 84->67 84->67 85->1 85->1 86->1 86->22 86->48 86->48 86->68 86->68 86->83 86->84 87->1 87->57 87->57 88->1 88->61 88->61 88->90 89->1 89->1 89->81 90->1 90->65 90->65 90->88 91->1 91->48 91->48 91->68 91->68 91->85 91->85 92->1 92->21 92->48 92->48 92->68 92->68 92->81 92->85 92->85 92->89 93->1 93->87 93->87 94->69 95->1 95->79 95->79 99->1 99->1 99->89 99->89 100->99 100->99 100->101 101->1 101->1
>>>Token int main ( int donuxyqyuqbx , const bthigtwccjoc * argv [ ] ) { bthigtwccjoc eodgxrrrpbaa [ 32 ] ; bthigtwccjoc bchgnwkyfsxy [ 32 ] , outfile [ 32 ] ; scanf ( " " , eodgxrrrpbaa ) ; strcpy ( bchgnwkyfsxy , eodgxrrrpbaa ) ; strcpy ( outfile , eodgxrrrpbaa ) ; strcat ( bchgnwkyfsxy , " " ) ; strcat ( outfile , " " ) ; FILE * fp = fopen ( bchgnwkyfsxy , " " ) , * ofp = fopen ( outfile , " " ) ; fscanf ( fp , " " , & T ) ; for ( i = 1 ; i <= T ; i ++ ) { fscanf ( fp , " " , & N ) ; memset ( in , 0 , sizeof ( in ) ) ; for ( j = 1 ; j <= N ; j ++ ) { n_cnt = 0 ; w_cnt = 0 ; l_cnt = 0 ; fscanf ( fp , " " , & L [ 1 ] ) ; for ( k = 1 ; k <= N ; k ++ ) { vkiawrlyvgfx ( ( L [ k ] - ' ' ) == 0 )  { in [ j ] [ k ] = -1 ; n_cnt ++ ; } else { in [ j ] [ k ] = L [ k ] - ' ' ; vkiawrlyvgfx ( in [ j ] [ k ] == 0 )  { l_cnt ++ ; } else  { w_cnt ++ ; } } } in [ j ] [ N + 1 ] = n_cnt ; in [ j ] [ N + 2 ] = w_cnt ; in [ j ] [ N + 3 ] = l_cnt ; WP [ j ] = w_cnt * 1.0 / ( w_cnt + l_cnt ) ; } memset ( OWP , 0 , sizeof ( OWP ) ) ; for ( j = 1 ; j <= N ; j ++ ) { int ohznsemyxlkl = 0 ; for ( k = 1 ; k <= N ; k ++ ) { vkiawrlyvgfx ( in [ j ] [ k ] >= 0 )  { n_cnt = in [ k ] [ N + 1 ] ; w_cnt = in [ k ] [ N + 2 ] ; l_cnt = in [ k ] [ N + 3 ] ; vkiawrlyvgfx ( in [ k ] [ j ] < 0 )  { OWP [ j ] += ( w_cnt * 1.0 / ( w_cnt + l_cnt ) ) ; } else vkiawrlyvgfx ( in [ k ] [ j ] = = 0 ) { l_cnt -- ; OWP [ j ] += ( w_cnt * 1.0 / ( w_cnt + l_cnt ) ) ; ohznsemyxlkl ++ ; } else  { w_cnt -- ; OWP [ j ] += ( w_cnt * 1.0 / ( w_cnt + l_cnt ) ) ; ohznsemyxlkl ++ ; } } } OWP [ j ] = OWP [ j ] * 1.0 / ohznsemyxlkl ; } memset ( OOWP , 0 , sizeof ( OOWP ) ) ; for ( j = 1 ; j <= N ; j ++ ) { int vsjrcnvpawlk = 0 ; for ( k = 1 ; k <= N ; k ++ ) { vkiawrlyvgfx ( in [ j ] [ k ] >= 0 )  { vsjrcnvpawlk ++ ; OOWP [ j ] += OWP [ k ] ; } } OOWP [ j ] = OOWP [ j ] * 1.0 / vsjrcnvpawlk ; } fprintf ( ofp , " \n " , i ) ; for ( j = 1 ; j <= N ; j ++ ) { RPI = 0.25 * WP [ j ] + 0.5 * OWP [ j ] + 0.25 * OOWP [ j ] ; fprintf ( ofp , " \n " , RPI ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment eoismoqoydxu=1
scanf scanf("%d",&T)
RETURN return 0; return 0;
<operator>.lessEqualsThan eoismoqoydxu<=T
LITERAL 0 return 0;
init init()
scanf scanf("%d",&C)
scanf scanf("%d ",&D)
<operator>.assignment j=0
scanf scanf("%d %s",&N,input)
printf printf("Case #%d: [",eoismoqoydxu)
printf printf("]\n")
<operator>.postIncrement eoismoqoydxu++
<operator>.lessThan i<C
<operator>.postIncrement i++
<operator>.lessThan i<D
<operator>.postIncrement i++
<operator>.logicalAnd C==0&&D==0
<operator>.lessThan i<fi
<operator>.postIncrement i++
<operator>.assignment i=0
scanf scanf("%s ",mzscuswwkjvj)
<operator>.assignment combine[mzscuswwkjvj[0]][0]=mzscuswwkjvj[1]
<operator>.assignment combine[mzscuswwkjvj[0]][1]=mzscuswwkjvj[2]
<operator>.assignment combine[mzscuswwkjvj[0]][2]='\0'
<operator>.assignment combine[mzscuswwkjvj[1]][0]=mzscuswwkjvj[0]
<operator>.assignment combine[mzscuswwkjvj[1]][1]=mzscuswwkjvj[2]
<operator>.assignment combine[mzscuswwkjvj[1]][2]='\0'
<operator>.assignment i=0
scanf scanf("%s ",oppose_temp)
<operator>.postIncrement j++
<operator>.assignment oppose[oppose_temp[0]][0]=oppose_temp[1]
<operator>.assignment oppose[oppose_temp[0]][1]='\0'
<operator>.assignment oppose[oppose_temp[1]][0]=oppose_temp[0]
<operator>.assignment oppose[oppose_temp[1]][1]='\0'
<operator>.assignment i=0
printf printf("%c",final[i])
<operator>.equals C==0
<operator>.equals D==0
<operator>.lessThan fi<N
<operator>.postIncrement fi++
<operator>.assignment final[fi]=input[fi]
<operator>.assignment fi=0
<operator>.assignment ret=0
<operator>.assignment final[fi++]=input[0]
<operator>.notEquals i!=fi-1
<operator>.assignment fi=0
<operator>.lessThan i<N
<operator>.postIncrement i++
printf printf(", ")
<operator>.assignment i=1
<operator>.assignment final[fi++]=input[i]
<operator>.assignment ret=1
<operator>.subtraction fi-1
<operator>.postIncrement fi++
<operator>.logicalAnd ret&&fi>0
<operator>.assignment ret=check_combine()
<operator>.greaterThan fi>0
check_oppose check_oppose()
<operator>.postIncrement fi++
<operator>.greaterThan fi>0
<operator>.addressOf &C
<operator>.addressOf &D
<operator>.addressOf &N
<operator>.indirectIndexAccess combine[mzscuswwkjvj[0]][0]
<operator>.indirectIndexAccess mzscuswwkjvj[1]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[0]][1]
<operator>.indirectIndexAccess mzscuswwkjvj[2]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[0]][2]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[1]][0]
<operator>.indirectIndexAccess mzscuswwkjvj[0]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[1]][1]
<operator>.indirectIndexAccess mzscuswwkjvj[2]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[1]][2]
<operator>.indirectIndexAccess oppose[oppose_temp[0]][0]
<operator>.indirectIndexAccess oppose_temp[1]
<operator>.indirectIndexAccess oppose[oppose_temp[0]][1]
<operator>.indirectIndexAccess oppose[oppose_temp[1]][0]
<operator>.indirectIndexAccess oppose_temp[0]
<operator>.indirectIndexAccess oppose[oppose_temp[1]][1]
<operator>.indirectIndexAccess final[i]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[0]]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[0]]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[0]]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[1]]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[1]]
<operator>.indirectIndexAccess combine[mzscuswwkjvj[1]]
<operator>.indirectIndexAccess oppose[oppose_temp[0]]
<operator>.indirectIndexAccess oppose[oppose_temp[0]]
<operator>.indirectIndexAccess oppose[oppose_temp[1]]
<operator>.indirectIndexAccess oppose[oppose_temp[1]]
<operator>.indirectIndexAccess final[fi]
<operator>.indirectIndexAccess input[fi]
<operator>.indirectIndexAccess final[fi++]
<operator>.indirectIndexAccess input[0]
<operator>.indirectIndexAccess mzscuswwkjvj[0]
<operator>.indirectIndexAccess mzscuswwkjvj[0]
<operator>.indirectIndexAccess mzscuswwkjvj[0]
<operator>.indirectIndexAccess mzscuswwkjvj[1]
<operator>.indirectIndexAccess mzscuswwkjvj[1]
<operator>.indirectIndexAccess mzscuswwkjvj[1]
<operator>.indirectIndexAccess oppose_temp[0]
<operator>.indirectIndexAccess oppose_temp[0]
<operator>.indirectIndexAccess oppose_temp[1]
<operator>.indirectIndexAccess oppose_temp[1]
<operator>.indirectIndexAccess final[fi++]
<operator>.indirectIndexAccess input[i]
check_combine check_combine()
>>>PDG&110 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->21 0->22 0->23 0->26 0->29 0->30 0->31 0->32 0->34 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->47 0->48 0->49 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 2->1 2->5 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->7 5->8 5->9 5->10 5->11 5->12 5->12 5->13 5->14 5->15 5->17 5->19 5->20 5->22 5->30 5->37 5->39 5->63 5->64 5->65 6->4 7->1 8->1 8->15 8->39 9->1 9->17 9->40 10->1 10->1 10->32 11->1 11->1 11->41 11->49 12->1 12->14 13->1 14->1 14->5 15->1 15->15 15->16 15->16 15->23 15->24 15->25 15->26 15->27 15->28 15->29 15->39 15->66 15->67 15->68 15->69 15->70 15->71 15->72 15->73 15->74 15->75 15->83 15->84 15->85 15->86 15->87 15->88 15->97 15->98 15->99 15->100 15->101 15->102 16->1 16->15 17->1 17->1 17->9 17->17 17->18 17->18 17->31 17->32 17->33 17->34 17->35 17->36 17->40 17->76 17->77 17->78 17->79 17->80 17->81 17->89 17->90 17->91 17->92 17->103 17->104 17->105 17->106 18->1 18->17 19->1 19->1 19->1 19->41 19->44 19->45 19->46 19->48 19->49 19->52 19->56 19->95 19->96 20->1 20->1 20->1 20->20 20->21 20->38 20->47 20->47 20->55 20->55 20->82 21->1 21->20 22->15 23->1 23->24 23->25 23->27 23->28 24->1 24->1 24->1 25->1 25->1 26->1 26->1 27->1 27->1 27->1 28->1 28->1 28->1 29->1 29->1 30->17 31->1 31->33 31->35 32->1 32->1 33->1 33->1 33->1 34->1 34->1 35->1 35->1 35->1 36->1 36->1 37->1 37->20 38->1 38->1 39->1 39->8 39->15 39->19 39->19 39->40 40->1 40->9 40->17 40->19 40->19 41->1 41->1 41->11 41->20 41->41 41->42 41->42 41->43 41->49 41->93 41->94 42->1 42->41 43->1 43->1 43->1 44->1 44->56 45->1 45->1 46->1 46->1 46->1 47->1 47->1 47->21 47->51 48->1 48->41 49->1 49->1 49->11 49->41 49->49 49->50 49->50 49->53 49->54 49->57 49->59 49->61 49->62 49->107 49->108 50->1 50->49 51->1 52->1 52->49 53->1 53->1 53->1 54->1 54->57 55->20 55->47 55->47 56->20 56->61 57->1 57->1 57->57 57->58 57->62 57->109 58->1 58->1 58->57 59->1 59->20 59->57 59->60 59->61 60->1 61->59 61->62 62->57 62->57 62->59
>>>Token int main ( ) { int eoismoqoydxu = 1 , i , ret , j , k ; char mzscuswwkjvj [ 4 ] , oppose_temp [ 3 ] , input [ MAX ] ; char ftdrmtvhxtsn [ MAX ] ; scanf ( " " , & T ) ; while ( eoismoqoydxu <= T ) { init ( ) ; scanf ( " " , & C ) ; for ( i = 0 ; i < C ; i ++ ) { scanf ( " " , mzscuswwkjvj ) ; combine [ mzscuswwkjvj [ 0 ] ] [ 0 ] = mzscuswwkjvj [ 1 ] ; combine [ mzscuswwkjvj [ 0 ] ] [ 1 ] = mzscuswwkjvj [ 2 ] ; combine [ mzscuswwkjvj [ 0 ] ] [ 2 ] = ' \0 ' ; combine [ mzscuswwkjvj [ 1 ] ] [ 0 ] = mzscuswwkjvj [ 0 ] ; combine [ mzscuswwkjvj [ 1 ] ] [ 1 ] = mzscuswwkjvj [ 2 ] ; combine [ mzscuswwkjvj [ 1 ] ] [ 2 ] = ' \0 ' ; } scanf ( " " , & D ) ; j = 0 ; for ( i = 0 ; i < D ; i ++ ) { scanf ( " " , oppose_temp ) ; j ++ ; oppose [ oppose_temp [ 0 ] ] [ 0 ] = oppose_temp [ 1 ] ; oppose [ oppose_temp [ 0 ] ] [ 1 ] = ' \0 ' ; oppose [ oppose_temp [ 1 ] ] [ 0 ] = oppose_temp [ 0 ] ; oppose [ oppose_temp [ 1 ] ] [ 1 ] = ' \0 ' ; } scanf ( " " , & N , input ) ; if ( C == 0 && D == 0 ) { for ( fi = 0 ; fi < N ; fi ++ ) final [ fi ] = input [ fi ] ; } else { fi = 0 ; ret = 0 ; final [ fi ++ ] = input [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { final [ fi ++ ] = input [ i ] ; ret = 1 ; while ( ret && fi > 0 ) ret = check_combine ( ) ; if ( fi > 0 ) check_oppose ( ) ; } } printf ( " " , eoismoqoydxu ) ; for ( i = 0 ; i < fi ; i ++ ) { printf ( " " , final [ i ] ) ; if ( i != fi - 1 ) printf ( " " ) ; } printf ( " \n " ) ; eoismoqoydxu ++ ; } return 0 ; }
>>>Func
METHOD sobtcvvegljs
METHOD_RETURN void
PARAM Node **pHead
PARAM Node **pTail
<operator>.logicalOr NULL==pHead||NULL==pTail
<operator>.notEquals NodeCount!=0
DeleteLastNode DeleteLastNode(pHead,pTail)
RETURN return ; return ;
<operator>.equals NULL==pHead
<operator>.equals NULL==pTail
>>>PDG&10 0->2 0->3 0->5 0->6 0->7 0->8 0->9 2->8 3->1 3->6 3->9 4->1 4->1 4->1 4->5 4->7 5->1 5->5 5->6 7->1 8->1 8->1 8->4 8->4 8->6 8->9 8->9 9->1 9->1 9->4 9->4 9->6
>>>Token void sobtcvvegljs ( Node * * pHead , Node * * pTail ) { if ( NULL == pHead || NULL == pTail ) return ; while ( NodeCount != 0 ) DeleteLastNode ( pHead , pTail ) ; }
>>>Func
METHOD jvkukpoculbf
METHOD_RETURN int
PARAM int *nums
PARAM int gwllcweitwzp
<operator>.assignment yzduzeewaidg=0
qsort qsort(nums gwllcweitwzp sizeof(int),cmpval)
RETURN return yzduzeewaidg; return yzduzeewaidg;
<operator>.lessThan i<gwllcweitwzp
<operator>.assignment i=i+2
<operator>.assignment yzduzeewaidg=yzduzeewaidg+nums[i]
IDENTIFIER yzduzeewaidg return yzduzeewaidg;
<operator>.sizeOf sizeof(int)
<operator>.assignment i=0
<operator>.addition i+2
<operator>.addition yzduzeewaidg+nums[i]
<operator>.indirectIndexAccess nums[i]
>>>PDG&16 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->12 0->13 0->14 2->5 3->5 4->1 4->1 4->9 4->10 4->14 5->1 5->1 5->1 5->7 5->9 5->14 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->9 7->13 7->13 7->14 7->15 8->1 8->1 8->7 9->1 9->1 9->1 9->10 9->14 10->6 11->1 12->1 12->7 14->1
>>>Token int jvkukpoculbf ( int * nums , int gwllcweitwzp ) { int yzduzeewaidg = 0 , i ; qsort ( nums , gwllcweitwzp , sizeof ( int ) , cmpval ) ; for ( i = 0 ; i < gwllcweitwzp ; i = i + 2 ) yzduzeewaidg = yzduzeewaidg + nums [ i ] ; return yzduzeewaidg ; }
>>>Func
METHOD scoaxpxjjzwn
METHOD_RETURN int
PARAM double mhhcdjkjfmpt
<operator>.assignment vafbnbfaaudt=-1e100
RETURN return 1; return 1;
<operator>.lessThan mfyagdjtubmh<n
<operator>.postIncrement mfyagdjtubmh++
LITERAL 1 return 1;
<operator>.minus -1e100
<operator>.assignment mfyagdjtubmh=0
<operator>.lessThan j<a[mfyagdjtubmh][1]
<operator>.postIncrement j++
<operator>.assignment j=0
<operator>.assignment pos=a[mfyagdjtubmh][0]-mhhcdjkjfmpt
<operator>.assignment vafbnbfaaudt=pos
<operator>.greaterThan vafbnbfaaudt+m>pos
<operator>.greaterThan pos-a[mfyagdjtubmh][0]>mhhcdjkjfmpt+1e-12
<operator>.subtraction a[mfyagdjtubmh][0]-mhhcdjkjfmpt
<operator>.assignment pos=vafbnbfaaudt+m
RETURN return 0; return 0;
<operator>.addition vafbnbfaaudt+m
<operator>.subtraction pos-a[mfyagdjtubmh][0]
<operator>.addition mhhcdjkjfmpt+1e-12
LITERAL 0 return 0;
<operator>.addition vafbnbfaaudt+m
<operator>.indirectIndexAccess a[mfyagdjtubmh][1]
<operator>.indirectIndexAccess a[mfyagdjtubmh]
<operator>.indirectIndexAccess a[mfyagdjtubmh][0]
<operator>.indirectIndexAccess a[mfyagdjtubmh]
<operator>.indirectIndexAccess a[mfyagdjtubmh][0]
<operator>.indirectIndexAccess a[mfyagdjtubmh]
>>>PDG&31 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 2->17 3->1 3->1 3->15 3->18 3->20 3->24 4->1 5->1 5->1 5->1 5->4 5->6 5->10 5->12 5->25 5->26 6->1 6->5 7->4 8->3 9->1 9->5 10->1 10->1 10->1 10->5 10->6 10->11 10->13 10->15 10->16 10->17 10->20 10->21 10->22 10->27 10->28 10->29 10->30 11->1 11->10 12->1 12->10 13->1 13->1 13->15 14->1 14->15 14->18 14->20 14->24 15->1 15->1 15->18 15->21 15->24 16->1 16->1 16->1 16->10 16->11 16->14 16->19 16->25 16->26 17->13 17->13 17->16 17->21 17->22 18->1 18->1 18->21 19->1 20->1 20->1 21->1 21->1 21->14 21->16 21->16 21->17 22->1 23->19 24->1 24->1
>>>Token int scoaxpxjjzwn ( double mhhcdjkjfmpt ) { int mfyagdjtubmh , j ; double vafbnbfaaudt = -1e100 , pos ; for ( mfyagdjtubmh = 0 ; mfyagdjtubmh < n ; mfyagdjtubmh ++ ) for ( j = 0 ; j < a [ mfyagdjtubmh ] [ 1 ] ; j ++ ) { pos = a [ mfyagdjtubmh ] [ 0 ] - mhhcdjkjfmpt ; if ( vafbnbfaaudt + m > pos ) pos = vafbnbfaaudt + m ; if ( pos - a [ mfyagdjtubmh ] [ 0 ] > mhhcdjkjfmpt + 1e-12 ) return 0 ; vafbnbfaaudt = pos ; } return 1 ; }
>>>Func
METHOD alloc_test_get_header
METHOD_RETURN smgweqidavuq
PARAM void *ptr
<operator>.assignment jplmpevfxiew=((smgweqidavuq *)ptr)-1
assert assert(jplmpevfxiew->magic_number==ALLOC_TEST_MAGIC)
RETURN return jplmpevfxiew; return jplmpevfxiew;
IDENTIFIER jplmpevfxiew return jplmpevfxiew;
<operator>.subtraction ((smgweqidavuq *)ptr)-1
<operator>.equals jplmpevfxiew->magic_number==ALLOC_TEST_MAGIC
<operator>.cast (smgweqidavuq *)ptr
>>>PDG&10 0->2 0->6 0->7 0->8 0->9 2->7 2->9 3->1 3->1 3->1 3->6 4->1 4->1 5->1 6->5 7->1 7->3 7->3 8->1 8->1 8->4 8->4 9->1
>>>Token static smgweqidavuq * alloc_test_get_header ( void * ptr ) { smgweqidavuq * jplmpevfxiew ; jplmpevfxiew = ( ( smgweqidavuq * ) ptr ) - 1 ; assert ( jplmpevfxiew -> magic_number == ALLOC_TEST_MAGIC ) ; return jplmpevfxiew ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int cygcbgzkjwbk
PARAM const hfiifzyakztq*argv [ ]
<operator>.assignment erkeuopywrdp=0
<operator>.assignment krnvxpsxplgz=0
<operator>.assignment fhrpukyrgfgj=0
<operator>.assignment vndvwgthmbnp=0
<operator>.assignment vcucmgkdebzv=0
<operator>.assignment j=0
<operator>.assignment k=0
<operator>.assignment l=0
<operator>.assignment cznkudyejvhf=0
<operator>.assignment igjpcboklfhp[MAX_CHARACTERS]={'\0'}
<operator>.assignment dfyfddmrdtxq[MAX_CHARACTERS]={'\0'}
scanf scanf("%d",&erkeuopywrdp)
RETURN return 0; return 0;
<operator>.lessThan vcucmgkdebzv<NUM_CHARACTERS
<operator>.postIncrement vcucmgkdebzv++
<operator>.lessThan vcucmgkdebzv<erkeuopywrdp
<operator>.postIncrement vcucmgkdebzv++
LITERAL 0 return 0;
<operator>.arrayInitializer {'\0'}
<operator>.arrayInitializer {'\0'}
<operator>.assignment vcucmgkdebzv=0
<operator>.assignment vcucmgkdebzv=0
scanf scanf("%d",&krnvxpsxplgz)
scanf scanf("%d",&fhrpukyrgfgj)
scanf scanf("%d",&vndvwgthmbnp)
scanf scanf("%s",igjpcboklfhp)
<operator>.assignment k=0
printf printf("Case #%d: [",vcucmgkdebzv+1)
printf printf("]\n")
<operator>.assignment l=0
<operator>.lessThan j<NUM_CHARACTERS
<operator>.postIncrement j++
<operator>.lessThan k<NUM_CHARACTERS
<operator>.postIncrement k++
<operator>.lessThan j<krnvxpsxplgz
<operator>.postIncrement j++
<operator>.lessThan j<fhrpukyrgfgj
<operator>.postIncrement j++
<operator>.lessThan j<vndvwgthmbnp
<operator>.postIncrement j++
<operator>.lessThan l<k
<operator>.postIncrement l++
<operator>.notEquals dfyfddmrdtxq[l]!='\0'
<operator>.assignment j=0
<operator>.assignment lzzvbwgdrrpt[vcucmgkdebzv][j]='\0'
<operator>.assignment cbtueqstmxzr[vcucmgkdebzv][j]=false
<operator>.assignment k=0
<operator>.assignment j=0
scanf scanf("%s",igjpcboklfhp)
<operator>.assignment lzzvbwgdrrpt[(unsigned)igjpcboklfhp[0]][(unsigned)igjpcboklfhp[1]]=igjpcboklfhp[2]
<operator>.assignment lzzvbwgdrrpt[(unsigned)igjpcboklfhp[1]][(unsigned)igjpcboklfhp[0]]=igjpcboklfhp[2]
<operator>.assignment j=0
scanf scanf("%s",igjpcboklfhp)
<operator>.assignment cbtueqstmxzr[(unsigned)igjpcboklfhp[0]][(unsigned)igjpcboklfhp[1]]=true
<operator>.assignment cbtueqstmxzr[(unsigned)igjpcboklfhp[1]][(unsigned)igjpcboklfhp[0]]=true
<operator>.assignment j=0
<operator>.assignment dfyfddmrdtxq[k]=igjpcboklfhp[j]
<operator>.addition vcucmgkdebzv+1
<operator>.assignment l=0
printf printf("%c",dfyfddmrdtxq[l])
<operator>.assignment dfyfddmrdtxq[l++]='\0'
<operator>.lessThan j<NUM_CHARACTERS
<operator>.postIncrement j++
<operator>.greaterThan (cznkudyejvhf=check_end(dfyfddmrdtxq,k,lzzvbwgdrrpt,cbtueqstmxzr))>0
<operator>.notEquals dfyfddmrdtxq[l+1]!='\0'
<operator>.assignment j=0
<operator>.assignment lzzvbwgdrrpt[k][j]='\0'
<operator>.assignment cbtueqstmxzr[k][j]=false
<operator>.assignment k=k+1-cznkudyejvhf
printf printf(", ")
<operator>.cast (unsigned)igjpcboklfhp[1]
<operator>.cast (unsigned)igjpcboklfhp[0]
<operator>.cast (unsigned)igjpcboklfhp[1]
<operator>.cast (unsigned)igjpcboklfhp[0]
<operator>.assignment cznkudyejvhf=check_end(dfyfddmrdtxq,k,lzzvbwgdrrpt,cbtueqstmxzr)
<operator>.postIncrement k++
<operator>.postIncrement l++
<operator>.cast (unsigned)igjpcboklfhp[0]
<operator>.cast (unsigned)igjpcboklfhp[1]
<operator>.cast (unsigned)igjpcboklfhp[0]
<operator>.cast (unsigned)igjpcboklfhp[1]
check_end check_end(dfyfddmrdtxq,k,lzzvbwgdrrpt,cbtueqstmxzr)
<operator>.subtraction k+1-cznkudyejvhf
<operator>.addition l+1
<operator>.addition k+1
<operator>.addressOf &krnvxpsxplgz
<operator>.addressOf &fhrpukyrgfgj
<operator>.addressOf &vndvwgthmbnp
<operator>.indirectIndexAccess dfyfddmrdtxq[l]
<operator>.indirectIndexAccess lzzvbwgdrrpt[vcucmgkdebzv][j]
<operator>.indirectIndexAccess cbtueqstmxzr[vcucmgkdebzv][j]
<operator>.indirectIndexAccess lzzvbwgdrrpt[(unsigned)igjpcboklfhp[0]][(unsigned)igjpcboklfhp[1]]
<operator>.indirectIndexAccess igjpcboklfhp[2]
<operator>.indirectIndexAccess lzzvbwgdrrpt[(unsigned)igjpcboklfhp[1]][(unsigned)igjpcboklfhp[0]]
<operator>.indirectIndexAccess igjpcboklfhp[2]
<operator>.indirectIndexAccess cbtueqstmxzr[(unsigned)igjpcboklfhp[0]][(unsigned)igjpcboklfhp[1]]
<operator>.indirectIndexAccess cbtueqstmxzr[(unsigned)igjpcboklfhp[1]][(unsigned)igjpcboklfhp[0]]
<operator>.indirectIndexAccess dfyfddmrdtxq[k]
<operator>.indirectIndexAccess igjpcboklfhp[j]
<operator>.indirectIndexAccess dfyfddmrdtxq[l]
<operator>.indirectIndexAccess dfyfddmrdtxq[l++]
<operator>.indirectIndexAccess lzzvbwgdrrpt[vcucmgkdebzv]
<operator>.indirectIndexAccess cbtueqstmxzr[vcucmgkdebzv]
<operator>.indirectIndexAccess lzzvbwgdrrpt[(unsigned)igjpcboklfhp[0]]
<operator>.indirectIndexAccess lzzvbwgdrrpt[(unsigned)igjpcboklfhp[1]]
<operator>.indirectIndexAccess cbtueqstmxzr[(unsigned)igjpcboklfhp[0]]
<operator>.indirectIndexAccess cbtueqstmxzr[(unsigned)igjpcboklfhp[1]]
<operator>.indirectIndexAccess dfyfddmrdtxq[l+1]
<operator>.indirectIndexAccess lzzvbwgdrrpt[k][j]
<operator>.indirectIndexAccess cbtueqstmxzr[k][j]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess igjpcboklfhp[1]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess igjpcboklfhp[0]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess igjpcboklfhp[1]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess igjpcboklfhp[0]
<operator>.indirectIndexAccess lzzvbwgdrrpt[k]
<operator>.indirectIndexAccess cbtueqstmxzr[k]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess igjpcboklfhp[0]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess igjpcboklfhp[1]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess igjpcboklfhp[0]
UNKNOWN unsigned unsigned
<operator>.indirectIndexAccess igjpcboklfhp[1]
>>>PDG&132 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->55 0->56 0->57 0->58 0->59 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->73 0->79 0->80 0->85 0->86 0->87 0->88 2->1 3->1 4->1 4->15 4->19 5->1 5->1 5->26 5->38 6->1 6->1 6->27 6->40 7->1 7->1 7->28 7->42 9->1 9->1 10->1 10->1 11->1 11->1 12->1 12->1 13->1 13->1 13->29 13->52 13->56 14->1 14->1 14->1 14->46 14->63 14->68 14->85 15->1 15->19 16->1 17->1 17->1 17->17 17->18 17->18 17->34 17->34 17->36 17->47 18->1 18->17 19->1 19->1 19->1 19->19 19->20 19->20 19->26 19->27 19->28 19->29 19->30 19->31 19->31 19->32 19->33 19->36 19->38 19->40 19->42 19->44 19->46 19->50 19->51 19->55 19->59 19->61 19->61 19->62 19->89 19->90 19->91 19->92 20->1 20->19 21->16 22->13 23->14 24->17 25->1 25->19 26->1 26->38 27->1 27->40 28->1 28->42 29->1 29->52 29->56 29->60 30->1 30->44 30->85 31->1 31->1 32->1 33->1 33->1 33->80 34->1 34->1 34->17 34->34 34->35 34->35 34->48 34->49 34->93 34->94 34->105 34->106 35->1 35->34 36->1 36->1 36->36 36->37 36->37 36->65 36->65 36->69 37->1 37->36 38->1 38->1 38->26 38->38 38->39 38->39 38->52 38->53 38->54 38->74 38->75 38->81 38->82 38->95 38->96 38->97 38->98 38->107 38->108 38->114 38->115 38->116 38->117 38->124 38->125 38->126 38->127 39->1 39->38 40->1 40->1 40->27 40->40 40->41 40->41 40->56 40->57 40->58 40->76 40->77 40->83 40->84 40->99 40->100 40->109 40->110 40->118 40->119 40->120 40->121 40->128 40->129 40->130 40->131 41->1 41->40 42->1 42->1 42->1 42->28 42->42 42->43 42->43 42->60 42->67 42->78 42->85 42->101 42->102 43->1 43->42 44->1 44->1 44->44 44->45 44->45 44->63 44->68 44->87 44->87 44->103 44->111 45->1 45->44 46->1 46->1 46->46 46->63 46->64 46->80 46->85 46->92 46->104 47->1 47->34 48->1 48->1 49->1 49->1 49->1 50->36 51->38 52->29 52->53 52->54 52->56 52->74 52->75 52->76 52->77 52->81 52->82 52->83 52->84 53->1 53->1 54->1 54->1 54->1 55->40 56->29 56->52 56->76 56->77 56->83 56->84 57->1 57->1 58->1 58->1 58->1 59->1 59->42 60->1 60->1 60->1 60->85 62->44 63->1 63->46 64->1 64->1 64->85 65->1 65->36 65->65 65->66 65->66 65->70 65->71 65->112 65->113 65->122 65->123 66->1 66->65 67->1 67->1 67->72 67->79 67->86 67->88 68->1 68->1 68->73 68->85 69->65 70->1 70->1 71->1 71->1 71->1 72->1 72->1 72->44 72->85 73->1 75->1 77->1 78->1 78->1 78->67 78->86 79->1 79->44 79->85 80->1 82->1 84->1 85->1 85->1 85->1 85->46 85->63 85->67 85->67 85->67 85->67 85->68 85->78 85->78 85->78 85->78 85->79 85->86 85->88 86->1 86->1 86->72 86->72
>>>Token int main ( int cygcbgzkjwbk , const hfiifzyakztq * argv [ ] ) { int erkeuopywrdp = 0 ; int krnvxpsxplgz = 0 ; int fhrpukyrgfgj = 0 ; int vndvwgthmbnp = 0 ; int vcucmgkdebzv = 0 , j = 0 , k = 0 , l = 0 ; int cznkudyejvhf = 0 ; hfiifzyakztq lzzvbwgdrrpt [ NUM_CHARACTERS ] [ NUM_CHARACTERS ] ; bool cbtueqstmxzr [ NUM_CHARACTERS ] [ NUM_CHARACTERS ] ; hfiifzyakztq igjpcboklfhp [ MAX_CHARACTERS ] = { ' \0 ' } ; hfiifzyakztq dfyfddmrdtxq [ MAX_CHARACTERS ] = { ' \0 ' } ; for ( vcucmgkdebzv = 0 ; vcucmgkdebzv < NUM_CHARACTERS ; vcucmgkdebzv ++ ) { for ( j = 0 ; j < NUM_CHARACTERS ; j ++ ) { lzzvbwgdrrpt [ vcucmgkdebzv ] [ j ] = ' \0 ' ; cbtueqstmxzr [ vcucmgkdebzv ] [ j ] = false ; } } scanf ( " " , & erkeuopywrdp ) ; for ( vcucmgkdebzv = 0 ; vcucmgkdebzv < erkeuopywrdp ; vcucmgkdebzv ++ ) { for ( k = 0 ; k < NUM_CHARACTERS ; k ++ ) { for ( j = 0 ; j < NUM_CHARACTERS ; j ++ ) { lzzvbwgdrrpt [ k ] [ j ] = ' \0 ' ; cbtueqstmxzr [ k ] [ j ] = false ; } } scanf ( " " , & krnvxpsxplgz ) ; for ( j = 0 ; j < krnvxpsxplgz ; j ++ ) { scanf ( " " , igjpcboklfhp ) ; lzzvbwgdrrpt [ ( unsigned ) igjpcboklfhp [ 0 ] ] [ ( unsigned ) igjpcboklfhp [ 1 ] ] = igjpcboklfhp [ 2 ] ; lzzvbwgdrrpt [ ( unsigned ) igjpcboklfhp [ 1 ] ] [ ( unsigned ) igjpcboklfhp [ 0 ] ] = igjpcboklfhp [ 2 ] ; } scanf ( " " , & fhrpukyrgfgj ) ; for ( j = 0 ; j < fhrpukyrgfgj ; j ++ ) { scanf ( " " , igjpcboklfhp ) ; cbtueqstmxzr [ ( unsigned ) igjpcboklfhp [ 0 ] ] [ ( unsigned ) igjpcboklfhp [ 1 ] ] = true ; cbtueqstmxzr [ ( unsigned ) igjpcboklfhp [ 1 ] ] [ ( unsigned ) igjpcboklfhp [ 0 ] ] = true ; } scanf ( " " , & vndvwgthmbnp ) ; scanf ( " " , igjpcboklfhp ) ; k = 0 ; for ( j = 0 ; j < vndvwgthmbnp ; j ++ ) { dfyfddmrdtxq [ k ] = igjpcboklfhp [ j ] ; if ( ( cznkudyejvhf = check_end ( dfyfddmrdtxq , k , lzzvbwgdrrpt , cbtueqstmxzr ) ) > 0 ) { k = k + 1 - cznkudyejvhf ; } else { k ++ ; } } printf ( " " , vcucmgkdebzv + 1 ) ; for ( l = 0 ; l < k ; l ++ ) { printf ( " " , dfyfddmrdtxq [ l ] ) ; if ( dfyfddmrdtxq [ l + 1 ] != ' \0 ' ) { printf ( " " ) ; } } printf ( " \n " ) ; l = 0 ; while ( dfyfddmrdtxq [ l ] != ' \0 ' ) { dfyfddmrdtxq [ l ++ ] = ' \0 ' ; } } return 0 ; }
>>>Func
METHOD rand_string
METHOD_RETURN char*
PARAM zzmwmynpogtw *mgtyfcnplolq
PARAM size_t cfkzfomnbgyw
<operator>.assignment zzmwmynpogtwmgxsginasaen [ ]="abcdefghijklmnopqrstuvwxyz1234567890"
RETURN return mgtyfcnplolq; return mgtyfcnplolq;
IDENTIFIER cfkzfomnbgyw if (cfkzfomnbgyw)
IDENTIFIER mgtyfcnplolq return mgtyfcnplolq;
<operator>.preDecrement --cfkzfomnbgyw
<operator>.assignment mgtyfcnplolq[cfkzfomnbgyw]='\0'
<operator>.lessThan pjerrmsadwkk<cfkzfomnbgyw
<operator>.postIncrement pjerrmsadwkk++
<operator>.assignment pjerrmsadwkk=0
<operator>.assignment kgpjkvsnpezt=rand()%(int)(sizeof mgxsginasaen-1)
<operator>.assignment mgtyfcnplolq[pjerrmsadwkk]=mgxsginasaen[kgpjkvsnpezt]
<operator>.modulo rand()%(int)(sizeof mgxsginasaen-1)
<operator>.cast (int)(sizeof mgxsginasaen-1)
<operator>.subtraction sizeof mgxsginasaen-1
<operator>.sizeOf sizeof mgxsginasaen
<operator>.indirectIndexAccess mgtyfcnplolq[pjerrmsadwkk]
<operator>.indirectIndexAccess mgxsginasaen[kgpjkvsnpezt]
rand rand()
UNKNOWN int int
>>>PDG&23 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->15 0->17 2->1 2->7 3->1 3->8 4->1 4->1 5->1 7->5 8->1 8->10 9->1 9->1 9->7 10->1 10->1 10->1 10->10 10->11 10->11 10->13 10->14 10->15 10->16 10->17 10->18 10->19 10->20 10->21 10->22 11->1 11->10 12->1 12->10 13->1 13->1 13->1 14->1 14->1 14->1 14->7 15->1 15->1 15->13 15->13 16->1 17->15 17->16 18->1
>>>Token char * rand_string ( zzmwmynpogtw * mgtyfcnplolq , size_t cfkzfomnbgyw ) { const zzmwmynpogtwmgxsginasaen  [ ] = " " ; if ( cfkzfomnbgyw ) { -- cfkzfomnbgyw ; for ( size_t pjerrmsadwkk = 0 ; pjerrmsadwkk < cfkzfomnbgyw ; pjerrmsadwkk ++ ) { int kgpjkvsnpezt = rand ( ) % ( int ) ( sizeof mgxsginasaen - 1 ) ; mgtyfcnplolq [ pjerrmsadwkk ] = mgxsginasaen [ kgpjkvsnpezt ] ; } mgtyfcnplolq [ cfkzfomnbgyw ] = ' \0 ' ; } return mgtyfcnplolq ; }
>>>Func
METHOD tyqzaavyclnv
METHOD_RETURN float
PARAM float chfjufenhbzm[ARRAY_SIZE][ARRAY_SIZE]
PARAM int mqnrwyfdazet
PARAM int uzfefdvqehsa
<operator>.assignment dbfeuzakigwu=1
RETURN return chfjufenhbzm[ARRAY_SIZE-1][ARRAY_SIZE-1]; return chfjufenhbzm[ARRAY_SIZE-1][ARRAY_SIZE-1];
<operator>.lessThan j<uzfefdvqehsa-1
<operator>.postIncrement j++
<operator>.assignment j=mqnrwyfdazet
<operator>.assignment dzcnxjgvuksa=-((chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu][mqnrwyfdazet])/(chfjufenhbzm[mqnrwyfdazet][mqnrwyfdazet]))
<operator>.postIncrement dbfeuzakigwu++
<operator>.subtraction uzfefdvqehsa-1
<operator>.lessEqualsThan l<=uzfefdvqehsa
<operator>.postIncrement l++
<operator>.subtraction ARRAY_SIZE-1
<operator>.minus -((chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu][mqnrwyfdazet])/(chfjufenhbzm[mqnrwyfdazet][mqnrwyfdazet]))
<operator>.assignment l=0
<operator>.assignment chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu][l]=(chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu][l])+(chfjufenhbzm[mqnrwyfdazet][l]*dzcnxjgvuksa)
<operator>.subtraction ARRAY_SIZE-1
<operator>.division (chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu][mqnrwyfdazet])/(chfjufenhbzm[mqnrwyfdazet][mqnrwyfdazet])
<operator>.addition (chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu][l])+(chfjufenhbzm[mqnrwyfdazet][l]*dzcnxjgvuksa)
<operator>.multiplication chfjufenhbzm[mqnrwyfdazet][l]*dzcnxjgvuksa
<operator>.addition mqnrwyfdazet+dbfeuzakigwu
<operator>.addition mqnrwyfdazet+dbfeuzakigwu
<operator>.addition mqnrwyfdazet+dbfeuzakigwu
<operator>.indirectIndexAccess chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu][mqnrwyfdazet]
<operator>.indirectIndexAccess chfjufenhbzm[mqnrwyfdazet][mqnrwyfdazet]
<operator>.indirectIndexAccess chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu][l]
<operator>.indirectIndexAccess chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu]
<operator>.indirectIndexAccess chfjufenhbzm[mqnrwyfdazet]
<operator>.indirectIndexAccess chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu]
<operator>.indirectIndexAccess chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu][l]
<operator>.indirectIndexAccess chfjufenhbzm[mqnrwyfdazet+dbfeuzakigwu]
<operator>.indirectIndexAccess chfjufenhbzm[mqnrwyfdazet][l]
<operator>.indirectIndexAccess chfjufenhbzm[mqnrwyfdazet]
>>>PDG&36 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->17 0->19 0->22 0->23 0->24 0->25 2->1 3->9 3->23 4->12 5->1 5->1 5->11 5->23 5->24 5->25 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->10 7->11 7->12 7->13 7->16 7->17 7->20 7->23 7->26 7->27 7->29 7->30 8->1 8->7 9->1 9->1 9->7 10->1 10->1 10->1 10->22 11->1 11->1 11->23 11->24 11->25 12->1 12->7 12->7 12->13 13->1 13->1 13->12 13->13 13->14 13->14 13->18 13->21 13->22 13->24 13->25 13->28 13->31 13->32 13->33 13->34 13->35 14->1 14->13 15->1 16->1 16->10 17->1 17->13 18->1 18->1 18->1 18->21 19->15 20->1 20->1 20->16 20->16 21->1 22->1 22->1 22->18 22->18 22->21 22->21 23->1 25->1
>>>Token float tyqzaavyclnv ( float chfjufenhbzm [ ARRAY_SIZE ] [ ARRAY_SIZE ] , int mqnrwyfdazet , int uzfefdvqehsa ) { float dzcnxjgvuksa ; int dbfeuzakigwu = 1 , l , j ; for ( j = mqnrwyfdazet ; j < uzfefdvqehsa - 1 ; j ++ ) { dzcnxjgvuksa = - ( ( chfjufenhbzm [ mqnrwyfdazet + dbfeuzakigwu ] [ mqnrwyfdazet ] ) / ( chfjufenhbzm [ mqnrwyfdazet ] [ mqnrwyfdazet ] ) ) ; for ( l = 0 ; l <= uzfefdvqehsa ; l ++ ) { chfjufenhbzm [ mqnrwyfdazet + dbfeuzakigwu ] [ l ] = ( chfjufenhbzm [ mqnrwyfdazet + dbfeuzakigwu ] [ l ] ) + ( chfjufenhbzm [ mqnrwyfdazet ] [ l ] * dzcnxjgvuksa ) ; } dbfeuzakigwu ++ ; } return chfjufenhbzm [ ARRAY_SIZE - 1 ] [ ARRAY_SIZE - 1 ] ; }
>>>Func
METHOD hbrckwwldxhl
METHOD_RETURN int
PARAM int *prices
PARAM int pndocwfrowkk
<operator>.assignment kqrdkaqukdqm=0
<operator>.assignment wxdgfvpdlmyk=0
RETURN return wxdgfvpdlmyk; return wxdgfvpdlmyk;
<operator>.lessThan vebsbklfijmo<pndocwfrowkk
<operator>.postIncrement vebsbklfijmo++
IDENTIFIER wxdgfvpdlmyk return wxdgfvpdlmyk;
<operator>.assignment vebsbklfijmo=1
<operator>.assignment kqrdkaqukdqm=maxcmp(0,kqrdkaqukdqm+prices[vebsbklfijmo]-prices[vebsbklfijmo-1])
<operator>.assignment wxdgfvpdlmyk=maxcmp(wxdgfvpdlmyk,kqrdkaqukdqm)
maxcmp maxcmp(0,kqrdkaqukdqm+prices[vebsbklfijmo]-prices[vebsbklfijmo-1])
maxcmp maxcmp(wxdgfvpdlmyk,kqrdkaqukdqm)
<operator>.subtraction kqrdkaqukdqm+prices[vebsbklfijmo]-prices[vebsbklfijmo-1]
<operator>.addition kqrdkaqukdqm+prices[vebsbklfijmo]
<operator>.subtraction vebsbklfijmo-1
<operator>.indirectIndexAccess prices[vebsbklfijmo-1]
<operator>.indirectIndexAccess prices[vebsbklfijmo]
>>>PDG&20 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->13 0->14 0->15 0->16 0->17 2->1 2->15 2->16 3->7 4->1 4->1 4->15 4->16 5->1 5->1 5->9 5->14 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->13 7->14 7->15 7->16 7->17 7->17 7->18 7->19 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->14 12->1 12->1 12->1 12->9 12->14 13->1 13->11 13->11 14->1 14->12 14->12 14->15 14->16 15->1 15->1 15->13 15->13 16->1 17->8
>>>Token int hbrckwwldxhl ( int * prices , int pndocwfrowkk ) { int kqrdkaqukdqm = 0 , wxdgfvpdlmyk = 0 ; for ( int vebsbklfijmo = 1 ; vebsbklfijmo < pndocwfrowkk ; vebsbklfijmo ++ ) { kqrdkaqukdqm = maxcmp ( 0 , kqrdkaqukdqm + prices [ vebsbklfijmo ] - prices [ vebsbklfijmo - 1 ] ) ; wxdgfvpdlmyk = maxcmp ( wxdgfvpdlmyk , kqrdkaqukdqm ) ; } return wxdgfvpdlmyk ; }
>>>Func
METHOD vieshttqmwed
METHOD_RETURN int
PARAM struct tmbafyaymrnc*root
IDENTIFIER rbiczaozorxk <empty>
<operator>.addition 1+max(vieshttqmwed(root->left) vieshttqmwed(root->right))
max max(vieshttqmwed(root->left) vieshttqmwed(root->right))
vieshttqmwed vieshttqmwed(root->left)
vieshttqmwed vieshttqmwed(root->right)
>>>PDG&8 0->2 0->3 0->4 2->1 4->1 4->1 5->1 5->1 5->4 5->4 6->1 6->5 7->1 7->5
>>>Token int vieshttqmwed ( struct tmbafyaymrnc * root ) { if ( root == NULL ) rbiczaozorxk0 ; else rbiczaozorxk 1 + max ( vieshttqmwed ( root -> left ) , vieshttqmwed ( root -> right ) ) ; }
>>>Func
METHOD ayvfxozgwivj
METHOD_RETURN void
<operator>.lessThan sgdskakligmo<8
<operator>.postIncrement sgdskakligmo++
<operator>.assignment clear[sgdskakligmo]=0
<operator>.assignment sgdskakligmo=0
<operator>.indirectIndexAccess clear[sgdskakligmo]
>>>PDG&7 0->2 0->3 0->4 0->5 2->1 2->1 2->2 2->3 2->3 2->4 2->6 3->1 3->2 4->1 4->1 5->1 5->2
>>>Token void ayvfxozgwivj ( ) { int sgdskakligmo ; for ( sgdskakligmo = 0 ; sgdskakligmo < 8 ; sgdskakligmo ++ ) clear [ sgdskakligmo ] = 0 ; }
>>>Func
METHOD oqlkwzmwujgs
METHOD_RETURN long
PARAM long *freq
<operator>.assignment jmwogifavmtv=-1
<operator>.assignment cgdvmgaeagfj=-1
<operator>.assignment *freq=jmwogifavmtv
<operator>.assignment fr[cgdvmgaeagfj].used=1
RETURN return cgdvmgaeagfj; return cgdvmgaeagfj;
<operator>.lessThan xdemxnbrrtpc<l
<operator>.postIncrement xdemxnbrrtpc++
IDENTIFIER cgdvmgaeagfj return cgdvmgaeagfj;
<operator>.minus -1
<operator>.minus -1
<operator>.assignment xdemxnbrrtpc=0
<operator>.assignment running=fr[xdemxnbrrtpc].fre
<operator>.equals fr[xdemxnbrrtpc].used==0
<operator>.greaterThan running>jmwogifavmtv
<operator>.assignment jmwogifavmtv=running
<operator>.assignment cgdvmgaeagfj=xdemxnbrrtpc
<operator>.fieldAccess fr[xdemxnbrrtpc].fre
<operator>.indirectIndexAccess fr[xdemxnbrrtpc]
FIELD_IDENTIFIER fre fre
<operator>.fieldAccess fr[xdemxnbrrtpc].used
<operator>.indirectIndexAccess fr[xdemxnbrrtpc]
FIELD_IDENTIFIER used used
>>>PDG&25 0->2 0->5 0->6 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 2->1 3->1 3->5 3->16 4->1 4->1 4->1 4->10 5->1 5->1 5->1 6->1 6->1 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->14 8->15 8->18 8->19 8->20 8->21 8->22 8->23 8->24 9->1 9->8 10->7 11->3 12->4 13->1 13->8 14->1 14->1 14->16 15->1 15->16 16->1 16->1 16->5 16->17 16->17 16->18 17->1 17->1 17->5 17->16 18->1 18->1 18->10
>>>Token long oqlkwzmwujgs ( long * freq ) { long xdemxnbrrtpc ; long jmwogifavmtv = -1 , running ; long cgdvmgaeagfj = -1 ; for ( xdemxnbrrtpc = 0 ; xdemxnbrrtpc < l ; xdemxnbrrtpc ++ ) { running = fr [ xdemxnbrrtpc ] . fre ; if ( fr [ xdemxnbrrtpc ] . used == 0 ) { if ( running > jmwogifavmtv ) { jmwogifavmtv = running ; cgdvmgaeagfj = xdemxnbrrtpc ; } } } * freq = jmwogifavmtv ; fr [ cgdvmgaeagfj ] . used = 1 ; return cgdvmgaeagfj ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%lld",&nTestes)
RETURN return 0; return 0;
<operator>.lessEqualsThan t<=nTestes
<operator>.preIncrement ++t
LITERAL 0 return 0;
<operator>.assignment t=1
<operator>.assignment topo=qt=0
scanf scanf("%lld %lld %lld %lld %lld %lld %lld %lld",&n,&A,&B,&C,&D,&x0,&y0,&M)
<operator>.expressionList X=x0 Y=y0
<operator>.assignment pontos[topo].x=X
<operator>.assignment pontos[topo].y=Y
<operator>.preIncrement ++topo
printf printf("Case #%lld: %lld\n",t,qt)
<operator>.lessThan i<n
<operator>.preIncrement ++i
<operator>.lessThan i1<topo
<operator>.preIncrement ++i1
<operator>.assignment qt=0
<operator>.assignment X=x0
<operator>.assignment Y=y0
<operator>.assignment i=1
<operator>.assignment X=(A *X+B)%M
<operator>.assignment Y=(C *Y+D)%M
<operator>.assignment pontos[topo].x=X
<operator>.assignment pontos[topo].y=Y
<operator>.preIncrement ++topo
<operator>.assignment i1=0
<operator>.lessThan i2<topo
<operator>.preIncrement ++i2
<operator>.modulo (A *X+B)%M
<operator>.modulo (C *Y+D)%M
<operator>.assignment i2=i1+1
<operator>.addition A *X+B
<operator>.addition C *Y+D
<operator>.equals i1==i2
<operator>.lessThan i3<topo
<operator>.preIncrement ++i3
<operator>.multiplication A *X
<operator>.multiplication C *Y
<operator>.addition i1+1
<operator>.assignment i3=i2+1
<operator>.assignment qtvjpunwihah=(double)(pontos[i1].x+pontos[i2].x+pontos[i3].x)/(double)3
<operator>.assignment cY=(double)(pontos[i1].y+pontos[i2].y+pontos[i3].y)/(double)3
<operator>.equals i1==i3
<operator>.equals i2==i3
<operator>.addition i2+1
<operator>.division (double)(pontos[i1].x+pontos[i2].x+pontos[i3].x)/(double)3
<operator>.division (double)(pontos[i1].y+pontos[i2].y+pontos[i3].y)/(double)3
<operator>.preIncrement ++qt
<operator>.cast (double)(pontos[i1].x+pontos[i2].x+pontos[i3].x)
<operator>.cast (double)3
<operator>.cast (double)(pontos[i1].y+pontos[i2].y+pontos[i3].y)
<operator>.cast (double)3
<operator>.addition pontos[i1].x+pontos[i2].x+pontos[i3].x
<operator>.addition pontos[i1].y+pontos[i2].y+pontos[i3].y
<operator>.addressOf &n
<operator>.addressOf &A
<operator>.addressOf &B
<operator>.addressOf &C
<operator>.addressOf &D
<operator>.addressOf &x0
<operator>.addressOf &y0
<operator>.addressOf &M
<operator>.fieldAccess pontos[topo].x
<operator>.fieldAccess pontos[topo].y
<operator>.indirectIndexAccess pontos[topo]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess pontos[topo]
FIELD_IDENTIFIER y y
<operator>.fieldAccess pontos[topo].x
<operator>.fieldAccess pontos[topo].y
<operator>.indirectIndexAccess pontos[topo]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess pontos[topo]
FIELD_IDENTIFIER y y
UNKNOWN qtvjpunwihah==(glvyweokzwjt glvyweokzwjt)qtvjpunwihah&&cY==(glvyweokzwjt glvyweokzwjt)(cY) qtvjpunwihah==(glvyweokzwjt glvyweokzwjt)qtvjpunwihah&&cY==(glvyweokzwjt glvyweokzwjt)(cY)
UNKNOWN double double
UNKNOWN double double
UNKNOWN double double
UNKNOWN double double
<operator>.addition pontos[i1].x+pontos[i2].x
<operator>.fieldAccess pontos[i3].x
<operator>.addition pontos[i1].y+pontos[i2].y
<operator>.fieldAccess pontos[i3].y
<operator>.fieldAccess pontos[i1].x
<operator>.fieldAccess pontos[i2].x
<operator>.indirectIndexAccess pontos[i3]
FIELD_IDENTIFIER x x
<operator>.fieldAccess pontos[i1].y
<operator>.fieldAccess pontos[i2].y
<operator>.indirectIndexAccess pontos[i3]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess pontos[i1]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess pontos[i2]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess pontos[i1]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess pontos[i2]
FIELD_IDENTIFIER y y
>>>PDG&102 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->45 0->46 0->47 0->48 0->49 0->50 0->52 0->54 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->14 4->15 4->17 4->19 4->20 4->21 4->22 4->28 4->57 4->58 4->59 4->60 4->61 4->62 4->63 4->64 4->65 4->66 4->67 4->68 4->69 4->70 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->13 9->1 9->1 9->1 9->1 9->1 9->1 9->1 9->1 9->15 10->1 10->1 10->1 11->1 11->1 12->1 12->1 13->1 13->17 13->27 14->1 14->1 14->5 15->1 15->1 15->1 15->9 15->15 15->16 15->16 15->23 15->24 15->25 15->26 15->27 15->31 15->32 15->34 15->35 15->39 15->40 15->71 15->72 15->73 15->74 15->75 15->76 16->1 16->15 17->1 17->1 17->1 17->17 17->18 17->18 17->29 17->29 17->33 17->33 17->36 17->41 17->41 18->1 18->17 19->8 19->14 19->50 20->1 20->10 20->11 20->39 21->1 21->10 21->12 21->40 22->1 22->15 23->1 23->1 23->25 23->39 24->1 24->1 24->26 24->40 25->1 25->1 26->1 26->1 27->1 27->17 28->1 28->17 29->1 29->1 29->17 29->29 29->30 29->36 29->36 29->37 30->1 30->29 31->1 31->23 31->23 31->32 32->1 32->1 32->24 32->24 32->31 33->1 33->1 33->29 34->1 34->1 35->1 35->1 36->1 36->18 36->30 36->37 36->42 36->42 36->45 36->46 36->47 36->47 37->1 37->1 37->29 37->37 37->38 37->45 37->45 38->1 38->37 39->1 39->31 39->31 39->34 39->34 40->1 40->32 40->32 40->35 40->35 42->1 42->1 42->37 43->1 43->1 43->1 44->1 44->1 44->1 45->1 45->18 45->36 45->38 45->46 45->46 46->1 46->30 46->38 46->43 46->44 46->48 46->49 46->51 46->52 46->53 46->54 46->55 46->56 46->77 46->78 46->79 46->80 46->81 46->82 46->83 46->84 46->85 46->86 46->87 46->88 46->89 46->90 46->91 46->92 46->93 46->94 46->95 46->96 46->97 46->98 46->99 46->100 46->101 48->1 48->43 48->43 49->1 49->1 49->44 49->44 50->1 50->14 51->1 53->1 55->1 56->1 77->50
>>>Token int main ( ) { glvyweokzwjt glvyweokzwjtnTestes , t , n , A , B , C , D , x0 , y0 , X , Y , i , M , i1 , i2 , i3 , qt ; double qtvjpunwihah , cY ; scanf ( " " , & nTestes ) ; for ( t = 1 ; t <= nTestes ; ++ t ) { topo = qt = 0 ; scanf ( " " , & n , & A , & B , & C , & D , & x0 , & y0 , & M ) ; X = x0 , Y = y0 ; pontos [ topo ] . x = X ; pontos [ topo ] . y = Y ; ++ topo ; for ( i = 1 ; i < n ; ++ i ) { X = ( A * X + B ) % M ; Y = ( C * Y + D ) % M ; pontos [ topo ] . x = X ; pontos [ topo ] . y = Y ; ++ topo ; } for ( i1 = 0 ; i1 < topo ; ++ i1 ) { for ( i2 = i1 + 1 ; i2 < topo ; ++ i2 ) { if ( i1 == i2 ) continue ; for ( i3 = i2 + 1 ; i3 < topo ; ++ i3 ) { if ( i1 == i3 ) continue ; if ( i2 == i3 ) continue ; qtvjpunwihah = ( double ) ( pontos [ i1 ] . x + pontos [ i2 ] . x + pontos [ i3 ] . x ) / ( double ) 3 ; cY = ( double ) ( pontos [ i1 ] . y + pontos [ i2 ] . y + pontos [ i3 ] . y ) / ( double ) 3 ; if ( qtvjpunwihah == ( glvyweokzwjt glvyweokzwjt ) qtvjpunwihah && cY == ( glvyweokzwjt glvyweokzwjt ) ( cY ) ) ++ qt ; } } } printf ( " \n " , t , qt ) ; } return 0 ; }
>>>Func
METHOD kttuxwibwfyqblake2b_increment_counter
METHOD_RETURN ANY
PARAM blake2b_state *S
PARAM const phiojvnebdzsinc
<operator>.assignmentPlus S->t[0]+=inc
<operator>.assignmentPlus S->t[1]+=(S->t[0]<inc)
<operator>.lessThan S->t[0]<inc
>>>PDG&7 0->2 0->3 0->4 0->6 2->1 3->1 4->1 4->6 5->1 5->1 5->1 6->1 6->1 6->5 6->5
>>>Token static kttuxwibwfyqblake2b_increment_counter ( blake2b_state *  S , const phiojvnebdzsinc ) { S -> t [ 0 ] += inc ; S -> t [ 1 ] += ( S -> t [ 0 ] < inc ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
<operator>.assignment fp=fopen("A-small.in","r")
fscanf fscanf(fp,"%d",&mxsinilihryb)
fclose fclose(fp)
<operator>.lessThan nljifqmkxubl<mxsinilihryb
<operator>.postIncrement nljifqmkxubl++
fopen fopen("A-small.in","r")
<operator>.assignment nljifqmkxubl=0
<operator>.assignment ANS=0
fscanf fscanf(fp,"%d",&engines)
fgets fgets(iknnlixgiwgu,100,fp)
fscanf fscanf(fp,"%d",&qno)
fgets fgets(iknnlixgiwgu,100,fp)
printf printf("Case #%d: %d\n",nljifqmkxubl+1,ANS)
<operator>.lessThan j<engines
<operator>.postIncrement j++
<operator>.lessThan j<qno
<operator>.postIncrement j++
<operator>.lessThan k<engines
<operator>.postIncrement k++
<operator>.lessThan j<qno
<operator>.postIncrement j++
<operator>.assignment j=0
fgets fgets(rcxoueenvytp[j],100,fp)
<operator>.assignment j=0
fgets fgets(vrmdpjryahtn[j],100,fp)
<operator>.assignment k=0
<operator>.assignment bzkkgahxevcc[k]=0
<operator>.expressionList j=0 m=0
<operator>.addition nljifqmkxubl+1
<operator>.lessThan k<engines
<operator>.postIncrement k++
<operator>.equals m==engines
<operator>.assignment j=0
<operator>.assignment m=0
<operator>.assignment k=0
<operator>.postDecrement j--
<operator>.assignment m=0
<operator>.postIncrement ANS++
<operator>.equals strcmp(vrmdpjryahtn[j],rcxoueenvytp[k])==0
<operator>.lessThan k<engines
<operator>.postIncrement k++
<operator>.assignment k=engines
<operator>.assignment k=0
<operator>.assignment bzkkgahxevcc[k]=0
strcmp strcmp(vrmdpjryahtn[j],rcxoueenvytp[k])
<operator>.equals bzkkgahxevcc[k]==0
<operator>.assignment bzkkgahxevcc[k]=1
<operator>.postIncrement m++
<operator>.addressOf &engines
<operator>.addressOf &qno
<operator>.indirectIndexAccess rcxoueenvytp[j]
<operator>.indirectIndexAccess vrmdpjryahtn[j]
<operator>.indirectIndexAccess bzkkgahxevcc[k]
<operator>.indirectIndexAccess vrmdpjryahtn[j]
<operator>.indirectIndexAccess rcxoueenvytp[k]
<operator>.indirectIndexAccess bzkkgahxevcc[k]
<operator>.indirectIndexAccess bzkkgahxevcc[k]
<operator>.indirectIndexAccess bzkkgahxevcc[k]
>>>PDG&61 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->48 0->49 0->50 2->1 3->1 3->1 3->4 4->1 4->1 4->5 4->6 4->11 5->1 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->15 6->16 6->18 6->20 6->22 6->24 6->26 6->28 6->30 6->31 6->31 6->35 6->36 6->51 6->52 7->1 7->6 8->3 8->3 9->1 9->6 10->1 10->15 10->40 11->1 11->1 11->12 11->16 11->20 11->32 11->34 11->42 11->44 12->13 12->14 12->25 13->1 13->1 13->14 13->18 13->22 14->1 14->1 14->5 14->11 14->12 14->27 15->1 15->1 15->1 16->1 16->16 16->17 16->17 16->20 16->25 16->53 17->1 17->16 18->18 18->19 18->19 18->22 18->27 18->54 19->1 19->18 20->1 20->1 20->1 20->11 20->16 20->20 20->21 20->21 20->29 20->32 20->55 21->1 21->20 22->1 22->1 22->1 22->13 22->18 22->22 22->23 22->23 22->32 22->34 22->37 22->38 23->1 23->22 24->16 25->1 25->1 25->13 26->18 27->1 27->1 27->5 27->11 27->47 28->1 28->20 29->1 29->1 29->48 30->1 30->1 30->1 32->1 32->1 32->32 32->33 32->33 32->34 32->41 32->44 32->47 32->56 32->57 33->1 33->32 34->1 34->1 34->1 34->11 34->16 34->32 34->38 34->39 34->40 34->42 34->42 34->45 34->50 35->22 35->30 36->1 36->30 36->34 36->50 37->1 37->32 38->1 38->23 39->1 39->1 39->34 39->50 40->1 40->15 41->1 41->1 41->44 41->48 41->59 42->1 42->1 42->1 42->11 42->16 42->32 42->42 42->43 42->43 42->46 42->58 43->1 43->42 44->1 44->33 45->1 45->42 46->1 46->1 46->48 47->1 47->1 47->27 47->41 47->41 48->1 48->1 48->49 48->50 48->60 49->1 49->1 49->48 50->1 50->34
>>>Token int main ( void ) { FILE * fp ; int mxsinilihryb , engines , ANS , qno ; int nljifqmkxubl , j , k , m ; char rcxoueenvytp [ 100 ] [ 100 ] ; char vrmdpjryahtn [ 1000 ] [ 100 ] ; int bzkkgahxevcc [ 100 ] ; char iknnlixgiwgu [ 100 ] ; fp = fopen ( " " , " " ) ; fscanf ( fp , " " , & mxsinilihryb ) ; for ( nljifqmkxubl = 0 ; nljifqmkxubl < mxsinilihryb ; nljifqmkxubl ++ ) { ANS = 0 ; fscanf ( fp , " " , & engines ) ; fgets ( iknnlixgiwgu , 100 , fp ) ; for ( j = 0 ; j < engines ; j ++ ) { fgets ( rcxoueenvytp [ j ] , 100 , fp ) ; } fscanf ( fp , " " , & qno ) ; fgets ( iknnlixgiwgu , 100 , fp ) ; for ( j = 0 ; j < qno ; j ++ ) { fgets ( vrmdpjryahtn [ j ] , 100 , fp ) ; } for ( k = 0 ; k < engines ; k ++ ) { bzkkgahxevcc [ k ] = 0 ; } for ( j = 0 , m = 0 ; j < qno ; j ++ ) { for ( k = 0 ; k < engines ; k ++ ) { if ( strcmp ( vrmdpjryahtn [ j ] , rcxoueenvytp [ k ] ) == 0 ) { if ( bzkkgahxevcc [ k ] == 0 ) { bzkkgahxevcc [ k ] = 1 ; m ++ ; } k = engines ; } } if ( m == engines ) { j -- ; m = 0 ; ANS ++ ; for ( k = 0 ; k < engines ; k ++ ) { bzkkgahxevcc [ k ] = 0 ; } } } printf ( " \n " , nljifqmkxubl + 1 , ANS ) ; } fclose ( fp ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int yryfzgchoddg
PARAM char **argv
scanf scanf("%d",&cmnfarvxvbjj)
init init()
RETURN return 0; return 0;
<operator>.lessEqualsThan i<=cmnfarvxvbjj
<operator>.postIncrement i++
LITERAL 0 return 0;
<operator>.assignment i=1
init_round init_round()
scanf scanf("%d ",&mwbsshnmpcrz)
scanf scanf("%d ",&D)
scanf scanf("%d ",&N)
print_result print_result(i)
<operator>.lessThan j<mwbsshnmpcrz
<operator>.postIncrement j++
<operator>.lessThan j<D
<operator>.postIncrement j++
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.assignment j=0
scanf scanf("%c%c%c ",&dbxthigvcejx,&q,&r)
add_combine_rule add_combine_rule(dbxthigvcejx,q,r)
<operator>.assignment j=0
scanf scanf("%c%c ",&dbxthigvcejx,&q)
add_oppose_rule add_oppose_rule(dbxthigvcejx,q)
<operator>.assignment j=0
scanf scanf("%c",&becvbpoxzevc)
invoke invoke(becvbpoxzevc)
<operator>.addressOf &mwbsshnmpcrz
<operator>.addressOf &D
<operator>.addressOf &N
<operator>.addressOf &dbxthigvcejx
<operator>.addressOf &q
<operator>.addressOf &r
<operator>.addressOf &dbxthigvcejx
<operator>.addressOf &q
<operator>.addressOf &becvbpoxzevc
>>>PDG&40 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 2->1 3->1 4->1 4->7 5->1 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->13 7->14 7->15 7->15 7->16 7->18 7->20 7->22 7->25 7->28 7->31 7->32 7->33 8->1 8->7 9->6 10->1 10->7 11->1 12->1 12->16 13->1 13->18 14->1 14->20 15->1 15->8 16->1 16->1 16->12 16->16 16->17 16->17 16->23 16->24 16->34 16->35 16->36 17->1 17->16 18->1 18->1 18->13 18->18 18->19 18->19 18->26 18->27 18->37 18->38 19->1 19->18 20->1 20->1 20->1 20->14 20->20 20->21 20->21 20->29 20->30 20->39 21->1 21->20 22->16 23->1 23->1 23->1 23->24 23->26 23->27 24->1 24->1 24->1 24->1 24->23 24->26 24->27 24->27 25->18 26->1 26->1 26->23 26->24 26->27 27->1 27->1 27->1 27->23 27->24 27->24 27->26 28->1 28->20 29->1 29->30 30->1 30->1 30->29
>>>Token int main ( int yryfzgchoddg , char * * argv ) { int cmnfarvxvbjj , i ; scanf ( " " , & cmnfarvxvbjj ) ; init ( ) ; for ( i = 1 ; i <= cmnfarvxvbjj ; i ++ ) { int mwbsshnmpcrz , D , N , j ; init_round ( ) ; scanf ( " " , & mwbsshnmpcrz ) ; for ( j = 0 ; j < mwbsshnmpcrz ; j ++ ) { char dbxthigvcejx , q , r ; scanf ( " " , & dbxthigvcejx , & q , & r ) ; add_combine_rule ( dbxthigvcejx , q , r ) ; } scanf ( " " , & D ) ; for ( j = 0 ; j < D ; j ++ ) { char dbxthigvcejx , q ; scanf ( " " , & dbxthigvcejx , & q ) ; add_oppose_rule ( dbxthigvcejx , q ) ; } scanf ( " " , & N ) ; for ( j = 0 ; j < N ; j ++ ) { char becvbpoxzevc ; scanf ( " " , & becvbpoxzevc ) ; invoke ( becvbpoxzevc ) ; } print_result ( i ) ; } return 0 ; }
>>>Func
METHOD cwhqdzmwyolc
METHOD_RETURN float
PARAM int myzuywaipcfu
PARAM int yojgyrpiysml
<operator>.assignment count_1=0
<operator>.assignment count_0=0
<operator>.assignment count=0
<operator>.assignment pvehdmwjsrfn=0
aogfmxhocpnp aogfmxhocpnp(myzuywaipcfu==3)
<operator>.expressionList count_0=0 count_1=0
RETURN return (pvehdmwjsrfn/count); return (pvehdmwjsrfn/count);
<operator>.lessThan loicdstngwbx<yojgyrpiysml
<operator>.postIncrement loicdstngwbx++
<operator>.division pvehdmwjsrfn/count
<operator>.equals myzuywaipcfu==3
<operator>.assignment count_0=0
<operator>.assignment count_1=0
<operator>.assignment loicdstngwbx=0
<operator>.expressionList count_0=0 count_1=0
aogfmxhocpnp aogfmxhocpnp(loicdstngwbx==myzuywaipcfu||table[loicdstngwbx][myzuywaipcfu]=='.')
<operator>.assignmentPlus pvehdmwjsrfn+=(float)count_1/(count_0+count_1)
<operator>.assignment count_0=0
<operator>.assignment count_1=0
<operator>.logicalOr loicdstngwbx==myzuywaipcfu||table[loicdstngwbx][myzuywaipcfu]=='.'
<operator>.equals loicdstngwbx==myzuywaipcfu
<operator>.equals table[loicdstngwbx][myzuywaipcfu]=='.'
UNKNOWN,),)
<operator>.lessThan k<yojgyrpiysml
<operator>.postIncrement k++
aogfmxhocpnp aogfmxhocpnp(k==myzuywaipcfu||table[loicdstngwbx][k]=='.')
UNKNOWN,),)
<operator>.indirectIndexAccess table[loicdstngwbx][myzuywaipcfu]
<operator>.logicalOr k==myzuywaipcfu||table[loicdstngwbx][k]=='.'
<operator>.indirectIndexAccess table[loicdstngwbx]
<operator>.equals k==myzuywaipcfu
<operator>.equals table[loicdstngwbx][k]=='.'
<operator>.indirectIndexAccess table[loicdstngwbx][k]
<operator>.indirectIndexAccess table[loicdstngwbx]
>>>PDG&38 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->21 0->22 0->24 0->25 2->14 3->11 6->1 6->13 7->1 7->13 8->1 8->1 9->1 9->1 9->1 10->1 11->1 11->1 11->1 11->11 11->12 11->18 11->19 11->21 11->22 11->23 11->24 11->24 11->26 12->1 12->11 13->1 13->1 13->1 13->10 14->1 14->8 14->8 14->24 15->1 15->9 16->1 16->9 17->1 17->11 18->1 18->1 18->1 19->1 19->1 20->1 20->1 20->13 21->1 21->18 22->1 22->18 23->1 23->1 23->19 23->19 24->1 24->12 24->23 24->23 24->25 24->31 24->33 25->1 25->23 25->23 27->27 27->28 27->29 27->30 27->32 27->34 34->35 34->36 34->37
>>>Token float cwhqdzmwyolc ( int myzuywaipcfu , int yojgyrpiysml ) { int loicdstngwbx , k , count_1 = 0 , count_0 = 0 , count = 0 ; float pvehdmwjsrfn = 0 ; aogfmxhocpnp ( myzuywaipcfu == 3 ) count_0 = 0 , count_1 = 0 ; for ( loicdstngwbx = 0 ; loicdstngwbx < yojgyrpiysml ; loicdstngwbx ++ ) { count_0 = 0 , count_1 = 0 ; aogfmxhocpnp ( loicdstngwbx == myzuywaipcfu || table [ loicdstngwbx ] [ myzuywaipcfu ] == ' ' ) continue ; for ( k = 0 ; k < yojgyrpiysml ; k ++ ) { aogfmxhocpnp ( k == myzuywaipcfu || table [ loicdstngwbx ] [ k ] == ' ' ) continue ; aogfmxhocpnp ( table [ loicdstngwbx ] [ k ] == ' ' ) count_1 ++ ; else aogfmxhocpnp ( table [ loicdstngwbx ] [ k ] = = ' ' ) count_0 ++ ; } count ++ ; pvehdmwjsrfn += ( float ) count_1 / ( count_0 + count_1 ) ; } return ( pvehdmwjsrfn / count ) ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&oilvimlzlbux)
RETURN return 0; return 0;
<operator>.lessThan rqpldszovvkq<oilvimlzlbux
<operator>.postIncrement rqpldszovvkq++
LITERAL 0 return 0;
<operator>.assignment rqpldszovvkq=0
<operator>.assignment ibszfaftitjl=0
scanf scanf("%d",&yjqfuemrxesi)
scanf scanf(" %d ",&fxltqgmqtsfi)
scanf scanf(" %d ",&vtkanbmzzqsu)
printf printf("Case #%d: [",rqpldszovvkq+1)
printf printf("]\n")
<operator>.lessThan tupmlihahblu<26
<operator>.postIncrement tupmlihahblu++
<operator>.lessThan tupmlihahblu<yjqfuemrxesi
<operator>.postIncrement tupmlihahblu++
<operator>.lessThan tupmlihahblu<fxltqgmqtsfi
<operator>.postIncrement tupmlihahblu++
<operator>.lessThan tupmlihahblu<vtkanbmzzqsu
<operator>.postIncrement tupmlihahblu++
IDENTIFIER ibszfaftitjl if (ibszfaftitjl)
<operator>.lessThan tupmlihahblu<ibszfaftitjl
<operator>.postIncrement tupmlihahblu++
<operator>.assignment tupmlihahblu=0
<operator>.assignment zmmzzkajtxdw[tupmlihahblu]=0
<operator>.assignment tupmlihahblu=0
scanf scanf(" %c%c%c ",&xuvsdwgxnqgs,&reagent2,&product)
<operator>.assignment zyqhvbopdmkt[xuvsdwgxnqgs-'A'][reagent2-'A']=product
<operator>.assignment zyqhvbopdmkt[reagent2-'A'][xuvsdwgxnqgs-'A']=product
<operator>.assignment tupmlihahblu=0
scanf scanf(" %c%c ",&jglngjzwsyul,&op2)
<operator>.assignment orrjegwnajak[jglngjzwsyul-'A'][op2-'A']=1
<operator>.assignment orrjegwnajak[op2-'A'][jglngjzwsyul-'A']=1
<operator>.assignment tupmlihahblu=0
scanf scanf("%c",&foxgthjrsweo)
<operator>.addition rqpldszovvkq+1
printf printf("%c",zquhfaotkqrk[0])
<operator>.assignment tupmlihahblu=1
printf printf(", %c",zquhfaotkqrk[tupmlihahblu])
<operator>.lessThan qgdhtrurqftv<26
<operator>.postIncrement qgdhtrurqftv++
<operator>.logicalAnd ibszfaftitjl>0&&zyqhvbopdmkt[foxgthjrsweo-'A'][zquhfaotkqrk[ibszfaftitjl-1]-'A']!=0
<operator>.lessThan qgdhtrurqftv<26
<operator>.postIncrement qgdhtrurqftv++
<operator>.assignment qgdhtrurqftv=0
<operator>.assignment zyqhvbopdmkt[tupmlihahblu][qgdhtrurqftv]=0
<operator>.assignment orrjegwnajak[tupmlihahblu][qgdhtrurqftv]=0
<operator>.postDecrement zmmzzkajtxdw[zquhfaotkqrk[ibszfaftitjl-1]-'A']--
<operator>.assignment zquhfaotkqrk[ibszfaftitjl-1]=zyqhvbopdmkt[foxgthjrsweo-'A'][zquhfaotkqrk[ibszfaftitjl-1]-'A']
<operator>.postIncrement zmmzzkajtxdw[zquhfaotkqrk[ibszfaftitjl-1]-'A']++
<operator>.assignment qgdhtrurqftv=0
<operator>.subtraction reagent2-'A'
<operator>.subtraction xuvsdwgxnqgs-'A'
<operator>.subtraction op2-'A'
<operator>.subtraction jglngjzwsyul-'A'
<operator>.greaterThan ibszfaftitjl>0
<operator>.notEquals zyqhvbopdmkt[foxgthjrsweo-'A'][zquhfaotkqrk[ibszfaftitjl-1]-'A']!=0
<operator>.assignment zquhfaotkqrk[ibszfaftitjl++]=foxgthjrsweo
<operator>.assignmentPlus zmmzzkajtxdw[foxgthjrsweo-'A']+=1
<operator>.logicalAnd zmmzzkajtxdw[qgdhtrurqftv]&&orrjegwnajak[qgdhtrurqftv][zquhfaotkqrk[ibszfaftitjl-1]-'A']
<operator>.subtraction xuvsdwgxnqgs-'A'
<operator>.subtraction reagent2-'A'
<operator>.subtraction jglngjzwsyul-'A'
<operator>.subtraction op2-'A'
<operator>.assignment ibszfaftitjl=0
<operator>.subtraction zquhfaotkqrk[ibszfaftitjl-1]-'A'
<operator>.subtraction zquhfaotkqrk[ibszfaftitjl-1]-'A'
<operator>.subtraction ibszfaftitjl-1
<operator>.subtraction zquhfaotkqrk[ibszfaftitjl-1]-'A'
<operator>.subtraction zquhfaotkqrk[ibszfaftitjl-1]-'A'
<operator>.lessThan lfblwbvpajek<26
<operator>.postIncrement lfblwbvpajek++
<operator>.subtraction foxgthjrsweo-'A'
<operator>.subtraction foxgthjrsweo-'A'
<operator>.postIncrement ibszfaftitjl++
<operator>.subtraction foxgthjrsweo-'A'
<operator>.subtraction zquhfaotkqrk[ibszfaftitjl-1]-'A'
<operator>.assignment lfblwbvpajek=0
<operator>.assignment zmmzzkajtxdw[lfblwbvpajek]=0
<operator>.subtraction ibszfaftitjl-1
<operator>.subtraction ibszfaftitjl-1
<operator>.subtraction ibszfaftitjl-1
<operator>.subtraction ibszfaftitjl-1
<operator>.subtraction ibszfaftitjl-1
<operator>.addressOf &yjqfuemrxesi
<operator>.addressOf &fxltqgmqtsfi
<operator>.addressOf &vtkanbmzzqsu
<operator>.indirectIndexAccess zmmzzkajtxdw[tupmlihahblu]
<operator>.addressOf &xuvsdwgxnqgs
<operator>.addressOf &reagent2
<operator>.addressOf &product
<operator>.indirectIndexAccess zyqhvbopdmkt[xuvsdwgxnqgs-'A'][reagent2-'A']
<operator>.indirectIndexAccess zyqhvbopdmkt[reagent2-'A'][xuvsdwgxnqgs-'A']
<operator>.addressOf &jglngjzwsyul
<operator>.addressOf &op2
<operator>.indirectIndexAccess orrjegwnajak[jglngjzwsyul-'A'][op2-'A']
<operator>.indirectIndexAccess orrjegwnajak[op2-'A'][jglngjzwsyul-'A']
<operator>.addressOf &foxgthjrsweo
<operator>.indirectIndexAccess zquhfaotkqrk[0]
<operator>.indirectIndexAccess zquhfaotkqrk[tupmlihahblu]
<operator>.indirectIndexAccess zyqhvbopdmkt[xuvsdwgxnqgs-'A']
<operator>.indirectIndexAccess zyqhvbopdmkt[reagent2-'A']
<operator>.indirectIndexAccess orrjegwnajak[jglngjzwsyul-'A']
<operator>.indirectIndexAccess orrjegwnajak[op2-'A']
<operator>.indirectIndexAccess zyqhvbopdmkt[tupmlihahblu][qgdhtrurqftv]
<operator>.indirectIndexAccess orrjegwnajak[tupmlihahblu][qgdhtrurqftv]
<operator>.indirectIndexAccess zyqhvbopdmkt[foxgthjrsweo-'A'][zquhfaotkqrk[ibszfaftitjl-1]-'A']
<operator>.indirectIndexAccess zmmzzkajtxdw[zquhfaotkqrk[ibszfaftitjl-1]-'A']
<operator>.indirectIndexAccess zquhfaotkqrk[ibszfaftitjl-1]
<operator>.indirectIndexAccess zyqhvbopdmkt[foxgthjrsweo-'A'][zquhfaotkqrk[ibszfaftitjl-1]-'A']
<operator>.indirectIndexAccess zmmzzkajtxdw[zquhfaotkqrk[ibszfaftitjl-1]-'A']
<operator>.indirectIndexAccess zyqhvbopdmkt[tupmlihahblu]
<operator>.indirectIndexAccess orrjegwnajak[tupmlihahblu]
<operator>.indirectIndexAccess zyqhvbopdmkt[foxgthjrsweo-'A']
<operator>.indirectIndexAccess zyqhvbopdmkt[foxgthjrsweo-'A']
<operator>.indirectIndexAccess zquhfaotkqrk[ibszfaftitjl++]
<operator>.indirectIndexAccess zmmzzkajtxdw[foxgthjrsweo-'A']
<operator>.indirectIndexAccess zmmzzkajtxdw[qgdhtrurqftv]
<operator>.indirectIndexAccess orrjegwnajak[qgdhtrurqftv][zquhfaotkqrk[ibszfaftitjl-1]-'A']
<operator>.indirectIndexAccess zquhfaotkqrk[ibszfaftitjl-1]
<operator>.indirectIndexAccess zquhfaotkqrk[ibszfaftitjl-1]
<operator>.indirectIndexAccess zquhfaotkqrk[ibszfaftitjl-1]
<operator>.indirectIndexAccess zquhfaotkqrk[ibszfaftitjl-1]
<operator>.indirectIndexAccess orrjegwnajak[qgdhtrurqftv]
<operator>.indirectIndexAccess zquhfaotkqrk[ibszfaftitjl-1]
<operator>.indirectIndexAccess zmmzzkajtxdw[lfblwbvpajek]
>>>PDG&128 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 0->48 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->14 4->16 4->18 4->20 4->23 4->25 4->27 4->31 4->35 4->37 4->37 4->38 4->39 4->86 4->87 4->88 4->100 5->1 5->4 6->3 7->1 7->4 8->1 8->23 8->57 9->1 9->16 10->1 10->18 11->1 11->20 12->1 12->1 13->1 14->1 14->14 14->15 14->15 14->26 14->41 14->46 14->89 15->1 15->14 16->1 16->1 16->9 16->16 16->17 16->17 16->28 16->29 16->30 16->53 16->54 16->62 16->63 16->90 16->91 16->92 16->93 16->94 16->102 16->103 17->1 17->16 18->1 18->1 18->10 18->18 18->19 18->19 18->32 18->33 18->34 18->55 18->56 18->64 18->65 18->95 18->96 18->97 18->98 18->104 18->105 19->1 19->18 20->1 20->1 20->11 20->20 20->21 20->21 20->36 20->43 20->44 20->52 20->57 20->99 21->1 21->20 23->1 23->1 23->1 23->23 23->24 23->24 23->40 23->101 24->1 24->23 25->14 26->1 26->1 27->16 28->1 28->1 28->1 28->54 28->62 29->1 29->1 30->1 30->1 30->1 31->18 32->1 32->1 32->56 32->64 33->1 33->1 34->1 34->1 35->1 35->20 36->1 36->59 36->74 36->75 36->77 38->1 38->1 39->1 39->23 40->1 40->1 41->1 41->1 41->41 41->42 41->42 41->47 41->48 41->106 41->107 41->113 41->114 42->1 42->41 43->1 43->1 43->1 43->49 43->50 43->51 43->59 43->60 43->68 43->69 43->70 43->71 43->75 43->76 43->77 43->82 43->83 43->84 43->109 43->110 43->111 43->112 43->116 43->117 43->118 43->122 43->123 43->124 44->1 44->1 44->44 44->45 44->45 44->61 44->119 45->1 45->44 46->1 46->41 47->1 47->1 48->1 48->1 49->1 49->51 50->1 50->1 50->71 51->1 51->1 51->49 52->1 52->44 53->63 54->1 54->28 54->62 55->65 56->1 56->32 56->64 57->43 57->43 57->58 57->67 57->74 57->76 57->81 57->81 57->82 57->108 57->115 57->121 58->1 58->43 58->43 58->50 59->1 59->1 60->1 60->1 61->1 61->1 61->1 61->66 61->72 61->79 62->54 63->1 63->53 64->56 65->1 65->55 66->1 66->23 66->57 66->85 67->1 67->68 67->78 68->70 69->83 71->1 71->67 71->68 71->78 72->1 72->1 72->72 72->73 72->73 72->80 72->127 73->1 73->72 74->59 74->75 74->77 75->1 75->36 75->59 75->74 75->77 76->23 76->57 76->85 77->1 77->36 77->59 77->74 77->75 78->1 78->67 78->68 79->1 79->72 80->1 80->1 81->76 81->82 82->69 83->84 84->23 84->57 84->85 85->23 85->57 119->78 119->85 119->120 119->125 119->126
>>>Token int main ( ) { int oilvimlzlbux ; scanf ( " " , & oilvimlzlbux ) ; for ( int rqpldszovvkq = 0 ; rqpldszovvkq < oilvimlzlbux ; rqpldszovvkq ++ ) { int zquhfaotkqrk [ 128 ] ; int ibszfaftitjl = 0 ; int zmmzzkajtxdw [ 26 ] ; char zyqhvbopdmkt [ 26 ] [ 26 ] ; int orrjegwnajak [ 26 ] [ 26 ] ; for ( int tupmlihahblu = 0 ; tupmlihahblu < 26 ; tupmlihahblu ++ ) { zmmzzkajtxdw [ tupmlihahblu ] = 0 ; for ( int qgdhtrurqftv = 0 ; qgdhtrurqftv < 26 ; qgdhtrurqftv ++ ) { zyqhvbopdmkt [ tupmlihahblu ] [ qgdhtrurqftv ] = 0 ; orrjegwnajak [ tupmlihahblu ] [ qgdhtrurqftv ] = 0 ; } } int yjqfuemrxesi ; scanf ( " " , & yjqfuemrxesi ) ; for ( int tupmlihahblu = 0 ; tupmlihahblu < yjqfuemrxesi ; tupmlihahblu ++ ) { char xuvsdwgxnqgs , reagent2 , product ; scanf ( " " , & xuvsdwgxnqgs , & reagent2 , & product ) ; zyqhvbopdmkt [ xuvsdwgxnqgs - ' ' ] [ reagent2 - ' ' ] = product ; zyqhvbopdmkt [ reagent2 - ' ' ] [ xuvsdwgxnqgs - ' ' ] = product ; } int fxltqgmqtsfi ; scanf ( " " , & fxltqgmqtsfi ) ; for ( int tupmlihahblu = 0 ; tupmlihahblu < fxltqgmqtsfi ; tupmlihahblu ++ ) { char jglngjzwsyul , op2 ; scanf ( " " , & jglngjzwsyul , & op2 ) ; orrjegwnajak [ jglngjzwsyul - ' ' ] [ op2 - ' ' ] = 1 ; orrjegwnajak [ op2 - ' ' ] [ jglngjzwsyul - ' ' ] = 1 ; } int vtkanbmzzqsu ; scanf ( " " , & vtkanbmzzqsu ) ; for ( int tupmlihahblu = 0 ; tupmlihahblu < vtkanbmzzqsu ; tupmlihahblu ++ ) { char foxgthjrsweo ; scanf ( " " , & foxgthjrsweo ) ; if ( ibszfaftitjl > 0 && zyqhvbopdmkt [ foxgthjrsweo - ' ' ] [ zquhfaotkqrk [ ibszfaftitjl - 1 ] - ' ' ] != 0 ) { zmmzzkajtxdw [ zquhfaotkqrk [ ibszfaftitjl - 1 ] - ' ' ] -- ; zquhfaotkqrk [ ibszfaftitjl - 1 ] = zyqhvbopdmkt [ foxgthjrsweo - ' ' ] [ zquhfaotkqrk [ ibszfaftitjl - 1 ] - ' ' ] ; zmmzzkajtxdw [ zquhfaotkqrk [ ibszfaftitjl - 1 ] - ' ' ] ++ ; } else { zquhfaotkqrk [ ibszfaftitjl ++ ] = foxgthjrsweo ; zmmzzkajtxdw [ foxgthjrsweo - ' ' ] += 1 ; } for ( int qgdhtrurqftv = 0 ; qgdhtrurqftv < 26 ; qgdhtrurqftv ++ ) { if ( zmmzzkajtxdw [ qgdhtrurqftv ] && orrjegwnajak [ qgdhtrurqftv ] [ zquhfaotkqrk [ ibszfaftitjl - 1 ] - ' ' ] ) { ibszfaftitjl = 0 ; for ( int lfblwbvpajek = 0 ; lfblwbvpajek < 26 ; lfblwbvpajek ++ ) { zmmzzkajtxdw [ lfblwbvpajek ] = 0 ; } } } } printf ( " " , rqpldszovvkq + 1 ) ; if ( ibszfaftitjl ) { printf ( " " , zquhfaotkqrk [ 0 ] ) ; } for ( int tupmlihahblu = 1 ; tupmlihahblu < ibszfaftitjl ; tupmlihahblu ++ ) { printf ( " " , zquhfaotkqrk [ tupmlihahblu ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int xqhdeztfwtcd
PARAM char **argv
assert assert(xqhdeztfwtcd==3)
<operator>.assignment inputFile=fopen(argv[1],"r")
<operator>.assignment outputFile=fopen(argv[2],"w")
fgets fgets(kcqavalgwabv,5000,inputFile)
<operator>.assignment pzyuxbizgidg=atoi(kcqavalgwabv)
<operator>.assignment caseNum=1
fclose fclose(inputFile)
fclose fclose(outputFile)
<operator>.notEquals fgets(kcqavalgwabv,5000,inputFile)!=NULL
<operator>.equals xqhdeztfwtcd==3
fopen fopen(argv[1],"r")
fopen fopen(argv[2],"w")
atoi atoi(kcqavalgwabv)
<operator>.assignment numTeams=atoi(kcqavalgwabv)
fprintf fprintf(outputFile,"Case #%d:\n",caseNum)
fflush fflush(outputFile)
fflush fflush(outputFile)
<operator>.postIncrement caseNum++
fgets fgets(kcqavalgwabv,5000,inputFile)
<operator>.lessThan tluaxntlcmvk<numTeams
<operator>.postIncrement tluaxntlcmvk++
<operator>.lessThan tluaxntlcmvk<numTeams
<operator>.postIncrement tluaxntlcmvk++
<operator>.lessThan tluaxntlcmvk<numTeams
<operator>.postIncrement tluaxntlcmvk++
<operator>.assignment tpdrjaqsdvbn[tluaxntlcmvk]=(double)numWins[tluaxntlcmvk]/numGames[tluaxntlcmvk]
<operator>.lessThan tluaxntlcmvk<numTeams
<operator>.postIncrement tluaxntlcmvk++
<operator>.lessThan tluaxntlcmvk<numTeams
<operator>.postIncrement tluaxntlcmvk++
<operator>.lessThan tluaxntlcmvk<numTeams
<operator>.postIncrement tluaxntlcmvk++
fprintf fprintf(outputFile "%.6lf\n" (0.25 *(tpdrjaqsdvbn[tluaxntlcmvk]+oowp[tluaxntlcmvk])+0.5 *(owp[tluaxntlcmvk])))
atoi atoi(kcqavalgwabv)
<operator>.assignment tluaxntlcmvk=0
<operator>.assignment tpdrjaqsdvbn[tluaxntlcmvk]=owp[tluaxntlcmvk]=oowp[tluaxntlcmvk]=0.0
<operator>.assignment numGames[tluaxntlcmvk]=numWins[tluaxntlcmvk]=0
<operator>.assignment tluaxntlcmvk=0
fgets fgets(kcqavalgwabv,5000,inputFile)
<operator>.assignment tluaxntlcmvk=0
<operator>.assignment tluaxntlcmvk=0
dkqotpgjrggu dkqotpgjrggu(dggrtavurlbd[tluaxntlcmvk][j]!=-1)
<operator>.assignmentPlus owp[tluaxntlcmvk]+=(((tpdrjaqsdvbn[j]*numGames[j])-(1-dggrtavurlbd[tluaxntlcmvk][j]))/(numGames[j]-1))
<operator>.assignment owp[tluaxntlcmvk]=owp[tluaxntlcmvk]/numGames[tluaxntlcmvk]
<operator>.assignment tluaxntlcmvk=0
dkqotpgjrggu dkqotpgjrggu(dggrtavurlbd[tluaxntlcmvk][j]!=-1)
<operator>.assignmentPlus oowp[tluaxntlcmvk]+=owp[j]
<operator>.assignment oowp[tluaxntlcmvk]=oowp[tluaxntlcmvk]/numGames[tluaxntlcmvk]
<operator>.assignment tluaxntlcmvk=0
<operator>.lessThan j<numTeams
<operator>.postIncrement j++
<operator>.division (double)numWins[tluaxntlcmvk]/numGames[tluaxntlcmvk]
<operator>.addition 0.25 *(tpdrjaqsdvbn[tluaxntlcmvk]+oowp[tluaxntlcmvk])+0.5 *(owp[tluaxntlcmvk])
<operator>.assignment owp[tluaxntlcmvk]=oowp[tluaxntlcmvk]=0.0
<operator>.assignment numWins[tluaxntlcmvk]=0
<operator>.assignment j=0
dkqotpgjrggu dkqotpgjrggu(kcqavalgwabv[j]=='0')
BLOCK <empty> <empty>
<operator>.cast (double)numWins[tluaxntlcmvk]
<operator>.notEquals dggrtavurlbd[tluaxntlcmvk][j]!=-1
<operator>.division ((tpdrjaqsdvbn[j]*numGames[j])-(1-dggrtavurlbd[tluaxntlcmvk][j]))/(numGames[j]-1)
<operator>.division owp[tluaxntlcmvk]/numGames[tluaxntlcmvk]
<operator>.notEquals dggrtavurlbd[tluaxntlcmvk][j]!=-1
<operator>.division oowp[tluaxntlcmvk]/numGames[tluaxntlcmvk]
<operator>.multiplication 0.25 *(tpdrjaqsdvbn[tluaxntlcmvk]+oowp[tluaxntlcmvk])
<operator>.multiplication 0.5 *(owp[tluaxntlcmvk])
<operator>.assignment oowp[tluaxntlcmvk]=0.0
<operator>.assignment dggrtavurlbd[tluaxntlcmvk][j]=0
<operator>.postIncrement numGames[tluaxntlcmvk]++
<operator>.minus -1
<operator>.subtraction (tpdrjaqsdvbn[j]*numGames[j])-(1-dggrtavurlbd[tluaxntlcmvk][j])
<operator>.subtraction numGames[j]-1
<operator>.minus -1
<operator>.addition tpdrjaqsdvbn[tluaxntlcmvk]+oowp[tluaxntlcmvk]
<operator>.equals kcqavalgwabv[j]=='0'
<operator>.multiplication tpdrjaqsdvbn[j]*numGames[j]
<operator>.subtraction 1-dggrtavurlbd[tluaxntlcmvk][j]
<operator>.indirectIndexAccess tpdrjaqsdvbn[tluaxntlcmvk]
UNKNOWN,),)
UNKNOWN,),)
<operator>.indirectIndexAccess tpdrjaqsdvbn[tluaxntlcmvk]
<operator>.indirectIndexAccess numGames[tluaxntlcmvk]
<operator>.indirectIndexAccess numGames[tluaxntlcmvk]
<operator>.indirectIndexAccess owp[tluaxntlcmvk]
<operator>.indirectIndexAccess owp[tluaxntlcmvk]
<operator>.indirectIndexAccess oowp[tluaxntlcmvk]
<operator>.indirectIndexAccess owp[j]
<operator>.indirectIndexAccess oowp[tluaxntlcmvk]
<operator>.indirectIndexAccess owp[tluaxntlcmvk]
<operator>.indirectIndexAccess numWins[tluaxntlcmvk]
UNKNOWN,),)
UNKNOWN else dkqotpgjrggu (kcqavalgwabv[j]=='1'){dggrtavurlbd[tluaxntlcmvk][j]=1;numGames[tluaxntlcmvk]++;numWins[tluaxntlcmvk]++;} else dkqotpgjrggu (kcqavalgwabv[j]=='1'){dggrtavurlbd[tluaxntlcmvk][j]=1;numGames[tluaxntlcmvk]++;numWins[tluaxntlcmvk]++;}
UNKNOWN else dggrtavurlbd [tluaxntlcmvk][j]=-1; else dggrtavurlbd [tluaxntlcmvk][j]=-1;
UNKNOWN double double
<operator>.indirectIndexAccess numWins[tluaxntlcmvk]
<operator>.indirectIndexAccess dggrtavurlbd[tluaxntlcmvk][j]
<operator>.indirectIndexAccess owp[tluaxntlcmvk]
<operator>.indirectIndexAccess numGames[tluaxntlcmvk]
<operator>.indirectIndexAccess dggrtavurlbd[tluaxntlcmvk][j]
<operator>.indirectIndexAccess oowp[tluaxntlcmvk]
<operator>.indirectIndexAccess numGames[tluaxntlcmvk]
<operator>.indirectIndexAccess owp[tluaxntlcmvk]
<operator>.indirectIndexAccess oowp[tluaxntlcmvk]
<operator>.indirectIndexAccess dggrtavurlbd[tluaxntlcmvk]
<operator>.indirectIndexAccess numGames[j]
<operator>.indirectIndexAccess dggrtavurlbd[tluaxntlcmvk]
<operator>.indirectIndexAccess tpdrjaqsdvbn[tluaxntlcmvk]
<operator>.indirectIndexAccess oowp[tluaxntlcmvk]
<operator>.indirectIndexAccess kcqavalgwabv[j]
<operator>.indirectIndexAccess dggrtavurlbd[tluaxntlcmvk][j]
<operator>.indirectIndexAccess numGames[tluaxntlcmvk]
<operator>.indirectIndexAccess tpdrjaqsdvbn[j]
<operator>.indirectIndexAccess numGames[j]
<operator>.indirectIndexAccess dggrtavurlbd[tluaxntlcmvk][j]
<operator>.indirectIndexAccess dggrtavurlbd[tluaxntlcmvk]
<operator>.indirectIndexAccess dggrtavurlbd[tluaxntlcmvk]
>>>PDG&120 0->2 0->3 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->48 0->52 0->53 0->54 0->57 0->58 0->59 0->61 0->68 0->69 0->70 0->71 0->73 0->75 0->76 0->78 0->80 2->13 3->1 3->14 3->15 4->1 4->1 5->1 5->1 5->7 6->1 6->1 6->11 6->18 7->16 7->22 8->1 8->1 8->1 9->1 9->1 9->18 10->1 10->1 11->1 11->1 12->1 12->1 12->1 12->12 12->17 12->18 12->19 12->20 12->21 12->22 12->23 12->25 12->27 12->30 12->32 12->34 12->37 12->38 12->41 12->43 12->44 12->48 12->52 13->1 13->4 13->4 14->1 14->5 14->5 15->1 15->6 15->6 16->8 16->22 17->1 17->1 17->23 18->1 18->19 18->21 19->20 19->36 20->1 20->11 20->18 21->1 21->1 21->18 22->1 22->10 22->12 22->12 22->12 22->37 22->42 23->23 23->24 23->24 23->25 23->39 23->40 23->57 23->58 23->70 23->84 23->85 23->92 23->93 23->106 24->1 24->23 25->25 25->26 25->26 25->27 25->42 25->53 25->53 25->59 26->1 26->25 27->27 27->28 27->28 27->29 27->30 27->55 27->62 27->81 27->86 27->97 27->98 28->1 28->27 29->1 29->1 29->1 29->68 29->77 30->30 30->31 30->31 30->32 30->45 30->46 30->47 30->63 30->64 30->65 30->73 30->74 30->75 30->79 30->80 30->82 30->87 30->88 30->99 30->100 30->101 30->107 30->108 30->115 30->116 30->117 30->119 31->1 31->30 32->32 32->33 32->33 32->34 32->49 32->50 32->51 32->66 32->67 32->76 32->83 32->89 32->90 32->91 32->102 32->103 32->104 32->109 33->1 33->32 34->1 34->1 34->1 34->34 34->35 34->35 34->36 34->56 34->68 34->69 34->77 34->105 34->110 34->111 35->1 35->34 36->1 36->1 36->20 37->17 37->22 37->42 38->23 39->1 39->1 39->1 39->68 39->77 40->1 40->1 40->1 40->55 40->65 40->67 40->72 41->25 42->22 42->22 42->78 43->27 44->30 45->1 45->1 46->1 46->1 46->65 47->1 47->1 47->1 47->46 47->69 48->32 49->1 49->1 50->1 50->1 50->67 51->1 51->1 51->1 51->50 51->68 51->77 52->1 52->34 53->1 53->1 53->25 53->53 53->54 53->54 53->60 53->71 53->72 53->78 53->94 53->95 53->96 53->112 53->113 53->114 53->118 54->1 54->53 55->1 55->1 55->29 55->29 55->65 55->67 55->72 56->1 56->1 57->1 57->1 57->39 57->46 57->69 58->1 58->40 58->55 58->62 59->1 59->53 60->1 60->1 62->1 63->1 63->45 63->45 63->80 64->1 64->1 64->46 64->46 65->1 65->47 65->47 65->55 65->67 65->72 66->1 66->1 66->49 66->49 66->63 67->1 67->51 67->51 67->55 67->65 67->72 68->1 68->36 68->36 68->56 68->56 69->1 69->36 69->36 69->46 69->56 69->56 70->1 70->39 70->50 70->57 70->68 70->77 71->1 71->1 71->63 71->66 72->1 72->1 72->55 72->65 72->67 73->63 74->1 74->1 74->64 74->64 75->1 75->64 75->64 75->79 76->66 77->1 77->1 78->1 78->22 78->37 78->42 78->60 78->60 79->1 79->74 79->74 79->75 80->1 80->63 80->66 80->74 80->74
>>>Token int main ( int xqhdeztfwtcd , char * * argv ) { assert ( xqhdeztfwtcd == 3 ) ; FILE * inputFile , * outputFile ; int pzyuxbizgidg , numTeams , caseNum ; int tluaxntlcmvk , j , dggrtavurlbd [ MAX_TEAMS ] [ MAX_TEAMS ] , numGames [ MAX_TEAMS ] , numWins [ MAX_TEAMS ] ; char kcqavalgwabv [ 5000 ] , * pch ; double tpdrjaqsdvbn [ MAX_TEAMS ] , owp [ MAX_TEAMS ] , oowp [ MAX_TEAMS ] ; inputFile = fopen ( argv [ 1 ] , " " ) ; outputFile = fopen ( argv [ 2 ] , " " ) ; fgets ( kcqavalgwabv , 5000 , inputFile ) ; pzyuxbizgidg = atoi ( kcqavalgwabv ) ; caseNum = 1 ; while ( fgets ( kcqavalgwabv , 5000 , inputFile ) != NULL ) { numTeams = atoi ( kcqavalgwabv ) ; for ( tluaxntlcmvk = 0 ; tluaxntlcmvk < numTeams ; tluaxntlcmvk ++ ) { tpdrjaqsdvbn [ tluaxntlcmvk ] = owp [ tluaxntlcmvk ] = oowp [ tluaxntlcmvk ] = 0.0 ; numGames [ tluaxntlcmvk ] = numWins [ tluaxntlcmvk ] = 0 ; } for ( tluaxntlcmvk = 0 ; tluaxntlcmvk < numTeams ; tluaxntlcmvk ++ ) { fgets ( kcqavalgwabv , 5000 , inputFile ) ; for ( j = 0 ; j < numTeams ; j ++ ) { dkqotpgjrggu ( kcqavalgwabv [ j ] == ' ' )  { dggrtavurlbd [ tluaxntlcmvk ] [ j ] = 0 ; numGames [ tluaxntlcmvk ] ++ ; } else dkqotpgjrggu ( kcqavalgwabv [ j ] = = ' ' ) { dggrtavurlbd [ tluaxntlcmvk ] [ j ] = 1 ; numGames [ tluaxntlcmvk ] ++ ; numWins [ tluaxntlcmvk ] ++ ; } else dggrtavurlbd [ tluaxntlcmvk ] [ j ] = -1 ; } } for ( tluaxntlcmvk = 0 ; tluaxntlcmvk < numTeams ; tluaxntlcmvk ++ ) tpdrjaqsdvbn [ tluaxntlcmvk ] = ( double ) numWins [ tluaxntlcmvk ] / numGames [ tluaxntlcmvk ] ; for ( tluaxntlcmvk = 0 ; tluaxntlcmvk < numTeams ; tluaxntlcmvk ++ ) { for ( j = 0 ; j < numTeams ; j ++ ) dkqotpgjrggu ( dggrtavurlbd [ tluaxntlcmvk ] [ j ] != -1 ) owp [ tluaxntlcmvk ] += ( ( ( tpdrjaqsdvbn [ j ] * numGames [ j ] ) - ( 1 - dggrtavurlbd [ tluaxntlcmvk ] [ j ] ) ) / ( numGames [ j ] - 1 ) ) ; owp [ tluaxntlcmvk ] = owp [ tluaxntlcmvk ] / numGames [ tluaxntlcmvk ] ; } for ( tluaxntlcmvk = 0 ; tluaxntlcmvk < numTeams ; tluaxntlcmvk ++ ) { for ( j = 0 ; j < numTeams ; j ++ ) dkqotpgjrggu ( dggrtavurlbd [ tluaxntlcmvk ] [ j ] != -1 ) oowp [ tluaxntlcmvk ] += owp [ j ] ; oowp [ tluaxntlcmvk ] = oowp [ tluaxntlcmvk ] / numGames [ tluaxntlcmvk ] ; } fprintf ( outputFile , " \n " , caseNum ) ; fflush ( outputFile ) ; for ( tluaxntlcmvk = 0 ; tluaxntlcmvk < numTeams ; tluaxntlcmvk ++ ) fprintf ( outputFile , " \n " , ( 0.25 * ( tpdrjaqsdvbn [ tluaxntlcmvk ] + oowp [ tluaxntlcmvk ] ) + 0.5 * ( owp [ tluaxntlcmvk ] ) ) ) ; fflush ( outputFile ) ; caseNum ++ ; } fclose ( inputFile ) ; fclose ( outputFile ) ; }
>>>Func
METHOD ufpncwnlkgub
METHOD_RETURN int
PARAM int uuibxorsawfq
PARAM int lrrycbpnarix
RETURN return (uuibxorsawfq>lrrycbpnarix)?uuibxorsawfq:lrrycbpnarix; return (uuibxorsawfq>lrrycbpnarix)?uuibxorsawfq:lrrycbpnarix;
<operator>.conditional (uuibxorsawfq>lrrycbpnarix)?uuibxorsawfq:lrrycbpnarix
<operator>.greaterThan uuibxorsawfq>lrrycbpnarix
>>>PDG&7 0->2 0->3 0->5 0->6 2->6 3->6 4->1 5->1 5->1 5->1 5->1 5->4 6->5 6->5
>>>Token int ufpncwnlkgub ( int uuibxorsawfq , int lrrycbpnarix ) { return ( uuibxorsawfq > lrrycbpnarix ) ? uuibxorsawfq : lrrycbpnarix ; }
>>>Func
METHOD get_val_tab_combine
METHOD_RETURN void*
PARAM void *a
PARAM void *b
<operator>.assignment olsalwegbgar=get_indice(a)
<operator>.assignment cnqxusnygvbf=get_indice(b)
RETURN return pdynrcdljypn[26 *olsalwegbgar+cnqxusnygvbf]; return pdynrcdljypn[26 *olsalwegbgar+cnqxusnygvbf];
get_indice get_indice(a)
get_indice get_indice(b)
<operator>.addition 26 *olsalwegbgar+cnqxusnygvbf
<operator>.multiplication 26 *olsalwegbgar
>>>PDG&11 0->2 0->3 0->6 0->7 0->8 0->9 0->10 2->7 3->8 4->1 4->1 4->10 5->1 5->1 5->9 6->1 7->1 7->4 8->1 8->5 9->1 9->1 10->1 10->9 10->9
>>>Token void * get_val_tab_combine ( void * a , void * b ) { int olsalwegbgar = get_indice ( a ) ; int cnqxusnygvbf = get_indice ( b ) ; return pdynrcdljypn [ 26 * olsalwegbgar + cnqxusnygvbf ] ; }
>>>Func
METHOD powigzfhiszv
METHOD_RETURN int
PARAM int kmuvosdgmdax
PARAM int eibqqoowfqkh
PARAM int srexvxzbmuta
PARAM int harqdmxudvhq
<operator>.assignment dzjaqafzvsjj=-1
<operator>.assignment hqtqiufentru=-1
<operator>.assignment knfbwylqwzvd=-1
tfdrweejsrtw tfdrweejsrtw(!srexvxzbmuta)
RETURN return 0; return 0;
LITERAL 0 return 0;
<operator>.minus -1
<operator>.minus -1
<operator>.minus -1
<operator>.logicalNot !srexvxzbmuta
<operator>.lessThan ncechlnvyxsl<N
<operator>.postIncrement ncechlnvyxsl++
tfdrweejsrtw tfdrweejsrtw(ncechlnvyxsl==knfbwylqwzvd)
UNKNOWN,),)
<operator>.equals ncechlnvyxsl==knfbwylqwzvd
>>>PDG&21 0->2 0->3 0->4 0->5 0->10 0->11 0->12 0->13 0->14 0->15 2->1 3->1 4->15 5->1 6->1 6->1 7->1 7->1 8->1 8->1 8->1 9->1 9->1 10->1 11->10 12->6 13->7 14->8 15->1 15->9 16->1 16->16 16->17 16->18 16->19 16->20
>>>Token int powigzfhiszv ( int kmuvosdgmdax , int eibqqoowfqkh , int srexvxzbmuta , int harqdmxudvhq ) { int ncechlnvyxsl ; int dzjaqafzvsjj = -1 ; int hqtqiufentru = -1 ; int knfbwylqwzvd = -1 ; tfdrweejsrtw ( ! srexvxzbmuta )  return 0 ; for ( ncechlnvyxsl = kmuvosdgmdax + 1 ; ncechlnvyxsl < N ; ncechlnvyxsl ++ ) tfdrweejsrtw ( dist [ ncechlnvyxsl ] > dzjaqafzvsjj )  { dzjaqafzvsjj = dist [ ncechlnvyxsl ] ; knfbwylqwzvd = ncechlnvyxsl ; } for ( ncechlnvyxsl = kmuvosdgmdax + 1 ; ncechlnvyxsl < N ; ncechlnvyxsl ++ ) { tfdrweejsrtw ( ncechlnvyxsl == knfbwylqwzvd ) continue ; tfdrweejsrtw ( dist [ ncechlnvyxsl ] > hqtqiufentru )  hqtqiufentru = dist [ ncechlnvyxsl ] ; } tfdrweejsrtw ( dist [ kmuvosdgmdax ] * 2 - eibqqoowfqkh >= dzjaqafzvsjj * 2 )  return 1 ; else tfdrweejsrtw ( harqdmxudvhq == 0 )  tfdrweejsrtw ( dist [ kmuvosdgmdax ] * 2 - eibqqoowfqkh >= hqtqiufentru * 2 )  return 1 ; return 0 ; }
>>>Func
METHOD kkvouvwslejn
METHOD_RETURN int
PARAM const kvurkhbrzgtb*fname
PARAM struct vsikrzlzctee*W
<operator>.assignment *fp=fopen(fname,"wt")
<operator>.assignment cczhtzipkrxq=max(W->dim1>>3,2)
<operator>.lessThan icbansgvlpyz<W->dim1
<operator>.postIncrement icbansgvlpyz++
fclose fclose(fp)
RETURN return 0; return 0;
<operator>.logicalNot !fp
LITERAL 0 return 0;
fopen fopen(fname,"wt")
sprintf sprintf(hrvbimslakpi "File error (%s): ",fname)
perror perror(hrvbimslakpi)
RETURN return -1; return -1;
max max(W->dim1>>3,2)
<operator>.minus -1
<operator>.arithmeticShiftRight W->dim1>>3
UNKNOWN otejtfmrnjye(int icbansgvlpyz=0; otejtfmrnjye(int icbansgvlpyz=0;
UNKNOWN + +
UNKNOWN,){otejtfmrnjye(int oyrltinttqde=0;oyrltinttqde<W->dim2;oyrltinttqde++){double duczbfrgechn=0.f;int mpniadhearcw;int esyulixgxgle=max(0,icbansgvlpyz-cczhtzipkrxq);int bsitsaxdhmpn=min(W->dim1,icbansgvlpyz+cczhtzipkrxq+1);int nqmpjbdilcwd=max(0,oyrltinttqde-cczhtzipkrxq);int qeetfutvtgyh=min(W->dim2,oyrltinttqde+cczhtzipkrxq+1);int yaqkucgczljv;def aftkkstdcsqindif otejtfmrnjye(yaqkucgczljv<missing')'>=esyulixgxgle;yaqkucgczljv<bsitsaxdhmpn;yaqkucgczljv++){otejtfmrnjye(int pofjxexdyiuf=nqmpjbdilcwd;pofjxexdyiuf<qeetfutvtgyh;pofjxexdyiuf++){double hsomptnumnlf=0.f;otejtfmrnjye(mpniadhearcw=0;mpniadhearcw<W->dim3;mpniadhearcw++){double *w1=kohonen_data_3d(W,icbansgvlpyz,oyrltinttqde,mpniadhearcw);double *w2=kohonen_data_3d(W,yaqkucgczljv,pofjxexdyiuf,mpniadhearcw);hsomptnumnlf+=(w1[0]-w2[0])*(w1[0]-w2[0]);}duczbfrgechn+=sqrt(hsomptnumnlf);}}duczbfrgechn/=cczhtzipkrxq *cczhtzipkrxq;fprintf(fp,"%.4g",duczbfrgechn);if(oyrltinttqde<W->dim2-1)fputc(',',fp);}if(icbansgvlpyz<W->dim1-1)fputc('\n',fp);},){otejtfmrnjye(int oyrltinttqde=0;oyrltinttqde<W->dim2;oyrltinttqde++){double duczbfrgechn=0.f;int mpniadhearcw;int esyulixgxgle=max(0,icbansgvlpyz-cczhtzipkrxq);int bsitsaxdhmpn=min(W->dim1,icbansgvlpyz+cczhtzipkrxq+1);int nqmpjbdilcwd=max(0,oyrltinttqde-cczhtzipkrxq);int qeetfutvtgyh=min(W->dim2,oyrltinttqde+cczhtzipkrxq+1);int yaqkucgczljv;def aftkkstdcsqindif otejtfmrnjye(yaqkucgczljv<missing')'>=esyulixgxgle;yaqkucgczljv<bsitsaxdhmpn;yaqkucgczljv++){otejtfmrnjye(int pofjxexdyiuf=nqmpjbdilcwd;pofjxexdyiuf<qeetfutvtgyh;pofjxexdyiuf++){double hsomptnumnlf=0.f;otejtfmrnjye(mpniadhearcw=0;mpniadhearcw<W->dim3;mpniadhearcw++){double *w1=kohonen_data_3d(W,icbansgvlpyz,oyrltinttqde,mpniadhearcw);double *w2=kohonen_data_3d(W,yaqkucgczljv,pofjxexdyiuf,mpniadhearcw);hsomptnumnlf+=(w1[0]-w2[0])*(w1[0]-w2[0]);}duczbfrgechn+=sqrt(hsomptnumnlf);}}duczbfrgechn/=cczhtzipkrxq *cczhtzipkrxq;fprintf(fp,"%.4g",duczbfrgechn);if(oyrltinttqde<W->dim2-1)fputc(',',fp);}if(icbansgvlpyz<W->dim1-1)fputc('\n',fp);}
<operator>.indirectFieldAccess W->dim1
FIELD_IDENTIFIER dim1 dim1
<operator>.indirectFieldAccess W->dim1
FIELD_IDENTIFIER dim1 dim1
>>>PDG&26 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 2->12 3->1 4->1 4->1 4->10 6->7 9->1 10->1 10->1 10->5 10->6 10->7 10->8 10->8 10->9 10->13 10->14 10->15 10->16 10->17 10->18 10->19 10->20 10->21 10->22 10->23 10->24 10->25 11->9 12->4 12->4 12->13 13->1 13->1 13->14 14->1 14->1 15->1 16->5 16->5 17->1 17->15 18->6 18->16 18->16
>>>Token int kkvouvwslejn ( const kvurkhbrzgtb * fname , struct vsikrzlzctee * W ) { FILE * fp = fopen ( fname , " " ) ; if ( ! fp ) { kvurkhbrzgtb hrvbimslakpi [ 120 ] ; sprintf ( hrvbimslakpi , " " , fname ) ; perror ( hrvbimslakpi ) ; return -1 ; } int cczhtzipkrxq = max ( W -> dim1 >> 3 , 2 ) ; otejtfmrnjye ( int  icbansgvlpyz = 0 ; icbansgvlpyz < W -> dim1 ; icbansgvlpyz ++ ) { otejtfmrnjye ( int  oyrltinttqde = 0 ; oyrltinttqde < W -> dim2 ; oyrltinttqde ++ ) { double duczbfrgechn = 0.f ; int mpniadhearcw ; int esyulixgxgle = max ( 0 , icbansgvlpyz - cczhtzipkrxq ) ; int bsitsaxdhmpn = min ( W -> dim1 , icbansgvlpyz + cczhtzipkrxq + 1 ) ; int nqmpjbdilcwd = max ( 0 , oyrltinttqde - cczhtzipkrxq ) ; int qeetfutvtgyh = min ( W -> dim2 , oyrltinttqde + cczhtzipkrxq + 1 ) ; int yaqkucgczljv ; def aftkkstdcsqindif  otejtfmrnjye ( yaqkucgczljv < missing ' ' >= esyulixgxgle  ; yaqkucgczljv < bsitsaxdhmpn ; yaqkucgczljv ++ ) { otejtfmrnjye ( int  pofjxexdyiuf = nqmpjbdilcwd ; pofjxexdyiuf < qeetfutvtgyh ; pofjxexdyiuf ++ ) { double hsomptnumnlf = 0.f ; otejtfmrnjye ( mpniadhearcw = 0  ; mpniadhearcw < W -> dim3 ; mpniadhearcw ++ ) { double * w1 = kohonen_data_3d ( W , icbansgvlpyz , oyrltinttqde , mpniadhearcw ) ; double * w2 = kohonen_data_3d ( W , yaqkucgczljv , pofjxexdyiuf , mpniadhearcw ) ; hsomptnumnlf += ( w1 [ 0 ] - w2 [ 0 ] ) * ( w1 [ 0 ] - w2 [ 0 ] ) ; } duczbfrgechn += sqrt ( hsomptnumnlf ) ; } } duczbfrgechn /= cczhtzipkrxq * cczhtzipkrxq ; fprintf ( fp , " " , duczbfrgechn ) ; if ( oyrltinttqde < W -> dim2 - 1 ) fputc ( ' ' , fp ) ; } if ( icbansgvlpyz < W -> dim1 - 1 ) fputc ( ' \n ' , fp ) ; } fclose ( fp ) ; return 0 ; }
>>>Func
METHOD fbgmxrppeuacset_file_list
METHOD_RETURN ANY
PARAM char **list
<operator>.assignment have_read_stdin=false
<operator>.logicalNot !list
<operator>.assignment eqrnelfrmmyq=stdin_argv
<operator>.assignment eqrnelfrmmyq =list
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->4 3->1 3->1 3->1 4->1 4->1 4->5 4->6 4->6 5->1 5->1 5->1
>>>Token extern fbgmxrppeuacset_file_list ( char * * list )  { have_read_stdin = false ; if ( ! list ) eqrnelfrmmyq = stdin_argv ; else eqrnelfrmmyq = list ; }
>>>Func
METHOD vrvnddfryszt
METHOD_RETURN void
PARAM char xsbzfzskwepl
sumOpposite sumOpposite(xsbzfzskwepl,-1)
<operator>.minus -1
>>>PDG&5 0->2 0->3 0->4 2->3 3->1 3->1 3->1 4->3
>>>Token void vrvnddfryszt ( char xsbzfzskwepl ) { sumOpposite ( xsbzfzskwepl , -1 ) ; }
>>>Func
METHOD ylscrzqbsgke
METHOD_RETURN int
PARAM a
PARAM b
RETURN return (b>a?ylscrzqbsgke(b,a):(b==0?a:ylscrzqbsgke(b,a%b))); return (b>a?ylscrzqbsgke(b,a):(b==0?a:ylscrzqbsgke(b,a%b)));
<operator>.conditional b>a?ylscrzqbsgke(b,a):(b==0?a:ylscrzqbsgke(b,a%b))
<operator>.greaterThan b>a
ylscrzqbsgke ylscrzqbsgke(b,a)
<operator>.conditional b==0?a:ylscrzqbsgke(b,a%b)
<operator>.equals b==0
ylscrzqbsgke ylscrzqbsgke(b,a%b)
<operator>.modulo a%b
>>>PDG&12 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->6 3->6 4->1 5->1 5->1 5->1 5->1 5->4 6->5 6->7 6->7 6->7 6->8 6->8 6->9 6->9 6->11 7->1 7->1 7->5 7->5 8->1 8->1 8->1 9->1 9->10 9->11 9->11 10->1 10->1 10->5 10->5 10->8 10->8 11->5 11->8 11->10 11->10
>>>Token int ylscrzqbsgke ( a , b ) { return ( b > a ? ylscrzqbsgke ( b , a ) : ( b == 0 ? a : ylscrzqbsgke ( b , a % b ) ) ) ; }
>>>Func
METHOD dhgdkhmvcibz
METHOD_RETURN void
PARAM int *a
PARAM int epmrhtqyjxkm
PARAM int brfuhslbvqkp
<operator>.assignment temp=a[epmrhtqyjxkm]
<operator>.assignment uekbuaobpjcv=2 *epmrhtqyjxkm
<operator>.assignment a[uekbuaobpjcv/2]=temp
RETURN return ; return ;
<operator>.lessEqualsThan uekbuaobpjcv<=brfuhslbvqkp
<operator>.multiplication 2 *epmrhtqyjxkm
uimvcvpggwac uimvcvpggwac(uekbuaobpjcv<brfuhslbvqkp&&a[uekbuaobpjcv+1]>a[uekbuaobpjcv])
<operator>.assignment uekbuaobpjcv=uekbuaobpjcv+1
uimvcvpggwac uimvcvpggwac(temp>a[uekbuaobpjcv])
<operator>.division uekbuaobpjcv/2
<operator>.logicalAnd uekbuaobpjcv<brfuhslbvqkp&&a[uekbuaobpjcv+1]>a[uekbuaobpjcv]
<operator>.addition uekbuaobpjcv+1
<operator>.greaterThan temp>a[uekbuaobpjcv]
<operator>.lessThan uekbuaobpjcv<brfuhslbvqkp
<operator>.greaterThan a[uekbuaobpjcv+1]>a[uekbuaobpjcv]
<operator>.addition uekbuaobpjcv+1
UNKNOWN,),)
UNKNOWN,),)
<operator>.indirectIndexAccess a[uekbuaobpjcv]
<operator>.indirectIndexAccess a[uekbuaobpjcv+1]
<operator>.indirectIndexAccess a[uekbuaobpjcv]
>>>PDG&26 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->12 0->14 0->16 0->17 0->18 0->20 2->1 2->5 2->17 2->19 3->10 4->9 5->1 5->1 5->7 5->17 6->1 6->1 6->9 7->1 7->1 7->1 8->1 9->1 9->1 9->11 9->12 9->13 9->14 9->15 9->16 9->17 9->18 9->18 9->18 9->21 9->22 9->23 10->1 10->6 10->6 11->1 11->1 12->1 12->1 12->14 13->1 13->1 14->1 15->1 15->1 15->11 15->11 17->1 17->7 17->13 17->13 18->1 18->12 18->15 18->15 18->16 18->19 18->20 18->20 18->24 18->25 19->1 19->15 19->15 19->17
>>>Token void dhgdkhmvcibz ( int * a , int epmrhtqyjxkm , int brfuhslbvqkp ) { int uekbuaobpjcv , temp ; temp = a [ epmrhtqyjxkm ] ; uekbuaobpjcv = 2 * epmrhtqyjxkm ; while ( uekbuaobpjcv <= brfuhslbvqkp ) { uimvcvpggwac ( uekbuaobpjcv < brfuhslbvqkp && a [ uekbuaobpjcv + 1 ] > a [ uekbuaobpjcv ] )  uekbuaobpjcv = uekbuaobpjcv + 1 ; uimvcvpggwac ( temp > a [ uekbuaobpjcv ] )  { break ; } else uimvcvpggwac ( temp <= a [ uekbuaobpjcv ] ) { a [ uekbuaobpjcv / 2 ] = a [ uekbuaobpjcv ] ; uekbuaobpjcv = 2 * uekbuaobpjcv ; } } a [ uekbuaobpjcv / 2 ] = temp ; return ; }
>>>Func
METHOD bbbqntzwrvgj
METHOD_RETURN int
PARAM void *a
PARAM void *b
RETURN return *((int *)b)-*((int *)a); return *((int *)b)-*((int *)a);
<operator>.subtraction *((int *)b)-*((int *)a)
<operator>.cast (int *)b
<operator>.cast (int *)a
>>>PDG&8 0->2 0->3 0->6 0->7 2->7 3->6 4->1 5->1 5->1 5->1 5->4 6->1 7->1
>>>Token int bbbqntzwrvgj ( void * a , void * b ) { return * ( ( int * ) b ) - * ( ( int * ) a ) ; }
>>>Func
METHOD uydmjlmwyfut
METHOD_RETURN void
PARAM int jjdwdsijgzld
PARAM int fkfhzfyivxgh
<operator>.assignment fdpymfobrcqi=1
<operator>.assignment kkumsnoqcwic=jjdwdsijgzld
<operator>.logicalOr jjdwdsijgzld==fkfhzfyivxgh+1||(fkfhzfyivxgh==n&&jjdwdsijgzld==1)
LITERAL 1 while (1)
<operator>.lessThan fdpymfobrcqi<barev
RETURN return ; return ;
<operator>.assignment zjulunzvgkzn=nextv(jjdwdsijgzld,fkfhzfyivxgh)
<operator>.postIncrement fdpymfobrcqi++
<operator>.assignment jjdwdsijgzld=fkfhzfyivxgh
<operator>.assignment fkfhzfyivxgh=zjulunzvgkzn
uydmjlmwyfut uydmjlmwyfut(fkfhzfyivxgh,jjdwdsijgzld)
<operator>.assignment barev=fdpymfobrcqi
<operator>.equals jjdwdsijgzld==fkfhzfyivxgh+1
<operator>.logicalAnd fkfhzfyivxgh==n&&jjdwdsijgzld==1
<operator>.equals fkfhzfyivxgh==kkumsnoqcwic
<operator>.addition fkfhzfyivxgh+1
<operator>.equals fkfhzfyivxgh==n
<operator>.equals jjdwdsijgzld==1
nextv nextv(jjdwdsijgzld,fkfhzfyivxgh)
>>>PDG&23 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 2->5 2->16 3->16 3->18 3->19 3->20 4->1 4->1 4->8 4->11 5->1 5->1 5->18 6->1 6->1 6->1 6->8 6->9 6->18 8->15 8->15 9->1 10->13 11->8 12->14 13->14 14->18 14->22 16->1 16->1 16->6 16->6 16->17 16->20 16->21 16->22 17->1 17->1 17->6 17->6 18->10 18->11 18->12 18->13 18->14 18->18 18->22 18->22 19->1 20->1 20->1 20->17 20->17 20->18 20->21 21->1 21->17 21->17 21->22 22->10 22->10 22->12
>>>Token void uydmjlmwyfut ( int jjdwdsijgzld , int fkfhzfyivxgh ) { int fdpymfobrcqi = 1 ; int kkumsnoqcwic = jjdwdsijgzld ; int zjulunzvgkzn ; if ( jjdwdsijgzld == fkfhzfyivxgh + 1 || ( fkfhzfyivxgh == n && jjdwdsijgzld == 1 ) ) { return ; } while ( 1 ) { if ( fkfhzfyivxgh == kkumsnoqcwic ) { break ; } zjulunzvgkzn = nextv ( jjdwdsijgzld , fkfhzfyivxgh ) ; fdpymfobrcqi ++ ; jjdwdsijgzld = fkfhzfyivxgh ; fkfhzfyivxgh = zjulunzvgkzn ; uydmjlmwyfut ( fkfhzfyivxgh , jjdwdsijgzld ) ; } if ( fdpymfobrcqi < barev ) { barev = fdpymfobrcqi ; } }
>>>Func
METHOD sklilfhaqrmx
METHOD_RETURN void
PARAM void
<operator>.assignment ytjhizwipcwe=backtrace(buf,4096)
backtrace_symbols_fd backtrace_symbols_fd(buf,ytjhizwipcwe,1)
RETURN return ; return ;
backtrace backtrace(buf,4096)
>>>PDG&7 0->2 0->4 0->5 0->6 2->1 3->1 3->1 3->4 4->1 4->1 4->1 5->1 6->3 6->3 6->4
>>>Token void sklilfhaqrmx ( void ) { int ytjhizwipcwe ; void * buf [ 4096 ] ; ytjhizwipcwe = backtrace ( buf , 4096 ) ; backtrace_symbols_fd ( buf , ytjhizwipcwe , 1 ) ; return ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int eapfqqfxipct
PARAM char *argv [ ]
<operator>.assignment fbhlujdwobqz=0
printf printf("Sum is: %d\n",fbhlujdwobqz)
RETURN return 0; return 0;
<operator>.lessThan dhnzszflmfuc<eapfqqfxipct
<operator>.postIncrement dhnzszflmfuc++
LITERAL 0 return 0;
<operator>.assignment dhnzszflmfuc=0
<operator>.assignmentPlus fbhlujdwobqz+=dhnzszflmfuc
<operator>.lessThan fbhlujdwobqz<127
<operator>.assignmentPlus fbhlujdwobqz+=64
>>>PDG&14 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->7 3->1 4->1 4->5 4->12 5->1 5->1 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->11 7->11 7->12 8->1 8->7 9->6 10->1 10->7 11->1 11->5 11->12 12->1 12->11 12->13 12->13 13->1 13->11
>>>Token int main ( int eapfqqfxipct , char * argv [ ] ) { int dhnzszflmfuc ; int fbhlujdwobqz = 0 ; for ( dhnzszflmfuc = 0 ; dhnzszflmfuc < eapfqqfxipct ; dhnzszflmfuc ++ ) { if ( fbhlujdwobqz < 127 ) { fbhlujdwobqz += 64 ; } fbhlujdwobqz += dhnzszflmfuc ; } printf ( " \n " , fbhlujdwobqz ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment caseno=1
gets gets(t)
sscanf sscanf(t,"%d",&mayohevatcsh)
RETURN return 0; return 0;
<operator>.postDecrement mayohevatcsh--
LITERAL 0 return 0;
gets gets(t)
sscanf sscanf(t,"%d",&k)
memset memset(dia -1 sizeof(dia))
<operator>.assignment ans=0
<operator>.assignment ex=0
solve solve()
<operator>.assignment l=2 *k-1
memcpy memcpy(s u sizeof(s))
solve solve()
<operator>.assignmentPlus ex+=k
<operator>.assignment ans=ex *ex-k *k
printf printf("Case #%d: %d\n",caseno++,ans)
<operator>.lessThan i<2 *k-1
<operator>.postIncrement i++
gets gets(s[i])
<operator>.lessThan i<k
<operator>.postIncrement i++
<operator>.lessThan i<2 *k-1
<operator>.postIncrement i++
<operator>.lessThan i<2 *k-1
<operator>.postIncrement i++
<operator>.lessThan i<k
<operator>.postIncrement i++
<operator>.lessThan i<2 *k-1
<operator>.postIncrement i++
<operator>.minus -1
<operator>.assignment i=0
<operator>.assignment i=0
<operator>.assignment i=k
<operator>.assignment m=2 *k-i
<operator>.subtraction 2 *k-1
<operator>.assignment i=0
<operator>.lessThan j<2 *k-1
<operator>.postIncrement j++
<operator>.assignment i=0
<operator>.assignment i=k
<operator>.assignment m=2 *k-i
<operator>.subtraction ex *ex-k *k
<operator>.postIncrement caseno++
<operator>.subtraction 2 *k-1
<operator>.lessEqualsThan j<=i
<operator>.postIncrement j++
<operator>.assignment dia[i][j]=s[i][k-i-1+j *2]-'0'
<operator>.subtraction 2 *k-1
<operator>.lessThan j<m
<operator>.postIncrement j++
<operator>.multiplication 2 *k
<operator>.subtraction 2 *k-1
<operator>.assignment j=0
<operator>.assignment u[l-1-j][i]=s[i][j]
<operator>.lessEqualsThan j<=i
<operator>.postIncrement j++
<operator>.assignment dia[i][j]=s[i][k-i-1+j *2]-'0'
<operator>.subtraction 2 *k-1
<operator>.lessThan j<m
<operator>.postIncrement j++
<operator>.multiplication ex *ex
<operator>.multiplication k *k
<operator>.multiplication 2 *k
<operator>.assignment j=0
<operator>.multiplication 2 *k
<operator>.subtraction 2 *k-i
<operator>.assignment j=0
<operator>.assignment dia[i][j]=s[i][i-k+j *2+1]-'0'
<operator>.multiplication 2 *k
<operator>.subtraction 2 *k-1
<operator>.assignment j=0
<operator>.multiplication 2 *k
<operator>.subtraction 2 *k-i
<operator>.assignment j=0
<operator>.assignment dia[i][j]=s[i][i-k+j *2+1]-'0'
<operator>.subtraction s[i][k-i-1+j *2]-'0'
<operator>.multiplication 2 *k
<operator>.multiplication 2 *k
<operator>.subtraction s[i][k-i-1+j *2]-'0'
<operator>.multiplication 2 *k
<operator>.subtraction s[i][i-k+j *2+1]-'0'
<operator>.subtraction s[i][i-k+j *2+1]-'0'
<operator>.addition k-i-1+j *2
<operator>.subtraction l-1-j
<operator>.addition k-i-1+j *2
<operator>.subtraction k-i-1
<operator>.multiplication j *2
<operator>.addition i-k+j *2+1
<operator>.subtraction l-1
<operator>.subtraction k-i-1
<operator>.multiplication j *2
<operator>.addition i-k+j *2+1
<operator>.subtraction k-i
<operator>.addition i-k+j *2
<operator>.subtraction k-i
<operator>.addition i-k+j *2
<operator>.subtraction i-k
<operator>.multiplication j *2
<operator>.subtraction i-k
<operator>.multiplication j *2
<operator>.addressOf &k
<operator>.sizeOf sizeof(dia)
<operator>.sizeOf sizeof(s)
<operator>.indirectIndexAccess s[i]
<operator>.indirectIndexAccess dia[i][j]
<operator>.indirectIndexAccess u[l-1-j][i]
<operator>.indirectIndexAccess s[i][j]
<operator>.indirectIndexAccess dia[i][j]
<operator>.indirectIndexAccess dia[i]
<operator>.indirectIndexAccess s[i][k-i-1+j *2]
<operator>.indirectIndexAccess dia[i][j]
<operator>.indirectIndexAccess u[l-1-j]
<operator>.indirectIndexAccess s[i]
<operator>.indirectIndexAccess dia[i]
<operator>.indirectIndexAccess s[i][k-i-1+j *2]
<operator>.indirectIndexAccess dia[i][j]
<operator>.indirectIndexAccess s[i]
<operator>.indirectIndexAccess dia[i]
<operator>.indirectIndexAccess s[i][i-k+j *2+1]
<operator>.indirectIndexAccess s[i]
<operator>.indirectIndexAccess dia[i]
<operator>.indirectIndexAccess s[i][i-k+j *2+1]
<operator>.indirectIndexAccess s[i]
<operator>.indirectIndexAccess s[i]
>>>PDG&128 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->19 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->43 0->46 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->56 0->58 0->59 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->72 0->73 0->74 0->75 0->76 0->77 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->87 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->98 0->100 0->101 0->102 0->103 2->1 2->1 2->46 3->1 3->4 4->1 4->1 4->1 4->6 4->8 5->1 6->1 6->1 6->6 6->8 6->9 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->20 6->23 6->25 6->27 6->29 6->31 6->33 6->34 6->35 6->36 6->38 6->39 6->42 6->43 6->45 6->46 6->47 6->51 6->54 6->55 6->61 6->64 6->65 6->66 6->68 6->72 6->75 6->104 6->105 6->106 7->5 8->1 8->9 9->1 9->1 9->1 9->8 9->17 9->23 9->29 9->36 9->43 9->54 9->65 9->66 9->68 9->72 9->75 9->80 9->81 9->83 9->96 9->98 9->100 9->102 10->1 10->1 10->1 11->1 12->1 12->17 14->1 14->1 14->92 15->1 15->1 15->1 15->22 16->1 17->1 17->64 18->1 18->1 18->19 19->1 19->1 19->1 20->20 20->21 20->21 20->22 20->47 20->66 20->107 21->1 21->20 22->1 22->1 22->15 23->23 23->24 23->36 23->48 23->48 23->67 23->68 23->96 24->1 24->23 25->25 25->26 25->37 25->51 25->52 25->68 25->69 25->69 25->70 25->80 26->1 26->25 27->27 27->28 27->28 27->40 27->55 27->56 27->72 27->73 27->81 28->1 28->27 29->1 29->29 29->30 29->43 29->58 29->58 29->74 29->75 29->98 30->1 30->29 31->1 31->1 31->1 31->31 31->32 31->44 31->61 31->62 31->75 31->76 31->76 31->77 31->83 32->1 32->31 33->10 34->20 35->23 36->25 37->1 37->1 37->52 38->14 38->14 39->27 40->1 40->1 40->40 40->41 40->57 40->73 40->81 40->87 40->87 40->92 40->109 40->110 40->115 40->116 41->1 41->40 42->1 42->29 43->1 43->31 44->1 44->1 44->62 45->1 45->1 45->18 45->18 46->1 46->19 47->20 47->20 48->1 48->1 48->24 48->48 48->49 48->50 48->79 48->86 48->89 48->90 48->90 48->96 48->96 48->108 48->112 48->113 48->120 49->1 49->48 50->1 50->1 50->1 51->25 51->25 52->1 52->1 52->1 52->52 52->53 52->71 52->84 52->91 52->97 52->100 52->101 52->101 52->114 52->121 52->122 52->126 53->1 53->52 54->38 54->38 54->72 55->27 55->27 56->1 56->40 57->1 57->1 57->1 58->1 58->1 58->30 58->58 58->59 58->60 58->82 58->88 58->93 58->94 58->94 58->98 58->98 58->111 58->117 58->118 58->123 59->1 59->58 60->1 60->1 60->1 61->1 61->31 61->31 62->1 62->1 62->1 62->62 62->63 62->78 62->85 62->95 62->99 62->102 62->103 62->103 62->119 62->124 62->125 62->127 63->1 63->62 64->1 64->45 65->1 65->9 65->45 65->66 66->23 66->47 66->47 67->1 67->48 68->51 68->51 68->54 68->80 69->26 69->37 69->37 69->100 70->1 70->52 71->1 71->1 71->1 72->29 72->55 72->55 72->81 73->40 73->40 74->1 74->58 75->17 75->61 75->61 75->65 75->83 76->32 76->44 76->44 76->102 77->1 77->62 78->1 78->1 78->1 79->1 79->22 79->50 79->50 79->82 80->68 80->69 80->69 80->100 81->72 81->73 81->73 82->1 82->22 82->60 82->60 82->79 83->75 83->76 83->76 83->102 84->1 84->22 84->71 84->71 84->85 85->1 85->22 85->78 85->78 85->84 86->1 86->1 87->1 87->41 88->1 88->1 89->1 89->86 89->86 90->49 90->86 90->86 91->1 92->1 92->87 92->87 93->1 93->88 93->88 94->59 94->88 94->88 95->1 96->23 96->48 96->89 96->89 97->1 97->1 98->29 98->58 98->93 98->93 99->1 99->1 100->26 100->68 100->91 100->91 100->97 100->97 101->53 101->91 101->91 101->97 101->97 102->32 102->75 102->95 102->95 102->99 102->99 103->63 103->95 103->95 103->99 103->99
>>>Token int main ( ) { int mayohevatcsh , caseno = 1 , i , j , l , m ; gets ( t ) ; sscanf ( t , " " , & mayohevatcsh ) ; while ( mayohevatcsh -- ) { gets ( t ) ; sscanf ( t , " " , & k ) ; memset ( dia , -1 , sizeof ( dia ) ) ; for ( i = 0 ; i < 2 * k - 1 ; i ++ ) gets ( s [ i ] ) ; for ( i = 0 ; i < k ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) dia [ i ] [ j ] = s [ i ] [ k - i - 1 + j * 2 ] - ' ' ; } for ( i = k ; i < 2 * k - 1 ; i ++ ) { m = 2 * k - i ; for ( j = 0 ; j < m ; j ++ ) { dia [ i ] [ j ] = s [ i ] [ i - k + j * 2 + 1 ] - ' ' ; } } ans = 0 ; ex = 0 ; solve ( ) ; l = 2 * k - 1 ; for ( i = 0 ; i < 2 * k - 1 ; i ++ ) for ( j = 0 ; j < 2 * k - 1 ; j ++ ) { u [ l - 1 - j ] [ i ] = s [ i ] [ j ] ; } memcpy ( s , u , sizeof ( s ) ) ; for ( i = 0 ; i < k ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) dia [ i ] [ j ] = s [ i ] [ k - i - 1 + j * 2 ] - ' ' ; } for ( i = k ; i < 2 * k - 1 ; i ++ ) { m = 2 * k - i ; for ( j = 0 ; j < m ; j ++ ) { dia [ i ] [ j ] = s [ i ] [ i - k + j * 2 + 1 ] - ' ' ; } } solve ( ) ; ex += k ; ans = ex * ex - k * k ; printf ( " \n " , caseno ++ , ans ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int kcpifesjbxyq
PARAM char *argv [ ]
<operator>.assignment pjjfcysqufyp=0
<operator>.assignment cas=1
<operator>.assignment mjfinqnmiwby=0
<operator>.assignment q=0
<operator>.assignment g=0
<operator>.assignment d=0
<operator>.assignment n=0
<operator>.assignment wd=0
<operator>.assignment wg=0
<operator>.assignment udwheuupuhkg=0
<operator>.assignment pg=0
<operator>.assignment k=0
scanf scanf("%d",&pjjfcysqufyp)
RETURN return 0; return 0;
<operator>.postDecrement pjjfcysqufyp--
LITERAL 0 return 0;
scanf scanf("%d %d %d",&n,&udwheuupuhkg,&pg)
<operator>.assignment tqpsxqmkoxsj=0
<operator>.equals pg==100
<operator>.equals pg==0
<operator>.lessEqualsThan pisjddjqgqdw<=n
<operator>.postIncrement pisjddjqgqdw++
<operator>.equals tqpsxqmkoxsj==0
<operator>.assignment pisjddjqgqdw=1
<operator>.assignment d=pisjddjqgqdw
printf printf("Case #%d: Broken\n",cas++)
<operator>.notEquals udwheuupuhkg!=100
<operator>.notEquals udwheuupuhkg!=0
<operator>.equals d *udwheuupuhkg%100==0
<operator>.assignment wd=d *udwheuupuhkg/100
<operator>.assignment g=gcd(pg,100)
<operator>.assignment mjfinqnmiwby=pg/g
<operator>.assignment q=100/g
<operator>.assignment k=divv((d-wd) (q-mjfinqnmiwby))
<operator>.assignment wg=k *mjfinqnmiwby
<operator>.assignment g=k *q
printf printf("Case #%d: Broken\n",cas++)
printf printf("Case #%d: Broken\n",cas++)
<operator>.assignment tqpsxqmkoxsj=1
<operator>.postIncrement cas++
<operator>.greaterThan divv(d,q)>k
<operator>.greaterThan divv(wd,mjfinqnmiwby)>k
<operator>.logicalAnd wd<=d&&wg<=g&&wd<=wg&&d<=g
printf printf("Case #%d: Possible\n",cas++)
printf printf("Case #%d: Possible\n",cas++)
<operator>.modulo d *udwheuupuhkg%100
<operator>.division d *udwheuupuhkg/100
gcd gcd(pg,100)
<operator>.division pg/g
<operator>.division 100/g
divv divv((d-wd) (q-mjfinqnmiwby))
<operator>.assignment k=divv(d,q)
<operator>.assignment k=divv(wd,mjfinqnmiwby)
<operator>.multiplication k *mjfinqnmiwby
<operator>.multiplication k *q
printf printf("Case #%d: Possible\n",cas++)
<operator>.postIncrement cas++
<operator>.postIncrement cas++
<operator>.multiplication d *udwheuupuhkg
<operator>.multiplication d *udwheuupuhkg
<operator>.subtraction d-wd
<operator>.subtraction q-mjfinqnmiwby
divv divv(d,q)
divv divv(wd,mjfinqnmiwby)
<operator>.logicalAnd wd<=d&&wg<=g&&wd<=wg
<operator>.lessEqualsThan d<=g
printf printf("Case #%d: Broken\n",cas++)
<operator>.postIncrement cas++
<operator>.postIncrement cas++
divv divv(d,q)
divv divv(wd,mjfinqnmiwby)
<operator>.logicalAnd wd<=d&&wg<=g
<operator>.lessEqualsThan wd<=wg
<operator>.postIncrement cas++
<operator>.lessEqualsThan wd<=d
<operator>.lessEqualsThan wg<=g
<operator>.postIncrement cas++
<operator>.addressOf &n
<operator>.addressOf &udwheuupuhkg
<operator>.addressOf &pg
>>>PDG&84 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->40 0->41 0->42 0->43 0->44 0->45 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->69 0->70 0->71 0->72 0->73 0->74 0->76 0->77 0->78 0->79 0->80 2->1 3->1 4->1 4->16 4->18 5->1 5->1 5->43 5->60 5->61 5->71 5->72 5->77 5->80 6->1 6->1 7->1 7->1 8->1 8->1 9->1 9->1 9->63 10->1 10->1 10->20 10->24 11->1 11->1 12->1 12->1 13->1 13->1 13->30 13->31 13->62 13->63 14->1 14->1 14->22 15->1 15->1 16->1 16->18 17->1 18->1 18->1 18->18 18->20 18->22 18->81 18->82 18->83 19->17 20->1 20->1 20->1 20->24 21->1 21->26 22->1 22->1 22->23 22->23 22->30 23->1 23->1 23->21 23->22 23->24 23->26 23->27 23->31 23->51 24->1 24->1 24->1 24->20 24->25 24->28 24->28 24->32 24->49 24->62 25->1 25->24 26->1 26->1 26->29 26->33 26->34 26->35 26->36 26->37 26->38 26->39 26->43 26->44 26->45 26->46 26->50 26->51 26->52 26->53 26->54 26->57 26->58 26->63 26->64 26->65 26->66 26->67 26->68 26->75 26->78 27->1 27->24 28->1 28->1 28->62 29->1 29->1 30->1 30->1 30->31 30->40 30->47 30->60 30->62 30->63 30->71 31->1 31->1 31->30 31->41 31->48 31->61 31->62 31->63 31->72 32->1 32->1 32->24 32->25 32->42 33->1 33->1 33->64 34->1 34->1 34->52 35->1 35->1 35->65 36->1 36->1 36->65 37->1 37->1 37->44 38->1 38->1 38->1 38->76 38->79 39->1 39->1 39->1 39->69 39->79 40->1 40->1 41->1 41->1 42->1 42->26 43->1 43->29 43->60 43->61 43->71 43->72 43->77 43->80 44->1 44->1 44->45 44->55 44->73 45->1 45->1 45->56 45->57 45->74 46->1 46->1 46->1 46->59 46->70 46->77 46->80 47->1 47->1 48->1 48->1 49->1 49->32 49->32 50->1 50->33 50->33 51->34 51->34 51->52 52->1 52->22 52->35 52->35 52->53 53->36 53->36 54->1 54->1 54->37 54->37 55->1 55->1 55->45 56->1 56->1 56->57 57->1 57->38 57->38 57->58 58->1 58->1 58->39 58->39 59->1 59->1 60->1 60->40 60->43 60->61 60->71 60->72 60->77 60->80 61->1 61->41 61->43 61->60 61->71 61->72 61->77 61->80 62->1 62->1 62->30 62->31 62->49 62->49 62->63 62->63 63->1 63->30 63->31 63->50 63->50 63->62 63->64 64->54 64->54 64->66 64->67 65->54 65->54 65->66 65->67 66->44 66->44 66->58 66->73 66->73 66->78 67->45 67->45 67->57 67->74 67->74 67->78 68->1 68->1 68->46 68->46 68->69 69->1 69->1 69->46 69->46 69->63 70->1 70->1 71->1 71->43 71->47 71->60 71->61 71->72 71->77 71->80 72->1 72->43 72->48 72->60 72->61 72->71 72->77 72->80 73->55 73->55 73->58 73->78 74->56 74->56 74->57 74->78 75->1 75->1 75->68 75->68 75->76 76->1 76->1 76->68 76->68 77->1 77->43 77->59 77->60 77->61 77->71 77->72 77->80 78->1 78->1 78->63 78->69 78->75 78->75 78->76 78->79 79->1 79->1 79->69 79->75 79->75 79->76 80->1 80->43 80->60 80->61 80->70 80->71 80->72 80->77
>>>Token int main ( int kcpifesjbxyq , char * argv [ ] ) { int pjjfcysqufyp = 0 , cas = 1 ; int mjfinqnmiwby = 0 , q = 0 , g = 0 , d = 0 , n = 0 , wd = 0 , wg = 0 ; int udwheuupuhkg = 0 , pg = 0 , k = 0 ; scanf ( " " , & pjjfcysqufyp ) ; while ( pjjfcysqufyp -- ) { scanf ( " " , & n , & udwheuupuhkg , & pg ) ; if ( pg == 100 ) { if ( udwheuupuhkg != 100 ) { printf ( " \n " , cas ++ ) ; continue ; } else { printf ( " \n " , cas ++ ) ; continue ; } } if ( pg == 0 ) { if ( udwheuupuhkg != 0 ) { printf ( " \n " , cas ++ ) ; continue ; } else { printf ( " \n " , cas ++ ) ; continue ; } } int tqpsxqmkoxsj = 0 ; for ( int pisjddjqgqdw = 1 ; pisjddjqgqdw <= n ; pisjddjqgqdw ++ ) { d = pisjddjqgqdw ; if ( d * udwheuupuhkg % 100 == 0 ) { tqpsxqmkoxsj = 1 ; break ; } } if ( tqpsxqmkoxsj == 0 ) { printf ( " \n " , cas ++ ) ; } else { wd = d * udwheuupuhkg / 100 ; g = gcd ( pg , 100 ) ; mjfinqnmiwby = pg / g ; q = 100 / g ; k = divv ( ( d - wd ) , ( q - mjfinqnmiwby ) ) ; if ( divv ( d , q ) > k ) { k = divv ( d , q ) ; } if ( divv ( wd , mjfinqnmiwby ) > k ) { k = divv ( wd , mjfinqnmiwby ) ; } wg = k * mjfinqnmiwby ; g = k * q ; if ( wd <= d && wg <= g && wd <= wg && d <= g ) { printf ( " \n " , cas ++ ) ; } else { printf ( " \n " , cas ++ ) ; } } } return 0 ; }
>>>Func
METHOD dortctkifvkaline_cost
METHOD_RETURN ANY
PARAM WORD *next
PARAM int hmpsoywtphph
<operator>.assignment axxekvkmmbhc=goal_width-hmpsoywtphph
<operator>.assignment fdpcemyuprfw=SHORT_COST(axxekvkmmbhc)
RETURN return fdpcemyuprfw; return fdpcemyuprfw;
<operator>.equals next==word_limit
<operator>.notEquals next->next_break!=word_limit
IDENTIFIER fdpcemyuprfw return fdpcemyuprfw;
RETURN return 0; return 0;
<operator>.subtraction goal_width-hmpsoywtphph
SHORT_COST SHORT_COST(axxekvkmmbhc)
<operator>.assignment axxekvkmmbhc=hmpsoywtphph-next->line_length
<operator>.assignmentPlus fdpcemyuprfw+=RAGGED_COST(axxekvkmmbhc)
LITERAL 0 return 0;
<operator>.subtraction hmpsoywtphph-next->line_length
RAGGED_COST RAGGED_COST(axxekvkmmbhc)
<operator>.indirectFieldAccess next->next_break
FIELD_IDENTIFIER next_break next_break
<operator>.indirectFieldAccess next->line_length
FIELD_IDENTIFIER line_length line_length
>>>PDG&22 0->2 0->3 0->7 0->8 0->9 0->10 0->11 0->12 0->14 0->15 0->16 0->17 2->7 3->1 3->11 4->12 5->9 5->14 6->1 7->1 7->1 7->1 7->4 7->5 7->6 7->8 7->8 7->10 7->11 7->12 7->18 7->19 8->13 8->14 8->16 8->17 8->20 8->21 9->6 10->1 11->1 11->4 11->4 11->16 12->5 13->17 14->9 15->10 16->13 16->13 17->14
>>>Token static dortctkifvkaline_cost ( WORD *  next , int hmpsoywtphph ) { int axxekvkmmbhc ; dortctkifvka fdpcemyuprfw ; if ( next == word_limit ) return 0 ; axxekvkmmbhc = goal_width - hmpsoywtphph ; fdpcemyuprfw = SHORT_COST ( axxekvkmmbhc ) ; if ( next -> next_break != word_limit ) { axxekvkmmbhc = hmpsoywtphph - next -> line_length ; fdpcemyuprfw += RAGGED_COST ( axxekvkmmbhc ) ; } return fdpcemyuprfw ; }
>>>Func
METHOD ujcwspdgakqiabso
METHOD_RETURN long
PARAM ujcwspdgakqi ujcwspdgakqivrsmaolpomdx
RETURN return vrsmaolpomdx<0?-vrsmaolpomdx:vrsmaolpomdx; return vrsmaolpomdx<0?-vrsmaolpomdx:vrsmaolpomdx;
<operator>.conditional vrsmaolpomdx<0?-vrsmaolpomdx:vrsmaolpomdx
<operator>.lessThan vrsmaolpomdx<0
<operator>.minus -vrsmaolpomdx
>>>PDG&7 0->2 0->4 0->5 0->6 2->1 3->1 4->1 4->1 4->1 4->1 4->3 5->4 5->6 5->6 6->4
>>>Token long ujcwspdgakqiabso ( ujcwspdgakqi ujcwspdgakqivrsmaolpomdx ) { return vrsmaolpomdx < 0 ? - vrsmaolpomdx : vrsmaolpomdx ; }
>>>Func
METHOD kldkvitiwrjw
METHOD_RETURN void
PARAM int ydywmipexovb
ewwxrgpjpimn ewwxrgpjpimn("%d\n",&nde)
imprimir imprimir(ydywmipexovb+1)
<operator>.lessThan iuqjirjzouzz<nde
<operator>.postIncrement iuqjirjzouzz++
<operator>.lessThan iuqjirjzouzz<nde
<operator>.postIncrement iuqjirjzouzz++
<operator>.lessThan ecyqbkzrrjdo<nde
<operator>.postIncrement ecyqbkzrrjdo++
<operator>.lessThan ecyqbkzrrjdo<nde
<operator>.postIncrement ecyqbkzrrjdo++
<operator>.assignment iuqjirjzouzz=0
<operator>.assignment iuqjirjzouzz=0
<operator>.assignment yfzndwyykjjf=0
<operator>.assignment wasivdhldbrn=0
<operator>.assignment ecyqbkzrrjdo=0
<operator>.assignment jotymgiyxqkp=0.0
<operator>.assignment yzciscolnarw=0.0
<operator>.assignment ecyqbkzrrjdo=0
<operator>.assignment jotymgiyxqkp=0.0
<operator>.assignment yzciscolnarw=0.0
<operator>.assignment oowps[ecyqbkzrrjdo]=jotymgiyxqkp/(double)(yzciscolnarw)
<operator>.addition ydywmipexovb+1
<operator>.lessThan j<nde
<operator>.postIncrement j++
<operator>.lessThan j<nde
<operator>.postIncrement j++
<operator>.greaterThan yfzndwyykjjf>0
<operator>.lessThan a<nde
<operator>.postIncrement a++
<operator>.greaterThan yzciscolnarw>0
<operator>.lessThan iuqjirjzouzz<nde
<operator>.postIncrement iuqjirjzouzz++
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.assignment uqvzvjprivtp[iuqjirjzouzz]=(double)wasivdhldbrn/(double)yfzndwyykjjf
<operator>.assignment a=0
<operator>.assignment qntheztckqzb[ecyqbkzrrjdo]=jotymgiyxqkp/(yzciscolnarw)
<operator>.assignment iuqjirjzouzz=0
<operator>.division jotymgiyxqkp/(double)(yzciscolnarw)
<operator>.equals j==nde-1
<operator>.logicalAnd m[iuqjirjzouzz][j]!='.'&&j!=iuqjirjzouzz
<operator>.assignment uqvzvjprivtp [iuqjirjzouzz]=0.0
<operator>.logicalAnd ecyqbkzrrjdo!=a&&m[a][ecyqbkzrrjdo]!='.'
<operator>.assignment qntheztckqzb [ecyqbkzrrjdo]=0.0
<operator>.logicalAnd iuqjirjzouzz!=ecyqbkzrrjdo&&m[iuqjirjzouzz][ecyqbkzrrjdo]!='.'
<operator>.cast (double)(yzciscolnarw)
ewwxrgpjpimn ewwxrgpjpimn("%c\n",&m[iuqjirjzouzz][j])
<operator>.postIncrement yfzndwyykjjf++
<operator>.division (double)wasivdhldbrn/(double)yfzndwyykjjf
<operator>.assignment yfzndwyykjjf=0
<operator>.assignment wasivdhldbrn=0
<operator>.assignmentPlus jotymgiyxqkp+=(double)wasivdhldbrn/(double)yfzndwyykjjf
<operator>.assignmentPlus yzciscolnarw+=1
<operator>.division jotymgiyxqkp/(yzciscolnarw)
<operator>.assignmentPlus jotymgiyxqkp+=qntheztckqzb[iuqjirjzouzz]
<operator>.assignmentPlus yzciscolnarw+=1.0
<operator>.subtraction nde-1
ewwxrgpjpimn ewwxrgpjpimn ("%c",&m[iuqjirjzouzz][j])
<operator>.notEquals m[iuqjirjzouzz][j]!='.'
<operator>.notEquals j!=iuqjirjzouzz
<operator>.equals m[iuqjirjzouzz][j]=='1'
<operator>.cast (double)wasivdhldbrn
<operator>.cast (double)yfzndwyykjjf
<operator>.notEquals ecyqbkzrrjdo!=a
<operator>.notEquals m[a][ecyqbkzrrjdo]!='.'
<operator>.lessThan iuqjirjzouzz<nde
<operator>.postIncrement iuqjirjzouzz++
<operator>.notEquals iuqjirjzouzz!=ecyqbkzrrjdo
<operator>.notEquals m[iuqjirjzouzz][ecyqbkzrrjdo]!='.'
<operator>.postIncrement wasivdhldbrn++
<operator>.assignment iuqjirjzouzz=0
<operator>.division (double)wasivdhldbrn/(double)yfzndwyykjjf
<operator>.logicalAnd m[a][iuqjirjzouzz]!='.'&&iuqjirjzouzz!=ecyqbkzrrjdo
<operator>.cast (double)wasivdhldbrn
<operator>.cast (double)yfzndwyykjjf
<operator>.postIncrement yfzndwyykjjf++
<operator>.notEquals m[a][iuqjirjzouzz]!='.'
<operator>.notEquals iuqjirjzouzz!=ecyqbkzrrjdo
<operator>.equals m[a][iuqjirjzouzz]=='1'
<operator>.postIncrement wasivdhldbrn++
<operator>.indirectIndexAccess oowps[ecyqbkzrrjdo]
<operator>.indirectIndexAccess uqvzvjprivtp[iuqjirjzouzz]
<operator>.indirectIndexAccess qntheztckqzb[ecyqbkzrrjdo]
UNKNOWN double double
<operator>.indirectIndexAccess uqvzvjprivtp [iuqjirjzouzz]
<operator>.indirectIndexAccess qntheztckqzb [ecyqbkzrrjdo]
<operator>.addressOf &m[iuqjirjzouzz][j]
<operator>.indirectIndexAccess m[iuqjirjzouzz][j]
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess m[a][ecyqbkzrrjdo]
<operator>.indirectIndexAccess m[iuqjirjzouzz][ecyqbkzrrjdo]
<operator>.indirectIndexAccess qntheztckqzb[iuqjirjzouzz]
<operator>.indirectIndexAccess m[iuqjirjzouzz][j]
<operator>.addressOf &m[iuqjirjzouzz][j]
<operator>.indirectIndexAccess m[iuqjirjzouzz]
<operator>.indirectIndexAccess m[iuqjirjzouzz][j]
<operator>.indirectIndexAccess m[a]
<operator>.indirectIndexAccess m[iuqjirjzouzz]
<operator>.indirectIndexAccess m[iuqjirjzouzz]
<operator>.indirectIndexAccess m[iuqjirjzouzz][j]
<operator>.indirectIndexAccess m[iuqjirjzouzz]
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess m[iuqjirjzouzz]
<operator>.indirectIndexAccess m[a][iuqjirjzouzz]
<operator>.indirectIndexAccess m[a]
<operator>.indirectIndexAccess m[a][iuqjirjzouzz]
<operator>.indirectIndexAccess m[a]
>>>PDG&112 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->38 0->40 0->41 0->42 0->44 0->46 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->76 0->77 0->78 0->79 0->80 0->81 0->82 2->4 2->24 3->1 3->1 3->5 3->7 3->9 3->11 3->25 3->27 3->30 3->33 3->59 3->68 4->1 4->1 5->5 5->6 5->6 5->7 5->25 5->25 5->35 6->1 6->5 7->1 7->1 7->7 7->8 7->8 7->9 7->15 7->16 7->27 7->27 7->29 7->36 7->62 8->1 8->7 9->9 9->10 9->10 9->11 9->18 9->19 9->30 9->30 9->32 9->38 9->66 10->1 10->9 11->1 11->1 11->1 11->11 11->12 11->12 11->21 11->22 11->23 11->33 11->33 11->40 11->41 11->48 11->70 11->83 11->86 12->1 12->11 13->5 14->1 14->7 15->1 15->29 15->50 16->1 16->1 16->51 16->64 16->72 17->9 18->1 18->1 18->54 18->56 19->1 19->32 19->55 20->1 20->11 21->1 21->41 21->57 22->1 22->41 22->48 22->58 23->1 23->1 23->1 24->1 25->1 25->1 25->5 25->25 25->26 25->42 25->42 25->59 25->59 26->1 26->25 27->1 27->1 27->7 27->27 27->28 27->28 27->43 27->61 27->62 27->90 27->98 28->1 28->27 29->1 29->1 29->37 29->44 29->51 29->51 29->64 29->65 29->65 29->84 29->87 29->91 29->92 30->1 30->1 30->9 30->30 30->31 30->45 30->66 30->66 30->68 31->1 31->30 32->1 32->1 32->39 32->46 32->56 32->56 32->85 32->88 33->1 33->1 33->11 33->33 33->34 33->47 33->70 33->70 34->1 34->33 35->1 35->25 36->1 36->27 37->1 37->1 37->1 38->1 38->30 39->1 39->1 39->1 40->1 40->33 41->1 41->1 41->23 41->23 42->1 42->1 42->26 42->49 42->60 42->89 42->96 42->97 42->102 42->103 42->107 43->1 43->1 43->1 43->50 43->63 43->99 43->104 44->1 44->1 45->1 45->1 45->1 45->52 45->53 45->54 45->55 45->68 45->73 45->74 45->76 45->77 45->105 45->106 46->1 46->1 47->1 47->1 47->1 47->57 47->58 47->95 48->1 49->1 49->1 49->60 49->61 49->63 50->1 50->29 51->1 51->1 51->37 51->37 52->1 52->74 52->77 52->78 53->1 53->74 53->76 53->82 54->1 54->1 54->1 54->56 55->1 55->32 56->1 56->1 56->39 56->39 57->1 57->1 57->41 58->1 58->41 58->48 59->25 59->42 59->42 60->1 60->1 60->49 60->61 60->63 61->1 61->43 61->43 61->62 61->63 62->8 62->28 62->43 62->43 63->1 63->1 63->61 63->72 64->1 65->1 66->10 66->31 66->45 66->45 66->67 66->80 66->93 66->100 67->1 67->45 67->45 68->1 68->1 68->30 68->68 68->69 68->69 68->75 68->79 68->80 68->108 68->109 69->1 69->68 70->12 70->34 70->47 70->47 70->71 70->94 70->101 71->1 71->47 71->47 72->1 72->1 72->51 72->64 73->1 73->68 74->1 74->1 74->54 74->54 75->1 75->1 75->1 75->78 75->81 75->110 75->111 76->1 77->1 78->1 78->74 78->77 79->1 79->75 79->75 79->80 79->81 80->10 80->66 80->69 80->75 80->75 81->1 81->1 81->79 81->82 82->1 82->74 82->76
>>>Token void kldkvitiwrjw ( int ydywmipexovb ) { ewwxrgpjpimn ( " \n " , & nde ) ; int iuqjirjzouzz , j ; for ( iuqjirjzouzz = 0 ; iuqjirjzouzz < nde ; iuqjirjzouzz ++ ) { for ( j = 0 ; j < nde ; j ++ ) { char wsztwgqylotf ; if ( j == nde - 1 ) ewwxrgpjpimn ( " \n " , & m [ iuqjirjzouzz ] [ j ] ) ; else ewwxrgpjpimn ( " " , & m [ iuqjirjzouzz ] [ j ] ) ; } } for ( iuqjirjzouzz = 0 ; iuqjirjzouzz < nde ; iuqjirjzouzz ++ ) { int yfzndwyykjjf = 0 ; int wasivdhldbrn = 0 ; for ( j = 0 ; j < nde ; j ++ ) { if ( m [ iuqjirjzouzz ] [ j ] != ' ' && j != iuqjirjzouzz ) { yfzndwyykjjf ++ ; if ( m [ iuqjirjzouzz ] [ j ] == ' ' ) wasivdhldbrn ++ ; } } if ( yfzndwyykjjf > 0 ) uqvzvjprivtp [ iuqjirjzouzz ] = ( double ) wasivdhldbrn / ( double ) yfzndwyykjjf ; else uqvzvjprivtp [ iuqjirjzouzz ] = 0.0 ; } int ecyqbkzrrjdo , a ; for ( ecyqbkzrrjdo = 0 ; ecyqbkzrrjdo < nde ; ecyqbkzrrjdo ++ ) { double jotymgiyxqkp = 0.0 ; double yzciscolnarw = 0.0 ; for ( a = 0 ; a < nde ; a ++ ) { if ( ecyqbkzrrjdo != a && m [ a ] [ ecyqbkzrrjdo ] != ' ' ) { int yfzndwyykjjf = 0 ; int wasivdhldbrn = 0 ; for ( iuqjirjzouzz = 0 ; iuqjirjzouzz < nde ; iuqjirjzouzz ++ ) { if ( m [ a ] [ iuqjirjzouzz ] != ' ' && iuqjirjzouzz != ecyqbkzrrjdo ) { yfzndwyykjjf ++ ; if ( m [ a ] [ iuqjirjzouzz ] == ' ' ) wasivdhldbrn ++ ; } } jotymgiyxqkp += ( double ) wasivdhldbrn / ( double ) yfzndwyykjjf ; yzciscolnarw += 1 ; } } if ( yzciscolnarw > 0 ) qntheztckqzb [ ecyqbkzrrjdo ] = jotymgiyxqkp / ( yzciscolnarw ) ; else qntheztckqzb [ ecyqbkzrrjdo ] = 0.0 ; } for ( ecyqbkzrrjdo = 0 ; ecyqbkzrrjdo < nde ; ecyqbkzrrjdo ++ ) { double jotymgiyxqkp = 0.0 ; double yzciscolnarw = 0.0 ; for ( iuqjirjzouzz = 0 ; iuqjirjzouzz < nde ; iuqjirjzouzz ++ ) { if ( iuqjirjzouzz != ecyqbkzrrjdo && m [ iuqjirjzouzz ] [ ecyqbkzrrjdo ] != ' ' ) { jotymgiyxqkp += qntheztckqzb [ iuqjirjzouzz ] ; yzciscolnarw += 1.0 ; } } oowps [ ecyqbkzrrjdo ] = jotymgiyxqkp / ( double ) ( yzciscolnarw ) ; } imprimir ( ydywmipexovb + 1 ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int pixcffggaldq
PARAM char **argv
scanf scanf("%d\n",&ncase)
RETURN return 0; return 0;
<operator>.lessEqualsThan i<=ncase
<operator>.postIncrement i++
LITERAL 0 return 0;
<operator>.assignment i=1
<operator>.assignment *p=oebadgyfwsyf
fgets fgets(oebadgyfwsyf sizeof(oebadgyfwsyf),stdin)
<operator>.assignment n=2
printf printf("Case #%d: %lld\n",i,--n)
<operator>.assignment igqpvebxllbo[nbases]=strtol(p,&p,10)
<operator>.postIncrement nbases++
<operator>.lessThan j<nbases
<operator>.assignment nbases=0
<operator>.postIncrement n++
<operator>.preDecrement --n
strtol strtol(p,&p,10)
<operator>.lessThan j<nbases
<operator>.postIncrement j++
<operator>.assignment j=0
<operator>.logicalNot !ishappy(n,igqpvebxllbo[j])
ishappy ishappy(n,igqpvebxllbo[j])
<operator>.sizeOf sizeof(oebadgyfwsyf)
<operator>.indirectIndexAccess igqpvebxllbo[nbases]
<operator>.addressOf &p
<operator>.indirectIndexAccess igqpvebxllbo[j]
>>>PDG&30 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 2->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->12 6->13 6->13 6->14 6->16 6->17 6->18 6->19 6->20 6->21 6->23 6->26 6->27 6->28 7->1 7->6 8->5 9->1 9->6 10->1 10->20 11->1 11->1 11->1 11->10 12->1 12->18 12->25 13->1 13->1 13->7 14->1 14->1 14->1 14->14 14->15 14->20 14->27 14->28 15->1 15->21 16->1 16->1 16->1 16->16 16->18 16->21 16->21 16->23 17->1 17->15 17->21 18->1 18->19 18->25 19->1 19->13 20->1 20->1 20->14 20->14 20->14 21->16 21->16 21->22 21->24 21->25 21->29 22->1 22->21 23->1 23->21 24->1 24->1 24->21 24->22 25->1 25->18 25->24 25->24
>>>Token int main ( int pixcffggaldq , char * * argv ) { int igqpvebxllbo [ 10 ] , nbases , ncase , i , j ; qiujjiztbvrw qiujjiztbvrwn ; scanf ( " \n " , & ncase ) ; for ( i = 1 ; i <= ncase ; i ++ ) { char oebadgyfwsyf [ 0x100 ] , * p = oebadgyfwsyf ; fgets ( oebadgyfwsyf , sizeof ( oebadgyfwsyf ) , stdin ) ; for ( nbases = 0 ; ( igqpvebxllbo [ nbases ] = strtol ( p , & p , 10 ) ) ; nbases ++ ) ; n = 2 ; do { for ( j = 0 ; j < nbases ; j ++ ) { if ( ! ishappy ( n , igqpvebxllbo [ j ] ) ) break ; } n ++ ; } while ( j < nbases ) ; printf ( " \n " , i , -- n ) ; } return 0 ; }
>>>Func
METHOD aziaiwrpkrup
METHOD_RETURN void
PARAM void
<operator>.lessThan rpegfsqpzvkr<4 *M *N-1
<operator>.postIncrement rpegfsqpzvkr++
<operator>.assignment rpegfsqpzvkr=0
<operator>.assignment jbowmorfyoqf=-1
<operator>.assignment min_j=-1
<operator>.assignment min_t=INT_MAX
assert assert(min_t>0)
assert assert(valid(jbowmorfyoqf,min_j))
assert assert(opt[jbowmorfyoqf][min_j]<0)
<operator>.assignment opt[jbowmorfyoqf][min_j]=min_t
<operator>.subtraction 4 *M *N-1
<operator>.lessThan sopyujqkcbza<2 *M
<operator>.postIncrement sopyujqkcbza++
<operator>.multiplication 4 *M *N
<operator>.minus -1
<operator>.minus -1
<operator>.assignment sopyujqkcbza=0
<operator>.greaterThan min_t>0
valid valid(jbowmorfyoqf,min_j)
<operator>.lessThan opt[jbowmorfyoqf][min_j]<0
<operator>.multiplication 4 *M
<operator>.multiplication 2 *M
<operator>.lessThan omolslrcftle<2 *N
<operator>.postIncrement omolslrcftle++
<operator>.assignment omolslrcftle=0
<operator>.multiplication 2 *N
<operator>.lessThan opt[sopyujqkcbza][omolslrcftle]<0
<operator>.lessEqualsThan oglswongozyv<=sopyujqkcbza+1
<operator>.postIncrement oglswongozyv++
<operator>.assignment oglswongozyv=sopyujqkcbza-1
<operator>.addition sopyujqkcbza+1
<operator>.lessEqualsThan fxsefulovbva<=omolslrcftle+1
<operator>.postIncrement fxsefulovbva++
<operator>.subtraction sopyujqkcbza-1
<operator>.assignment fxsefulovbva=omolslrcftle-1
<operator>.assignment agljfddotzfv.x=sopyujqkcbza
<operator>.assignment agljfddotzfv.y=omolslrcftle
<operator>.assignment p1.x=oglswongozyv
<operator>.assignment p1.y=fxsefulovbva
<operator>.assignment bexpldtmpifz=dist(agljfddotzfv,p1,opt[sopyujqkcbza][omolslrcftle])
assert assert(bexpldtmpifz>0)
<operator>.addition omolslrcftle+1
<operator>.logicalNot !valid(oglswongozyv,fxsefulovbva)
<operator>.greaterEqualsThan opt[oglswongozyv][fxsefulovbva]>=0
<operator>.lessThan bexpldtmpifz<0
<operator>.lessThan opt[sopyujqkcbza][omolslrcftle]+bexpldtmpifz<min_t
<operator>.subtraction omolslrcftle-1
dist dist(agljfddotzfv,p1,opt[sopyujqkcbza][omolslrcftle])
<operator>.greaterThan bexpldtmpifz>0
<operator>.assignment jbowmorfyoqf=oglswongozyv
<operator>.assignment min_j=fxsefulovbva
<operator>.assignment min_t=opt[sopyujqkcbza][omolslrcftle]+bexpldtmpifz
valid valid(oglswongozyv,fxsefulovbva)
<operator>.addition opt[sopyujqkcbza][omolslrcftle]+bexpldtmpifz
<operator>.addition opt[sopyujqkcbza][omolslrcftle]+bexpldtmpifz
<operator>.indirectIndexAccess opt[jbowmorfyoqf][min_j]
<operator>.indirectIndexAccess opt[jbowmorfyoqf][min_j]
<operator>.indirectIndexAccess opt[jbowmorfyoqf]
<operator>.indirectIndexAccess opt[jbowmorfyoqf]
<operator>.indirectIndexAccess opt[sopyujqkcbza][omolslrcftle]
<operator>.indirectIndexAccess opt[sopyujqkcbza]
<operator>.fieldAccess agljfddotzfv.x
<operator>.fieldAccess agljfddotzfv.y
<operator>.fieldAccess p1.x
<operator>.fieldAccess p1.y
<operator>.indirectIndexAccess opt[oglswongozyv][fxsefulovbva]
FIELD_IDENTIFIER x x
FIELD_IDENTIFIER y y
FIELD_IDENTIFIER x x
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess opt[sopyujqkcbza][omolslrcftle]
<operator>.indirectIndexAccess opt[oglswongozyv]
<operator>.indirectIndexAccess opt[sopyujqkcbza]
<operator>.indirectIndexAccess opt[sopyujqkcbza][omolslrcftle]
<operator>.indirectIndexAccess opt[sopyujqkcbza]
<operator>.indirectIndexAccess opt[sopyujqkcbza][omolslrcftle]
<operator>.indirectIndexAccess opt[sopyujqkcbza]
>>>PDG&80 0->2 0->3 0->4 0->5 0->8 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->33 0->34 0->35 0->36 0->38 0->39 0->40 0->41 0->44 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 2->1 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->7 3->8 3->9 3->10 3->11 3->12 3->13 3->14 3->16 3->17 3->18 3->19 3->20 3->21 3->22 3->23 3->24 3->58 3->59 3->60 3->61 4->1 4->3 5->1 5->3 6->21 7->21 8->1 8->20 8->48 12->22 13->1 13->3 13->3 14->14 14->15 14->15 14->24 14->25 14->27 14->28 14->36 15->14 16->1 16->1 16->13 16->13 16->28 17->6 18->7 19->14 20->9 20->9 20->12 21->10 21->10 22->11 22->11 23->1 23->16 23->16 23->24 24->14 24->14 24->23 25->25 25->26 25->26 25->28 25->29 25->49 25->62 25->63 26->25 27->25 28->16 28->25 28->25 29->30 29->32 29->33 29->36 29->50 30->30 30->31 30->31 30->33 30->34 30->37 30->44 30->49 30->55 31->30 32->30 34->34 34->35 34->44 34->45 34->55 34->55 35->34 36->15 36->30 36->32 36->32 36->33 37->34 38->50 39->50 40->50 41->50 42->47 45->46 45->68 45->74 46->38 46->39 46->40 46->41 46->42 46->47 46->50 46->64 46->65 46->66 46->67 46->69 46->70 46->71 46->72 46->73 46->75 47->43 47->48 47->51 47->51 47->56 47->76 47->77 48->20 48->52 48->53 48->54 48->57 48->78 48->79 49->26 49->34 49->37 49->37 49->44 50->29 50->42 50->42 50->42 50->48 50->54 50->56 50->57 51->43 51->43 51->48 51->54 51->56 51->57 52->21 53->21 54->20 54->48 55->31 55->35 55->40 55->41 55->45 55->45 55->52 55->53
>>>Token void aziaiwrpkrup ( void ) { for ( int rpegfsqpzvkr = 0 ; rpegfsqpzvkr < 4 * M * N - 1 ; rpegfsqpzvkr ++ ) { int jbowmorfyoqf = -1 , min_j = -1 , min_t = INT_MAX ; for ( int sopyujqkcbza = 0 ; sopyujqkcbza < 2 * M ; sopyujqkcbza ++ ) { for ( int omolslrcftle = 0 ; omolslrcftle < 2 * N ; omolslrcftle ++ ) { if ( opt [ sopyujqkcbza ] [ omolslrcftle ] < 0 ) { continue ; } for ( int oglswongozyv = sopyujqkcbza - 1 ; oglswongozyv <= sopyujqkcbza + 1 ; oglswongozyv ++ ) { for ( int fxsefulovbva = omolslrcftle - 1 ; fxsefulovbva <= omolslrcftle + 1 ; fxsefulovbva ++ ) { if ( ! valid ( oglswongozyv , fxsefulovbva ) ) { continue ; } if ( opt [ oglswongozyv ] [ fxsefulovbva ] >= 0 ) { continue ; } point agljfddotzfv , p1 ; agljfddotzfv . x = sopyujqkcbza ; agljfddotzfv . y = omolslrcftle ; p1 . x = oglswongozyv ; p1 . y = fxsefulovbva ; int bexpldtmpifz = dist ( agljfddotzfv , p1 , opt [ sopyujqkcbza ] [ omolslrcftle ] ) ; if ( bexpldtmpifz < 0 ) { continue ; } assert ( bexpldtmpifz > 0 ) ; if ( opt [ sopyujqkcbza ] [ omolslrcftle ] + bexpldtmpifz < min_t ) { jbowmorfyoqf = oglswongozyv ; min_j = fxsefulovbva ; min_t = opt [ sopyujqkcbza ] [ omolslrcftle ] + bexpldtmpifz ; } } } } } assert ( min_t > 0 ) ; assert ( valid ( jbowmorfyoqf , min_j ) ) ; assert ( opt [ jbowmorfyoqf ] [ min_j ] < 0 ) ; opt [ jbowmorfyoqf ] [ min_j ] = min_t ; } }
>>>Func
METHOD main
METHOD_RETURN int
init init()
scanf scanf("%d",&htpeswdeqqhz)
RETURN return 0; return 0;
<operator>.lessThan i<htpeswdeqqhz
<operator>.preIncrement ++i
LITERAL 0 return 0;
<operator>.assignment i=0
scanf scanf("%d",&c)
<operator>.assignment fpfvelgqvcrz=0
scanf scanf("%d",&d)
scanf scanf("%d",&n)
scanf scanf("%s",bbdywcmzbkgw)
printf printf("Case #%d: ",i+1)
printf printf("[")
printf printf("]\n")
<operator>.lessThan j<c
<operator>.preIncrement ++j
<operator>.lessThan k<d
<operator>.preIncrement ++k
<operator>.lessThan j<n
<operator>.preIncrement ++j
<operator>.lessThan l<fpfvelgqvcrz
<operator>.preIncrement ++l
<operator>.assignment j=0
scanf scanf("%s",ecbhobbfrnhv[j])
<operator>.assignment k=0
scanf scanf("%s",mrbtpaeopkqm[k])
<operator>.assignment j=0
<operator>.assignment kwikpywwnlqh[fpfvelgqvcrz]=bbdywcmzbkgw[j]
<operator>.preIncrement ++fpfvelgqvcrz
<operator>.addition i+1
<operator>.assignment l=0
printf printf("%c",kwikpywwnlqh[l])
LITERAL 1 while (1)
<operator>.notEquals l!=0
<operator>.assignment bnwqlwrfzitr=0
printf printf(", ")
<operator>.lessThan fpfvelgqvcrz<2
<operator>.lessThan k<c
<operator>.preIncrement ++k
IDENTIFIER bnwqlwrfzitr if (bnwqlwrfzitr)
<operator>.lessThan l<fpfvelgqvcrz-1
<operator>.preIncrement ++l
<operator>.logicalNot !bnwqlwrfzitr
<operator>.assignment k=0
<operator>.assignment l=0
<operator>.logicalOr (ecbhobbfrnhv[k][0]==kwikpywwnlqh[fpfvelgqvcrz-1]&&ecbhobbfrnhv[k][1]==kwikpywwnlqh[fpfvelgqvcrz-2])||(ecbhobbfrnhv[k][1]==kwikpywwnlqh[fpfvelgqvcrz-1]&&ecbhobbfrnhv[k][0]==kwikpywwnlqh[fpfvelgqvcrz-2])
<operator>.subtraction fpfvelgqvcrz-1
<operator>.lessThan k<d
<operator>.preIncrement ++k
IDENTIFIER bnwqlwrfzitr if (bnwqlwrfzitr)
<operator>.assignment bnwqlwrfzitr=1
<operator>.assignment kwikpywwnlqh[fpfvelgqvcrz-2]=ecbhobbfrnhv[k][2]
<operator>.preDecrement --fpfvelgqvcrz
<operator>.assignment k=0
<operator>.assignment fpfvelgqvcrz=0
<operator>.logicalAnd ecbhobbfrnhv[k][0]==kwikpywwnlqh[fpfvelgqvcrz-1]&&ecbhobbfrnhv[k][1]==kwikpywwnlqh[fpfvelgqvcrz-2]
<operator>.logicalAnd ecbhobbfrnhv[k][1]==kwikpywwnlqh[fpfvelgqvcrz-1]&&ecbhobbfrnhv[k][0]==kwikpywwnlqh[fpfvelgqvcrz-2]
<operator>.logicalOr (mrbtpaeopkqm[k][0]==kwikpywwnlqh[fpfvelgqvcrz-1]&&mrbtpaeopkqm[k][1]==kwikpywwnlqh[l])||(mrbtpaeopkqm[k][1]==kwikpywwnlqh[fpfvelgqvcrz-1]&&mrbtpaeopkqm[k][0]==kwikpywwnlqh[l])
<operator>.equals ecbhobbfrnhv[k][0]==kwikpywwnlqh[fpfvelgqvcrz-1]
<operator>.equals ecbhobbfrnhv[k][1]==kwikpywwnlqh[fpfvelgqvcrz-2]
<operator>.equals ecbhobbfrnhv[k][1]==kwikpywwnlqh[fpfvelgqvcrz-1]
<operator>.equals ecbhobbfrnhv[k][0]==kwikpywwnlqh[fpfvelgqvcrz-2]
<operator>.assignment bnwqlwrfzitr=1
<operator>.subtraction fpfvelgqvcrz-2
<operator>.logicalAnd mrbtpaeopkqm[k][0]==kwikpywwnlqh[fpfvelgqvcrz-1]&&mrbtpaeopkqm[k][1]==kwikpywwnlqh[l]
<operator>.logicalAnd mrbtpaeopkqm[k][1]==kwikpywwnlqh[fpfvelgqvcrz-1]&&mrbtpaeopkqm[k][0]==kwikpywwnlqh[l]
<operator>.subtraction fpfvelgqvcrz-1
<operator>.subtraction fpfvelgqvcrz-2
<operator>.subtraction fpfvelgqvcrz-1
<operator>.subtraction fpfvelgqvcrz-2
<operator>.equals mrbtpaeopkqm[k][0]==kwikpywwnlqh[fpfvelgqvcrz-1]
<operator>.equals mrbtpaeopkqm[k][1]==kwikpywwnlqh[l]
<operator>.equals mrbtpaeopkqm[k][1]==kwikpywwnlqh[fpfvelgqvcrz-1]
<operator>.equals mrbtpaeopkqm[k][0]==kwikpywwnlqh[l]
<operator>.subtraction fpfvelgqvcrz-1
<operator>.subtraction fpfvelgqvcrz-1
<operator>.addressOf &c
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.indirectIndexAccess ecbhobbfrnhv[j]
<operator>.indirectIndexAccess mrbtpaeopkqm[k]
<operator>.indirectIndexAccess kwikpywwnlqh[fpfvelgqvcrz]
<operator>.indirectIndexAccess bbdywcmzbkgw[j]
<operator>.indirectIndexAccess kwikpywwnlqh[l]
<operator>.indirectIndexAccess kwikpywwnlqh[fpfvelgqvcrz-2]
<operator>.indirectIndexAccess ecbhobbfrnhv[k][2]
<operator>.indirectIndexAccess ecbhobbfrnhv[k][0]
<operator>.indirectIndexAccess kwikpywwnlqh[fpfvelgqvcrz-1]
<operator>.indirectIndexAccess ecbhobbfrnhv[k][1]
<operator>.indirectIndexAccess kwikpywwnlqh[fpfvelgqvcrz-2]
<operator>.indirectIndexAccess ecbhobbfrnhv[k][1]
<operator>.indirectIndexAccess kwikpywwnlqh[fpfvelgqvcrz-1]
<operator>.indirectIndexAccess ecbhobbfrnhv[k][0]
<operator>.indirectIndexAccess kwikpywwnlqh[fpfvelgqvcrz-2]
<operator>.indirectIndexAccess ecbhobbfrnhv[k]
<operator>.indirectIndexAccess ecbhobbfrnhv[k]
<operator>.indirectIndexAccess ecbhobbfrnhv[k]
<operator>.indirectIndexAccess ecbhobbfrnhv[k]
<operator>.indirectIndexAccess ecbhobbfrnhv[k]
<operator>.indirectIndexAccess mrbtpaeopkqm[k][0]
<operator>.indirectIndexAccess kwikpywwnlqh[fpfvelgqvcrz-1]
<operator>.indirectIndexAccess mrbtpaeopkqm[k][1]
<operator>.indirectIndexAccess kwikpywwnlqh[l]
<operator>.indirectIndexAccess mrbtpaeopkqm[k][1]
<operator>.indirectIndexAccess kwikpywwnlqh[fpfvelgqvcrz-1]
<operator>.indirectIndexAccess mrbtpaeopkqm[k][0]
<operator>.indirectIndexAccess kwikpywwnlqh[l]
<operator>.indirectIndexAccess mrbtpaeopkqm[k]
<operator>.indirectIndexAccess mrbtpaeopkqm[k]
<operator>.indirectIndexAccess mrbtpaeopkqm[k]
<operator>.indirectIndexAccess mrbtpaeopkqm[k]
>>>PDG&114 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->29 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->49 0->50 0->51 0->52 0->53 0->55 0->56 0->57 0->65 0->66 0->69 0->70 0->71 0->72 0->77 0->78 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->10 5->11 5->12 5->13 5->14 5->14 5->15 5->16 5->17 5->19 5->21 5->23 5->25 5->27 5->29 5->32 5->32 5->33 5->79 5->80 5->81 6->1 6->5 7->4 8->1 8->5 9->1 9->17 9->40 10->1 10->23 10->31 11->1 11->19 11->50 12->1 12->21 13->1 13->30 14->1 14->1 15->1 16->1 17->1 17->1 17->9 17->17 17->18 17->18 17->26 17->40 17->82 18->1 18->17 19->1 19->1 19->1 19->11 19->19 19->20 19->20 19->28 19->50 19->83 20->1 20->19 21->1 21->1 21->1 21->12 21->21 21->22 21->22 21->30 21->31 21->39 21->84 21->85 22->1 22->21 23->1 23->1 23->1 23->23 23->24 23->34 23->36 23->36 23->86 24->1 24->23 25->17 26->1 27->1 27->19 28->1 29->1 29->21 30->1 30->1 30->1 31->1 31->23 31->39 33->1 33->23 34->1 34->1 34->74 34->76 36->1 36->24 36->38 37->1 37->1 37->45 38->1 39->1 39->23 39->31 39->37 39->39 39->40 39->43 39->45 39->46 39->47 39->49 39->49 39->69 40->1 40->1 40->1 40->9 40->17 40->41 40->48 40->58 40->61 40->69 40->89 40->90 40->98 41->1 41->40 43->1 43->1 43->43 43->44 43->44 43->49 43->50 43->56 43->57 44->1 44->43 45->1 45->1 45->39 46->1 46->40 47->43 48->1 48->1 48->1 48->40 48->41 48->53 48->54 48->55 48->66 48->87 48->88 48->97 49->23 49->31 49->39 49->43 49->43 49->77 50->1 50->1 50->1 50->11 50->19 50->51 50->60 50->67 50->73 50->77 50->102 50->103 50->110 51->1 51->50 53->1 53->1 53->45 54->1 54->1 54->1 54->62 54->64 55->1 55->23 55->31 55->39 55->49 56->1 56->50 57->1 57->23 57->31 57->39 58->1 58->1 58->48 58->48 58->59 58->63 58->71 58->93 58->94 58->100 59->1 59->1 59->48 59->48 60->1 60->1 60->1 60->50 60->51 60->65 61->1 61->1 61->58 61->58 61->62 61->63 61->64 61->70 61->73 61->91 61->92 61->99 62->1 62->1 62->58 62->58 62->63 62->64 63->1 63->1 63->59 63->59 63->61 63->62 63->64 63->72 63->73 63->95 63->96 63->101 64->1 64->1 64->59 64->59 64->61 64->62 65->1 65->45 66->55 67->1 67->1 67->60 67->60 67->68 67->75 67->78 67->106 67->107 67->112 68->1 68->1 68->60 68->60 69->23 69->31 69->39 69->49 69->66 69->70 69->71 70->23 70->31 70->39 70->49 70->66 70->69 70->71 71->23 71->31 71->39 71->49 71->66 71->69 71->72 72->23 72->31 72->39 72->49 72->66 72->69 73->1 73->1 73->28 73->61 73->67 73->67 73->74 73->75 73->76 73->104 73->105 73->111 74->1 74->1 74->28 74->34 74->67 74->67 74->75 74->76 75->1 75->1 75->28 75->61 75->68 75->68 75->73 75->74 75->76 75->108 75->109 75->113 76->1 76->1 76->28 76->34 76->68 76->68 76->73 76->74 77->49 77->78 78->49 78->77
>>>Token int main ( ) { init ( ) ; int htpeswdeqqhz , i , j , k , l , c , d , n ; scanf ( " " , & htpeswdeqqhz ) ; for ( i = 0 ; i < htpeswdeqqhz ; ++ i ) { scanf ( " " , & c ) ; char ecbhobbfrnhv [ 40 ] [ 4 ] ; char mrbtpaeopkqm [ 30 ] [ 3 ] ; char bbdywcmzbkgw [ 101 ] ; char kwikpywwnlqh [ 101 ] ; int fpfvelgqvcrz = 0 ; int bnwqlwrfzitr ; for ( j = 0 ; j < c ; ++ j ) { scanf ( " " , ecbhobbfrnhv [ j ] ) ; } scanf ( " " , & d ) ; for ( k = 0 ; k < d ; ++ k ) { scanf ( " " , mrbtpaeopkqm [ k ] ) ; } scanf ( " " , & n ) ; scanf ( " " , bbdywcmzbkgw ) ; for ( j = 0 ; j < n ; ++ j ) { kwikpywwnlqh [ fpfvelgqvcrz ] = bbdywcmzbkgw [ j ] ; ++ fpfvelgqvcrz ; while ( 1 ) { if ( fpfvelgqvcrz < 2 ) { break ; } bnwqlwrfzitr = 0 ; for ( k = 0 ; k < c ; ++ k ) { if ( ( ecbhobbfrnhv [ k ] [ 0 ] == kwikpywwnlqh [ fpfvelgqvcrz - 1 ] && ecbhobbfrnhv [ k ] [ 1 ] == kwikpywwnlqh [ fpfvelgqvcrz - 2 ] ) || ( ecbhobbfrnhv [ k ] [ 1 ] == kwikpywwnlqh [ fpfvelgqvcrz - 1 ] && ecbhobbfrnhv [ k ] [ 0 ] == kwikpywwnlqh [ fpfvelgqvcrz - 2 ] ) ) { bnwqlwrfzitr = 1 ; kwikpywwnlqh [ fpfvelgqvcrz - 2 ] = ecbhobbfrnhv [ k ] [ 2 ] ; -- fpfvelgqvcrz ; break ; } } if ( bnwqlwrfzitr ) { continue ; } for ( l = 0 ; l < fpfvelgqvcrz - 1 ; ++ l ) { for ( k = 0 ; k < d ; ++ k ) { if ( ( mrbtpaeopkqm [ k ] [ 0 ] == kwikpywwnlqh [ fpfvelgqvcrz - 1 ] && mrbtpaeopkqm [ k ] [ 1 ] == kwikpywwnlqh [ l ] ) || ( mrbtpaeopkqm [ k ] [ 1 ] == kwikpywwnlqh [ fpfvelgqvcrz - 1 ] && mrbtpaeopkqm [ k ] [ 0 ] == kwikpywwnlqh [ l ] ) ) { bnwqlwrfzitr = 1 ; break ; } } if ( bnwqlwrfzitr ) { fpfvelgqvcrz = 0 ; break ; } } if ( ! bnwqlwrfzitr ) { break ; } } } printf ( " " , i + 1 ) ; printf ( " " ) ; for ( l = 0 ; l < fpfvelgqvcrz ; ++ l ) { if ( l != 0 ) { printf ( " " ) ; } printf ( " " , kwikpywwnlqh [ l ] ) ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int ygmkttskawze
PARAM char *argv [ ]
<operator>.assignment *in_fp=NULL
<operator>.assignment *out_fp=NULL
IDENTIFIER adoahxnnbnwn <empty>
<operator>.assignment in_fp=fopen(argv[1],"r")
ERRCHK ERRCHK(in_fp)
<operator>.assignment out_fp=fopen("output.txt","w")
ERRCHK ERRCHK(out_fp)
fscanf fscanf(in_fp,"%d",&gfhwxbhfmefr)
<operator>.lessThan LOOP(counter,gfhwxbhfmefr)<missing
fclose fclose(out_fp)
fclose fclose(in_fp)
RETURN return 0; return 0;
<operator>.notEquals ygmkttskawze!=2
LITERAL 0 return 0;
ERR ERR("Incorrect number of command line arguments, exiting...\n")
RETURN return 1; return 1;
fopen fopen(argv[1],"r")
fopen fopen("output.txt","w")
LOOP LOOP(counter,gfhwxbhfmefr)
LITERAL 1 return 1;
UNKNOWN g g
UNKNOWN ';'>{lmhiwiaqedtg=0;FIN("%lld%d%d",&adoahxnnbnwn,&pd,&mdyoqivtoyvv);mogrliykvxms=pd/100.0;ERR("frac: %f\n",mogrliykvxms);for(jkzrvtgacdip=1;jkzrvtgacdip<=adoahxnnbnwn;jkzrvtgacdip++){kazzvgizrvep=mogrliykvxms *jkzrvtgacdip;ERR("%f == %f?\n" kazzvgizrvep floor(kazzvgizrvep));if(kazzvgizrvep==floor(kazzvgizrvep))lmhiwiaqedtg=1;}if(mdyoqivtoyvv==100&&pd!=100)lmhiwiaqedtg=0;if(mdyoqivtoyvv==0&&pd!=0)lmhiwiaqedtg=0;if(lmhiwiaqedtg)npcmydebvajl("Case #%d: Possible\n",counter+1);else npcmydebvajl ("Case #%d: Broken\n",counter+1);} ';'>{lmhiwiaqedtg=0;FIN("%lld%d%d",&adoahxnnbnwn,&pd,&mdyoqivtoyvv);mogrliykvxms=pd/100.0;ERR("frac: %f\n",mogrliykvxms);for(jkzrvtgacdip=1;jkzrvtgacdip<=adoahxnnbnwn;jkzrvtgacdip++){kazzvgizrvep=mogrliykvxms *jkzrvtgacdip;ERR("%f == %f?\n" kazzvgizrvep floor(kazzvgizrvep));if(kazzvgizrvep==floor(kazzvgizrvep))lmhiwiaqedtg=1;}if(mdyoqivtoyvv==100&&pd!=100)lmhiwiaqedtg=0;if(mdyoqivtoyvv==0&&pd!=0)lmhiwiaqedtg=0;if(lmhiwiaqedtg)npcmydebvajl("Case #%d: Possible\n",counter+1);else npcmydebvajl ("Case #%d: Broken\n",counter+1);}
<operator>.addressOf &gfhwxbhfmefr
<operator>.indirectIndexAccess argv[1]
>>>PDG&28 0->2 0->3 0->4 0->5 0->6 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 2->16 3->1 3->20 4->1 4->1 5->1 5->1 5->1 7->8 8->11 9->10 10->13 11->14 11->22 12->1 15->1 16->1 16->1 16->7 16->8 16->9 16->10 16->11 16->12 16->13 16->14 16->15 16->18 16->19 16->20 16->21 16->22 16->24 16->25 16->26 16->27 17->15 18->1 19->1 20->7 20->7 21->9 21->9 22->12 22->12 23->19
>>>Token int main ( int ygmkttskawze , char * argv [ ] ) { FILE * in_fp = NULL ; FILE * out_fp = NULL ; int jkzrvtgacdip , j , k , counter ; int gfhwxbhfmefr ; afwkyenurfdl afwkyenurfdlint  adoahxnnbnwn ; int mdyoqivtoyvv , pd ; int lmhiwiaqedtg ; float mogrliykvxms ; float kazzvgizrvep ; if ( ygmkttskawze != 2 ) { ERR ( " \n " ) ; return 1 ; } in_fp = fopen ( argv [ 1 ] , " " ) ; ERRCHK ( in_fp ) ; out_fp = fopen ( " " , " " ) ; ERRCHK ( out_fp ) ; fscanf ( in_fp , " " , & gfhwxbhfmefr ) ; LOOP ( counter , gfhwxbhfmefr ) < missing ' ; ' { lmhiwiaqedtg = 0 ; FIN ( " " , & adoahxnnbnwn , & pd , & mdyoqivtoyvv ) ; mogrliykvxms = pd / 100.0 ; ERR ( " \n " , mogrliykvxms ) ; for ( jkzrvtgacdip = 1 ; jkzrvtgacdip <= adoahxnnbnwn ; jkzrvtgacdip ++ ) { kazzvgizrvep = mogrliykvxms * jkzrvtgacdip ; ERR ( " \n " , kazzvgizrvep , floor ( kazzvgizrvep ) ) ; if ( kazzvgizrvep == floor ( kazzvgizrvep ) ) lmhiwiaqedtg = 1 ; } if ( mdyoqivtoyvv == 100 && pd != 100 ) lmhiwiaqedtg = 0 ; if ( mdyoqivtoyvv == 0 && pd != 0 ) lmhiwiaqedtg = 0 ; if ( lmhiwiaqedtg ) npcmydebvajl ( " \n " , counter + 1 ) ; else npcmydebvajl ( " \n " , counter + 1 ) ; } fclose ( out_fp ) ; fclose ( in_fp ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM qmgfqfhdbthc mgwulegfkdje
PARAM char **argv
<operator>.assignment *input=fopen("input.in","r")
<operator>.assignment *output=fopen("output.txt","w")
<operator>.assignment xkfatzavhdxb=0
fgets fgets(dxjpamptulcs,10,input)
<operator>.assignment caseCnt=atoi(dxjpamptulcs)
fclose fclose(input)
fclose fclose(output)
RETURN return 0; return 0;
<operator>.lessEqualsThan jprwqbedwxpy<=caseCnt
<operator>.postIncrement jprwqbedwxpy++
LITERAL 0 return 0;
fopen fopen("input.in","r")
fopen fopen("output.txt","w")
atoi atoi(dxjpamptulcs)
<operator>.assignment jprwqbedwxpy=1
<operator>.expressionList L N C
IDENTIFIER t <empty>
fscanf fscanf(input,"%u %lu %u %u",&L,&t,&N,&C)
<operator>.expressionList i j
<operator>.assignment dist_per_loop=0
<operator>.assignment dist_last_loop=0
<operator>.assignment dist_last_loop=dist_per_loop
<operator>.assignment time_per_loop=dist_per_loop *2
<operator>.assignment time_last_loop=dist_last_loop *2
<operator>.assignment full_time=(time_per_loop *loop_cnt)+time_last_loop
printf printf("Case #%d: %lu\n",jprwqbedwxpy,full_time)
fprintf fprintf(output,"Case #%d: %lu\n",jprwqbedwxpy,full_time)
<operator>.lessThan i<C
<operator>.postIncrement i++
<operator>.lessThan i<C
<operator>.postIncrement i++
<operator>.lessEqualsThan t<=full_time
<operator>.assignment i=0
fscanf fscanf(input,"%u",&a[i])
<operator>.assignmentPlus dist_per_loop+=a[i]
<operator>.assignment last_a[i]=a[i]
<operator>.assignment i=N%C
<operator>.assignmentMinus dist_last_loop-=a[i]
<operator>.assignment last_a[i]=0
<operator>.multiplication dist_per_loop *2
<operator>.multiplication dist_last_loop *2
<operator>.addition (time_per_loop *loop_cnt)+time_last_loop
<operator>.assignment dist_pending=0
<operator>.assignment pos=0
<operator>.assignment index_pending=i
<operator>.assignment size_last=N%C
<operator>.assignment last_a[size_last++]=dist_pending
<operator>.assignment j=1
<operator>.assignment index_a=0
<operator>.assignment index_l=0
<operator>.multiplication time_per_loop *loop_cnt
<operator>.lessThan i<C
<operator>.postIncrement i++
<operator>.lessThan i<C
<operator>.postIncrement i++
<operator>.logicalAnd (L>0)&&(index_a<size_a||index_l<size_l)
<operator>.modulo N%C
<operator>.assignment i=0
<operator>.modulo N%C
<operator>.assignment i=index_pending+1
<operator>.assignment last_a[size_last++]=a[i]
<operator>.greaterThan dist_passed>a[i]
<operator>.postIncrement size_last++
<operator>.greaterThan L>0
<operator>.logicalOr index_a<size_a||index_l<size_l
<operator>.logicalAnd a[index_a]>=last_a[index_l]&&loop_left>0
<operator>.assignmentMinus dist_passed-=a[i]
<operator>.addition index_pending+1
<operator>.lessThan index_a<size_a
<operator>.lessThan index_l<size_l
<operator>.postIncrement index_a++
<operator>.assignment dist_pending=a[i]-dist_passed
<operator>.postIncrement size_last++
<operator>.greaterEqualsThan a[index_a]>=last_a[index_l]
<operator>.greaterThan loop_left>0
<operator>.greaterThan L>loop_left
<operator>.assignmentMinus full_time-=last_a[index_l]
<operator>.postDecrement L--
<operator>.postIncrement index_l++
<operator>.assignmentMinus full_time-=loop_left *a[index_a]
<operator>.assignmentMinus L-=loop_left
<operator>.subtraction a[i]-dist_passed
<operator>.assignmentMinus full_time-=L *a[index_a]
<operator>.assignment L=0
<operator>.multiplication loop_left *a[index_a]
<operator>.multiplication L *a[index_a]
UNKNOWN c c
UNKNOWN m m
UNKNOWN c c
UNKNOWN c c
UNKNOWN a[1000]={0}; a[1000]={0};
UNKNOWN c c
UNKNOWN c c
UNKNOWN c c
UNKNOWN last_a[2000]={0}; last_a[2000]={0};
UNKNOWN c c
UNKNOWN loop_cnt=(unsigned qmgfqfhdbthc )(N/C); loop_cnt=(unsigned qmgfqfhdbthc )(N/C);
UNKNOWN c c
UNKNOWN c c
UNKNOWN m m
<operator>.addressOf &L
<operator>.addressOf &t
<operator>.addressOf &N
<operator>.addressOf &C
UNKNOWN c c
UNKNOWN loop_passed=(unsigned qmgfqfhdbthc )(t/time_per_loop); loop_passed=(unsigned qmgfqfhdbthc )(t/time_per_loop);
UNKNOWN c c
UNKNOWN dist_passed=(unsigned qmgfqfhdbthc )((t%time_per_loop)/2); dist_passed=(unsigned qmgfqfhdbthc )((t%time_per_loop)/2);
UNKNOWN c c
UNKNOWN c c
UNKNOWN c c
UNKNOWN loop_left=(unsigned qmgfqfhdbthc )(loop_cnt-loop_passed-1); loop_left=(unsigned qmgfqfhdbthc )(loop_cnt-loop_passed-1);
UNKNOWN c c
UNKNOWN c c
UNKNOWN qsort(a C sizeof(unsigned qmgfqfhdbthc ),compare); qsort(a C sizeof(unsigned qmgfqfhdbthc ),compare);
UNKNOWN qsort(last_a size_last sizeof(unsigned qmgfqfhdbthc ),compare); qsort(last_a size_last sizeof(unsigned qmgfqfhdbthc ),compare);
UNKNOWN c c
UNKNOWN c c
<operator>.addressOf &a[i]
<operator>.indirectIndexAccess a[i]
<operator>.indirectIndexAccess last_a[i]
<operator>.indirectIndexAccess a[i]
<operator>.indirectIndexAccess a[i]
<operator>.indirectIndexAccess last_a[i]
<operator>.indirectIndexAccess last_a[size_last++]
<operator>.indirectIndexAccess a[i]
<operator>.indirectIndexAccess last_a[size_last++]
<operator>.indirectIndexAccess a[i]
<operator>.indirectIndexAccess a[i]
<operator>.indirectIndexAccess a[i]
<operator>.indirectIndexAccess a[index_a]
<operator>.indirectIndexAccess last_a[index_l]
<operator>.indirectIndexAccess last_a[index_l]
<operator>.indirectIndexAccess a[i]
<operator>.indirectIndexAccess a[index_a]
<operator>.indirectIndexAccess a[index_a]
>>>PDG&140 0->2 0->3 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->60 0->61 0->62 0->63 0->65 0->66 0->67 0->70 0->71 0->72 0->73 0->74 0->76 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 2->1 3->1 4->1 4->1 4->7 5->1 5->1 5->10 5->30 6->1 6->1 7->1 7->9 7->17 7->21 8->1 8->1 8->12 9->1 9->1 10->1 10->1 11->1 12->1 12->1 12->1 12->12 12->13 12->19 12->21 12->22 12->23 12->24 12->25 12->26 12->27 12->28 12->29 12->29 12->30 12->31 12->33 12->35 12->36 12->40 12->43 12->44 12->45 12->54 12->60 12->90 12->91 12->92 12->93 12->94 12->95 12->96 12->97 12->98 12->99 12->100 12->101 12->102 12->103 12->104 12->105 12->106 12->107 13->1 13->12 14->11 15->4 15->4 16->5 16->5 17->1 17->8 18->1 18->12 19->1 19->1 19->21 19->21 19->21 19->31 19->60 19->67 21->1 21->1 21->1 21->1 21->1 21->9 21->19 21->19 21->19 21->31 21->33 21->35 21->37 21->55 21->57 21->60 21->60 21->62 21->62 21->67 21->79 21->81 21->84 21->89 22->1 22->1 23->1 23->25 23->38 23->43 24->1 25->1 25->41 25->44 26->1 26->1 26->54 27->1 27->1 27->28 27->45 28->1 28->1 28->35 29->1 29->30 29->30 30->1 30->1 30->10 30->13 31->31 31->32 31->32 31->37 31->38 31->39 31->60 31->122 31->123 31->124 31->125 31->129 32->1 32->31 33->1 33->1 33->1 33->19 33->22 33->33 33->34 33->34 33->41 33->42 33->55 33->126 33->127 34->1 34->33 35->1 35->1 35->21 35->29 35->46 35->47 35->48 35->49 35->50 35->51 35->52 35->53 35->55 35->57 35->59 35->61 35->62 35->63 35->66 35->67 35->71 35->80 35->83 35->86 35->108 35->109 35->110 35->111 35->112 35->113 35->114 35->115 35->116 35->117 35->118 35->119 35->120 35->121 35->128 36->1 36->31 37->1 37->1 37->9 37->21 37->38 37->39 37->41 37->64 37->65 37->70 37->85 38->1 38->25 38->43 39->1 39->1 39->1 40->1 40->1 40->33 41->1 41->1 41->44 42->1 42->1 43->1 43->26 43->26 44->1 44->27 44->27 45->1 45->1 46->1 46->50 47->1 47->1 48->1 48->63 48->71 49->1 49->1 49->66 50->1 50->1 50->1 51->1 51->1 51->22 52->1 52->1 52->72 52->74 53->1 53->1 53->73 53->82 54->1 54->1 54->28 54->28 54->45 54->45 55->48 55->56 55->62 55->65 55->132 56->1 56->55 57->1 57->1 57->1 57->19 57->22 57->57 57->58 57->58 57->64 57->76 57->130 57->131 58->1 58->57 59->1 59->1 59->1 59->59 59->67 59->69 59->77 59->134 59->135 60->1 60->19 60->33 60->40 60->40 60->62 61->1 61->55 62->1 62->19 62->49 62->49 62->57 63->1 63->1 63->57 64->1 64->1 64->1 65->1 65->37 65->38 65->41 65->55 65->56 65->64 65->70 65->70 65->70 65->75 65->85 65->85 65->85 65->133 65->137 66->1 66->76 67->1 67->19 67->59 67->59 67->68 67->72 67->79 67->81 68->1 68->1 68->59 68->59 69->1 69->1 69->1 69->74 69->79 69->80 69->81 69->82 69->136 70->1 70->1 70->1 70->65 71->1 72->1 72->1 72->68 72->68 72->73 72->74 73->1 73->1 73->68 73->68 73->82 74->1 74->1 74->72 75->1 75->1 75->50 76->1 77->1 77->1 77->69 77->69 77->78 77->80 77->88 77->89 78->1 78->69 78->69 78->79 79->1 79->1 79->78 79->83 79->84 79->84 79->86 79->87 79->88 79->88 79->89 79->89 79->138 79->139 80->1 80->1 80->29 80->83 80->86 81->1 81->67 82->1 82->1 82->73 83->1 83->1 83->29 83->80 83->86 84->1 84->1 84->67 85->1 85->1 85->37 85->38 85->41 85->64 85->65 85->65 85->75 85->75 86->1 86->1 86->29 86->80 86->83 87->1 87->67 88->1 88->77 88->78 88->79 88->83 88->83 88->84 89->1 89->77 89->86 89->86
>>>Token int main ( qmgfqfhdbthc mgwulegfkdje , char * * argv ) { FILE * input = fopen ( " " , " " ) ; FILE * output = fopen ( " " , " " ) ; char dxjpamptulcs [ INPUTLEN ] ; qmgfqfhdbthc jprwqbedwxpy , caseCnt ; qmgfqfhdbthc xkfatzavhdxb = 0 ; fgets ( dxjpamptulcs , 10 , input ) ; caseCnt = atoi ( dxjpamptulcs ) ; for ( jprwqbedwxpy = 1 ; jprwqbedwxpy <= caseCnt ; jprwqbedwxpy ++ ) { unsigned qmgfqfhdbthc L , N , C ; unsigned xeqpsdefxnbm t ; fscanf ( input , " " , & L , & t , & N , & C ) ; unsigned qmgfqfhdbthc i , j ; unsigned qmgfqfhdbthc a [ 1000 ] = { 0 } ; unsigned qmgfqfhdbthc dist_per_loop = 0 ; unsigned qmgfqfhdbthc dist_last_loop = 0 ; unsigned qmgfqfhdbthc last_a [ 2000 ] = { 0 } ; for ( i = 0 ; i < C ; i ++ ) { fscanf ( input , " " , & a [ i ] ) ; dist_per_loop += a [ i ] ; last_a [ i ] = a [ i ] ; } dist_last_loop = dist_per_loop ; for ( i = N % C ; i < C ; i ++ ) { dist_last_loop -= a [ i ] ; last_a [ i ] = 0 ; } unsigned qmgfqfhdbthc loop_cnt = ( unsigned qmgfqfhdbthc ) ( N / C ) ; unsigned qmgfqfhdbthc time_per_loop = dist_per_loop * 2 ; unsigned qmgfqfhdbthc time_last_loop = dist_last_loop * 2 ; unsigned xeqpsdefxnbm full_time = ( time_per_loop * loop_cnt ) + time_last_loop ; if ( t <= full_time ) { unsigned qmgfqfhdbthc loop_passed = ( unsigned qmgfqfhdbthc ) ( t / time_per_loop ) ; unsigned qmgfqfhdbthc dist_passed = ( unsigned qmgfqfhdbthc ) ( ( t % time_per_loop ) / 2 ) ; unsigned qmgfqfhdbthc dist_pending = 0 ; unsigned qmgfqfhdbthc pos = 0 ; for ( i = 0 ; i < C ; i ++ ) { if ( dist_passed > a [ i ] ) dist_passed -= a [ i ] ; else { dist_pending = a [ i ] - dist_passed ; break ; } } unsigned qmgfqfhdbthc loop_left = ( unsigned qmgfqfhdbthc ) ( loop_cnt - loop_passed - 1 ) ; unsigned qmgfqfhdbthc index_pending = i ; unsigned qmgfqfhdbthc size_last = N % C ; last_a [ size_last ++ ] = dist_pending ; j = 1 ; for ( i = index_pending + 1 ; i < C ; i ++ ) { last_a [ size_last ++ ] = a [ i ] ; } qsort ( a , C , sizeof ( unsigned qmgfqfhdbthc ) , compare ) ; qsort ( last_a , size_last , sizeof ( unsigned qmgfqfhdbthc ) , compare ) ; unsigned qmgfqfhdbthc index_a = 0 ; unsigned qmgfqfhdbthc index_l = 0 ; while ( ( L > 0 ) && ( index_a < size_a || index_l < size_l ) ) { if ( a [ index_a ] >= last_a [ index_l ] && loop_left > 0 ) { if ( L > loop_left ) { full_time -= loop_left * a [ index_a ] ; L -= loop_left ; } else { full_time -= L * a [ index_a ] ; L = 0 ; } index_a ++ ; } else { full_time -= last_a [ index_l ] ; L -- ; index_l ++ ; } } } printf ( " \n " , jprwqbedwxpy , full_time ) ; fprintf ( output , " \n " , jprwqbedwxpy , full_time ) ; } fclose ( input ) ; fclose ( output ) ; return 0 ; }
>>>Func
METHOD cktxbwshisxx
METHOD_RETURN void
PARAM int afbncfjtsedo
PARAM int uegwzbgypvuj
<operator>.equals uegwzbgypvuj==10
<operator>.assignment g[num1][num2]=1
<operator>.equals afbncfjtsedo==0
<operator>.assignment row[0][uegwzbgypvuj]=0
<operator>.notEquals row[0][uegwzbgypvuj-1]!=1
<operator>.lessThan uegwzbgypvuj<9
<operator>.assignment row[1][uegwzbgypvuj]=0
cktxbwshisxx cktxbwshisxx(1,uegwzbgypvuj+1)
<operator>.assignment row[0][uegwzbgypvuj]=1
<operator>.assignmentPlus num1+=p[uegwzbgypvuj]
<operator>.postIncrement count++
<operator>.assignmentMinus num1-=p[uegwzbgypvuj]
<operator>.postDecrement count--
cktxbwshisxx cktxbwshisxx(0,uegwzbgypvuj+1)
<operator>.equals uegwzbgypvuj==0
<operator>.equals uegwzbgypvuj==9
<operator>.equals wjsowmovoxmb==0
<operator>.lessThan uegwzbgypvuj<9
<operator>.assignment cnt[num1]=count
cktxbwshisxx cktxbwshisxx(1,0)
<operator>.assignment wjsowmovoxmb=row[0][1]
<operator>.assignment wjsowmovoxmb=row[0][8]+row[1][8]
<operator>.assignment row[1][uegwzbgypvuj]=1
<operator>.assignmentPlus num2+=p[uegwzbgypvuj]
cktxbwshisxx cktxbwshisxx(1,uegwzbgypvuj+1)
<operator>.assignmentMinus num2-=p[uegwzbgypvuj]
<operator>.addition uegwzbgypvuj+1
<operator>.subtraction uegwzbgypvuj-1
cktxbwshisxx cktxbwshisxx(0,uegwzbgypvuj+1)
<operator>.addition uegwzbgypvuj+1
<operator>.assignment wjsowmovoxmb=row[0][uegwzbgypvuj-1]+row[0][uegwzbgypvuj+1]+row[1][uegwzbgypvuj-1]+row[1][uegwzbgypvuj+1]
cktxbwshisxx cktxbwshisxx(1,1)
<operator>.addition uegwzbgypvuj+1
<operator>.addition uegwzbgypvuj+1
<operator>.addition uegwzbgypvuj+1
<operator>.subtraction uegwzbgypvuj-1
<operator>.subtraction uegwzbgypvuj-1
<operator>.addition uegwzbgypvuj+1
<operator>.indirectIndexAccess g[num1][num2]
<operator>.indirectIndexAccess g[num1]
<operator>.indirectIndexAccess row[0][uegwzbgypvuj]
<operator>.indirectIndexAccess row[0][uegwzbgypvuj-1]
<operator>.indirectIndexAccess row[0]
<operator>.indirectIndexAccess row[1][uegwzbgypvuj]
<operator>.indirectIndexAccess row[0]
<operator>.indirectIndexAccess row[0][uegwzbgypvuj]
<operator>.indirectIndexAccess p[uegwzbgypvuj]
<operator>.indirectIndexAccess p[uegwzbgypvuj]
<operator>.indirectIndexAccess row[1]
<operator>.indirectIndexAccess row[0]
<operator>.indirectIndexAccess cnt[num1]
<operator>.indirectIndexAccess row[0][1]
<operator>.addition row[0][8]+row[1][8]
<operator>.indirectIndexAccess row[1][uegwzbgypvuj]
<operator>.indirectIndexAccess p[uegwzbgypvuj]
<operator>.indirectIndexAccess p[uegwzbgypvuj]
<operator>.indirectIndexAccess row[0]
<operator>.indirectIndexAccess row[0][8]
<operator>.indirectIndexAccess row[1][8]
<operator>.addition row[0][uegwzbgypvuj-1]+row[0][uegwzbgypvuj+1]+row[1][uegwzbgypvuj-1]+row[1][uegwzbgypvuj+1]
<operator>.indirectIndexAccess row[1]
<operator>.indirectIndexAccess row[0]
<operator>.indirectIndexAccess row[1]
<operator>.addition row[0][uegwzbgypvuj-1]+row[0][uegwzbgypvuj+1]+row[1][uegwzbgypvuj-1]
<operator>.indirectIndexAccess row[1][uegwzbgypvuj+1]
<operator>.addition row[0][uegwzbgypvuj-1]+row[0][uegwzbgypvuj+1]
<operator>.indirectIndexAccess row[1][uegwzbgypvuj-1]
<operator>.indirectIndexAccess row[1]
<operator>.indirectIndexAccess row[0][uegwzbgypvuj-1]
<operator>.indirectIndexAccess row[0][uegwzbgypvuj+1]
<operator>.indirectIndexAccess row[1]
<operator>.indirectIndexAccess row[0]
<operator>.indirectIndexAccess row[0]
>>>PDG&77 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 2->1 2->6 3->4 4->1 4->1 4->5 4->6 4->18 4->31 4->42 4->43 5->1 5->1 6->7 6->8 6->9 6->10 6->11 6->18 6->19 6->20 6->30 6->31 6->44 6->45 6->46 6->47 6->48 6->52 8->12 8->13 8->14 8->15 8->16 8->21 8->49 8->50 8->51 8->53 9->17 9->17 9->22 9->23 9->33 9->33 9->54 13->15 14->16 16->22 18->19 18->24 18->55 18->60 19->11 19->25 19->28 19->30 19->34 19->36 19->38 19->39 19->40 19->40 19->41 19->56 19->61 19->62 19->63 19->65 19->66 19->67 19->68 19->69 19->70 19->71 19->72 19->73 19->74 19->75 19->76 20->26 20->27 20->28 20->29 20->36 20->57 20->58 20->59 20->64 21->9 21->32 21->32 21->35 21->37 21->37 25->20 27->29 31->9 31->21 34->20 39->11 39->28 39->30 39->36 39->38 40->39 40->41
>>>Token void cktxbwshisxx ( int afbncfjtsedo , int uegwzbgypvuj ) { if ( uegwzbgypvuj == 10 ) g [ num1 ] [ num2 ] = 1 ; else { if ( afbncfjtsedo == 0 ) { if ( row [ 0 ] [ uegwzbgypvuj - 1 ] != 1 ) { row [ 0 ] [ uegwzbgypvuj ] = 1 ; num1 += p [ uegwzbgypvuj ] ; count ++ ; if ( uegwzbgypvuj < 9 ) cktxbwshisxx ( 0 , uegwzbgypvuj + 1 ) ; else cktxbwshisxx ( 1 , 1 ) ; num1 -= p [ uegwzbgypvuj ] ; count -- ; } row [ 0 ] [ uegwzbgypvuj ] = 0 ; if ( uegwzbgypvuj < 9 ) cktxbwshisxx ( 0 , uegwzbgypvuj + 1 ) ; else { cnt [ num1 ] = count ; cktxbwshisxx ( 1 , 0 ) ; } } else { int wjsowmovoxmb ; if ( uegwzbgypvuj == 0 ) wjsowmovoxmb = row [ 0 ] [ 1 ] ; if ( uegwzbgypvuj == 9 ) wjsowmovoxmb = row [ 0 ] [ 8 ] + row [ 1 ] [ 8 ] ; else wjsowmovoxmb = row [ 0 ] [ uegwzbgypvuj - 1 ] + row [ 0 ] [ uegwzbgypvuj + 1 ] + row [ 1 ] [ uegwzbgypvuj - 1 ] + row [ 1 ] [ uegwzbgypvuj + 1 ] ; if ( wjsowmovoxmb == 0 ) { row [ 1 ] [ uegwzbgypvuj ] = 1 ; num2 += p [ uegwzbgypvuj ] ; cktxbwshisxx ( 1 , uegwzbgypvuj + 1 ) ; num2 -= p [ uegwzbgypvuj ] ; } row [ 1 ] [ uegwzbgypvuj ] = 0 ; cktxbwshisxx ( 1 , uegwzbgypvuj + 1 ) ; } } }
>>>Func
METHOD jwjninpoguzk
METHOD_RETURN int
PARAM int iyxnapdtkfdq
<operator>.assignment ufoiisovhlev=1
<operator>.assignment high=iyxnapdtkfdq
RETURN return ufoiisovhlev; return ufoiisovhlev;
<operator>.lessEqualsThan ufoiisovhlev<=high
IDENTIFIER ufoiisovhlev return ufoiisovhlev;
<operator>.assignment nxppzqppmnlr=ufoiisovhlev+(high-ufoiisovhlev)/2
isBadVersion isBadVersion(nxppzqppmnlr)
<operator>.addition ufoiisovhlev+(high-ufoiisovhlev)/2
<operator>.assignment high=nxppzqppmnlr-1
<operator>.division (high-ufoiisovhlev)/2
<operator>.assignment ufoiisovhlev=nxppzqppmnlr+1
<operator>.subtraction high-ufoiisovhlev
<operator>.subtraction nxppzqppmnlr-1
<operator>.addition nxppzqppmnlr+1
>>>PDG&17 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 2->4 3->1 3->6 4->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->8 6->9 6->10 6->12 6->14 6->14 6->14 7->5 8->1 8->1 8->9 9->1 9->11 9->13 9->13 9->15 9->15 9->16 9->16 10->1 11->1 11->1 11->6 12->1 12->8 12->8 12->10 12->10 13->1 13->1 13->6 14->6 14->6 14->8 14->10 14->12 14->12 15->1 15->11 15->11 16->1
>>>Token int jwjninpoguzk ( int iyxnapdtkfdq ) { int ufoiisovhlev = 1 , high = iyxnapdtkfdq ; while ( ufoiisovhlev <= high ) { int nxppzqppmnlr = ufoiisovhlev + ( high - ufoiisovhlev ) / 2 ; if ( isBadVersion ( nxppzqppmnlr ) ) { high = nxppzqppmnlr - 1 ; } else { ufoiisovhlev = nxppzqppmnlr + 1 ; } } return ufoiisovhlev ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int ysybbqnhncuo
PARAM char *argv [ ]
<operator>.assignment jmcskyqrhvic=0
printf printf("Sum is: %d\n",jmcskyqrhvic)
RETURN return 0; return 0;
<operator>.lessThan ytqynccowqzs<ysybbqnhncuo
<operator>.postIncrement ytqynccowqzs++
LITERAL 0 return 0;
<operator>.assignment ytqynccowqzs=0
<operator>.assignmentPlus jmcskyqrhvic+=ytqynccowqzs
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->7 3->1 4->1 4->5 4->11 5->1 5->1 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->11 7->11 8->1 8->7 9->6 10->1 10->7 11->1 11->5
>>>Token int main ( int ysybbqnhncuo , char * argv [ ] ) { int ytqynccowqzs ; int jmcskyqrhvic = 0 ; for ( ytqynccowqzs = 0 ; ytqynccowqzs < ysybbqnhncuo ; ytqynccowqzs ++ ) { jmcskyqrhvic += ytqynccowqzs ; } printf ( " \n " , jmcskyqrhvic ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
RETURN return 0; return 0;
<operator>.lessEqualsThan h<=mxwfkkzcjbpr
<operator>.postIncrement h++
LITERAL 0 return 0;
<operator>.expressionList scanf("%d",&mxwfkkzcjbpr) h=1
scanf scanf("%s",s)
<operator>.assignment n=strlen(s)
<operator>.assignment cnt=0
bt bt(0,0,0,+1)
printf printf("Case #%d: %d\n",h,cnt)
scanf scanf("%d",&mxwfkkzcjbpr)
<operator>.assignment h=1
strlen strlen(s)
<operator>.plus +1
>>>PDG&17 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->15 0->16 2->1 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->15 4->16 5->1 5->4 6->3 7->1 7->1 8->15 9->1 9->1 9->1 10->1 10->12 11->1 11->1 12->1 12->1 12->5 13->1 13->4 13->7 14->4 14->7 15->1 15->8 15->9 16->11
>>>Token int main ( void ) { int mxwfkkzcjbpr , h ; for ( scanf ( " " , & mxwfkkzcjbpr ) , h = 1 ; h <= mxwfkkzcjbpr ; h ++ ) { scanf ( " " , s ) ; n = strlen ( s ) ; cnt = 0 ; bt ( 0 , 0 , 0 , +1 ) ; printf ( " \n " , h , cnt ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
freopen freopen("a.in","r",stdin)
freopen freopen("output.txt","w",stdout)
scanf scanf("%d",&test)
RETURN return 0; return 0;
<operator>.lessEqualsThan t<=test
<operator>.postIncrement t++
LITERAL 0 return 0;
<operator>.assignment t=1
scanf scanf("%d",&n)
printf printf("Case #%d:\n",t)
<operator>.lessThan kyfvavbyozyy<n
<operator>.postIncrement kyfvavbyozyy++
scanf scanf("%s",zyjbeirlpzyt[kyfvavbyozyy])
<operator>.lessThan kyfvavbyozyy<n
<operator>.postIncrement kyfvavbyozyy++
<operator>.lessThan kyfvavbyozyy<n
<operator>.postIncrement kyfvavbyozyy++
<operator>.lessThan kyfvavbyozyy<n
<operator>.postIncrement kyfvavbyozyy++
<operator>.lessThan kyfvavbyozyy<n
<operator>.postIncrement kyfvavbyozyy++
printf printf("%0.8lf\n",0.25 *hjikfjssdkxt[kyfvavbyozyy]+0.50 *op[kyfvavbyozyy]+0.25 *owp[kyfvavbyozyy])
<operator>.assignment kyfvavbyozyy=0
<operator>.assignment kyfvavbyozyy=0
<operator>.assignment hjikfjssdkxt[kyfvavbyozyy]=0.0
<operator>.assignment deno=0
<operator>.assignmentDivision hjikfjssdkxt[kyfvavbyozyy]/=deno
<operator>.assignment kyfvavbyozyy=0
<operator>.assignment op[kyfvavbyozyy]=0.0
<operator>.assignment len=0
<operator>.assignment sum=0.0
<operator>.assignment op[kyfvavbyozyy]=sum/len
<operator>.assignment kyfvavbyozyy=0
<operator>.assignment owp[kyfvavbyozyy]=0.0
<operator>.assignment len=0
<operator>.assignmentDivision owp[kyfvavbyozyy]/=len
<operator>.assignment kyfvavbyozyy=0
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.addition 0.25 *hjikfjssdkxt[kyfvavbyozyy]+0.50 *op[kyfvavbyozyy]+0.25 *owp[kyfvavbyozyy]
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.expressionList x=0.0 deno=0
<operator>.division sum/len
<operator>.assignment j=0
<operator>.notEquals zyjbeirlpzyt[kyfvavbyozyy][j]!='.'
<operator>.addition 0.25 *hjikfjssdkxt[kyfvavbyozyy]+0.50 *op[kyfvavbyozyy]
<operator>.multiplication 0.25 *owp[kyfvavbyozyy]
<operator>.notEquals zyjbeirlpzyt[kyfvavbyozyy][j]!='.'
<operator>.lessThan k<n
<operator>.postIncrement k++
<operator>.logicalAnd j!=kyfvavbyozyy&&zyjbeirlpzyt[kyfvavbyozyy][j]!='.'
<operator>.postIncrement len++
<operator>.assignmentPlus owp[kyfvavbyozyy]+=op[j]
<operator>.multiplication 0.25 *hjikfjssdkxt[kyfvavbyozyy]
<operator>.multiplication 0.50 *op[kyfvavbyozyy]
<operator>.assignmentPlus hjikfjssdkxt[kyfvavbyozyy]+=zyjbeirlpzyt[kyfvavbyozyy][j]-'0'
<operator>.postIncrement deno++
<operator>.assignment x=0.0
<operator>.assignment deno=0
<operator>.assignment k=0
<operator>.postIncrement len++
<operator>.assignment sum=sum+x/deno
<operator>.logicalAnd zyjbeirlpzyt[j][k]!='.'&&j!=kyfvavbyozyy&&k!=kyfvavbyozyy
<operator>.notEquals j!=kyfvavbyozyy
<operator>.notEquals zyjbeirlpzyt[kyfvavbyozyy][j]!='.'
<operator>.subtraction zyjbeirlpzyt[kyfvavbyozyy][j]-'0'
<operator>.assignmentPlus x+=zyjbeirlpzyt[j][k]-'0'
<operator>.postIncrement deno++
<operator>.addition sum+x/deno
<operator>.logicalAnd zyjbeirlpzyt[j][k]!='.'&&j!=kyfvavbyozyy
<operator>.notEquals k!=kyfvavbyozyy
<operator>.division x/deno
<operator>.notEquals zyjbeirlpzyt[j][k]!='.'
<operator>.notEquals j!=kyfvavbyozyy
<operator>.subtraction zyjbeirlpzyt[j][k]-'0'
<operator>.addressOf &n
<operator>.indirectIndexAccess zyjbeirlpzyt[kyfvavbyozyy]
<operator>.indirectIndexAccess hjikfjssdkxt[kyfvavbyozyy]
<operator>.indirectIndexAccess hjikfjssdkxt[kyfvavbyozyy]
<operator>.indirectIndexAccess op[kyfvavbyozyy]
<operator>.indirectIndexAccess op[kyfvavbyozyy]
<operator>.indirectIndexAccess owp[kyfvavbyozyy]
<operator>.indirectIndexAccess owp[kyfvavbyozyy]
<operator>.indirectIndexAccess owp[kyfvavbyozyy]
<operator>.indirectIndexAccess zyjbeirlpzyt[kyfvavbyozyy][j]
<operator>.indirectIndexAccess hjikfjssdkxt[kyfvavbyozyy]
<operator>.indirectIndexAccess op[kyfvavbyozyy]
<operator>.indirectIndexAccess zyjbeirlpzyt[kyfvavbyozyy][j]
<operator>.indirectIndexAccess zyjbeirlpzyt[kyfvavbyozyy]
<operator>.indirectIndexAccess owp[kyfvavbyozyy]
<operator>.indirectIndexAccess op[j]
<operator>.indirectIndexAccess zyjbeirlpzyt[kyfvavbyozyy]
<operator>.indirectIndexAccess hjikfjssdkxt[kyfvavbyozyy]
<operator>.indirectIndexAccess zyjbeirlpzyt[kyfvavbyozyy][j]
<operator>.indirectIndexAccess zyjbeirlpzyt[kyfvavbyozyy][j]
<operator>.indirectIndexAccess zyjbeirlpzyt[kyfvavbyozyy]
<operator>.indirectIndexAccess zyjbeirlpzyt[kyfvavbyozyy]
<operator>.indirectIndexAccess zyjbeirlpzyt[j][k]
<operator>.indirectIndexAccess zyjbeirlpzyt[j][k]
<operator>.indirectIndexAccess zyjbeirlpzyt[j]
<operator>.indirectIndexAccess zyjbeirlpzyt[j]
>>>PDG&108 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->49 0->50 0->51 0->53 0->54 0->55 0->56 0->58 0->60 0->61 0->63 0->64 0->65 0->66 0->67 0->68 0->70 0->71 0->72 0->73 0->74 0->75 0->77 0->78 0->79 0->80 0->81 2->1 2->1 3->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->11 6->12 6->15 6->17 6->19 6->21 6->24 6->25 6->29 6->34 6->38 6->82 7->1 7->6 8->5 9->1 9->6 10->1 10->12 10->15 10->17 10->19 10->21 10->39 10->41 10->43 10->55 11->1 11->7 12->12 12->13 12->13 12->14 12->15 12->83 13->1 13->12 14->1 15->15 15->16 15->16 15->17 15->26 15->27 15->28 15->39 15->39 15->46 15->84 15->85 16->1 16->15 17->17 17->18 17->18 17->19 17->30 17->31 17->32 17->33 17->41 17->41 17->47 17->49 17->70 17->77 17->80 17->86 17->87 18->1 18->17 19->19 19->20 19->20 19->21 19->35 19->36 19->37 19->43 19->43 19->50 19->88 19->89 20->1 20->19 21->1 21->1 21->1 21->10 21->12 21->21 21->22 21->22 21->23 21->45 21->52 21->53 21->60 21->61 21->90 21->92 21->93 22->1 22->21 23->1 23->1 24->12 25->15 26->1 26->28 26->62 27->1 27->28 27->63 28->1 28->1 28->1 28->60 29->17 30->1 31->1 31->49 31->67 32->1 32->49 32->68 32->75 33->1 33->1 33->1 33->61 34->19 35->1 35->37 35->59 36->1 36->37 36->58 37->1 37->1 37->1 37->53 38->1 38->21 39->1 39->1 39->15 39->39 39->40 39->40 39->54 39->94 39->98 40->1 40->39 41->1 41->1 41->17 41->41 41->42 41->48 41->55 41->55 41->57 41->64 41->65 41->66 41->70 41->70 41->80 42->1 42->41 43->1 43->1 43->19 43->43 43->44 43->44 43->51 43->91 43->95 44->1 44->43 45->1 45->1 46->1 46->39 47->1 47->41 48->1 48->1 48->1 49->1 49->1 49->33 49->33 50->1 50->43 51->1 51->1 51->14 51->54 51->57 51->58 51->59 51->71 51->96 51->97 52->1 52->1 53->1 53->23 53->23 53->45 53->45 54->1 54->1 54->14 54->51 54->57 54->62 54->63 54->71 54->72 54->72 54->99 54->101 54->103 55->1 55->1 55->41 55->55 55->56 55->56 55->69 55->76 55->77 55->79 55->104 55->106 56->1 56->55 57->1 57->1 57->1 57->67 57->68 57->75 57->76 57->78 58->1 58->37 59->1 59->1 59->37 60->1 60->23 60->23 60->45 60->45 60->52 60->52 61->1 61->23 61->23 61->45 61->45 61->52 61->52 62->1 62->1 62->28 63->1 63->28 64->1 64->48 64->73 64->78 65->1 65->48 65->74 65->78 66->1 66->55 67->1 67->49 68->1 68->1 68->49 68->75 69->1 69->1 69->1 69->73 69->74 69->81 69->105 69->107 70->18 70->42 70->57 70->57 70->71 70->77 70->80 70->100 70->102 71->1 71->14 71->51 71->54 71->57 71->57 72->1 72->14 72->51 72->54 72->62 72->62 72->71 73->1 73->1 73->1 73->78 74->1 74->1 74->78 75->1 76->1 76->69 76->69 76->77 77->56 77->69 77->69 77->70 77->80 78->1 78->1 78->68 78->68 78->75 78->75 79->1 79->76 79->76 79->80 79->81 80->70 80->70 80->76 80->76 80->77 81->1 81->73 81->73 81->79
>>>Token int main ( ) { int kyfvavbyozyy , j , t , l , test , n , k , deno , len ; char zyjbeirlpzyt [ 100 ] [ 100 ] ; double hjikfjssdkxt [ 100 ] , op [ 100 ] , owp [ 100 ] , sum , x ; freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; scanf ( " " , & test ) ; for ( t = 1 ; t <= test ; t ++ ) { scanf ( " " , & n ) ; for ( kyfvavbyozyy = 0 ; kyfvavbyozyy < n ; kyfvavbyozyy ++ ) scanf ( " " , zyjbeirlpzyt [ kyfvavbyozyy ] ) ; for ( kyfvavbyozyy = 0 ; kyfvavbyozyy < n ; kyfvavbyozyy ++ ) { hjikfjssdkxt [ kyfvavbyozyy ] = 0.0 ; deno = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( zyjbeirlpzyt [ kyfvavbyozyy ] [ j ] != ' ' ) { hjikfjssdkxt [ kyfvavbyozyy ] += zyjbeirlpzyt [ kyfvavbyozyy ] [ j ] - ' ' ; deno ++ ; } } hjikfjssdkxt [ kyfvavbyozyy ] /= deno ; } for ( kyfvavbyozyy = 0 ; kyfvavbyozyy < n ; kyfvavbyozyy ++ ) { op [ kyfvavbyozyy ] = 0.0 ; len = 0 ; sum = 0.0 ; for ( j = 0 ; j < n ; j ++ ) { x = 0.0 , deno = 0 ; for ( k = 0 ; k < n ; k ++ ) { if ( zyjbeirlpzyt [ j ] [ k ] != ' ' && j != kyfvavbyozyy && k != kyfvavbyozyy ) { x += zyjbeirlpzyt [ j ] [ k ] - ' ' ; deno ++ ; } } if ( j != kyfvavbyozyy && zyjbeirlpzyt [ kyfvavbyozyy ] [ j ] != ' ' ) { len ++ ; sum = sum + x / deno ; } } op [ kyfvavbyozyy ] = sum / len ; } for ( kyfvavbyozyy = 0 ; kyfvavbyozyy < n ; kyfvavbyozyy ++ ) { owp [ kyfvavbyozyy ] = 0.0 ; len = 0 ; for ( j = 0 ; j < n ; j ++ ) if ( zyjbeirlpzyt [ kyfvavbyozyy ] [ j ] != ' ' ) { len ++ ; owp [ kyfvavbyozyy ] += op [ j ] ; } owp [ kyfvavbyozyy ] /= len ; } printf ( " \n " , t ) ; for ( kyfvavbyozyy = 0 ; kyfvavbyozyy < n ; kyfvavbyozyy ++ ) printf ( " \n " , 0.25 * hjikfjssdkxt [ kyfvavbyozyy ] + 0.50 * op [ kyfvavbyozyy ] + 0.25 * owp [ kyfvavbyozyy ] ) ; } return 0 ; }
>>>Func
METHOD meacruhdcual
METHOD_RETURN int
PARAM int gyqymfscjpls
RETURN return gyqymfscjpls; return gyqymfscjpls;
<operator>.lessThan i<gyqymfscjpls-1
<operator>.postIncrement i++
IDENTIFIER gyqymfscjpls return gyqymfscjpls;
<operator>.assignment i=0
<operator>.assignment cxfrxzzwmrxn=gyqymfscjpls-i
<operator>.subtraction gyqymfscjpls-1
<operator>.lessThan cxfrxzzwmrxn<2
<operator>.lessThan j<gyqymfscjpls
<operator>.postIncrement j++
<operator>.subtraction gyqymfscjpls-i
RETURN return gyqymfscjpls; return gyqymfscjpls;
<operator>.assignment j=i
IDENTIFIER gyqymfscjpls return gyqymfscjpls;
findOpp findOpp(B[i],B[j])
<operator>.assignment gyqymfscjpls=0
<operator>.assignment B[0]='\0'
RETURN return 0; return 0;
LITERAL 0 return 0;
<operator>.indirectIndexAccess B[i]
<operator>.indirectIndexAccess B[j]
<operator>.indirectIndexAccess B[0]
>>>PDG&25 0->2 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->18 0->19 0->20 0->21 2->9 3->1 4->1 4->1 4->3 4->8 4->10 4->13 4->13 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->10 9->4 9->4 9->6 9->13 10->1 10->1 10->11 10->14 10->15 11->1 11->1 11->4 11->5 11->9 11->9 11->12 11->17 11->22 11->23 12->1 12->11 13->1 13->1 13->5 13->8 13->8 13->11 13->15 13->16 14->1 15->1 15->11 16->14 17->1 17->1 17->1 17->11 17->12 17->18 17->19 17->20 17->24 20->1 21->20
>>>Token int meacruhdcual ( int gyqymfscjpls ) { int cxfrxzzwmrxn , i , j , tmp ; for ( i = 0 ; i < gyqymfscjpls - 1 ; i ++ ) { cxfrxzzwmrxn = gyqymfscjpls - i ; if ( cxfrxzzwmrxn < 2 ) return gyqymfscjpls ; for ( j = i ; j < gyqymfscjpls ; j ++ ) { if ( findOpp ( B [ i ] , B [ j ] ) ) { gyqymfscjpls = 0 ; B [ 0 ] = ' \0 ' ; return 0 ; } } } return gyqymfscjpls ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment uiwnfetvmcih[100][2]={{1 100} {2 50} {3 100} {4 25} {5 20} {6 50} {7 100} {8 25} {9 100} {10 10} {11 100} {12 25} {13 100} {14 50} {15 20} {16 20} {17 100} {18 50} {19 100} {20 5} {21 100} {22 50} {23 100} {24 25} {25 4} {26 50} {27 100} {28 25} {29 100} {30 10} {31 100} {32 25} {33 100} {34 50} {35 20} {36 25} {37 100} {38 50} {39 100} {40 5} {41 100} {42 50} {43 100} {44 25} {45 20} {46 50} {47 100} {48 25} {49 100} {50 2} {51 100} {52 25} {53 100} {54 50} {55 20} {56 25} {57 100} {58 50} {59 100} {60 5} {61 100} {62 50} {63 100} {64 25} {65 20} {66 50} {67 100} {68 25} {69 100} {70 10} {71 100} {72 25} {73 100} {74 50} {75 4} {76 25} {77 100} {78 50} {79 100} {80 5} {81 100} {82 50} {83 100} {84 25} {85 20} {86 50} {87 100} {88 25} {89 100} {90 10} {91 100} {92 25} {93 100} {94 50} {95 20} {96 25} {97 100} {98 50} {99 100} {100 1}}
<operator>.assignment i=1
scanf scanf("%d",&qngdtdtrregq)
RETURN return 0; return 0;
<operator>.postDecrement qngdtdtrregq--
LITERAL 0 return 0;
<operator>.arrayInitializer {{1 100} {2 50} {3 100} {4 25} {5 20} {6 50} {7 100} {8 25} {9 100} {10 10} {11 100} {12 25} {13 100} {14 50} {15 20} {16 20} {17 100} {18 50} {19 100} {20 5} {21 100} {22 50} {23 100} {24 25} {25 4} {26 50} {27 100} {28 25} {29 100} {30 10} {31 100} {32 25} {33 100} {34 50} {35 20} {36 25} {37 100} {38 50} {39 100} {40 5} {41 100} {42 50} {43 100} {44 25} {45 20} {46 50} {47 100} {48 25} {49 100} {50 2} {51 100} {52 25} {53 100} {54 50} {55 20} {56 25} {57 100} {58 50} {59 100} {60 5} {61 100} {62 50} {63 100} {64 25} {65 20} {66 50} {67 100} {68 25} {69 100} {70 10} {71 100} {72 25} {73 100} {74 50} {75 4} {76 25} {77 100} {78 50} {79 100} {80 5} {81 100} {82 50} {83 100} {84 25} {85 20} {86 50} {87 100} {88 25} {89 100} {90 10} {91 100} {92 25} {93 100} {94 50} {95 20} {96 25} {97 100} {98 50} {99 100} {100 1}}
scanf scanf("%lld %d %d",&n,&p1,&p2)
<operator>.postIncrement i++
<operator>.arrayInitializer {1 100}
<operator>.arrayInitializer {2 50}
<operator>.arrayInitializer {3 100}
<operator>.arrayInitializer {4 25}
<operator>.arrayInitializer {5 20}
<operator>.arrayInitializer {6 50}
<operator>.arrayInitializer {7 100}
<operator>.arrayInitializer {8 25}
<operator>.arrayInitializer {9 100}
<operator>.arrayInitializer {10 10}
<operator>.arrayInitializer {11 100}
<operator>.arrayInitializer {12 25}
<operator>.arrayInitializer {13 100}
<operator>.arrayInitializer {14 50}
<operator>.arrayInitializer {15 20}
<operator>.arrayInitializer {16 20}
<operator>.arrayInitializer {17 100}
<operator>.arrayInitializer {18 50}
<operator>.arrayInitializer {19 100}
<operator>.arrayInitializer {20 5}
<operator>.arrayInitializer {21 100}
<operator>.arrayInitializer {22 50}
<operator>.arrayInitializer {23 100}
<operator>.arrayInitializer {24 25}
<operator>.arrayInitializer {25 4}
<operator>.arrayInitializer {26 50}
<operator>.arrayInitializer {27 100}
<operator>.arrayInitializer {28 25}
<operator>.arrayInitializer {29 100}
<operator>.arrayInitializer {30 10}
<operator>.arrayInitializer {31 100}
<operator>.arrayInitializer {32 25}
<operator>.arrayInitializer {33 100}
<operator>.arrayInitializer {34 50}
<operator>.arrayInitializer {35 20}
<operator>.arrayInitializer {36 25}
<operator>.arrayInitializer {37 100}
<operator>.arrayInitializer {38 50}
<operator>.arrayInitializer {39 100}
<operator>.arrayInitializer {40 5}
<operator>.arrayInitializer {41 100}
<operator>.arrayInitializer {42 50}
<operator>.arrayInitializer {43 100}
<operator>.arrayInitializer {44 25}
<operator>.arrayInitializer {45 20}
<operator>.arrayInitializer {46 50}
<operator>.arrayInitializer {47 100}
<operator>.arrayInitializer {48 25}
<operator>.arrayInitializer {49 100}
<operator>.arrayInitializer {50 2}
<operator>.arrayInitializer {51 100}
<operator>.arrayInitializer {52 25}
<operator>.arrayInitializer {53 100}
<operator>.arrayInitializer {54 50}
<operator>.arrayInitializer {55 20}
<operator>.arrayInitializer {56 25}
<operator>.arrayInitializer {57 100}
<operator>.arrayInitializer {58 50}
<operator>.arrayInitializer {59 100}
<operator>.arrayInitializer {60 5}
<operator>.arrayInitializer {61 100}
<operator>.arrayInitializer {62 50}
<operator>.arrayInitializer {63 100}
<operator>.arrayInitializer {64 25}
<operator>.arrayInitializer {65 20}
<operator>.arrayInitializer {66 50}
<operator>.arrayInitializer {67 100}
<operator>.arrayInitializer {68 25}
<operator>.arrayInitializer {69 100}
<operator>.arrayInitializer {70 10}
<operator>.arrayInitializer {71 100}
<operator>.arrayInitializer {72 25}
<operator>.arrayInitializer {73 100}
<operator>.arrayInitializer {74 50}
<operator>.arrayInitializer {75 4}
<operator>.arrayInitializer {76 25}
<operator>.arrayInitializer {77 100}
<operator>.arrayInitializer {78 50}
<operator>.arrayInitializer {79 100}
<operator>.arrayInitializer {80 5}
<operator>.arrayInitializer {81 100}
<operator>.arrayInitializer {82 50}
<operator>.arrayInitializer {83 100}
<operator>.arrayInitializer {84 25}
<operator>.arrayInitializer {85 20}
<operator>.arrayInitializer {86 50}
<operator>.arrayInitializer {87 100}
<operator>.arrayInitializer {88 25}
<operator>.arrayInitializer {89 100}
<operator>.arrayInitializer {90 10}
<operator>.arrayInitializer {91 100}
<operator>.arrayInitializer {92 25}
<operator>.arrayInitializer {93 100}
<operator>.arrayInitializer {94 50}
<operator>.arrayInitializer {95 20}
<operator>.arrayInitializer {96 25}
<operator>.arrayInitializer {97 100}
<operator>.arrayInitializer {98 50}
<operator>.arrayInitializer {99 100}
<operator>.arrayInitializer {100 1}
<operator>.logicalOr (p1<100&&p2==100)||(p1>0&&p2==0)
vvxoqgeekgtc vvxoqgeekgtc("Case #%d: Broken\n",i)
<operator>.logicalAnd p1<100&&p2==100
<operator>.logicalAnd p1>0&&p2==0
<operator>.lessThan p1<100
<operator>.equals p2==100
<operator>.greaterThan p1>0
<operator>.equals p2==0
<operator>.greaterEqualsThan n>=uiwnfetvmcih[p1-1][1]
vvxoqgeekgtc vvxoqgeekgtc("Case #%d: Possible\n",i)
vvxoqgeekgtc vvxoqgeekgtc ("Case #%d: Broken\n",i)
<operator>.subtraction p1-1
<operator>.addressOf &n
<operator>.addressOf &p1
<operator>.addressOf &p2
<operator>.indirectIndexAccess uiwnfetvmcih[p1-1][1]
<operator>.indirectIndexAccess uiwnfetvmcih[p1-1]
>>>PDG&128 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->112 0->115 0->116 0->117 0->118 0->119 0->120 0->121 0->122 2->1 2->1 2->1 3->1 3->1 3->112 3->120 3->121 4->1 4->6 5->1 6->1 6->1 6->6 6->9 6->10 6->111 6->113 6->115 6->123 6->124 6->125 7->5 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->1 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 9->1 9->1 9->1 9->119 10->1 10->1 10->112 10->120 10->121 11->8 11->8 12->8 12->8 13->8 13->8 14->8 14->8 15->8 15->8 16->8 16->8 17->8 17->8 18->8 18->8 19->8 19->8 20->8 21->8 21->8 22->8 22->8 23->8 23->8 24->8 24->8 25->8 25->8 26->8 26->8 27->8 27->8 28->8 28->8 29->8 29->8 30->8 30->8 31->8 31->8 32->8 32->8 33->8 33->8 34->8 34->8 35->8 35->8 36->8 36->8 37->8 37->8 38->8 38->8 39->8 39->8 40->8 40->8 41->8 41->8 42->8 42->8 43->8 43->8 44->8 44->8 45->8 45->8 46->8 46->8 47->8 47->8 48->8 48->8 49->8 49->8 50->8 50->8 51->8 51->8 52->8 52->8 53->8 53->8 54->8 54->8 55->8 55->8 56->8 56->8 57->8 57->8 58->8 58->8 59->8 59->8 60->8 60->8 61->8 61->8 62->8 62->8 63->8 63->8 64->8 64->8 65->8 65->8 66->8 66->8 67->8 67->8 68->8 68->8 69->8 69->8 70->8 70->8 71->8 71->8 72->8 72->8 73->8 73->8 74->8 74->8 75->8 75->8 76->8 76->8 77->8 77->8 78->8 78->8 79->8 79->8 80->8 80->8 81->8 81->8 82->8 82->8 83->8 83->8 84->8 84->8 85->8 85->8 86->8 86->8 87->8 87->8 88->8 88->8 89->8 89->8 90->8 90->8 91->8 91->8 92->8 92->8 93->8 93->8 94->8 94->8 95->8 95->8 96->8 96->8 97->8 97->8 98->8 98->8 99->8 99->8 100->8 100->8 101->8 101->8 102->8 102->8 103->8 103->8 104->8 104->8 105->8 105->8 106->8 106->8 107->8 107->8 108->8 108->8 109->8 109->8 110->8 110->8 111->1 111->1 111->1 111->112 111->119 111->122 111->126 111->127 112->1 112->10 113->1 113->1 113->111 113->111 113->114 113->117 114->1 114->1 114->111 114->111 115->1 115->113 115->113 115->116 115->117 115->122 116->1 116->113 116->113 116->118 117->1 117->114 117->114 117->115 117->118 117->122 118->1 118->114 118->114 118->116 119->1 119->1 119->1 119->9 119->120 119->121 120->1 120->10 121->1 121->10 122->1 122->115
>>>Token int main ( ) { int uiwnfetvmcih [ 100 ] [ 2 ] = { { 1 , 100 } , { 2 , 50 } , { 3 , 100 } , { 4 , 25 } , { 5 , 20 } , { 6 , 50 } , { 7 , 100 } , { 8 , 25 } , { 9 , 100 } , { 10 , 10 } , { 11 , 100 } , { 12 , 25 } , { 13 , 100 } , { 14 , 50 } , { 15 , 20 } , { 16 , 20 } , { 17 , 100 } , { 18 , 50 } , { 19 , 100 } , { 20 , 5 } , { 21 , 100 } , { 22 , 50 } , { 23 , 100 } , { 24 , 25 } , { 25 , 4 } , { 26 , 50 } , { 27 , 100 } , { 28 , 25 } , { 29 , 100 } , { 30 , 10 } , { 31 , 100 } , { 32 , 25 } , { 33 , 100 } , { 34 , 50 } , { 35 , 20 } , { 36 , 25 } , { 37 , 100 } , { 38 , 50 } , { 39 , 100 } , { 40 , 5 } , { 41 , 100 } , { 42 , 50 } , { 43 , 100 } , { 44 , 25 } , { 45 , 20 } , { 46 , 50 } , { 47 , 100 } , { 48 , 25 } , { 49 , 100 } , { 50 , 2 } , { 51 , 100 } , { 52 , 25 } , { 53 , 100 } , { 54 , 50 } , { 55 , 20 } , { 56 , 25 } , { 57 , 100 } , { 58 , 50 } , { 59 , 100 } , { 60 , 5 } , { 61 , 100 } , { 62 , 50 } , { 63 , 100 } , { 64 , 25 } , { 65 , 20 } , { 66 , 50 } , { 67 , 100 } , { 68 , 25 } , { 69 , 100 } , { 70 , 10 } , { 71 , 100 } , { 72 , 25 } , { 73 , 100 } , { 74 , 50 } , { 75 , 4 } , { 76 , 25 } , { 77 , 100 } , { 78 , 50 } , { 79 , 100 } , { 80 , 5 } , { 81 , 100 } , { 82 , 50 } , { 83 , 100 } , { 84 , 25 } , { 85 , 20 } , { 86 , 50 } , { 87 , 100 } , { 88 , 25 } , { 89 , 100 } , { 90 , 10 } , { 91 , 100 } , { 92 , 25 } , { 93 , 100 } , { 94 , 50 } , { 95 , 20 } , { 96 , 25 } , { 97 , 100 } , { 98 , 50 } , { 99 , 100 } , { 100 , 1 } } ; int qngdtdtrregq , p1 , p2 , i = 1 ; cnfedydofxnd cnfedydofxndn ; scanf ( " " , & qngdtdtrregq ) ; while ( qngdtdtrregq -- ) { scanf ( " " , & n , & p1 , & p2 ) ; if ( ( p1 < 100 && p2 == 100 ) || ( p1 > 0 && p2 == 0 ) ) vvxoqgeekgtc ( " \n " , i ) ; else { if ( n >= uiwnfetvmcih [ p1 - 1 ] [ 1 ] ) vvxoqgeekgtc ( " \n " , i ) ; else vvxoqgeekgtc ( " \n " , i ) ; } i ++ ; } return 0 ; }
>>>Func
METHOD efbavrbjjxxt
METHOD_RETURN int
PARAM char *q
PARAM struct wgkymioxtcpr*sch
PARAM int mxcfkkpoqjfy
RETURN return 0; return 0;
<operator>.lessThan ctoxjcorrbpi<mxcfkkpoqjfy
<operator>.postIncrement ctoxjcorrbpi++
LITERAL 0 return 0;
<operator>.assignment ctoxjcorrbpi=0
<operator>.logicalAnd strcmp(q,sch[ctoxjcorrbpi].sarr)==0&&sch[ctoxjcorrbpi].flag==0
<operator>.assignment sch[ctoxjcorrbpi].flag=1
<operator>.postIncrement flag0++
<operator>.equals strcmp(q,sch[ctoxjcorrbpi].sarr)==0
<operator>.equals sch[ctoxjcorrbpi].flag==0
<operator>.equals flag0==mxcfkkpoqjfy
strcmp strcmp(q,sch[ctoxjcorrbpi].sarr)
<operator>.assignment flag0=0
RETURN return 1; return 1;
<operator>.lessThan k<mxcfkkpoqjfy
<operator>.postIncrement k++
LITERAL 1 return 1;
RETURN return 0; return 0;
<operator>.assignment k=0
<operator>.assignment sch[k].flag=0
LITERAL 0 return 0;
<operator>.fieldAccess sch[ctoxjcorrbpi].flag
<operator>.fieldAccess sch[ctoxjcorrbpi].flag
<operator>.fieldAccess sch[ctoxjcorrbpi].sarr
<operator>.indirectIndexAccess sch[ctoxjcorrbpi]
FIELD_IDENTIFIER flag flag
<operator>.indirectIndexAccess sch[ctoxjcorrbpi]
FIELD_IDENTIFIER flag flag
<operator>.indirectIndexAccess sch[ctoxjcorrbpi]
FIELD_IDENTIFIER sarr sarr
<operator>.fieldAccess sch[k].flag
<operator>.indirectIndexAccess sch[k]
FIELD_IDENTIFIER flag flag
>>>PDG&38 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 2->16 3->1 4->6 5->1 6->1 6->1 6->5 6->7 6->10 6->13 6->15 6->16 6->28 6->33 6->34 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->1 10->6 10->7 10->11 10->12 10->15 10->27 10->31 10->32 11->1 11->1 12->1 12->15 13->1 13->10 13->10 13->14 13->26 13->29 13->30 14->10 14->10 15->1 15->17 15->18 15->19 15->19 15->22 15->23 16->1 16->1 16->13 16->13 17->1 17->1 18->1 19->1 19->1 19->1 19->19 19->20 19->20 19->24 19->35 19->36 19->37 20->1 20->19 21->18 22->1 23->1 23->19 24->1 25->22
>>>Token int efbavrbjjxxt ( char * q , struct wgkymioxtcpr * sch , int mxcfkkpoqjfy ) { int ctoxjcorrbpi , k ; for ( ctoxjcorrbpi = 0 ; ctoxjcorrbpi < mxcfkkpoqjfy ; ctoxjcorrbpi ++ ) { if ( strcmp ( q , sch [ ctoxjcorrbpi ] . sarr ) == 0 && sch [ ctoxjcorrbpi ] . flag == 0 ) { sch [ ctoxjcorrbpi ] . flag = 1 ; flag0 ++ ; if ( flag0 == mxcfkkpoqjfy ) { flag0 = 0 ; for ( k = 0 ; k < mxcfkkpoqjfy ; k ++ ) { sch [ k ] . flag = 0 ; } return 1 ; } else { return 0 ; } } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment *head=create_heap(head)
push push(head,10)
printf printf("Pushing element : 10\n")
push push(head,3)
printf printf("Pushing element : 3\n")
push push(head,2)
printf printf("Pushing element : 2\n")
push push(head,8)
printf printf("Pushing element : 8\n")
printf printf("Top element = %d \n" top(head))
push push(head,1)
printf printf("Pushing element : 1\n")
push push(head,7)
printf printf("Pushing element : 7\n")
printf printf("Top element = %d \n" top(head))
pop pop(head)
printf printf("Popping an element.\n")
printf printf("Top element = %d \n" top(head))
pop pop(head)
printf printf("Popping an element.\n")
printf printf("Top element = %d \n" top(head))
printf printf("\n")
RETURN return 0; return 0;
LITERAL 0 return 0;
create_heap create_heap(head)
top top(head)
top top(head)
top top(head)
top top(head)
>>>PDG&31 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 2->1 2->1 2->3 3->1 3->5 4->1 5->1 5->7 6->1 7->1 7->9 8->1 9->1 9->27 10->1 12->1 12->14 13->1 14->1 14->28 15->1 17->29 20->1 20->30 21->1 22->1 22->1 23->1 24->1 25->24 26->2 27->11 27->12 28->16 28->17 29->19 29->20 30->1 30->22
>>>Token int main ( ) { Heap * head = create_heap ( head ) ; push ( head , 10 ) ; printf ( " \n " ) ; push ( head , 3 ) ; printf ( " \n " ) ; push ( head , 2 ) ; printf ( " \n " ) ; push ( head , 8 ) ; printf ( " \n " ) ; printf ( " \n " , top ( head ) ) ; push ( head , 1 ) ; printf ( " \n " ) ; push ( head , 7 ) ; printf ( " \n " ) ; printf ( " \n " , top ( head ) ) ; pop ( head ) ; printf ( " \n " ) ; printf ( " \n " , top ( head ) ) ; pop ( head ) ; printf ( " \n " ) ; printf ( " \n " , top ( head ) ) ; printf ( " \n " ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&t)
<operator>.lessEqualsThan l<=t
<operator>.postIncrement l++
<operator>.assignment l=1
<operator>.assignment n=-1
scanf scanf("%d",&c)
scanf scanf("%d",&d)
scanf scanf("%d",&ind)
scanf scanf("%c",&cxdbwaynnlvc)
uqxkmylrgjbo uqxkmylrgjbo("Case #%d: [",l)
uqxkmylrgjbo uqxkmylrgjbo("]\n")
<operator>.lessThan i<c
<operator>.postIncrement i++
scanf scanf("%c%c%c%c",&cxdbwaynnlvc,&comb[i][0],&comb[i][1],&comb[i][2])
<operator>.lessThan i<d
<operator>.postIncrement i++
scanf scanf("%c%c%c",&cxdbwaynnlvc,&opp[i][0],&opp[i][1])
<operator>.lessThan i<ind
<operator>.postIncrement i++
<operator>.lessEqualsThan i<=n
<operator>.postIncrement i++
<operator>.minus -1
<operator>.assignment i=0
<operator>.assignment i=0
<operator>.assignment i=0
<operator>.postIncrement n++
scanf scanf("%c",&str[n])
combine combine()
clear clear()
<operator>.assignment i=0
<operator>.notEquals i!=n
uqxkmylrgjbo uqxkmylrgjbo("%c, ",str[i])
uqxkmylrgjbo uqxkmylrgjbo ("%c",str[i])
<operator>.addressOf &c
<operator>.addressOf &d
<operator>.addressOf &ind
<operator>.addressOf &cxdbwaynnlvc
<operator>.addressOf &cxdbwaynnlvc
<operator>.addressOf &comb[i][0]
<operator>.addressOf &comb[i][1]
<operator>.addressOf &comb[i][2]
<operator>.addressOf &cxdbwaynnlvc
<operator>.addressOf &opp[i][0]
<operator>.addressOf &opp[i][1]
<operator>.indirectIndexAccess comb[i][0]
<operator>.indirectIndexAccess comb[i][1]
<operator>.indirectIndexAccess comb[i][2]
<operator>.indirectIndexAccess opp[i][0]
<operator>.indirectIndexAccess opp[i][1]
<operator>.addressOf &str[n]
<operator>.indirectIndexAccess comb[i]
<operator>.indirectIndexAccess comb[i]
<operator>.indirectIndexAccess comb[i]
<operator>.indirectIndexAccess opp[i]
<operator>.indirectIndexAccess opp[i]
<operator>.indirectIndexAccess str[n]
<operator>.indirectIndexAccess str[i]
<operator>.indirectIndexAccess str[i]
>>>PDG&60 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->29 0->30 0->31 0->32 0->33 0->34 2->1 2->3 3->1 3->1 3->1 3->3 3->4 3->6 3->7 3->8 3->9 3->10 3->11 3->11 3->12 3->13 3->16 3->19 3->21 3->23 3->24 3->25 3->26 3->31 3->35 3->36 3->37 3->38 4->1 4->3 5->1 5->3 6->1 6->1 6->21 6->27 7->1 7->13 8->1 8->16 9->1 9->19 10->1 10->15 10->18 11->1 11->4 12->1 13->1 13->1 13->7 13->13 13->14 13->14 13->15 13->39 13->40 13->41 13->42 13->46 13->47 13->48 13->52 13->53 13->54 14->1 14->13 15->1 15->1 15->1 15->10 15->18 16->1 16->1 16->8 16->16 16->17 16->17 16->18 16->43 16->44 16->45 16->49 16->50 16->55 16->56 17->1 17->16 18->1 18->1 18->10 19->1 19->1 19->9 19->19 19->20 19->20 19->27 19->28 19->29 19->30 19->51 19->57 20->1 20->19 21->1 21->1 21->1 21->21 21->22 21->32 21->32 21->32 22->1 22->21 23->6 24->13 25->16 26->19 27->1 27->21 28->1 29->1 30->1 31->1 31->21 32->1 32->21 32->22 32->33 32->34 32->58 32->59 33->1 33->1 33->34 34->1 34->1 34->33
>>>Token int main ( ) { scanf ( " " , & t ) ; for ( l = 1 ; l <= t ; l ++ ) { char cxdbwaynnlvc ; n = -1 ; scanf ( " " , & c ) ; for ( i = 0 ; i < c ; i ++ ) scanf ( " " , & cxdbwaynnlvc , & comb [ i ] [ 0 ] , & comb [ i ] [ 1 ] , & comb [ i ] [ 2 ] ) ; scanf ( " " , & d ) ; for ( i = 0 ; i < d ; i ++ ) scanf ( " " , & cxdbwaynnlvc , & opp [ i ] [ 0 ] , & opp [ i ] [ 1 ] ) ; scanf ( " " , & ind ) ; scanf ( " " , & cxdbwaynnlvc ) ; for ( i = 0 ; i < ind ; i ++ ) { n ++ ; scanf ( " " , & str [ n ] ) ; combine ( ) ; clear ( ) ; } uqxkmylrgjbo ( " " , l ) ; for ( i = 0 ; i <= n ; i ++ ) if ( i != n ) uqxkmylrgjbo ( " " , str [ i ] ) ; else uqxkmylrgjbo ( " " , str [ i ] ) ; uqxkmylrgjbo ( " \n " ) ; } }
>>>Func
METHOD mlxxqfknescs
METHOD_RETURN int
PARAM char rjfqqnkizwoe
IDENTIFIER rjfqqnkizwoe switch(rjfqqnkizwoe)
LITERAL 'Q' <empty>
RETURN return 1; return 1;
LITERAL 'W' <empty>
RETURN return 2; return 2;
LITERAL 'E' <empty>
RETURN return 3; return 3;
LITERAL 'R' <empty>
RETURN return 4; return 4;
LITERAL 'A' <empty>
RETURN return 5; return 5;
LITERAL 'S' <empty>
RETURN return 6; return 6;
LITERAL 'D' <empty>
RETURN return 7; return 7;
LITERAL 'F' <empty>
RETURN return 8; return 8;
RETURN return 0; return 0;
LITERAL 1 return 1;
LITERAL 2 return 2;
LITERAL 3 return 3;
LITERAL 4 return 4;
LITERAL 5 return 5;
LITERAL 6 return 6;
LITERAL 7 return 7;
LITERAL 8 return 8;
LITERAL 0 return 0;
>>>PDG&30 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 2->1 5->1 7->1 9->1 11->1 13->1 15->1 17->1 19->1 20->1 21->5 22->7 23->9 24->11 25->13 26->15 27->17 28->19 29->20
>>>Token int mlxxqfknescs ( char rjfqqnkizwoe ) { switch ( rjfqqnkizwoe ) { case ' ' : return 1 ; case ' ' : return 2 ; case ' ' : return 3 ; case ' ' : return 4 ; case ' ' : return 5 ; case ' ' : return 6 ; case ' ' : return 7 ; case ' ' : return 8 ; default : return 0 ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
scanf scanf("%d",&kfcmyvupnyce)
RETURN return 0; return 0;
<operator>.lessThan zlsxmlvsysid<kfcmyvupnyce
<operator>.postIncrement zlsxmlvsysid++
LITERAL 0 return 0;
<operator>.assignment zlsxmlvsysid=0
<operator>.assignment ruuraslkiifv=el2=r=laqgyubsvoum=op2='\0'
scanf scanf("%d",&zatvfeyxbenw)
scanf scanf("%c",&hrahogztpxzs)
scanf scanf("%c%c%c",&ruuraslkiifv,&el2,&r)
scanf scanf("%d",&D)
scanf scanf("%c",&hrahogztpxzs)
scanf scanf("%c %c",&laqgyubsvoum,&op2)
scanf scanf("%d",&N)
scanf scanf("%c",&hrahogztpxzs)
printf printf("Case #%d: [",zlsxmlvsysid+1)
printf printf("%c",izqvbidppygi[k-1],k)
printf printf("]\n")
scanf scanf("%c",&hrahogztpxzs)
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.lessThan j<k-1
<operator>.postIncrement j++
printf printf("%c, ",izqvbidppygi[j])
<operator>.assignment el2=r=laqgyubsvoum=op2='\0'
<operator>.expressionList k=0 j=0
scanf scanf("%c",&wizcqyfabvit[j])
kbasnakopwrx kbasnakopwrx(k)
BLOCK <empty> <empty>
<operator>.addition zlsxmlvsysid+1
<operator>.assignment j=0
<operator>.assignment r=laqgyubsvoum=op2='\0'
kbasnakopwrx kbasnakopwrx(wizcqyfabvit[j]==ruuraslkiifv&&izqvbidppygi[k-1]==el2)
<operator>.assignment izqvbidppygi[k-1]=r
<operator>.subtraction k-1
<operator>.subtraction k-1
<operator>.assignment laqgyubsvoum=op2='\0'
<operator>.assignment k=0
<operator>.assignment j=0
<operator>.assignment op2='\0'
<operator>.logicalAnd wizcqyfabvit[j]==ruuraslkiifv&&izqvbidppygi[k-1]==el2
<operator>.equals wizcqyfabvit[j]==ruuraslkiifv
<operator>.equals izqvbidppygi[k-1]==el2
<operator>.subtraction k-1
<operator>.subtraction k-1
UNKNOWN,),)
UNKNOWN,),)
UNKNOWN,),)
<operator>.addressOf &zatvfeyxbenw
<operator>.addressOf &hrahogztpxzs
<operator>.addressOf &ruuraslkiifv
<operator>.addressOf &el2
<operator>.addressOf &r
<operator>.addressOf &D
<operator>.addressOf &hrahogztpxzs
<operator>.addressOf &laqgyubsvoum
<operator>.addressOf &op2
<operator>.addressOf &N
<operator>.addressOf &hrahogztpxzs
<operator>.indirectIndexAccess izqvbidppygi[k-1]
<operator>.addressOf &hrahogztpxzs
UNKNOWN,),)
UNKNOWN else izqvbidppygi [k++]=wizcqyfabvit[j]; else izqvbidppygi [k++]=wizcqyfabvit[j];
<operator>.indirectIndexAccess izqvbidppygi[j]
<operator>.addressOf &wizcqyfabvit[j]
UNKNOWN,),)
UNKNOWN else kbasnakopwrx (wizcqyfabvit[j]==el2&&izqvbidppygi[k-1]==ruuraslkiifv)izqvbidppygi[k-1]=r; else kbasnakopwrx (wizcqyfabvit[j]==el2&&izqvbidppygi[k-1]==ruuraslkiifv)izqvbidppygi[k-1]=r;
UNKNOWN else kbasnakopwrx (wizcqyfabvit[j]==laqgyubsvoum){for(m=k-1;m>=0;m--)kbasnakopwrx(izqvbidppygi[m]==op2){k=0;break;}kbasnakopwrx(k)izqvbidppygi[k++]=wizcqyfabvit[j];} else kbasnakopwrx (wizcqyfabvit[j]==laqgyubsvoum){for(m=k-1;m>=0;m--)kbasnakopwrx(izqvbidppygi[m]==op2){k=0;break;}kbasnakopwrx(k)izqvbidppygi[k++]=wizcqyfabvit[j];}
UNKNOWN else kbasnakopwrx (wizcqyfabvit[j]==op2){for(m=k-1;m>=0;m--)kbasnakopwrx(izqvbidppygi[m]==laqgyubsvoum){k=0;break;}kbasnakopwrx(k)izqvbidppygi[k++]=wizcqyfabvit[j];} else kbasnakopwrx (wizcqyfabvit[j]==op2){for(m=k-1;m>=0;m--)kbasnakopwrx(izqvbidppygi[m]==laqgyubsvoum){k=0;break;}kbasnakopwrx(k)izqvbidppygi[k++]=wizcqyfabvit[j];}
UNKNOWN else izqvbidppygi [k++]=wizcqyfabvit[j]; else izqvbidppygi [k++]=wizcqyfabvit[j];
<operator>.indirectIndexAccess wizcqyfabvit[j]
<operator>.indirectIndexAccess izqvbidppygi[k-1]
<operator>.indirectIndexAccess wizcqyfabvit[j]
<operator>.indirectIndexAccess izqvbidppygi[k-1]
>>>PDG&77 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->31 0->32 0->33 0->34 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->44 0->45 0->46 0->47 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->10 5->11 5->12 5->13 5->14 5->15 5->16 5->17 5->18 5->18 5->19 5->20 5->21 5->22 5->24 5->27 5->28 5->32 5->32 5->33 5->34 5->37 5->38 5->39 5->40 5->41 5->42 5->48 5->49 5->50 5->51 5->52 5->53 5->54 5->55 5->56 5->57 5->58 5->59 5->60 5->61 5->62 5->63 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->1 9->12 9->44 10->1 11->14 12->1 12->1 12->1 12->44 13->1 14->11 14->17 15->1 15->1 16->1 16->22 17->11 17->14 17->21 18->1 18->1 19->1 19->1 19->1 19->45 20->1 21->1 21->11 22->1 22->1 22->16 22->22 22->23 22->23 22->29 22->30 22->35 22->36 22->43 22->44 22->46 22->64 22->65 22->67 22->68 22->69 22->70 22->71 22->72 22->73 22->74 22->75 23->1 23->22 24->1 24->1 24->24 24->25 24->25 24->26 24->37 24->66 25->1 25->24 26->1 26->1 27->1 27->1 27->9 27->45 28->1 28->1 29->1 29->44 30->1 30->46 30->47 33->1 33->24 34->1 34->1 34->9 34->27 34->36 35->1 35->1 36->1 36->1 36->19 36->45 37->24 37->24 37->38 38->19 39->1 39->1 39->9 39->15 39->27 39->34 40->28 40->30 40->37 41->22 41->28 42->1 42->9 42->27 42->34 42->39 43->1 43->1 43->35 43->35 44->1 44->1 44->29 44->43 44->43 44->45 44->47 44->76 45->1 45->43 45->43 46->30 46->37 47->46
>>>Token int main ( void ) { int kfcmyvupnyce ; int zatvfeyxbenw , D , N ; int zlsxmlvsysid , j , k , m ; char hrahogztpxzs ; char wizcqyfabvit [ 10 ] , izqvbidppygi [ 10 ] ; char ruuraslkiifv , el2 , r ; char laqgyubsvoum , op2 ; scanf ( " " , & kfcmyvupnyce ) ; for ( zlsxmlvsysid = 0 ; zlsxmlvsysid < kfcmyvupnyce ; zlsxmlvsysid ++ ) { ruuraslkiifv = el2 = r = laqgyubsvoum = op2 = ' \0 ' ; scanf ( " " , & zatvfeyxbenw ) ; scanf ( " " , & hrahogztpxzs ) ; kbasnakopwrx ( zatvfeyxbenw ) scanf ( " " , & ruuraslkiifv , & el2 , & r ) ; scanf ( " " , & D ) ; scanf ( " " , & hrahogztpxzs ) ; kbasnakopwrx ( D ) scanf ( " " , & laqgyubsvoum , & op2 ) ; scanf ( " " , & N ) ; scanf ( " " , & hrahogztpxzs ) ; for ( k = 0 , j = 0 ; j < N ; j ++ ) { scanf ( " " , & wizcqyfabvit [ j ] ) ; kbasnakopwrx ( k ) { kbasnakopwrx ( wizcqyfabvit [ j ] == ruuraslkiifv && izqvbidppygi [ k - 1 ] == el2 )  izqvbidppygi [ k - 1 ] = r ; else kbasnakopwrx ( wizcqyfabvit [ j ] = = el2 && izqvbidppygi [ k - 1 ] == ruuraslkiifv ) izqvbidppygi [ k - 1 ] = r ; else kbasnakopwrx ( wizcqyfabvit [ j ] = = laqgyubsvoum ) { for ( m = k - 1 ; m >= 0 ; m -- ) kbasnakopwrx ( izqvbidppygi [ m ] == op2 )  { k = 0 ; break ; } kbasnakopwrx ( k ) izqvbidppygi [ k ++ ] = wizcqyfabvit [ j ] ; } else kbasnakopwrx ( wizcqyfabvit [ j ] = = op2 ) { for ( m = k - 1 ; m >= 0 ; m -- ) kbasnakopwrx ( izqvbidppygi [ m ] == laqgyubsvoum )  { k = 0 ; break ; } kbasnakopwrx ( k ) izqvbidppygi [ k ++ ] = wizcqyfabvit [ j ] ; } else izqvbidppygi [ k ++ ] = wizcqyfabvit [ j ] ; } else izqvbidppygi [ k ++ ] = wizcqyfabvit [ j ] ; } printf ( " " , zlsxmlvsysid + 1 ) ; for ( j = 0 ; j < k - 1 ; j ++ ) printf ( " " , izqvbidppygi [ j ] ) ; kbasnakopwrx ( k ) printf ( " " , izqvbidppygi [ k - 1 ] , k ) ; printf ( " \n " ) ; scanf ( " " , & hrahogztpxzs ) ; } return 0 ; }
>>>Func
METHOD qyctpqusqcrnynfepevdecnx
METHOD_RETURN ANY
<operator>.assignment tloqbhlzguej [ ]={1 1 2 3 5 8 13 21 34 55 89 144 233 377 610}
<operator>.assignment mxrjojpsvngy=sizeof(tloqbhlzguej)/sizeof(int)
printf printf("1st test... ")
<operator>.assignment lqyjbountgvn=duplicateNumber(tloqbhlzguej,mxrjojpsvngy)
assert assert(lqyjbountgvn==1)
printf printf("passed\n")
<operator>.arrayInitializer {1 1 2 3 5 8 13 21 34 55 89 144 233 377 610}
duplicateNumber duplicateNumber(tloqbhlzguej,mxrjojpsvngy)
<operator>.equals lqyjbountgvn==1
<operator>.sizeOf sizeof(int)
>>>PDG&12 0->4 0->7 0->8 0->9 0->10 2->1 2->1 3->1 3->1 3->9 4->1 5->1 5->1 5->10 6->1 6->1 7->1 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 8->2 9->1 9->1 9->5 9->5 10->1 10->6 10->6 11->1
>>>Token static qyctpqusqcrnynfepevdecnx ( ) { uint32_t tloqbhlzguej [ ] = { 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 } ; size_t mxrjojpsvngy = sizeof ( tloqbhlzguej ) / sizeof ( int ) ; printf ( " " ) ; uint32_t lqyjbountgvn = duplicateNumber ( tloqbhlzguej , mxrjojpsvngy ) ; assert ( lqyjbountgvn == 1 ) ; printf ( " \n " ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
freopen freopen("B-small-attempt0.in","r",stdin)
freopen freopen("gcj_2.out","w",stdout)
scanf scanf("%d",&afiqgxpinusv)
RETURN return 0; return 0;
<operator>.lessEqualsThan i<=afiqgxpinusv
<operator>.postIncrement i++
LITERAL 0 return 0;
<operator>.assignment i=1
scanf scanf("%d",&c)
scanf scanf("%d",&d)
scanf scanf("%d",&n)
scanf scanf("%s",str)
printf printf("Case #%d: ",i)
work work()
<operator>.lessThan 0<missing
<operator>.greaterThan ';'>printf("======================\n")
printf printf("======================\n")
IDENTIFIER ndif <empty>
<operator>.lessThan j<c
<operator>.postIncrement j++
scanf scanf("%s",com[j])
<operator>.lessThan j<d
<operator>.postIncrement j++
scanf scanf("%s",opp[j])
<operator>.lessThan j<c
<operator>.postIncrement j++
printf printf("%s\n",com[j])
<operator>.lessThan j<d
<operator>.postIncrement j++
printf printf("%s\n",opp[j])
<operator>.assignment j=0
<operator>.assignment j=0
printf printf("======================\n")
<operator>.assignment j=0
<operator>.assignment j=0
UNKNOWN g g
UNKNOWN f f
<operator>.addressOf &c
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.indirectIndexAccess com[j]
<operator>.indirectIndexAccess opp[j]
<operator>.indirectIndexAccess com[j]
<operator>.indirectIndexAccess opp[j]
>>>PDG&47 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 2->1 3->1 3->1 4->1 4->1 5->1 5->7 6->1 7->1 7->1 7->1 7->7 7->8 7->11 7->12 7->13 7->14 7->15 7->15 7->16 7->17 7->18 7->19 7->21 7->24 7->27 7->30 7->33 7->34 7->35 7->36 7->37 7->38 7->39 7->40 7->41 7->42 8->1 8->7 9->6 10->1 10->7 11->1 11->21 11->27 12->1 12->24 12->30 13->1 14->1 15->1 15->8 16->1 17->1 17->1 18->1 19->1 21->21 21->22 21->22 21->23 21->27 21->43 22->1 22->21 23->1 23->29 24->24 24->25 24->25 24->26 24->30 24->44 25->1 25->24 26->1 26->32 27->1 27->1 27->11 27->21 27->27 27->28 27->28 27->29 27->45 28->1 28->27 29->1 29->1 29->23 30->1 30->1 30->1 30->12 30->24 30->30 30->31 30->31 30->32 30->46 31->1 31->30 32->1 32->1 32->26 33->21 34->24 35->18 36->27 37->1 37->30
>>>Token int main ( void ) { freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; int afiqgxpinusv , i , j ; scanf ( " " , & afiqgxpinusv ) ; for ( i = 1 ; i <= afiqgxpinusv ; i ++ ) { scanf ( " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) scanf ( " " , com [ j ] ) ; scanf ( " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) scanf ( " " , opp [ j ] ) ; scanf ( " " , & n ) ; scanf ( " " , str ) ; printf ( " " , i ) ; work ( ) ; 0 < missing ' ' > printf ( " \n " ) ; for ( j = 0 ; j < c ; j ++ ) printf ( " \n " , com [ j ] ) ; for ( j = 0 ; j < d ; j ++ ) printf ( " \n " , opp [ j ] ) ; printf ( " \n " ) ; ndif  } return 0 ; }
>>>Func
METHOD swvkydrbbxpx
METHOD_RETURN void
PARAM int lclufrnbszew
exit exit(lclufrnbszew)
<operator>.notEquals lclufrnbszew!=EXIT_SUCCESS
emit_try_help emit_try_help()
printf printf(_("\\012Usage: %s COMMAND [ARG]...\n\\012  or:  %s OPTION\n\\012"),program_name,program_name)
fputs fputs(_("\\012Run COMMAND, ignoring hangup signals.\n\\012\n\\012"),stdout)
fputs fputs(HELP_OPTION_DESCRIPTION,stdout)
fputs fputs(VERSION_OPTION_DESCRIPTION,stdout)
printf printf(_("\n\\012If standard input is a terminal, redirect it from an unreadable file.\n\\012If standard output is a terminal, append output to 'nohup.out' if possible,\n\\012'$HOME/nohup.out' otherwise.\n\\012If standard error is a terminal, redirect it to standard output.\n\\012To save output to FILE, use '%s COMMAND > FILE'.\n"),program_name)
printf printf(USAGE_BUILTIN_WARNING,PROGRAM_NAME)
emit_ancillary_info emit_ancillary_info(PROGRAM_NAME)
_ _("\\012Usage: %s COMMAND [ARG]...\n\\012  or:  %s OPTION\n\\012")
_ _("\\012Run COMMAND, ignoring hangup signals.\n\\012\n\\012")
_ _("\n\\012If standard input is a terminal, redirect it from an unreadable file.\n\\012If standard output is a terminal, append output to 'nohup.out' if possible,\n\\012'$HOME/nohup.out' otherwise.\n\\012If standard error is a terminal, redirect it to standard output.\n\\012To save output to FILE, use '%s COMMAND > FILE'.\n")
>>>PDG&16 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->4 3->1 4->1 4->1 4->3 4->5 4->6 4->7 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 5->1 6->1 6->1 6->10 7->1 7->1 7->8 8->1 8->1 8->9 9->1 9->1 9->1 10->1 10->1 10->1 11->1 11->1 11->12 12->1 12->1 13->6 14->7 15->10
>>>Token void swvkydrbbxpx ( int lclufrnbszew ) { if ( lclufrnbszew != EXIT_SUCCESS ) emit_try_help ( ) ; else { printf ( _ ( " \ " ) , program_name , program_name ) ; fputs ( _ ( " \
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%ld",&aapcvryehjaf)
RETURN return 0; return 0;
<operator>.lessThan dudfbzwycpux<aapcvryehjaf
<operator>.postIncrement dudfbzwycpux++
LITERAL 0 return 0;
<operator>.assignment dudfbzwycpux=0
scanf scanf("%ld",&beyvrvgetplm)
printf printf("Case #%d:\n",dudfbzwycpux+1)
<operator>.notEquals getchar()!='\n'
<operator>.lessThan sukqjhqunequ<beyvrvgetplm
<operator>.postIncrement sukqjhqunequ++
<operator>.lessThan sukqjhqunequ<beyvrvgetplm
<operator>.postIncrement sukqjhqunequ++
<operator>.lessThan sukqjhqunequ<beyvrvgetplm
<operator>.postIncrement sukqjhqunequ++
<operator>.assignment sukqjhqunequ=0
<operator>.assignment sukqjhqunequ=0
<operator>.assignment vccmpflrsyan=wpc(sukqjhqunequ,beyvrvgetplm,-1)
<operator>.assignment owp=owpc(sukqjhqunequ,beyvrvgetplm)
<operator>.assignment oowp=oowpc(sukqjhqunequ,beyvrvgetplm)
<operator>.assignment rpi[sukqjhqunequ]=0.25 *vccmpflrsyan+0.5 *owp+0.25 *oowp
<operator>.addition dudfbzwycpux+1
<operator>.assignment sukqjhqunequ=0
printf printf("%15.12f\n",rpi[sukqjhqunequ])
<operator>.lessThan j<beyvrvgetplm
<operator>.postIncrement j++
<operator>.notEquals getchar()!='\n'
<operator>.assignment j=0
<operator>.assignment sched[sukqjhqunequ][j]=getchar()
wpc wpc(sukqjhqunequ,beyvrvgetplm,-1)
owpc owpc(sukqjhqunequ,beyvrvgetplm)
oowpc oowpc(sukqjhqunequ,beyvrvgetplm)
<operator>.addition 0.25 *vccmpflrsyan+0.5 *owp+0.25 *oowp
<operator>.minus -1
<operator>.addition 0.25 *vccmpflrsyan+0.5 *owp
<operator>.multiplication 0.25 *oowp
<operator>.multiplication 0.25 *vccmpflrsyan
<operator>.multiplication 0.5 *owp
<operator>.addressOf &beyvrvgetplm
getchar getchar()
<operator>.indirectIndexAccess rpi[sukqjhqunequ]
<operator>.indirectIndexAccess rpi[sukqjhqunequ]
getchar getchar()
<operator>.indirectIndexAccess sched[sukqjhqunequ][j]
getchar getchar()
<operator>.indirectIndexAccess sched[sukqjhqunequ]
>>>PDG&48 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->37 0->38 0->39 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->5 4->8 4->9 4->9 4->10 4->11 4->13 4->15 4->17 4->18 4->23 4->23 4->24 4->40 4->41 5->1 5->4 6->3 7->1 7->4 8->1 8->11 8->13 8->15 8->26 8->31 8->32 8->33 9->1 9->1 10->1 10->1 11->11 11->12 11->12 11->13 11->26 11->26 11->28 11->29 11->44 12->1 12->11 13->13 13->14 13->15 13->19 13->20 13->21 13->22 13->31 13->31 13->31 13->32 13->33 13->34 13->35 13->36 13->37 13->38 13->39 13->42 14->1 14->13 15->1 15->1 15->1 15->8 15->11 15->15 15->16 15->16 15->25 15->43 16->1 16->15 17->11 18->13 19->1 19->1 19->38 20->1 20->1 20->39 21->1 21->1 21->37 22->1 22->1 22->1 22->25 24->1 24->15 25->1 25->1 26->1 26->1 26->11 26->26 26->27 26->27 26->30 26->45 26->46 26->47 27->1 27->26 28->1 28->1 29->1 29->26 30->1 30->1 31->1 31->19 31->19 31->19 31->32 31->32 32->20 32->20 32->33 32->33 33->13 33->14 33->21 33->21 34->1 34->1 35->31 36->1 36->1 37->1 37->22 37->22 37->34 37->34 38->1 38->22 38->22 38->34 38->34 38->36 38->36 39->1 39->22 39->22 39->34 39->34 39->36 39->36
>>>Token int main ( ) { int aapcvryehjaf ; int dudfbzwycpux ; int beyvrvgetplm ; int sukqjhqunequ , j ; double vccmpflrsyan , owp , oowp ; scanf ( " " , & aapcvryehjaf ) ; for ( dudfbzwycpux = 0 ; dudfbzwycpux < aapcvryehjaf ; dudfbzwycpux ++ ) { scanf ( " " , & beyvrvgetplm ) ; while ( getchar ( ) != ' \n ' ) ; for ( sukqjhqunequ = 0 ; sukqjhqunequ < beyvrvgetplm ; sukqjhqunequ ++ ) { for ( j = 0 ; j < beyvrvgetplm ; j ++ ) { sched [ sukqjhqunequ ] [ j ] = getchar ( ) ; } while ( getchar ( ) != ' \n ' ) ; } for ( sukqjhqunequ = 0 ; sukqjhqunequ < beyvrvgetplm ; sukqjhqunequ ++ ) { vccmpflrsyan = wpc ( sukqjhqunequ , beyvrvgetplm , -1 ) ; owp = owpc ( sukqjhqunequ , beyvrvgetplm ) ; oowp = oowpc ( sukqjhqunequ , beyvrvgetplm ) ; rpi [ sukqjhqunequ ] = 0.25 * vccmpflrsyan + 0.5 * owp + 0.25 * oowp ; } printf ( " \n " , dudfbzwycpux + 1 ) ; for ( sukqjhqunequ = 0 ; sukqjhqunequ < beyvrvgetplm ; sukqjhqunequ ++ ) { printf ( " \n " , rpi [ sukqjhqunequ ] ) ; } } return 0 ; }
>>>Func
METHOD momzdjmdedwq
METHOD_RETURN int
PARAM char *tab
PARAM char *tab_N
PARAM int dkxombtqsobx
PARAM int zcpjjvfcrphu
PARAM int *signet_0
PARAM int *signet_1
RETURN return 0; return 0;
<operator>.lessThan llwadtfsmemd<dkxombtqsobx
<operator>.postIncrement llwadtfsmemd++
LITERAL 0 return 0;
<operator>.assignment llwadtfsmemd=*signet_0+*signet_1+2
<operator>.equals tab_N[zcpjjvfcrphu]==tab[llwadtfsmemd *2]
<operator>.equals tab_N[zcpjjvfcrphu]==tab[llwadtfsmemd *2+1]
<operator>.addition *signet_0+*signet_1+2
<operator>.assignment *signet_0=llwadtfsmemd *2
<operator>.assignment *signet_1=-1
RETURN return 1; return 1;
<operator>.assignment *signet_0=-1
<operator>.assignment *signet_1=llwadtfsmemd *2+1
RETURN return 1; return 1;
LITERAL 1 return 1;
LITERAL 1 return 1;
<operator>.multiplication llwadtfsmemd *2
<operator>.multiplication llwadtfsmemd *2
<operator>.minus -1
<operator>.addition llwadtfsmemd *2+1
<operator>.minus -1
<operator>.addition llwadtfsmemd *2+1
<operator>.multiplication llwadtfsmemd *2
<operator>.multiplication llwadtfsmemd *2
<operator>.indirectIndexAccess tab_N[zcpjjvfcrphu]
<operator>.indirectIndexAccess tab[llwadtfsmemd *2]
<operator>.indirectIndexAccess tab_N[zcpjjvfcrphu]
<operator>.indirectIndexAccess tab[llwadtfsmemd *2+1]
<operator>.indirection *signet_0
<operator>.indirection *signet_1
<operator>.indirection *signet_0
<operator>.indirection *signet_1
>>>PDG&40 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->15 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->1 2->13 2->14 3->1 3->13 3->14 4->9 5->1 6->1 7->1 8->1 9->1 9->1 9->8 9->13 9->24 9->24 9->32 9->33 10->1 10->9 11->8 12->1 12->1 12->9 13->1 13->1 13->1 13->14 13->14 13->16 13->17 13->18 13->25 13->26 13->27 13->30 13->34 13->35 13->36 13->37 14->1 14->1 14->9 14->10 14->13 14->19 14->20 14->21 14->28 14->29 14->31 14->38 14->39 15->1 16->1 16->1 16->1 17->1 17->1 17->1 18->1 21->1 22->18 23->21 24->25 24->30 25->1 25->16 25->16 26->17 28->19 30->10 30->27 30->27 30->31 31->20 31->20 31->29 31->29
>>>Token int momzdjmdedwq ( char * tab , char * tab_N , int dkxombtqsobx , int zcpjjvfcrphu , int * signet_0 , int * signet_1 ) { for ( int llwadtfsmemd = * signet_0 + * signet_1 + 2 ; llwadtfsmemd < dkxombtqsobx ; llwadtfsmemd ++ ) { if ( tab_N [ zcpjjvfcrphu ] == tab [ llwadtfsmemd * 2 ] ) { * signet_0 = llwadtfsmemd * 2 ; * signet_1 = -1 ; return 1 ; } if ( tab_N [ zcpjjvfcrphu ] == tab [ llwadtfsmemd * 2 + 1 ] ) { * signet_0 = -1 ; * signet_1 = llwadtfsmemd * 2 + 1 ; return 1 ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int yygdlmlkdgkn
PARAM eqhvrlnvbzox *argv [ ]
<operator>.assignment yavgxwkqmazx=0
<operator>.assignment *str=argv[1]
<operator>.expressionList *s *t
printf printf("Sum is: %d\n",yavgxwkqmazx)
RETURN return 0; return 0;
<operator>.preIncrement ++t
LITERAL 0 return 0;
<operator>.assignment t=str
<operator>.greaterThan *t>127
<operator>.assignmentPlus yavgxwkqmazx+=*t
<operator>.assignmentPlus yavgxwkqmazx +=*t
<operator>.indirection *t
<operator>.indirection *t
<operator>.indirection *t
<operator>.indirection *t
>>>PDG&19 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 3->5 4->1 4->7 4->13 4->14 5->1 5->1 5->1 5->11 6->1 6->1 6->1 6->12 7->1 7->1 8->1 9->1 9->1 10->8 11->1 11->1 11->1 11->9 12->1 12->9 12->13 12->13 12->14 12->14 12->17 12->18 13->1 13->1 13->7 13->14 14->1 14->1 14->7 14->13 15->9 15->12 15->15 15->16
>>>Token int main ( int yygdlmlkdgkn , eqhvrlnvbzox * argv [ ] ) { int bfuslslybqht , j ; int yavgxwkqmazx = 0 ; bprzfvcjdmbt eqhvrlnvbzox  * str = argv [ 1 ] ; register bprzfvcjdmbt eqhvrlnvbzox  * s , * t ; for ( t = str ; * t ; ++ t ) { if ( * t > 127 ) yavgxwkqmazx += * t ; else yavgxwkqmazx += * t ; } printf ( " \n " , yavgxwkqmazx ) ; return 0 ; }
>>>Func
METHOD mzxycocfgwux
METHOD_RETURN int
PARAM int xksbdpohnjml [ ]
PARAM int tkcdpbqqtfyn
PARAM int eqwwhfznxtnf
<operator>.assignment gllokahbgzhs=0
<operator>.assignment high=tkcdpbqqtfyn-1
<operator>.subtraction mpukfopdpqvr-1
<operator>.logicalAnd gllokahbgzhs<=high&&eqwwhfznxtnf>=xksbdpohnjml[gllokahbgzhs]&&eqwwhfznxtnf<=xksbdpohnjml[high]
<operator>.subtraction tkcdpbqqtfyn-1
<operator>.assignment mgrpsctmmjky=gllokahbgzhs+((eqwwhfznxtnf-xksbdpohnjml[gllokahbgzhs])*(high-gllokahbgzhs))/(xksbdpohnjml[high]-xksbdpohnjml[gllokahbgzhs])
lizqecbjrelk lizqecbjrelk(eqwwhfznxtnf>xksbdpohnjml[mgrpsctmmjky])
<operator>.assignment gllokahbgzhs=mgrpsctmmjky+1
<operator>.logicalAnd gllokahbgzhs<=high&&eqwwhfznxtnf>=xksbdpohnjml[gllokahbgzhs]
<operator>.lessEqualsThan eqwwhfznxtnf<=xksbdpohnjml[high]
<operator>.lessEqualsThan gllokahbgzhs<=high
<operator>.greaterEqualsThan eqwwhfznxtnf>=xksbdpohnjml[gllokahbgzhs]
<operator>.addition gllokahbgzhs+((eqwwhfznxtnf-xksbdpohnjml[gllokahbgzhs])*(high-gllokahbgzhs))/(xksbdpohnjml[high]-xksbdpohnjml[gllokahbgzhs])
<operator>.greaterThan eqwwhfznxtnf>xksbdpohnjml[mgrpsctmmjky]
<operator>.addition mgrpsctmmjky+1
<operator>.division ((eqwwhfznxtnf-xksbdpohnjml[gllokahbgzhs])*(high-gllokahbgzhs))/(xksbdpohnjml[high]-xksbdpohnjml[gllokahbgzhs])
<operator>.multiplication (eqwwhfznxtnf-xksbdpohnjml[gllokahbgzhs])*(high-gllokahbgzhs)
<operator>.subtraction xksbdpohnjml[high]-xksbdpohnjml[gllokahbgzhs]
<operator>.subtraction eqwwhfznxtnf-xksbdpohnjml[gllokahbgzhs]
<operator>.subtraction high-gllokahbgzhs
UNKNOWN,),)
UNKNOWN else lizqecbjrelk (eqwwhfznxtnf<xksbdpohnjml[mgrpsctmmjky])high=mgrpsctmmjky-1; else lizqecbjrelk (eqwwhfznxtnf<xksbdpohnjml[mgrpsctmmjky])high=mgrpsctmmjky-1;
UNKNOWN else mpukfopdpqvr mgrpsctmmjky; else mpukfopdpqvr mgrpsctmmjky;
<operator>.indirectIndexAccess xksbdpohnjml[high]
<operator>.indirectIndexAccess xksbdpohnjml[gllokahbgzhs]
<operator>.indirectIndexAccess xksbdpohnjml[mgrpsctmmjky]
<operator>.indirectIndexAccess xksbdpohnjml[high]
<operator>.indirectIndexAccess xksbdpohnjml[gllokahbgzhs]
<operator>.indirectIndexAccess xksbdpohnjml[gllokahbgzhs]
>>>PDG&34 0->2 0->3 0->4 0->5 0->7 0->9 0->10 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->23 0->24 2->1 2->14 2->16 2->18 2->22 2->23 3->9 4->1 4->14 4->16 4->23 5->1 5->15 6->1 6->1 6->15 7->1 7->1 8->1 8->1 8->1 8->8 8->10 8->11 8->12 8->13 8->15 8->17 8->18 8->19 8->20 8->21 8->22 8->23 8->24 8->25 8->26 8->27 8->30 8->31 8->32 8->33 9->1 9->6 9->6 10->1 10->1 10->12 10->19 11->1 11->1 12->1 12->1 12->15 13->1 13->1 13->8 13->8 13->14 13->28 14->1 14->1 14->8 14->8 14->22 14->23 15->1 15->1 15->13 15->13 15->16 15->24 15->24 15->29 16->1 16->1 16->13 16->13 16->14 16->23 16->23 17->1 18->1 18->1 18->11 18->11 18->14 18->16 18->23 19->1 20->1 20->1 20->10 20->10 20->17 20->17 21->1 21->1 21->20 21->20 22->1 22->1 22->14 22->16 22->20 22->20 22->23 23->18 23->21 23->21 23->22 24->10 24->15 24->17 24->21 24->21
>>>Token int mzxycocfgwux ( int xksbdpohnjml [ ] , int tkcdpbqqtfyn , int eqwwhfznxtnf ) { int gllokahbgzhs = 0 , high = tkcdpbqqtfyn - 1 ; while ( gllokahbgzhs <= high && eqwwhfznxtnf >= xksbdpohnjml [ gllokahbgzhs ] && eqwwhfznxtnf <= xksbdpohnjml [ high ] ) { int mgrpsctmmjky = gllokahbgzhs + ( ( eqwwhfznxtnf - xksbdpohnjml [ gllokahbgzhs ] ) * ( high - gllokahbgzhs ) ) / ( xksbdpohnjml [ high ] - xksbdpohnjml [ gllokahbgzhs ] ) ; lizqecbjrelk ( eqwwhfznxtnf > xksbdpohnjml [ mgrpsctmmjky ] )  gllokahbgzhs = mgrpsctmmjky + 1 ; else lizqecbjrelk ( eqwwhfznxtnf < xksbdpohnjml [ mgrpsctmmjky ] ) high = mgrpsctmmjky - 1 ; else mpukfopdpqvr  mgrpsctmmjky ; } mpukfopdpqvr - 1 ; }
>>>Func
METHOD ovpbdwknrkuu
METHOD_RETURN void
PARAM double mpyykuwpmvdn
PARAM double *x
PARAM double *y
PARAM double *dy
problem problem(x,y,dy)
<operator>.assignment cvraewldylce=(*x)+0.5 *mpyykuwpmvdn
problem problem(&cvraewldylce,rxibpigrqhft,dy)
<operator>.lessThan qgukumcheobx<order
<operator>.postIncrement qgukumcheobx++
<operator>.assignment rxibpigrqhft[qgukumcheobx]=y[qgukumcheobx]+0.5 *mpyykuwpmvdn *dy[qgukumcheobx]
<operator>.lessThan qgukumcheobx<order
<operator>.postIncrement qgukumcheobx++
<operator>.assignmentPlus y[qgukumcheobx]+=mpyykuwpmvdn *dy[qgukumcheobx]
<operator>.addition (*x)+0.5 *mpyykuwpmvdn
<operator>.assignment qgukumcheobx=0
<operator>.assignment qgukumcheobx=0
<operator>.multiplication 0.5 *mpyykuwpmvdn
<operator>.addition y[qgukumcheobx]+0.5 *mpyykuwpmvdn *dy[qgukumcheobx]
<operator>.multiplication mpyykuwpmvdn *dy[qgukumcheobx]
<operator>.multiplication 0.5 *mpyykuwpmvdn *dy[qgukumcheobx]
<operator>.multiplication 0.5 *mpyykuwpmvdn
<operator>.indirectIndexAccess rxibpigrqhft[qgukumcheobx]
<operator>.indirectIndexAccess y[qgukumcheobx]
<operator>.indirectIndexAccess y[qgukumcheobx]
<operator>.indirectIndexAccess dy[qgukumcheobx]
<operator>.indirectIndexAccess dy[qgukumcheobx]
>>>PDG&28 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->12 0->13 0->16 0->17 0->18 0->20 0->22 2->18 3->6 4->6 5->6 6->1 6->1 6->1 6->8 6->11 6->14 6->19 6->21 7->1 7->1 7->1 7->8 8->1 8->1 8->1 8->1 8->20 9->9 9->10 9->10 9->11 9->12 9->19 9->21 9->22 9->23 9->25 9->27 10->1 10->9 11->8 12->1 12->1 12->1 12->12 12->13 12->13 12->14 12->20 12->24 12->26 13->1 13->12 15->1 15->1 16->9 17->1 17->12 18->1 18->7 18->7 18->15 18->15 18->20 18->22 20->14 20->14 21->8 21->11 21->11 21->19 21->19 21->20 22->20 22->21 22->21
>>>Token void ovpbdwknrkuu ( double mpyykuwpmvdn , double * x , double * y , double * dy ) { problem ( x , y , dy ) ; double cvraewldylce = ( * x ) + 0.5 * mpyykuwpmvdn ; double rxibpigrqhft [ order ] ; int qgukumcheobx ; for ( qgukumcheobx = 0 ; qgukumcheobx < order ; qgukumcheobx ++ ) rxibpigrqhft [ qgukumcheobx ] = y [ qgukumcheobx ] + 0.5 * mpyykuwpmvdn * dy [ qgukumcheobx ] ; problem ( & cvraewldylce , rxibpigrqhft , dy ) ; for ( qgukumcheobx = 0 ; qgukumcheobx < order ; qgukumcheobx ++ ) y [ qgukumcheobx ] += mpyykuwpmvdn * dy [ qgukumcheobx ] ; }
>>>Func
METHOD read_string
METHOD_RETURN char*
PARAM void
<operator>.assignment eocrbppsjqxe[strcspn(eocrbppsjqxe,"\r\n")]=0
RETURN return fgdahuuwzkpk(eocrbppsjqxe); return fgdahuuwzkpk(eocrbppsjqxe);
<operator>.logicalNot !fgets(eocrbppsjqxe,1000,stdin)
fgdahuuwzkpk fgdahuuwzkpk(eocrbppsjqxe)
perror perror("fgets")
exit exit(-1)
fgets fgets(eocrbppsjqxe,1000,stdin)
strcspn strcspn(eocrbppsjqxe,"\r\n")
<operator>.minus -1
>>>PDG&12 0->2 0->3 0->6 0->7 0->9 0->10 0->11 2->1 3->1 3->1 3->6 4->1 5->1 5->1 5->7 5->8 5->11 6->1 6->1 6->4 7->1 8->1 9->1 9->5 9->5 9->5 9->10 10->6 11->8
>>>Token char * read_string ( void ) { char eocrbppsjqxe [ 1000 ] ; if ( ! fgets ( eocrbppsjqxe , 1000 , stdin ) ) { perror ( " " ) ; exit ( -1 ) ; } eocrbppsjqxe [ strcspn ( eocrbppsjqxe , " \r \n " ) ] = 0 ; return fgdahuuwzkpk ( eocrbppsjqxe ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int szonibbhzrtv
PARAM char **argv
scanf scanf("%d",&bqsoekquvxsu)
RETURN return 0; return 0;
<operator>.lessEqualsThan mkhzuxylzdvi<=bqsoekquvxsu
<operator>.postIncrement mkhzuxylzdvi++
LITERAL 0 return 0;
<operator>.assignment mkhzuxylzdvi=1
run_exp run_exp(mkhzuxylzdvi)
>>>PDG&11 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->10 7->1 7->6 8->5 9->1 9->6 10->1 10->7
>>>Token int main ( int szonibbhzrtv , char * * argv ) { int bqsoekquvxsu ; int mkhzuxylzdvi ; scanf ( " " , & bqsoekquvxsu ) ; for ( mkhzuxylzdvi = 1 ; mkhzuxylzdvi <= bqsoekquvxsu ; mkhzuxylzdvi ++ ) { run_exp ( mkhzuxylzdvi ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&qnzvtnajrzag)
<operator>.lessEqualsThan i<=qnzvtnajrzag
<operator>.postIncrement i++
<operator>.assignment i=1
printf printf("Case #%d: ",i)
solve solve()
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 2->3 3->1 3->1 3->1 3->3 3->4 3->6 3->6 3->7 4->1 4->3 5->1 5->3 6->1 6->4 7->1
>>>Token int main ( ) { int qnzvtnajrzag , i ; scanf ( " " , & qnzvtnajrzag ) ; for ( i = 1 ; i <= qnzvtnajrzag ; i ++ ) { printf ( " " , i ) ; solve ( ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
scanf scanf("%d",&nrcases)
<operator>.lessEqualsThan testcase<=nrcases
<operator>.postIncrement testcase++
RETURN return 0; return 0;
LITERAL 0 return 0;
>>>PDG&8 0->2 0->3 0->4 0->5 0->6 0->7 2->1 3->1 3->4 4->1 4->1 4->5 5->1 5->1 6->1 7->6
>>>Token int main ( void ) { scanf ( " " , & nrcases ) ; qwlhvohamqgh ( testcase = 1  ; testcase <= nrcases ; testcase ++ ) { qwlhvohamqgh ( i = 0  ; i <= 8 ; i ++ ) qwlhvohamqgh ( j = 0 ; j <= 8 ; j ++ ) { comb [ i ] [ j ] = ' ' ; op [ i ] [ j ] = 0 ; } scanf ( " " , & c ) ; qwlhvohamqgh ( i = 1  ; i <= c ; i ++ ) { scanf ( " " , s ) ; comb [ ci ( s [ 0 ] ) ] [ ci ( s [ 1 ] ) ] = s [ 2 ] ; comb [ ci ( s [ 1 ] ) ] [ ci ( s [ 0 ] ) ] = s [ 2 ] ; } scanf ( " " , & d ) ; qwlhvohamqgh ( i = 1  ; i <= d ; i ++ ) { scanf ( " " , s ) ; op [ ci ( s [ 0 ] ) ] [ ci ( s [ 1 ] ) ] = 1 ; op [ ci ( s [ 1 ] ) ] [ ci ( s [ 0 ] ) ] = 1 ; } ansl = 1 ; scanf ( " " , & n , & ans [ 1 ] ) ; qwlhvohamqgh ( i = 2  ; i <= n ; i ++ ) { scanf ( " " , & ch ) ; ansl ++ ; ans [ ansl ] = ch ; if ( ( ansl >= 2 ) && ( comb [ ci ( ans [ ansl ] ) ] [ ci ( ans [ ansl - 1 ] ) ] != ' ' ) ) { ans [ ansl - 1 ] = comb [ ci ( ans [ ansl ] ) ] [ ci ( ans [ ansl - 1 ] ) ] ; ansl -- ; } else qwlhvohamqgh ( j = 1  ; j < ansl ; j ++ ) if ( op [ ci ( ans [ ansl ] ) ] [ ci ( ans [ j ] ) ] ) ansl = 0 ; } printf ( " " , testcase ) ; qwlhvohamqgh ( i = 1  ; i < ansl ; i ++ ) printf ( " " , ans [ i ] ) ; if ( ansl > 0 ) printf ( " " , ans [ ansl ] ) ; printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf("Input file: ")
scanf scanf("%s",myotlwuhhrfu)
ujldpscrople ujldpscrople((ofp=fopen("output.txt","w"))==NULL)
printf printf("Can't open output file.\n")
RETURN return (0); return (0);
<operator>.equals (ofp=fopen("output.txt","w"))==NULL
LITERAL 0 return (0);
<operator>.assignment ofp=fopen("output.txt","w")
fopen fopen("output.txt","w")
<operator>.lessThan i<lymrggnrvtbz
<operator>.postIncrement i++
fscanf fscanf(ifp,"%d",&c)
fscanf fscanf(ifp,"%d",&d)
fscanf fscanf(ifp,"%d",&n)
fscanf fscanf(ifp,"%s",zjdqltxbhfgl)
<operator>.assignment udbztuowigre=0
printf printf("Case #%d: [",i+1)
fprintf fprintf(ofp,"Case #%d: [",i+1)
printf printf("]\n")
fprintf fprintf(ofp,"]\n")
<operator>.addressOf &c
<operator>.lessThan j<c
<operator>.postIncrement j++
fscanf fscanf(ifp,"%s",ikbgnhkkrrih[j])
<operator>.addressOf &d
<operator>.lessThan j<d
<operator>.postIncrement j++
fscanf fscanf(ifp,"%s",fuumowxqbnju[j])
<operator>.addressOf &n
<operator>.lessThan j<n-1
<operator>.postIncrement j++
<operator>.addition i+1
<operator>.addition i+1
<operator>.lessThan rtlgvtdmvxjc<udbztuowigre
<operator>.postIncrement rtlgvtdmvxjc++
<operator>.assignment j=0
<operator>.indirectIndexAccess ikbgnhkkrrih[j]
<operator>.assignment j=0
<operator>.indirectIndexAccess fuumowxqbnju[j]
<operator>.assignment j=0
<operator>.subtraction n-1
<operator>.assignment dmefirvnfbur=0
ujldpscrople ujldpscrople(!(zjdqltxbhfgl[j]=='Q'||zjdqltxbhfgl[j]=='W'||zjdqltxbhfgl[j]=='E'||zjdqltxbhfgl[j]=='R'||zjdqltxbhfgl[j]=='A'||zjdqltxbhfgl[j]=='S'||zjdqltxbhfgl[j]=='D'||zjdqltxbhfgl[j]=='F'))
UNKNOWN,),)
<operator>.assignment rtlgvtdmvxjc=0
printf printf("%c",naoklgzvsyin[rtlgvtdmvxjc])
fprintf fprintf(ofp,"%c",naoklgzvsyin[rtlgvtdmvxjc])
ujldpscrople ujldpscrople(rtlgvtdmvxjc<udbztuowigre-1)
UNKNOWN,),)
<operator>.logicalNot !(zjdqltxbhfgl[j]=='Q'||zjdqltxbhfgl[j]=='W'||zjdqltxbhfgl[j]=='E'||zjdqltxbhfgl[j]=='R'||zjdqltxbhfgl[j]=='A'||zjdqltxbhfgl[j]=='S'||zjdqltxbhfgl[j]=='D'||zjdqltxbhfgl[j]=='F')
<operator>.lessThan k<c
<operator>.lessThan k<d
<operator>.indirectIndexAccess naoklgzvsyin[rtlgvtdmvxjc]
<operator>.indirectIndexAccess naoklgzvsyin[rtlgvtdmvxjc]
<operator>.lessThan rtlgvtdmvxjc<udbztuowigre-1
printf printf(", ")
fprintf fprintf(ofp,", ")
<operator>.logicalOr zjdqltxbhfgl[j]=='Q'||zjdqltxbhfgl[j]=='W'||zjdqltxbhfgl[j]=='E'||zjdqltxbhfgl[j]=='R'||zjdqltxbhfgl[j]=='A'||zjdqltxbhfgl[j]=='S'||zjdqltxbhfgl[j]=='D'||zjdqltxbhfgl[j]=='F'
ujldpscrople ujldpscrople(zjdqltxbhfgl[j]==ikbgnhkkrrih[k][0]&&zjdqltxbhfgl[j+1]==ikbgnhkkrrih[k][1]||zjdqltxbhfgl[j]==ikbgnhkkrrih[k][1]&&zjdqltxbhfgl[j+1]==ikbgnhkkrrih[k][0])
UNKNOWN,),)
ujldpscrople ujldpscrople(zjdqltxbhfgl[j]==fuumowxqbnju[k][0])
UNKNOWN,),)
<operator>.subtraction udbztuowigre-1
<operator>.logicalOr zjdqltxbhfgl[j]=='Q'||zjdqltxbhfgl[j]=='W'||zjdqltxbhfgl[j]=='E'||zjdqltxbhfgl[j]=='R'||zjdqltxbhfgl[j]=='A'||zjdqltxbhfgl[j]=='S'||zjdqltxbhfgl[j]=='D'
<operator>.equals zjdqltxbhfgl[j]=='F'
<operator>.logicalOr zjdqltxbhfgl[j]==ikbgnhkkrrih[k][0]&&zjdqltxbhfgl[j+1]==ikbgnhkkrrih[k][1]||zjdqltxbhfgl[j]==ikbgnhkkrrih[k][1]&&zjdqltxbhfgl[j+1]==ikbgnhkkrrih[k][0]
<operator>.assignment naoklgzvsyin[udbztuowigre++]=ikbgnhkkrrih[k][2]
<operator>.assignment dmefirvnfbur=1
<operator>.postIncrement j++
<operator>.equals zjdqltxbhfgl[j]==fuumowxqbnju[k][0]
ujldpscrople ujldpscrople(zjdqltxbhfgl[j+1]==fuumowxqbnju[k][1])
UNKNOWN,),)
UNKNOWN else     ujldpscrople (j<n-2){ujldpscrople(zjdqltxbhfgl[j+2]==fuumowxqbnju[k][1]){int sgpdysywlodc;for(sgpdysywlodc=0;sgpdysywlodc<c;sgpdysywlodc++){ujldpscrople(zjdqltxbhfgl[j+1]==ikbgnhkkrrih[sgpdysywlodc][0]&&zjdqltxbhfgl[j+2]==ikbgnhkkrrih[sgpdysywlodc][1]||zjdqltxbhfgl[j+1]==ikbgnhkkrrih[sgpdysywlodc][1]&&zjdqltxbhfgl[j+2]==ikbgnhkkrrih[sgpdysywlodc][0]){naoklgzvsyin[udbztuowigre++]=zjdqltxbhfgl[j];naoklgzvsyin[udbztuowigre++]=ikbgnhkkrrih[sgpdysywlodc][2];break;}}j+=2;dmefirvnfbur=1;}else    {continue;}} else     ujldpscrople (j<n-2){ujldpscrople(zjdqltxbhfgl[j+2]==fuumowxqbnju[k][1]){int sgpdysywlodc;for(sgpdysywlodc=0;sgpdysywlodc<c;sgpdysywlodc++){ujldpscrople(zjdqltxbhfgl[j+1]==ikbgnhkkrrih[sgpdysywlodc][0]&&zjdqltxbhfgl[j+2]==ikbgnhkkrrih[sgpdysywlodc][1]||zjdqltxbhfgl[j+1]==ikbgnhkkrrih[sgpdysywlodc][1]&&zjdqltxbhfgl[j+2]==ikbgnhkkrrih[sgpdysywlodc][0]){naoklgzvsyin[udbztuowigre++]=zjdqltxbhfgl[j];naoklgzvsyin[udbztuowigre++]=ikbgnhkkrrih[sgpdysywlodc][2];break;}}j+=2;dmefirvnfbur=1;}else    {continue;}}
UNKNOWN else    {continue;} else    {continue;}
UNKNOWN,),)
<operator>.logicalOr zjdqltxbhfgl[j]=='Q'||zjdqltxbhfgl[j]=='W'||zjdqltxbhfgl[j]=='E'||zjdqltxbhfgl[j]=='R'||zjdqltxbhfgl[j]=='A'||zjdqltxbhfgl[j]=='S'
<operator>.equals zjdqltxbhfgl[j]=='D'
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
<operator>.logicalAnd zjdqltxbhfgl[j]==ikbgnhkkrrih[k][0]&&zjdqltxbhfgl[j+1]==ikbgnhkkrrih[k][1]
<operator>.logicalAnd zjdqltxbhfgl[j]==ikbgnhkkrrih[k][1]&&zjdqltxbhfgl[j+1]==ikbgnhkkrrih[k][0]
<operator>.indirectIndexAccess naoklgzvsyin[udbztuowigre++]
<operator>.indirectIndexAccess ikbgnhkkrrih[k][2]
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
<operator>.indirectIndexAccess fuumowxqbnju[k][0]
<operator>.equals zjdqltxbhfgl[j+1]==fuumowxqbnju[k][1]
<operator>.postIncrement j++
<operator>.assignment dmefirvnfbur=1
<operator>.logicalOr zjdqltxbhfgl[j]=='Q'||zjdqltxbhfgl[j]=='W'||zjdqltxbhfgl[j]=='E'||zjdqltxbhfgl[j]=='R'||zjdqltxbhfgl[j]=='A'
<operator>.equals zjdqltxbhfgl[j]=='S'
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
<operator>.equals zjdqltxbhfgl[j]==ikbgnhkkrrih[k][0]
<operator>.equals zjdqltxbhfgl[j+1]==ikbgnhkkrrih[k][1]
<operator>.equals zjdqltxbhfgl[j]==ikbgnhkkrrih[k][1]
<operator>.equals zjdqltxbhfgl[j+1]==ikbgnhkkrrih[k][0]
<operator>.postIncrement udbztuowigre++
<operator>.indirectIndexAccess ikbgnhkkrrih[k]
<operator>.indirectIndexAccess fuumowxqbnju[k]
<operator>.indirectIndexAccess zjdqltxbhfgl[j+1]
<operator>.indirectIndexAccess fuumowxqbnju[k][1]
<operator>.logicalOr zjdqltxbhfgl[j]=='Q'||zjdqltxbhfgl[j]=='W'||zjdqltxbhfgl[j]=='E'||zjdqltxbhfgl[j]=='R'
<operator>.equals zjdqltxbhfgl[j]=='A'
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
<operator>.indirectIndexAccess ikbgnhkkrrih[k][0]
<operator>.indirectIndexAccess zjdqltxbhfgl[j+1]
<operator>.indirectIndexAccess ikbgnhkkrrih[k][1]
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
<operator>.indirectIndexAccess ikbgnhkkrrih[k][1]
<operator>.indirectIndexAccess zjdqltxbhfgl[j+1]
<operator>.indirectIndexAccess ikbgnhkkrrih[k][0]
<operator>.addition j+1
<operator>.indirectIndexAccess fuumowxqbnju[k]
<operator>.logicalOr zjdqltxbhfgl[j]=='Q'||zjdqltxbhfgl[j]=='W'||zjdqltxbhfgl[j]=='E'
<operator>.equals zjdqltxbhfgl[j]=='R'
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
<operator>.indirectIndexAccess ikbgnhkkrrih[k]
<operator>.addition j+1
<operator>.indirectIndexAccess ikbgnhkkrrih[k]
<operator>.indirectIndexAccess ikbgnhkkrrih[k]
<operator>.addition j+1
<operator>.indirectIndexAccess ikbgnhkkrrih[k]
<operator>.logicalOr zjdqltxbhfgl[j]=='Q'||zjdqltxbhfgl[j]=='W'
<operator>.equals zjdqltxbhfgl[j]=='E'
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
<operator>.equals zjdqltxbhfgl[j]=='Q'
<operator>.equals zjdqltxbhfgl[j]=='W'
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
<operator>.indirectIndexAccess zjdqltxbhfgl[j]
>>>PDG&131 0->2 0->3 0->5 0->6 0->7 0->8 0->10 2->1 3->1 4->1 4->1 5->1 6->1 7->1 7->1 7->4 7->4 8->6 9->1 9->1 9->7 10->7 10->7 10->9 10->9 11->11 11->12 11->13 11->14 11->15 11->16 11->17 11->18 11->19 11->20 11->21 11->22 11->23 11->26 11->27 11->30 11->31 11->33 11->34 11->35 11->37 11->39 11->41 11->42 11->46 23->23 23->24 23->25 23->38 27->27 27->28 27->29 27->40 31->31 31->32 31->42 31->43 31->44 31->45 31->51 31->59 31->65 31->77 31->89 31->101 31->114 31->123 31->126 31->129 35->35 35->36 35->47 35->48 35->49 35->50 35->54 35->55 35->56 35->57 35->58 35->64 52->60 52->61 52->67 52->68 52->69 52->70 52->80 52->82 52->83 52->92 52->96 52->97 52->104 52->105 52->117 53->62 53->63 53->71 53->72 53->73 53->74 53->75 53->76 53->84 53->85 53->86 53->87 53->88 53->98 53->99 53->100 53->112 53->113 65->66 65->79 77->78 77->91 80->81 80->94 80->108 80->109 80->120 89->90 89->103 92->93 92->106 92->107 92->118 92->119 94->95 94->110 94->111 94->121 94->122 101->102 101->116 114->115 114->125 123->124 123->128 126->127 126->130
>>>Token int main ( ) { FILE * ifp ; FILE * ofp ; char myotlwuhhrfu [ 128 ] ; int lymrggnrvtbz , c , d , n ; int eaayysxvhanq , i , j , k ; char ikbgnhkkrrih [ 36 ] [ 4 ] ; char fuumowxqbnju [ 28 ] [ 3 ] ; char zjdqltxbhfgl [ 110 ] ; char naoklgzvsyin [ 110 ] ; int dmefirvnfbur ; int udbztuowigre ; int rtlgvtdmvxjc ; printf ( " " ) ; scanf ( " " , myotlwuhhrfu ) ; ujldpscrople ( ( ofp = fopen ( " " , " " ) ) == NULL )  { printf ( " \n " ) ; return ( 0 ) ; } ujldpscrople ( ( ifp = fopen ( myotlwuhhrfu , " " ) ) == NULL )  { printf ( " \n " ) ; return ( 0 ) ; } fscanf ( ifp , " " , & lymrggnrvtbz ) ; for ( i = 0 ; i < lymrggnrvtbz ; i ++ ) { fscanf ( ifp , " " , & c ) ; for ( j = 0 ; j < c ; j ++ ) fscanf ( ifp , " " , ikbgnhkkrrih [ j ] ) ; fscanf ( ifp , " " , & d ) ; for ( j = 0 ; j < d ; j ++ ) fscanf ( ifp , " " , fuumowxqbnju [ j ] ) ; fscanf ( ifp , " " , & n ) ; fscanf ( ifp , " " , zjdqltxbhfgl ) ; udbztuowigre = 0 ; for ( j = 0 ; j < n - 1 ; j ++ ) { dmefirvnfbur = 0 ; ujldpscrople ( ! ( zjdqltxbhfgl [ j ] == ' ' || zjdqltxbhfgl [ j ] == ' ' || zjdqltxbhfgl [ j ] == ' ' || zjdqltxbhfgl [ j ] == ' ' || zjdqltxbhfgl [ j ] == ' ' || zjdqltxbhfgl [ j ] == ' ' || zjdqltxbhfgl [ j ] == ' ' || zjdqltxbhfgl [ j ] == ' ' ) )  { continue ; } for ( k = 0 ; k < c ; k ++ ) { ujldpscrople ( zjdqltxbhfgl [ j ] == ikbgnhkkrrih [ k ] [ 0 ] && zjdqltxbhfgl [ j + 1 ] == ikbgnhkkrrih [ k ] [ 1 ] || zjdqltxbhfgl [ j ] == ikbgnhkkrrih [ k ] [ 1 ] && zjdqltxbhfgl [ j + 1 ] == ikbgnhkkrrih [ k ] [ 0 ] )  { naoklgzvsyin [ udbztuowigre ++ ] = ikbgnhkkrrih [ k ] [ 2 ] ; dmefirvnfbur = 1 ; j ++ ; break ; } } ujldpscrople ( dmefirvnfbur ) { ujldpscrople ( j == n - 2 )  naoklgzvsyin [ udbztuowigre ++ ] = zjdqltxbhfgl [ j + 1 ] ; continue ; } for ( k = 0 ; k < d ; k ++ ) { ujldpscrople ( zjdqltxbhfgl [ j ] == fuumowxqbnju [ k ] [ 0 ] )  { ujldpscrople ( zjdqltxbhfgl [ j + 1 ] == fuumowxqbnju [ k ] [ 1 ] )  { j ++ ; dmefirvnfbur = 1 ; } else ujldpscrople ( j < n -2 ) { ujldpscrople ( zjdqltxbhfgl [ j + 2 ] == fuumowxqbnju [ k ] [ 1 ] )  { int sgpdysywlodc ; for ( sgpdysywlodc = 0 ; sgpdysywlodc < c ; sgpdysywlodc ++ ) { ujldpscrople ( zjdqltxbhfgl [ j + 1 ] == ikbgnhkkrrih [ sgpdysywlodc ] [ 0 ] && zjdqltxbhfgl [ j + 2 ] == ikbgnhkkrrih [ sgpdysywlodc ] [ 1 ] || zjdqltxbhfgl [ j + 1 ] == ikbgnhkkrrih [ sgpdysywlodc ] [ 1 ] && zjdqltxbhfgl [ j + 2 ] == ikbgnhkkrrih [ sgpdysywlodc ] [ 0 ] )  { naoklgzvsyin [ udbztuowigre ++ ] = zjdqltxbhfgl [ j ] ; naoklgzvsyin [ udbztuowigre ++ ] = ikbgnhkkrrih [ sgpdysywlodc ] [ 2 ] ; break ; } } j += 2 ; dmefirvnfbur = 1 ; } else  { continue ; } } else  { continue ; } ujldpscrople ( dmefirvnfbur ) break ; } else ujldpscrople ( zjdqltxbhfgl [ j ] = = fuumowxqbnju [ k ] [ 1 ] ) { ujldpscrople ( zjdqltxbhfgl [ j + 1 ] == fuumowxqbnju [ k ] [ 0 ] )  { j ++ ; dmefirvnfbur = 1 ; } else ujldpscrople ( j < n -2 ) { ujldpscrople ( zjdqltxbhfgl [ j + 2 ] == fuumowxqbnju [ k ] [ 0 ] )  { int sgpdysywlodc ; for ( sgpdysywlodc = 0 ; sgpdysywlodc < c ; sgpdysywlodc ++ ) { ujldpscrople ( zjdqltxbhfgl [ j + 1 ] == ikbgnhkkrrih [ sgpdysywlodc ] [ 0 ] && zjdqltxbhfgl [ j + 2 ] == ikbgnhkkrrih [ sgpdysywlodc ] [ 1 ] || zjdqltxbhfgl [ j + 1 ] == ikbgnhkkrrih [ sgpdysywlodc ] [ 1 ] && zjdqltxbhfgl [ j + 2 ] == ikbgnhkkrrih [ sgpdysywlodc ] [ 0 ] )  { naoklgzvsyin [ udbztuowigre ++ ] = zjdqltxbhfgl [ j ] ; naoklgzvsyin [ udbztuowigre ++ ] = ikbgnhkkrrih [ sgpdysywlodc ] [ 2 ] ; break ; } } j += 2 ; dmefirvnfbur = 1 ; } else  { continue ; } } else  { continue ; } ujldpscrople ( dmefirvnfbur ) break ; } } ujldpscrople ( ! dmefirvnfbur )  naoklgzvsyin [ udbztuowigre ++ ] = zjdqltxbhfgl [ j ] ; ujldpscrople ( j == n - 2 )  naoklgzvsyin [ udbztuowigre ++ ] = zjdqltxbhfgl [ j + 1 ] ; } printf ( " " , i + 1 ) ; fprintf ( ofp , " " , i + 1 ) ; for ( rtlgvtdmvxjc = 0 ; rtlgvtdmvxjc < udbztuowigre ; rtlgvtdmvxjc ++ ) { printf ( " " , naoklgzvsyin [ rtlgvtdmvxjc ] ) ; fprintf ( ofp , " " , naoklgzvsyin [ rtlgvtdmvxjc ] ) ; ujldpscrople ( rtlgvtdmvxjc < udbztuowigre - 1 )  { printf ( " " ) ; fprintf ( ofp , " " ) ; } } printf ( " \n " ) ; fprintf ( ofp , " \n " ) ; } printf ( " \n " ) ; return ( 0 ) ; }
>>>Func
METHOD acsdimtzawjh
METHOD_RETURN void
PARAM int naevzsbeqkwp
<operator>.assignment pnode=(struct kukvhaxtqjyn*)malloc(sizeof(struct kukvhaxtqjyn))
<operator>.assignment pnode->data=naevzsbeqkwp
<operator>.assignment pnode->next=NULL
<operator>.equals pnode==NULL
empty empty()
<operator>.cast (struct kukvhaxtqjyn*)malloc(sizeof(struct kukvhaxtqjyn))
printf printf("Memory overflow. Unable to insert.\n")
exit exit(1)
<operator>.assignment front=rear=pnode
<operator>.assignment rear->next=pnode
<operator>.assignment rear=pnode
<operator>.sizeOf sizeof(struct kukvhaxtqjyn)
<operator>.assignment rear=pnode
<operator>.indirectFieldAccess rear->next
FIELD_IDENTIFIER next next
>>>PDG&18 0->2 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->15 2->4 3->1 3->1 3->6 4->1 4->1 4->1 5->1 5->1 5->1 6->1 6->5 6->9 6->10 6->11 6->12 6->13 6->15 7->1 7->11 7->12 7->13 7->15 7->16 7->17 8->1 9->1 11->1 11->1 11->1 14->1 15->1 15->1 15->11
>>>Token void acsdimtzawjh ( int naevzsbeqkwp ) { struct kukvhaxtqjyn * pnode ; pnode = ( struct kukvhaxtqjyn * ) malloc ( sizeof ( struct kukvhaxtqjyn ) ) ; if ( pnode == NULL ) { printf ( " \n " ) ; exit ( 1 ) ; } pnode -> data = naevzsbeqkwp ; pnode -> next = NULL ; if ( empty ( ) ) front = rear = pnode ; else { rear -> next = pnode ; rear = pnode ; } }
>>>Func
METHOD jyluquigmhxj
METHOD_RETURN int
PARAM const hprmqhsagpzy*a
PARAM const hprmqhsagpzy*b
<operator>.assignment *pkdncniccplm=(const vewfzkdehqceseg *)a
<operator>.assignment *sb=(const vewfzkdehqceseg *)b
RETURN return pkdncniccplm->v-sb->v; return pkdncniccplm->v-sb->v;
<operator>.subtraction pkdncniccplm->v-sb->v
<operator>.cast (const vewfzkdehqceseg *)a
<operator>.cast (const vewfzkdehqceseg *)b
>>>PDG&10 0->2 0->3 0->4 0->5 0->8 0->9 2->4 2->8 3->5 3->9 4->1 4->1 4->1 5->1 5->1 5->1 6->1 7->1 7->1 7->1 7->6 8->1 9->1
>>>Token int jyluquigmhxj ( const hprmqhsagpzy * a , const hprmqhsagpzy * b ) { const vewfzkdehqceseg * pkdncniccplm = ( const vewfzkdehqceseg * ) a ; const vewfzkdehqceseg * sb = ( const vewfzkdehqceseg * ) b ; return pkdncniccplm -> v - sb -> v ; }
>>>Func
METHOD sdvunwvevoji
METHOD_RETURN int
PARAM ArrayList *arraylist
PARAM ArrayListValue wiqtzofuxudl
RETURN return nnqjrcpugbzx(arraylist,arraylist->length,wiqtzofuxudl); return nnqjrcpugbzx(arraylist,arraylist->length,wiqtzofuxudl);
nnqjrcpugbzx nnqjrcpugbzx(arraylist,arraylist->length,wiqtzofuxudl)
>>>PDG&6 0->2 0->3 0->5 2->5 3->5 4->1 5->1 5->1 5->1 5->1 5->4
>>>Token int sdvunwvevoji ( ArrayList * arraylist , ArrayListValue wiqtzofuxudl ) { return nnqjrcpugbzx ( arraylist , arraylist -> length , wiqtzofuxudl ) ; }
>>>Func
METHOD main
METHOD_RETURN int
printf printf("Enter values of eq1:")
scanf scanf("%f%f%f%f",&a1,&a2,&a3,&d1)
printf printf("Enter values of eq2:")
scanf scanf("%f%f%f%f",&b1,&b2,&b3,&d2)
printf printf("Enter values of eq3:")
scanf scanf("%f%f%f%f",&c1,&c2,&c3,&d3)
<operator>.assignment x1=x2=x3=0.0
printf printf("x1=%f\nx2=%f\nx3=%f",x1,x2,x3)
RETURN return 0; return 0;
<operator>.logicalAnd fabs(x1-kdsrmijruxfg)>0.0001&&fabs(x2-b)>0.0001&&fabs(x3-c)>0.0001
LITERAL 0 return 0;
<operator>.assignment x2=x3=0.0
<operator>.assignment kdsrmijruxfg=x1
<operator>.assignment b=x2
<operator>.assignment c=x3
<operator>.assignment x1=(1/a1)*(d1-(a2 *x2)-(a3 *x3))
<operator>.assignment x2=(1/b2)*(d2-(b1 *x1)-(b3 *x3))
<operator>.assignment x3=(1/c3)*(d3-(c1 *x1)-(c2 *x2))
<operator>.assignment x3=0.0
<operator>.logicalAnd fabs(x1-kdsrmijruxfg)>0.0001&&fabs(x2-b)>0.0001
<operator>.greaterThan fabs(x3-c)>0.0001
<operator>.multiplication (1/a1)*(d1-(a2 *x2)-(a3 *x3))
<operator>.multiplication (1/b2)*(d2-(b1 *x1)-(b3 *x3))
<operator>.multiplication (1/c3)*(d3-(c1 *x1)-(c2 *x2))
<operator>.greaterThan fabs(x1-kdsrmijruxfg)>0.0001
<operator>.greaterThan fabs(x2-b)>0.0001
fabs fabs(x3-c)
<operator>.division 1/a1
<operator>.subtraction d1-(a2 *x2)-(a3 *x3)
<operator>.division 1/b2
<operator>.subtraction d2-(b1 *x1)-(b3 *x3)
<operator>.division 1/c3
<operator>.subtraction d3-(c1 *x1)-(c2 *x2)
fabs fabs(x1-kdsrmijruxfg)
fabs fabs(x2-b)
<operator>.subtraction x3-c
<operator>.subtraction d1-(a2 *x2)
<operator>.multiplication a3 *x3
<operator>.subtraction d2-(b1 *x1)
<operator>.multiplication b3 *x3
<operator>.subtraction d3-(c1 *x1)
<operator>.multiplication c2 *x2
<operator>.subtraction x1-kdsrmijruxfg
<operator>.subtraction x2-b
<operator>.multiplication a2 *x2
<operator>.multiplication b1 *x1
<operator>.multiplication c1 *x1
>>>PDG&49 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->20 0->22 0->26 0->27 0->29 0->31 0->33 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 2->1 3->1 3->1 3->1 3->1 3->29 4->1 5->1 5->1 5->1 5->1 5->47 6->1 7->1 7->1 7->1 7->1 7->48 8->1 8->1 8->14 9->1 9->1 9->1 9->1 10->1 11->1 11->1 11->1 11->11 11->14 11->15 11->16 11->17 11->18 11->19 11->21 11->23 11->24 11->25 11->26 11->29 11->30 11->31 11->32 11->33 11->34 11->35 11->38 11->39 11->40 11->41 11->42 11->43 11->44 11->46 11->47 11->48 12->10 13->1 13->8 13->15 13->46 14->1 14->44 15->1 15->1 15->45 16->1 16->1 16->37 17->1 17->1 17->47 18->1 18->1 18->43 19->1 19->1 19->9 19->16 19->37 19->39 20->8 20->13 20->16 20->39 21->1 21->1 21->11 21->11 21->22 21->28 21->37 22->1 22->11 22->11 23->1 23->1 23->17 23->17 24->1 24->1 24->18 24->18 25->1 25->1 25->19 25->19 26->1 26->21 26->21 26->27 26->36 26->45 27->1 27->21 27->21 28->1 29->1 29->23 29->23 30->1 30->1 30->23 30->23 31->1 31->24 31->24 32->1 32->1 32->24 32->24 33->1 33->25 33->25 34->1 34->1 34->25 34->25 35->1 36->1 37->1 37->9 37->16 37->22 37->22 37->28 37->28 37->39 38->1 38->1 38->30 38->30 39->1 39->30 39->30 39->41 40->1 40->1 40->32 40->32 41->1 41->32 41->32 42->1 42->1 42->34 42->34 43->1 43->9 43->15 43->34 43->34 43->45 43->46 44->1 44->9 44->14 44->26 44->26 44->35 44->35 45->1 45->9 45->15 45->27 45->27 45->36 45->36 45->46 46->1 46->38 46->38 47->1 47->40 47->40 47->48 48->1 48->42 48->42 48->44
>>>Token int main ( ) { float kdsrmijruxfg , b , c , a1 , a2 , a3 , b1 , b2 , b3 , c1 , c2 , c3 , d1 , d2 , d3 , x1 , x2 , x3 ; printf ( " " ) ; scanf ( " " , & a1 , & a2 , & a3 , & d1 ) ; printf ( " " ) ; scanf ( " " , & b1 , & b2 , & b3 , & d2 ) ; printf ( " " ) ; scanf ( " " , & c1 , & c2 , & c3 , & d3 ) ; x1 = x2 = x3 = 0.0 ; do { kdsrmijruxfg = x1 ; b = x2 ; c = x3 ; x1 = ( 1 / a1 ) * ( d1 - ( a2 * x2 ) - ( a3 * x3 ) ) ; x2 = ( 1 / b2 ) * ( d2 - ( b1 * x1 ) - ( b3 * x3 ) ) ; x3 = ( 1 / c3 ) * ( d3 - ( c1 * x1 ) - ( c2 * x2 ) ) ; } while ( fabs ( x1 - kdsrmijruxfg ) > 0.0001 && fabs ( x2 - b ) > 0.0001 && fabs ( x3 - c ) > 0.0001 ) ; printf ( " \n \n " , x1 , x2 , x3 ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d\n",&fihypaxhgyiq)
RETURN return 0; return 0;
<operator>.lessEqualsThan nc<=fihypaxhgyiq
<operator>.postIncrement nc++
LITERAL 0 return 0;
<operator>.assignment nc=1
invalidate invalidate()
memset memset(combinationTable 0 sizeof(combinationTable))
memset memset(oppositeTable 0 sizeof(oppositeTable))
scanf scanf("%d",&tgcazlqyndrh)
scanf scanf("%d",&n_opposite)
scanf scanf("%d",&n_invoke)
<operator>.assignment kduimzelwdtp=0
printf printf("Case #%d: [",nc)
BLOCK <empty> <empty>
<operator>.postDecrement tgcazlqyndrh--
<operator>.postDecrement n_opposite--
<operator>.postDecrement n_invoke--
putchar putchar(']')
putchar putchar('\n')
<operator>.assignment e2=getchar()
<operator>.assignment e3=getchar()
<operator>.assignment combinationTable[eqxehrtxtezp].target=e2
<operator>.assignment combinationTable[e2].target=eqxehrtxtezp
<operator>.assignment combinationTable[eqxehrtxtezp].result=combinationTable[e2].result=e3
<operator>.assignment e2=getchar()
<operator>.assignment oppositeTable[eqxehrtxtezp].target=e2
<operator>.assignment oppositeTable[e2].target=eqxehrtxtezp
<operator>.assignment oppositeTable[eqxehrtxtezp].invoke=oppositeTable[e2].invoke=0
<operator>.assignment kduimzelwdtp=gbzrtafupubf
<operator>.lessEqualsThan ggnmmlfglmoa<=esp
<operator>.postIncrement ggnmmlfglmoa++
<operator>.equals eqxehrtxtezp==''
<operator>.equals eqxehrtxtezp==''
<operator>.equals gbzrtafupubf==''
<operator>.logicalAnd kduimzelwdtp!=0&&combinationTable[gbzrtafupubf].target==kduimzelwdtp
<operator>.logicalAnd oppositeTable[gbzrtafupubf].target!=0&&oppositeTable[oppositeTable[gbzrtafupubf].target].invoke>0
<operator>.assignment ggnmmlfglmoa=0
<operator>.assignment eqxehrtxtezp=getchar()
<operator>.assignment combinationTable[e2].result=e3
<operator>.assignment eqxehrtxtezp=getchar()
<operator>.assignment oppositeTable[e2].invoke=0
<operator>.assignment gbzrtafupubf=getchar()
pop pop()
<operator>.assignment gbzrtafupubf=combinationTable[gbzrtafupubf].result
<operator>.postDecrement oppositeTable[gbzrtafupubf].invoke--
<operator>.assignment kduimzelwdtp=0
invalidate invalidate()
IDENTIFIER ggnmmlfglmoa if (ggnmmlfglmoa)
<operator>.notEquals kduimzelwdtp!=0
<operator>.equals combinationTable[gbzrtafupubf].target==kduimzelwdtp
<operator>.lessThan oppositeTable[gbzrtafupubf].invoke<0
<operator>.notEquals oppositeTable[gbzrtafupubf].target!=0
<operator>.greaterThan oppositeTable[oppositeTable[gbzrtafupubf].target].invoke>0
<operator>.lessThan wgdfbbjcqqoh<256
<operator>.postIncrement wgdfbbjcqqoh++
<operator>.assignment oppositeTable[wgdfbbjcqqoh].invoke=0
<operator>.postIncrement oppositeTable[gbzrtafupubf].invoke++
push push(gbzrtafupubf)
printf printf(", %c",stack[ggnmmlfglmoa])
<operator>.assignment oppositeTable[gbzrtafupubf].invoke=0
<operator>.assignment wgdfbbjcqqoh=0
putchar putchar(stack[ggnmmlfglmoa])
UNKNOWN e e
UNKNOWN [256]; [256];
UNKNOWN e e
UNKNOWN [256]; [256];
<operator>.sizeOf sizeof(combinationTable)
<operator>.sizeOf sizeof(oppositeTable)
<operator>.addressOf &tgcazlqyndrh
<operator>.addressOf &n_opposite
<operator>.addressOf &n_invoke
getchar getchar()
getchar getchar()
<operator>.fieldAccess combinationTable[eqxehrtxtezp].target
<operator>.fieldAccess combinationTable[e2].target
<operator>.fieldAccess combinationTable[eqxehrtxtezp].result
getchar getchar()
<operator>.fieldAccess oppositeTable[eqxehrtxtezp].target
<operator>.fieldAccess oppositeTable[e2].target
<operator>.fieldAccess oppositeTable[eqxehrtxtezp].invoke
<operator>.indirectIndexAccess combinationTable[eqxehrtxtezp]
FIELD_IDENTIFIER target target
<operator>.indirectIndexAccess combinationTable[e2]
FIELD_IDENTIFIER target target
<operator>.indirectIndexAccess combinationTable[eqxehrtxtezp]
FIELD_IDENTIFIER result result
<operator>.fieldAccess combinationTable[e2].result
<operator>.indirectIndexAccess oppositeTable[eqxehrtxtezp]
FIELD_IDENTIFIER target target
<operator>.indirectIndexAccess oppositeTable[e2]
FIELD_IDENTIFIER target target
<operator>.indirectIndexAccess oppositeTable[eqxehrtxtezp]
FIELD_IDENTIFIER invoke invoke
<operator>.fieldAccess oppositeTable[e2].invoke
getchar getchar()
<operator>.indirectIndexAccess combinationTable[e2]
FIELD_IDENTIFIER result result
getchar getchar()
<operator>.indirectIndexAccess oppositeTable[e2]
FIELD_IDENTIFIER invoke invoke
getchar getchar()
<operator>.fieldAccess combinationTable[gbzrtafupubf].target
<operator>.fieldAccess combinationTable[gbzrtafupubf].result
<operator>.fieldAccess oppositeTable[gbzrtafupubf].invoke
<operator>.fieldAccess oppositeTable[gbzrtafupubf].target
<operator>.fieldAccess oppositeTable[oppositeTable[gbzrtafupubf].target].invoke
<operator>.indirectIndexAccess combinationTable[gbzrtafupubf]
FIELD_IDENTIFIER target target
<operator>.indirectIndexAccess combinationTable[gbzrtafupubf]
FIELD_IDENTIFIER result result
<operator>.indirectIndexAccess oppositeTable[gbzrtafupubf]
FIELD_IDENTIFIER invoke invoke
<operator>.fieldAccess oppositeTable[gbzrtafupubf].invoke
<operator>.indirectIndexAccess oppositeTable[gbzrtafupubf]
FIELD_IDENTIFIER target target
<operator>.indirectIndexAccess oppositeTable[oppositeTable[gbzrtafupubf].target]
FIELD_IDENTIFIER invoke invoke
<operator>.fieldAccess oppositeTable[wgdfbbjcqqoh].invoke
<operator>.fieldAccess oppositeTable[gbzrtafupubf].invoke
<operator>.indirectIndexAccess stack[ggnmmlfglmoa]
<operator>.indirectIndexAccess oppositeTable[gbzrtafupubf]
FIELD_IDENTIFIER invoke invoke
<operator>.fieldAccess oppositeTable[gbzrtafupubf].invoke
<operator>.fieldAccess oppositeTable[gbzrtafupubf].target
<operator>.indirectIndexAccess oppositeTable[wgdfbbjcqqoh]
FIELD_IDENTIFIER invoke invoke
<operator>.indirectIndexAccess oppositeTable[gbzrtafupubf]
FIELD_IDENTIFIER invoke invoke
<operator>.indirectIndexAccess stack[ggnmmlfglmoa]
<operator>.indirectIndexAccess oppositeTable[gbzrtafupubf]
FIELD_IDENTIFIER invoke invoke
<operator>.indirectIndexAccess oppositeTable[gbzrtafupubf]
FIELD_IDENTIFIER target target
>>>PDG&136 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->60 0->61 0->62 0->63 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->15 4->17 4->18 4->19 4->20 4->21 4->32 4->39 4->65 4->66 4->67 4->68 4->69 4->70 4->71 4->72 4->73 5->1 5->4 6->3 7->1 7->4 8->1 9->1 9->1 10->1 10->1 11->1 11->17 12->1 12->18 13->1 13->19 14->1 14->1 14->51 15->1 15->5 17->1 17->1 17->11 17->17 17->22 17->23 17->24 17->25 17->26 17->34 17->40 17->41 17->74 17->75 17->76 17->77 17->78 17->83 17->84 17->85 17->86 17->87 17->88 17->89 17->97 17->98 17->99 18->1 18->1 18->12 18->18 18->27 18->28 18->29 18->30 18->35 18->42 18->43 18->79 18->80 18->81 18->82 18->90 18->91 18->92 18->93 18->94 18->95 18->96 18->100 18->101 18->102 19->1 19->1 19->13 19->19 19->31 19->36 19->37 19->38 19->44 19->51 19->54 19->103 19->107 19->116 19->117 20->1 21->1 22->1 22->24 23->1 23->1 23->26 23->41 24->1 24->1 25->1 25->1 25->1 26->1 26->1 26->1 27->1 27->1 27->28 28->1 28->1 29->1 29->1 29->1 30->1 30->1 30->1 31->1 31->1 31->1 31->51 32->1 32->1 32->1 32->32 32->33 32->33 32->61 32->64 32->122 32->131 33->1 33->32 34->1 34->25 34->34 34->40 34->97 35->1 35->29 35->35 35->42 35->100 36->1 36->31 36->36 36->44 36->60 36->103 37->1 37->1 37->1 37->45 37->46 37->47 37->53 37->105 37->106 37->111 37->112 37->113 37->114 37->115 37->123 37->124 38->1 38->1 38->1 38->48 38->49 38->56 38->59 38->60 38->63 38->121 38->129 38->130 39->1 39->32 40->1 40->34 41->1 41->1 41->26 42->1 42->35 43->1 43->30 44->1 44->1 44->36 45->1 46->1 46->31 46->60 47->1 47->53 48->1 48->1 48->51 49->1 51->37 51->37 51->52 51->52 51->104 51->109 51->110 52->37 52->37 53->1 53->62 53->125 53->132 53->133 54->1 54->38 54->38 54->55 54->108 54->118 54->119 54->126 54->134 54->135 55->1 55->38 55->38 56->1 56->1 56->56 56->57 56->57 56->58 56->120 56->127 56->128 57->1 57->56 58->1 59->1 60->1 60->1 61->1 61->1 61->64 62->1 63->1 63->56 64->1 64->1 64->61
>>>Token int main ( ) { int fihypaxhgyiq , nc ; scanf ( " \n " , & fihypaxhgyiq ) ; for ( nc = 1 ; nc <= fihypaxhgyiq ; nc ++ ) { int tgcazlqyndrh , n_opposite , n_invoke ; struct sjdkunxdpbejcombinationTable  [ 256 ] ; struct ridpyzcmtlnooppositeTable  [ 256 ] ; int kduimzelwdtp ; invalidate ( ) ; memset ( combinationTable , 0 , sizeof ( combinationTable ) ) ; memset ( oppositeTable , 0 , sizeof ( oppositeTable ) ) ; scanf ( " " , & tgcazlqyndrh ) ; while ( tgcazlqyndrh -- ) { int eqxehrtxtezp , e2 , e3 ; do { eqxehrtxtezp = getchar ( ) ; } while ( eqxehrtxtezp == ' ' ) ; e2 = getchar ( ) ; e3 = getchar ( ) ; combinationTable [ eqxehrtxtezp ] . target = e2 ; combinationTable [ e2 ] . target = eqxehrtxtezp ; combinationTable [ eqxehrtxtezp ] . result = combinationTable [ e2 ] . result = e3 ; } scanf ( " " , & n_opposite ) ; while ( n_opposite -- ) { int eqxehrtxtezp , e2 ; do { eqxehrtxtezp = getchar ( ) ; } while ( eqxehrtxtezp == ' ' ) ; e2 = getchar ( ) ; oppositeTable [ eqxehrtxtezp ] . target = e2 ; oppositeTable [ e2 ] . target = eqxehrtxtezp ; oppositeTable [ eqxehrtxtezp ] . invoke = oppositeTable [ e2 ] . invoke = 0 ; } scanf ( " " , & n_invoke ) ; kduimzelwdtp = 0 ; while ( n_invoke -- ) { int gbzrtafupubf ; do { gbzrtafupubf = getchar ( ) ; } while ( gbzrtafupubf == ' ' ) ; if ( kduimzelwdtp != 0 && combinationTable [ gbzrtafupubf ] . target == kduimzelwdtp ) { pop ( ) ; gbzrtafupubf = combinationTable [ gbzrtafupubf ] . result ; oppositeTable [ gbzrtafupubf ] . invoke -- ; if ( oppositeTable [ gbzrtafupubf ] . invoke < 0 ) oppositeTable [ gbzrtafupubf ] . invoke = 0 ; } kduimzelwdtp = gbzrtafupubf ; if ( oppositeTable [ gbzrtafupubf ] . target != 0 && oppositeTable [ oppositeTable [ gbzrtafupubf ] . target ] . invoke > 0 ) { int wgdfbbjcqqoh ; kduimzelwdtp = 0 ; invalidate ( ) ; for ( wgdfbbjcqqoh = 0 ; wgdfbbjcqqoh < 256 ; wgdfbbjcqqoh ++ ) oppositeTable [ wgdfbbjcqqoh ] . invoke = 0 ; } else { oppositeTable [ gbzrtafupubf ] . invoke ++ ; push ( gbzrtafupubf ) ; } } printf ( " " , nc ) ; { int ggnmmlfglmoa ; for ( ggnmmlfglmoa = 0 ; ggnmmlfglmoa <= esp ; ggnmmlfglmoa ++ ) { if ( ggnmmlfglmoa ) { printf ( " " , stack [ ggnmmlfglmoa ] ) ; } else { putchar ( stack [ ggnmmlfglmoa ] ) ; } } putchar ( ' ' ) ; putchar ( ' \n ' ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int swnyxbfvkjro
PARAM char **argv
<operator>.assignment iprpigldtvjn=0
<operator>.assignment dmjgxykgbxyi=0
<operator>.assignment iaitdhufecej=0
<operator>.assignment coavilbmxfdp=0
pdwrawujvmqf pdwrawujvmqf(!(pfich=fopen("A-small-attempt1.in","r")))
printf printf("Error al abrir fichero1\n")
RETURN return 0; return 0;
<operator>.logicalNot !(pfich=fopen("A-small-attempt1.in","r"))
LITERAL 0 return 0;
<operator>.assignment pfich=fopen("A-small-attempt1.in","r")
fopen fopen("A-small-attempt1.in","r")
<operator>.lessThan i<ghabxucdlbax
<operator>.postIncrement i++
fscanf fscanf(pfich,"%d ",&nequipos)
fprintf fprintf(pfich2,"Case #%i:\n",i+1)
<operator>.addressOf &nequipos
<operator>.addition i+1
<operator>.lessThan j<nequipos
<operator>.postIncrement j++
<operator>.lessThan j<nequipos
<operator>.postIncrement j++
<operator>.lessThan j<nequipos
<operator>.postIncrement j++
<operator>.lessThan j<nequipos
<operator>.postIncrement j++
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.assignment wp[j]=dmjgxykgbxyi/iprpigldtvjn
printf printf("WP[%d]: %f\n",j,wp[j])
<operator>.assignment dmjgxykgbxyi=0
<operator>.assignment iprpigldtvjn=0
<operator>.assignment owp[j]=coavilbmxfdp/iaitdhufecej
<operator>.assignment coavilbmxfdp=0
<operator>.assignment iaitdhufecej=0
printf printf("OWP[%d]: %f\n",j,owp[j])
<operator>.assignment j=0
printf printf("PORQUE?: %f %f\n",coavilbmxfdp,iaitdhufecej)
<operator>.assignment oowp[j]=coavilbmxfdp/iaitdhufecej
<operator>.assignment coavilbmxfdp=0
<operator>.assignment iaitdhufecej=0
printf printf("OOWP[%d]: %f\n",j,oowp[j])
<operator>.assignment j=0
<operator>.assignment mwlqqylsvwbl[j]=0.25 *wp[j]+0.5 *owp[j]+0.25 *oowp[j]
printf printf("total[%d]: %lf ---  %f %f %f \n",j,mwlqqylsvwbl[j],wp[j],owp[j],oowp[j])
fprintf fprintf(pfich2,"%lf\n",mwlqqylsvwbl[j])
<operator>.lessThan k<nequipos
<operator>.postIncrement k++
<operator>.lessThan k<nequipos
<operator>.postIncrement k++
<operator>.indirectIndexAccess wp[j]
<operator>.division dmjgxykgbxyi/iprpigldtvjn
<operator>.indirectIndexAccess wp[j]
<operator>.lessThan k<nequipos
<operator>.postIncrement k++
<operator>.indirectIndexAccess owp[j]
<operator>.division coavilbmxfdp/iaitdhufecej
<operator>.indirectIndexAccess owp[j]
<operator>.lessThan k<nequipos
<operator>.postIncrement k++
<operator>.indirectIndexAccess oowp[j]
<operator>.division coavilbmxfdp/iaitdhufecej
<operator>.indirectIndexAccess oowp[j]
<operator>.indirectIndexAccess mwlqqylsvwbl[j]
<operator>.addition 0.25 *wp[j]+0.5 *owp[j]+0.25 *oowp[j]
<operator>.indirectIndexAccess mwlqqylsvwbl[j]
<operator>.indirectIndexAccess wp[j]
<operator>.indirectIndexAccess owp[j]
<operator>.indirectIndexAccess oowp[j]
<operator>.indirectIndexAccess mwlqqylsvwbl[j]
<operator>.assignment k=0
fscanf fscanf(pfich,"%c ",&attqzhkrhoyc[j][k])
<operator>.assignment k=0
pdwrawujvmqf pdwrawujvmqf(attqzhkrhoyc[j][k]=='0')
UNKNOWN,),)
UNKNOWN else pdwrawujvmqf (attqzhkrhoyc[j][k]=='1'){iprpigldtvjn++;dmjgxykgbxyi++;} else pdwrawujvmqf (attqzhkrhoyc[j][k]=='1'){iprpigldtvjn++;dmjgxykgbxyi++;}
<operator>.assignment k=0
pdwrawujvmqf pdwrawujvmqf(attqzhkrhoyc[j][k]!='.')
UNKNOWN,),)
<operator>.assignment k=0
pdwrawujvmqf pdwrawujvmqf(attqzhkrhoyc[j][k]!='.')
UNKNOWN,),)
<operator>.addition 0.25 *wp[j]+0.5 *owp[j]
<operator>.multiplication 0.25 *oowp[j]
<operator>.addressOf &attqzhkrhoyc[j][k]
<operator>.equals attqzhkrhoyc[j][k]=='0'
<operator>.postIncrement iprpigldtvjn++
<operator>.notEquals attqzhkrhoyc[j][k]!='.'
<operator>.postIncrement iaitdhufecej++
<operator>.assignment coavilbmxfdp=coavilbmxfdp+dmjgxykgbxyi/iprpigldtvjn
<operator>.assignment dmjgxykgbxyi=0
<operator>.assignment iprpigldtvjn=0
<operator>.notEquals attqzhkrhoyc[j][k]!='.'
<operator>.postIncrement iaitdhufecej++
printf printf("PORQUE?: %f %f\n",coavilbmxfdp,owp[k])
<operator>.assignment coavilbmxfdp=coavilbmxfdp+owp[k]
<operator>.multiplication 0.25 *wp[j]
<operator>.multiplication 0.5 *owp[j]
<operator>.indirectIndexAccess oowp[j]
<operator>.indirectIndexAccess attqzhkrhoyc[j][k]
<operator>.indirectIndexAccess attqzhkrhoyc[j][k]
<operator>.indirectIndexAccess attqzhkrhoyc[j][k]
<operator>.lessThan z<nequipos
<operator>.postIncrement z++
<operator>.addition coavilbmxfdp+dmjgxykgbxyi/iprpigldtvjn
<operator>.indirectIndexAccess attqzhkrhoyc[j][k]
<operator>.indirectIndexAccess owp[k]
<operator>.addition coavilbmxfdp+owp[k]
<operator>.indirectIndexAccess wp[j]
<operator>.indirectIndexAccess owp[j]
<operator>.indirectIndexAccess attqzhkrhoyc[j]
<operator>.indirectIndexAccess attqzhkrhoyc[j]
<operator>.indirectIndexAccess attqzhkrhoyc[j]
<operator>.assignment z=0
pdwrawujvmqf pdwrawujvmqf((attqzhkrhoyc[k][z]=='0')&&(z!=j))
UNKNOWN,),)
UNKNOWN else pdwrawujvmqf ((attqzhkrhoyc[k][z]=='1')&&(z!=j)){iprpigldtvjn++;dmjgxykgbxyi++;} else pdwrawujvmqf ((attqzhkrhoyc[k][z]=='1')&&(z!=j)){iprpigldtvjn++;dmjgxykgbxyi++;}
<operator>.division dmjgxykgbxyi/iprpigldtvjn
<operator>.indirectIndexAccess attqzhkrhoyc[j]
<operator>.indirectIndexAccess owp[k]
<operator>.logicalAnd (attqzhkrhoyc[k][z]=='0')&&(z!=j)
<operator>.postIncrement iprpigldtvjn++
<operator>.equals attqzhkrhoyc[k][z]=='0'
<operator>.notEquals z!=j
<operator>.indirectIndexAccess attqzhkrhoyc[k][z]
<operator>.indirectIndexAccess attqzhkrhoyc[k]
>>>PDG&129 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->12 0->14 2->1 3->1 4->1 4->1 5->1 5->1 6->1 6->1 7->1 7->1 8->1 8->1 9->1 10->1 11->1 11->8 12->10 13->1 13->1 13->11 14->11 14->11 14->13 14->13 15->15 15->16 15->17 15->18 15->19 15->20 15->21 15->23 15->25 15->27 15->29 15->30 15->39 15->45 21->21 21->22 21->49 21->73 23->23 23->24 23->31 23->32 23->33 23->34 23->35 23->36 23->37 23->38 23->51 23->53 23->54 23->55 23->56 23->58 23->59 23->60 23->75 23->79 25->25 25->26 25->40 25->41 25->42 25->43 25->44 25->61 25->63 25->64 25->65 25->82 27->27 27->28 27->46 27->47 27->48 27->66 27->67 27->68 27->69 27->70 27->71 27->72 27->85 27->86 27->99 27->100 27->101 27->111 27->112 49->49 49->50 49->74 49->87 49->102 49->113 51->51 51->52 51->76 51->77 51->78 51->88 51->89 51->103 51->114 56->56 56->57 56->80 56->81 56->90 56->91 56->92 56->93 56->94 56->104 56->105 56->107 56->115 56->116 56->120 61->61 61->62 61->83 61->84 61->95 61->96 61->97 61->98 61->108 61->109 61->110 61->121 61->122 105->105 105->106 105->117 105->118 105->119 105->123 105->124 105->125 105->127 105->128 125->126
>>>Token int main ( int swnyxbfvkjro , char * * argv ) { FILE * pfich ; FILE * pfich2 ; int ghabxucdlbax , i , z , n , nequipos , j , k ; double iprpigldtvjn = 0 ; double dmjgxykgbxyi = 0 ; double iaitdhufecej = 0 ; double coavilbmxfdp = 0 ; trio attqzhkrhoyc [ 100 ] ; double mwlqqylsvwbl [ 100 ] , wp [ 100 ] , owp [ 100 ] , oowp [ 100 ] ; pdwrawujvmqf ( ! ( pfich = fopen ( " " , " " ) ) )  { printf ( " \n " ) ; return 0 ; } pdwrawujvmqf ( ! ( pfich2 = fopen ( " " , " " ) ) )  { printf ( " \n " ) ; return 0 ; } fscanf ( pfich , " \n " , & ghabxucdlbax ) ; for ( i = 0 ; i < ghabxucdlbax ; i ++ ) { fscanf ( pfich , " " , & nequipos ) ; fprintf ( pfich2 , " \n " , i + 1 ) ; for ( j = 0 ; j < nequipos ; j ++ ) { for ( k = 0 ; k < nequipos ; k ++ ) { fscanf ( pfich , " " , & attqzhkrhoyc [ j ] [ k ] ) ; } } for ( j = 0 ; j < nequipos ; j ++ ) { for ( k = 0 ; k < nequipos ; k ++ ) { pdwrawujvmqf ( attqzhkrhoyc [ j ] [ k ] == ' ' )  { iprpigldtvjn ++ ; } else pdwrawujvmqf ( attqzhkrhoyc [ j ] [ k ] = = ' ' ) { iprpigldtvjn ++ ; dmjgxykgbxyi ++ ; } } wp [ j ] = dmjgxykgbxyi / iprpigldtvjn ; printf ( " \n " , j , wp [ j ] ) ; dmjgxykgbxyi = 0 ; iprpigldtvjn = 0 ; for ( k = 0 ; k < nequipos ; k ++ ) { pdwrawujvmqf ( attqzhkrhoyc [ j ] [ k ] != ' ' )  { iaitdhufecej ++ ; for ( z = 0 ; z < nequipos ; z ++ ) { pdwrawujvmqf ( ( attqzhkrhoyc [ k ] [ z ] == ' ' ) && ( z != j ) )  { iprpigldtvjn ++ ; } else pdwrawujvmqf ( ( attqzhkrhoyc [ k ] [ z ] = = ' ' ) && ( z != j ) ) { iprpigldtvjn ++ ; dmjgxykgbxyi ++ ; } } coavilbmxfdp = coavilbmxfdp + dmjgxykgbxyi / iprpigldtvjn ; dmjgxykgbxyi = 0 ; iprpigldtvjn = 0 ; } } owp [ j ] = coavilbmxfdp / iaitdhufecej ; coavilbmxfdp = 0 ; iaitdhufecej = 0 ; printf ( " \n " , j , owp [ j ] ) ; } for ( j = 0 ; j < nequipos ; j ++ ) { for ( k = 0 ; k < nequipos ; k ++ ) { pdwrawujvmqf ( attqzhkrhoyc [ j ] [ k ] != ' ' )  { iaitdhufecej ++ ; printf ( " \n " , coavilbmxfdp , owp [ k ] ) ; coavilbmxfdp = coavilbmxfdp + owp [ k ] ; } } printf ( " \n " , coavilbmxfdp , iaitdhufecej ) ; oowp [ j ] = coavilbmxfdp / iaitdhufecej ; coavilbmxfdp = 0 ; iaitdhufecej = 0 ; printf ( " \n " , j , oowp [ j ] ) ; } for ( j = 0 ; j < nequipos ; j ++ ) { mwlqqylsvwbl [ j ] = 0.25 * wp [ j ] + 0.5 * owp [ j ] + 0.25 * oowp [ j ] ; printf ( " \n " , j , mwlqqylsvwbl [ j ] , wp [ j ] , owp [ j ] , oowp [ j ] ) ; fprintf ( pfich2 , " \n " , mwlqqylsvwbl [ j ] ) ; } } fclose ( pfich ) ; fclose ( pfich2 ) ; return 0 ; }
>>>Func
METHOD avl_tree_new
METHOD_RETURN AVLTree
PARAM AVLTreeCompareFunc qkmyyjxriivz
<operator>.assignment sdczlyeosrca=(AVLTree *)malloc(sizeof(AVLTree))
<operator>.assignment sdczlyeosrca->root_node=zjnwfmchkacp
<operator>.assignment sdczlyeosrca->qkmyyjxriivz=qkmyyjxriivz
<operator>.assignment sdczlyeosrca->num_nodes=0
RETURN return sdczlyeosrca; return sdczlyeosrca;
<operator>.equals sdczlyeosrca==zjnwfmchkacp
IDENTIFIER sdczlyeosrca return sdczlyeosrca;
<operator>.cast (AVLTree *)malloc(sizeof(AVLTree))
RETURN return zjnwfmchkacp; return zjnwfmchkacp;
IDENTIFIER zjnwfmchkacp return zjnwfmchkacp;
<operator>.sizeOf sizeof(AVLTree)
<operator>.indirectFieldAccess sdczlyeosrca->root_node
<operator>.indirectFieldAccess sdczlyeosrca->qkmyyjxriivz
<operator>.indirectFieldAccess sdczlyeosrca->num_nodes
FIELD_IDENTIFIER root_node root_node
FIELD_IDENTIFIER qkmyyjxriivz qkmyyjxriivz
FIELD_IDENTIFIER num_nodes num_nodes
>>>PDG&20 0->2 0->4 0->5 0->6 0->8 0->9 0->12 2->1 2->5 3->1 3->1 3->8 7->1 8->1 8->1 8->1 8->4 8->4 8->5 8->6 8->7 8->9 8->11 8->12 8->14 8->15 8->16 8->17 8->18 8->19 9->7 10->1 11->1 12->11 13->1
>>>Token AVLTree * avl_tree_new ( AVLTreeCompareFunc qkmyyjxriivz ) { AVLTree * sdczlyeosrca ; sdczlyeosrca = ( AVLTree * ) malloc ( sizeof ( AVLTree ) ) ; if ( sdczlyeosrca == zjnwfmchkacp ) { return zjnwfmchkacp ; } sdczlyeosrca -> root_node = zjnwfmchkacp ; sdczlyeosrca -> qkmyyjxriivz = qkmyyjxriivz ; sdczlyeosrca -> num_nodes = 0 ; return sdczlyeosrca ; }
>>>Func
METHOD uzqmdoskxnej
METHOD_RETURN void
PARAM void
scanf scanf("%I64d %d %d ",&N,&kpmdjgbvzwuc,&G)
<operator>.assignment uicbktsjrodj=100/gcd(100,kpmdjgbvzwuc)
<operator>.division 100/gcd(100,kpmdjgbvzwuc)
printf printf("Broken\n")
gcd gcd(100,kpmdjgbvzwuc)
printf printf("Possible\n")
UNKNOWN (G==0&&kpmdjgbvzwuc!=0)||(G==100&&kpmdjgbvzwuc!=100)||((gipcgcsvhdlf gipcgcsvhdlf)uicbktsjrodj>N) (G==0&&kpmdjgbvzwuc!=0)||(G==100&&kpmdjgbvzwuc!=100)||((gipcgcsvhdlf gipcgcsvhdlf)uicbktsjrodj>N)
>>>PDG&10 0->2 0->3 0->5 0->6 0->7 0->8 2->1 3->1 3->1 3->1 4->1 4->1 4->1 5->1 5->4 5->4 6->1 7->1 7->5 7->5 9->6 9->8
>>>Token void uzqmdoskxnej ( void ) { gipcgcsvhdlf gipcgcsvhdlfN ; int kpmdjgbvzwuc , G ; scanf ( " " , & N , & kpmdjgbvzwuc , & G ) ; int uicbktsjrodj = 100 / gcd ( 100 , kpmdjgbvzwuc ) ; if ( ( G == 0 && kpmdjgbvzwuc != 0 ) || ( G == 100 && kpmdjgbvzwuc != 100 ) || ( ( gipcgcsvhdlf gipcgcsvhdlf ) uicbktsjrodj > N ) ) { printf ( " \n " ) ; } else { printf ( " \n " ) ; } }
>>>Func
METHOD zjdsrxfecvdk
METHOD_RETURN Vector
PARAM Vector fgyjczwhocqm
PARAM Vector fxieilgirfem
RETURN return (Vector){fgyjczwhocqm.fgyjczwhocqm+fxieilgirfem.fgyjczwhocqm fgyjczwhocqm.fxieilgirfem+fxieilgirfem.fxieilgirfem}; return (Vector){fgyjczwhocqm.fgyjczwhocqm+fxieilgirfem.fgyjczwhocqm fgyjczwhocqm.fxieilgirfem+fxieilgirfem.fxieilgirfem};
<operator>.cast (Vector){fgyjczwhocqm.fgyjczwhocqm+fxieilgirfem.fgyjczwhocqm fgyjczwhocqm.fxieilgirfem+fxieilgirfem.fxieilgirfem}
<operator>.arrayInitializer {fgyjczwhocqm.fgyjczwhocqm+fxieilgirfem.fgyjczwhocqm fgyjczwhocqm.fxieilgirfem+fxieilgirfem.fxieilgirfem}
<operator>.addition fgyjczwhocqm.fgyjczwhocqm+fxieilgirfem.fgyjczwhocqm
<operator>.addition fgyjczwhocqm.fxieilgirfem+fxieilgirfem.fxieilgirfem
>>>PDG&9 0->2 0->3 2->1 2->6 2->7 2->8 3->1 3->6 3->7 3->8 4->1 5->1 5->1 5->4 6->1 6->1 6->5 6->5 7->1 7->1 8->1 8->1
>>>Token Vector zjdsrxfecvdk ( Vector fgyjczwhocqm , Vector fxieilgirfem ) { return ( Vector ) { fgyjczwhocqm . fgyjczwhocqm + fxieilgirfem . fgyjczwhocqm , fgyjczwhocqm . fxieilgirfem + fxieilgirfem . fxieilgirfem } ; }
>>>Func
METHOD main
METHOD_RETURN ANY
freopen freopen("B-small-attempt0.in","r",stdin)
freopen freopen("Bs.txt","w",stdout)
scanf scanf("%d",&onzudrwzxbrh)
<operator>.lessEqualsThan i<=onzudrwzxbrh
<operator>.postIncrement i++
<operator>.assignment i=1
<operator>.assignment tot=co=0
scanf scanf("%d%d%d%d",&l,&ti,&n,&c)
<operator>.assignment k=0
<operator>.assignment tim=ti
<operator>.assignment j=co=0
<operator>.assignment tot=ti
clwiqdnfsjsq clwiqdnfsjsq((n-co)<=l)
BLOCK <empty> <empty>
<operator>.lessThan j<c
<operator>.postIncrement j++
scanf scanf("%d",&a[j])
<operator>.lessThan j<n
<operator>.postIncrement j++
<operator>.greaterThan tim>0
printf printf("Case #%d: %d\n",i,tot)
<operator>.assignment co=0
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.assignment b[j]=a[k++]
clwiqdnfsjsq clwiqdnfsjsq(k==c)
<operator>.assignment k=0
<operator>.assignment co=0
clwiqdnfsjsq clwiqdnfsjsq(b[j]>tim/2)
<operator>.postIncrement j++
<operator>.lessEqualsThan (n-co)<=l
<operator>.lessThan co<n
<operator>.assignment b[j]=b[j]-tim/2
<operator>.assignment tim=0
<operator>.subtraction n-co
<operator>.assignmentPlus tot+=b[j++]
<operator>.postIncrement co++
<operator>.equals k==c
<operator>.greaterThan b[j]>tim/2
<operator>.postIncrement k++
<operator>.division tim/2
<operator>.subtraction b[j]-tim/2
<operator>.division tim/2
<operator>.postIncrement j++
UNKNOWN,),)
UNKNOWN else {z=0;for(k=j;k<n;k++)d[z++]=b[k];qsort(d z sizeof(int),compare);j=z-1;while(l>0){tot+=d[j--];l--;}while(j>=0)tot+=d[j--]*2;printf("Case #%d: %d\n",i,tot);} else {z=0;for(k=j;k<n;k++)d[z++]=b[k];qsort(d z sizeof(int),compare);j=z-1;while(l>0){tot+=d[j--];l--;}while(j>=0)tot+=d[j--]*2;printf("Case #%d: %d\n",i,tot);}
<operator>.addressOf &l
<operator>.addressOf &ti
<operator>.addressOf &n
<operator>.addressOf &c
<operator>.addressOf &a[j]
UNKNOWN,),)
UNKNOWN,),)
<operator>.indirectIndexAccess a[j]
<operator>.indirectIndexAccess b[j]
<operator>.indirectIndexAccess a[k++]
<operator>.indirectIndexAccess b[j]
<operator>.indirectIndexAccess b[j]
<operator>.indirectIndexAccess b[j++]
<operator>.indirectIndexAccess b[j]
>>>PDG&62 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->28 0->29 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->41 0->42 0->44 0->45 2->1 2->1 3->1 3->1 4->1 4->5 5->1 5->1 5->1 5->5 5->6 5->8 5->9 5->10 5->11 5->12 5->13 5->14 5->16 5->19 5->21 5->22 5->22 5->23 5->24 5->25 5->29 5->32 5->33 5->36 5->46 5->47 5->48 5->49 5->50 5->51 6->1 6->5 7->1 7->5 8->1 9->1 9->1 9->1 9->1 9->32 10->1 10->1 10->41 11->1 11->21 12->1 12->1 12->1 12->45 13->1 13->1 13->22 13->37 14->1 14->1 16->1 16->1 16->16 16->17 16->17 16->18 16->39 16->52 16->55 17->1 17->16 18->1 19->1 19->19 19->20 19->20 19->26 19->27 19->28 19->36 19->39 19->41 19->53 19->56 19->57 20->1 20->19 21->1 21->1 21->30 21->34 21->35 21->40 21->42 21->42 21->43 21->44 21->54 21->58 21->59 21->61 22->1 22->1 22->6 23->8 24->16 25->1 25->19 26->1 26->1 26->1 26->40 27->1 27->1 28->1 28->1 28->41 29->12 29->36 30->1 30->1 31->1 31->1 31->45 32->1 32->1 32->9 32->14 32->14 33->1 33->1 33->1 33->19 33->33 33->37 33->38 33->38 33->45 33->60 34->1 34->1 34->1 34->40 35->1 35->1 36->32 36->32 36->33 36->33 37->1 37->1 37->22 38->1 38->33 39->1 39->16 39->27 39->27 40->30 40->30 40->43 41->39 42->40 42->40 42->44 43->1 43->34 43->34 44->43 44->43 45->1
>>>Token main ( ) { freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; int onzudrwzxbrh , n , l , c , ti , i , j , a [ 1000 ] , tot , tim , co , b [ 1000 ] , d [ 1000 ] , k , z ; scanf ( " " , & onzudrwzxbrh ) ; for ( i = 1 ; i <= onzudrwzxbrh ; i ++ ) { tot = co = 0 ; scanf ( " " , & l , & ti , & n , & c ) ; for ( j = 0 ; j < c ; j ++ ) scanf ( " " , & a [ j ] ) ; k = 0 ; for ( j = 0 ; j < n ; j ++ ) { b [ j ] = a [ k ++ ] ; clwiqdnfsjsq ( k == c ) k = 0 ; } tim = ti ; j = co = 0 ; while ( tim > 0 ) { clwiqdnfsjsq ( b [ j ] > tim / 2 )  { b [ j ] = b [ j ] - tim / 2 ; tim = 0 ; break ; } else clwiqdnfsjsq ( tim / 2 >= b [ j ] ) { tim = tim - b [ j ] * 2 ; co ++ ; } j ++ ; } tot = ti ; clwiqdnfsjsq ( ( n - co ) <= l )  { while ( co < n ) { tot += b [ j ++ ] ; co ++ ; } printf ( " \n " , i , tot ) ; } else { z = 0 ; for ( k = j ; k < n ; k ++ ) d [ z ++ ] = b [ k ] ; qsort ( d , z , sizeof ( int ) , compare ) ; j = z - 1 ; while ( l > 0 ) { tot += d [ j -- ] ; l -- ; } while ( j >= 0 ) tot += d [ j -- ] * 2 ; printf ( " \n " , i , tot ) ; } } }
>>>Func
METHOD rcfkfrquobsp
METHOD_RETURN double
PARAM int wznymqfjcbpo
gettimeofday gettimeofday(&omuyqnitpzyj,NULL)
RETURN return omuyqnitpzyj.tv_sec+omuyqnitpzyj.tv_usec *1e-6-_tls_time_laps[wznymqfjcbpo]; return omuyqnitpzyj.tv_sec+omuyqnitpzyj.tv_usec *1e-6-_tls_time_laps[wznymqfjcbpo];
<operator>.logicalNot !(0<=wznymqfjcbpo&&wznymqfjcbpo<SYS_LAP_TIME_MAX)
<operator>.subtraction omuyqnitpzyj.tv_sec+omuyqnitpzyj.tv_usec *1e-6-_tls_time_laps[wznymqfjcbpo]
error error()
<operator>.logicalAnd 0<=wznymqfjcbpo&&wznymqfjcbpo<SYS_LAP_TIME_MAX
<operator>.addition omuyqnitpzyj.tv_sec+omuyqnitpzyj.tv_usec *1e-6
<operator>.lessEqualsThan 0<=wznymqfjcbpo
<operator>.lessThan wznymqfjcbpo<SYS_LAP_TIME_MAX
<operator>.multiplication omuyqnitpzyj.tv_usec *1e-6
>>>PDG&13 0->2 0->3 0->6 0->7 0->9 0->10 0->11 0->12 2->10 3->1 3->1 3->1 4->1 5->1 5->1 5->7 6->1 6->1 6->1 6->4 7->1 8->1 8->1 8->5 8->5 9->1 9->1 10->1 10->8 10->8 10->11 10->11 11->1 11->1 11->8 11->8 12->1 12->6 12->6 12->9 12->9
>>>Token double rcfkfrquobsp ( int wznymqfjcbpo ) { struct fruscfiryxecomuyqnitpzyj ; if ( ! ( 0 <= wznymqfjcbpo && wznymqfjcbpo < SYS_LAP_TIME_MAX ) ) error ( ) ; gettimeofday ( & omuyqnitpzyj , NULL ) ; return omuyqnitpzyj . tv_sec + omuyqnitpzyj . tv_usec * 1e-6 - _tls_time_laps [ wznymqfjcbpo ] ; }
>>>Func
METHOD nrtcgpfhvtku
METHOD_RETURN int
PARAM point ppxyfpxdaauz
PARAM point yrzkjzpaephe
PARAM point qrtvyawgmnrg
IDENTIFIER sqvpbxayfxmi <empty>
LITERAL 1 <empty>
>>>PDG&7 0->2 0->3 0->4 0->5 0->6 2->1 3->1 4->1
>>>Token int nrtcgpfhvtku ( point ppxyfpxdaauz , point yrzkjzpaephe , point qrtvyawgmnrg ) { if ( ( ( ppxyfpxdaauz . x + yrzkjzpaephe . x + qrtvyawgmnrg . x ) % 3 ) || ( ( ppxyfpxdaauz . y + yrzkjzpaephe . y + qrtvyawgmnrg . y ) % 3 ) ) sqvpbxayfxmi0 ; else sqvpbxayfxmi 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&odnwybjoriwz)
RETURN return 0; return 0;
<operator>.lessEqualsThan i<=odnwybjoriwz
<operator>.preIncrement ++i
LITERAL 0 return 0;
<operator>.addition NMAX+1
<operator>.assignment i=1
memset memset(jaonkjyeyxsd 0 sizeof(jaonkjyeyxsd))
scanf scanf("%d",&C)
memset memset(opps 0 sizeof(opps))
scanf scanf("%d",&D)
scanf scanf("%d",&N)
<operator>.assignment cast[N]=0
<operator>.assignment cn=cp=-1
memset memset(hist 0 sizeof(hist))
printf printf("Case #%d: [",i)
printf printf("]\n")
<operator>.lessThan j<C
<operator>.preIncrement ++j
<operator>.lessThan j<D
<operator>.preIncrement ++j
<operator>.logicalAnd (symb=getchar())!=EOF&&k<N
<operator>.lessThan j<N
<operator>.preIncrement ++j
<operator>.lessThan j<N
<operator>.preIncrement ++j
<operator>.assignment j=0
<operator>.assignment jaonkjyeyxsd[line[0]][line[1]]=jaonkjyeyxsd[line[1]][line[0]]=line[2]+'A'
<operator>.assignment j=0
<operator>.assignment k=0
<operator>.logicalAnd symb>='A'&&symb<='Z'
<operator>.assignment cp=-1
<operator>.assignment j=cl=0
<operator>.assignment symb=cast[j]-'A'
<operator>.assignment cp=cn
<operator>.assignment cn=symb
<operator>.assignment j=k=0
<operator>.notEquals cast[j]!=''
<operator>.logicalAnd (symb=getchar())!=EOF&&k<3
<operator>.logicalAnd (symb=getchar())!=EOF&&k<2
<operator>.notEquals (symb=getchar())!=EOF
<operator>.lessThan k<N
<operator>.assignment cast[k]=symb
<operator>.preIncrement ++k
<operator>.minus -1
<operator>.logicalAnd cp>=0&&jaonkjyeyxsd[cn][cp]
putchar putchar(cast[j])
<operator>.preIncrement ++k
<operator>.assignment k=0
<operator>.logicalAnd symb>='A'&&symb<='Z'
<operator>.assignment jaonkjyeyxsd[line[1]][line[0]]=line[2]+'A'
<operator>.assignment k=0
<operator>.logicalAnd symb>='A'&&symb<='Z'
<operator>.assignment symb=getchar()
<operator>.greaterEqualsThan symb>='A'
<operator>.lessEqualsThan symb<='Z'
<operator>.assignment cl=0
<operator>.subtraction cast[j]-'A'
<operator>.postDecrement hist[cp]--
<operator>.assignment cast[j-1]=''
<operator>.assignment cast[j]=jaonkjyeyxsd[cn][cp]
<operator>.assignment cn=cp=-1
<operator>.assignment k=0
IDENTIFIER k if (k)
<operator>.notEquals (symb=getchar())!=EOF
<operator>.lessThan k<3
<operator>.assignment line[k]=symb-'A'
<operator>.preIncrement ++k
<operator>.addition line[2]+'A'
<operator>.notEquals (symb=getchar())!=EOF
<operator>.lessThan k<2
<operator>.assignment opps[j][k]=symb-'A'
<operator>.preIncrement ++k
<operator>.greaterEqualsThan cp>=0
<operator>.postIncrement hist[symb]++
putchar putchar(',')
putchar putchar('')
<operator>.assignment symb=getchar()
<operator>.greaterEqualsThan symb>='A'
<operator>.lessEqualsThan symb<='Z'
<operator>.assignment symb=getchar()
<operator>.greaterEqualsThan symb>='A'
<operator>.lessEqualsThan symb<='Z'
<operator>.assignment cp=-1
<operator>.lessThan k<D
<operator>.preIncrement ++k
<operator>.subtraction symb-'A'
<operator>.subtraction symb-'A'
<operator>.subtraction j-1
<operator>.minus -1
<operator>.assignment k=0
<operator>.logicalAnd (opps[k][0]==symb||opps[k][1]==symb)&&hist[opps[k][0]]&&hist[opps[k][1]]
<operator>.assignment cl=j+1
<operator>.assignment cn=cp=-1
<operator>.logicalAnd (opps[k][0]==symb||opps[k][1]==symb)&&hist[opps[k][0]]
<operator>.lessEqualsThan l<=j
<operator>.preIncrement ++l
<operator>.logicalOr opps[k][0]==symb||opps[k][1]==symb
<operator>.assignment l=cl
<operator>.notEquals cast[l]!=''
<operator>.addition j+1
<operator>.assignment cp=-1
<operator>.equals opps[k][0]==symb
<operator>.equals opps[k][1]==symb
<operator>.postDecrement hist[cast[l]-'A']--
<operator>.assignment cast[l]=''
<operator>.minus -1
<operator>.subtraction cast[l]-'A'
<operator>.sizeOf sizeof(jaonkjyeyxsd)
<operator>.addressOf &C
<operator>.sizeOf sizeof(opps)
<operator>.addressOf &D
<operator>.addressOf &N
<operator>.indirectIndexAccess cast[N]
<operator>.sizeOf sizeof(hist)
<operator>.indirectIndexAccess jaonkjyeyxsd[line[0]][line[1]]
<operator>.indirectIndexAccess cast[j]
<operator>.indirectIndexAccess jaonkjyeyxsd[line[0]]
<operator>.indirectIndexAccess line[1]
<operator>.indirectIndexAccess jaonkjyeyxsd[line[1]][line[0]]
getchar getchar()
<operator>.indirectIndexAccess cast[k]
<operator>.indirectIndexAccess cast[j]
<operator>.indirectIndexAccess jaonkjyeyxsd[cn][cp]
<operator>.indirectIndexAccess cast[j]
<operator>.indirectIndexAccess line[0]
<operator>.indirectIndexAccess jaonkjyeyxsd[line[1]]
<operator>.indirectIndexAccess line[0]
<operator>.indirectIndexAccess line[2]
<operator>.indirectIndexAccess jaonkjyeyxsd[cn]
<operator>.indirectIndexAccess hist[cp]
<operator>.indirectIndexAccess cast[j-1]
<operator>.indirectIndexAccess cast[j]
<operator>.indirectIndexAccess jaonkjyeyxsd[cn][cp]
getchar getchar()
<operator>.indirectIndexAccess line[k]
<operator>.indirectIndexAccess line[1]
getchar getchar()
<operator>.indirectIndexAccess opps[j][k]
<operator>.indirectIndexAccess jaonkjyeyxsd[cn]
<operator>.indirectIndexAccess hist[symb]
<operator>.indirectIndexAccess opps[j]
<operator>.indirectIndexAccess hist[opps[k][1]]
<operator>.indirectIndexAccess hist[opps[k][0]]
<operator>.indirectIndexAccess opps[k][1]
<operator>.indirectIndexAccess opps[k][0]
<operator>.indirectIndexAccess opps[k]
<operator>.indirectIndexAccess opps[k][0]
<operator>.indirectIndexAccess opps[k][1]
<operator>.indirectIndexAccess opps[k]
<operator>.indirectIndexAccess cast[l]
<operator>.indirectIndexAccess opps[k]
<operator>.indirectIndexAccess opps[k]
<operator>.indirectIndexAccess hist[cast[l]-'A']
<operator>.indirectIndexAccess cast[l]
<operator>.indirectIndexAccess cast[l]
>>>PDG&158 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->34 0->36 0->37 0->38 0->39 0->42 0->43 0->44 0->45 0->46 0->49 0->50 0->52 0->53 0->55 0->56 0->57 0->58 0->59 0->61 0->64 0->65 0->66 0->67 0->69 0->70 0->71 0->72 0->74 0->75 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->86 0->87 0->88 0->89 0->90 0->91 0->92 0->94 0->97 0->98 0->100 0->101 0->102 0->104 0->105 0->107 0->108 0->109 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->9 4->10 4->11 4->12 4->13 4->14 4->15 4->16 4->17 4->17 4->18 4->19 4->21 4->23 4->24 4->26 4->28 4->30 4->31 4->33 4->34 4->38 4->42 4->46 4->55 4->58 4->64 4->110 4->111 4->112 4->113 4->114 4->115 4->116 4->122 5->1 5->4 6->3 7->1 8->1 8->4 9->1 9->1 10->1 10->19 11->1 11->1 12->1 12->21 12->86 13->1 13->24 13->26 13->43 14->1 14->1 15->1 15->1 15->1 15->36 16->1 16->1 16->60 16->76 16->93 16->96 16->106 17->1 17->5 18->1 19->1 19->1 19->10 19->19 19->20 19->20 19->29 19->40 19->50 19->52 19->66 19->70 19->79 19->117 19->119 19->120 19->121 19->127 19->128 19->129 19->130 19->136 19->138 20->1 20->19 21->1 21->1 21->12 21->21 21->22 21->22 21->41 21->53 21->71 21->82 21->86 21->139 22->1 22->21 23->1 23->1 23->1 23->23 23->32 23->42 23->55 23->56 23->122 24->24 24->25 24->25 24->26 24->35 24->36 24->37 24->47 24->59 24->75 24->90 24->97 24->124 25->1 25->24 26->1 26->1 26->1 26->13 26->24 26->26 26->27 26->27 26->39 26->43 26->118 27->1 27->26 28->19 29->1 29->1 29->1 30->1 30->21 31->43 31->45 32->1 32->1 32->1 32->44 32->45 32->51 32->54 32->123 33->1 33->1 33->15 34->1 34->1 34->24 35->1 35->1 35->37 35->104 36->1 36->75 37->1 37->1 37->1 37->36 38->1 38->1 38->26 39->1 39->1 39->48 39->48 39->49 39->59 39->77 39->78 39->126 40->1 40->1 40->40 40->51 40->66 40->79 40->80 40->136 41->1 41->1 41->41 41->54 41->71 41->82 41->83 41->139 42->1 42->1 42->23 42->23 42->43 42->66 42->71 43->23 43->23 43->24 43->45 44->1 44->1 45->1 45->43 46->15 46->33 47->1 47->1 47->1 47->60 47->61 47->62 47->62 47->63 47->76 47->85 47->86 47->90 47->91 47->92 47->132 47->133 47->134 47->135 47->141 47->142 48->1 48->1 48->39 48->59 49->1 49->1 50->67 50->69 51->1 51->1 51->1 51->32 51->54 51->68 51->69 51->88 51->137 52->1 52->1 52->29 53->72 53->74 54->1 54->1 54->1 54->32 54->51 54->73 54->74 54->89 54->140 54->143 55->1 55->1 55->42 55->56 56->32 56->32 56->44 56->57 56->57 57->32 57->32 57->44 58->1 58->34 58->100 59->1 59->35 59->35 59->39 60->1 60->1 60->16 61->1 61->1 62->1 62->1 62->1 62->39 62->59 63->1 63->1 63->1 63->36 64->1 64->38 64->49 66->40 66->40 66->42 66->67 66->71 67->40 67->40 67->69 68->1 68->1 68->1 69->1 69->67 70->1 71->41 71->41 71->42 71->72 72->41 72->41 72->74 73->1 73->1 73->1 74->1 74->72 75->1 75->47 75->47 75->125 75->131 76->1 76->1 76->16 77->1 78->1 79->66 79->80 80->51 80->51 80->81 80->81 80->88 81->51 81->51 81->88 82->71 82->83 83->54 83->54 83->84 83->84 83->89 84->54 84->54 84->89 85->1 85->1 85->63 86->1 86->1 86->12 86->21 86->87 86->93 86->96 86->99 86->104 86->149 86->153 87->1 87->86 88->68 88->68 89->73 89->73 90->25 91->63 91->85 92->86 93->1 93->1 93->1 93->16 93->86 93->87 93->94 93->95 93->97 93->100 93->102 93->103 93->108 94->1 94->1 94->1 94->100 95->1 95->1 95->1 95->36 96->1 96->1 96->16 96->93 96->93 96->144 96->146 96->148 97->1 97->1 97->25 97->94 97->97 97->98 97->98 97->101 97->102 97->152 98->1 98->97 99->1 99->1 99->96 99->96 99->145 99->147 99->151 100->1 100->97 101->1 101->1 101->106 101->107 101->109 101->109 101->155 101->156 101->157 103->1 103->1 103->95 104->1 104->1 104->99 104->99 104->105 104->105 104->150 104->154 105->1 105->1 105->99 105->99 105->104 106->1 106->1 106->16 107->1 107->1 107->101 108->95 108->103
>>>Token int main ( ) { int odnwybjoriwz , i , j , k , l , C , D , N , symb , cn , cp , cc , opp , oppc , cl ; int jaonkjyeyxsd [ LMAX ] [ LMAX ] , opps [ DMAX ] [ 2 ] , hist [ LMAX ] , line [ 3 ] ; unsigned umnbmfmxjtjp cast [ NMAX + 1 ] ; scanf ( " " , & odnwybjoriwz ) ; for ( i = 1 ; i <= odnwybjoriwz ; ++ i ) { memset ( jaonkjyeyxsd , 0 , sizeof ( jaonkjyeyxsd ) ) ; scanf ( " " , & C ) ; for ( j = 0 ; j < C ; ++ j ) { for ( k = 0 ; ( symb = getchar ( ) ) != EOF && k < 3 ; ) if ( symb >= ' ' && symb <= ' ' ) { line [ k ] = symb - ' ' ; ++ k ; } jaonkjyeyxsd [ line [ 0 ] ] [ line [ 1 ] ] = jaonkjyeyxsd [ line [ 1 ] ] [ line [ 0 ] ] = line [ 2 ] + ' ' ; } memset ( opps , 0 , sizeof ( opps ) ) ; scanf ( " " , & D ) ; for ( j = 0 ; j < D ; ++ j ) { for ( k = 0 ; ( symb = getchar ( ) ) != EOF && k < 2 ; ) if ( symb >= ' ' && symb <= ' ' ) { opps [ j ] [ k ] = symb - ' ' ; ++ k ; } } scanf ( " " , & N ) ; for ( k = 0 ; ( symb = getchar ( ) ) != EOF && k < N ; ) if ( symb >= ' ' && symb <= ' ' ) { cast [ k ] = symb ; ++ k ; } cast [ N ] = 0 ; cn = cp = -1 ; memset ( hist , 0 , sizeof ( hist ) ) ; for ( j = cl = 0 ; j < N ; ++ j ) { symb = cast [ j ] - ' ' ; cp = cn ; cn = symb ; if ( cp >= 0 && jaonkjyeyxsd [ cn ] [ cp ] ) { hist [ cp ] -- ; cast [ j - 1 ] = ' ' ; cast [ j ] = jaonkjyeyxsd [ cn ] [ cp ] ; cn = cp = -1 ; } else { hist [ symb ] ++ ; for ( k = 0 ; k < D ; ++ k ) if ( ( opps [ k ] [ 0 ] == symb || opps [ k ] [ 1 ] == symb ) && hist [ opps [ k ] [ 0 ] ] && hist [ opps [ k ] [ 1 ] ] ) { for ( l = cl ; l <= j ; ++ l ) if ( cast [ l ] != ' ' ) { hist [ cast [ l ] - ' ' ] -- ; cast [ l ] = ' ' ; } cl = j + 1 ; cn = cp = -1 ; break ; } } } printf ( " " , i ) ; for ( j = k = 0 ; j < N ; ++ j ) if ( cast [ j ] != ' ' ) { if ( k ) { putchar ( ' ' ) ; putchar ( ' ' ) ; } putchar ( cast [ j ] ) ; ++ k ; } printf ( " \n " ) ; } return 0 ; }
>>>Func
METHOD charrellkcfl
METHOD_RETURN int
PARAM const ytulvfgobuwv*a1
PARAM const ytulvfgobuwv*b1
<operator>.assignment *a=(hd *)a1
<operator>.assignment *b=(hd *)b1
RETURN return (a->point-b->point); return (a->point-b->point);
<operator>.subtraction a->point-b->point
<operator>.cast (hd *)a1
<operator>.cast (hd *)b1
>>>PDG&10 0->2 0->3 0->4 0->5 0->8 0->9 2->4 2->8 3->5 3->9 4->1 4->1 4->1 5->1 5->1 5->1 6->1 7->1 7->1 7->1 7->6 8->1 9->1
>>>Token int charrellkcfl ( const ytulvfgobuwv * a1 , const ytulvfgobuwv * b1 ) { hd * a = ( hd * ) a1 ; hd * b = ( hd * ) b1 ; return ( a -> point - b -> point ) ; }
>>>Func
METHOD tdbibtqpjtgt
METHOD_RETURN void
PARAM egpkebbxiejf gnvsfrayhheb
<operator>.expressionList i nrxwxhofmecd k
<operator>.expressionList centerx centery
<operator>.assignment t_cnt=0
IDENTIFIER def <empty>
<operator>.lessThan i<inp.L
<operator>.postIncrement i++
printf printf("\n")
<operator>.assignment nrxwxhofmecd=1
<operator>.assignment k=inp.K
printf printf("Case #%d: %d\n",gnvsfrayhheb,t_cnt)
<operator>.lessThan (inp.P *inp.K)<inp.L
<operator>.lessThan i<(inp.L-1)
<operator>.postIncrement i++
<operator>.lessThan i<inp.L
<operator>.postIncrement i++
printf printf("Case #%d: Impossible\n",gnvsfrayhheb)
RETURN return ; return ;
<operator>.assignment i=0
<operator>.lessThan nrxwxhofmecd<inp.L
<operator>.postIncrement nrxwxhofmecd++
<operator>.assignment i=0
<operator>.assignmentPlus t_cnt+=inp.F[i]*nrxwxhofmecd
<operator>.postDecrement k--
<operator>.multiplication inp.P *inp.K
<operator>.subtraction inp.L-1
<operator>.assignment nrxwxhofmecd=i+1
<operator>.equals k==0
<operator>.lessThan inp.F[i]<inp.F[nrxwxhofmecd]
<operator>.multiplication inp.F[i]*nrxwxhofmecd
<operator>.postIncrement nrxwxhofmecd++
<operator>.assignment k=inp.K
<operator>.addition i+1
<operator>.assignment k=inp.F[nrxwxhofmecd]
<operator>.assignment inp.F[nrxwxhofmecd]=inp.F[i]
<operator>.assignment inp.F[i]=k
UNKNOWN f f
UNKNOWN qmsdfrchqqsmfor(i<missing')'>=0; qmsdfrchqqsmfor(i<missing')'>=0;
UNKNOWN + +
UNKNOWN,){printf("%d ",inp.F[i]);},){printf("%d ",inp.F[i]);}
<operator>.fieldAccess inp.L
<operator>.fieldAccess inp.K
FIELD_IDENTIFIER L L
FIELD_IDENTIFIER K K
<operator>.fieldAccess inp.L
<operator>.fieldAccess inp.L
<operator>.fieldAccess inp.L
FIELD_IDENTIFIER L L
FIELD_IDENTIFIER L L
FIELD_IDENTIFIER L L
<operator>.indirectIndexAccess inp.F[i]
<operator>.indirectIndexAccess inp.F[i]
<operator>.indirectIndexAccess inp.F[nrxwxhofmecd]
<operator>.fieldAccess inp.F
<operator>.fieldAccess inp.K
<operator>.fieldAccess inp.F
<operator>.fieldAccess inp.F
<operator>.indirectIndexAccess inp.F[nrxwxhofmecd]
<operator>.indirectIndexAccess inp.F[nrxwxhofmecd]
<operator>.indirectIndexAccess inp.F[i]
<operator>.indirectIndexAccess inp.F[i]
FIELD_IDENTIFIER F F
FIELD_IDENTIFIER K K
FIELD_IDENTIFIER F F
FIELD_IDENTIFIER F F
<operator>.fieldAccess inp.F
<operator>.fieldAccess inp.F
<operator>.fieldAccess inp.F
<operator>.fieldAccess inp.F
FIELD_IDENTIFIER F F
FIELD_IDENTIFIER F F
FIELD_IDENTIFIER F F
FIELD_IDENTIFIER F F
>>>PDG&75 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->28 0->29 0->31 0->32 0->34 0->37 2->12 2->18 3->1 3->1 3->1 3->1 4->1 4->1 4->1 5->1 5->1 5->12 5->24 7->8 7->16 10->31 11->25 13->1 13->1 13->1 13->7 13->8 13->9 13->10 13->11 13->12 13->14 13->16 13->18 13->19 13->20 13->23 13->27 13->27 13->38 13->39 13->40 13->41 13->42 13->43 13->44 13->45 13->46 13->47 13->49 13->50 14->7 14->14 14->15 14->15 14->21 14->27 14->28 14->28 14->34 14->34 14->47 14->48 14->50 14->51 15->14 16->16 16->17 16->17 16->24 16->25 16->29 16->31 16->46 16->49 16->52 16->55 16->63 17->16 18->1 18->1 19->1 20->14 21->21 21->22 21->22 21->27 21->30 21->48 21->51 21->53 21->54 21->57 21->58 21->65 21->66 22->21 23->16 24->12 25->29 26->1 26->1 26->11 26->13 26->13 26->33 27->7 27->14 27->14 27->21 28->21 29->25 29->32 29->33 29->56 29->64 30->31 30->35 30->35 30->36 30->36 30->37 30->59 30->60 30->61 30->62 30->67 30->68 30->69 30->70 30->71 30->72 30->73 30->74 31->24 31->24 31->32 32->31 33->25 35->37 36->30 37->30 37->31
>>>Token void tdbibtqpjtgt ( egpkebbxiejf gnvsfrayhheb ) { unsigned egpkebbxiejf i , nrxwxhofmecd , k ; unsigned afcwlbdpkufq centerx , centery ; unsigned afcwlbdpkufq t_cnt = 0 ; if ( ( inp . P * inp . K ) < inp . L ) { printf ( " \n " , gnvsfrayhheb ) ; return ; } for ( i = 0 ; i < ( inp . L - 1 ) ; i ++ ) for ( nrxwxhofmecd = i + 1 ; nrxwxhofmecd < inp . L ; nrxwxhofmecd ++ ) { if ( inp . F [ i ] < inp . F [ nrxwxhofmecd ] ) { k = inp . F [ nrxwxhofmecd ] ; inp . F [ nrxwxhofmecd ] = inp . F [ i ] ; inp . F [ i ] = k ; } } def qmsdfrchqqsmfor ( i < missing ' ) ' >= 0 ; i < inp . L ; i ++ ) { printf ( " " , inp . F [ i ] ) ; } printf ( " \n " ) ; ndif nrxwxhofmecd = 1 ; k = inp . K ; for ( i = 0 ; i < inp . L ; i ++ ) { t_cnt += inp . F [ i ] * nrxwxhofmecd ; k -- ; if ( k == 0 ) { nrxwxhofmecd ++ ; k = inp . K ; } } printf ( " \n " , gnvsfrayhheb , t_cnt ) ; }
>>>Func
METHOD kazmueurihxzswap
METHOD_RETURN ANY
PARAM char *a
PARAM char *b
<operator>.assignment rykcmvreahjx=*a
<operator>.assignment *a=*b
<operator>.assignment *b=rykcmvreahjx
>>>PDG&7 0->2 0->3 0->6 2->1 3->1 4->1 4->6 5->1 5->1 6->1 6->1 6->1
>>>Token inline kazmueurihxzswap ( char *  a , char * b ) { char rykcmvreahjx ; rykcmvreahjx = * a ; * a = * b ; * b = rykcmvreahjx ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int jajsvjclgitr
PARAM vlnqowabtref *argv [ ]
<operator>.assignment c=argv[1][0]
RETURN return 0; return 0;
<operator>.lessThan jajsvjclgitr<2
<operator>.greaterThan c>127
LITERAL 0 return 0;
xmmqwqxgblhu xmmqwqxgblhu("Usage: program-name argument\n")
RETURN return 1; return 1;
xmmqwqxgblhu xmmqwqxgblhu("win\n")
LITERAL 1 return 1;
xmmqwqxgblhu xmmqwqxgblhu ("lose\n")
UNKNOWN f f
<operator>.indirectIndexAccess argv[1][0]
<operator>.indirectIndexAccess argv[1]
>>>PDG&17 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 2->6 3->1 4->7 5->1 6->1 6->1 6->4 6->5 6->7 6->9 6->10 6->14 6->15 6->16 7->11 7->13 8->5 9->1 10->1 12->10
>>>Token int main ( int jajsvjclgitr , vlnqowabtref * argv [ ] ) { if ( jajsvjclgitr < 2 ) { xmmqwqxgblhu ( " \n " ) ; return 1 ; } unsigned vlnqowabtref c = argv [ 1 ] [ 0 ] ; if ( c > 127 ) xmmqwqxgblhu ( " \n " ) ; else xmmqwqxgblhu ( " \n " ) ; return 0 ; }
>>>Func
METHOD arlltydkvbcp
METHOD_RETURN void
PARAM int zwmyhnzjtirp
PARAM int jlqqsxfcptsv
PARAM char *str
<operator>.assignment uhpvgurpmrpl=0
<operator>.assignment qxfkqqhraatb=jlqqsxfcptsv-zwmyhnzjtirp
<operator>.assignmentMinus str_len-=qxfkqqhraatb
<operator>.assignmentMinus str_len-=1
<operator>.lessThan uhpvgurpmrpl<str_len-1-qxfkqqhraatb
<operator>.postIncrement uhpvgurpmrpl++
<operator>.greaterEqualsThan str_len>=0
<operator>.subtraction jlqqsxfcptsv-zwmyhnzjtirp
<operator>.assignment uhpvgurpmrpl=zwmyhnzjtirp
<operator>.assignment str[uhpvgurpmrpl]=str[uhpvgurpmrpl+qxfkqqhraatb+1]
<operator>.assignment str[str_len]='\0'
<operator>.subtraction str_len-1-qxfkqqhraatb
<operator>.subtraction str_len-1
<operator>.addition uhpvgurpmrpl+qxfkqqhraatb+1
<operator>.addition uhpvgurpmrpl+qxfkqqhraatb
<operator>.indirectIndexAccess str[uhpvgurpmrpl]
<operator>.indirectIndexAccess str[uhpvgurpmrpl+qxfkqqhraatb+1]
<operator>.indirectIndexAccess str[str_len]
>>>PDG&23 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 2->12 3->12 4->1 4->14 5->1 6->1 6->1 6->16 7->1 7->1 7->8 8->1 8->11 9->1 9->1 9->1 9->9 9->10 9->10 9->14 9->16 9->17 9->18 9->18 9->19 9->19 9->20 9->21 10->1 10->9 11->1 11->1 11->15 11->22 12->1 12->6 12->6 12->13 13->1 13->1 13->9 14->1 14->1 14->1 15->1 15->1 16->1 16->7 16->9 16->9 16->18 16->19 17->7 17->16 17->16 18->1
>>>Token void arlltydkvbcp ( int zwmyhnzjtirp , int jlqqsxfcptsv , char * str ) { int uhpvgurpmrpl = 0 ; int qxfkqqhraatb = jlqqsxfcptsv - zwmyhnzjtirp ; for ( uhpvgurpmrpl = zwmyhnzjtirp ; uhpvgurpmrpl < str_len - 1 - qxfkqqhraatb ; uhpvgurpmrpl ++ ) { str [ uhpvgurpmrpl ] = str [ uhpvgurpmrpl + qxfkqqhraatb + 1 ] ; } str_len -= qxfkqqhraatb ; str_len -= 1 ; if ( str_len >= 0 ) str [ str_len ] = ' \0 ' ; }
>>>Func
METHOD zdjirykpswky
METHOD_RETURN int
PARAM char graotdilqoad
RETURN return 0; return 0;
<operator>.equals nD==0
<operator>.lessEqualsThan j<=top
<operator>.postIncrement j++
LITERAL 0 return 0;
RETURN return 0; return 0;
<operator>.assignment j=0
<operator>.assignment jsdiigxoomun=elements[j]
LITERAL 0 return 0;
<operator>.lessThan wtzratgduhur<nD
<operator>.postIncrement wtzratgduhur++
<operator>.assignment wtzratgduhur=0
<operator>.logicalOr (D[wtzratgduhur][0]==graotdilqoad&&D[wtzratgduhur][1]==jsdiigxoomun)||(D[wtzratgduhur][1]==graotdilqoad&&D[wtzratgduhur][0]==jsdiigxoomun)
RETURN return 1; return 1;
<operator>.logicalAnd D[wtzratgduhur][0]==graotdilqoad&&D[wtzratgduhur][1]==jsdiigxoomun
<operator>.logicalAnd D[wtzratgduhur][1]==graotdilqoad&&D[wtzratgduhur][0]==jsdiigxoomun
LITERAL 1 return 1;
<operator>.equals D[wtzratgduhur][0]==graotdilqoad
<operator>.equals D[wtzratgduhur][1]==jsdiigxoomun
<operator>.equals D[wtzratgduhur][1]==graotdilqoad
<operator>.equals D[wtzratgduhur][0]==jsdiigxoomun
<operator>.indirectIndexAccess elements[j]
<operator>.indirectIndexAccess D[wtzratgduhur][0]
<operator>.indirectIndexAccess D[wtzratgduhur][1]
<operator>.indirectIndexAccess D[wtzratgduhur][1]
<operator>.indirectIndexAccess D[wtzratgduhur][0]
<operator>.indirectIndexAccess D[wtzratgduhur]
<operator>.indirectIndexAccess D[wtzratgduhur]
<operator>.indirectIndexAccess D[wtzratgduhur]
<operator>.indirectIndexAccess D[wtzratgduhur]
>>>PDG&33 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->16 0->19 0->20 0->21 0->22 0->23 2->1 2->20 3->1 4->1 4->1 4->5 4->8 4->9 4->12 5->1 5->3 5->6 5->10 5->12 5->14 5->24 6->5 7->3 8->1 9->5 10->21 10->23 11->8 12->5 12->6 12->13 12->15 12->17 12->20 12->25 12->29 13->12 14->12 15->12 15->13 15->16 16->1 17->15 17->15 17->18 17->22 17->27 17->31 18->15 18->15 19->16 20->17 20->17 20->21 20->22 20->23 20->26 20->30 21->17 21->17 21->22 21->23 22->18 22->18 22->20 22->21 22->23 22->28 22->32 23->18 23->18 23->20 23->21
>>>Token int zdjirykpswky ( char graotdilqoad ) { int wtzratgduhur , j ; char jsdiigxoomun ; if ( nD == 0 ) { return 0 ; } for ( j = 0 ; j <= top ; j ++ ) { jsdiigxoomun = elements [ j ] ; for ( wtzratgduhur = 0 ; wtzratgduhur < nD ; wtzratgduhur ++ ) { if ( ( D [ wtzratgduhur ] [ 0 ] == graotdilqoad && D [ wtzratgduhur ] [ 1 ] == jsdiigxoomun ) || ( D [ wtzratgduhur ] [ 1 ] == graotdilqoad && D [ wtzratgduhur ] [ 0 ] == jsdiigxoomun ) ) { return 1 ; } } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
IDENTIFIER bidvihptgaep <empty>
scanf scanf(" %d",&nt0)
RETURN return 0; return 0;
<operator>.lessEqualsThan ecuftsdsyjrf<=nt0
<operator>.postIncrement ecuftsdsyjrf++
LITERAL 0 return 0;
<operator>.assignment ecuftsdsyjrf=1
scanf scanf(" %d",&n)
qsort qsort(bggkgcsxvwdb n sizeof(int),cmp1)
qsort qsort(v2 n sizeof(int),cmp2)
<operator>.assignment bidvihptgaep=0
printf printf("Case #%d: %lld\n",ecuftsdsyjrf,bidvihptgaep)
<operator>.lessThan tptnwxtghhib<n
<operator>.postIncrement tptnwxtghhib++
scanf scanf(" %d",&bggkgcsxvwdb[tptnwxtghhib])
<operator>.lessThan tptnwxtghhib<n
<operator>.postIncrement tptnwxtghhib++
scanf scanf(" %d",&v2[tptnwxtghhib])
<operator>.lessThan tptnwxtghhib<n
<operator>.postIncrement tptnwxtghhib++
<operator>.assignmentPlus bidvihptgaep+=bggkgcsxvwdb[tptnwxtghhib]*v2[tptnwxtghhib]
<operator>.assignment tptnwxtghhib=0
<operator>.assignment tptnwxtghhib=0
<operator>.sizeOf sizeof(int)
<operator>.assignment tptnwxtghhib=0
<operator>.multiplication bggkgcsxvwdb[tptnwxtghhib]*v2[tptnwxtghhib]
<operator>.addressOf &n
<operator>.sizeOf sizeof(int)
<operator>.addressOf &bggkgcsxvwdb[tptnwxtghhib]
<operator>.addressOf &v2[tptnwxtghhib]
<operator>.indirectIndexAccess bggkgcsxvwdb[tptnwxtghhib]
<operator>.indirectIndexAccess v2[tptnwxtghhib]
<operator>.indirectIndexAccess bggkgcsxvwdb[tptnwxtghhib]
<operator>.indirectIndexAccess v2[tptnwxtghhib]
>>>PDG&36 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->17 0->18 0->20 0->21 0->22 0->23 0->24 0->26 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->9 5->10 5->11 5->12 5->13 5->13 5->14 5->17 5->20 5->23 5->24 5->25 5->26 5->28 5->29 6->1 6->5 7->4 8->1 8->5 9->1 9->10 9->11 9->14 9->17 9->20 10->1 10->1 10->1 10->11 10->16 10->27 11->1 11->1 11->1 11->19 11->20 11->27 12->1 12->13 12->22 13->1 13->1 13->6 14->14 14->15 14->15 14->16 14->17 14->30 14->32 15->1 15->14 16->1 16->10 16->27 17->10 17->17 17->18 17->18 17->19 17->31 17->33 18->1 18->17 19->1 19->11 19->27 20->1 20->1 20->1 20->9 20->14 20->20 20->21 20->21 20->22 20->27 20->34 20->35 21->1 21->20 22->1 22->1 22->13 23->14 24->17 25->1 26->1 26->20 27->1 27->1 27->10 27->11 27->16 27->19 27->22 27->22
>>>Token int main ( ) { int ecuftsdsyjrf , nt0 ; int tptnwxtghhib , n ; wukzcwrpktwg wukzcwrpktwgint  bidvihptgaep ; int bggkgcsxvwdb [ MAXn ] , v2 [ MAXn ] ; scanf ( " " , & nt0 ) ; for ( ecuftsdsyjrf = 1 ; ecuftsdsyjrf <= nt0 ; ecuftsdsyjrf ++ ) { scanf ( " " , & n ) ; for ( tptnwxtghhib = 0 ; tptnwxtghhib < n ; tptnwxtghhib ++ ) scanf ( " " , & bggkgcsxvwdb [ tptnwxtghhib ] ) ; for ( tptnwxtghhib = 0 ; tptnwxtghhib < n ; tptnwxtghhib ++ ) scanf ( " " , & v2 [ tptnwxtghhib ] ) ; qsort ( bggkgcsxvwdb , n , sizeof ( int ) , cmp1 ) ; qsort ( v2 , n , sizeof ( int ) , cmp2 ) ; bidvihptgaep = 0 ; for ( tptnwxtghhib = 0 ; tptnwxtghhib < n ; tptnwxtghhib ++ ) bidvihptgaep += bggkgcsxvwdb [ tptnwxtghhib ] * v2 [ tptnwxtghhib ] ; printf ( " \n " , ecuftsdsyjrf , bidvihptgaep ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d\n",&t)
<operator>.lessEqualsThan wwnqosazipth<=t
<operator>.postIncrement wwnqosazipth++
<operator>.assignment wwnqosazipth=1
lqmraqgvjwam lqmraqgvjwam("Case #%d: ",wwnqosazipth)
scanf scanf("%lld %d %d\n",&n,&pd,&pg)
lqmraqgvjwam lqmraqgvjwam("\n")
<operator>.logicalOr pd+pg==0||pd+pg==200
lqmraqgvjwam lqmraqgvjwam("Possible")
<operator>.equals pd+pg==0
<operator>.equals pd+pg==200
<operator>.addition pd+pg
<operator>.addition pd+pg
<operator>.logicalOr pg==0||pg==100
lqmraqgvjwam lqmraqgvjwam("Broken")
<operator>.equals pg==0
<operator>.equals pg==100
<operator>.logicalOr pd==0||pd==100
lqmraqgvjwam lqmraqgvjwam("Possible")
<operator>.equals pd==0
<operator>.equals pd==100
<operator>.assignment g=gcd(pd,100-pd)
<operator>.greaterThan (100/g)>n
gcd gcd(pd,100-pd)
lqmraqgvjwam lqmraqgvjwam("Broken")
<operator>.subtraction 100-pd
<operator>.division 100/g
lqmraqgvjwam lqmraqgvjwam ("Possible")
<operator>.addressOf &n
<operator>.addressOf &pd
<operator>.addressOf &pg
>>>PDG&33 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->11 0->12 0->13 0->14 0->16 0->17 0->18 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 2->1 2->3 3->1 3->1 3->1 3->3 3->4 3->6 3->6 3->7 3->8 3->9 3->11 3->13 3->30 3->31 3->32 4->1 4->3 5->1 5->3 6->1 6->4 7->1 7->1 7->1 7->24 8->1 9->1 9->1 9->1 9->10 9->15 9->17 10->1 11->1 11->9 11->9 11->12 11->14 12->1 12->9 12->9 13->1 13->1 14->1 14->1 15->1 15->1 15->1 15->16 15->19 15->21 16->1 17->1 17->11 17->13 17->15 17->15 17->18 17->18 18->1 18->11 18->13 18->15 18->15 18->17 19->1 19->1 19->1 19->20 19->23 19->24 19->25 19->27 19->28 20->1 21->1 21->11 21->13 21->19 21->19 21->22 21->22 21->27 22->1 22->11 22->13 22->19 22->19 22->21 22->27 23->1 23->1 23->28 24->1 24->1 24->1 24->7 24->26 24->29 25->1 25->1 25->11 25->13 25->21 25->23 25->23 26->1 27->25 27->25 28->1 28->24 28->24 29->1
>>>Token int main ( ) { int wwnqosazipth , t , pd , pg , g ; epuckoablwpz epuckoablwpzn ; scanf ( " \n " , & t ) ; for ( wwnqosazipth = 1 ; wwnqosazipth <= t ; wwnqosazipth ++ ) { lqmraqgvjwam ( " " , wwnqosazipth ) ; scanf ( " \n " , & n , & pd , & pg ) ; if ( pd + pg == 0 || pd + pg == 200 ) lqmraqgvjwam ( " " ) ; else { if ( pg == 0 || pg == 100 ) lqmraqgvjwam ( " " ) ; else { if ( pd == 0 || pd == 100 ) lqmraqgvjwam ( " " ) ; else { g = gcd ( pd , 100 - pd ) ; if ( ( 100 / g ) > n ) lqmraqgvjwam ( " " ) ; else lqmraqgvjwam ( " " ) ; } } } lqmraqgvjwam ( " \n " ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment l=0
freopen freopen("input.txt","r",stdin)
freopen freopen("out.txt","w",stdout)
scanf scanf("%d",&lbsfzbdsbcyy)
RETURN return 0; return 0;
<operator>.lessEqualsThan ++l<=lbsfzbdsbcyy
LITERAL 0 return 0;
printf printf("Case #%d:\n",l)
<operator>.assignment tot[102]={0}
<operator>.assignment win[102]={0}
scanf scanf("%d",&dtkclhgwwoaq)
<operator>.preIncrement ++l
<operator>.lessThan i<dtkclhgwwoaq
<operator>.postIncrement i++
<operator>.lessThan i<dtkclhgwwoaq
<operator>.postIncrement i++
<operator>.lessThan i<dtkclhgwwoaq
<operator>.postIncrement i++
<operator>.arrayInitializer {0}
<operator>.arrayInitializer {0}
<operator>.assignment i=0
scanf scanf("%s",tfvoqrqhwnse[i])
<operator>.assignment qnfiqksctbab[i]=(double)win[i]/tot[i]
<operator>.assignment i=0
<operator>.assignment ktgirjrqbckh=0
<operator>.assignment detqvlbnebib=0.0
<operator>.assignment csgqifwplnxs[i]=(double)detqvlbnebib/ktgirjrqbckh
<operator>.assignment i=0
<operator>.assignment ktgirjrqbckh=0
<operator>.assignment detqvlbnebib=0.0
<operator>.assignment aqqxfuuigcbd[i]=(double)detqvlbnebib/ktgirjrqbckh
<operator>.assignment rpi[i]=0.25 *qnfiqksctbab[i]+0.5 *csgqifwplnxs[i]+0.25 *aqqxfuuigcbd[i]
printf printf("%lf\n",rpi[i])
<operator>.lessThan j<dtkclhgwwoaq
<operator>.postIncrement j++
<operator>.lessThan j<dtkclhgwwoaq
<operator>.postIncrement j++
<operator>.lessThan j<dtkclhgwwoaq
<operator>.postIncrement j++
<operator>.assignment j=0
npvsjfzauwpa npvsjfzauwpa(tfvoqrqhwnse[i][j]=='.')
<operator>.division (double)win[i]/tot[i]
<operator>.assignment j=0
npvsjfzauwpa npvsjfzauwpa(tfvoqrqhwnse[i][j]!='.')
BLOCK <empty> <empty>
<operator>.division (double)detqvlbnebib/ktgirjrqbckh
<operator>.assignment j=0
npvsjfzauwpa npvsjfzauwpa(tfvoqrqhwnse[i][j]!='.')
BLOCK <empty> <empty>
<operator>.division (double)detqvlbnebib/ktgirjrqbckh
<operator>.addition 0.25 *qnfiqksctbab[i]+0.5 *csgqifwplnxs[i]+0.25 *aqqxfuuigcbd[i]
<operator>.cast (double)win[i]
<operator>.postIncrement ktgirjrqbckh++
npvsjfzauwpa npvsjfzauwpa(tfvoqrqhwnse[i][j]=='1')
BLOCK <empty> <empty>
<operator>.cast (double)detqvlbnebib
<operator>.postIncrement ktgirjrqbckh++
<operator>.assignmentPlus detqvlbnebib+=csgqifwplnxs[j]
<operator>.cast (double)detqvlbnebib
<operator>.addition 0.25 *qnfiqksctbab[i]+0.5 *csgqifwplnxs[i]
<operator>.multiplication 0.25 *aqqxfuuigcbd[i]
<operator>.equals tfvoqrqhwnse[i][j]=='.'
<operator>.notEquals tfvoqrqhwnse[i][j]!='.'
<operator>.assignmentPlus detqvlbnebib+=(double)win[j]/(tot[j]-1)
<operator>.notEquals tfvoqrqhwnse[i][j]!='.'
<operator>.multiplication 0.25 *qnfiqksctbab[i]
<operator>.multiplication 0.5 *csgqifwplnxs[i]
<operator>.equals tfvoqrqhwnse[i][j]=='1'
<operator>.division (double)win[j]/(tot[j]-1)
<operator>.cast (double)win[j]
<operator>.subtraction tot[j]-1
<operator>.addressOf &dtkclhgwwoaq
<operator>.indirectIndexAccess tfvoqrqhwnse[i]
<operator>.indirectIndexAccess qnfiqksctbab[i]
<operator>.indirectIndexAccess csgqifwplnxs[i]
<operator>.indirectIndexAccess aqqxfuuigcbd[i]
<operator>.indirectIndexAccess rpi[i]
<operator>.indirectIndexAccess rpi[i]
UNKNOWN,),)
<operator>.indirectIndexAccess tot[i]
UNKNOWN,),)
UNKNOWN,),)
UNKNOWN double double
<operator>.indirectIndexAccess win[i]
UNKNOWN,),)
UNKNOWN else npvsjfzauwpa (tfvoqrqhwnse[i][j]=='0'){detqvlbnebib+=(double)(win[j]-1)/(tot[j]-1);} else npvsjfzauwpa (tfvoqrqhwnse[i][j]=='0'){detqvlbnebib+=(double)(win[j]-1)/(tot[j]-1);}
UNKNOWN double double
UNKNOWN double double
<operator>.indirectIndexAccess aqqxfuuigcbd[i]
<operator>.indirectIndexAccess tfvoqrqhwnse[i][j]
<operator>.indirectIndexAccess tfvoqrqhwnse[i][j]
<operator>.indirectIndexAccess tfvoqrqhwnse[i][j]
<operator>.indirectIndexAccess csgqifwplnxs[j]
<operator>.indirectIndexAccess qnfiqksctbab[i]
<operator>.indirectIndexAccess csgqifwplnxs[i]
<operator>.indirectIndexAccess tfvoqrqhwnse[i]
<operator>.indirectIndexAccess tfvoqrqhwnse[i]
<operator>.indirectIndexAccess tfvoqrqhwnse[i][j]
<operator>.indirectIndexAccess tfvoqrqhwnse[i]
<operator>.indirectIndexAccess tfvoqrqhwnse[i]
UNKNOWN double double
<operator>.indirectIndexAccess win[j]
<operator>.indirectIndexAccess tot[j]
>>>PDG&105 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->25 0->26 0->27 0->29 0->30 0->31 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->44 0->46 0->47 0->48 0->50 0->51 0->54 0->56 0->57 0->58 0->59 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->72 2->1 2->13 3->1 3->1 4->1 4->1 5->1 5->7 6->1 7->1 7->1 7->1 7->7 7->9 7->10 7->11 7->12 7->13 7->14 7->16 7->18 7->20 7->21 7->22 7->25 7->29 7->73 8->6 9->1 9->13 10->1 10->1 10->43 10->72 11->1 11->1 11->1 11->43 11->53 11->70 11->71 12->1 12->14 12->16 12->18 12->35 12->37 12->39 13->1 13->7 13->9 14->14 14->15 14->15 14->16 14->23 14->24 14->35 14->35 14->41 14->43 14->53 14->74 14->75 14->81 14->84 14->85 15->1 15->14 16->16 16->17 16->17 16->18 16->26 16->27 16->28 16->37 16->37 16->44 16->47 16->57 16->76 16->88 17->1 17->16 18->1 18->1 18->1 18->12 18->14 18->18 18->19 18->19 18->30 18->31 18->32 18->33 18->34 18->39 18->39 18->48 18->51 18->52 18->60 18->61 18->62 18->67 18->68 18->77 18->78 18->79 18->89 18->90 18->95 18->96 19->1 19->18 20->10 21->11 22->14 23->1 24->1 24->1 24->1 24->67 25->16 26->1 26->47 26->54 27->1 27->47 27->57 27->65 28->1 28->1 28->1 28->68 29->1 29->18 30->1 30->51 30->58 31->1 31->51 31->59 31->60 32->1 32->1 32->62 33->1 33->1 33->34 34->1 34->1 35->1 35->1 35->14 35->35 35->36 35->36 35->42 35->63 35->80 35->91 35->97 36->1 36->35 37->1 37->1 37->16 37->37 37->38 37->38 37->45 37->54 37->55 37->64 37->65 37->69 37->70 37->71 37->72 37->82 37->86 37->87 37->92 37->98 37->99 37->101 37->102 37->103 37->104 38->1 38->37 39->1 39->1 39->18 39->39 39->40 39->40 39->49 39->58 39->59 39->66 39->83 39->93 39->94 39->100 40->1 40->39 41->1 41->35 42->1 42->1 43->1 43->1 43->24 43->24 44->1 44->37 45->1 45->1 47->1 47->1 47->28 47->28 48->1 48->39 49->1 49->1 51->1 51->1 51->32 51->32 52->1 52->1 53->1 54->1 54->47 55->1 55->1 57->1 58->1 58->51 59->1 59->1 59->51 59->60 60->1 61->1 61->1 62->1 62->33 62->33 62->52 62->52 63->1 63->23 63->42 63->42 63->64 63->66 64->45 64->45 64->69 65->1 65->1 65->47 65->57 66->1 66->23 66->49 66->49 66->63 66->64 67->1 67->33 67->33 67->52 67->52 67->61 67->61 68->1 68->33 68->33 68->52 68->52 68->61 68->61 69->1 69->23 69->55 69->55 69->63 69->64 69->66 70->1 70->1 70->65 70->65 71->1 72->1 72->70 72->70
>>>Token int main ( ) { int lbsfzbdsbcyy , l = 0 ; freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; scanf ( " " , & lbsfzbdsbcyy ) ; while ( ++ l <= lbsfzbdsbcyy ) { printf ( " \n " , l ) ; int dtkclhgwwoaq , i , j , tot [ 102 ] = { 0 } , win [ 102 ] = { 0 } ; scanf ( " " , & dtkclhgwwoaq ) ; char tfvoqrqhwnse [ dtkclhgwwoaq + 1 ] [ dtkclhgwwoaq + 1 ] ; double qnfiqksctbab [ dtkclhgwwoaq + 1 ] ; for ( i = 0 ; i < dtkclhgwwoaq ; i ++ ) { scanf ( " " , tfvoqrqhwnse [ i ] ) ; for ( j = 0 ; j < dtkclhgwwoaq ; j ++ ) { npvsjfzauwpa ( tfvoqrqhwnse [ i ] [ j ] == ' ' ) continue ; else npvsjfzauwpa ( tfvoqrqhwnse [ i ] [ j ] = = ' ' ) { tot [ i ] ++ ; win [ i ] ++ ; } else npvsjfzauwpa ( tfvoqrqhwnse [ i ] [ j ] = = ' ' ) { tot [ i ] ++ ; } } qnfiqksctbab [ i ] = ( double ) win [ i ] / tot [ i ] ; } double csgqifwplnxs [ dtkclhgwwoaq + 1 ] ; for ( i = 0 ; i < dtkclhgwwoaq ; i ++ ) { int ktgirjrqbckh = 0 ; double detqvlbnebib = 0.0 ; for ( j = 0 ; j < dtkclhgwwoaq ; j ++ ) { npvsjfzauwpa ( tfvoqrqhwnse [ i ] [ j ] != ' ' )  { ktgirjrqbckh ++ ; npvsjfzauwpa ( tfvoqrqhwnse [ i ] [ j ] == ' ' )  { detqvlbnebib += ( double ) win [ j ] / ( tot [ j ] - 1 ) ; } else npvsjfzauwpa ( tfvoqrqhwnse [ i ] [ j ] = = ' ' ) { detqvlbnebib += ( double ) ( win [ j ] - 1 ) / ( tot [ j ] - 1 ) ; } } } csgqifwplnxs [ i ] = ( double ) detqvlbnebib / ktgirjrqbckh ; } double aqqxfuuigcbd [ dtkclhgwwoaq + 1 ] , rpi [ dtkclhgwwoaq + 1 ] ; for ( i = 0 ; i < dtkclhgwwoaq ; i ++ ) { int ktgirjrqbckh = 0 ; double detqvlbnebib = 0.0 ; for ( j = 0 ; j < dtkclhgwwoaq ; j ++ ) { npvsjfzauwpa ( tfvoqrqhwnse [ i ] [ j ] != ' ' )  { ktgirjrqbckh ++ ; detqvlbnebib += csgqifwplnxs [ j ] ; } } aqqxfuuigcbd [ i ] = ( double ) detqvlbnebib / ktgirjrqbckh ; rpi [ i ] = 0.25 * qnfiqksctbab [ i ] + 0.5 * csgqifwplnxs [ i ] + 0.25 * aqqxfuuigcbd [ i ] ; printf ( " \n " , rpi [ i ] ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM char *argv [ ]
PARAM int wcqcfdvxkxvl
<operator>.assignment *input_data=fopen("input.txt","r")
<operator>.assignment *buf=malloc(1000000)
<operator>.assignment kagndlhbcfgk=-1
<operator>.assignment buf[++kagndlhbcfgk]='\0'
fclose fclose(input_data)
<operator>.assignment *output_data=fopen("output.txt","w")
<operator>.assignment kagndlhbcfgk=0
<operator>.assignment fhutnfhosjjp=1
<operator>.assignment vncyhlvbcohq[8]={'vwmtivipjuxq' 'W' 'E' 'R' 'A' 'S' 'glxtyxapvhiy' 'F'}
fclose fclose(output_data)
RETURN return 0; return 0;
<operator>.logicalNot !feof(input_data)
<operator>.notEquals buf[kagndlhbcfgk]!='\n'
<operator>.preIncrement ++kagndlhbcfgk
<operator>.notEquals buf[kagndlhbcfgk]!=0
LITERAL 0 return 0;
fopen fopen("input.txt","r")
malloc malloc(1000000)
<operator>.minus -1
<operator>.assignment buf[++kagndlhbcfgk]=getc(input_data)
fopen fopen("output.txt","w")
<operator>.arrayInitializer {'vwmtivipjuxq' 'W' 'E' 'R' 'A' 'S' 'glxtyxapvhiy' 'F'}
<operator>.assignment llonpgsailps=0
<operator>.assignment mmclwjvodbrl=0
<operator>.assignment ipjwnrfdxkdz=0
memset memset(iyrtopazhyct,0,36 *3)
memset memset(glxtyxapvhiy,0,28 *2)
<operator>.assignment yvzkzmkblcbf=-1
<operator>.assignment odigpikoroob=kagndlhbcfgk
<operator>.assignment kagndlhbcfgk=odigpikoroob+1
<operator>.assignment yvzkzmkblcbf=-1
<operator>.assignment odigpikoroob=kagndlhbcfgk-1
<operator>.assignment kagndlhbcfgk=odigpikoroob+1
<operator>.assignment yvzkzmkblcbf=-1
<operator>.assignment odigpikoroob=kagndlhbcfgk-1
<operator>.assignment kagndlhbcfgk=odigpikoroob+1
memset memset(vwmtivipjuxq,0,101)
<operator>.assignment *N=vwmtivipjuxq
<operator>.assignment vdcpozicileo=0
<operator>.assignment dndgxiybwybr=ipjwnrfdxkdz
<operator>.assignment isnxiobliddy=0
rrfiyilddttv rrfiyilddttv(output_data,"Case #%i: [",fhutnfhosjjp)
<operator>.preIncrement ++fhutnfhosjjp
feof feof(input_data)
<operator>.preIncrement ++kagndlhbcfgk
<operator>.logicalAnd buf[++odigpikoroob]<0x3A&&buf[odigpikoroob]>0x2F
<operator>.greaterThan yvzkzmkblcbf>-1
<operator>.lessThan udwbtamcytdy<llonpgsailps
<operator>.preIncrement ++udwbtamcytdy
<operator>.logicalAnd buf[++odigpikoroob]<0x3A&&buf[odigpikoroob]>0x2F
<operator>.greaterThan yvzkzmkblcbf>-1
<operator>.lessThan udwbtamcytdy<mmclwjvodbrl
<operator>.preIncrement ++udwbtamcytdy
<operator>.logicalAnd buf[++odigpikoroob]<0x3A&&buf[odigpikoroob]>0x2F
<operator>.greaterThan yvzkzmkblcbf>-1
<operator>.lessThan udwbtamcytdy<ipjwnrfdxkdz
<operator>.preIncrement ++udwbtamcytdy
LITERAL 1 while (1)
<operator>.lessThan udwbtamcytdy<ipjwnrfdxkdz-1
<operator>.preIncrement ++udwbtamcytdy
<operator>.notEquals N[udwbtamcytdy]!=0
getc getc(input_data)
<operator>.multiplication 36 *3
<operator>.multiplication 28 *2
<operator>.minus -1
<operator>.assignment eorgjyaccuhh[++yvzkzmkblcbf]=buf[odigpikoroob]
<operator>.assignment eorgjyaccuhh[++yvzkzmkblcbf]='\0'
<operator>.assignment llonpgsailps=atoi(eorgjyaccuhh)
<operator>.addition odigpikoroob+1
<operator>.assignment udwbtamcytdy=0
memcpy memcpy(iyrtopazhyct[udwbtamcytdy],buf+kagndlhbcfgk,3)
<operator>.assignmentPlus kagndlhbcfgk+=4
<operator>.minus -1
<operator>.subtraction kagndlhbcfgk-1
<operator>.assignment eorgjyaccuhh[++yvzkzmkblcbf]=buf[odigpikoroob]
<operator>.assignment eorgjyaccuhh[++yvzkzmkblcbf]='\0'
<operator>.assignment mmclwjvodbrl=atoi(eorgjyaccuhh)
<operator>.addition odigpikoroob+1
<operator>.assignment udwbtamcytdy=0
memcpy memcpy(glxtyxapvhiy[udwbtamcytdy],buf+kagndlhbcfgk,2)
<operator>.assignmentPlus kagndlhbcfgk+=3
<operator>.minus -1
<operator>.subtraction kagndlhbcfgk-1
<operator>.assignment eorgjyaccuhh[++yvzkzmkblcbf]=buf[odigpikoroob]
<operator>.assignment eorgjyaccuhh[++yvzkzmkblcbf]='\0'
<operator>.assignment ipjwnrfdxkdz=atoi(eorgjyaccuhh)
<operator>.addition odigpikoroob+1
<operator>.assignment udwbtamcytdy=0
<operator>.assignment rleyoqpzambj=0
<operator>.assignment N[udwbtamcytdy]=buf[kagndlhbcfgk]
<operator>.preIncrement ++kagndlhbcfgk
<operator>.assignment isnxiobliddy=0
<operator>.preIncrement ++vdcpozicileo
<operator>.assignment udwbtamcytdy=0
rrfiyilddttv rrfiyilddttv(output_data,"%c]\n",N[udwbtamcytdy])
<operator>.preIncrement ++kagndlhbcfgk
<operator>.lessThan buf[++odigpikoroob]<0x3A
<operator>.greaterThan buf[odigpikoroob]>0x2F
<operator>.minus -1
IDENTIFIER elucqkvrskni <empty>
<operator>.lessThan buf[++odigpikoroob]<0x3A
<operator>.greaterThan buf[odigpikoroob]>0x2F
<operator>.minus -1
IDENTIFIER elucqkvrskni <empty>
<operator>.lessThan buf[++odigpikoroob]<0x3A
<operator>.greaterThan buf[odigpikoroob]>0x2F
<operator>.minus -1
IDENTIFIER elucqkvrskni <empty>
<operator>.lessThan vjkswmdqiyvf<8
<operator>.preIncrement ++vjkswmdqiyvf
<operator>.logicalNot !rleyoqpzambj
<operator>.lessThan vdcpozicileo<2
<operator>.logicalAnd vdcpozicileo>ipjwnrfdxkdz&&isnxiobliddy==0
<operator>.lessThan udwbtamcytdy<llonpgsailps
<operator>.preIncrement ++udwbtamcytdy
IDENTIFIER isnxiobliddy if (isnxiobliddy)
<operator>.lessThan udwbtamcytdy<vdcpozicileo
<operator>.preIncrement ++udwbtamcytdy
IDENTIFIER isnxiobliddy if (isnxiobliddy)
<operator>.subtraction ipjwnrfdxkdz-1
<operator>.notEquals N[udwbtamcytdy]!=0
rrfiyilddttv rrfiyilddttv (output_data,"]\n")
atoi atoi(eorgjyaccuhh)
<operator>.addition buf+kagndlhbcfgk
atoi atoi(eorgjyaccuhh)
<operator>.addition buf+kagndlhbcfgk
atoi atoi(eorgjyaccuhh)
<operator>.assignment vjkswmdqiyvf=0
<operator>.preDecrement --udwbtamcytdy
<operator>.preDecrement --ipjwnrfdxkdz
<operator>.preIncrement ++vdcpozicileo
<operator>.assignment isnxiobliddy=0
IDENTIFIER elucqkvrskni <empty>
<operator>.assignment udwbtamcytdy=0
<operator>.assignment udwbtamcytdy=0
rrfiyilddttv rrfiyilddttv(output_data,"%c, ",N[udwbtamcytdy])
<operator>.preIncrement ++odigpikoroob
<operator>.preIncrement ++yvzkzmkblcbf
<operator>.preIncrement ++yvzkzmkblcbf
<operator>.preIncrement ++odigpikoroob
<operator>.preIncrement ++yvzkzmkblcbf
<operator>.preIncrement ++yvzkzmkblcbf
<operator>.preIncrement ++odigpikoroob
<operator>.preIncrement ++yvzkzmkblcbf
<operator>.preIncrement ++yvzkzmkblcbf
<operator>.equals buf[kagndlhbcfgk]==vncyhlvbcohq[vjkswmdqiyvf]
<operator>.greaterThan vdcpozicileo>ipjwnrfdxkdz
<operator>.equals isnxiobliddy==0
<operator>.logicalOr (N[vdcpozicileo-1]==iyrtopazhyct[udwbtamcytdy][0]&&N[vdcpozicileo-2]==iyrtopazhyct[udwbtamcytdy][1])||(N[vdcpozicileo-1]==iyrtopazhyct[udwbtamcytdy][1]&&N[vdcpozicileo-2]==iyrtopazhyct[udwbtamcytdy][0])
<operator>.lessThan vjkswmdqiyvf<vdcpozicileo
<operator>.preIncrement ++vjkswmdqiyvf
IDENTIFIER isnxiobliddy if (isnxiobliddy)
<operator>.assignment rleyoqpzambj=1
IDENTIFIER elucqkvrskni <empty>
<operator>.assignment N[vdcpozicileo-2]=iyrtopazhyct[udwbtamcytdy][2]
<operator>.preDecrement --vdcpozicileo
<operator>.preDecrement --ipjwnrfdxkdz
<operator>.assignment isnxiobliddy=1
IDENTIFIER elucqkvrskni <empty>
<operator>.assignment vjkswmdqiyvf=0
IDENTIFIER elucqkvrskni <empty>
<operator>.logicalAnd N[vdcpozicileo-1]==iyrtopazhyct[udwbtamcytdy][0]&&N[vdcpozicileo-2]==iyrtopazhyct[udwbtamcytdy][1]
<operator>.logicalAnd N[vdcpozicileo-1]==iyrtopazhyct[udwbtamcytdy][1]&&N[vdcpozicileo-2]==iyrtopazhyct[udwbtamcytdy][0]
<operator>.lessThan vjkswmdqiyvf<ipjwnrfdxkdz
<operator>.preIncrement ++vjkswmdqiyvf
<operator>.equals udwbtamcytdy==vjkswmdqiyvf
<operator>.lessThan hdfqmrtslqvf<mmclwjvodbrl
<operator>.preIncrement ++hdfqmrtslqvf
IDENTIFIER isnxiobliddy if (isnxiobliddy)
<operator>.equals N[vdcpozicileo-1]==iyrtopazhyct[udwbtamcytdy][0]
<operator>.equals N[vdcpozicileo-2]==iyrtopazhyct[udwbtamcytdy][1]
<operator>.equals N[vdcpozicileo-1]==iyrtopazhyct[udwbtamcytdy][1]
<operator>.equals N[vdcpozicileo-2]==iyrtopazhyct[udwbtamcytdy][0]
<operator>.assignment vjkswmdqiyvf=vdcpozicileo-1
<operator>.assignment N[vjkswmdqiyvf]=N[vjkswmdqiyvf+1]
<operator>.assignment hdfqmrtslqvf=0
IDENTIFIER elucqkvrskni <empty>
<operator>.subtraction vdcpozicileo-2
<operator>.logicalOr (N[udwbtamcytdy]==glxtyxapvhiy[hdfqmrtslqvf][0]&&N[vjkswmdqiyvf]==glxtyxapvhiy[hdfqmrtslqvf][1])||(N[udwbtamcytdy]==glxtyxapvhiy[hdfqmrtslqvf][1]&&N[vjkswmdqiyvf]==glxtyxapvhiy[hdfqmrtslqvf][0])
<operator>.subtraction vdcpozicileo-1
<operator>.subtraction vdcpozicileo-2
<operator>.subtraction vdcpozicileo-1
<operator>.subtraction vdcpozicileo-2
<operator>.subtraction vdcpozicileo-1
<operator>.assignment isnxiobliddy=1
IDENTIFIER elucqkvrskni <empty>
<operator>.addition vjkswmdqiyvf+1
<operator>.logicalAnd N[udwbtamcytdy]==glxtyxapvhiy[hdfqmrtslqvf][0]&&N[vjkswmdqiyvf]==glxtyxapvhiy[hdfqmrtslqvf][1]
<operator>.logicalAnd N[udwbtamcytdy]==glxtyxapvhiy[hdfqmrtslqvf][1]&&N[vjkswmdqiyvf]==glxtyxapvhiy[hdfqmrtslqvf][0]
<operator>.lessThan tcenqjjisdku<vdcpozicileo
<operator>.preIncrement ++tcenqjjisdku
<operator>.assignment N[tcenqjjisdku]=0
<operator>.equals N[udwbtamcytdy]==glxtyxapvhiy[hdfqmrtslqvf][0]
<operator>.equals N[vjkswmdqiyvf]==glxtyxapvhiy[hdfqmrtslqvf][1]
<operator>.equals N[udwbtamcytdy]==glxtyxapvhiy[hdfqmrtslqvf][1]
<operator>.equals N[vjkswmdqiyvf]==glxtyxapvhiy[hdfqmrtslqvf][0]
<operator>.assignment tcenqjjisdku=0
<operator>.indirectIndexAccess buf[kagndlhbcfgk]
<operator>.indirectIndexAccess buf[kagndlhbcfgk]
<operator>.indirectIndexAccess buf[++kagndlhbcfgk]
<operator>.indirectIndexAccess N[udwbtamcytdy]
<operator>.indirectIndexAccess buf[++odigpikoroob]
<operator>.indirectIndexAccess buf[odigpikoroob]
<operator>.indirectIndexAccess eorgjyaccuhh[++yvzkzmkblcbf]
<operator>.indirectIndexAccess buf[odigpikoroob]
<operator>.indirectIndexAccess eorgjyaccuhh[++yvzkzmkblcbf]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy]
<operator>.indirectIndexAccess buf[++odigpikoroob]
<operator>.indirectIndexAccess buf[odigpikoroob]
<operator>.indirectIndexAccess eorgjyaccuhh[++yvzkzmkblcbf]
<operator>.indirectIndexAccess buf[odigpikoroob]
<operator>.indirectIndexAccess eorgjyaccuhh[++yvzkzmkblcbf]
<operator>.indirectIndexAccess glxtyxapvhiy[udwbtamcytdy]
<operator>.indirectIndexAccess buf[++odigpikoroob]
<operator>.indirectIndexAccess buf[odigpikoroob]
<operator>.indirectIndexAccess eorgjyaccuhh[++yvzkzmkblcbf]
<operator>.indirectIndexAccess buf[odigpikoroob]
<operator>.indirectIndexAccess eorgjyaccuhh[++yvzkzmkblcbf]
<operator>.indirectIndexAccess N[udwbtamcytdy]
<operator>.indirectIndexAccess buf[kagndlhbcfgk]
<operator>.indirectIndexAccess N[udwbtamcytdy]
<operator>.indirectIndexAccess N[udwbtamcytdy]
<operator>.indirectIndexAccess N[udwbtamcytdy]
<operator>.indirectIndexAccess buf[kagndlhbcfgk]
<operator>.indirectIndexAccess vncyhlvbcohq[vjkswmdqiyvf]
<operator>.indirectIndexAccess N[vdcpozicileo-2]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy][2]
<operator>.indirectIndexAccess N[vdcpozicileo-1]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy][0]
<operator>.indirectIndexAccess N[vdcpozicileo-2]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy][1]
<operator>.indirectIndexAccess N[vdcpozicileo-1]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy][1]
<operator>.indirectIndexAccess N[vdcpozicileo-2]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy][0]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy]
<operator>.indirectIndexAccess iyrtopazhyct[udwbtamcytdy]
<operator>.indirectIndexAccess N[vjkswmdqiyvf]
<operator>.indirectIndexAccess N[vjkswmdqiyvf+1]
<operator>.indirectIndexAccess N[udwbtamcytdy]
<operator>.indirectIndexAccess glxtyxapvhiy[hdfqmrtslqvf][0]
<operator>.indirectIndexAccess N[vjkswmdqiyvf]
<operator>.indirectIndexAccess glxtyxapvhiy[hdfqmrtslqvf][1]
<operator>.indirectIndexAccess N[udwbtamcytdy]
<operator>.indirectIndexAccess glxtyxapvhiy[hdfqmrtslqvf][1]
<operator>.indirectIndexAccess N[vjkswmdqiyvf]
<operator>.indirectIndexAccess glxtyxapvhiy[hdfqmrtslqvf][0]
<operator>.indirectIndexAccess N[tcenqjjisdku]
<operator>.indirectIndexAccess glxtyxapvhiy[hdfqmrtslqvf]
<operator>.indirectIndexAccess glxtyxapvhiy[hdfqmrtslqvf]
<operator>.indirectIndexAccess glxtyxapvhiy[hdfqmrtslqvf]
<operator>.indirectIndexAccess glxtyxapvhiy[hdfqmrtslqvf]
>>>PDG&259 0->2 0->3 0->7 0->8 0->10 0->11 0->13 0->14 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->36 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->54 0->55 0->56 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->70 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->90 0->91 0->92 0->93 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->108 0->109 0->110 0->111 0->112 0->113 0->114 0->115 0->117 0->118 0->119 0->120 0->121 0->122 0->123 0->124 0->125 0->126 0->127 0->128 0->129 0->130 0->131 0->132 0->133 0->134 0->135 0->136 0->137 0->138 0->139 0->140 0->141 0->142 0->143 0->144 0->145 0->146 0->147 0->148 0->149 0->150 0->151 0->153 0->154 0->155 0->156 0->157 0->159 0->160 0->161 0->162 0->163 0->164 0->167 0->168 0->169 0->170 0->171 0->172 0->179 0->180 0->181 0->183 0->184 0->185 0->186 0->187 0->188 0->189 0->190 0->193 0->194 0->195 0->200 2->1 3->1 4->1 4->1 4->47 5->1 5->1 5->1 5->16 5->18 5->69 5->74 5->78 5->83 5->87 5->93 5->100 5->101 5->104 5->105 5->108 5->109 5->127 5->129 5->149 6->1 6->1 6->48 6->99 7->1 7->1 7->18 7->74 7->78 7->83 7->87 7->93 7->100 7->101 7->104 7->105 7->108 7->109 7->127 7->129 7->149 8->1 8->1 9->1 9->1 9->13 9->45 10->1 10->1 10->17 10->32 11->1 11->1 11->45 12->1 12->1 12->1 12->149 13->1 13->1 14->1 15->1 15->1 15->15 15->23 15->47 15->65 15->99 15->203 16->1 16->16 16->17 16->18 16->201 17->1 17->1 17->32 18->1 18->1 18->18 18->26 18->27 18->28 18->29 18->30 18->31 18->32 18->33 18->34 18->35 18->36 18->37 18->38 18->39 18->40 18->41 18->42 18->43 18->44 18->45 18->46 18->49 18->50 18->51 18->53 18->54 18->55 18->57 18->58 18->59 18->62 18->64 18->66 18->67 18->68 18->72 18->73 18->74 18->76 18->77 18->78 18->81 18->82 18->83 18->85 18->86 18->87 18->90 18->91 18->93 18->97 18->100 18->100 18->101 18->102 18->104 18->104 18->105 18->106 18->108 18->108 18->109 18->110 18->115 18->123 18->127 18->129 18->140 18->143 18->146 18->149 18->202 18->204 18->205 18->211 18->217 19->14 20->4 20->4 21->5 22->6 23->1 24->9 24->9 25->12 25->12 25->12 25->12 25->12 25->12 25->12 25->12 26->1 26->51 27->1 27->55 28->1 28->59 29->1 29->1 29->1 29->74 30->1 30->1 30->1 30->83 31->50 31->141 32->1 32->140 33->74 33->75 33->77 33->127 34->54 34->144 35->143 36->83 36->84 36->86 36->129 37->1 37->58 37->147 38->1 38->1 38->146 39->1 39->1 39->1 39->32 39->94 40->1 40->41 41->1 41->1 41->1 41->64 41->98 41->124 41->139 41->173 41->174 41->175 41->176 41->178 41->196 41->197 41->198 41->199 42->1 42->1 42->115 43->1 43->1 44->1 44->1 44->151 45->1 45->46 45->98 45->125 45->139 46->1 46->1 46->45 47->8 47->15 47->65 49->49 49->53 49->69 49->100 49->140 49->141 49->205 49->207 49->208 50->70 50->71 50->126 50->142 50->142 50->209 51->1 51->1 51->51 51->52 51->52 51->74 51->75 51->117 51->127 51->210 52->1 52->51 53->53 53->57 53->78 53->104 53->143 53->144 53->211 53->213 53->214 54->79 54->80 54->128 54->145 54->145 54->215 55->1 55->1 55->55 55->56 55->56 55->83 55->84 55->129 55->170 55->216 56->1 56->55 57->1 57->1 57->1 57->49 57->57 57->87 57->108 57->146 57->147 57->217 57->219 57->220 58->1 58->1 58->1 58->88 58->89 58->130 58->148 58->148 58->221 59->1 59->43 59->59 59->60 59->60 59->92 59->112 59->114 59->123 59->131 59->132 59->133 59->150 60->1 60->59 62->1 62->1 62->1 62->62 62->63 62->63 62->123 62->124 62->225 63->1 63->62 64->1 64->1 64->98 64->98 64->124 64->125 64->196 64->224 65->23 65->47 66->29 66->29 67->30 67->30 68->31 69->1 69->1 69->1 70->1 70->1 70->126 71->1 71->1 71->51 73->51 74->1 74->1 74->1 74->29 75->1 75->74 75->77 75->127 76->34 77->35 77->35 78->1 78->1 78->1 79->1 79->1 79->128 80->1 80->1 80->55 82->55 83->1 83->1 83->1 83->30 84->1 84->83 84->86 84->129 85->37 86->38 86->38 87->1 87->1 87->1 88->1 88->1 88->130 89->1 89->1 89->59 90->1 91->59 92->1 92->114 93->1 93->64 93->124 93->196 94->1 94->1 94->32 95->1 95->1 95->151 96->1 96->1 96->115 97->1 97->62 98->1 98->1 98->13 98->45 98->64 98->124 98->196 99->48 100->18 100->49 100->49 100->74 100->78 100->83 100->87 100->93 100->101 100->101 100->104 100->105 100->108 100->109 100->127 100->129 100->149 100->206 101->1 101->18 101->49 101->49 101->69 101->74 101->78 101->83 101->87 101->93 101->100 101->104 101->105 101->108 101->109 101->127 101->129 101->149 102->50 104->18 104->53 104->53 104->83 104->93 104->100 104->101 104->105 104->105 104->108 104->109 104->129 104->149 104->212 105->1 105->18 105->53 105->53 105->69 105->74 105->78 105->83 105->87 105->93 105->100 105->101 105->104 105->108 105->109 105->127 105->129 105->149 106->54 108->1 108->57 108->57 108->100 108->109 108->218 109->1 109->18 109->57 109->57 109->69 109->74 109->78 109->83 109->87 109->93 109->100 109->101 109->104 109->105 109->108 109->127 109->129 109->149 110->58 112->1 112->1 112->112 112->113 112->113 112->149 112->227 112->228 113->1 113->112 114->1 114->1 114->93 114->94 114->132 114->133 114->222 114->223 115->1 115->95 115->96 115->116 115->117 115->120 115->134 115->134 115->135 115->137 115->138 115->150 115->150 116->1 116->1 116->1 117->1 117->1 117->117 117->118 117->118 117->152 117->165 117->173 117->183 117->231 117->232 117->240 118->1 118->117 120->1 120->1 120->96 120->115 120->120 120->121 120->121 120->153 120->153 120->163 120->169 121->1 121->120 123->1 123->62 123->62 124->64 124->139 124->139 124->226 125->1 125->13 125->45 126->1 126->71 126->128 126->130 127->1 128->1 128->80 128->126 128->130 129->1 130->1 130->89 130->126 130->128 131->1 131->112 132->1 132->60 133->1 133->59 134->1 134->1 134->115 135->1 135->1 135->151 137->117 138->120 139->1 139->64 139->98 139->124 139->125 140->33 140->72 141->50 143->36 143->81 144->54 146->39 146->90 147->58 148->1 149->1 149->1 149->18 149->93 149->156 150->1 150->115 150->116 150->116 150->120 150->123 150->151 150->167 150->183 151->116 151->116 152->1 152->1 152->1 152->158 152->159 152->160 152->161 152->167 152->177 152->181 152->187 152->229 152->230 152->239 153->1 153->1 153->120 153->153 153->154 153->169 153->169 153->193 154->1 154->153 156->1 156->114 158->1 158->1 158->1 158->174 158->176 159->1 159->1 159->115 159->120 159->183 160->1 160->123 160->150 160->167 161->1 161->1 161->151 163->1 163->153 165->1 165->1 165->152 165->152 165->166 165->175 165->185 165->235 165->236 165->242 166->1 166->1 166->152 166->152 167->1 167->1 167->160 167->167 167->168 167->168 167->178 167->190 167->190 167->244 167->245 168->1 168->167 169->1 169->121 169->154 169->170 169->179 170->1 170->1 170->1 170->170 170->171 170->171 170->182 170->191 170->196 170->246 170->247 170->255 171->1 171->170 173->1 173->1 173->74 173->165 173->165 173->174 173->175 173->176 173->184 173->233 173->234 173->241 174->1 174->1 174->74 174->165 174->165 174->175 174->176 175->1 175->1 175->74 175->166 175->166 175->173 175->174 175->176 175->186 175->237 175->238 175->243 176->1 176->1 176->74 176->166 176->166 176->173 176->174 177->1 177->1 177->167 178->1 178->1 178->1 178->197 178->199 179->1 179->170 181->187 182->1 182->1 182->1 182->188 182->193 182->200 183->1 183->115 183->120 183->181 183->184 183->185 184->1 184->115 184->120 184->181 184->183 184->185 185->1 185->115 185->120 185->181 185->183 185->186 186->1 186->115 186->120 186->181 186->183 187->159 187->177 187->177 188->1 188->1 188->151 191->1 191->1 191->182 191->182 191->192 191->198 191->250 191->251 191->257 192->1 192->1 192->182 192->182 193->1 193->1 193->153 193->193 193->194 193->194 193->195 193->254 194->1 194->193 195->1 195->1 196->1 196->64 196->124 196->191 196->191 196->197 196->198 196->199 196->248 196->249 196->256 197->1 197->1 197->191 197->191 197->198 197->199 198->1 198->64 198->124 198->192 198->192 198->196 198->197 198->199 198->252 198->253 198->258 199->1 199->1 199->192 199->192 199->196 199->197 200->1 200->193
>>>Token int main ( char * argv [ ] , int wcqcfdvxkxvl ) { FILE * input_data = fopen ( " " , " " ) ; char * buf = malloc ( 1000000 ) ; int kagndlhbcfgk = -1 ; while ( ! feof ( input_data ) ) { buf [ ++ kagndlhbcfgk ] = getc ( input_data ) ; } buf [ ++ kagndlhbcfgk ] = ' \0 ' ; fclose ( input_data ) ; FILE * output_data = fopen ( " " , " " ) ; kagndlhbcfgk = 0 ; while ( buf [ kagndlhbcfgk ] != ' \n ' ) ++ kagndlhbcfgk ; int fhutnfhosjjp = 1 ; char iyrtopazhyct [ 36 ] [ 3 ] ; char glxtyxapvhiy [ 28 ] [ 2 ] ; char vncyhlvbcohq [ 8 ] = { ' wmtivipjuxq ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' lxtyxapvhiy ' , ' ' } ; while ( buf [ kagndlhbcfgk ] != 0 ) { int llonpgsailps = 0 ; int mmclwjvodbrl = 0 ; int ipjwnrfdxkdz = 0 ; memset ( iyrtopazhyct , 0 , 36 * 3 ) ; memset ( glxtyxapvhiy , 0 , 28 * 2 ) ; char eorgjyaccuhh [ 10 ] ; int yvzkzmkblcbf = -1 ; int odigpikoroob = kagndlhbcfgk ; while ( buf [ ++ odigpikoroob ] < 0x3A && buf [ odigpikoroob ] > 0x2F ) { eorgjyaccuhh [ ++ yvzkzmkblcbf ] = buf [ odigpikoroob ] ; } if ( yvzkzmkblcbf > -1 ) { eorgjyaccuhh [ ++ yvzkzmkblcbf ] = ' \0 ' ; llonpgsailps = atoi ( eorgjyaccuhh ) ; } else elucqkvrskni ; kagndlhbcfgk = odigpikoroob + 1 ; int udwbtamcytdy ; for ( udwbtamcytdy = 0 ; udwbtamcytdy < llonpgsailps ; ++ udwbtamcytdy ) { memcpy ( iyrtopazhyct [ udwbtamcytdy ] , buf + kagndlhbcfgk , 3 ) ; kagndlhbcfgk += 4 ; } yvzkzmkblcbf = -1 ; odigpikoroob = kagndlhbcfgk - 1 ; while ( buf [ ++ odigpikoroob ] < 0x3A && buf [ odigpikoroob ] > 0x2F ) { eorgjyaccuhh [ ++ yvzkzmkblcbf ] = buf [ odigpikoroob ] ; } if ( yvzkzmkblcbf > -1 ) { eorgjyaccuhh [ ++ yvzkzmkblcbf ] = ' \0 ' ; mmclwjvodbrl = atoi ( eorgjyaccuhh ) ; } else elucqkvrskni ; kagndlhbcfgk = odigpikoroob + 1 ; for ( udwbtamcytdy = 0 ; udwbtamcytdy < mmclwjvodbrl ; ++ udwbtamcytdy ) { memcpy ( glxtyxapvhiy [ udwbtamcytdy ] , buf + kagndlhbcfgk , 2 ) ; kagndlhbcfgk += 3 ; } yvzkzmkblcbf = -1 ; odigpikoroob = kagndlhbcfgk - 1 ; while ( buf [ ++ odigpikoroob ] < 0x3A && buf [ odigpikoroob ] > 0x2F ) { eorgjyaccuhh [ ++ yvzkzmkblcbf ] = buf [ odigpikoroob ] ; } if ( yvzkzmkblcbf > -1 ) { eorgjyaccuhh [ ++ yvzkzmkblcbf ] = ' \0 ' ; ipjwnrfdxkdz = atoi ( eorgjyaccuhh ) ; } else elucqkvrskni ; kagndlhbcfgk = odigpikoroob + 1 ; char vwmtivipjuxq [ 101 ] ; memset ( vwmtivipjuxq , 0 , 101 ) ; char * N = vwmtivipjuxq ; for ( udwbtamcytdy = 0 ; udwbtamcytdy < ipjwnrfdxkdz ; ++ udwbtamcytdy ) { int vjkswmdqiyvf ; int rleyoqpzambj = 0 ; for ( vjkswmdqiyvf = 0 ; vjkswmdqiyvf < 8 ; ++ vjkswmdqiyvf ) { if ( buf [ kagndlhbcfgk ] == vncyhlvbcohq [ vjkswmdqiyvf ] ) { rleyoqpzambj = 1 ; elucqkvrskni ; } } if ( ! rleyoqpzambj ) { -- udwbtamcytdy ; -- ipjwnrfdxkdz ; continue ; } N [ udwbtamcytdy ] = buf [ kagndlhbcfgk ] ; ++ kagndlhbcfgk ; } int vdcpozicileo = 0 ; int dndgxiybwybr = ipjwnrfdxkdz ; int isnxiobliddy = 0 ; while ( 1 ) { if ( vdcpozicileo < 2 ) { ++ vdcpozicileo ; isnxiobliddy = 0 ; continue ; } if ( vdcpozicileo > ipjwnrfdxkdz && isnxiobliddy == 0 ) elucqkvrskni ; isnxiobliddy = 0 ; for ( udwbtamcytdy = 0 ; udwbtamcytdy < llonpgsailps ; ++ udwbtamcytdy ) { if ( ( N [ vdcpozicileo - 1 ] == iyrtopazhyct [ udwbtamcytdy ] [ 0 ] && N [ vdcpozicileo - 2 ] == iyrtopazhyct [ udwbtamcytdy ] [ 1 ] ) || ( N [ vdcpozicileo - 1 ] == iyrtopazhyct [ udwbtamcytdy ] [ 1 ] && N [ vdcpozicileo - 2 ] == iyrtopazhyct [ udwbtamcytdy ] [ 0 ] ) ) { N [ vdcpozicileo - 2 ] = iyrtopazhyct [ udwbtamcytdy ] [ 2 ] ; int vjkswmdqiyvf ; for ( vjkswmdqiyvf = vdcpozicileo - 1 ; vjkswmdqiyvf < ipjwnrfdxkdz ; ++ vjkswmdqiyvf ) { N [ vjkswmdqiyvf ] = N [ vjkswmdqiyvf + 1 ] ; } -- vdcpozicileo ; -- ipjwnrfdxkdz ; isnxiobliddy = 1 ; elucqkvrskni ; } } if ( isnxiobliddy ) continue ; for ( udwbtamcytdy = 0 ; udwbtamcytdy < vdcpozicileo ; ++ udwbtamcytdy ) { int vjkswmdqiyvf ; for ( vjkswmdqiyvf = 0 ; vjkswmdqiyvf < vdcpozicileo ; ++ vjkswmdqiyvf ) { if ( udwbtamcytdy == vjkswmdqiyvf ) continue ; int hdfqmrtslqvf ; for ( hdfqmrtslqvf = 0 ; hdfqmrtslqvf < mmclwjvodbrl ; ++ hdfqmrtslqvf ) { if ( ( N [ udwbtamcytdy ] == glxtyxapvhiy [ hdfqmrtslqvf ] [ 0 ] && N [ vjkswmdqiyvf ] == glxtyxapvhiy [ hdfqmrtslqvf ] [ 1 ] ) || ( N [ udwbtamcytdy ] == glxtyxapvhiy [ hdfqmrtslqvf ] [ 1 ] && N [ vjkswmdqiyvf ] == glxtyxapvhiy [ hdfqmrtslqvf ] [ 0 ] ) ) { int tcenqjjisdku ; for ( tcenqjjisdku = 0 ; tcenqjjisdku < vdcpozicileo ; ++ tcenqjjisdku ) N [ tcenqjjisdku ] = 0 ; isnxiobliddy = 1 ; elucqkvrskni ; } } if ( isnxiobliddy ) elucqkvrskni ; } if ( isnxiobliddy ) elucqkvrskni ; } if ( isnxiobliddy ) continue ; ++ vdcpozicileo ; } rrfiyilddttv ( output_data , " " , fhutnfhosjjp ) ; for ( udwbtamcytdy = 0 ; udwbtamcytdy < ipjwnrfdxkdz - 1 ; ++ udwbtamcytdy ) { if ( N [ udwbtamcytdy ] != 0 ) rrfiyilddttv ( output_data , " " , N [ udwbtamcytdy ] ) ; } if ( N [ udwbtamcytdy ] != 0 ) rrfiyilddttv ( output_data , " \n " , N [ udwbtamcytdy ] ) ; else rrfiyilddttv ( output_data , " \n " ) ; ++ fhutnfhosjjp ; } fclose ( output_data ) ; return 0 ; }
>>>Func
METHOD fesiyiyhjalx
METHOD_RETURN void
<operator>.greaterEqualsThan l>=1
<operator>.lessThan jzgdbdrtvjvg<d
<operator>.preIncrement ++jzgdbdrtvjvg
<operator>.assignment jzgdbdrtvjvg=0
<operator>.assignment bupeyvjagjgd=0
<operator>.equals sir[l]==md[jzgdbdrtvjvg][1]
<operator>.equals sir[l]==md[jzgdbdrtvjvg][0]
IDENTIFIER bupeyvjagjgd if (bupeyvjagjgd)
<operator>.assignment bupeyvjagjgd=md[jzgdbdrtvjvg][0]
<operator>.assignment bupeyvjagjgd=md[jzgdbdrtvjvg][1]
<operator>.lessThan i<l
<operator>.preIncrement ++i
<operator>.assignment i=0
<operator>.equals sir[i]==bupeyvjagjgd
<operator>.assignment l=-1
<operator>.minus -1
<operator>.indirectIndexAccess sir[l]
<operator>.indirectIndexAccess md[jzgdbdrtvjvg][1]
<operator>.indirectIndexAccess sir[l]
<operator>.indirectIndexAccess md[jzgdbdrtvjvg][0]
<operator>.indirectIndexAccess md[jzgdbdrtvjvg]
<operator>.indirectIndexAccess md[jzgdbdrtvjvg][0]
<operator>.indirectIndexAccess md[jzgdbdrtvjvg]
<operator>.indirectIndexAccess md[jzgdbdrtvjvg][1]
<operator>.indirectIndexAccess md[jzgdbdrtvjvg]
<operator>.indirectIndexAccess md[jzgdbdrtvjvg]
<operator>.indirectIndexAccess sir[i]
>>>PDG&29 0->2 0->3 0->4 0->5 0->6 0->9 0->12 0->13 0->14 0->15 0->17 2->1 2->1 2->3 2->5 2->12 3->1 3->1 3->1 3->3 3->4 3->4 3->6 3->7 3->8 3->12 3->14 3->18 3->19 3->20 3->21 3->22 3->24 4->1 4->3 5->1 5->3 6->1 6->1 6->15 7->1 7->1 7->8 7->10 7->11 7->23 7->26 8->1 8->1 8->1 8->7 8->10 8->11 8->25 8->27 10->1 10->1 10->15 11->1 11->1 11->1 11->15 12->1 12->1 12->1 12->13 12->15 12->28 13->1 13->12 14->1 14->12 15->1 15->1 15->1 15->12 15->13 15->16 15->17 16->1 16->1 16->1 16->12 17->16
>>>Token void fesiyiyhjalx ( ) { int jzgdbdrtvjvg , i ; if ( l >= 1 ) { for ( jzgdbdrtvjvg = 0 ; jzgdbdrtvjvg < d ; ++ jzgdbdrtvjvg ) { char bupeyvjagjgd = 0 ; if ( sir [ l ] == md [ jzgdbdrtvjvg ] [ 1 ] ) { bupeyvjagjgd = md [ jzgdbdrtvjvg ] [ 0 ] ; } if ( sir [ l ] == md [ jzgdbdrtvjvg ] [ 0 ] ) { bupeyvjagjgd = md [ jzgdbdrtvjvg ] [ 1 ] ; } if ( bupeyvjagjgd ) { for ( i = 0 ; i < l ; ++ i ) { if ( sir [ i ] == bupeyvjagjgd ) { l = -1 ; break ; } } } } } }
>>>Func
METHOD kfkidaainsld
METHOD_RETURN int
PARAM int *distance
PARAM int iezoxkbjzhlc
PARAM int yfajpezsdgss
PARAM int kznzqugtzzio
<operator>.assignment syadigpttiva=0
<operator>.assignment yrwjwsrfjlms=0
RETURN return syadigpttiva<yrwjwsrfjlms?syadigpttiva:yrwjwsrfjlms; return syadigpttiva<yrwjwsrfjlms?syadigpttiva:yrwjwsrfjlms;
<operator>.greaterThan yfajpezsdgss>kznzqugtzzio
<operator>.lessThan vigzdhiwctzq<iezoxkbjzhlc
<operator>.preIncrement ++vigzdhiwctzq
<operator>.conditional syadigpttiva<yrwjwsrfjlms?syadigpttiva:yrwjwsrfjlms
<operator>.assignment kjnqcbkeyyxv=yfajpezsdgss
<operator>.assignment yfajpezsdgss=kznzqugtzzio
<operator>.assignment kznzqugtzzio=kjnqcbkeyyxv
<operator>.assignment vigzdhiwctzq=0
<operator>.logicalAnd vigzdhiwctzq>=yfajpezsdgss&&vigzdhiwctzq<kznzqugtzzio
<operator>.lessThan syadigpttiva<yrwjwsrfjlms
<operator>.assignmentPlus syadigpttiva+=distance[vigzdhiwctzq]
<operator>.greaterEqualsThan vigzdhiwctzq>=yfajpezsdgss
<operator>.lessThan vigzdhiwctzq<kznzqugtzzio
<operator>.assignmentPlus yrwjwsrfjlms +=distance[vigzdhiwctzq]
<operator>.indirectIndexAccess distance[vigzdhiwctzq]
<operator>.indirectIndexAccess distance[vigzdhiwctzq]
>>>PDG&25 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->20 0->21 0->22 2->1 2->19 2->22 3->10 4->9 5->9 6->1 6->18 6->19 7->1 7->18 7->22 8->1 9->1 9->1 9->1 9->13 9->13 9->14 9->14 9->15 9->20 9->21 10->1 10->1 10->1 10->10 10->11 10->17 10->20 10->20 11->1 11->10 12->1 12->1 12->1 12->1 12->8 13->1 13->15 14->1 14->1 14->20 15->1 15->1 15->1 15->21 16->1 16->10 17->1 17->1 17->1 17->19 17->22 17->23 17->24 18->12 18->12 19->1 19->1 19->18 20->1 20->11 20->17 20->17 20->21 20->21 21->1 21->11 21->17 21->17 22->1 22->1 22->18
>>>Token int kfkidaainsld ( int * distance , int iezoxkbjzhlc , int yfajpezsdgss , int kznzqugtzzio ) { int syadigpttiva = 0 , yrwjwsrfjlms = 0 ; if ( yfajpezsdgss > kznzqugtzzio ) { int kjnqcbkeyyxv = yfajpezsdgss ; yfajpezsdgss = kznzqugtzzio ; kznzqugtzzio = kjnqcbkeyyxv ; } for ( auto vigzdhiwctzq  = 0 ; vigzdhiwctzq < iezoxkbjzhlc ; ++ vigzdhiwctzq ) { if ( vigzdhiwctzq >= yfajpezsdgss && vigzdhiwctzq < kznzqugtzzio ) syadigpttiva += distance [ vigzdhiwctzq ] ; else yrwjwsrfjlms += distance [ vigzdhiwctzq ] ; } return syadigpttiva < yrwjwsrfjlms ? syadigpttiva : yrwjwsrfjlms ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int ixpeggjlgorv
PARAM char *argv [ ]
<operator>.assignment xmklenzxlwlg=0
printf printf("Sum is: %d\n",xmklenzxlwlg)
RETURN return 0; return 0;
<operator>.lessThan ggljzaqxzuwl<argv[1][0]
<operator>.postIncrement ggljzaqxzuwl++
LITERAL 0 return 0;
<operator>.assignment ggljzaqxzuwl=0
<operator>.lessThan j<argv[1][0]
<operator>.postIncrement j++
<operator>.assignment j=0
<operator>.assignmentPlus xmklenzxlwlg+=j
<operator>.indirectIndexAccess argv[1][0]
<operator>.indirectIndexAccess argv[1]
<operator>.indirectIndexAccess argv[1][0]
<operator>.indirectIndexAccess argv[1]
>>>PDG&19 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 4->1 4->5 4->14 5->1 5->1 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->11 7->11 7->13 7->15 7->16 7->17 7->18 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->7 11->11 11->12 11->12 11->14 11->14 11->17 11->18 12->1 12->11 13->1 13->11 14->1 14->5
>>>Token int main ( int ixpeggjlgorv , char * argv [ ] ) { int ggljzaqxzuwl , j ; int xmklenzxlwlg = 0 ; for ( ggljzaqxzuwl = 0 ; ggljzaqxzuwl < argv [ 1 ] [ 0 ] ; ggljzaqxzuwl ++ ) { for ( j = 0 ; j < argv [ 1 ] [ 0 ] ; j ++ ) { xmklenzxlwlg += j ; } } printf ( " \n " , xmklenzxlwlg ) ; return 0 ; }
>>>Func
METHOD vkcgsnyefwuf
METHOD_RETURN void
PARAM int xvsyctbjsmyr
PARAM TypeDataSet ptkwatiksqjm [ ]
<operator>.assignment *fd=fopen("datasetCopy.txt","w")
fprintf fprintf(fd,"%d",xvsyctbjsmyr)
fclose fclose(fd)
<operator>.lessThan wzvnmzaowull<xvsyctbjsmyr
<operator>.postIncrement wzvnmzaowull++
writeDataSet writeDataSet(fd,&ptkwatiksqjm[wzvnmzaowull])
fopen fopen("datasetCopy.txt","w")
<operator>.assignment wzvnmzaowull=0
<operator>.addressOf &ptkwatiksqjm[wzvnmzaowull]
<operator>.indirectIndexAccess ptkwatiksqjm[wzvnmzaowull]
>>>PDG&14 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->5 3->1 3->9 4->1 4->1 4->5 5->1 5->6 5->7 5->9 6->1 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->9 7->12 7->13 8->1 8->7 9->1 9->1 9->6 10->4 10->4 11->1 11->7
>>>Token void vkcgsnyefwuf ( int xvsyctbjsmyr , TypeDataSet ptkwatiksqjm [ ] ) { int wzvnmzaowull ; FILE * fd = fopen ( " " , " " ) ; fprintf ( fd , " " , xvsyctbjsmyr ) ; for ( wzvnmzaowull = 0 ; wzvnmzaowull < xvsyctbjsmyr ; wzvnmzaowull ++ ) writeDataSet ( fd , & ptkwatiksqjm [ wzvnmzaowull ] ) ; fclose ( fd ) ; }
>>>Func
METHOD my_realloc
METHOD_RETURN char*
PARAM char *str
PARAM int *inc
<operator>.assignment topeomfjeawd=0
<operator>.assignment topeomfjeawd=0
free free(str)
RETURN return  (n_str); return  (n_str);
<operator>.notEquals str[topeomfjeawd]!='\0'
<operator>.assignment topeomfjeawd=topeomfjeawd+1
<operator>.equals (n_str=malloc((topeomfjeawd+SIZE_BUFF)*sizeof(char)+1))==NULL
<operator>.notEquals str[topeomfjeawd]!='\0'
<operator>.equals n_str[*inc-1]=='\0'
IDENTIFIER n_str return  (n_str);
RETURN return  (NULL); return  (NULL);
<operator>.assignment n_str[topeomfjeawd]=str[topeomfjeawd]
<operator>.assignment topeomfjeawd=topeomfjeawd+1
<operator>.assignment *inc=*inc-1
<operator>.addition topeomfjeawd+1
<operator>.assignment n_str=malloc((topeomfjeawd+SIZE_BUFF)*sizeof(char)+1)
IDENTIFIER NULL return  (NULL);
malloc malloc((topeomfjeawd+SIZE_BUFF)*sizeof(char)+1)
<operator>.addition topeomfjeawd+1
<operator>.subtraction *inc-1
<operator>.subtraction *inc-1
<operator>.addition (topeomfjeawd+SIZE_BUFF)*sizeof(char)+1
<operator>.multiplication (topeomfjeawd+SIZE_BUFF)*sizeof(char)
<operator>.addition topeomfjeawd+SIZE_BUFF
<operator>.sizeOf sizeof(char)
<operator>.indirectIndexAccess str[topeomfjeawd]
<operator>.indirectIndexAccess str[topeomfjeawd]
<operator>.indirectIndexAccess n_str[*inc-1]
<operator>.indirectIndexAccess n_str[topeomfjeawd]
<operator>.indirectIndexAccess str[topeomfjeawd]
<operator>.indirection *inc
<operator>.indirection *inc
<operator>.indirection *inc
>>>PDG&37 0->2 0->3 0->4 0->5 0->6 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->16 0->18 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->1 2->6 2->8 2->11 2->15 3->1 4->1 4->9 4->18 4->26 4->27 5->16 5->22 7->1 8->1 8->1 8->8 8->9 8->11 8->18 8->29 9->1 9->1 9->18 9->26 9->27 10->1 10->1 10->1 10->5 10->6 10->7 10->11 10->12 10->14 10->23 10->30 10->31 10->35 11->6 11->11 11->15 11->15 11->16 11->22 11->30 11->32 11->33 12->13 12->17 12->24 12->34 12->36 13->7 14->1 15->13 16->22 19->1 19->1 19->10 19->12 19->13 20->14 21->1 21->10 21->19 23->24 24->17 24->17 25->1 26->1 26->21 26->25 27->1 27->1 28->1
>>>Token char * my_realloc ( char * str , int * inc ) { char * n_str ; int topeomfjeawd ; topeomfjeawd = 0 ; while ( str [ topeomfjeawd ] != ' \0 ' ) topeomfjeawd = topeomfjeawd + 1 ; if ( ( n_str = malloc ( ( topeomfjeawd + SIZE_BUFF ) * sizeof ( char ) +1 ) ) == NULL ) return ( NULL ) ; topeomfjeawd = 0 ; while ( str [ topeomfjeawd ] != ' \0 ' ) { n_str [ topeomfjeawd ] = str [ topeomfjeawd ] ; topeomfjeawd = topeomfjeawd + 1 ; } if ( n_str [ * inc - 1 ] == ' \0 ' ) * inc = * inc - 1 ; free ( str ) ; return ( n_str ) ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment fin=fopen("a.in","r")
<operator>.assignment fout=fopen("a.out","w")
fscanf fscanf(fin,"%ld",&a)
RETURN return 0; return 0;
<operator>.lessEqualsThan z<=a
<operator>.postIncrement z++
LITERAL 0 return 0;
fopen fopen("a.in","r")
fopen fopen("a.out","w")
<operator>.assignment z=1
fprintf fprintf(fout,"Case #%ld:\n",z)
fscanf fscanf(fin,"%ld",&b)
<operator>.lessThan y<b
<operator>.postIncrement y++
<operator>.lessThan x<b
<operator>.postIncrement x++
<operator>.lessThan x<b
<operator>.postIncrement x++
<operator>.lessThan x<b
<operator>.postIncrement x++
<operator>.assignment y=0
fscanf fscanf(fin,"%s",&ltrvwssjxsay[y])
<operator>.assignment c=0
<operator>.assignment d=0
<operator>.assignment eshnbymdklol[y]=0
<operator>.assignment s[y]=c
<operator>.assignment x=0
<operator>.assignment c=0
<operator>.assignment uhzbvbscycsn=0
<operator>.assignment g=0
<operator>.assignment h=0
<operator>.assignment q[x]=0
<operator>.assignment q[x]=uhzbvbscycsn/(double)c
<operator>.assignment x=0
<operator>.assignment c=0
<operator>.assignment uhzbvbscycsn=0
<operator>.assignment r[x]=0
<operator>.assignment x=0
fprintf fprintf(fout "%.12lf\n" .25 *eshnbymdklol[x]/(double)s[x]+.5 *q[x]+.25 *r[x])
<operator>.lessThan x<b
<operator>.postIncrement x++
<operator>.greaterThan c>0
<operator>.lessThan y<b
<operator>.postIncrement y++
<operator>.lessThan y<b
<operator>.postIncrement y++
<operator>.greaterThan c>0
<operator>.assignment x=0
<operator>.assignment eshnbymdklol[y]=(double)d
<operator>.assignment y=0
<operator>.division uhzbvbscycsn/(double)c
<operator>.assignment y=0
<operator>.assignment r[x]=uhzbvbscycsn/(double)c
<operator>.addition .25 *eshnbymdklol[x]/(double)s[x]+.5 *q[x]+.25 *r[x]
<operator>.notEquals ltrvwssjxsay[y][x]!='.'
<operator>.equals ltrvwssjxsay[y][x]=='1'
<operator>.notEquals ltrvwssjxsay[x][y]!='.'
<operator>.cast (double)c
<operator>.notEquals ltrvwssjxsay[x][y]!='.'
<operator>.addition .25 *eshnbymdklol[x]/(double)s[x]+.5 *q[x]
<operator>.multiplication .25 *r[x]
<operator>.postIncrement c++
<operator>.postIncrement d++
<operator>.cast (double)d
<operator>.postIncrement c++
<operator>.postIncrement c++
<operator>.assignment uhzbvbscycsn=uhzbvbscycsn+q[y]
<operator>.division uhzbvbscycsn/(double)c
<operator>.division .25 *eshnbymdklol[x]/(double)s[x]
<operator>.multiplication .5 *q[x]
<operator>.logicalAnd ltrvwssjxsay[x][y]=='0'&&s[y]>1
<operator>.cast (double)c
<operator>.multiplication .25 *eshnbymdklol[x]
<operator>.cast (double)s[x]
<operator>.assignmentPlus uhzbvbscycsn+=(eshnbymdklol[y]-1)/(double)(s[y]-1)
<operator>.addition uhzbvbscycsn+q[y]
<operator>.equals ltrvwssjxsay[x][y]=='0'
<operator>.greaterThan s[y]>1
<operator>.assignmentPlus uhzbvbscycsn+=eshnbymdklol[y]/(double)(s[y]-1)
<operator>.division (eshnbymdklol[y]-1)/(double)(s[y]-1)
<operator>.subtraction eshnbymdklol[y]-1
<operator>.cast (double)(s[y]-1)
<operator>.division eshnbymdklol[y]/(double)(s[y]-1)
<operator>.subtraction s[y]-1
<operator>.cast (double)(s[y]-1)
<operator>.subtraction s[y]-1
<operator>.addressOf &b
<operator>.addressOf &ltrvwssjxsay[y]
<operator>.indirectIndexAccess eshnbymdklol[y]
<operator>.indirectIndexAccess s[y]
<operator>.indirectIndexAccess q[x]
<operator>.indirectIndexAccess q[x]
<operator>.indirectIndexAccess r[x]
<operator>.indirectIndexAccess ltrvwssjxsay[y]
<operator>.indirectIndexAccess eshnbymdklol[y]
UNKNOWN double double
<operator>.indirectIndexAccess r[x]
<operator>.indirectIndexAccess r[x]
<operator>.indirectIndexAccess ltrvwssjxsay[y][x]
<operator>.indirectIndexAccess ltrvwssjxsay[y][x]
UNKNOWN double double
<operator>.indirectIndexAccess ltrvwssjxsay[x][y]
<operator>.indirectIndexAccess ltrvwssjxsay[x][y]
<operator>.indirectIndexAccess q[x]
<operator>.indirectIndexAccess ltrvwssjxsay[y]
<operator>.indirectIndexAccess ltrvwssjxsay[y]
<operator>.indirectIndexAccess ltrvwssjxsay[x]
<operator>.indirectIndexAccess ltrvwssjxsay[x]
UNKNOWN double double
<operator>.indirectIndexAccess eshnbymdklol[x]
UNKNOWN double double
<operator>.indirectIndexAccess s[x]
<operator>.indirectIndexAccess q[y]
<operator>.indirectIndexAccess ltrvwssjxsay[x][y]
<operator>.indirectIndexAccess s[y]
<operator>.indirectIndexAccess ltrvwssjxsay[x]
<operator>.indirectIndexAccess eshnbymdklol[y]
UNKNOWN double double
<operator>.indirectIndexAccess eshnbymdklol[y]
<operator>.indirectIndexAccess s[y]
UNKNOWN double double
<operator>.indirectIndexAccess s[y]
>>>PDG&124 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->56 0->57 0->58 0->59 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->71 0->73 0->74 0->76 0->77 0->78 0->79 0->80 0->82 0->85 0->87 2->1 2->1 2->4 3->1 3->1 3->1 3->12 4->1 4->1 4->1 4->6 4->13 5->1 6->1 6->1 6->1 6->6 6->7 6->12 6->12 6->13 6->14 6->16 6->18 6->20 6->22 6->28 6->35 6->39 6->88 7->1 7->6 8->5 9->2 9->2 10->3 10->3 11->1 11->6 12->1 12->1 12->7 12->40 13->1 13->1 13->1 13->14 13->16 13->18 13->20 13->23 13->41 13->44 13->46 14->1 14->1 14->14 14->15 14->15 14->16 14->23 14->24 14->25 14->26 14->27 14->41 14->41 14->43 14->49 14->89 14->90 14->91 14->95 15->1 15->14 16->16 16->17 16->17 16->18 16->29 16->30 16->31 16->32 16->33 16->34 16->44 16->44 16->51 16->52 16->59 16->92 16->93 16->97 17->1 17->16 18->18 18->19 18->19 18->20 18->36 18->37 18->38 18->46 18->46 18->48 18->53 18->94 19->1 19->18 20->1 20->1 20->1 20->13 20->14 20->20 20->21 20->21 20->40 20->55 20->61 20->62 20->70 20->71 20->74 20->75 20->99 20->105 20->111 20->112 20->113 21->1 21->20 22->1 22->14 23->1 23->1 23->1 23->13 24->1 24->27 24->43 24->63 25->1 25->1 25->50 25->64 25->65 26->1 26->1 26->82 26->84 27->1 27->1 27->79 27->85 27->87 28->16 29->1 29->52 29->59 29->66 30->1 30->52 30->76 30->80 31->1 31->1 32->1 32->1 33->1 34->1 34->1 34->1 34->71 35->18 36->1 36->48 36->67 37->1 37->1 37->68 37->69 37->77 38->1 38->1 38->62 39->1 39->20 40->1 40->1 40->1 40->12 41->14 41->41 41->42 41->42 41->56 41->57 41->100 41->101 41->106 41->107 42->1 42->41 43->1 43->1 43->50 43->65 43->96 43->102 44->1 44->1 44->16 44->44 44->45 44->45 44->58 44->103 44->108 45->1 45->44 46->1 46->1 46->18 46->46 46->47 46->47 46->60 46->104 46->109 47->1 47->46 48->1 48->1 48->54 48->69 48->69 48->73 48->73 48->98 48->110 49->41 50->1 50->1 50->1 50->82 50->84 51->1 51->44 52->1 52->1 52->34 52->34 53->1 53->46 54->1 54->1 54->1 54->62 55->1 55->1 56->1 56->57 56->63 57->1 57->1 57->23 57->56 57->64 58->1 58->1 58->60 58->66 58->72 58->78 58->78 58->115 58->117 59->1 60->1 60->1 60->58 60->67 60->68 60->77 60->114 61->1 61->1 62->1 62->40 62->40 62->55 62->55 63->1 63->27 63->43 64->1 64->1 64->50 64->65 65->1 66->1 66->52 66->59 67->1 67->48 68->1 68->1 68->1 68->69 68->77 69->1 69->1 69->54 69->54 70->1 70->1 70->40 70->40 70->55 70->55 70->61 70->61 71->1 71->40 71->40 71->55 71->55 71->61 71->61 72->1 72->1 72->1 72->76 72->80 72->81 72->82 72->83 72->84 72->85 72->86 72->87 72->118 72->119 72->120 72->121 72->122 72->123 73->1 74->1 74->70 74->70 75->1 76->1 76->1 76->52 76->80 77->1 78->1 78->58 78->60 78->72 78->72 78->79 78->116 79->72 79->72 79->85 79->87 80->1 80->1 80->52 80->76 81->1 81->1 81->76 81->76 82->1 82->81 82->81 82->84 83->1 84->1 84->1 84->80 84->80 84->82 85->1 85->79 85->81 85->81 85->83 85->83 85->87 86->1 87->1 87->79 87->84 87->84 87->85 87->86 87->86
>>>Token int main ( ) { fin = fopen ( " " , " " ) ; fout = fopen ( " " , " " ) ; long wffnvwsrqhbsa , b , c , d , e , x , y , z ; char ltrvwssjxsay [ 110 ] [ 110 ] ; double eshnbymdklol [ 110 ] , q [ 110 ] , r [ 110 ] ; double uhzbvbscycsn , g , h , i ; long wffnvwsrqhbss [ 110 ] ; fscanf ( fin , " " , & a ) ; for ( z = 1 ; z <= a ; z ++ ) { fprintf ( fout , " \n " , z ) ; fscanf ( fin , " " , & b ) ; for ( y = 0 ; y < b ; y ++ ) { fscanf ( fin , " " , & ltrvwssjxsay [ y ] ) ; c = 0 ; d = 0 ; eshnbymdklol [ y ] = 0 ; for ( x = 0 ; x < b ; x ++ ) { if ( ltrvwssjxsay [ y ] [ x ] != ' ' ) { c ++ ; } if ( ltrvwssjxsay [ y ] [ x ] == ' ' ) { d ++ ; } } s [ y ] = c ; if ( c > 0 ) { eshnbymdklol [ y ] = ( double ) d ; } } for ( x = 0 ; x < b ; x ++ ) { c = 0 ; uhzbvbscycsn = 0 ; g = 0 ; h = 0 ; q [ x ] = 0 ; for ( y = 0 ; y < b ; y ++ ) { if ( ltrvwssjxsay [ x ] [ y ] != ' ' ) { c ++ ; if ( ltrvwssjxsay [ x ] [ y ] == ' ' && s [ y ] > 1 ) { uhzbvbscycsn += ( eshnbymdklol [ y ] - 1 ) / ( double ) ( s [ y ] - 1 ) ; } else { uhzbvbscycsn += eshnbymdklol [ y ] / ( double ) ( s [ y ] - 1 ) ; } } } q [ x ] = uhzbvbscycsn / ( double ) c ; } for ( x = 0 ; x < b ; x ++ ) { c = 0 ; uhzbvbscycsn = 0 ; r [ x ] = 0 ; for ( y = 0 ; y < b ; y ++ ) { if ( ltrvwssjxsay [ x ] [ y ] != ' ' ) { c ++ ; uhzbvbscycsn = uhzbvbscycsn + q [ y ] ; } } if ( c > 0 ) { r [ x ] = uhzbvbscycsn / ( double ) c ; } } for ( x = 0 ; x < b ; x ++ ) { fprintf ( fout , " \n " , .25 * eshnbymdklol [ x ] / ( double ) s [ x ] + .5 * q [ x ] + .25 * r [ x ] ) ; } } return 0 ; }
>>>Func
METHOD zckspikopvsw
METHOD_RETURN int
PARAM char *list
PARAM int rniovjkuvkjf
PARAM int usqarpebswnb
PARAM int ipopahakxnrz
<operator>.assignment zrgswyszuqsa=rniovjkuvkjf
<operator>.assignment diff=usqarpebswnb-rniovjkuvkjf+1
<operator>.assignmentMinus ipopahakxnrz-=diff
RETURN return ipopahakxnrz; return ipopahakxnrz;
<operator>.lessThan zrgswyszuqsa<(ipopahakxnrz-diff)
<operator>.assignment list[zrgswyszuqsa++]=list[zrgswyszuqsa+diff]
IDENTIFIER ipopahakxnrz return ipopahakxnrz;
<operator>.addition usqarpebswnb-rniovjkuvkjf+1
<operator>.subtraction usqarpebswnb-rniovjkuvkjf
<operator>.subtraction ipopahakxnrz-diff
<operator>.postIncrement zrgswyszuqsa++
<operator>.addition zrgswyszuqsa+diff
<operator>.indirectIndexAccess list[zrgswyszuqsa++]
<operator>.indirectIndexAccess list[zrgswyszuqsa+diff]
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->12 0->13 0->14 0->15 0->16 0->17 2->1 2->11 3->6 3->14 4->14 5->15 6->1 6->10 7->1 7->1 7->15 8->1 8->1 8->1 8->12 9->1 10->1 10->1 10->1 10->10 10->11 10->15 10->16 10->16 10->17 10->18 10->19 11->1 11->1 11->1 12->9 13->1 14->1 14->1 14->7 14->7 14->13 14->13 15->8 15->8 15->10 15->10 15->17 16->10 16->17
>>>Token int zckspikopvsw ( char * list , int rniovjkuvkjf , int usqarpebswnb , int ipopahakxnrz ) { int zrgswyszuqsa = rniovjkuvkjf , diff = usqarpebswnb - rniovjkuvkjf + 1 ; while ( zrgswyszuqsa < ( ipopahakxnrz - diff ) ) list [ zrgswyszuqsa ++ ] = list [ zrgswyszuqsa + diff ] ; ipopahakxnrz -= diff ; return ipopahakxnrz ; }
>>>Func
METHOD kqqdneebpggp
METHOD_RETURN int
PARAM int ltagvtztiuqr
PARAM int telmikjnxbay
RETURN return ltagvtztiuqr<telmikjnxbay?ltagvtztiuqr:telmikjnxbay; return ltagvtztiuqr<telmikjnxbay?ltagvtztiuqr:telmikjnxbay;
<operator>.conditional ltagvtztiuqr<telmikjnxbay?ltagvtztiuqr:telmikjnxbay
<operator>.lessThan ltagvtztiuqr<telmikjnxbay
>>>PDG&7 0->2 0->3 0->5 0->6 2->6 3->6 4->1 5->1 5->1 5->1 5->1 5->4 6->5 6->5
>>>Token int kqqdneebpggp ( int ltagvtztiuqr , int telmikjnxbay ) { return ltagvtztiuqr < telmikjnxbay ? ltagvtztiuqr : telmikjnxbay ; }
>>>Func
METHOD mutbdcsvrxlx
METHOD_RETURN T
PARAM T blljycoshmmv
RETURN return blljycoshmmv*blljycoshmmv; return blljycoshmmv*blljycoshmmv;
<operator>.multiplication blljycoshmmv*blljycoshmmv
>>>PDG&5 0->2 0->4 2->4 3->1 4->1 4->1 4->3
>>>Token T mutbdcsvrxlx ( T blljycoshmmv ) { return blljycoshmmv * blljycoshmmv ; }
>>>Func
METHOD qmxnzsjwntrf
METHOD_RETURN void
PARAM int *arr
PARAM int xfsgierafnnl
<operator>.assignment sauzvdndiqgm=false
<operator>.logicalNot !sauzvdndiqgm
<operator>.assignment sauzvdndiqgm=true
<operator>.lessEqualsThan voqnhnhtshei<=xfsgierafnnl-2
<operator>.assignmentPlus voqnhnhtshei+=2
<operator>.lessEqualsThan voqnhnhtshei<=xfsgierafnnl-2
<operator>.assignmentPlus voqnhnhtshei+=2
<operator>.assignment voqnhnhtshei=0
<operator>.assignment voqnhnhtshei=1
<operator>.subtraction xfsgierafnnl-2
<operator>.greaterThan arr[voqnhnhtshei]>arr[voqnhnhtshei+1]
<operator>.subtraction xfsgierafnnl-2
<operator>.greaterThan arr[voqnhnhtshei]>arr[voqnhnhtshei+1]
swap swap(&arr[voqnhnhtshei],&arr[voqnhnhtshei+1])
<operator>.assignment sauzvdndiqgm=false
swap swap(&arr[voqnhnhtshei],&arr[voqnhnhtshei+1])
<operator>.assignment sauzvdndiqgm=false
<operator>.addition voqnhnhtshei+1
<operator>.addition voqnhnhtshei+1
<operator>.addition voqnhnhtshei+1
<operator>.addition voqnhnhtshei+1
<operator>.indirectIndexAccess arr[voqnhnhtshei]
<operator>.indirectIndexAccess arr[voqnhnhtshei+1]
<operator>.indirectIndexAccess arr[voqnhnhtshei]
<operator>.indirectIndexAccess arr[voqnhnhtshei+1]
<operator>.addressOf &arr[voqnhnhtshei]
<operator>.addressOf &arr[voqnhnhtshei+1]
<operator>.addressOf &arr[voqnhnhtshei]
<operator>.addressOf &arr[voqnhnhtshei+1]
<operator>.indirectIndexAccess arr[voqnhnhtshei]
<operator>.indirectIndexAccess arr[voqnhnhtshei+1]
<operator>.indirectIndexAccess arr[voqnhnhtshei]
<operator>.indirectIndexAccess arr[voqnhnhtshei+1]
>>>PDG&37 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->18 0->20 0->21 0->22 0->23 0->24 2->1 2->14 2->16 2->17 2->19 3->1 3->13 4->1 4->1 4->5 5->1 5->1 5->5 5->6 5->7 5->9 5->11 5->12 5->13 5->15 6->1 6->5 7->7 7->8 7->8 7->13 7->14 7->21 7->21 7->23 7->25 7->26 8->7 9->1 9->1 9->1 9->9 9->10 9->10 9->15 9->16 9->22 9->22 9->24 9->27 9->28 10->9 11->7 12->9 13->7 13->7 13->15 14->16 14->16 14->17 14->17 14->17 14->18 14->23 14->29 14->30 14->33 14->34 15->9 15->9 15->13 16->14 16->14 16->19 16->19 16->19 16->20 16->24 16->31 16->32 16->35 16->36 17->14 17->14 17->16 17->16 17->19 17->19 18->5 19->14 19->14 19->16 19->16 19->17 19->17 20->5
>>>Token void qmxnzsjwntrf ( int * arr , int xfsgierafnnl ) { bool sauzvdndiqgm = false ; while ( ! sauzvdndiqgm ) { sauzvdndiqgm = true ; int32_t voqnhnhtshei ; for ( voqnhnhtshei = 0 ; voqnhnhtshei <= xfsgierafnnl - 2 ; voqnhnhtshei += 2 ) { if ( arr [ voqnhnhtshei ] > arr [ voqnhnhtshei + 1 ] ) { swap ( & arr [ voqnhnhtshei ] , & arr [ voqnhnhtshei + 1 ] ) ; sauzvdndiqgm = false ; } } for ( voqnhnhtshei = 1 ; voqnhnhtshei <= xfsgierafnnl - 2 ; voqnhnhtshei += 2 ) { if ( arr [ voqnhnhtshei ] > arr [ voqnhnhtshei + 1 ] ) { swap ( & arr [ voqnhnhtshei ] , & arr [ voqnhnhtshei + 1 ] ) ; sauzvdndiqgm = false ; } } } }
>>>Func
METHOD hxaiaofbjtbi
METHOD_RETURN int
PARAM int ccqljcspzvkc
PARAM int **teams
<operator>.assignment wp=(double *)xmalloc(ccqljcspzvkc *sizeof(double))
<operator>.assignment owp=(double *)xmalloc(ccqljcspzvkc *sizeof(double))
<operator>.assignment oowp=(double *)xmalloc(ccqljcspzvkc *sizeof(double))
<operator>.lessThan mspxausodcom<ccqljcspzvkc
<operator>.postIncrement mspxausodcom++
<operator>.lessThan mspxausodcom<ccqljcspzvkc
<operator>.postIncrement mspxausodcom++
<operator>.lessThan mspxausodcom<ccqljcspzvkc
<operator>.postIncrement mspxausodcom++
<operator>.lessThan mspxausodcom<ccqljcspzvkc
<operator>.postIncrement mspxausodcom++
<operator>.cast (double *)xmalloc(ccqljcspzvkc *sizeof(double))
<operator>.cast (double *)xmalloc(ccqljcspzvkc *sizeof(double))
<operator>.cast (double *)xmalloc(ccqljcspzvkc *sizeof(double))
<operator>.assignment mspxausodcom=0
<operator>.assignment seijaftubien=0
<operator>.assignment mafxyxgjkaea=0
<operator>.assignment wp[mspxausodcom]=((double)seijaftubien)/(mafxyxgjkaea)
<operator>.assignment mspxausodcom=0
<operator>.assignment owp[mspxausodcom]=0
<operator>.assignment zwvqchoybyfo=0
<operator>.assignmentDivision owp[mspxausodcom]/=zwvqchoybyfo
<operator>.assignment mspxausodcom=0
<operator>.assignment oowp[mspxausodcom]=0
<operator>.assignment zwvqchoybyfo=0
<operator>.assignmentDivision oowp[mspxausodcom]/=zwvqchoybyfo
<operator>.assignment mspxausodcom=0
<operator>.assignment hnilcwbjeaor=0.25 *wp[mspxausodcom]+0.5 *owp[mspxausodcom]+0.25 *oowp[mspxausodcom]
printf printf("%f\n",hnilcwbjeaor)
xmalloc xmalloc(ccqljcspzvkc *sizeof(double))
xmalloc xmalloc(ccqljcspzvkc *sizeof(double))
xmalloc xmalloc(ccqljcspzvkc *sizeof(double))
<operator>.lessThan iscwxpuwhqzi<ccqljcspzvkc
<operator>.postIncrement iscwxpuwhqzi++
<operator>.lessThan iscwxpuwhqzi<ccqljcspzvkc
<operator>.postIncrement iscwxpuwhqzi++
<operator>.lessThan iscwxpuwhqzi<ccqljcspzvkc
<operator>.postIncrement iscwxpuwhqzi++
<operator>.multiplication ccqljcspzvkc *sizeof(double)
<operator>.multiplication ccqljcspzvkc *sizeof(double)
<operator>.multiplication ccqljcspzvkc *sizeof(double)
<operator>.assignment iscwxpuwhqzi=0
<operator>.postIncrement mafxyxgjkaea++
<operator>.division ((double)seijaftubien)/(mafxyxgjkaea)
<operator>.assignment iscwxpuwhqzi=0
<operator>.assignment seijaftubien=0
<operator>.assignment mafxyxgjkaea=0
<operator>.assignmentPlus owp[mspxausodcom]+=(double)seijaftubien/mafxyxgjkaea
<operator>.postIncrement zwvqchoybyfo++
<operator>.assignment iscwxpuwhqzi=0
<operator>.assignmentPlus oowp[mspxausodcom]+=owp[iscwxpuwhqzi]
<operator>.postIncrement zwvqchoybyfo++
<operator>.addition 0.25 *wp[mspxausodcom]+0.5 *owp[mspxausodcom]+0.25 *oowp[mspxausodcom]
<operator>.sizeOf sizeof(double)
<operator>.lessThan teams[mspxausodcom][iscwxpuwhqzi]<0
<operator>.greaterThan teams[mspxausodcom][iscwxpuwhqzi]>0
<operator>.cast (double)seijaftubien
<operator>.lessThan teams[mspxausodcom][iscwxpuwhqzi]<0
<operator>.lessThan bcfedkbeiszn<ccqljcspzvkc
<operator>.postIncrement bcfedkbeiszn++
<operator>.lessThan teams[mspxausodcom][iscwxpuwhqzi]<0
<operator>.addition 0.25 *wp[mspxausodcom]+0.5 *owp[mspxausodcom]
<operator>.multiplication 0.25 *oowp[mspxausodcom]
<operator>.postIncrement seijaftubien++
<operator>.assignment bcfedkbeiszn=0
<operator>.postIncrement mafxyxgjkaea++
<operator>.division (double)seijaftubien/mafxyxgjkaea
<operator>.multiplication 0.25 *wp[mspxausodcom]
<operator>.multiplication 0.5 *owp[mspxausodcom]
<operator>.logicalOr mspxausodcom==bcfedkbeiszn||teams[iscwxpuwhqzi][bcfedkbeiszn]<0
<operator>.greaterThan teams[iscwxpuwhqzi][bcfedkbeiszn]>0
<operator>.cast (double)seijaftubien
<operator>.postIncrement seijaftubien++
<operator>.equals mspxausodcom==bcfedkbeiszn
<operator>.lessThan teams[iscwxpuwhqzi][bcfedkbeiszn]<0
<operator>.indirectIndexAccess wp[mspxausodcom]
<operator>.indirectIndexAccess owp[mspxausodcom]
<operator>.indirectIndexAccess owp[mspxausodcom]
<operator>.indirectIndexAccess oowp[mspxausodcom]
<operator>.indirectIndexAccess oowp[mspxausodcom]
UNKNOWN double double
<operator>.indirectIndexAccess owp[mspxausodcom]
<operator>.indirectIndexAccess oowp[mspxausodcom]
<operator>.indirectIndexAccess owp[iscwxpuwhqzi]
<operator>.indirectIndexAccess oowp[mspxausodcom]
<operator>.indirectIndexAccess teams[mspxausodcom][iscwxpuwhqzi]
<operator>.indirectIndexAccess teams[mspxausodcom][iscwxpuwhqzi]
<operator>.indirectIndexAccess teams[mspxausodcom][iscwxpuwhqzi]
<operator>.indirectIndexAccess teams[mspxausodcom][iscwxpuwhqzi]
<operator>.indirectIndexAccess wp[mspxausodcom]
<operator>.indirectIndexAccess owp[mspxausodcom]
<operator>.indirectIndexAccess teams[mspxausodcom]
<operator>.indirectIndexAccess teams[mspxausodcom]
<operator>.indirectIndexAccess teams[mspxausodcom]
UNKNOWN double double
<operator>.indirectIndexAccess teams[mspxausodcom]
<operator>.indirectIndexAccess teams[iscwxpuwhqzi][bcfedkbeiszn]
<operator>.indirectIndexAccess teams[iscwxpuwhqzi][bcfedkbeiszn]
<operator>.indirectIndexAccess teams[iscwxpuwhqzi]
<operator>.indirectIndexAccess teams[iscwxpuwhqzi]
>>>PDG&104 0->2 0->3 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->52 0->53 0->55 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->74 0->75 0->76 0->77 0->78 2->42 3->1 4->1 4->1 4->71 5->1 5->1 5->25 5->51 5->54 5->72 6->1 6->1 6->1 6->29 6->54 6->66 7->7 7->8 7->8 7->9 7->19 7->20 7->21 7->36 7->36 7->45 7->47 7->60 7->79 7->84 8->1 8->7 9->9 9->10 9->10 9->11 9->23 9->24 9->25 9->38 9->38 9->48 9->77 9->80 9->81 10->1 10->9 11->11 11->12 11->12 11->13 11->27 11->28 11->29 11->40 11->40 11->53 11->82 11->83 12->1 12->11 13->1 13->1 13->1 13->13 13->14 13->14 13->31 13->32 13->56 13->65 13->66 13->71 13->72 13->88 13->93 13->94 14->1 14->13 17->1 18->7 19->47 19->60 19->67 20->46 20->47 21->71 22->9 23->25 23->51 24->25 24->52 25->72 26->11 27->29 27->54 28->29 28->55 29->66 30->1 30->13 31->32 33->4 33->15 34->5 34->16 35->1 35->6 35->17 36->7 36->36 36->37 36->37 36->58 36->89 36->95 37->36 38->9 38->38 38->39 38->39 38->61 38->62 38->91 38->97 39->38 40->11 40->40 40->41 40->41 40->64 40->92 40->99 41->40 42->33 42->43 43->34 43->44 44->7 44->35 45->36 46->47 47->21 47->21 48->38 49->70 49->75 49->76 50->69 50->70 51->25 52->25 53->40 54->29 55->29 57->1 58->46 58->59 58->59 58->61 58->64 58->90 58->96 59->58 59->61 59->64 59->67 61->49 61->50 61->51 61->52 61->62 61->64 61->68 61->70 61->75 61->85 61->98 62->38 62->62 62->63 62->73 62->77 62->77 63->62 64->54 64->55 64->86 64->87 66->31 66->31 66->56 66->56 67->47 67->60 68->62 69->70 70->51 70->51 71->31 71->31 71->56 71->56 71->65 71->65 72->31 72->31 72->56 72->56 72->65 72->65 73->69 73->74 73->100 73->102 74->76 74->78 76->70 76->75 77->10 77->63 77->73 77->73 77->78 77->101 77->103 78->73 78->73 78->74
>>>Token int hxaiaofbjtbi ( int ccqljcspzvkc , int * * teams ) { int mspxausodcom ; int iscwxpuwhqzi ; int bcfedkbeiszn ; int ggluyhsmozzr ; double * wp ; double * owp ; double * oowp ; int seijaftubien ; int mafxyxgjkaea ; int zwvqchoybyfo ; int rncanthtbzmq ; double atreumkjposq ; double hnilcwbjeaor ; wp = ( double * ) xmalloc ( ccqljcspzvkc * sizeof ( double ) ) ; owp = ( double * ) xmalloc ( ccqljcspzvkc * sizeof ( double ) ) ; oowp = ( double * ) xmalloc ( ccqljcspzvkc * sizeof ( double ) ) ; for ( mspxausodcom = 0 ; mspxausodcom < ccqljcspzvkc ; mspxausodcom ++ ) { seijaftubien = 0 ; mafxyxgjkaea = 0 ; for ( iscwxpuwhqzi = 0 ; iscwxpuwhqzi < ccqljcspzvkc ; iscwxpuwhqzi ++ ) { if ( teams [ mspxausodcom ] [ iscwxpuwhqzi ] < 0 ) continue ; if ( teams [ mspxausodcom ] [ iscwxpuwhqzi ] > 0 ) { seijaftubien ++ ; } mafxyxgjkaea ++ ; } wp [ mspxausodcom ] = ( ( double ) seijaftubien ) / ( mafxyxgjkaea ) ; } for ( mspxausodcom = 0 ; mspxausodcom < ccqljcspzvkc ; mspxausodcom ++ ) { owp [ mspxausodcom ] = 0 ; zwvqchoybyfo = 0 ; for ( iscwxpuwhqzi = 0 ; iscwxpuwhqzi < ccqljcspzvkc ; iscwxpuwhqzi ++ ) { if ( teams [ mspxausodcom ] [ iscwxpuwhqzi ] < 0 ) continue ; seijaftubien = 0 ; mafxyxgjkaea = 0 ; for ( bcfedkbeiszn = 0 ; bcfedkbeiszn < ccqljcspzvkc ; bcfedkbeiszn ++ ) { if ( mspxausodcom == bcfedkbeiszn || teams [ iscwxpuwhqzi ] [ bcfedkbeiszn ] < 0 ) continue ; if ( teams [ iscwxpuwhqzi ] [ bcfedkbeiszn ] > 0 ) { seijaftubien ++ ; } mafxyxgjkaea ++ ; } owp [ mspxausodcom ] += ( double ) seijaftubien / mafxyxgjkaea ; zwvqchoybyfo ++ ; } owp [ mspxausodcom ] /= zwvqchoybyfo ; } for ( mspxausodcom = 0 ; mspxausodcom < ccqljcspzvkc ; mspxausodcom ++ ) { oowp [ mspxausodcom ] = 0 ; zwvqchoybyfo = 0 ; for ( iscwxpuwhqzi = 0 ; iscwxpuwhqzi < ccqljcspzvkc ; iscwxpuwhqzi ++ ) { if ( teams [ mspxausodcom ] [ iscwxpuwhqzi ] < 0 ) continue ; oowp [ mspxausodcom ] += owp [ iscwxpuwhqzi ] ; zwvqchoybyfo ++ ; } oowp [ mspxausodcom ] /= zwvqchoybyfo ; } for ( mspxausodcom = 0 ; mspxausodcom < ccqljcspzvkc ; mspxausodcom ++ ) { hnilcwbjeaor = 0.25 * wp [ mspxausodcom ] + 0.5 * owp [ mspxausodcom ] + 0.25 * oowp [ mspxausodcom ] ; printf ( " \n " , hnilcwbjeaor ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&hraahhtdypua)
RETURN return 0; return 0;
<operator>.lessEqualsThan t<=hraahhtdypua
<operator>.preIncrement ++t
LITERAL 0 return 0;
<operator>.assignment t=1
scanf scanf("%d",&n)
WP WP()
OWP OWP()
OOWP OOWP()
printf printf("Case #%d:\n",t)
<operator>.lessThan wcpxqvbwrieg<n
<operator>.preIncrement ++wcpxqvbwrieg
<operator>.lessThan wcpxqvbwrieg<n
<operator>.preIncrement ++wcpxqvbwrieg
<operator>.assignment wcpxqvbwrieg=0
scanf scanf(" %s",table[wcpxqvbwrieg])
<operator>.assignment wcpxqvbwrieg=0
printf printf("%lf\n" 0.25 *(double)(wp[wcpxqvbwrieg][0])/(double)(wp[wcpxqvbwrieg][1])+0.5 *owp[wcpxqvbwrieg]+0.25 *oowp[wcpxqvbwrieg])
<operator>.addition 0.25 *(double)(wp[wcpxqvbwrieg][0])/(double)(wp[wcpxqvbwrieg][1])+0.5 *owp[wcpxqvbwrieg]+0.25 *oowp[wcpxqvbwrieg]
<operator>.addition 0.25 *(double)(wp[wcpxqvbwrieg][0])/(double)(wp[wcpxqvbwrieg][1])+0.5 *owp[wcpxqvbwrieg]
<operator>.multiplication 0.25 *oowp[wcpxqvbwrieg]
<operator>.division 0.25 *(double)(wp[wcpxqvbwrieg][0])/(double)(wp[wcpxqvbwrieg][1])
<operator>.multiplication 0.5 *owp[wcpxqvbwrieg]
<operator>.multiplication 0.25 *(double)(wp[wcpxqvbwrieg][0])
<operator>.cast (double)(wp[wcpxqvbwrieg][1])
<operator>.cast (double)(wp[wcpxqvbwrieg][0])
<operator>.addressOf &n
<operator>.indirectIndexAccess table[wcpxqvbwrieg]
<operator>.indirectIndexAccess oowp[wcpxqvbwrieg]
<operator>.indirectIndexAccess owp[wcpxqvbwrieg]
UNKNOWN double double
<operator>.indirectIndexAccess wp[wcpxqvbwrieg][1]
UNKNOWN double double
<operator>.indirectIndexAccess wp[wcpxqvbwrieg][0]
<operator>.indirectIndexAccess wp[wcpxqvbwrieg]
<operator>.indirectIndexAccess wp[wcpxqvbwrieg]
>>>PDG&39 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->23 0->25 0->26 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->11 4->12 4->12 4->13 4->15 4->17 4->19 4->29 5->1 5->4 6->3 7->1 7->4 8->1 8->13 8->15 9->1 10->1 11->1 12->1 12->5 13->13 13->14 13->14 13->15 13->18 13->30 14->1 14->13 15->1 15->1 15->1 15->8 15->13 15->15 15->16 15->16 15->20 15->21 15->22 15->23 15->24 15->25 15->26 15->27 15->28 15->31 15->32 15->33 15->34 15->35 15->36 15->37 15->38 16->1 16->15 17->13 18->1 19->1 19->15 20->1 20->1 21->1 21->1 22->1 22->1 23->1 23->20 23->20 23->21 23->21 24->1 24->1 24->20 24->20 24->21 24->21 24->22 24->22 25->1 25->20 25->20 25->21 25->21 25->22 25->22 26->1 26->24 26->24 27->1 28->1
>>>Token int main ( ) { int hraahhtdypua , t ; int wcpxqvbwrieg , j ; scanf ( " " , & hraahhtdypua ) ; for ( t = 1 ; t <= hraahhtdypua ; ++ t ) { scanf ( " " , & n ) ; for ( wcpxqvbwrieg = 0 ; wcpxqvbwrieg < n ; ++ wcpxqvbwrieg ) { scanf ( " " , table [ wcpxqvbwrieg ] ) ; } WP ( ) ; OWP ( ) ; OOWP ( ) ; printf ( " \n " , t ) ; for ( wcpxqvbwrieg = 0 ; wcpxqvbwrieg < n ; ++ wcpxqvbwrieg ) { printf ( " \n " , 0.25 * ( double ) ( wp [ wcpxqvbwrieg ] [ 0 ] ) / ( double ) ( wp [ wcpxqvbwrieg ] [ 1 ] ) +0.5 * owp [ wcpxqvbwrieg ] + 0.25 * oowp [ wcpxqvbwrieg ] ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int bwxsituutimo
PARAM char *argv [ ]
<operator>.assignment kujnlvwvxnvc=0
printf printf("Sum is: %d\n",kujnlvwvxnvc)
RETURN return 0; return 0;
<operator>.lessThan yrwzxtdivkuq<127
<operator>.postIncrement yrwzxtdivkuq++
<operator>.assignmentPlus kujnlvwvxnvc+=yrwzxtdivkuq
LITERAL 0 return 0;
<operator>.assignment yrwzxtdivkuq=0
>>>PDG&12 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->1 3->1 4->1 4->5 4->9 5->1 5->1 6->1 7->1 7->1 7->7 7->8 7->8 7->9 7->9 8->1 8->7 9->1 9->5 10->6 11->1 11->7
>>>Token int main ( int bwxsituutimo , char * argv [ ] ) { int yrwzxtdivkuq ; int kujnlvwvxnvc = 0 ; for ( yrwzxtdivkuq = 0 ; yrwzxtdivkuq < 127 ; yrwzxtdivkuq ++ ) kujnlvwvxnvc += yrwzxtdivkuq ; printf ( " \n " , kujnlvwvxnvc ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN ANY
PARAM void
<operator>.assignment in=fopen("a.in","r")
<operator>.assignment out=fopen("a.out","w")
fscanf fscanf(in,"%d",&t)
fclose fclose(in)
fclose fclose(out)
<operator>.lessThan smksbdapkkyg<t
<operator>.postIncrement smksbdapkkyg++
fopen fopen("a.in","r")
fopen fopen("a.out","w")
<operator>.assignment smksbdapkkyg=0
fscanf fscanf(in,"%d %d %d",&n,&d,&g)
<operator>.logicalAnd g==100&&d!=100
<operator>.logicalAnd g==100&&d==100
<operator>.logicalAnd d==100&&g>0
<operator>.logicalAnd d==100&&g==0
<operator>.logicalAnd g==0&&d!=0
<operator>.logicalAnd g==0&&d==0
<operator>.greaterThan i>0
<operator>.postDecrement i--
<operator>.equals i==0
fprintf fprintf(out,"Case #%d: Broken\n",smksbdapkkyg+1)
fprintf fprintf(out,"Case #%d: Possible\n",smksbdapkkyg+1)
fprintf fprintf(out,"Case #%d: Possible\n",smksbdapkkyg+1)
fprintf fprintf(out,"Case #%d: Broken\n",smksbdapkkyg+1)
fprintf fprintf(out,"Case #%d: Broken\n",smksbdapkkyg+1)
fprintf fprintf(out,"Case #%d: Possible\n",smksbdapkkyg+1)
<operator>.assignment i=n
<operator>.equals (i *d)/100==(i *d)/100.0
fprintf fprintf(out,"Case #%d: Broken\n",smksbdapkkyg+1)
<operator>.equals g==100
<operator>.notEquals d!=100
<operator>.equals g==100
<operator>.equals d==100
<operator>.equals d==100
<operator>.greaterThan g>0
<operator>.equals d==100
<operator>.equals g==0
<operator>.equals g==0
<operator>.notEquals d!=0
<operator>.equals g==0
<operator>.equals d==0
fprintf fprintf(out,"Case #%d: Possible\n",smksbdapkkyg+1)
<operator>.addition smksbdapkkyg+1
<operator>.addition smksbdapkkyg+1
<operator>.addition smksbdapkkyg+1
<operator>.addition smksbdapkkyg+1
<operator>.addition smksbdapkkyg+1
<operator>.addition smksbdapkkyg+1
<operator>.division (i *d)/100
<operator>.division (i *d)/100.0
<operator>.addition smksbdapkkyg+1
<operator>.multiplication i *d
<operator>.multiplication i *d
<operator>.addition smksbdapkkyg+1
<operator>.addressOf &n
<operator>.addressOf &d
<operator>.addressOf &g
>>>PDG&60 0->2 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 2->1 3->1 3->1 3->5 4->1 4->1 4->7 4->23 4->24 4->25 4->26 4->27 4->28 4->31 4->44 5->1 5->1 5->6 5->8 5->13 6->1 6->1 7->1 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->13 8->14 8->23 8->24 8->25 8->26 8->27 8->28 8->31 8->32 8->44 8->45 8->46 8->47 8->48 8->49 8->50 8->53 8->56 8->57 8->58 8->59 9->1 9->8 10->3 10->3 11->4 11->4 12->1 12->8 13->1 13->1 13->1 13->1 13->6 13->29 13->32 13->33 13->34 13->35 13->36 13->37 13->38 13->39 13->40 13->41 13->42 13->43 13->54 13->55 14->1 14->1 14->1 14->15 14->23 14->34 14->45 15->1 15->1 15->1 15->16 15->24 15->36 15->46 16->1 16->1 16->1 16->15 16->17 16->25 16->38 16->47 17->1 17->1 17->1 17->15 17->18 17->26 17->40 17->48 18->1 18->1 18->1 18->17 18->19 18->27 18->42 18->49 19->1 19->1 19->1 19->17 19->20 19->22 19->28 19->29 19->50 20->1 20->22 20->30 20->51 20->52 20->54 20->54 20->55 21->1 21->20 22->1 22->1 22->31 22->53 23->1 23->1 23->7 23->24 23->25 23->26 23->27 23->28 23->31 23->44 24->1 24->1 24->7 24->23 24->25 24->26 24->27 24->28 24->31 24->44 25->1 25->1 25->7 25->23 25->24 25->26 25->27 25->28 25->31 25->44 26->1 26->1 26->7 26->23 26->24 26->25 26->27 26->28 26->31 26->44 27->1 27->1 27->7 27->23 27->24 27->25 27->26 27->28 27->31 27->44 28->1 28->1 28->7 28->23 28->24 28->25 28->26 28->27 28->31 28->44 29->1 29->1 29->20 30->1 30->1 30->1 30->20 30->21 30->44 30->56 31->1 31->1 31->7 31->23 31->24 31->25 31->26 31->27 31->28 31->44 32->1 32->13 32->14 32->14 32->33 32->34 33->1 33->13 33->14 33->14 33->35 33->36 34->1 34->13 34->15 34->15 34->32 34->35 34->37 34->39 34->40 35->1 35->13 35->15 35->15 35->33 35->36 36->1 36->13 36->16 36->16 36->33 36->35 36->37 36->38 37->1 37->13 37->16 37->16 37->32 37->39 37->40 38->1 38->13 38->17 38->17 38->33 38->35 38->36 38->39 38->41 38->43 38->54 39->1 39->13 39->17 39->17 39->32 39->40 40->1 40->13 40->18 40->18 40->32 40->41 40->42 41->1 41->13 41->18 41->18 41->33 41->35 41->36 41->43 41->54 42->1 42->13 42->19 42->19 42->32 42->43 43->1 43->13 43->19 43->19 43->33 43->35 43->36 43->54 44->1 44->1 44->7 44->23 44->24 44->25 44->26 44->27 44->28 44->31 51->30 51->30 52->1 52->30 52->30 54->51 54->51 54->55 54->55 55->1 55->13 55->21 55->22 55->33 55->35 55->36 55->52 55->52 55->54
>>>Token main ( void ) { int smksbdapkkyg , t , n , d , g , i ; FILE * in ; FILE * out ; in = fopen ( " " , " " ) ; out = fopen ( " " , " " ) ; fscanf ( in , " " , & t ) ; for ( smksbdapkkyg = 0 ; smksbdapkkyg < t ; smksbdapkkyg ++ ) { fscanf ( in , " " , & n , & d , & g ) ; if ( g == 100 && d != 100 ) { fprintf ( out , " \n " , smksbdapkkyg + 1 ) ; continue ; } if ( g == 100 && d == 100 ) { fprintf ( out , " \n " , smksbdapkkyg + 1 ) ; continue ; } if ( d == 100 && g > 0 ) { fprintf ( out , " \n " , smksbdapkkyg + 1 ) ; continue ; } if ( d == 100 && g == 0 ) { fprintf ( out , " \n " , smksbdapkkyg + 1 ) ; continue ; } if ( g == 0 && d != 0 ) { fprintf ( out , " \n " , smksbdapkkyg + 1 ) ; continue ; } if ( g == 0 && d == 0 ) { fprintf ( out , " \n " , smksbdapkkyg + 1 ) ; continue ; } for ( i = n ; i > 0 ; i -- ) if ( ( i * d ) / 100 == ( i * d ) / 100.0 ) { fprintf ( out , " \n " , smksbdapkkyg + 1 ) ; break ; } if ( i == 0 ) fprintf ( out , " \n " , smksbdapkkyg + 1 ) ; } fclose ( in ) ; fclose ( out ) ; }
>>>Func
METHOD main
METHOD_RETURN int
freopen freopen("1B-A-RPI.in","r",stdin)
freopen freopen("1B-A-RPI.out","w",stdout)
scanf scanf("%d",&pyyajfjatzyk)
RETURN return 0; return 0;
<operator>.lessEqualsThan qvdlibrpkjlh<=pyyajfjatzyk
<operator>.postIncrement qvdlibrpkjlh++
LITERAL 0 return 0;
<operator>.assignment qvdlibrpkjlh=1
scanf scanf("%d",&N)
printf printf("Case #%d:\n",qvdlibrpkjlh)
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.assignment j=0
scanf scanf("%s",lrrsgznejcyf[j])
<operator>.assignment cybehftgdcmn[j]=0
<operator>.assignment OWP[j]=0
<operator>.assignment OOWP[j]=0
<operator>.assignment j=0
<operator>.assignment wxwbiclfxbna=0
<operator>.assignment aWP[j]=wxwbiclfxbna
<operator>.assignmentDivision cybehftgdcmn[j]/=wxwbiclfxbna
<operator>.assignment j=0
<operator>.assignment wxwbiclfxbna=0
<operator>.assignmentDivision OWP[j]/=wxwbiclfxbna
<operator>.assignment j=0
<operator>.assignment wxwbiclfxbna=0
<operator>.assignmentDivision OOWP[j]/=wxwbiclfxbna
printf printf("%.12lf\n",0.25 *cybehftgdcmn[j]+0.5 *OWP[j]+0.25 *OOWP[j])
<operator>.lessThan k<N
<operator>.postIncrement k++
<operator>.lessThan k<N
<operator>.postIncrement k++
<operator>.lessThan k<N
<operator>.postIncrement k++
<operator>.assignment k=0
<operator>.assignment k=0
<operator>.assignment k=0
<operator>.addition 0.25 *cybehftgdcmn[j]+0.5 *OWP[j]+0.25 *OOWP[j]
<operator>.notEquals lrrsgznejcyf[j][k]!='.'
<operator>.notEquals lrrsgznejcyf[j][k]!='.'
<operator>.notEquals lrrsgznejcyf[j][k]!='.'
<operator>.addition 0.25 *cybehftgdcmn[j]+0.5 *OWP[j]
<operator>.multiplication 0.25 *OOWP[j]
<operator>.postIncrement wxwbiclfxbna++
<operator>.assignmentPlus cybehftgdcmn[j]+=lrrsgznejcyf[j][k]-'0'
<operator>.postIncrement wxwbiclfxbna++
<operator>.assignmentPlus OWP[j]+=(cybehftgdcmn[k]*aWP[k]-(lrrsgznejcyf[k][j]-'0'))/(aWP[k]-1)
<operator>.postIncrement wxwbiclfxbna++
<operator>.assignmentPlus OOWP[j]+=OWP[k]
<operator>.multiplication 0.25 *cybehftgdcmn[j]
<operator>.multiplication 0.5 *OWP[j]
<operator>.subtraction lrrsgznejcyf[j][k]-'0'
<operator>.division (cybehftgdcmn[k]*aWP[k]-(lrrsgznejcyf[k][j]-'0'))/(aWP[k]-1)
<operator>.subtraction cybehftgdcmn[k]*aWP[k]-(lrrsgznejcyf[k][j]-'0')
<operator>.subtraction aWP[k]-1
<operator>.multiplication cybehftgdcmn[k]*aWP[k]
<operator>.subtraction lrrsgznejcyf[k][j]-'0'
<operator>.addressOf &N
<operator>.indirectIndexAccess lrrsgznejcyf[j]
<operator>.indirectIndexAccess cybehftgdcmn[j]
<operator>.indirectIndexAccess OWP[j]
<operator>.indirectIndexAccess OOWP[j]
<operator>.indirectIndexAccess aWP[j]
<operator>.indirectIndexAccess cybehftgdcmn[j]
<operator>.indirectIndexAccess OWP[j]
<operator>.indirectIndexAccess OOWP[j]
<operator>.indirectIndexAccess OOWP[j]
<operator>.indirectIndexAccess lrrsgznejcyf[j][k]
<operator>.indirectIndexAccess lrrsgznejcyf[j][k]
<operator>.indirectIndexAccess lrrsgznejcyf[j][k]
<operator>.indirectIndexAccess cybehftgdcmn[j]
<operator>.indirectIndexAccess OWP[j]
<operator>.indirectIndexAccess lrrsgznejcyf[j]
<operator>.indirectIndexAccess cybehftgdcmn[j]
<operator>.indirectIndexAccess lrrsgznejcyf[j]
<operator>.indirectIndexAccess OWP[j]
<operator>.indirectIndexAccess lrrsgznejcyf[j]
<operator>.indirectIndexAccess OOWP[j]
<operator>.indirectIndexAccess OWP[k]
<operator>.indirectIndexAccess lrrsgznejcyf[j][k]
<operator>.indirectIndexAccess lrrsgznejcyf[j]
<operator>.indirectIndexAccess aWP[k]
<operator>.indirectIndexAccess cybehftgdcmn[k]
<operator>.indirectIndexAccess aWP[k]
<operator>.indirectIndexAccess lrrsgznejcyf[k][j]
<operator>.indirectIndexAccess lrrsgznejcyf[k]
>>>PDG&94 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->46 0->47 0->48 0->50 0->51 0->53 0->55 0->57 0->58 0->59 0->62 0->64 2->1 2->1 3->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->11 6->12 6->14 6->16 6->18 6->20 6->25 6->29 6->32 6->65 7->1 7->6 8->5 9->1 9->6 10->1 10->12 10->14 10->16 10->18 10->36 10->38 10->40 11->1 11->7 12->12 12->13 12->13 12->14 12->21 12->22 12->23 12->24 12->66 12->67 12->68 12->69 13->1 13->12 14->14 14->15 14->15 14->16 14->26 14->27 14->28 14->36 14->36 14->42 14->70 14->71 15->1 15->14 16->16 16->17 16->17 16->18 16->30 16->31 16->38 16->38 16->43 16->72 17->1 17->16 18->1 18->1 18->1 18->10 18->12 18->18 18->19 18->19 18->33 18->34 18->35 18->40 18->40 18->44 18->45 18->49 18->50 18->57 18->58 18->73 18->74 18->78 18->79 19->1 19->18 20->12 21->1 22->1 22->1 22->28 22->52 22->57 23->1 23->1 23->31 23->54 23->58 24->1 24->1 24->34 24->56 25->14 26->1 26->27 26->28 26->51 27->1 27->1 28->1 28->1 28->1 28->52 28->57 29->16 30->1 30->31 30->53 31->1 31->1 31->1 31->54 31->58 32->1 32->18 33->1 33->34 33->55 34->1 34->1 34->50 35->1 35->1 36->1 36->1 36->14 36->36 36->37 36->37 36->46 36->75 36->80 37->1 37->36 38->1 38->1 38->16 38->38 38->39 38->39 38->47 38->76 38->82 39->1 39->38 40->1 40->1 40->18 40->40 40->41 40->41 40->48 40->77 40->84 41->1 41->40 42->1 42->36 43->1 43->38 44->1 44->40 45->1 45->1 46->1 46->1 46->21 46->47 46->48 46->51 46->52 46->59 46->59 46->81 46->87 46->88 47->1 47->1 47->21 47->46 47->48 47->53 47->54 47->60 47->61 47->62 47->63 47->64 47->83 47->89 47->90 47->91 47->92 47->93 48->1 48->1 48->21 48->46 48->47 48->55 48->56 48->85 48->86 49->1 49->1 50->1 50->34 50->35 50->35 50->45 50->45 50->56 51->1 51->27 51->28 52->1 52->1 52->28 53->1 53->31 54->1 54->1 54->31 55->1 55->34 56->1 56->1 56->34 57->1 57->28 57->35 57->35 57->45 57->45 57->49 57->49 57->52 58->1 58->31 58->35 58->35 58->45 58->45 58->49 58->49 58->54 59->1 59->21 59->46 59->47 59->48 59->52 59->52 60->1 60->1 60->54 60->54 61->1 61->1 61->60 61->60 62->1 62->60 62->60 62->63 63->1 63->61 63->61 63->62 64->1 64->61 64->61
>>>Token int main ( ) { freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; int pyyajfjatzyk , N ; int qvdlibrpkjlh , j , k , aWP [ 110 ] ; char lrrsgznejcyf [ 110 ] [ 110 ] ; double cybehftgdcmn [ 110 ] , OWP [ 110 ] , OOWP [ 11 ] ; scanf ( " " , & pyyajfjatzyk ) ; for ( qvdlibrpkjlh = 1 ; qvdlibrpkjlh <= pyyajfjatzyk ; qvdlibrpkjlh ++ ) { scanf ( " " , & N ) ; printf ( " \n " , qvdlibrpkjlh ) ; for ( j = 0 ; j < N ; j ++ ) { scanf ( " " , lrrsgznejcyf [ j ] ) ; cybehftgdcmn [ j ] = 0 ; OWP [ j ] = 0 ; OOWP [ j ] = 0 ; } for ( j = 0 ; j < N ; j ++ ) { int wxwbiclfxbna = 0 ; for ( k = 0 ; k < N ; k ++ ) { if ( lrrsgznejcyf [ j ] [ k ] != ' ' ) { wxwbiclfxbna ++ ; cybehftgdcmn [ j ] += lrrsgznejcyf [ j ] [ k ] - ' ' ; } } aWP [ j ] = wxwbiclfxbna ; cybehftgdcmn [ j ] /= wxwbiclfxbna ; } for ( j = 0 ; j < N ; j ++ ) { int wxwbiclfxbna = 0 ; for ( k = 0 ; k < N ; k ++ ) { if ( lrrsgznejcyf [ j ] [ k ] != ' ' ) { wxwbiclfxbna ++ ; OWP [ j ] += ( cybehftgdcmn [ k ] * aWP [ k ] - ( lrrsgznejcyf [ k ] [ j ] - ' ' ) ) / ( aWP [ k ] - 1 ) ; } } OWP [ j ] /= wxwbiclfxbna ; } for ( j = 0 ; j < N ; j ++ ) { int wxwbiclfxbna = 0 ; for ( k = 0 ; k < N ; k ++ ) { if ( lrrsgznejcyf [ j ] [ k ] != ' ' ) { wxwbiclfxbna ++ ; OOWP [ j ] += OWP [ k ] ; } } OOWP [ j ] /= wxwbiclfxbna ; printf ( " \n " , 0.25 * cybehftgdcmn [ j ] + 0.5 * OWP [ j ] + 0.25 * OOWP [ j ] ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&pjyjvvtwqcpx)
RETURN return 0; return 0;
<operator>.lessEqualsThan testno<=pjyjvvtwqcpx
<operator>.postIncrement testno++
LITERAL 0 return 0;
<operator>.assignment testno=1
<operator>.assignment ccranmywdeku=0
scanf scanf("%lld%d%d",&N,&xfxzolmskeho,&PG)
printf printf("Case #%d: %s\n",testno,ccranmywdeku?"Possible":"Broken")
<operator>.logicalOr PG==0||PG==100
<operator>.conditional ccranmywdeku?"Possible":"Broken"
<operator>.equals PG==0
<operator>.equals PG==100
<operator>.equals xfxzolmskeho==PG
IDENTIFIER guyslrmsnloy <empty>
<operator>.assignment ccranmywdeku=1
<operator>.assignment ccranmywdeku=0
<operator>.assignment ccranmywdeku=1
<operator>.assignment ccranmywdeku=0
<operator>.addressOf &N
<operator>.addressOf &xfxzolmskeho
<operator>.addressOf &PG
UNKNOWN y y
UNKNOWN guyslrmsnloyd=(guyslrmsnloy guyslrmsnloy)gcd(xfxzolmskeho,100); guyslrmsnloyd=(guyslrmsnloy guyslrmsnloy)gcd(xfxzolmskeho,100);
UNKNOWN N>=(guyslrmsnloy guyslrmsnloy)100/d N>=(guyslrmsnloy guyslrmsnloy)100/d
>>>PDG&27 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 2->1 2->4 3->1 4->1 4->1 4->1 4->4 4->5 4->8 4->9 4->10 4->10 4->11 4->12 4->13 4->21 4->22 4->23 5->1 5->4 6->3 7->1 7->4 8->1 9->1 9->1 9->1 10->1 10->1 10->5 11->1 11->1 11->1 11->15 11->24 11->25 11->26 12->1 13->1 13->11 13->11 13->14 13->14 13->15 14->1 14->11 14->11 14->13 14->15 15->1 15->1 15->1 15->13 15->17 15->18 17->1 18->1 19->1 20->1 26->19 26->20
>>>Token int main ( ) { int pjyjvvtwqcpx , testno ; scanf ( " " , & pjyjvvtwqcpx ) ; for ( testno = 1 ; testno <= pjyjvvtwqcpx ; testno ++ ) { guyslrmsnloy guyslrmsnloyN ; int xfxzolmskeho , PG ; int ccranmywdeku = 0 ; scanf ( " " , & N , & xfxzolmskeho , & PG ) ; if ( PG == 0 || PG == 100 ) { if ( xfxzolmskeho == PG ) { ccranmywdeku = 1 ; } else { ccranmywdeku = 0 ; } } else { guyslrmsnloy guyslrmsnloyd = ( guyslrmsnloy guyslrmsnloy ) gcd ( xfxzolmskeho , 100 ) ; if ( N >= ( guyslrmsnloy guyslrmsnloy ) 100 / d ) { ccranmywdeku = 1 ; } else { ccranmywdeku = 0 ; } } printf ( " \n " , testno , ccranmywdeku ? " " : " " ) ; } return 0 ; }
>>>Func
METHOD kcgfznurgtom
METHOD_RETURN int
PARAM Heap *heap
<operator>.notEquals heap->count!=0
<operator>.multiplication ianfczxafkwr *(heap->p)
<operator>.indirectFieldAccess heap->p
FIELD_IDENTIFIER p p
>>>PDG&7 0->2 0->3 0->4 2->1 3->1 3->1 3->4 3->5 3->6 4->1 4->1 4->1
>>>Token int kcgfznurgtom ( Heap * heap ) { if ( heap -> count != 0 ) ianfczxafkwr * ( heap -> p ) ; else ianfczxafkwr INT_MIN ; }
>>>Func
METHOD main
METHOD_RETURN void
<operator>.assignment *in=fopen("input.in","r")
<operator>.assignment *out=fopen("output.out","w")
fscanf fscanf(in,"%d",&wokuhheydiyw)
fclose fclose(in)
fclose fclose(out)
<operator>.lessThan zdlbpwzkquif<wokuhheydiyw
<operator>.postIncrement zdlbpwzkquif++
fopen fopen("input.in","r")
fopen fopen("output.out","w")
<operator>.assignment zdlbpwzkquif=0
fscanf fscanf(in,"%d ",&C)
<operator>.assignment cukdqxrarjje=0
<operator>.assignment r_com=0
<operator>.assignment com=0
<operator>.assignment l_op=0
<operator>.assignment r_op=0
fscanf fscanf(in,"%d ",&D)
fscanf fscanf(in,"%d ",&N)
fprintf fprintf(out,"Case #%d: [",zdlbpwzkquif+1)
fprintf fprintf(out,"]\n")
<operator>.lessThan j<C
<operator>.postIncrement j++
<operator>.lessThan j<D
<operator>.postIncrement j++
<operator>.lessThan j<N
<operator>.postIncrement j++
fscanf fscanf(in,"%c",&ls[j])
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.assignment j=0
fscanf fscanf(in,"%c",&cukdqxrarjje)
fscanf fscanf(in,"%c",&r_com)
fscanf fscanf(in,"%c",&com)
<operator>.assignment j=0
fscanf fscanf(in,"%c",&l_op)
fscanf fscanf(in,"%c",&r_op)
<operator>.assignment j=0
<operator>.assignment j=0
vhfsflqshalz vhfsflqshalz(ls[j]==cukdqxrarjje&&ls[j-1]==r_com)
BLOCK <empty> <empty>
<operator>.addition zdlbpwzkquif+1
<operator>.assignment j=0
vhfsflqshalz vhfsflqshalz(ls[j]=='\0')
<operator>.assignment ls[j]=com
<operator>.assignment ls[j-1]='\0'
<operator>.logicalAnd ls[j]==cukdqxrarjje&&ls[j-1]==r_com
<operator>.equals ls[j]=='\0'
<operator>.equals ls[j]==cukdqxrarjje
<operator>.equals ls[j-1]==r_com
<operator>.subtraction j-1
<operator>.subtraction j-1
<operator>.addressOf &C
<operator>.addressOf &D
<operator>.addressOf &N
<operator>.addressOf &ls[j]
UNKNOWN,),)
UNKNOWN else vhfsflqshalz (ls[j]==r_com&&ls[j-1]==cukdqxrarjje){ls[j]=com;ls[j-1]='\0';} else vhfsflqshalz (ls[j]==r_com&&ls[j-1]==cukdqxrarjje){ls[j]=com;ls[j-1]='\0';}
UNKNOWN else vhfsflqshalz (ls[j]==l_op){for(op_chk=j-1;op_chk>=0;op_chk--){vhfsflqshalz(ls[op_chk]==r_op){for(k=0;k<=j;k++)ls[k]='\0';break;}}} else vhfsflqshalz (ls[j]==l_op){for(op_chk=j-1;op_chk>=0;op_chk--){vhfsflqshalz(ls[op_chk]==r_op){for(k=0;k<=j;k++)ls[k]='\0';break;}}}
UNKNOWN else vhfsflqshalz (ls[j]==r_op){for(op_chk=j-1;op_chk>=0;op_chk--){vhfsflqshalz(ls[op_chk]==l_op){for(k=0;k<=j;k++)ls[k]='\0';break;}}} else vhfsflqshalz (ls[j]==r_op){for(op_chk=j-1;op_chk>=0;op_chk--){vhfsflqshalz(ls[op_chk]==l_op){for(k=0;k<=j;k++)ls[k]='\0';break;}}}
UNKNOWN,),)
<operator>.addressOf &cukdqxrarjje
<operator>.addressOf &r_com
<operator>.addressOf &com
<operator>.addressOf &l_op
<operator>.addressOf &r_op
<operator>.indirectIndexAccess ls[j]
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.indirectIndexAccess ls[j]
<operator>.indirectIndexAccess ls[j-1]
<operator>.indirectIndexAccess ls[j]
vhfsflqshalz vhfsflqshalz(ls[j]=='\0')
UNKNOWN,),)
<operator>.indirectIndexAccess ls[j]
<operator>.indirectIndexAccess ls[j-1]
<operator>.equals ls[j]=='\0'
<operator>.indirectIndexAccess ls[j]
>>>PDG&81 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->43 0->44 0->45 0->47 0->48 0->50 0->51 0->52 0->53 0->54 2->1 2->1 2->4 3->1 3->1 3->6 3->20 4->1 4->1 4->5 4->7 4->12 5->1 5->1 6->1 6->1 7->1 7->1 7->1 7->7 7->8 7->8 7->12 7->13 7->14 7->15 7->16 7->17 7->18 7->19 7->20 7->20 7->21 7->22 7->24 7->26 7->29 7->31 7->33 7->37 7->40 7->41 7->44 7->44 7->45 7->55 7->56 7->57 8->1 8->7 9->2 9->2 10->3 10->3 11->1 11->7 12->1 12->1 12->18 12->22 12->34 13->1 13->1 13->34 13->51 14->1 14->1 14->35 14->52 15->1 15->1 15->36 15->47 16->1 16->1 16->38 17->1 17->1 17->39 18->1 18->1 18->19 18->24 18->38 19->1 19->1 19->5 19->12 19->26 19->28 19->29 19->31 20->1 20->1 20->21 21->1 21->6 21->20 22->1 22->1 22->12 22->22 22->23 22->23 22->34 22->35 22->36 22->64 22->65 22->66 23->1 23->22 24->1 24->1 24->18 24->24 24->25 24->25 24->38 24->39 24->67 24->68 25->1 25->24 26->26 26->27 26->27 26->28 26->29 26->58 26->69 27->1 27->26 28->1 28->1 28->5 28->12 28->50 28->51 29->29 29->30 29->31 29->42 29->47 29->48 29->49 29->51 29->53 29->53 29->54 29->59 29->60 29->61 29->62 29->72 29->73 29->77 30->1 30->29 31->1 31->1 31->1 31->19 31->26 31->31 31->32 31->32 31->46 31->50 31->63 31->74 32->1 32->31 33->22 34->1 34->1 34->35 34->51 35->1 35->1 35->36 35->52 36->1 36->1 36->18 36->34 36->47 37->24 38->1 38->1 38->39 39->1 39->1 39->19 39->38 40->26 41->29 42->1 42->1 45->1 45->31 46->1 46->1 47->1 47->1 47->1 47->28 47->50 47->51 48->1 48->1 48->52 49->1 49->1 49->42 49->42 50->1 50->28 50->46 50->46 50->51 51->1 51->49 51->49 51->52 51->54 51->78 52->1 52->49 52->49 53->30 54->53 70->70 70->71 70->75 70->76 70->79 70->80
>>>Token void main ( ) { int wokuhheydiyw , C , D , N ; char cukdqxrarjje , r_com , com , l_op , r_op , ls [ 10 ] ; int zdlbpwzkquif , j , k , op_chk ; FILE * in = fopen ( " " , " " ) ; FILE * out = fopen ( " " , " " ) ; fscanf ( in , " " , & wokuhheydiyw ) ; for ( zdlbpwzkquif = 0 ; zdlbpwzkquif < wokuhheydiyw ; zdlbpwzkquif ++ ) { fscanf ( in , " " , & C ) ; cukdqxrarjje = 0 ; r_com = 0 ; com = 0 ; l_op = 0 ; r_op = 0 ; for ( j = 0 ; j < C ; j ++ ) { fscanf ( in , " " , & cukdqxrarjje ) ; fscanf ( in , " " , & r_com ) ; fscanf ( in , " " , & com ) ; } fscanf ( in , " " , & D ) ; for ( j = 0 ; j < D ; j ++ ) { fscanf ( in , " " , & l_op ) ; fscanf ( in , " " , & r_op ) ; } fscanf ( in , " " , & N ) ; for ( j = 0 ; j < N ; j ++ ) fscanf ( in , " " , & ls [ j ] ) ; for ( j = 0 ; j < N ; j ++ ) { vhfsflqshalz ( ls [ j ] == cukdqxrarjje && ls [ j - 1 ] == r_com )  { ls [ j ] = com ; ls [ j - 1 ] = ' \0 ' ; } else vhfsflqshalz ( ls [ j ] = = r_com && ls [ j - 1 ] == cukdqxrarjje ) { ls [ j ] = com ; ls [ j - 1 ] = ' \0 ' ; } else vhfsflqshalz ( ls [ j ] = = l_op ) { for ( op_chk = j - 1 ; op_chk >= 0 ; op_chk -- ) { vhfsflqshalz ( ls [ op_chk ] == r_op )  { for ( k = 0 ; k <= j ; k ++ ) ls [ k ] = ' \0 ' ; break ; } } } else vhfsflqshalz ( ls [ j ] = = r_op ) { for ( op_chk = j - 1 ; op_chk >= 0 ; op_chk -- ) { vhfsflqshalz ( ls [ op_chk ] == l_op )  { for ( k = 0 ; k <= j ; k ++ ) ls [ k ] = ' \0 ' ; break ; } } } } fprintf ( out , " " , zdlbpwzkquif + 1 ) ; for ( j = 0 ; j < N ; j ++ ) { vhfsflqshalz ( ls [ j ] == ' \0 ' ) continue ; fprintf ( out , " " , ls [ j ] ) ; j ++ ; for ( ; j < N ; j ++ ) { vhfsflqshalz ( ls [ j ] == ' \0 ' ) continue ; fprintf ( out , " " ) ; fprintf ( out , " " , ls [ j ] ) ; } break ; } fprintf ( out , " \n " ) ; } fclose ( in ) ; fclose ( out ) ; }
>>>Func
METHOD atkapjaybolj
METHOD_RETURN int
PARAM int nqsjgnxllkfj
<operator>.assignment wzuigmpltnya=0
RETURN return wzuigmpltnya; return wzuigmpltnya;
<operator>.notEquals nqsjgnxllkfj!=0
IDENTIFIER wzuigmpltnya return wzuigmpltnya;
<operator>.assignment ykbekpitljan=nqsjgnxllkfj%10
<operator>.assignmentDivision nqsjgnxllkfj/=10
<operator>.assignment wzuigmpltnya=wzuigmpltnya *10+ykbekpitljan
<operator>.logicalOr wzuigmpltnya>INT_MAX/10||(wzuigmpltnya==INT_MAX/10&&ykbekpitljan>7)
<operator>.logicalOr wzuigmpltnya<INT_MIN/10||(wzuigmpltnya==INT_MIN/10&&ykbekpitljan<-8)
<operator>.modulo nqsjgnxllkfj%10
RETURN return 0; return 0;
RETURN return 0; return 0;
<operator>.addition wzuigmpltnya *10+ykbekpitljan
<operator>.greaterThan wzuigmpltnya>INT_MAX/10
<operator>.logicalAnd wzuigmpltnya==INT_MAX/10&&ykbekpitljan>7
LITERAL 0 return 0;
<operator>.lessThan wzuigmpltnya<INT_MIN/10
<operator>.logicalAnd wzuigmpltnya==INT_MIN/10&&ykbekpitljan<-8
LITERAL 0 return 0;
<operator>.multiplication wzuigmpltnya *10
<operator>.division INT_MAX/10
<operator>.equals wzuigmpltnya==INT_MAX/10
<operator>.greaterThan ykbekpitljan>7
<operator>.division INT_MIN/10
<operator>.equals wzuigmpltnya==INT_MIN/10
<operator>.lessThan ykbekpitljan<-8
<operator>.division INT_MAX/10
<operator>.division INT_MIN/10
<operator>.minus -8
>>>PDG&32 0->2 0->3 0->5 0->6 0->8 0->9 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 2->5 3->1 3->6 3->16 4->1 5->1 5->4 5->7 5->8 5->10 5->12 5->12 5->16 5->23 6->4 7->1 7->1 7->1 7->9 7->15 7->25 7->28 8->1 8->1 8->5 9->1 9->1 9->6 9->16 10->1 10->1 10->1 10->11 10->13 10->19 10->26 11->1 11->1 11->1 11->5 11->9 11->14 11->15 11->22 12->7 12->7 12->8 13->1 14->1 15->1 16->1 16->1 16->10 16->10 16->17 16->19 16->24 16->24 16->29 17->1 17->1 17->10 17->10 18->13 19->1 19->11 19->11 19->20 19->22 19->27 19->27 19->30 20->1 20->1 20->11 20->11 21->14 22->9 22->9 22->15 22->15 23->1 23->16 23->16 23->29 24->1 24->1 24->17 24->17 24->19 24->25 25->1 25->9 25->15 25->17 25->17 25->28 26->1 26->19 26->19 26->30 27->1 27->20 27->20 27->22 27->28 27->31 28->1 28->9 28->15 28->20 28->20 29->1 29->23 29->24 29->24 30->1 30->26 30->27 30->27 31->28
>>>Token int atkapjaybolj ( int nqsjgnxllkfj ) { int wzuigmpltnya = 0 ; while ( nqsjgnxllkfj != 0 ) { int ykbekpitljan = nqsjgnxllkfj % 10 ; nqsjgnxllkfj /= 10 ; if ( wzuigmpltnya > INT_MAX / 10 || ( wzuigmpltnya == INT_MAX / 10 && ykbekpitljan > 7 ) ) return 0 ; if ( wzuigmpltnya < INT_MIN / 10 || ( wzuigmpltnya == INT_MIN / 10 && ykbekpitljan < -8 ) ) return 0 ; wzuigmpltnya = wzuigmpltnya * 10 + ykbekpitljan ; } return wzuigmpltnya ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.arithmeticShiftRight cin>>ca
<operator>.lessEqualsThan vhhgsihkbnos<=ca
<operator>.postIncrement vhhgsihkbnos++
<operator>.assignment vhhgsihkbnos=1
clear sname.clear()
scanf scanf("%d",&S)
fgets fgets(ckwsnvwghrdy,1024,stdin)
scanf scanf("%d",&Q)
fgets fgets(ckwsnvwghrdy,1024,stdin)
<operator>.assignment qjedvkvxqxll=1000000
printf printf("Case #%d: %d\n",vhhgsihkbnos,qjedvkvxqxll)
<operator>.lessThan olqjgkesjclu<S
<operator>.postIncrement olqjgkesjclu++
<operator>.lessThan olqjgkesjclu<Q
<operator>.postIncrement olqjgkesjclu++
<operator>.lessThan olqjgkesjclu<Q
<operator>.postIncrement olqjgkesjclu++
<operator>.lessThan k<S
<operator>.postIncrement k++
<operator>.assignment olqjgkesjclu=0
fgets fgets(ckwsnvwghrdy,1024,stdin)
<operator>.assignment sname[ckwsnvwghrdy]=olqjgkesjclu
<operator>.assignment olqjgkesjclu=0
fgets fgets(ckwsnvwghrdy,1024,stdin)
<operator>.assignment query[olqjgkesjclu]=sname[ckwsnvwghrdy]
<operator>.assignment olqjgkesjclu=0
<operator>.lessThan j<S
<operator>.postIncrement j++
<operator>.assignment best[olqjgkesjclu][j]=-1
<operator>.assignment k=0
<operator>.assignment fsestjvthvmf=calc(0,k)
<operator>.logicalOr ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\qjedvkvxqxll'||ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\n'
<operator>.logicalOr ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\qjedvkvxqxll'||ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\n'
<operator>.logicalOr ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\qjedvkvxqxll'||ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\n'
<operator>.logicalOr ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\qjedvkvxqxll'||ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\n'
<operator>.assignment j=0
<operator>.lessThan fsestjvthvmf<qjedvkvxqxll
<operator>.assignment ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=0
<operator>.assignment ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=0
<operator>.assignment ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=0
<operator>.assignment ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=0
<operator>.minus -1
calc calc(0,k)
<operator>.assignment qjedvkvxqxll=fsestjvthvmf
<operator>.equals ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\qjedvkvxqxll'
<operator>.equals ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\n'
<operator>.equals ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\qjedvkvxqxll'
<operator>.equals ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\n'
<operator>.equals ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\qjedvkvxqxll'
<operator>.equals ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\n'
<operator>.equals ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\qjedvkvxqxll'
<operator>.equals ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]=='\n'
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
<operator>.subtraction strlen(ckwsnvwghrdy)-1
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
strlen strlen(ckwsnvwghrdy)
<operator>.fieldAccess sname.clear
<operator>.addressOf &S
<operator>.addressOf &Q
FIELD_IDENTIFIER clear clear
<operator>.indirectIndexAccess sname[ckwsnvwghrdy]
<operator>.indirectIndexAccess query[olqjgkesjclu]
<operator>.indirectIndexAccess sname[ckwsnvwghrdy]
<operator>.indirectIndexAccess best[olqjgkesjclu][j]
<operator>.indirectIndexAccess best[olqjgkesjclu]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
<operator>.indirectIndexAccess ckwsnvwghrdy[strlen(ckwsnvwghrdy)-1]
>>>PDG&99 0->2 0->3 0->4 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->28 0->29 0->31 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 2->1 2->1 2->3 3->1 3->1 3->1 3->3 3->4 3->6 3->7 3->8 3->9 3->10 3->11 3->12 3->12 3->13 3->15 3->17 3->19 3->21 3->24 3->27 3->31 3->78 3->79 3->80 3->81 4->1 4->3 5->1 5->3 6->1 6->1 7->1 7->13 7->19 7->28 8->10 8->10 8->22 8->22 9->1 9->15 9->17 10->1 10->1 10->1 10->8 10->8 10->25 10->25 11->1 11->12 11->38 12->1 12->1 12->4 13->1 13->13 13->14 13->14 13->19 13->22 13->23 13->23 13->28 13->33 13->34 13->46 13->48 13->54 13->57 13->66 13->69 13->82 13->87 13->90 14->1 14->13 15->15 15->16 15->16 15->17 15->25 15->26 15->35 15->36 15->50 15->52 15->60 15->63 15->72 15->75 15->83 15->84 15->93 15->96 16->1 16->15 17->1 17->1 17->1 17->9 17->15 17->17 17->18 17->18 17->28 17->37 18->1 18->17 19->1 19->1 19->1 19->7 19->13 19->19 19->20 19->32 19->38 19->44 19->44 20->1 20->19 21->13 22->10 22->66 23->1 23->1 23->26 24->15 25->1 25->1 25->8 25->72 26->1 26->1 26->1 27->1 27->17 28->1 28->1 28->19 28->28 28->29 28->29 28->30 28->43 28->85 28->86 29->1 29->28 30->1 30->1 30->1 31->1 31->19 32->1 32->1 32->38 33->34 33->39 33->56 33->68 33->89 34->1 34->1 34->1 34->33 34->35 34->40 34->59 34->71 34->92 35->36 35->41 35->62 35->74 35->95 36->1 36->1 36->1 36->33 36->35 36->42 36->65 36->77 36->98 37->1 37->28 38->1 38->1 38->12 38->45 38->45 39->1 39->48 39->69 40->1 40->1 40->8 40->10 40->22 40->25 40->46 40->50 40->66 40->72 41->1 41->52 41->75 42->1 42->1 42->8 42->10 42->22 42->25 42->46 42->50 42->66 42->72 43->30 44->20 44->32 44->32 45->1 45->1 45->12 45->38 46->33 46->33 46->47 46->47 46->48 46->55 46->67 46->67 46->68 46->69 46->88 47->33 47->33 47->48 47->68 47->69 48->1 48->8 48->10 48->22 48->25 48->34 48->34 48->46 48->49 48->49 48->50 48->58 48->66 48->70 48->70 48->71 48->72 48->91 49->1 49->8 49->10 49->22 49->25 49->34 49->34 49->46 49->50 49->66 49->71 49->72 50->35 50->35 50->51 50->51 50->52 50->61 50->73 50->73 50->74 50->75 50->94 51->35 51->35 51->52 51->74 51->75 52->1 52->8 52->10 52->22 52->25 52->36 52->36 52->46 52->50 52->53 52->53 52->64 52->66 52->72 52->76 52->76 52->77 52->97 53->1 53->8 53->10 53->22 53->25 53->36 53->36 53->46 53->50 53->66 53->72 53->77 57->1 58->1 59->1 63->1 64->1 65->1 66->46 66->54 66->67 66->68 66->69 67->47 67->55 67->68 67->69 68->56 68->69 69->10 69->22 69->48 69->57 69->70 69->71 70->10 70->22 70->49 70->58 70->71 71->10 71->22 71->59 72->50 72->60 72->73 72->74 72->75 73->51 73->61 73->74 73->75 74->62 74->75 75->1 75->8 75->25 75->52 75->63 75->76 75->77 76->1 76->8 76->25 76->53 76->64 76->77 77->1 77->8 77->25 77->65
>>>Token int main ( ) { int vhhgsihkbnos , ca ; int olqjgkesjclu , j , k ; cin >> ca ; map < string , < missing ' ' > int > sname ; for ( vhhgsihkbnos = 1 ; vhhgsihkbnos <= ca ; vhhgsihkbnos ++ ) { sname . clear ( ) ; char ckwsnvwghrdy [ 1024 ] ; scanf ( " " , & S ) ; fgets ( ckwsnvwghrdy , 1024 , stdin ) ; for ( olqjgkesjclu = 0 ; olqjgkesjclu < S ; olqjgkesjclu ++ ) { fgets ( ckwsnvwghrdy , 1024 , stdin ) ; if ( ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] == ' \q jedvkvxqxll ' || ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] == ' \n ' ) ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] = 0 ; if ( ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] == ' \q jedvkvxqxll ' || ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] == ' \n ' ) ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] = 0 ; sname [ ckwsnvwghrdy ] = olqjgkesjclu ; } scanf ( " " , & Q ) ; fgets ( ckwsnvwghrdy , 1024 , stdin ) ; for ( olqjgkesjclu = 0 ; olqjgkesjclu < Q ; olqjgkesjclu ++ ) { fgets ( ckwsnvwghrdy , 1024 , stdin ) ; if ( ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] == ' \q jedvkvxqxll ' || ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] == ' \n ' ) ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] = 0 ; if ( ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] == ' \q jedvkvxqxll ' || ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] == ' \n ' ) ckwsnvwghrdy [ strlen ( ckwsnvwghrdy ) - 1 ] = 0 ; query [ olqjgkesjclu ] = sname [ ckwsnvwghrdy ] ; } for ( olqjgkesjclu = 0 ; olqjgkesjclu < Q ; olqjgkesjclu ++ ) for ( j = 0 ; j < S ; j ++ ) best [ olqjgkesjclu ] [ j ] = -1 ; int qjedvkvxqxll = 1000000 ; for ( k = 0 ; k < S ; k ++ ) { int fsestjvthvmf = calc ( 0 , k ) ; if ( fsestjvthvmf < qjedvkvxqxll ) qjedvkvxqxll = fsestjvthvmf ; } printf ( " \n " , vhhgsihkbnos , qjedvkvxqxll ) ; } }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment *fin=fopen("B.in","r")
<operator>.assignment *fout=fopen("B.out","w")
fscanf fscanf(fin,"%d",&smvwxoeqfdos)
RETURN return 0; return 0;
<operator>.lessEqualsThan tc<=smvwxoeqfdos
<operator>.postIncrement tc++
LITERAL 0 return 0;
fopen fopen("B.in","r")
fopen fopen("B.out","w")
<operator>.assignment tc=1
<operator>.assignment xzryjfsomeke[SIZE][SIZE]={0}
<operator>.assignment govbshzesyzl[SIZE][SIZE]={0}
<operator>.assignment smuwouluvvbn=0
fscanf fscanf(fin,"%d",&vktbnzuqcncu)
fscanf fscanf(fin,"%d",&d)
fscanf fscanf(fin,"%d",&n)
fgetc fgetc(fin)
fprintf fprintf(fout,"Case #%d: ",tc)
fprintf fprintf(fout,"[")
fprintf fprintf(fout,"]\n")
<operator>.postDecrement vktbnzuqcncu--
<operator>.postDecrement d--
<operator>.postDecrement n--
<operator>.lessThan hjgffcuwoicv<smuwouluvvbn
<operator>.postIncrement hjgffcuwoicv++
<operator>.arrayInitializer {0}
<operator>.arrayInitializer {0}
fscanf fscanf(fin," %c%c%c",&yflyongbbkow,&beb,&nbe)
<operator>.assignment xzryjfsomeke[yflyongbbkow-'A'][beb-'A']=xzryjfsomeke[beb-'A'][yflyongbbkow-'A']=nbe
fscanf fscanf(fin," %c%c",&yflyongbbkow,&beb)
<operator>.assignment govbshzesyzl[yflyongbbkow-'A'][beb-'A']=govbshzesyzl[beb-'A'][yflyongbbkow-'A']=1
<operator>.assignment ch=fgetc(fin)
<operator>.assignment hjgffcuwoicv=0
fprintf fprintf(fout,"%c",maencustsmoh[hjgffcuwoicv])
<operator>.logicalAnd smuwouluvvbn>0&&xzryjfsomeke[maencustsmoh[smuwouluvvbn-1]-'A'][ch-'A']
IDENTIFIER hjgffcuwoicv if (hjgffcuwoicv)
<operator>.assignment xzryjfsomeke[beb-'A'][yflyongbbkow-'A']=nbe
<operator>.assignment govbshzesyzl[beb-'A'][yflyongbbkow-'A']=1
fgetc fgetc(fin)
<operator>.assignment maencustsmoh[smuwouluvvbn-1]=xzryjfsomeke[maencustsmoh[smuwouluvvbn-1]-'A'][ch-'A']
fprintf fprintf(fout,", ")
<operator>.subtraction beb-'A'
<operator>.subtraction beb-'A'
<operator>.greaterThan smuwouluvvbn>0
<operator>.subtraction yflyongbbkow-'A'
<operator>.subtraction yflyongbbkow-'A'
<operator>.subtraction yflyongbbkow-'A'
<operator>.subtraction yflyongbbkow-'A'
<operator>.subtraction ch-'A'
<operator>.lessThan hjgffcuwoicv<smuwouluvvbn
<operator>.postIncrement hjgffcuwoicv++
<operator>.equals hjgffcuwoicv==smuwouluvvbn
<operator>.subtraction beb-'A'
<operator>.subtraction beb-'A'
<operator>.subtraction maencustsmoh[smuwouluvvbn-1]-'A'
<operator>.subtraction smuwouluvvbn-1
<operator>.subtraction ch-'A'
<operator>.assignment hjgffcuwoicv=0
<operator>.assignment maencustsmoh[smuwouluvvbn++]=ch
<operator>.subtraction maencustsmoh[smuwouluvvbn-1]-'A'
<operator>.assignment smuwouluvvbn=0
<operator>.subtraction smuwouluvvbn-1
<operator>.subtraction ch-'A'
<operator>.subtraction smuwouluvvbn-1
<operator>.subtraction maencustsmoh[hjgffcuwoicv]-'A'
<operator>.postIncrement smuwouluvvbn++
<operator>.addressOf &vktbnzuqcncu
<operator>.addressOf &d
<operator>.addressOf &n
<operator>.addressOf &yflyongbbkow
<operator>.addressOf &beb
<operator>.addressOf &nbe
<operator>.indirectIndexAccess xzryjfsomeke[yflyongbbkow-'A'][beb-'A']
<operator>.addressOf &yflyongbbkow
<operator>.addressOf &beb
<operator>.indirectIndexAccess govbshzesyzl[yflyongbbkow-'A'][beb-'A']
<operator>.indirectIndexAccess maencustsmoh[hjgffcuwoicv]
<operator>.indirectIndexAccess xzryjfsomeke[yflyongbbkow-'A']
<operator>.indirectIndexAccess xzryjfsomeke[beb-'A'][yflyongbbkow-'A']
<operator>.indirectIndexAccess govbshzesyzl[yflyongbbkow-'A']
<operator>.indirectIndexAccess govbshzesyzl[beb-'A'][yflyongbbkow-'A']
<operator>.indirectIndexAccess xzryjfsomeke[maencustsmoh[smuwouluvvbn-1]-'A'][ch-'A']
<operator>.indirectIndexAccess xzryjfsomeke[beb-'A']
<operator>.indirectIndexAccess govbshzesyzl[beb-'A']
<operator>.indirectIndexAccess xzryjfsomeke[maencustsmoh[smuwouluvvbn-1]-'A']
<operator>.indirectIndexAccess maencustsmoh[smuwouluvvbn-1]
<operator>.indirectIndexAccess xzryjfsomeke[maencustsmoh[smuwouluvvbn-1]-'A'][ch-'A']
<operator>.indirectIndexAccess xzryjfsomeke[maencustsmoh[smuwouluvvbn-1]-'A']
<operator>.indirectIndexAccess maencustsmoh[smuwouluvvbn-1]
<operator>.indirectIndexAccess govbshzesyzl[maencustsmoh[hjgffcuwoicv]-'A'][ch-'A']
<operator>.indirectIndexAccess maencustsmoh[smuwouluvvbn-1]
<operator>.indirectIndexAccess govbshzesyzl[maencustsmoh[hjgffcuwoicv]-'A']
<operator>.indirectIndexAccess maencustsmoh[smuwouluvvbn++]
<operator>.indirectIndexAccess maencustsmoh[hjgffcuwoicv]
>>>PDG&96 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->34 0->35 0->37 0->38 0->39 0->40 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 2->1 2->1 2->4 3->1 3->1 3->1 3->19 4->1 4->1 4->1 4->6 4->15 5->1 6->1 6->1 6->1 6->6 6->7 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->19 6->20 6->21 6->22 6->23 6->24 6->25 6->27 6->28 6->34 6->68 6->69 6->70 7->1 7->6 8->5 9->2 9->2 10->3 10->3 11->1 11->6 12->1 12->1 13->1 13->1 13->1 14->1 14->25 14->45 15->1 15->1 15->16 15->22 15->29 16->1 16->1 16->17 16->23 16->31 17->1 17->1 17->18 17->24 18->1 18->1 18->15 18->40 19->1 19->7 19->20 20->1 20->21 20->35 20->42 21->1 21->1 21->19 22->1 22->1 22->15 22->22 22->29 22->30 22->38 22->43 22->46 22->47 22->54 22->71 22->72 22->73 22->74 22->79 22->80 22->84 23->1 23->1 23->16 23->23 23->31 23->32 23->39 23->44 23->48 23->49 23->55 23->75 23->76 23->77 23->81 23->82 23->85 24->1 24->1 24->17 24->24 24->33 24->36 24->40 24->45 25->1 25->1 25->1 25->25 25->26 25->26 25->35 25->42 25->78 26->1 26->25 27->12 28->13 29->1 29->1 29->1 29->1 29->16 29->30 29->31 29->31 29->38 29->43 29->44 29->46 29->47 29->48 29->54 30->1 30->1 30->1 31->1 31->1 31->1 31->17 31->29 31->29 31->43 31->44 31->46 31->48 31->49 31->55 32->1 32->1 32->1 33->1 33->1 33->1 33->50 33->58 33->60 33->64 34->1 34->25 35->1 35->1 35->21 35->42 35->66 36->1 36->1 36->1 36->41 36->41 36->51 36->53 36->57 36->58 36->59 36->61 36->65 36->87 36->88 36->89 36->92 38->1 38->1 38->30 39->1 39->32 40->1 40->15 40->33 41->1 41->1 41->1 41->56 41->61 42->1 42->35 43->54 44->55 45->36 45->36 45->50 45->51 45->56 45->57 45->63 45->63 45->83 45->86 45->90 46->47 47->1 47->29 47->31 47->46 47->48 48->49 49->1 49->29 49->31 49->46 49->48 50->1 50->58 50->60 50->64 51->52 51->53 51->53 51->64 51->66 51->91 51->93 51->95 52->1 52->51 53->1 53->60 53->62 53->67 53->67 53->94 54->1 54->29 54->31 54->43 54->44 55->1 55->29 55->31 55->43 55->44 56->1 56->61 57->65 58->1 59->51 60->1 60->1 60->1 62->1 62->25 62->45 63->51 63->57 64->1 64->60 65->25 65->45 66->1 66->35 67->25 67->45 91->51 91->52
>>>Token int main ( ) { int hjgffcuwoicv ; FILE * fin = fopen ( " " , " " ) ; FILE * fout = fopen ( " " , " " ) ; int smvwxoeqfdos , tc ; fscanf ( fin , " " , & smvwxoeqfdos ) ; for ( tc = 1 ; tc <= smvwxoeqfdos ; tc ++ ) { char yflyongbbkow , beb , nbe , ch ; int vktbnzuqcncu , d , n ; char xzryjfsomeke [ SIZE ] [ SIZE ] = { 0 } ; int govbshzesyzl [ SIZE ] [ SIZE ] = { 0 } ; char maencustsmoh [ MAXLEN ] ; int smuwouluvvbn = 0 ; fscanf ( fin , " " , & vktbnzuqcncu ) ; while ( vktbnzuqcncu -- ) { fscanf ( fin , " " , & yflyongbbkow , & beb , & nbe ) ; xzryjfsomeke [ yflyongbbkow - ' ' ] [ beb - ' ' ] = xzryjfsomeke [ beb - ' ' ] [ yflyongbbkow - ' ' ] = nbe ; } fscanf ( fin , " " , & d ) ; while ( d -- ) { fscanf ( fin , " " , & yflyongbbkow , & beb ) ; govbshzesyzl [ yflyongbbkow - ' ' ] [ beb - ' ' ] = govbshzesyzl [ beb - ' ' ] [ yflyongbbkow - ' ' ] = 1 ; } fscanf ( fin , " " , & n ) ; fgetc ( fin ) ; while ( n -- ) { ch = fgetc ( fin ) ; if ( smuwouluvvbn > 0 && xzryjfsomeke [ maencustsmoh [ smuwouluvvbn - 1 ] - ' ' ] [ ch - ' ' ] ) maencustsmoh [ smuwouluvvbn - 1 ] = xzryjfsomeke [ maencustsmoh [ smuwouluvvbn - 1 ] - ' ' ] [ ch - ' ' ] ; else { for ( hjgffcuwoicv = 0 ; hjgffcuwoicv < smuwouluvvbn ; hjgffcuwoicv ++ ) if ( govbshzesyzl [ maencustsmoh [ hjgffcuwoicv ] - ' ' ] [ ch - ' ' ] ) break ; if ( hjgffcuwoicv == smuwouluvvbn ) maencustsmoh [ smuwouluvvbn ++ ] = ch ; else smuwouluvvbn = 0 ; } } fprintf ( fout , " " , tc ) ; fprintf ( fout , " " ) ; for ( hjgffcuwoicv = 0 ; hjgffcuwoicv < smuwouluvvbn ; hjgffcuwoicv ++ ) { if ( hjgffcuwoicv ) fprintf ( fout , " " ) ; fprintf ( fout , " " , maencustsmoh [ hjgffcuwoicv ] ) ; } fprintf ( fout , " \n " ) ; } return 0 ; }
>>>Func
METHOD qfllyxvqmwqt
METHOD_RETURN nnzcqdsvgodzchar
scanf scanf("%1s",kqzjnpptxnlk)
RETURN return kqzjnpptxnlk[0]; return kqzjnpptxnlk[0];
>>>PDG&4 0->2 2->1 3->1
>>>Token static nnzcqdsvgodzchar qfllyxvqmwqt ( ) { char kqzjnpptxnlk [ 2 ] ; scanf ( " " , kqzjnpptxnlk ) ; return kqzjnpptxnlk [ 0 ] ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
<operator>.assignment in=fopen("input.txt","rt")
<operator>.assignment out=fopen("output.txt","wt")
fgets fgets(bghbepwcvics,110,in)
<operator>.assignment T=atoi(bghbepwcvics)
fclose fclose(in)
fclose fclose(out)
RETURN return 0; return 0;
<operator>.lessEqualsThan zipaavzgdhbr<=T
<operator>.postIncrement zipaavzgdhbr++
LITERAL 0 return 0;
fopen fopen("input.txt","rt")
fopen fopen("output.txt","wt")
atoi atoi(bghbepwcvics)
<operator>.assignment zipaavzgdhbr=1
fgets fgets(bghbepwcvics,110,in)
<operator>.assignment N=atoi(bghbepwcvics)
fprintf fprintf(out,"Case #%d:\n",zipaavzgdhbr)
<operator>.lessThan i<N
<operator>.postIncrement i++
<operator>.lessThan i<N
<operator>.postIncrement i++
<operator>.lessThan i<N
<operator>.postIncrement i++
atoi atoi(bghbepwcvics)
<operator>.assignment i=0
fgets fgets(bghbepwcvics,110,in)
<operator>.assignment num_games[i]=0
<operator>.assignment wins=0
<operator>.assignment regirheuumcz[i]=(double)wins/num_games[i]
<operator>.assignment i=0
<operator>.assignment sum_owp=0.0
<operator>.assignment OWP[i]=sum_owp/num_games[i]
<operator>.assignment i=0
<operator>.assignment sum_owp=0.0
<operator>.assignment OOWP[i]=sum_owp/num_games[i]
fprintf fprintf(out,"%.12f\n",0.25 *regirheuumcz[i]+0.5 *OWP[i]+0.25 *OOWP[i])
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.lessThan j<N
<operator>.postIncrement j++
<operator>.assignment j=0
<operator>.division (double)wins/num_games[i]
<operator>.assignment j=0
<operator>.greaterEqualsThan schedule[i][j]>=0
<operator>.division sum_owp/num_games[i]
<operator>.assignment j=0
<operator>.greaterEqualsThan schedule[i][j]>=0
<operator>.division sum_owp/num_games[i]
<operator>.addition 0.25 *regirheuumcz[i]+0.5 *OWP[i]+0.25 *OOWP[i]
<operator>.equals bghbepwcvics[j]=='.'
<operator>.cast (double)wins
<operator>.assignment sum=0
<operator>.assignmentPlus sum_owp+=(double)sum/(num_games[j]-1)
<operator>.assignmentPlus sum_owp+=OWP[j]
<operator>.addition 0.25 *regirheuumcz[i]+0.5 *OWP[i]
<operator>.multiplication 0.25 *OOWP[i]
<operator>.assignment schedule[i][j]=-1
<operator>.lessThan k<i
<operator>.postIncrement k++
<operator>.lessThan k<N
<operator>.postIncrement k++
<operator>.multiplication 0.25 *regirheuumcz[i]
<operator>.multiplication 0.5 *OWP[i]
<operator>.assignment schedule[i][j]=bghbepwcvics[j]-'0'
<operator>.assignmentPlus num_games[i]+=1
<operator>.assignmentPlus wins+=schedule[i][j]
<operator>.assignment k=0
<operator>.greaterEqualsThan schedule[j][k]>=0
<operator>.assignment k=i+1
<operator>.greaterEqualsThan schedule[j][k]>=0
<operator>.division (double)sum/(num_games[j]-1)
<operator>.minus -1
<operator>.assignmentPlus sum+=schedule[j][k]
<operator>.assignmentPlus sum+=schedule[j][k]
<operator>.cast (double)sum
<operator>.subtraction num_games[j]-1
<operator>.subtraction bghbepwcvics[j]-'0'
<operator>.addition i+1
<operator>.indirectIndexAccess num_games[i]
<operator>.indirectIndexAccess regirheuumcz[i]
<operator>.indirectIndexAccess OWP[i]
<operator>.indirectIndexAccess OOWP[i]
<operator>.indirectIndexAccess num_games[i]
<operator>.indirectIndexAccess num_games[i]
<operator>.indirectIndexAccess num_games[i]
UNKNOWN double double
<operator>.indirectIndexAccess schedule[i][j]
<operator>.indirectIndexAccess schedule[i][j]
<operator>.indirectIndexAccess OOWP[i]
<operator>.indirectIndexAccess bghbepwcvics[j]
<operator>.indirectIndexAccess schedule[i]
<operator>.indirectIndexAccess schedule[i]
<operator>.indirectIndexAccess OWP[j]
<operator>.indirectIndexAccess regirheuumcz[i]
<operator>.indirectIndexAccess OWP[i]
<operator>.indirectIndexAccess schedule[i][j]
<operator>.indirectIndexAccess schedule[i]
<operator>.indirectIndexAccess schedule[i][j]
<operator>.indirectIndexAccess num_games[i]
<operator>.indirectIndexAccess schedule[i][j]
<operator>.indirectIndexAccess schedule[j][k]
<operator>.indirectIndexAccess schedule[j][k]
UNKNOWN double double
<operator>.indirectIndexAccess num_games[j]
<operator>.indirectIndexAccess schedule[i]
<operator>.indirectIndexAccess bghbepwcvics[j]
<operator>.indirectIndexAccess schedule[i]
<operator>.indirectIndexAccess schedule[j]
<operator>.indirectIndexAccess schedule[j][k]
<operator>.indirectIndexAccess schedule[j]
<operator>.indirectIndexAccess schedule[j][k]
<operator>.indirectIndexAccess schedule[j]
<operator>.indirectIndexAccess schedule[j]
>>>PDG&118 0->2 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->35 0->36 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->58 0->60 0->62 0->63 0->64 0->65 0->66 0->67 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 2->1 3->1 3->1 3->5 4->1 4->1 4->8 4->19 5->1 5->7 5->15 5->17 6->1 6->1 6->10 7->1 7->1 8->1 8->1 9->1 10->1 10->1 10->1 10->10 10->11 10->17 10->18 10->19 10->19 10->20 10->22 10->24 10->26 10->27 10->32 10->35 11->1 11->10 12->9 13->3 13->3 14->4 14->4 15->1 15->6 15->17 16->1 16->10 17->1 17->7 17->26 17->28 18->1 18->1 18->20 19->1 19->8 19->11 19->38 20->20 20->21 20->21 20->22 20->28 20->29 20->30 20->31 20->39 20->39 20->45 20->46 20->55 20->83 20->84 20->87 20->90 21->1 21->20 22->22 22->23 22->23 22->24 22->33 22->34 22->41 22->41 22->47 22->49 22->62 22->85 22->88 23->1 23->22 24->1 24->1 24->1 24->24 24->25 24->25 24->36 24->37 24->38 24->43 24->43 24->50 24->52 24->53 24->59 24->60 24->66 24->67 24->86 24->89 24->93 24->98 24->99 25->1 25->24 26->1 26->17 26->18 26->28 27->20 28->1 28->1 28->7 28->17 28->17 28->54 28->81 29->1 29->46 29->69 30->1 30->46 30->55 30->70 31->1 31->1 31->1 31->66 32->22 33->1 33->49 33->57 34->1 34->1 34->1 34->67 35->1 35->24 36->1 36->52 36->58 37->1 37->1 37->60 38->1 38->1 38->8 38->19 39->1 39->1 39->20 39->39 39->40 39->40 39->54 39->94 40->1 40->39 41->1 41->1 41->22 41->41 41->42 41->42 41->48 41->64 41->91 41->95 42->1 42->41 43->1 43->1 43->24 43->43 43->44 43->44 43->51 43->92 43->96 44->1 44->43 45->1 45->39 46->1 46->1 46->31 46->31 46->49 46->52 47->1 47->41 48->1 48->1 48->51 48->56 48->57 48->62 48->64 48->71 48->73 48->75 48->79 48->80 48->82 48->107 48->108 49->1 49->1 49->34 49->34 49->52 50->1 50->43 51->1 51->1 51->48 51->58 51->97 52->1 52->1 52->37 52->37 52->49 53->1 53->1 54->1 54->1 54->17 54->26 54->28 54->61 54->68 54->69 54->70 54->76 54->81 54->81 54->100 54->101 54->102 54->103 54->104 54->109 54->110 54->111 55->1 56->1 56->75 56->77 56->78 56->79 57->1 57->1 57->49 58->1 58->1 58->52 59->1 59->1 60->1 60->38 60->38 60->53 60->53 61->1 61->1 61->1 61->48 61->51 62->1 62->23 62->62 62->63 62->63 62->72 62->73 62->82 62->105 62->112 63->1 63->62 64->1 64->1 64->41 64->64 64->65 64->65 64->74 64->106 64->114 65->1 65->64 66->1 66->38 66->38 66->53 66->53 66->59 66->59 67->1 67->38 67->38 67->53 67->53 67->59 67->59 68->1 68->1 68->48 68->51 68->70 69->1 69->46 70->1 70->1 70->46 70->55 71->1 71->62 72->1 72->1 72->74 72->77 72->77 72->113 72->116 73->1 73->1 73->64 74->1 74->1 74->72 74->78 74->78 74->115 74->117 75->1 75->1 75->57 75->57 76->61 77->1 77->1 77->75 77->78 77->79 78->1 78->1 78->75 78->79 79->1 80->1 80->75 80->75 81->1 81->17 81->26 81->28 81->54 81->68 81->68
>>>Token int main ( void ) { char bghbepwcvics [ 110 ] ; int zipaavzgdhbr , T , i , j , k , N , num_games [ 100 ] , schedule [ 100 ] [ 100 ] , wins , sum ; double regirheuumcz [ 100 ] , OWP [ 100 ] , OOWP [ 100 ] , sum_owp ; FILE * in , * out ; in = fopen ( " " , " " ) ; out = fopen ( " " , " " ) ; fgets ( bghbepwcvics , 110 , in ) ; T = atoi ( bghbepwcvics ) ; for ( zipaavzgdhbr = 1 ; zipaavzgdhbr <= T ; zipaavzgdhbr ++ ) { fgets ( bghbepwcvics , 110 , in ) ; N = atoi ( bghbepwcvics ) ; for ( i = 0 ; i < N ; i ++ ) { fgets ( bghbepwcvics , 110 , in ) ; num_games [ i ] = 0 ; wins = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( bghbepwcvics [ j ] == ' ' ) schedule [ i ] [ j ] = -1 ; else { schedule [ i ] [ j ] = bghbepwcvics [ j ] - ' ' ; num_games [ i ] += 1 ; wins += schedule [ i ] [ j ] ; } } regirheuumcz [ i ] = ( double ) wins / num_games [ i ] ; } for ( i = 0 ; i < N ; i ++ ) { sum_owp = 0.0 ; for ( j = 0 ; j < N ; j ++ ) if ( schedule [ i ] [ j ] >= 0 ) { sum = 0 ; for ( k = 0 ; k < i ; k ++ ) if ( schedule [ j ] [ k ] >= 0 ) sum += schedule [ j ] [ k ] ; for ( k = i + 1 ; k < N ; k ++ ) if ( schedule [ j ] [ k ] >= 0 ) sum += schedule [ j ] [ k ] ; sum_owp += ( double ) sum / ( num_games [ j ] - 1 ) ; } OWP [ i ] = sum_owp / num_games [ i ] ; } fprintf ( out , " \n " , zipaavzgdhbr ) ; for ( i = 0 ; i < N ; i ++ ) { sum_owp = 0.0 ; for ( j = 0 ; j < N ; j ++ ) if ( schedule [ i ] [ j ] >= 0 ) sum_owp += OWP [ j ] ; OOWP [ i ] = sum_owp / num_games [ i ] ; fprintf ( out , " \n " , 0.25 * regirheuumcz [ i ] + 0.5 * OWP [ i ] + 0.25 * OOWP [ i ] ) ; } } fclose ( in ) ; fclose ( out ) ; return 0 ; }
>>>Func
METHOD azdertobznzc
METHOD_RETURN esdqsfqutmrbint
PARAM int awcmyyrwiqgn
PARAM int fnhnvegtxyha
RETURN return awcmyyrwiqgn<fnhnvegtxyha?awcmyyrwiqgn:fnhnvegtxyha; return awcmyyrwiqgn<fnhnvegtxyha?awcmyyrwiqgn:fnhnvegtxyha;
<operator>.conditional awcmyyrwiqgn<fnhnvegtxyha?awcmyyrwiqgn:fnhnvegtxyha
<operator>.lessThan awcmyyrwiqgn<fnhnvegtxyha
>>>PDG&7 0->2 0->3 0->5 0->6 2->6 3->6 4->1 5->1 5->1 5->1 5->1 5->4 6->5 6->5
>>>Token inline esdqsfqutmrbint azdertobznzc ( int awcmyyrwiqgn , int fnhnvegtxyha ) { return awcmyyrwiqgn < fnhnvegtxyha ? awcmyyrwiqgn : fnhnvegtxyha ; }
>>>Func
METHOD xggiffpsgbgf
METHOD_RETURN void
PARAM int ghrsllbavaqg
PARAM int fhkjwflkzbzr
PARAM int jjsbnxgqurso
PARAM enum fmmunxnoqtkd*res
<operator>.assignment *res=_false
RETURN return   ; return   ;
<operator>.equals jjsbnxgqurso==0
<operator>.equals jjsbnxgqurso==100
<operator>.lessEqualsThan astmvpyisnxb<=ghrsllbavaqg
<operator>.postIncrement astmvpyisnxb++
RETURN return   ; return   ;
RETURN return   ; return   ;
<operator>.assignment astmvpyisnxb=1
<operator>.equals fhkjwflkzbzr==0
<operator>.equals fhkjwflkzbzr==100
<operator>.equals ((((astmvpyisnxb *fhkjwflkzbzr)/100)*100)-(astmvpyisnxb *fhkjwflkzbzr))==0
<operator>.assignment *res=_true
<operator>.assignment *res=_true
<operator>.assignment *res=_true
<operator>.subtraction (((astmvpyisnxb *fhkjwflkzbzr)/100)*100)-(astmvpyisnxb *fhkjwflkzbzr)
<operator>.multiplication ((astmvpyisnxb *fhkjwflkzbzr)/100)*100
<operator>.multiplication astmvpyisnxb *fhkjwflkzbzr
<operator>.division (astmvpyisnxb *fhkjwflkzbzr)/100
<operator>.multiplication astmvpyisnxb *fhkjwflkzbzr
<operator>.indirection *res
<operator>.indirection *res
<operator>.indirection *res
>>>PDG&29 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->25 2->1 2->10 3->15 3->16 3->25 4->8 5->1 6->1 6->1 6->1 7->1 8->1 8->1 8->9 8->9 8->12 8->15 9->7 9->10 9->13 9->14 9->16 10->17 10->21 10->22 10->23 10->24 10->25 10->25 11->10 12->1 13->1 14->10 15->1 15->1 15->18 15->26 16->19 16->27 17->10 17->11 17->20 17->28 18->1 18->1 18->1 21->17 21->17 22->21 22->21 23->11 23->21 23->21 23->25 24->22 24->22 25->23 25->23 25->24 25->24
>>>Token void xggiffpsgbgf ( int ghrsllbavaqg , int fhkjwflkzbzr , int jjsbnxgqurso , enum fmmunxnoqtkd * res ) { int astmvpyisnxb , j ; * res = _false ; if ( jjsbnxgqurso == 0 ) { if ( fhkjwflkzbzr == 0 ) { * res = _true ; } return ; } if ( jjsbnxgqurso == 100 ) { if ( fhkjwflkzbzr == 100 ) { * res = _true ; } return ; } for ( astmvpyisnxb = 1 ; astmvpyisnxb <= ghrsllbavaqg ; astmvpyisnxb ++ ) { if ( ( ( ( ( astmvpyisnxb * fhkjwflkzbzr ) / 100 ) * 100 ) - ( astmvpyisnxb * fhkjwflkzbzr ) ) == 0 ) { * res = _true ; break ; } } return ; }
>>>Func
METHOD main
METHOD_RETURN int
scanf scanf("%d",&vhnlzgilqlnu)
memset memset(g 0 sizeof(g))
build_graph build_graph(0,0)
RETURN return 0; return 0;
<operator>.lessEqualsThan i<=vhnlzgilqlnu
<operator>.postIncrement i++
LITERAL 0 return 0;
<operator>.assignment i=1
scanf scanf("%d %d\n",&mbfpzvsjkpxq,&n)
memset memset(map 0 sizeof(map))
memset memset(ecgcdzjhfewk 0 sizeof(ecgcdzjhfewk))
<operator>.assignment nsvcjlbrrpkc=0
printf printf("Case #%d: %d\n",i,nsvcjlbrrpkc)
<operator>.lessThan j<mbfpzvsjkpxq
<operator>.postIncrement j++
<operator>.lessThan j<p[n]
<operator>.postIncrement j++
<operator>.lessThan j<mbfpzvsjkpxq
<operator>.postIncrement j++
<operator>.lessThan j<p[n]
<operator>.postIncrement j++
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.equals (map[0]&j)==0
<operator>.assignment j=1
<operator>.lessThan k<p[n]
<operator>.postIncrement k++
<operator>.assignment j=0
<operator>.greaterThan ecgcdzjhfewk[mbfpzvsjkpxq-1][j]>nsvcjlbrrpkc
<operator>.lessThan k<n
<operator>.postIncrement k++
<operator>.assignment ecgcdzjhfewk[0][j]=cnt[j]
<operator>.assignment k=0
<operator>.equals (map[j]&k)==0
<operator>.assignment nsvcjlbrrpkc=ecgcdzjhfewk[mbfpzvsjkpxq-1][j]
<operator>.assignment k=0
<operator>.equals getchar()=='x'
<operator>.and map[0]&j
<operator>.assignmentPlus map[j]+=p[k]
<operator>.and map[j]&k
<operator>.lessThan l<p[n]
<operator>.postIncrement l++
<operator>.assignment l=0
<operator>.logicalAnd g[l][k]==1&&ecgcdzjhfewk[j-1][l]+cnt[k]>ecgcdzjhfewk[j][k]
<operator>.subtraction mbfpzvsjkpxq-1
<operator>.assignment ecgcdzjhfewk[j][k]=ecgcdzjhfewk[j-1][l]+cnt[k]
<operator>.subtraction mbfpzvsjkpxq-1
<operator>.equals g[l][k]==1
<operator>.greaterThan ecgcdzjhfewk[j-1][l]+cnt[k]>ecgcdzjhfewk[j][k]
<operator>.addition ecgcdzjhfewk[j-1][l]+cnt[k]
<operator>.addition ecgcdzjhfewk[j-1][l]+cnt[k]
<operator>.subtraction j-1
<operator>.subtraction j-1
<operator>.addressOf &mbfpzvsjkpxq
<operator>.addressOf &n
<operator>.sizeOf sizeof(map)
<operator>.sizeOf sizeof(ecgcdzjhfewk)
scanf scanf("\n")
<operator>.indirectIndexAccess p[n]
<operator>.indirectIndexAccess p[n]
<operator>.indirectIndexAccess p[n]
<operator>.indirectIndexAccess ecgcdzjhfewk[mbfpzvsjkpxq-1][j]
<operator>.indirectIndexAccess map[0]
<operator>.indirectIndexAccess ecgcdzjhfewk[0][j]
<operator>.indirectIndexAccess cnt[j]
<operator>.indirectIndexAccess ecgcdzjhfewk[mbfpzvsjkpxq-1]
<operator>.indirectIndexAccess ecgcdzjhfewk[mbfpzvsjkpxq-1][j]
getchar getchar()
<operator>.indirectIndexAccess ecgcdzjhfewk[0]
<operator>.indirectIndexAccess map[j]
<operator>.indirectIndexAccess ecgcdzjhfewk[mbfpzvsjkpxq-1]
<operator>.indirectIndexAccess map[j]
<operator>.indirectIndexAccess p[k]
<operator>.indirectIndexAccess p[n]
<operator>.indirectIndexAccess g[l][k]
<operator>.indirectIndexAccess ecgcdzjhfewk[j][k]
<operator>.indirectIndexAccess ecgcdzjhfewk[j][k]
<operator>.indirectIndexAccess g[l]
<operator>.indirectIndexAccess ecgcdzjhfewk[j-1][l]
<operator>.indirectIndexAccess cnt[k]
<operator>.indirectIndexAccess ecgcdzjhfewk[j]
<operator>.indirectIndexAccess ecgcdzjhfewk[j]
<operator>.indirectIndexAccess ecgcdzjhfewk[j-1][l]
<operator>.indirectIndexAccess cnt[k]
<operator>.indirectIndexAccess ecgcdzjhfewk[j-1]
<operator>.indirectIndexAccess ecgcdzjhfewk[j-1]
>>>PDG&88 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->34 0->35 0->37 0->38 0->39 0->41 0->42 0->43 0->44 0->46 0->48 0->49 0->53 0->54 2->1 2->6 3->1 3->1 4->1 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->12 6->13 6->14 6->14 6->15 6->17 6->19 6->21 6->23 6->24 6->26 6->29 6->55 6->56 6->57 6->58 6->60 6->61 7->1 7->6 8->5 9->1 9->6 10->1 10->1 10->15 10->19 10->46 10->48 11->1 11->1 11->39 11->40 11->41 12->1 12->1 13->1 13->14 13->30 14->1 14->1 14->7 15->15 15->16 15->16 15->19 15->31 15->37 15->59 16->1 16->15 17->17 17->18 17->21 17->25 17->27 17->39 17->39 17->60 17->64 18->1 18->17 19->1 19->1 19->10 19->15 19->19 19->20 19->20 19->27 19->34 19->46 19->53 19->54 19->62 20->1 20->19 21->1 21->1 21->1 21->17 21->21 21->22 21->22 21->30 21->46 21->61 21->63 21->67 22->1 22->21 23->15 24->17 25->1 25->1 25->33 25->65 25->66 25->70 26->1 26->19 27->1 27->1 27->21 27->27 27->28 27->35 27->41 27->41 27->42 27->62 27->71 28->1 28->27 29->1 29->21 30->1 30->1 30->14 30->36 30->36 30->48 30->68 30->72 31->1 31->1 31->1 31->31 31->32 31->32 31->38 31->69 32->1 32->31 33->1 33->1 33->1 34->1 34->27 35->1 35->1 35->42 35->44 35->75 36->1 36->1 36->14 36->30 37->1 37->31 38->1 38->1 38->40 38->73 38->74 39->1 39->11 39->18 39->25 39->25 40->1 40->1 40->1 40->11 40->41 41->1 41->11 41->28 41->35 41->35 41->40 42->1 42->1 42->27 42->42 42->43 42->43 42->45 42->49 42->75 42->76 42->79 43->1 43->42 44->1 44->42 45->1 45->1 45->1 45->47 45->52 45->54 45->78 45->83 45->84 45->85 45->87 46->1 46->10 46->15 46->48 47->1 47->1 47->1 47->50 48->1 48->10 48->15 48->46 49->1 49->45 49->45 49->50 49->51 49->53 49->77 49->80 49->81 49->82 49->86 50->1 50->1 50->45 50->45 51->1 51->1 52->1 52->1 53->20 53->54 54->20 54->53
>>>Token int main ( ) { int vhnlzgilqlnu , i ; scanf ( " " , & vhnlzgilqlnu ) ; memset ( g , 0 , sizeof ( g ) ) ; build_graph ( 0 , 0 ) ; for ( i = 1 ; i <= vhnlzgilqlnu ; i ++ ) { int mbfpzvsjkpxq , n , j , k , l ; scanf ( " \n " , & mbfpzvsjkpxq , & n ) ; memset ( map , 0 , sizeof ( map ) ) ; for ( j = 0 ; j < mbfpzvsjkpxq ; j ++ ) { for ( k = 0 ; k < n ; k ++ ) if ( getchar ( ) == ' ' ) map [ j ] += p [ k ] ; scanf ( " \n " ) ; } int ecgcdzjhfewk [ MAXLEN ] [ 1024 ] ; memset ( ecgcdzjhfewk , 0 , sizeof ( ecgcdzjhfewk ) ) ; for ( j = 0 ; j < p [ n ] ; j ++ ) if ( ( map [ 0 ] & j ) == 0 ) ecgcdzjhfewk [ 0 ] [ j ] = cnt [ j ] ; for ( j = 1 ; j < mbfpzvsjkpxq ; j ++ ) for ( k = 0 ; k < p [ n ] ; k ++ ) if ( ( map [ j ] & k ) == 0 ) for ( l = 0 ; l < p [ n ] ; l ++ ) if ( g [ l ] [ k ] == 1 && ecgcdzjhfewk [ j - 1 ] [ l ] + cnt [ k ] > ecgcdzjhfewk [ j ] [ k ] ) ecgcdzjhfewk [ j ] [ k ] = ecgcdzjhfewk [ j - 1 ] [ l ] + cnt [ k ] ; int nsvcjlbrrpkc = 0 ; for ( j = 0 ; j < p [ n ] ; j ++ ) if ( ecgcdzjhfewk [ mbfpzvsjkpxq - 1 ] [ j ] > nsvcjlbrrpkc ) nsvcjlbrrpkc = ecgcdzjhfewk [ mbfpzvsjkpxq - 1 ] [ j ] ; printf ( " \n " , i , nsvcjlbrrpkc ) ; } return 0 ; }
>>>Func
METHOD qxhorqbugvrj
METHOD_RETURN void
PARAM FILE *input
<operator>.assignment *out=fopen("/Users/vribeiro/Desktop/A-small-attempt0.out.txt","w")
fscanf fscanf(input,"%d",&tpkunllwxobb)
fclose fclose(out)
<operator>.lessThan t<tpkunllwxobb
<operator>.postIncrement t++
fopen fopen("/Users/vribeiro/Desktop/A-small-attempt0.out.txt","w")
<operator>.assignment t=0
fscanf fscanf(input,"%d",&N)
<operator>.assignment jjcshgjekvkc=0
<operator>.assignment I[1]=0
<operator>.assignment I[2]=0
<operator>.assignment jjcshgjekvkc=0
<operator>.assignment I[1]=0
<operator>.assignment I[2]=0
<operator>.assignment pos[1]=1
<operator>.assignment pos[2]=1
fprintf fprintf(out,"Case #%d: %d\n",t+1,gplracfgaodm)
<operator>.lessThan n<N
<operator>.postIncrement n++
<operator>.lessThan jjcshgjekvkc<N
<operator>.postIncrement gplracfgaodm++
<operator>.assignment n=0
fscanf fscanf(input,"%c",&briywvwiumvx)
hxjppglfupiv hxjppglfupiv(briywvwiumvx=='O'||briywvwiumvx=='B')
BLOCK <empty> <empty>
<operator>.assignment gplracfgaodm=0
<operator>.assignment xgkebdlhqrcy=krdloxyecwgm[jjcshgjekvkc]/1000
<operator>.assignment cur_btn=krdloxyecwgm[jjcshgjekvkc]%1000
<operator>.addition t+1
fscanf fscanf(input,"%d",&uiyttppievlw)
hxjppglfupiv hxjppglfupiv(briywvwiumvx=='B')
BLOCK <empty> <empty>
<operator>.assignmentPlus krdloxyecwgm[jjcshgjekvkc]+=uiyttppievlw
<operator>.postIncrement jjcshgjekvkc++
<operator>.lessEqualsThan b<=2
<operator>.postIncrement b++
<operator>.logicalOr briywvwiumvx=='O'||briywvwiumvx=='B'
<operator>.assignment agrqgejvfvbl[1][I[1]]=uiyttppievlw
<operator>.postIncrement I[1]++
<operator>.assignment krdloxyecwgm[jjcshgjekvkc]=1000
<operator>.division krdloxyecwgm[jjcshgjekvkc]/1000
<operator>.modulo krdloxyecwgm[jjcshgjekvkc]%1000
<operator>.assignment b=1
hxjppglfupiv hxjppglfupiv(b==xgkebdlhqrcy)
BLOCK <empty> <empty>
<operator>.equals briywvwiumvx=='O'
<operator>.equals briywvwiumvx=='B'
<operator>.equals briywvwiumvx=='B'
hxjppglfupiv hxjppglfupiv(pos[b]-agrqgejvfvbl[b][I[b]]==0)
BLOCK <empty> <empty>
<operator>.equals b==xgkebdlhqrcy
<operator>.postIncrement I[b]++
<operator>.postIncrement jjcshgjekvkc++
<operator>.equals pos[b]-agrqgejvfvbl[b][I[b]]==0
<operator>.subtraction pos[b]-agrqgejvfvbl[b][I[b]]
<operator>.addressOf &N
<operator>.indirectIndexAccess I[1]
<operator>.indirectIndexAccess I[2]
<operator>.indirectIndexAccess I[1]
<operator>.indirectIndexAccess I[2]
<operator>.indirectIndexAccess pos[1]
<operator>.indirectIndexAccess pos[2]
UNKNOWN,),)
UNKNOWN else     {n--;} else     {n--;}
<operator>.addressOf &briywvwiumvx
UNKNOWN,),)
UNKNOWN else      hxjppglfupiv (briywvwiumvx=='O'){agrqgejvfvbl[2][I[2]]=uiyttppievlw;I[2]++;krdloxyecwgm[jjcshgjekvkc]=2000;} else      hxjppglfupiv (briywvwiumvx=='O'){agrqgejvfvbl[2][I[2]]=uiyttppievlw;I[2]++;krdloxyecwgm[jjcshgjekvkc]=2000;}
<operator>.addressOf &uiyttppievlw
<operator>.indirectIndexAccess krdloxyecwgm[jjcshgjekvkc]
<operator>.indirectIndexAccess krdloxyecwgm[jjcshgjekvkc]
<operator>.indirectIndexAccess krdloxyecwgm[jjcshgjekvkc]
UNKNOWN,),)
UNKNOWN else     {hxjppglfupiv(pos[b]-agrqgejvfvbl[b][I[b]]!=0){hxjppglfupiv(pos[b]>agrqgejvfvbl[b][I[b]]){pos[b]--;}else     {pos[b]++;}}} else     {hxjppglfupiv(pos[b]-agrqgejvfvbl[b][I[b]]!=0){hxjppglfupiv(pos[b]>agrqgejvfvbl[b][I[b]]){pos[b]--;}else     {pos[b]++;}}}
<operator>.indirectIndexAccess agrqgejvfvbl[1][I[1]]
<operator>.indirectIndexAccess I[1]
<operator>.indirectIndexAccess krdloxyecwgm[jjcshgjekvkc]
UNKNOWN,),)
UNKNOWN else     {hxjppglfupiv(pos[b]>agrqgejvfvbl[b][I[b]]){pos[b]--;}else     {pos[b]++;}} else     {hxjppglfupiv(pos[b]>agrqgejvfvbl[b][I[b]]){pos[b]--;}else     {pos[b]++;}}
<operator>.indirectIndexAccess agrqgejvfvbl[1]
<operator>.indirectIndexAccess I[1]
<operator>.indirectIndexAccess I[b]
<operator>.indirectIndexAccess pos[b]
<operator>.indirectIndexAccess agrqgejvfvbl[b][I[b]]
<operator>.indirectIndexAccess agrqgejvfvbl[b]
<operator>.indirectIndexAccess I[b]
>>>PDG&88 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->27 0->28 0->31 0->32 0->34 0->35 0->36 0->37 0->38 0->40 0->42 0->43 0->44 0->45 0->47 0->48 0->49 0->50 0->52 0->53 0->55 0->56 2->4 3->1 3->1 3->5 3->19 4->1 4->1 4->1 4->6 4->10 5->1 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->19 6->20 6->22 6->24 6->28 6->31 6->31 6->58 6->59 6->60 6->61 6->62 6->63 6->64 7->1 7->6 8->3 8->3 9->1 9->6 10->1 10->1 10->1 10->20 10->22 10->25 11->36 12->41 14->1 14->22 15->1 15->1 16->1 16->1 17->1 17->1 18->1 18->1 19->1 19->1 19->1 19->5 20->1 20->1 20->20 20->21 20->21 20->22 20->25 20->26 20->32 20->33 20->35 20->36 20->39 20->40 20->41 20->42 20->48 20->50 20->65 20->66 20->67 20->68 20->69 20->70 20->71 20->76 20->77 20->78 20->81 20->82 21->1 21->20 22->1 22->1 22->1 22->10 22->20 22->22 22->23 22->29 22->30 22->37 22->43 22->44 22->45 22->55 22->72 22->73 23->1 23->19 24->1 24->20 25->1 25->1 25->32 25->48 25->49 25->50 26->1 26->1 28->1 28->19 28->23 29->1 29->1 29->1 29->53 30->1 30->1 30->1 32->1 32->1 32->1 32->10 32->25 32->35 32->40 33->1 33->1 33->39 35->1 35->1 35->1 35->43 36->1 37->1 37->1 37->37 37->38 37->46 37->51 37->53 37->53 37->54 37->55 37->56 37->57 37->74 37->75 37->79 37->80 37->83 37->84 37->85 37->86 37->87 38->1 38->37 39->1 39->26 39->26 40->1 40->1 41->1 42->1 42->35 43->29 43->29 43->44 44->1 44->30 44->30 44->43 45->1 45->37 46->1 46->1 48->39 48->39 48->49 48->49 48->50 49->39 49->39 49->50 50->1 50->25 50->33 50->33 50->48 51->1 51->1 53->1 53->38 53->46 53->46 54->1 54->1 55->1 55->22 56->1 56->51 56->51 57->1 57->1 57->56 57->56
>>>Token void qxhorqbugvrj ( FILE * input ) { int tpkunllwxobb , t , N , n ; int jjcshgjekvkc , b ; int gplracfgaodm ; char briywvwiumvx ; int uiyttppievlw ; int krdloxyecwgm [ 101 ] ; int agrqgejvfvbl [ 3 ] [ 101 ] , I [ 3 ] , pos [ 3 ] ; int xgkebdlhqrcy , cur_btn ; FILE * out = fopen ( " " , " " ) ; fscanf ( input , " " , & tpkunllwxobb ) ; for ( t = 0 ; t < tpkunllwxobb ; t ++ ) { fscanf ( input , " " , & N ) ; jjcshgjekvkc = 0 ; I [ 1 ] = 0 ; I [ 2 ] = 0 ; for ( n = 0 ; n < N ; n ++ ) { fscanf ( input , " " , & briywvwiumvx ) ; hxjppglfupiv ( briywvwiumvx == ' ' || briywvwiumvx == ' ' )  { fscanf ( input , " " , & uiyttppievlw ) ; hxjppglfupiv ( briywvwiumvx == ' ' )  { agrqgejvfvbl [ 1 ] [ I [ 1 ] ] = uiyttppievlw ; I [ 1 ] ++ ; krdloxyecwgm [ jjcshgjekvkc ] = 1000 ; } else hxjppglfupiv ( briywvwiumvx == ' O ' ) { agrqgejvfvbl [ 2 ] [ I [ 2 ] ] = uiyttppievlw ; I [ 2 ] ++ ; krdloxyecwgm [ jjcshgjekvkc ] = 2000 ; } krdloxyecwgm [ jjcshgjekvkc ] += uiyttppievlw ; jjcshgjekvkc ++ ; } else  { n -- ; } } jjcshgjekvkc = 0 ; I [ 1 ] = 0 ; I [ 2 ] = 0 ; pos [ 1 ] = 1 ; pos [ 2 ] = 1 ; for ( gplracfgaodm = 0 ; jjcshgjekvkc < N ; gplracfgaodm ++ ) { xgkebdlhqrcy = krdloxyecwgm [ jjcshgjekvkc ] / 1000 ; cur_btn = krdloxyecwgm [ jjcshgjekvkc ] % 1000 ; for ( b = 1 ; b <= 2 ; b ++ ) { hxjppglfupiv ( b == xgkebdlhqrcy )  { hxjppglfupiv ( pos [ b ] - agrqgejvfvbl [ b ] [ I [ b ] ] == 0 )  { I [ b ] ++ ; jjcshgjekvkc ++ ; } else  { hxjppglfupiv ( pos [ b ] > agrqgejvfvbl [ b ] [ I [ b ] ] )  { pos [ b ] -- ; } else  { pos [ b ] ++ ; } } } else  { hxjppglfupiv ( pos [ b ] - agrqgejvfvbl [ b ] [ I [ b ] ] != 0 )  { hxjppglfupiv ( pos [ b ] > agrqgejvfvbl [ b ] [ I [ b ] ] )  { pos [ b ] -- ; } else  { pos [ b ] ++ ; } } } } } fprintf ( out , " \n " , t + 1 , gplracfgaodm ) ; } fclose ( out ) ; }
>>>Func
METHOD main
METHOD_RETURN int
freopen freopen("1.txt","r",stdin)
freopen freopen("2.txt","w",stdout)
scanf scanf("%d",&zjjxtfxceqvb)
RETURN return 0; return 0;
<operator>.lessEqualsThan sxotnefutdyw<=zjjxtfxceqvb
<operator>.postIncrement sxotnefutdyw++
LITERAL 0 return 0;
<operator>.assignment sxotnefutdyw=1
scanf scanf("%d",&kcwukvckfdjj)
printf printf("Case #%d:\n",sxotnefutdyw)
<operator>.lessThan bcjsvyosnttp<kcwukvckfdjj
<operator>.postIncrement bcjsvyosnttp++
scanf scanf("%s",g[bcjsvyosnttp])
<operator>.lessThan bcjsvyosnttp<kcwukvckfdjj
<operator>.postIncrement bcjsvyosnttp++
<operator>.lessThan bcjsvyosnttp<kcwukvckfdjj
<operator>.postIncrement bcjsvyosnttp++
<operator>.lessThan bcjsvyosnttp<kcwukvckfdjj
<operator>.postIncrement bcjsvyosnttp++
<operator>.assignment bcjsvyosnttp=0
<operator>.assignment bcjsvyosnttp=0
<operator>.assignment gokltlywusoi=0
<operator>.assignment igylskfbtxim=0
<operator>.assignment wp[bcjsvyosnttp]=gokltlywusoi *1.0/igylskfbtxim
<operator>.assignment num=0
<operator>.assignment sbusolfgbzrl=0
<operator>.assignment bcjsvyosnttp=0
<operator>.assignment tpordfulttbh=0
<operator>.assignment igylskfbtxim=0
<operator>.assignment oowp[bcjsvyosnttp]=tpordfulttbh/igylskfbtxim
<operator>.assignment bcjsvyosnttp=0
<operator>.assignment kcfxeidxyzeb=(wp[bcjsvyosnttp]+znqpimcjemmx[bcjsvyosnttp]*2+oowp[bcjsvyosnttp])/4
printf printf("%.6g\n",kcfxeidxyzeb)
<operator>.lessThan j<kcwukvckfdjj
<operator>.postIncrement j++
<operator>.lessThan j<kcwukvckfdjj
<operator>.postIncrement j++
<operator>.notEquals num!=0
<operator>.lessThan j<kcwukvckfdjj
<operator>.postIncrement j++
<operator>.assignment j=0
<operator>.notEquals g[bcjsvyosnttp][j]!='.'
<operator>.division gokltlywusoi *1.0/igylskfbtxim
<operator>.assignment j=0
<operator>.postIncrement num++
<operator>.assignment igylskfbtxim=0
<operator>.assignment gokltlywusoi=0
<operator>.assignmentPlus sbusolfgbzrl+=gokltlywusoi *1.0/igylskfbtxim
<operator>.assignment znqpimcjemmx[bcjsvyosnttp]=sbusolfgbzrl/num
<operator>.assignment j=0
<operator>.notEquals g[bcjsvyosnttp][j]!='.'
<operator>.division tpordfulttbh/igylskfbtxim
<operator>.division (wp[bcjsvyosnttp]+znqpimcjemmx[bcjsvyosnttp]*2+oowp[bcjsvyosnttp])/4
<operator>.postIncrement igylskfbtxim++
<operator>.multiplication gokltlywusoi *1.0
<operator>.equals bcjsvyosnttp==j
<operator>.equals g[bcjsvyosnttp][j]=='.'
<operator>.lessThan k<kcwukvckfdjj
<operator>.postIncrement k++
<operator>.assignment znqpimcjemmx [bcjsvyosnttp]=0
<operator>.assignmentPlus tpordfulttbh+=znqpimcjemmx[j]
<operator>.postIncrement igylskfbtxim++
<operator>.addition wp[bcjsvyosnttp]+znqpimcjemmx[bcjsvyosnttp]*2+oowp[bcjsvyosnttp]
<operator>.equals g[bcjsvyosnttp][j]=='1'
<operator>.assignment k=0
<operator>.division gokltlywusoi *1.0/igylskfbtxim
<operator>.division sbusolfgbzrl/num
<operator>.addition wp[bcjsvyosnttp]+znqpimcjemmx[bcjsvyosnttp]*2
<operator>.postIncrement gokltlywusoi++
<operator>.equals k==bcjsvyosnttp
<operator>.notEquals g[j][k]!='.'
<operator>.multiplication gokltlywusoi *1.0
<operator>.multiplication znqpimcjemmx[bcjsvyosnttp]*2
<operator>.postIncrement igylskfbtxim++
<operator>.equals g[j][k]=='1'
<operator>.postIncrement gokltlywusoi++
<operator>.addressOf &kcwukvckfdjj
<operator>.indirectIndexAccess g[bcjsvyosnttp]
<operator>.indirectIndexAccess wp[bcjsvyosnttp]
<operator>.indirectIndexAccess oowp[bcjsvyosnttp]
<operator>.indirectIndexAccess g[bcjsvyosnttp][j]
<operator>.indirectIndexAccess znqpimcjemmx[bcjsvyosnttp]
<operator>.indirectIndexAccess g[bcjsvyosnttp][j]
<operator>.indirectIndexAccess oowp[bcjsvyosnttp]
<operator>.indirectIndexAccess g[bcjsvyosnttp]
<operator>.indirectIndexAccess g[bcjsvyosnttp][j]
<operator>.indirectIndexAccess znqpimcjemmx [bcjsvyosnttp]
<operator>.indirectIndexAccess g[bcjsvyosnttp]
<operator>.indirectIndexAccess znqpimcjemmx[j]
<operator>.indirectIndexAccess wp[bcjsvyosnttp]
<operator>.indirectIndexAccess g[bcjsvyosnttp][j]
<operator>.indirectIndexAccess g[bcjsvyosnttp]
<operator>.indirectIndexAccess znqpimcjemmx[bcjsvyosnttp]
<operator>.indirectIndexAccess g[bcjsvyosnttp]
<operator>.indirectIndexAccess g[j][k]
<operator>.indirectIndexAccess g[j]
<operator>.indirectIndexAccess g[j][k]
<operator>.indirectIndexAccess g[j]
>>>PDG&100 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->26 0->27 0->28 0->29 0->30 0->32 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->65 0->66 0->67 0->68 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 2->1 2->1 3->1 3->1 4->1 4->6 5->1 6->1 6->1 6->1 6->6 6->7 6->10 6->11 6->11 6->12 6->15 6->17 6->19 6->21 6->22 6->28 6->32 6->78 7->1 7->6 8->5 9->1 9->6 10->1 10->12 10->15 10->17 10->19 10->35 10->37 10->40 10->59 11->1 11->7 12->12 12->13 12->13 12->14 12->15 12->79 13->1 13->12 14->1 15->15 15->16 15->16 15->17 15->23 15->24 15->25 15->26 15->27 15->35 15->35 15->37 15->39 15->42 15->44 15->45 15->56 15->57 15->80 16->1 16->15 17->17 17->18 17->18 17->19 17->29 17->30 17->31 17->40 17->40 17->51 17->53 17->81 18->1 18->17 19->1 19->1 19->1 19->10 19->12 19->19 19->20 19->20 19->33 19->34 19->54 19->64 19->69 19->74 19->85 19->91 19->94 20->1 20->19 21->12 22->15 23->1 23->56 23->70 24->1 24->44 24->55 25->1 25->1 25->1 25->54 25->64 25->69 26->1 26->39 26->46 27->1 27->1 27->49 27->68 28->17 29->1 29->53 29->62 30->1 30->53 30->63 31->1 31->1 31->1 31->54 31->64 32->1 32->19 33->1 33->1 33->34 34->1 34->1 35->35 35->36 35->36 35->37 35->43 35->82 35->86 36->1 36->35 37->1 37->1 37->15 37->37 37->38 37->57 37->57 37->59 38->1 38->37 39->1 39->1 39->50 39->61 39->68 39->68 39->83 39->88 40->1 40->1 40->17 40->40 40->41 40->41 40->52 40->84 40->89 41->1 41->40 42->35 43->1 43->1 43->14 43->52 43->55 43->58 43->65 43->65 43->92 43->95 44->1 44->1 44->25 44->25 45->1 45->37 46->1 46->39 47->1 47->67 47->75 48->1 48->73 48->77 49->1 49->1 49->1 49->68 50->1 50->1 50->1 50->74 51->1 51->40 52->1 52->1 52->14 52->43 52->58 52->62 52->63 52->90 53->1 53->1 53->31 53->31 54->1 54->33 54->33 55->1 55->44 56->1 56->44 56->44 57->1 57->16 57->38 57->58 57->71 57->87 57->93 58->1 58->1 58->14 58->43 58->46 58->47 58->48 58->49 58->52 58->59 58->66 58->67 58->73 59->1 59->1 59->37 59->59 59->60 59->71 59->71 60->1 60->59 61->1 61->1 62->1 62->1 62->53 63->1 63->53 64->1 64->1 65->1 65->1 65->14 65->43 65->52 65->58 65->70 66->1 66->59 67->1 67->1 67->49 67->49 68->1 68->1 68->50 68->50 69->1 69->1 70->1 70->56 71->1 71->16 71->57 71->60 71->72 71->96 71->97 72->1 72->1 72->75 72->76 72->76 72->98 72->99 73->1 73->67 73->67 74->1 74->54 74->54 74->64 74->64 74->69 74->69 75->1 75->67 76->1 76->1 76->72 76->77 77->1 77->73
>>>Token int main ( ) { int zjjxtfxceqvb ; int sxotnefutdyw ; int bcjsvyosnttp , j , k ; int kcwukvckfdjj ; int igylskfbtxim , num ; double sbusolfgbzrl ; double gokltlywusoi ; double tpordfulttbh ; double kcfxeidxyzeb ; freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; scanf ( " " , & zjjxtfxceqvb ) ; for ( sxotnefutdyw = 1 ; sxotnefutdyw <= zjjxtfxceqvb ; sxotnefutdyw ++ ) { scanf ( " " , & kcwukvckfdjj ) ; for ( bcjsvyosnttp = 0 ; bcjsvyosnttp < kcwukvckfdjj ; bcjsvyosnttp ++ ) scanf ( " " , g [ bcjsvyosnttp ] ) ; for ( bcjsvyosnttp = 0 ; bcjsvyosnttp < kcwukvckfdjj ; bcjsvyosnttp ++ ) { gokltlywusoi = 0 ; igylskfbtxim = 0 ; for ( j = 0 ; j < kcwukvckfdjj ; j ++ ) if ( g [ bcjsvyosnttp ] [ j ] != ' ' ) { igylskfbtxim ++ ; if ( g [ bcjsvyosnttp ] [ j ] == ' ' ) gokltlywusoi ++ ; } wp [ bcjsvyosnttp ] = gokltlywusoi * 1.0 / igylskfbtxim ; num = 0 ; sbusolfgbzrl = 0 ; for ( j = 0 ; j < kcwukvckfdjj ; j ++ ) { if ( bcjsvyosnttp == j ) continue ; if ( g [ bcjsvyosnttp ] [ j ] == ' ' ) continue ; num ++ ; igylskfbtxim = 0 ; gokltlywusoi = 0 ; for ( k = 0 ; k < kcwukvckfdjj ; k ++ ) { if ( k == bcjsvyosnttp ) continue ; if ( g [ j ] [ k ] != ' ' ) { igylskfbtxim ++ ; if ( g [ j ] [ k ] == ' ' ) gokltlywusoi ++ ; } } sbusolfgbzrl += gokltlywusoi * 1.0 / igylskfbtxim ; } if ( num != 0 ) znqpimcjemmx [ bcjsvyosnttp ] = sbusolfgbzrl / num ; else znqpimcjemmx [ bcjsvyosnttp ] = 0 ; } for ( bcjsvyosnttp = 0 ; bcjsvyosnttp < kcwukvckfdjj ; bcjsvyosnttp ++ ) { tpordfulttbh = 0 ; igylskfbtxim = 0 ; for ( j = 0 ; j < kcwukvckfdjj ; j ++ ) if ( g [ bcjsvyosnttp ] [ j ] != ' ' ) { tpordfulttbh += znqpimcjemmx [ j ] ; igylskfbtxim ++ ; } oowp [ bcjsvyosnttp ] = tpordfulttbh / igylskfbtxim ; } printf ( " \n " , sxotnefutdyw ) ; for ( bcjsvyosnttp = 0 ; bcjsvyosnttp < kcwukvckfdjj ; bcjsvyosnttp ++ ) { kcfxeidxyzeb = ( wp [ bcjsvyosnttp ] + znqpimcjemmx [ bcjsvyosnttp ] * 2 + oowp [ bcjsvyosnttp ] ) / 4 ; printf ( " \n " , kcfxeidxyzeb ) ; } } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN void
clrscr clrscr()
getch getch()
<operator>.notEquals ch!=4
printf printf("\n Menu: \n")
printf printf("1:Create Linked List \n")
printf printf("2:Delete Node \n")
printf printf("3:Traverse \n")
printf printf("4:Exit \n")
printf printf("\nEnter your choice: ")
scanf scanf("%d",&ch)
IDENTIFIER ch switch(ch)
create create()
printf printf("Enter the data value of the node to be deleted: ")
scanf scanf("%d",&k)
deletenode deletenode(k)
traverse traverse()
<operator>.addressOf &ch
<operator>.addressOf &k
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 2->1 3->1 4->1 4->1 4->4 4->5 4->6 4->7 4->8 4->9 4->10 4->11 4->11 4->13 4->14 4->15 4->16 4->17 4->18 4->19 5->1 6->1 7->1 8->1 9->1 10->1 11->1 11->4 13->1 14->1 15->1 15->16 16->1 16->1 16->15 17->1
>>>Token void main ( ) { int mhojlbnrswbt , k , ch ; clrscr ( ) ; do { printf ( " \n \n " ) ; printf ( " \n " ) ; printf ( " \n " ) ; printf ( " \n " ) ; printf ( " \n " ) ; printf ( " \n " ) ; scanf ( " " , & ch ) ; switch ( ch ) { case1 : create ( ) ; break ; case2 : printf ( " " ) ; scanf ( " " , & k ) ; deletenode ( k ) ; break ; case3 : traverse ( ) ; break ; case4 : break ; } } while ( ch != 4 ) ; getch ( ) ; }
>>>Func
METHOD sccvlaeqznun
METHOD_RETURN uint8_t
PARAM char uhfjvnaydvwy
PARAM char sotgutttdwwk [ ]
RETURN return 0; return 0;
<operator>.notEquals *sotgutttdwwk!='\0'
<operator>.preIncrement ++sotgutttdwwk
LITERAL 0 return 0;
<operator>.equals *sotgutttdwwk==uhfjvnaydvwy
RETURN return 1; return 1;
LITERAL 1 return 1;
<operator>.indirection *sotgutttdwwk
<operator>.indirection *sotgutttdwwk
>>>PDG&13 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 2->8 3->1 3->6 4->1 5->1 5->4 5->8 5->8 5->12 7->4 8->1 8->1 8->1 8->5 8->6 8->6 8->9 8->11 9->1 10->9
>>>Token uint8_t sccvlaeqznun ( char uhfjvnaydvwy , char sotgutttdwwk [ ] ) { for ( ; * sotgutttdwwk != ' \0 ' ; ++ sotgutttdwwk ) { if ( * sotgutttdwwk == uhfjvnaydvwy ) { return 1 ; } } return 0 ; }
>>>Func
METHOD ztauiblkfmqp
METHOD_RETURN int
PARAM char *fname
<operator>.assignment fp=fopen(fname,"r")
fclose fclose(fp)
RETURN return 0; return 0;
<operator>.equals fp==NULL
<operator>.lessThan init_input_structure(fp)<0
LITERAL 0 return 0;
fopen fopen(fname,"r")
printf printf("Unable to open input file (%s).\n",fname)
RETURN return -1; return -1;
printf printf("init_input_structre failed.\n")
RETURN return -1; return -1;
<operator>.minus -1
init_input_structure init_input_structure(fp)
<operator>.minus -1
>>>PDG&17 0->2 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->14 0->15 0->16 2->9 3->1 3->1 3->6 5->1 6->1 6->1 6->1 6->7 6->10 6->11 6->14 6->15 6->15 7->4 7->5 7->12 7->13 7->16 8->5 9->3 9->3 9->10 10->1 10->1 11->1 13->1 14->1 14->11 15->4 15->7 16->13
>>>Token int ztauiblkfmqp ( char * fname ) { FILE * fp ; fp = fopen ( fname , " " ) ; if ( fp == NULL ) { printf ( " \n " , fname ) ; return -1 ; } if ( init_input_structure ( fp ) < 0 ) { printf ( " \n " ) ; return -1 ; } fclose ( fp ) ; return 0 ; }
>>>Func
METHOD znpdntqaklnv
METHOD_RETURN int
PARAM int bbuggqqpickz
RETURN return 0; return 0;
<operator>.lessThan rkkivkgfqeun<d
<operator>.postIncrement rkkivkgfqeun++
LITERAL 0 return 0;
<operator>.assignment rkkivkgfqeun=0
<operator>.logicalOr (opp[rkkivkgfqeun][0]==input[bbuggqqpickz])||(opp[rkkivkgfqeun][1]==input[bbuggqqpickz])
<operator>.equals opp[rkkivkgfqeun][0]==input[bbuggqqpickz]
<operator>.equals opp[rkkivkgfqeun][1]==input[bbuggqqpickz]
<operator>.equals opp[rkkivkgfqeun][0]==input[bbuggqqpickz]
<operator>.greaterEqualsThan k>=0
<operator>.postDecrement k--
<operator>.assignment utspnplfkbar=1
<operator>.assignment k=bbuggqqpickz-1
<operator>.assignment utspnplfkbar =0
<operator>.equals output[k]==opp[rkkivkgfqeun][utspnplfkbar]
<operator>.subtraction bbuggqqpickz-1
del_opp del_opp(0,bbuggqqpickz)
RETURN return 1; return 1;
LITERAL 1 return 1;
<operator>.indirectIndexAccess opp[rkkivkgfqeun][0]
<operator>.indirectIndexAccess input[bbuggqqpickz]
<operator>.indirectIndexAccess opp[rkkivkgfqeun][1]
<operator>.indirectIndexAccess input[bbuggqqpickz]
<operator>.indirectIndexAccess opp[rkkivkgfqeun]
<operator>.indirectIndexAccess opp[rkkivkgfqeun]
<operator>.indirectIndexAccess opp[rkkivkgfqeun][0]
<operator>.indirectIndexAccess input[bbuggqqpickz]
<operator>.indirectIndexAccess opp[rkkivkgfqeun]
<operator>.indirectIndexAccess output[k]
<operator>.indirectIndexAccess opp[rkkivkgfqeun][utspnplfkbar]
<operator>.indirectIndexAccess opp[rkkivkgfqeun]
>>>PDG&34 0->2 0->3 0->4 0->5 0->6 0->7 0->12 0->13 0->14 0->16 0->18 0->19 0->20 0->21 2->18 3->1 4->1 4->1 4->1 4->3 4->5 4->8 4->9 4->22 4->23 4->26 5->1 5->4 6->3 7->1 7->4 8->1 8->1 8->4 8->5 8->11 8->12 8->15 8->18 8->28 8->29 8->30 9->8 9->8 9->10 9->10 9->11 9->11 9->24 9->25 9->27 10->1 10->8 10->8 10->9 10->11 11->1 11->1 11->1 11->9 11->9 11->14 11->16 12->1 12->1 12->4 12->5 12->13 12->17 12->31 12->32 12->33 13->1 13->12 14->1 14->1 15->1 15->1 15->12 16->1 16->1 17->1 17->1 17->1 17->12 17->13 17->19 17->20 18->15 18->15 18->19 19->1 19->1 20->1 21->20
>>>Token int znpdntqaklnv ( int bbuggqqpickz ) { int rkkivkgfqeun , k ; int utspnplfkbar ; for ( rkkivkgfqeun = 0 ; rkkivkgfqeun < d ; rkkivkgfqeun ++ ) { if ( ( opp [ rkkivkgfqeun ] [ 0 ] == input [ bbuggqqpickz ] ) || ( opp [ rkkivkgfqeun ] [ 1 ] == input [ bbuggqqpickz ] ) ) { if ( opp [ rkkivkgfqeun ] [ 0 ] == input [ bbuggqqpickz ] ) utspnplfkbar = 1 ; else utspnplfkbar = 0 ; for ( k = bbuggqqpickz - 1 ; k >= 0 ; k -- ) { if ( output [ k ] == opp [ rkkivkgfqeun ] [ utspnplfkbar ] ) { del_opp ( 0 , bbuggqqpickz ) ; return 1 ; } } } } return 0 ; }
>>>Func
METHOD zvzldnvbsejk
METHOD_RETURN int
PARAM const exdcgrrjceaq*a
PARAM const exdcgrrjceaq*b
RETURN return *(int *)b-*(int *)a; return *(int *)b-*(int *)a;
<operator>.subtraction *(int *)b-*(int *)a
<operator>.cast (int *)b
<operator>.cast (int *)a
>>>PDG&8 0->2 0->3 0->6 0->7 2->7 3->6 4->1 5->1 5->1 5->1 5->4 6->1 7->1
>>>Token int zvzldnvbsejk ( const exdcgrrjceaq * a , const exdcgrrjceaq * b ) { return * ( int * ) b - * ( int * ) a ; }
>>>Func
METHOD main
METHOD_RETURN void
PARAM void
freopen freopen("B-small-attempt2.in","r",stdin)
freopen freopen("A.out","w",stdout)
scanf scanf("%d",&tc)
<operator>.lessEqualsThan iihzfrajvens<=tc
<operator>.postIncrement iihzfrajvens++
<operator>.assignment iihzfrajvens=1
scanf scanf("%d",&nc)
dzzejyxbqmsd dzzejyxbqmsd(nc>0)
scanf scanf("%s",cstr)
scanf scanf("%d",&nd)
dzzejyxbqmsd dzzejyxbqmsd(nd>0)
scanf scanf("%s",dstr)
scanf scanf("%d",&length)
scanf scanf("%s",qxcgxozolmnx)
<operator>.assignment dstrActive=''
<operator>.assignment cstrActive=''
gireblpnsuth gireblpnsuth("Case #%d: [",iihzfrajvens)
dzzejyxbqmsd dzzejyxbqmsd(!newindex)
gireblpnsuth gireblpnsuth("]\n")
<operator>.lessThan j<length
<operator>.postIncrement j++
<operator>.lessThan j<newindex
<operator>.postIncrement j++
<operator>.greaterThan nc>0
<operator>.greaterThan nd>0
<operator>.expressionList newindex=0 j=0
dzzejyxbqmsd dzzejyxbqmsd((cstrActive==cstr[0]&&qxcgxozolmnx[j]==cstr[1])||(cstrActive==cstr[1]&&qxcgxozolmnx[j]==cstr[0]))
<operator>.assignment j=0
dzzejyxbqmsd dzzejyxbqmsd(j!=newindex-1)
gireblpnsuth gireblpnsuth("%c, ",qxcgxozolmnx[j])
<operator>.logicalNot !newindex
<operator>.assignment qxcgxozolmnx[newindex-1]=cstr[2]
dzzejyxbqmsd dzzejyxbqmsd(dstrActive==cstrActive&&(dstrActiveIndex==j-1))
<operator>.assignment dstrActive=''
<operator>.assignment cstrActive=''
<operator>.assignment qxcgxozolmnx[newindex++]=qxcgxozolmnx[j]
<operator>.assignment newindex=0
<operator>.assignment j=0
<operator>.logicalOr (cstrActive==cstr[0]&&qxcgxozolmnx[j]==cstr[1])||(cstrActive==cstr[1]&&qxcgxozolmnx[j]==cstr[0])
<operator>.notEquals j!=newindex-1
<operator>.logicalAnd cstrActive==cstr[0]&&qxcgxozolmnx[j]==cstr[1]
<operator>.logicalAnd cstrActive==cstr[1]&&qxcgxozolmnx[j]==cstr[0]
<operator>.logicalAnd dstrActive==cstrActive&&(dstrActiveIndex==j-1)
<operator>.subtraction newindex-1
<operator>.equals cstrActive==cstr[0]
<operator>.equals qxcgxozolmnx[j]==cstr[1]
<operator>.equals cstrActive==cstr[1]
<operator>.equals qxcgxozolmnx[j]==cstr[0]
<operator>.subtraction newindex-1
<operator>.equals dstrActive==cstrActive
<operator>.equals dstrActiveIndex==j-1
<operator>.subtraction j-1
UNKNOWN,),)
UNKNOWN,),)
UNKNOWN,),)
<operator>.addressOf &nc
<operator>.addressOf &nd
<operator>.addressOf &length
UNKNOWN,),)
UNKNOWN,),)
UNKNOWN else gireblpnsuth ("%c]\n",qxcgxozolmnx[j]); else gireblpnsuth ("%c]\n",qxcgxozolmnx[j]);
UNKNOWN,),)
<operator>.indirectIndexAccess qxcgxozolmnx[j]
<operator>.indirectIndexAccess qxcgxozolmnx[newindex-1]
<operator>.indirectIndexAccess cstr[2]
<operator>.logicalAnd dstrActive==dstr[0]&&qxcgxozolmnx[j]==dstr[1]
<operator>.logicalAnd dstrActive==dstr[1]&&qxcgxozolmnx[j]==dstr[0]
<operator>.equals dstrActive==dstr[0]
<operator>.equals qxcgxozolmnx[j]==dstr[1]
<operator>.equals dstrActive==dstr[1]
<operator>.equals qxcgxozolmnx[j]==dstr[0]
<operator>.indirectIndexAccess cstr[0]
<operator>.indirectIndexAccess qxcgxozolmnx[j]
<operator>.indirectIndexAccess cstr[1]
<operator>.indirectIndexAccess cstr[1]
<operator>.indirectIndexAccess qxcgxozolmnx[j]
<operator>.indirectIndexAccess cstr[0]
<operator>.indirectIndexAccess qxcgxozolmnx[j]
<operator>.indirectIndexAccess dstr[1]
<operator>.indirectIndexAccess dstr[1]
<operator>.indirectIndexAccess qxcgxozolmnx[j]
<operator>.indirectIndexAccess dstr[0]
>>>PDG&85 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->19 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->30 0->32 0->33 0->36 0->37 0->39 0->40 0->42 0->46 0->47 0->49 0->51 0->52 0->53 0->54 2->1 3->1 3->1 4->1 4->1 5->1 5->6 6->1 6->1 6->1 6->6 6->7 6->9 6->10 6->11 6->12 6->13 6->14 6->15 6->16 6->17 6->18 6->19 6->19 6->20 6->21 6->22 6->24 6->26 6->27 6->28 6->30 6->33 6->39 6->40 6->55 6->56 6->57 6->58 6->59 6->60 7->1 7->6 8->1 8->6 9->26 11->34 11->47 11->48 11->49 11->50 12->27 15->22 16->32 16->48 16->50 17->52 18->47 19->7 22->15 22->22 22->23 22->23 22->29 22->34 22->35 22->36 22->37 22->41 22->43 22->45 22->47 22->51 22->52 22->54 22->61 22->64 22->66 22->67 22->74 23->22 24->24 24->25 24->31 24->32 24->33 24->42 24->42 24->46 24->46 24->62 24->63 24->65 25->24 26->9 26->10 26->10 27->12 27->13 27->13 30->24 32->16 32->48 32->50 33->20 34->16 36->52 37->47 38->16 39->24 39->28 39->51 40->22 40->28 41->29 41->29 42->25 42->31 42->31 43->41 43->41 43->44 43->49 43->77 44->41 44->41 45->35 45->35 46->24 46->42 46->42 47->11 47->43 47->43 47->48 47->49 47->50 47->52 47->75 47->76 48->11 48->16 48->32 48->43 48->43 48->49 48->50 49->11 49->44 49->44 49->48 49->50 49->52 49->78 49->79 50->11 50->16 50->32 50->44 50->44 50->47 50->48 51->24 52->45 52->45 52->53 52->54 53->45 53->45 54->23 54->53 54->53 68->69 68->72 68->82 70->71 70->80 70->81 72->73 72->83 72->84
>>>Token void main ( void ) { int iihzfrajvens , j , tc , nc , nd , length , newindex ; char qxcgxozolmnx [ 10 ] , cstr [ 3 ] , dstr [ 2 ] , dstrActive , cstrActive , dstrActiveIndex ; freopen ( " " , " " , stdin ) ; freopen ( " " , " " , stdout ) ; scanf ( " " , & tc ) ; for ( iihzfrajvens = 1 ; iihzfrajvens <= tc ; iihzfrajvens ++ ) { scanf ( " " , & nc ) ; dzzejyxbqmsd ( nc > 0 )  scanf ( " " , cstr ) ; scanf ( " " , & nd ) ; dzzejyxbqmsd ( nd > 0 )  scanf ( " " , dstr ) ; scanf ( " " , & length ) ; scanf ( " " , qxcgxozolmnx ) ; dstrActive = ' ' ; cstrActive = ' ' ; for ( newindex = 0 , j = 0 ; j < length ; j ++ ) { dzzejyxbqmsd ( ( cstrActive == cstr [ 0 ] && qxcgxozolmnx [ j ] == cstr [ 1 ] ) || ( cstrActive == cstr [ 1 ] && qxcgxozolmnx [ j ] == cstr [ 0 ] ) )  { qxcgxozolmnx [ newindex - 1 ] = cstr [ 2 ] ; dzzejyxbqmsd ( dstrActive == cstrActive && ( dstrActiveIndex == j - 1 ) )  dstrActive = ' ' ; cstrActive = ' ' ; continue ; } else dzzejyxbqmsd ( cstrActive != ' ' )  cstrActive = ' ' ; dzzejyxbqmsd ( ( dstrActive == dstr [ 0 ] && qxcgxozolmnx [ j ] == dstr [ 1 ] ) || ( dstrActive == dstr [ 1 ] && qxcgxozolmnx [ j ] == dstr [ 0 ] ) )  { newindex = 0 ; dstrActive = ' ' ; cstrActive = ' ' ; continue ; } dzzejyxbqmsd ( qxcgxozolmnx [ j ] == cstr [ 0 ] ) cstrActive = cstr [ 0 ] ; else dzzejyxbqmsd ( qxcgxozolmnx [ j ] = = cstr [ 1 ] )  cstrActive = cstr [ 1 ] ; dzzejyxbqmsd ( qxcgxozolmnx [ j ] == dstr [ 0 ] )  { dstrActiveIndex = j ; dstrActive = dstr [ 0 ] ; } else dzzejyxbqmsd ( qxcgxozolmnx [ j ] = = dstr [ 1 ] ) { dstrActiveIndex = j ; dstrActive = dstr [ 1 ] ; } qxcgxozolmnx [ newindex ++ ] = qxcgxozolmnx [ j ] ; } gireblpnsuth ( " " , iihzfrajvens ) ; for ( j = 0 ; j < newindex ; j ++ ) { dzzejyxbqmsd ( j != newindex - 1 )  gireblpnsuth ( " " , qxcgxozolmnx [ j ] ) ; else gireblpnsuth ( " \n " , qxcgxozolmnx [ j ] ) ; } dzzejyxbqmsd ( ! newindex )  gireblpnsuth ( " \n " ) ; } }
>>>Func
METHOD acvobsdixdjg
METHOD_RETURN void
PARAM char lvjsdnnqomva
<operator>.assignment mrpyaograomj=top?list[top-1]:0
<operator>.assignment zopamrliejfo=map[mrpyaograomj]?combine[map[mrpyaograomj]|map[lvjsdnnqomva]]:0
xjxwcehozelh xjxwcehozelh(zopamrliejfo)
<operator>.assignment list[top-1]=zopamrliejfo
<operators>.assignmentAnd mark&=~map[mrpyaograomj]
xjxwcehozelh xjxwcehozelh(list[ennwccbpzgok]==mrpyaograomj)
<operator>.conditional top?list[top-1]:0
<operator>.conditional map[mrpyaograomj]?combine[map[mrpyaograomj]|map[lvjsdnnqomva]]:0
<operators>.assignmentOr mark|=map[mrpyaograomj]
<operator>.not ~map[mrpyaograomj]
<operator>.equals list[ennwccbpzgok]==mrpyaograomj
<operator>.subtraction top-1
<operator>.or map[mrpyaograomj]|map[lvjsdnnqomva]
<operator>.subtraction top-1
>>>PDG&17 0->2 0->3 0->4 0->5 0->6 0->7 0->9 0->10 0->11 0->13 0->14 0->16 3->13 4->5 5->6 7->11 12->7 12->11 13->8 13->8
>>>Token void acvobsdixdjg ( char lvjsdnnqomva ) { char mrpyaograomj = top ? list [ top - 1 ] : 0 ; char zopamrliejfo = map [ mrpyaograomj ] ? combine [ map [ mrpyaograomj ] | map [ lvjsdnnqomva ] ] : 0 ; int ennwccbpzgok ; xjxwcehozelh ( zopamrliejfo ) { list [ top - 1 ] = zopamrliejfo ; mark &= ~ map [ mrpyaograomj ] ; for ( ennwccbpzgok = 0 ; ennwccbpzgok < top - 1 ; ++ ennwccbpzgok ) xjxwcehozelh ( list [ ennwccbpzgok ] == mrpyaograomj )  { mark |= map [ mrpyaograomj ] ; break ; } } else xjxwcehozelh ( mark & opposed [ lvjsdnnqomva ] ) { top = 0 ; mark = 0 ; } else  { list [ top ++ ] = lvjsdnnqomva ; mark |= map [ lvjsdnnqomva ] ; } }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
scanf scanf("%d",&n)
RETURN return 0; return 0;
<operator>.lessThan rjtihpzuyuoy<n
<operator>.postIncrement rjtihpzuyuoy++
LITERAL 0 return 0;
<operator>.assignment rjtihpzuyuoy=0
<operator>.assignment result=solve()
IDENTIFIER result if (result)
zewomdnlqjqe zewomdnlqjqe("Case #%d: Possible\n",rjtihpzuyuoy+1)
zewomdnlqjqe zewomdnlqjqe ("Case #%d: Broken\n",rjtihpzuyuoy+1)
<operator>.addition rjtihpzuyuoy+1
<operator>.addition rjtihpzuyuoy+1
solve solve()
>>>PDG&16 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->5 5->6 5->6 5->9 5->11 5->11 5->12 5->12 5->13 5->13 5->14 5->14 5->15 6->1 6->5 7->4 8->1 8->5 9->1 9->1 9->1 11->1 11->1 12->1 12->1
>>>Token int main ( void ) { int rjtihpzuyuoy , n , result ; scanf ( " " , & n ) ; for ( rjtihpzuyuoy = 0 ; rjtihpzuyuoy < n ; rjtihpzuyuoy ++ ) { result = solve ( ) ; if ( result ) zewomdnlqjqe ( " \n " , rjtihpzuyuoy + 1 ) ; else zewomdnlqjqe ( " \n " , rjtihpzuyuoy + 1 ) ; } return 0 ; }
>>>Func
METHOD ucddgszypzlu
METHOD_RETURN int
PARAM int sdgtliayjkcw
RETURN return ucddgszypzlu; return ucddgszypzlu;
<operator>.logicalAnd ucddgszypzlu<length&&list[ucddgszypzlu]==''
<operator>.postIncrement ucddgszypzlu++
IDENTIFIER ucddgszypzlu return ucddgszypzlu;
<operator>.assignment ucddgszypzlu=sdgtliayjkcw+1
<operator>.lessThan ucddgszypzlu<length
<operator>.equals list[ucddgszypzlu]==''
<operator>.addition sdgtliayjkcw+1
<operator>.indirectIndexAccess list[ucddgszypzlu]
>>>PDG&12 0->2 0->5 0->6 0->7 0->8 0->9 0->10 2->7 2->10 3->1 4->1 4->1 4->1 4->4 4->5 4->8 5->1 5->8 6->3 7->1 7->1 7->8 8->1 8->1 8->4 8->4 8->5 8->6 8->9 8->11 9->1 9->4 9->4 10->1
>>>Token int ucddgszypzlu ( int sdgtliayjkcw ) { int ucddgszypzlu ; for ( ucddgszypzlu = sdgtliayjkcw + 1 ; ucddgszypzlu < length && list [ ucddgszypzlu ] == ' ' ; ucddgszypzlu ++ ) ; return ucddgszypzlu ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int chokyusbslam
PARAM dtqegoxqrmed *argv [ ]
IDENTIFIER wubhdktxizwb <empty>
<operator>.assignment c=argv[1][0]
RETURN return 0; return 0;
<operator>.greaterThan c>127
<operator>.greaterThan wubhdktxizwb>63
LITERAL 0 return 0;
<operator>.assignment wubhdktxizwb=c/3
mftbmfvviyth mftbmfvviyth("if-2-win\n")
<operator>.assignment wubhdktxizwb =c *2
mftbmfvviyth mftbmfvviyth ("if-2-lose\n")
<operator>.division c/3
<operator>.multiplication c *2
>>>PDG&16 0->2 0->3 0->4 0->6 0->7 0->8 0->9 0->11 0->13 0->14 0->15 2->1 3->1 5->1 5->1 5->7 6->1 7->1 7->10 7->12 7->14 7->14 7->15 7->15 8->1 8->1 8->11 8->13 9->6 10->1 10->1 10->8 11->1 12->1 12->1 12->8 13->1 14->1 14->10 14->10 15->1 15->12 15->12
>>>Token int main ( int chokyusbslam , dtqegoxqrmed * argv [ ] ) { unsigned dtqegoxqrmed wubhdktxizwb ; unsigned dtqegoxqrmed c = argv [ 1 ] [ 0 ] ; if ( c > 127 ) wubhdktxizwb = c / 3 ; else wubhdktxizwb = c * 2 ; if ( wubhdktxizwb > 63 ) mftbmfvviyth ( " \n " ) ; else mftbmfvviyth ( " \n " ) ; return 0 ; }
>>>Func
METHOD hootjqurwgqr
METHOD_RETURN void
printf printf("Enter the number of nodes required:\n")
scanf scanf("%d",&n)
printf printf("Enter the data value of each node:\n")
<operator>.lessEqualsThan jsgicmomgbqq<=n
<operator>.postIncrement jsgicmomgbqq++
<operator>.assignment jsgicmomgbqq=1
<operator>.assignment pnode=(struct cwyyggpwstlm*)malloc(sizeof(struct cwyyggpwstlm))
scanf scanf("%d",&pnode->data)
<operator>.assignment last->next=first
<operator>.equals pnode==NULL
<operator>.equals first==NULL
<operator>.cast (struct cwyyggpwstlm*)malloc(sizeof(struct cwyyggpwstlm))
printf printf("Memory overflow. Unable to create.\n")
RETURN return ; return ;
<operator>.assignment first=last=pnode
<operator>.assignment last->next=pnode
<operator>.assignment last=pnode
<operator>.sizeOf sizeof(struct cwyyggpwstlm)
<operator>.assignment last=pnode
<operator>.addressOf &pnode->data
<operator>.indirectFieldAccess last->next
UNKNOWN struct cwyyggpwstlm* struct cwyyggpwstlm*
malloc malloc(sizeof(struct cwyyggpwstlm))
<operator>.indirectFieldAccess pnode->data
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER data data
<operator>.indirectFieldAccess last->next
FIELD_IDENTIFIER next next
>>>PDG&30 0->2 0->3 0->4 0->5 0->6 0->7 0->10 0->11 0->12 0->14 0->15 0->16 0->17 0->18 0->20 2->1 3->1 3->5 4->1 5->1 5->1 5->1 5->6 5->8 5->11 5->13 5->19 5->23 5->24 6->1 6->5 7->1 7->5 8->1 8->1 8->11 9->1 10->1 10->1 10->1 11->1 11->1 11->1 11->5 11->6 11->9 11->10 11->12 11->12 11->14 11->15 11->16 11->17 11->18 11->20 11->21 11->22 11->25 11->26 11->27 12->1 12->10 12->11 12->16 12->17 12->18 12->20 12->28 12->29 13->1 14->1 15->1 16->1 16->1 16->10 16->12 17->1 18->1 18->1 19->1 20->1 20->16
>>>Token void hootjqurwgqr ( ) { int jsgicmomgbqq , n ; struct cwyyggpwstlm * pnode , * p ; printf ( " \n " ) ; scanf ( " " , & n ) ; printf ( " \n " ) ; for ( jsgicmomgbqq = 1 ; jsgicmomgbqq <= n ; jsgicmomgbqq ++ ) { pnode = ( struct cwyyggpwstlm * ) malloc ( sizeof ( struct cwyyggpwstlm ) ) ; if ( pnode == NULL ) { printf ( " \n " ) ; return ; } scanf ( " " , & pnode -> data ) ; if ( first == NULL ) first = last = pnode ; else { last -> next = pnode ; last = pnode ; } last -> next = first ; } }
>>>Func
METHOD fgyuiscgkvbt
METHOD_RETURN int
PARAM AVLTree *tree
PARAM AVLTreeKey dnybagxdtbky
<operator>.assignment node=avl_tree_lookup_node(tree,dnybagxdtbky)
avl_tree_remove_node avl_tree_remove_node(tree,node)
RETURN return 1; return 1;
<operator>.equals node==NULL
LITERAL 1 return 1;
avl_tree_lookup_node avl_tree_lookup_node(tree,dnybagxdtbky)
RETURN return 0; return 0;
LITERAL 0 return 0;
>>>PDG&12 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 2->9 3->9 4->1 4->1 4->7 6->1 7->1 7->1 7->1 7->5 7->5 7->6 7->10 8->6 9->1 9->1 9->4 9->4 9->5 10->1 11->10
>>>Token int fgyuiscgkvbt ( AVLTree * tree , AVLTreeKey dnybagxdtbky ) { AVLTreeNode * node ; node = avl_tree_lookup_node ( tree , dnybagxdtbky ) ; if ( node == NULL ) { return 0 ; } avl_tree_remove_node ( tree , node ) ; return 1 ; }
>>>Func
METHOD plusOne
METHOD_RETURN int*
PARAM int *japixsjrkntc
PARAM int jetcfnqieyma
PARAM int *returnSize
<operator>.assignment *akbdakzqqkna=(int *)malloc((jetcfnqieyma+1)*sizeof(int))
<operator>.assignment akbdakzqqkna[0]=1
<operator>.assignment *returnSize=jetcfnqieyma+1
RETURN return akbdakzqqkna; return akbdakzqqkna;
<operator>.greaterEqualsThan tuhwnyyydisn>=0
<operator>.postDecrement tuhwnyyydisn--
<operator>.lessThan tuhwnyyydisn<(jetcfnqieyma+1)
<operator>.postIncrement tuhwnyyydisn++
IDENTIFIER akbdakzqqkna return akbdakzqqkna;
<operator>.assignment tuhwnyyydisn=jetcfnqieyma-1
<operator>.cast (int *)malloc((jetcfnqieyma+1)*sizeof(int))
<operator>.assignment tuhwnyyydisn=1
<operator>.assignment akbdakzqqkna[tuhwnyyydisn]=japixsjrkntc[tuhwnyyydisn-1]
<operator>.addition jetcfnqieyma+1
<operator>.lessThan japixsjrkntc[tuhwnyyydisn]<9
malloc malloc((jetcfnqieyma+1)*sizeof(int))
<operator>.addition jetcfnqieyma+1
<operator>.subtraction jetcfnqieyma-1
<operator>.postIncrement japixsjrkntc[tuhwnyyydisn]++
<operator>.assignment *returnSize=jetcfnqieyma
RETURN return japixsjrkntc; return japixsjrkntc;
<operator>.multiplication (jetcfnqieyma+1)*sizeof(int)
IDENTIFIER japixsjrkntc return japixsjrkntc;
<operator>.assignment japixsjrkntc[tuhwnyyydisn]=0
<operator>.addition jetcfnqieyma+1
<operator>.sizeOf sizeof(int)
<operator>.subtraction tuhwnyyydisn-1
<operator>.indirectIndexAccess akbdakzqqkna[0]
<operator>.indirection *returnSize
UNKNOWN int * int *
<operator>.indirectIndexAccess akbdakzqqkna[tuhwnyyydisn]
<operator>.indirectIndexAccess japixsjrkntc[tuhwnyyydisn-1]
<operator>.indirectIndexAccess japixsjrkntc[tuhwnyyydisn]
<operator>.indirectIndexAccess japixsjrkntc[tuhwnyyydisn]
<operator>.indirection *returnSize
<operator>.indirectIndexAccess japixsjrkntc[tuhwnyyydisn]
>>>PDG&41 0->2 0->3 0->4 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->16 0->18 0->19 0->21 0->22 0->24 0->26 0->27 0->28 0->29 0->31 2->1 2->17 2->19 2->23 2->27 3->22 4->1 5->13 6->13 8->1 9->1 9->1 9->5 9->6 9->7 9->8 9->10 9->11 9->15 9->16 9->18 9->19 9->20 9->21 9->26 9->29 9->30 9->32 9->33 9->34 9->37 10->1 10->9 11->11 11->12 11->17 11->21 11->31 11->31 11->35 11->36 12->11 13->8 14->1 14->1 14->9 16->11 17->13 19->1 19->9 19->10 19->23 19->23 19->24 19->25 19->28 19->38 19->39 19->40 20->5 20->15 22->7 22->11 22->14 22->14 22->18 22->21 22->24 22->26 22->29 23->1 23->1 23->27 24->1 24->1 24->1 25->1 26->20 27->25 28->1 28->19 30->1 31->12
>>>Token int * plusOne ( int * japixsjrkntc , int jetcfnqieyma , int * returnSize ) { for ( int tuhwnyyydisn = jetcfnqieyma - 1 ; tuhwnyyydisn >= 0 ; tuhwnyyydisn -- ) { if ( japixsjrkntc [ tuhwnyyydisn ] < 9 ) { japixsjrkntc [ tuhwnyyydisn ] ++ ; * returnSize = jetcfnqieyma ; return japixsjrkntc ; } else { japixsjrkntc [ tuhwnyyydisn ] = 0 ; } } int * akbdakzqqkna = ( int * ) malloc ( ( jetcfnqieyma + 1 ) * sizeof ( int ) ) ; akbdakzqqkna [ 0 ] = 1 ; for ( int tuhwnyyydisn = 1 ; tuhwnyyydisn < ( jetcfnqieyma + 1 ) ; tuhwnyyydisn ++ ) { akbdakzqqkna [ tuhwnyyydisn ] = japixsjrkntc [ tuhwnyyydisn - 1 ] ; } * returnSize = jetcfnqieyma + 1 ; return akbdakzqqkna ; }
>>>Func
METHOD urytuexcxhxd
METHOD_RETURN struct slnflquxxsxt
PARAM struct slnflquxxsxt*lnnndwcpuxeb
RETURN return lnnndwcpuxeb; return lnnndwcpuxeb;
<operator>.equals lnnndwcpuxeb==gfbkndgktsir
<operator>.logicalAnd lnnndwcpuxeb->next&&lnnndwcpuxeb->val==lnnndwcpuxeb->next->val
IDENTIFIER lnnndwcpuxeb return lnnndwcpuxeb;
RETURN return gfbkndgktsir; return gfbkndgktsir;
RETURN return urytuexcxhxd(lnnndwcpuxeb->next); return urytuexcxhxd(lnnndwcpuxeb->next);
IDENTIFIER gfbkndgktsir return gfbkndgktsir;
<operator>.equals lnnndwcpuxeb->val==lnnndwcpuxeb->next->val
<operator>.logicalAnd lnnndwcpuxeb->next&&lnnndwcpuxeb->val==lnnndwcpuxeb->next->val
urytuexcxhxd urytuexcxhxd(lnnndwcpuxeb->next)
<operator>.assignment lnnndwcpuxeb->next=urytuexcxhxd(lnnndwcpuxeb->next)
<operator>.assignment lnnndwcpuxeb=lnnndwcpuxeb->next
<operator>.equals lnnndwcpuxeb->val==lnnndwcpuxeb->next->val
urytuexcxhxd urytuexcxhxd(lnnndwcpuxeb->next)
<operator>.indirectFieldAccess lnnndwcpuxeb->next
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess lnnndwcpuxeb->val
<operator>.indirectFieldAccess lnnndwcpuxeb->next->val
FIELD_IDENTIFIER val val
<operator>.indirectFieldAccess lnnndwcpuxeb->next
FIELD_IDENTIFIER val val
<operator>.indirectFieldAccess lnnndwcpuxeb->next
<operator>.indirectFieldAccess lnnndwcpuxeb->next
<operator>.indirectFieldAccess lnnndwcpuxeb->next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess lnnndwcpuxeb->val
<operator>.indirectFieldAccess lnnndwcpuxeb->next->val
<operator>.indirectFieldAccess lnnndwcpuxeb->next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
<operator>.indirectFieldAccess lnnndwcpuxeb->next
FIELD_IDENTIFIER val val
<operator>.indirectFieldAccess lnnndwcpuxeb->next
FIELD_IDENTIFIER val val
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
FIELD_IDENTIFIER next next
>>>PDG&41 0->2 0->4 0->6 0->7 0->9 2->4 3->1 4->1 4->1 4->1 4->5 4->6 4->7 4->17 4->18 5->3 5->8 5->11 5->11 5->11 5->12 5->13 5->16 5->16 5->24 5->25 5->26 5->28 5->32 5->33 5->34 5->39 6->3 7->1 8->1 9->7 10->5 10->5 10->15 10->15 11->11 11->12 11->14 11->14 11->24 11->28 11->31 11->38 12->8 15->11 15->11 16->13 17->10 17->19 17->20 17->21 17->22 17->23 17->27 24->15 24->29 24->30 24->35 24->36 24->37 24->40
>>>Token struct slnflquxxsxt * urytuexcxhxd ( struct slnflquxxsxt * lnnndwcpuxeb ) { if ( lnnndwcpuxeb == gfbkndgktsir ) return gfbkndgktsir ; if ( lnnndwcpuxeb -> next && lnnndwcpuxeb -> val == lnnndwcpuxeb -> next -> val ) { while ( lnnndwcpuxeb -> next && lnnndwcpuxeb -> val == lnnndwcpuxeb -> next -> val ) { lnnndwcpuxeb = lnnndwcpuxeb -> next ; } return urytuexcxhxd ( lnnndwcpuxeb -> next ) ; } else { lnnndwcpuxeb -> next = urytuexcxhxd ( lnnndwcpuxeb -> next ) ; } return lnnndwcpuxeb ; }
>>>Func
METHOD wzfkhhovtwbd
METHOD_RETURN char
PARAM char vetzudaihlcx[37][3]
PARAM int fxhwetnaxlgm
PARAM char fqjzczqslnya
PARAM char ptyogikbvlnt
RETURN return '\0'; return '\0';
<operator>.lessThan wrchcqmfsrdj<fxhwetnaxlgm
<operator>.postIncrement wrchcqmfsrdj++
LITERAL '\0' return '\0';
<operator>.assignment wrchcqmfsrdj=0
<operator>.logicalOr (vetzudaihlcx[wrchcqmfsrdj][0]==fqjzczqslnya&&vetzudaihlcx[wrchcqmfsrdj][1]==ptyogikbvlnt)||(vetzudaihlcx[wrchcqmfsrdj][0]==ptyogikbvlnt&&vetzudaihlcx[wrchcqmfsrdj][1]==fqjzczqslnya)
RETURN return  vetzudaihlcx[wrchcqmfsrdj][2]; return  vetzudaihlcx[wrchcqmfsrdj][2];
<operator>.logicalAnd vetzudaihlcx[wrchcqmfsrdj][0]==fqjzczqslnya&&vetzudaihlcx[wrchcqmfsrdj][1]==ptyogikbvlnt
<operator>.logicalAnd vetzudaihlcx[wrchcqmfsrdj][0]==ptyogikbvlnt&&vetzudaihlcx[wrchcqmfsrdj][1]==fqjzczqslnya
<operator>.equals vetzudaihlcx[wrchcqmfsrdj][0]==fqjzczqslnya
<operator>.equals vetzudaihlcx[wrchcqmfsrdj][1]==ptyogikbvlnt
<operator>.equals vetzudaihlcx[wrchcqmfsrdj][0]==ptyogikbvlnt
<operator>.equals vetzudaihlcx[wrchcqmfsrdj][1]==fqjzczqslnya
<operator>.indirectIndexAccess vetzudaihlcx[wrchcqmfsrdj][2]
<operator>.indirectIndexAccess vetzudaihlcx[wrchcqmfsrdj][0]
<operator>.indirectIndexAccess vetzudaihlcx[wrchcqmfsrdj][1]
<operator>.indirectIndexAccess vetzudaihlcx[wrchcqmfsrdj][0]
<operator>.indirectIndexAccess vetzudaihlcx[wrchcqmfsrdj][1]
<operator>.indirectIndexAccess vetzudaihlcx[wrchcqmfsrdj]
<operator>.indirectIndexAccess vetzudaihlcx[wrchcqmfsrdj]
<operator>.indirectIndexAccess vetzudaihlcx[wrchcqmfsrdj]
<operator>.indirectIndexAccess vetzudaihlcx[wrchcqmfsrdj]
<operator>.indirectIndexAccess vetzudaihlcx[wrchcqmfsrdj]
>>>PDG&29 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->12 0->15 0->16 0->17 0->18 2->1 3->7 4->15 5->1 5->16 5->17 6->1 7->1 7->1 7->1 7->6 7->8 7->11 7->13 7->15 7->20 7->25 8->1 8->7 9->6 10->1 10->7 11->1 11->1 11->1 11->7 11->8 11->12 11->19 11->24 12->1 13->1 13->1 13->11 13->11 13->14 13->17 13->22 13->27 14->1 14->1 14->11 14->11 15->1 15->1 15->13 15->13 15->16 15->17 15->18 15->21 15->26 16->1 16->1 16->13 16->13 16->17 16->18 17->1 17->1 17->14 17->14 17->15 17->16 17->18 17->23 17->28 18->1 18->1 18->14 18->14 18->15 18->16
>>>Token char wzfkhhovtwbd ( char vetzudaihlcx [ 37 ] [ 3 ] , int fxhwetnaxlgm , char fqjzczqslnya , char ptyogikbvlnt ) { int wrchcqmfsrdj ; for ( wrchcqmfsrdj = 0 ; wrchcqmfsrdj < fxhwetnaxlgm ; wrchcqmfsrdj ++ ) if ( ( vetzudaihlcx [ wrchcqmfsrdj ] [ 0 ] == fqjzczqslnya && vetzudaihlcx [ wrchcqmfsrdj ] [ 1 ] == ptyogikbvlnt ) || ( vetzudaihlcx [ wrchcqmfsrdj ] [ 0 ] == ptyogikbvlnt && vetzudaihlcx [ wrchcqmfsrdj ] [ 1 ] == fqjzczqslnya ) ) return vetzudaihlcx [ wrchcqmfsrdj ] [ 2 ] ; return ' \0 ' ; }
>>>Func
METHOD ikgzyzqgcnku
METHOD_RETURN void
PARAM int *pNumDataset
PARAM TypeDataSet mkejuahlafue [ ]
<operator>.assignment *fd=fopen("dataset.txt","r")
fscanf fscanf(fd,"%d\n",&kgidhihmjbse)
<operator>.assignment *pNumDataset=kgidhihmjbse
fclose fclose(fd)
<operator>.lessThan i<kgidhihmjbse
<operator>.postIncrement i++
readDataSet readDataSet(fd,&mkejuahlafue[i])
fopen fopen("dataset.txt","r")
<operator>.assignment i=0
<operator>.addressOf &mkejuahlafue[i]
<operator>.indirectIndexAccess mkejuahlafue[i]
>>>PDG&15 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 3->1 3->10 4->1 4->1 4->5 5->1 5->1 5->6 5->7 5->8 5->10 6->1 6->1 7->1 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->10 8->13 8->14 9->1 9->8 10->1 10->1 10->7 11->4 11->4 12->1 12->8
>>>Token void ikgzyzqgcnku ( int * pNumDataset , TypeDataSet mkejuahlafue [ ] ) { int kgidhihmjbse , i ; FILE * fd = fopen ( " " , " " ) ; fscanf ( fd , " \n " , & kgidhihmjbse ) ; * pNumDataset = kgidhihmjbse ; for ( i = 0 ; i < kgidhihmjbse ; i ++ ) readDataSet ( fd , & mkejuahlafue [ i ] ) ; fclose ( fd ) ; }
>>>Func
METHOD upccyoofxneo
METHOD_RETURN void
PARAM int *C
PARAM int *D
PARAM int *N
scanf scanf("%d",C)
scanf scanf("%d",D)
scanf scanf("%d",N)
scanf scanf("%c",&arskyidnskau)
<operator>.lessThan gxqhjeophtex<*C
<operator>.postIncrement gxqhjeophtex++
<operator>.lessThan gxqhjeophtex<*D
<operator>.postIncrement gxqhjeophtex++
<operator>.lessThan gxqhjeophtex<*N
<operator>.postIncrement gxqhjeophtex++
<operator>.assignment gxqhjeophtex=0
scanf scanf("%c",&arskyidnskau)
scanf scanf("%c%c%c",&c_input[gxqhjeophtex].element1,&c_input[gxqhjeophtex].element2,&c_input[gxqhjeophtex].combine)
<operator>.assignment gxqhjeophtex=0
scanf scanf("%c",&arskyidnskau)
scanf scanf("%c%c",&d_input[gxqhjeophtex].element1,&d_input[gxqhjeophtex].element2)
<operator>.assignment gxqhjeophtex=0
scanf scanf("%c",&n_input[gxqhjeophtex])
<operator>.indirection *C
<operator>.indirection *D
<operator>.indirection *N
<operator>.addressOf &arskyidnskau
<operator>.addressOf &c_input[gxqhjeophtex].element1
<operator>.addressOf &c_input[gxqhjeophtex].element2
<operator>.addressOf &c_input[gxqhjeophtex].combine
<operator>.addressOf &arskyidnskau
<operator>.addressOf &d_input[gxqhjeophtex].element1
<operator>.addressOf &d_input[gxqhjeophtex].element2
<operator>.addressOf &n_input[gxqhjeophtex]
<operator>.fieldAccess c_input[gxqhjeophtex].element1
<operator>.fieldAccess c_input[gxqhjeophtex].element2
<operator>.fieldAccess c_input[gxqhjeophtex].combine
<operator>.fieldAccess d_input[gxqhjeophtex].element1
<operator>.fieldAccess d_input[gxqhjeophtex].element2
<operator>.indirectIndexAccess n_input[gxqhjeophtex]
<operator>.indirectIndexAccess c_input[gxqhjeophtex]
FIELD_IDENTIFIER element1 element1
<operator>.indirectIndexAccess c_input[gxqhjeophtex]
FIELD_IDENTIFIER element2 element2
<operator>.indirectIndexAccess c_input[gxqhjeophtex]
FIELD_IDENTIFIER combine combine
<operator>.indirectIndexAccess d_input[gxqhjeophtex]
FIELD_IDENTIFIER element1 element1
<operator>.indirectIndexAccess d_input[gxqhjeophtex]
FIELD_IDENTIFIER element2 element2
>>>PDG&50 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->18 0->19 0->21 2->5 3->6 4->7 5->1 6->1 7->1 8->1 9->1 9->1 9->9 9->10 9->10 9->16 9->17 9->23 9->26 9->27 9->28 9->29 9->34 9->35 9->36 9->40 9->41 9->42 9->43 9->44 9->45 10->1 10->9 11->1 11->1 11->11 11->12 11->12 11->19 11->20 11->24 11->30 11->31 11->32 11->37 11->38 11->46 11->47 11->48 11->49 12->1 12->11 13->1 13->1 13->1 13->13 13->14 13->14 13->22 13->25 13->33 13->39 14->1 14->13 15->9 16->8 16->19 18->11 19->8 21->1 21->13
>>>Token void upccyoofxneo ( int * C , int * D , int * N ) { int gxqhjeophtex ; char arskyidnskau ; scanf ( " " , C ) ; for ( gxqhjeophtex = 0 ; gxqhjeophtex < * C ; gxqhjeophtex ++ ) { scanf ( " " , & arskyidnskau ) ; scanf ( " " , & c_input [ gxqhjeophtex ] . element1 , & c_input [ gxqhjeophtex ] . element2 , & c_input [ gxqhjeophtex ] . combine ) ; } scanf ( " " , D ) ; for ( gxqhjeophtex = 0 ; gxqhjeophtex < * D ; gxqhjeophtex ++ ) { scanf ( " " , & arskyidnskau ) ; scanf ( " " , & d_input [ gxqhjeophtex ] . element1 , & d_input [ gxqhjeophtex ] . element2 ) ; } scanf ( " " , N ) ; scanf ( " " , & arskyidnskau ) ; for ( gxqhjeophtex = 0 ; gxqhjeophtex < * N ; gxqhjeophtex ++ ) { scanf ( " " , & n_input [ gxqhjeophtex ] ) ; } }
>>>Func
METHOD uqkhyoytrpuvblake2b_init0
METHOD_RETURN ANY
PARAM blake2b_state *S
memset memset(S 0 sizeof(blake2b_state))
<operator>.lessThan offyteiuwain<8
<operator>.preIncrement ++offyteiuwain
<operator>.assignment S->h[offyteiuwain]=blake2b_IV[offyteiuwain]
<operator>.sizeOf sizeof(blake2b_state)
<operator>.assignment offyteiuwain=0
<operator>.indirectIndexAccess S->h[offyteiuwain]
<operator>.indirectIndexAccess blake2b_IV[offyteiuwain]
<operator>.indirectFieldAccess S->h
FIELD_IDENTIFIER h h
>>>PDG&13 0->2 0->3 0->4 0->5 0->8 2->3 3->1 3->1 4->1 4->1 4->4 4->5 4->5 4->6 4->9 4->10 4->11 4->12 5->1 5->4 7->1 8->1 8->4
>>>Token static uqkhyoytrpuvblake2b_init0 ( blake2b_state * S )  { size_t offyteiuwain ; memset ( S , 0 , sizeof ( blake2b_state ) ) ; for ( offyteiuwain = 0 ; offyteiuwain < 8 ; ++ offyteiuwain ) S -> h [ offyteiuwain ] = blake2b_IV [ offyteiuwain ] ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
IDENTIFIER std <empty>
RETURN return 0; return 0;
<operator>.lessThan diseviijxuiz<zlwhnmacvwgf
<operator>.postIncrement diseviijxuiz++
calc_case calc_case(diseviijxuiz)
LITERAL 0 return 0;
<operator>.assignment diseviijxuiz=0
>>>PDG&10 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 2->1 4->1 5->1 5->1 5->1 5->5 5->6 5->7 5->7 6->1 6->5 7->1 7->6 8->4 9->1 9->5
>>>Token int main ( void ) { int zlwhnmacvwgf ; std : : cin >> zlwhnmacvwgf ; for ( int diseviijxuiz = 0 ; diseviijxuiz < zlwhnmacvwgf ; diseviijxuiz ++ ) calc_case ( diseviijxuiz ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment cont=0
scanf scanf("%d ",&iltpgkfadtyo)
RETURN return 0; return 0;
<operator>.postDecrement iltpgkfadtyo--
LITERAL 0 return 0;
scanf scanf("%d %d %d",&mehvjkexcaxg,&hrafxannascj,&p1)
<operator>.assignment xp0=100-hrafxannascj
kuokjknrvnqm kuokjknrvnqm(hrafxannascj&&xp0)
BLOCK <empty> <empty>
IDENTIFIER ndif <empty>
kuokjknrvnqm kuokjknrvnqm((hrafxannascj+xp0)>mehvjkexcaxg)
printf printf("Case #%d: Possible\n",++cont)
<operator>.assignment ytsvkzhvuuyj=GCD(hrafxannascj,xp0)
<operator>.assignmentDivision xp0/=ytsvkzhvuuyj
printf printf("Case #%d: Broken\n",++cont)
<operator>.subtraction 100-hrafxannascj
<operator>.logicalAnd hrafxannascj&&xp0
<operator>.greaterThan (hrafxannascj+xp0)>mehvjkexcaxg
GCD GCD(hrafxannascj,xp0)
<operator>.addition hrafxannascj+xp0
<operator>.preIncrement ++cont
UNKNOWN,),)
UNKNOWN else {hrafxannascj=(hrafxannascj)?1:0;xp0=(xp0)?1:0;} else {hrafxannascj=(hrafxannascj)?1:0;xp0=(xp0)?1:0;}
UNKNOWN f f
UNKNOWN <missing';'>("%d %d %d\n",hrafxannascj,xp0,mehvjkexcaxg); <missing';'>("%d %d %d\n",hrafxannascj,xp0,mehvjkexcaxg);
UNKNOWN f f
UNKNOWN,),)
<operator>.addressOf &mehvjkexcaxg
<operator>.addressOf &hrafxannascj
<operator>.addressOf &p1
UNKNOWN f f
UNKNOWN <missing';'>("GCD: %d %d: %d\n",hrafxannascj,xp0,ytsvkzhvuuyj); <missing';'>("GCD: %d %d: %d\n",hrafxannascj,xp0,ytsvkzhvuuyj);
UNKNOWN j j
UNKNOWN /=ytsvkzhvuuyj; /=ytsvkzhvuuyj;
<operator>.logicalAnd hrafxannascj&&!p1
<operator>.logicalAnd xp0&&!xp1
<operator>.logicalNot !xp1
>>>PDG&39 0->2 0->3 0->4 0->5 0->6 0->7 0->10 0->11 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 2->1 2->1 2->22 3->1 3->5 4->1 5->1 5->1 5->5 5->7 5->8 5->9 5->12 5->14 5->15 5->16 5->17 5->18 5->19 5->20 5->21 5->22 5->23 5->24 5->25 5->26 5->27 5->28 5->29 5->30 5->31 5->32 5->33 5->34 5->35 6->4 7->1 7->1 7->1 7->19 8->1 8->1 8->18 9->1 9->1 12->1 12->1 13->1 13->1 14->1 14->1 14->15 15->1 15->1 15->19 15->21 16->1 16->1 17->8 17->8 17->18 18->9 18->9 18->20 18->20 19->1 19->1 19->7 19->12 19->12 20->14 20->14 20->15 20->17 20->19 20->21 21->1 21->1 22->1 22->16 36->37 36->38
>>>Token int main ( ) { int iltpgkfadtyo , cont = 0 ; scanf ( " " , & iltpgkfadtyo ) ; while ( iltpgkfadtyo -- ) { int mehvjkexcaxg , hrafxannascj , xp0 , p1 , xp1 ; int ytsvkzhvuuyj ; scanf ( " " , & mehvjkexcaxg , & hrafxannascj , & p1 ) ; xp0 = 100 - hrafxannascj ; kuokjknrvnqm ( hrafxannascj && xp0 )  { ytsvkzhvuuyj = GCD ( hrafxannascj , xp0 ) ; def puqmqhditsqbprintf < missing ' ; ' ( " \n " , hrafxannascj , xp0 , ytsvkzhvuuyj ) ; ndif hrafxannascj /= ytsvkzhvuuyj ; xp0 /= ytsvkzhvuuyj ; } else { hrafxannascj = ( hrafxannascj ) ? 1 : 0 ; xp0 = ( xp0 ) ? 1 : 0 ; } def puqmqhditsqbprintf < missing ' ; ' ( " \n " , hrafxannascj , xp0 , mehvjkexcaxg ) ; ndif kuokjknrvnqm ( ( hrafxannascj + xp0 ) > mehvjkexcaxg ) { printf ( " \n " , ++ cont ) ; continue ; } xp1 = 100 - p1 ; kuokjknrvnqm ( ( hrafxannascj && ! p1 ) || ( xp0 && ! xp1 ) )  { printf ( " \n " , ++ cont ) ; continue ; } printf ( " \n " , ++ cont ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int haanuiyjgrpl
PARAM char *argv [ ]
<operator>.assignment dwiuhpfivitj=VERBOSE_LEVEL_DEFAULT
<operator>.assignment *input_file_name_default="input.txt"
<operator>.assignment *input_file_name=NULL
<operator>.assignment *output_file_name_default="output.txt"
<operator>.assignment *output_file_name=NULL
siktqgrhbimd siktqgrhbimd(input_file_name==NULL)
BLOCK <empty> <empty>
siktqgrhbimd siktqgrhbimd(output_file_name==NULL)
BLOCK <empty> <empty>
<operator>.assignment input_file_ptr=fopen(input_file_name,"r")
siktqgrhbimd siktqgrhbimd(input_file_ptr==NULL)
<operator>.lessThan amhrupdjqumo<haanuiyjgrpl
<operator>.postIncrement amhrupdjqumo++
<operator>.assignment input_file_name=input_file_name_default
<operator>.assignment output_file_name=output_file_name_default
printf printf("Error opening input file.\n")
RETURN return 0; return 0;
<operator>.assignment amhrupdjqumo=1
siktqgrhbimd siktqgrhbimd(strcmp(argv[amhrupdjqumo],"-i")==0&&amhrupdjqumo+1<haanuiyjgrpl)
BLOCK <empty> <empty>
<operator>.equals input_file_name==NULL
<operator>.equals output_file_name==NULL
fopen fopen(input_file_name,"r")
<operator>.equals input_file_ptr==NULL
LITERAL 0 return 0;
<operator>.assignment input_file_name=argv[++amhrupdjqumo]
<operator>.logicalAnd strcmp(argv[amhrupdjqumo],"-i")==0&&amhrupdjqumo+1<haanuiyjgrpl
<operator>.equals strcmp(argv[amhrupdjqumo],"-i")==0
<operator>.lessThan amhrupdjqumo+1<haanuiyjgrpl
strcmp strcmp(argv[amhrupdjqumo],"-i")
<operator>.addition amhrupdjqumo+1
<operator>.preIncrement ++amhrupdjqumo
<operator>.lessEqualsThan test_id<=hltyvcoeiala
<operator>.postIncrement test_id++
UNKNOWN,),)
UNKNOWN else siktqgrhbimd (strcmp(argv[amhrupdjqumo],"-o")==0&&amhrupdjqumo+1<haanuiyjgrpl){output_file_name=argv[++amhrupdjqumo];} else siktqgrhbimd (strcmp(argv[amhrupdjqumo],"-o")==0&&amhrupdjqumo+1<haanuiyjgrpl){output_file_name=argv[++amhrupdjqumo];}
UNKNOWN else siktqgrhbimd (strcmp(argv[amhrupdjqumo],"-v")==0){dwiuhpfivitj=atoi(argv[++amhrupdjqumo]);} else siktqgrhbimd (strcmp(argv[amhrupdjqumo],"-v")==0){dwiuhpfivitj=atoi(argv[++amhrupdjqumo]);}
UNKNOWN else {printf("Error parsing arguments!\n");printf("Usage: bot_trust.bin -i <input_file_name> -o <output_file_name>");printf("  -v <verbose_level>\n");return 0;} else {printf("Error parsing arguments!\n");printf("Usage: bot_trust.bin -i <input_file_name> -o <output_file_name>");printf("  -v <verbose_level>\n");return 0;}
siktqgrhbimd siktqgrhbimd(dwiuhpfivitj>=1)
UNKNOWN,),)
<operator>.assignment temp_i=fscanf(input_file_ptr,"%d",&num_comb)
<operator>.assignment comb_list=malloc(num_comb *3 *sizeof(char))
<operator>.assignment temp_i=fscanf(input_file_ptr,"%d",&num_dest)
<operator>.assignment dest_list=malloc(num_dest *2 *sizeof(char))
<operator>.assignment temp_i=fscanf(input_file_ptr,"%d",&num_input_elt)
<operator>.assignment input_elt_list=malloc(num_input_elt *sizeof(char))
siktqgrhbimd siktqgrhbimd(dwiuhpfivitj>=2)
UNKNOWN,),)
<operator>.assignment output_elt_list=malloc(num_input_elt *sizeof(char))
<operator>.assignment j=-1
siktqgrhbimd siktqgrhbimd(dwiuhpfivitj>=4)
UNKNOWN,),)
<operator>.assignment num_output_elt=j+1
siktqgrhbimd siktqgrhbimd(dwiuhpfivitj>=1)
UNKNOWN,),)
fprintf fprintf(output_file_ptr,"Case #%d: [",test_id)
siktqgrhbimd siktqgrhbimd(num_output_elt>0)
UNKNOWN,),)
fprintf fprintf(output_file_ptr,"]\n",output_elt_list[amhrupdjqumo])
free free(comb_list)
free free(dest_list)
free free(input_elt_list)
free free(output_elt_list)
<operator>.greaterEqualsThan dwiuhpfivitj>=1
printf printf("  Test #%d:\n",test_id)
fscanf fscanf(input_file_ptr,"%d",&num_comb)
malloc malloc(num_comb *3 *sizeof(char))
<operator>.lessThan amhrupdjqumo<num_comb
<operator>.postIncrement amhrupdjqumo++
fscanf fscanf(input_file_ptr,"%d",&num_dest)
malloc malloc(num_dest *2 *sizeof(char))
<operator>.lessThan amhrupdjqumo<num_dest
<operator>.postIncrement amhrupdjqumo++
fscanf fscanf(input_file_ptr,"%d",&num_input_elt)
malloc malloc(num_input_elt *sizeof(char))
<operator>.lessThan amhrupdjqumo<num_input_elt
<operator>.postIncrement amhrupdjqumo++
<operator>.greaterEqualsThan dwiuhpfivitj>=2
printf printf("    Combination rules:")
printf printf("\n")
printf printf("    Destruction rules:")
printf printf("\n")
printf printf("    Input list: ")
printf printf("\n")
malloc malloc(num_input_elt *sizeof(char))
<operator>.minus -1
<operator>.lessThan amhrupdjqumo<num_input_elt
<operator>.postIncrement amhrupdjqumo++
<operator>.greaterEqualsThan dwiuhpfivitj>=4
printf printf("      olist: ")
printf printf("\n")
<operator>.addition j+1
<operator>.greaterEqualsThan dwiuhpfivitj>=1
printf printf("    Output list: [")
siktqgrhbimd siktqgrhbimd(num_output_elt>0)
UNKNOWN,),)
printf printf("]\n",output_elt_list[amhrupdjqumo])
<operator>.lessEqualsThan amhrupdjqumo<=num_output_elt-2
<operator>.postIncrement amhrupdjqumo++
<operator>.greaterThan num_output_elt>0
fprintf fprintf(output_file_ptr,"%c",output_elt_list[amhrupdjqumo])
<operator>.indirectIndexAccess output_elt_list[amhrupdjqumo]
<operator>.indirectIndexAccess argv[++amhrupdjqumo]
<operator>.addressOf &num_comb
<operator>.multiplication num_comb *3 *sizeof(char)
<operator>.assignment amhrupdjqumo=0
<operator>.assignment temp_i=fscanf(input_file_ptr," %c%c%c",&comb_list[amhrupdjqumo *3+0],&comb_list[amhrupdjqumo *3+1],&comb_list[amhrupdjqumo *3+2])
<operator>.addressOf &num_dest
<operator>.multiplication num_dest *2 *sizeof(char)
<operator>.assignment amhrupdjqumo=0
<operator>.assignment temp_i=fscanf(input_file_ptr," %c%c",&dest_list[amhrupdjqumo *2+0],&dest_list[amhrupdjqumo *2+1])
<operator>.addressOf &num_input_elt
<operator>.multiplication num_input_elt *sizeof(char)
<operator>.assignment amhrupdjqumo=0
<operator>.assignment temp_i=fscanf(input_file_ptr," %c",&input_elt_list[amhrupdjqumo])
<operator>.lessThan amhrupdjqumo<num_comb
<operator>.postIncrement amhrupdjqumo++
<operator>.lessThan amhrupdjqumo<num_dest
<operator>.postIncrement amhrupdjqumo++
<operator>.lessThan amhrupdjqumo<num_input_elt
<operator>.postIncrement amhrupdjqumo++
<operator>.multiplication num_input_elt *sizeof(char)
<operator>.assignment amhrupdjqumo=0
siktqgrhbimd siktqgrhbimd(dwiuhpfivitj>=4)
UNKNOWN,),)
siktqgrhbimd siktqgrhbimd(j==-1)
UNKNOWN,),)
<operator>.lessEqualsThan k<=j
<operator>.postIncrement k++
<operator>.lessEqualsThan amhrupdjqumo<=num_output_elt-2
<operator>.postIncrement amhrupdjqumo++
<operator>.greaterThan num_output_elt>0
printf printf("%c",output_elt_list[amhrupdjqumo])
<operator>.indirectIndexAccess output_elt_list[amhrupdjqumo]
<operator>.assignment amhrupdjqumo=0
<operator>.subtraction num_output_elt-2
fprintf fprintf(output_file_ptr,"%c, ",output_elt_list[amhrupdjqumo])
<operator>.indirectIndexAccess output_elt_list[amhrupdjqumo]
<operator>.multiplication num_comb *3
<operator>.sizeOf sizeof(char)
fscanf fscanf(input_file_ptr," %c%c%c",&comb_list[amhrupdjqumo *3+0],&comb_list[amhrupdjqumo *3+1],&comb_list[amhrupdjqumo *3+2])
<operator>.multiplication num_dest *2
<operator>.sizeOf sizeof(char)
fscanf fscanf(input_file_ptr," %c%c",&dest_list[amhrupdjqumo *2+0],&dest_list[amhrupdjqumo *2+1])
<operator>.sizeOf sizeof(char)
fscanf fscanf(input_file_ptr," %c",&input_elt_list[amhrupdjqumo])
<operator>.assignment amhrupdjqumo=0
printf printf(" %c%c%c",comb_list[amhrupdjqumo *3+0],comb_list[amhrupdjqumo *3+1],comb_list[amhrupdjqumo *3+2])
<operator>.assignment amhrupdjqumo=0
printf printf(" %c%c",dest_list[amhrupdjqumo *2+0],dest_list[amhrupdjqumo *2+1])
<operator>.assignment amhrupdjqumo=0
printf printf("%c",input_elt_list[amhrupdjqumo])
<operator>.sizeOf sizeof(char)
<operator>.greaterEqualsThan dwiuhpfivitj>=4
printf printf("      olist: ")
printf printf("\n")
<operator>.equals j==-1
<operator>.assignment j=0
<operator>.assignment output_elt_list[j]=input_elt_list[amhrupdjqumo]
<operator>.lessThan k<num_comb
<operator>.lessThan k<num_dest
<operator>.assignment k=0
printf printf("%c",output_elt_list[k])
<operator>.assignment amhrupdjqumo=0
<operator>.subtraction num_output_elt-2
printf printf("%c, ",output_elt_list[amhrupdjqumo])
<operator>.indirectIndexAccess output_elt_list[amhrupdjqumo]
<operator>.indirectIndexAccess output_elt_list[amhrupdjqumo]
<operator>.indirectIndexAccess argv[amhrupdjqumo]
<operator>.addressOf &comb_list[amhrupdjqumo *3+0]
<operator>.addressOf &comb_list[amhrupdjqumo *3+1]
<operator>.addressOf &comb_list[amhrupdjqumo *3+2]
<operator>.addressOf &dest_list[amhrupdjqumo *2+0]
<operator>.addressOf &dest_list[amhrupdjqumo *2+1]
<operator>.addressOf &input_elt_list[amhrupdjqumo]
<operator>.indirectIndexAccess comb_list[amhrupdjqumo *3+0]
<operator>.indirectIndexAccess comb_list[amhrupdjqumo *3+1]
<operator>.indirectIndexAccess comb_list[amhrupdjqumo *3+2]
<operator>.indirectIndexAccess dest_list[amhrupdjqumo *2+0]
<operator>.indirectIndexAccess dest_list[amhrupdjqumo *2+1]
<operator>.indirectIndexAccess input_elt_list[amhrupdjqumo]
<operator>.lessEqualsThan k<=j
<operator>.postIncrement k++
<operator>.minus -1
<operator>.indirectIndexAccess output_elt_list[j]
<operator>.indirectIndexAccess input_elt_list[amhrupdjqumo]
siktqgrhbimd siktqgrhbimd(((output_elt_list[j]==comb_list[k *3+0])&&(input_elt_list[amhrupdjqumo]==comb_list[k *3+1]))||((output_elt_list[j]==comb_list[k *3+1])&&(input_elt_list[amhrupdjqumo]==comb_list[k *3+0])))
UNKNOWN,),)
siktqgrhbimd siktqgrhbimd(l<=j)
UNKNOWN,),)
<operator>.indirectIndexAccess output_elt_list[k]
<operator>.indirectIndexAccess output_elt_list[amhrupdjqumo]
<operator>.indirectIndexAccess comb_list[amhrupdjqumo *3+0]
<operator>.indirectIndexAccess comb_list[amhrupdjqumo *3+1]
<operator>.indirectIndexAccess comb_list[amhrupdjqumo *3+2]
<operator>.indirectIndexAccess dest_list[amhrupdjqumo *2+0]
<operator>.indirectIndexAccess dest_list[amhrupdjqumo *2+1]
<operator>.indirectIndexAccess input_elt_list[amhrupdjqumo]
<operator>.addition amhrupdjqumo *3+0
<operator>.addition amhrupdjqumo *3+1
<operator>.addition amhrupdjqumo *3+2
<operator>.addition amhrupdjqumo *2+0
<operator>.addition amhrupdjqumo *2+1
<operator>.assignment k=0
printf printf("%c",output_elt_list[k])
<operator>.logicalOr ((output_elt_list[j]==comb_list[k *3+0])&&(input_elt_list[amhrupdjqumo]==comb_list[k *3+1]))||((output_elt_list[j]==comb_list[k *3+1])&&(input_elt_list[amhrupdjqumo]==comb_list[k *3+0]))
<operator>.assignment output_elt_list[j]=comb_list[k *3+2]
<operator>.lessEqualsThan l<=j
<operator>.lessEqualsThan l<=j
<operator>.assignment j=-1
<operator>.addition amhrupdjqumo *3+0
<operator>.addition amhrupdjqumo *3+1
<operator>.addition amhrupdjqumo *3+2
<operator>.addition amhrupdjqumo *2+0
<operator>.addition amhrupdjqumo *2+1
<operator>.multiplication amhrupdjqumo *3
<operator>.multiplication amhrupdjqumo *3
<operator>.multiplication amhrupdjqumo *3
<operator>.multiplication amhrupdjqumo *2
<operator>.multiplication amhrupdjqumo *2
<operator>.indirectIndexAccess output_elt_list[k]
<operator>.logicalAnd (output_elt_list[j]==comb_list[k *3+0])&&(input_elt_list[amhrupdjqumo]==comb_list[k *3+1])
<operator>.logicalAnd (output_elt_list[j]==comb_list[k *3+1])&&(input_elt_list[amhrupdjqumo]==comb_list[k *3+0])
<operator>.indirectIndexAccess output_elt_list[j]
<operator>.indirectIndexAccess comb_list[k *3+2]
<operator>.assignment l=0
siktqgrhbimd siktqgrhbimd(((output_elt_list[l]==dest_list[k *2+0])&&(input_elt_list[amhrupdjqumo]==dest_list[k *2+1]))||((output_elt_list[l]==dest_list[k *2+1])&&(input_elt_list[amhrupdjqumo]==dest_list[k *2+0])))
UNKNOWN,),)
<operator>.minus -1
<operator>.multiplication amhrupdjqumo *3
<operator>.multiplication amhrupdjqumo *3
<operator>.multiplication amhrupdjqumo *3
<operator>.multiplication amhrupdjqumo *2
<operator>.multiplication amhrupdjqumo *2
<operator>.equals output_elt_list[j]==comb_list[k *3+0]
<operator>.equals input_elt_list[amhrupdjqumo]==comb_list[k *3+1]
<operator>.equals output_elt_list[j]==comb_list[k *3+1]
<operator>.equals input_elt_list[amhrupdjqumo]==comb_list[k *3+0]
<operator>.addition k *3+2
<operator>.logicalOr ((output_elt_list[l]==dest_list[k *2+0])&&(input_elt_list[amhrupdjqumo]==dest_list[k *2+1]))||((output_elt_list[l]==dest_list[k *2+1])&&(input_elt_list[amhrupdjqumo]==dest_list[k *2+0]))
<operator>.indirectIndexAccess output_elt_list[j]
<operator>.indirectIndexAccess comb_list[k *3+0]
<operator>.indirectIndexAccess input_elt_list[amhrupdjqumo]
<operator>.indirectIndexAccess comb_list[k *3+1]
<operator>.indirectIndexAccess output_elt_list[j]
<operator>.indirectIndexAccess comb_list[k *3+1]
<operator>.indirectIndexAccess input_elt_list[amhrupdjqumo]
<operator>.indirectIndexAccess comb_list[k *3+0]
<operator>.multiplication k *3
<operator>.logicalAnd (output_elt_list[l]==dest_list[k *2+0])&&(input_elt_list[amhrupdjqumo]==dest_list[k *2+1])
<operator>.logicalAnd (output_elt_list[l]==dest_list[k *2+1])&&(input_elt_list[amhrupdjqumo]==dest_list[k *2+0])
<operator>.addition k *3+0
<operator>.addition k *3+1
<operator>.addition k *3+1
<operator>.addition k *3+0
<operator>.equals output_elt_list[l]==dest_list[k *2+0]
<operator>.equals input_elt_list[amhrupdjqumo]==dest_list[k *2+1]
<operator>.equals output_elt_list[l]==dest_list[k *2+1]
<operator>.equals input_elt_list[amhrupdjqumo]==dest_list[k *2+0]
<operator>.multiplication k *3
<operator>.multiplication k *3
<operator>.multiplication k *3
<operator>.multiplication k *3
<operator>.indirectIndexAccess output_elt_list[l]
<operator>.indirectIndexAccess dest_list[k *2+0]
<operator>.indirectIndexAccess input_elt_list[amhrupdjqumo]
<operator>.indirectIndexAccess dest_list[k *2+1]
<operator>.indirectIndexAccess output_elt_list[l]
<operator>.indirectIndexAccess dest_list[k *2+1]
<operator>.indirectIndexAccess input_elt_list[amhrupdjqumo]
<operator>.indirectIndexAccess dest_list[k *2+0]
<operator>.addition k *2+0
<operator>.addition k *2+1
<operator>.addition k *2+1
<operator>.addition k *2+0
<operator>.multiplication k *2
<operator>.multiplication k *2
<operator>.multiplication k *2
<operator>.multiplication k *2
>>>PDG&283 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->10 0->12 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->23 0->24 0->25 0->26 0->27 0->28 0->31 0->32 0->33 0->34 0->35 2->15 3->1 3->29 3->33 4->1 4->1 4->1 5->1 5->17 6->1 6->24 7->1 7->18 8->1 8->25 9->1 9->1 11->1 11->1 13->1 13->1 13->27 14->1 14->1 15->1 15->1 15->1 15->15 15->16 15->22 15->29 15->30 15->31 15->32 15->32 15->33 15->34 15->35 15->35 15->38 15->39 15->40 15->41 15->106 15->172 16->1 16->15 17->1 17->1 17->26 18->1 18->1 18->1 19->1 20->1 21->1 21->15 22->1 22->1 24->9 24->9 24->25 25->11 25->11 25->27 26->1 26->13 26->13 27->1 27->1 27->14 27->14 28->20 29->1 29->1 29->24 30->1 30->1 30->22 30->22 31->1 31->30 31->30 31->32 31->34 32->1 32->15 32->30 32->30 33->1 33->31 33->31 35->16 36->36 36->37 36->42 36->43 36->44 36->45 36->46 36->47 36->48 36->49 36->50 36->51 36->52 36->53 36->54 36->55 36->56 36->57 36->58 36->59 36->60 36->61 36->62 36->63 36->64 36->65 36->66 36->67 36->68 36->69 36->70 36->71 36->73 36->74 36->75 36->77 36->78 36->79 36->81 36->82 36->83 36->84 36->85 36->86 36->87 36->88 36->89 36->90 36->92 36->93 36->94 36->95 36->96 36->97 36->98 36->99 36->100 36->101 36->103 36->104 36->105 36->107 36->108 36->109 36->111 36->112 36->113 36->115 36->116 36->117 36->119 36->121 36->123 36->125 36->126 36->131 36->133 36->135 36->136 36->137 36->138 36->139 36->141 36->142 36->143 36->145 36->146 36->148 36->150 36->152 36->154 36->156 36->165 36->167 36->168 36->170 71->71 71->72 71->110 71->144 71->173 71->174 71->175 71->196 71->197 71->198 71->214 71->215 71->216 71->233 71->234 71->235 75->75 75->76 75->114 75->147 75->176 75->177 75->199 75->200 75->217 75->218 75->236 75->237 79->79 79->80 79->118 79->149 79->178 79->201 90->90 90->91 90->127 90->128 90->129 90->130 90->157 90->158 90->159 90->160 90->161 90->162 90->185 90->187 90->188 90->189 90->207 101->101 101->102 101->139 101->140 101->171 119->119 119->120 119->151 119->179 119->180 119->181 119->202 119->203 119->204 119->219 119->220 119->221 121->121 121->122 121->153 121->182 121->183 121->205 121->206 121->222 121->223 123->123 123->124 123->155 123->184 131->131 131->132 131->166 131->194 133->133 133->134 133->168 133->169 133->195 163->190 163->191 163->209 163->210 163->225 163->227 163->228 163->238 163->242 163->244 163->245 163->252 163->255 163->263 164->192 164->193 164->211 164->212 164->213 164->229 164->232 185->185 185->186 185->208 185->224 211->230 211->231 211->243 211->253 211->259 211->267 211->268 211->275 211->279 225->226 225->240 225->248 225->249 225->257 225->265 238->239 238->246 238->247 238->256 238->264 240->241 240->250 240->251 240->258 240->266 253->254 253->261 253->271 253->272 253->277 253->281 259->260 259->269 259->270 259->276 259->280 261->262 261->273 261->274 261->278 261->282
>>>Token int main ( int haanuiyjgrpl , char * argv [ ] ) { int amhrupdjqumo , j , k , l , temp_i ; char hfstmqraskwh ; FILE * input_file_ptr , * output_file_ptr ; int dwiuhpfivitj = VERBOSE_LEVEL_DEFAULT ; char * input_file_name_default = " " ; char * input_file_name = NULL ; char * output_file_name_default = " " ; char * output_file_name = NULL ; int hltyvcoeiala , test_id , num_comb , num_dest , num_input_elt , num_output_elt ; char * comb_list , * dest_list , * input_elt_list , * output_elt_list ; for ( amhrupdjqumo = 1 ; amhrupdjqumo < haanuiyjgrpl ; amhrupdjqumo ++ ) { siktqgrhbimd ( strcmp ( argv [ amhrupdjqumo ] , " " ) == 0 && amhrupdjqumo + 1 < haanuiyjgrpl )  { input_file_name = argv [ ++ amhrupdjqumo ] ; } else siktqgrhbimd ( strcmp ( argv [ amhrupdjqumo ] , " - o " ) == 0 && amhrupdjqumo + 1 < haanuiyjgrpl )  { output_file_name = argv [ ++ amhrupdjqumo ] ; } else siktqgrhbimd ( strcmp ( argv [ amhrupdjqumo ] , " - v " ) == 0 ) { dwiuhpfivitj = atoi ( argv [ ++ amhrupdjqumo ] ) ; } else { printf ( " Error parsing arguments ! n " ) ; printf ( " " ) ; printf ( " \n " ) ; return 0 ; } } siktqgrhbimd ( input_file_name == NULL )  { input_file_name = input_file_name_default ; } siktqgrhbimd ( output_file_name == NULL )  { output_file_name = output_file_name_default ; } input_file_ptr = fopen ( input_file_name , " " ) ; siktqgrhbimd ( input_file_ptr == NULL )  { printf ( " \n " ) ; return 0 ; } output_file_ptr = fopen ( output_file_name , " " ) ; siktqgrhbimd ( input_file_ptr == NULL )  { printf ( " \n " ) ; return 0 ; } temp_i = fscanf ( input_file_ptr , " " , & hltyvcoeiala ) ; siktqgrhbimd ( dwiuhpfivitj >= 2 )  { printf ( " \n " , hltyvcoeiala ) ; } for ( test_id = 1 ; test_id <= hltyvcoeiala ; test_id ++ ) { siktqgrhbimd ( dwiuhpfivitj >= 1 )  { printf ( " \n " , test_id ) ; } temp_i = fscanf ( input_file_ptr , " " , & num_comb ) ; comb_list = malloc ( num_comb * 3 * sizeof ( char ) ) ; for ( amhrupdjqumo = 0 ; amhrupdjqumo < num_comb ; amhrupdjqumo ++ ) { temp_i = fscanf ( input_file_ptr , " " , & comb_list [ amhrupdjqumo * 3 + 0 ] , & comb_list [ amhrupdjqumo * 3 + 1 ] , & comb_list [ amhrupdjqumo * 3 + 2 ] ) ; } temp_i = fscanf ( input_file_ptr , " " , & num_dest ) ; dest_list = malloc ( num_dest * 2 * sizeof ( char ) ) ; for ( amhrupdjqumo = 0 ; amhrupdjqumo < num_dest ; amhrupdjqumo ++ ) { temp_i = fscanf ( input_file_ptr , " " , & dest_list [ amhrupdjqumo * 2 + 0 ] , & dest_list [ amhrupdjqumo * 2 + 1 ] ) ; } temp_i = fscanf ( input_file_ptr , " " , & num_input_elt ) ; input_elt_list = malloc ( num_input_elt * sizeof ( char ) ) ; for ( amhrupdjqumo = 0 ; amhrupdjqumo < num_input_elt ; amhrupdjqumo ++ ) { temp_i = fscanf ( input_file_ptr , " " , & input_elt_list [ amhrupdjqumo ] ) ; } siktqgrhbimd ( dwiuhpfivitj >= 2 )  { printf ( " " ) ; for ( amhrupdjqumo = 0 ; amhrupdjqumo < num_comb ; amhrupdjqumo ++ ) { printf ( " " , comb_list [ amhrupdjqumo * 3 + 0 ] , comb_list [ amhrupdjqumo * 3 + 1 ] , comb_list [ amhrupdjqumo * 3 + 2 ] ) ; } printf ( " \n " ) ; printf ( " " ) ; for ( amhrupdjqumo = 0 ; amhrupdjqumo < num_dest ; amhrupdjqumo ++ ) { printf ( " " , dest_list [ amhrupdjqumo * 2 + 0 ] , dest_list [ amhrupdjqumo * 2 + 1 ] ) ; } printf ( " \n " ) ; printf ( " " ) ; for ( amhrupdjqumo = 0 ; amhrupdjqumo < num_input_elt ; amhrupdjqumo ++ ) { printf ( " " , input_elt_list [ amhrupdjqumo ] ) ; } printf ( " \n " ) ; } output_elt_list = malloc ( num_input_elt * sizeof ( char ) ) ; j = -1 ; for ( amhrupdjqumo = 0 ; amhrupdjqumo < num_input_elt ; amhrupdjqumo ++ ) { siktqgrhbimd ( dwiuhpfivitj >= 4 )  { printf ( " " ) ; for ( k = 0 ; k <= j ; k ++ ) { printf ( " " , output_elt_list [ k ] ) ; } printf ( " \n " ) ; } siktqgrhbimd ( j == -1 )  { j = 0 ; output_elt_list [ j ] = input_elt_list [ amhrupdjqumo ] ; continue ; } for ( k = 0 ; k < num_comb ; k ++ ) { siktqgrhbimd ( ( ( output_elt_list [ j ] == comb_list [ k * 3 + 0 ] ) && ( input_elt_list [ amhrupdjqumo ] == comb_list [ k * 3 + 1 ] ) ) || ( ( output_elt_list [ j ] == comb_list [ k * 3 + 1 ] ) && ( input_elt_list [ amhrupdjqumo ] == comb_list [ k * 3 + 0 ] ) ) )  { output_elt_list [ j ] = comb_list [ k * 3 + 2 ] ; break ; } } siktqgrhbimd ( k < num_comb )  { continue ; } for ( k = 0 ; k < num_dest ; k ++ ) { for ( l = 0 ; l <= j ; l ++ ) { siktqgrhbimd ( ( ( output_elt_list [ l ] == dest_list [ k * 2 + 0 ] ) && ( input_elt_list [ amhrupdjqumo ] == dest_list [ k * 2 + 1 ] ) ) || ( ( output_elt_list [ l ] == dest_list [ k * 2 + 1 ] ) && ( input_elt_list [ amhrupdjqumo ] == dest_list [ k * 2 + 0 ] ) ) )  { break ; } } siktqgrhbimd ( l <= j )  { j = -1 ; break ; } } siktqgrhbimd ( k < num_dest )  { continue ; } j += 1 ; output_elt_list [ j ] = input_elt_list [ amhrupdjqumo ] ; } siktqgrhbimd ( dwiuhpfivitj >= 4 )  { printf ( " " ) ; for ( k = 0 ; k <= j ; k ++ ) { printf ( " " , output_elt_list [ k ] ) ; } printf ( " \n " ) ; } num_output_elt = j + 1 ; siktqgrhbimd ( dwiuhpfivitj >= 1 )  { printf ( " " ) ; for ( amhrupdjqumo = 0 ; amhrupdjqumo <= num_output_elt - 2 ; amhrupdjqumo ++ ) { printf ( " " , output_elt_list [ amhrupdjqumo ] ) ; } siktqgrhbimd ( num_output_elt > 0 )  { printf ( " " , output_elt_list [ amhrupdjqumo ] ) ; } printf ( " \n " , output_elt_list [ amhrupdjqumo ] ) ; } fprintf ( output_file_ptr , " " , test_id ) ; for ( amhrupdjqumo = 0 ; amhrupdjqumo <= num_output_elt - 2 ; amhrupdjqumo ++ ) { fprintf ( output_file_ptr , " " , output_elt_list [ amhrupdjqumo ] ) ; } siktqgrhbimd ( num_output_elt > 0 )  { fprintf ( output_file_ptr , " " , output_elt_list [ amhrupdjqumo ] ) ; } fprintf ( output_file_ptr , " \n " , output_elt_list [ amhrupdjqumo ] ) ; free ( comb_list ) ; free ( dest_list ) ; free ( input_elt_list ) ; free ( output_elt_list ) ; } fclose ( input_file_ptr ) ; fclose ( output_file_ptr ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN ANY
RETURN return 0; return 0;
<operator>.lessEqualsThan cases<=ncases
<operator>.postIncrement cases++
LITERAL 0 return 0;
<operator>.expressionList scanf("%d",&ncases) cases=1
scanf scanf("%d %d %d",&hxwrwfoyzhyb,&pd,&pg)
<operator>.assignment sol=0
spwbkzlpconn spwbkzlpconn("Case #%d: ",cases)
<operator>.logicalAnd x>0&&sol==0
<operator>.postDecrement x--
<operator>.equals sol==0
scanf scanf("%d",&ncases)
<operator>.assignment cases=1
<operator>.assignment x=100000
spwbkzlpconn spwbkzlpconn("Broken\n")
<operator>.greaterThan x>0
<operator>.equals sol==0
<operator>.logicalAnd y>0&&sol==0
<operator>.postDecrement y--
spwbkzlpconn spwbkzlpconn ("Possible\n")
<operator>.assignment y=min(x,hxwrwfoyzhyb)
<operator>.assignment ikpfyoygwhtf=y *(pd/100.0)
<operator>.assignment p=y-ikpfyoygwhtf
<operator>.greaterThan y>0
<operator>.equals sol==0
<operator>.equals ikpfyoygwhtf==(int)ikpfyoygwhtf
min min(x,hxwrwfoyzhyb)
<operator>.multiplication y *(pd/100.0)
<operator>.subtraction y-ikpfyoygwhtf
<operator>.assignment d=x *(pg/100.0)
<operator>.division pd/100.0
<operator>.cast (int)ikpfyoygwhtf
<operator>.equals d==(int)d
<operator>.multiplication x *(pg/100.0)
<operator>.division pg/100.0
<operator>.cast (int)d
<operator>.logicalAnd (int)d>=(int)ikpfyoygwhtf&&x-d>=p
<operator>.postIncrement sol++
<operator>.greaterEqualsThan (int)d>=(int)ikpfyoygwhtf
<operator>.greaterEqualsThan x-d>=p
<operator>.cast (int)d
<operator>.cast (int)ikpfyoygwhtf
<operator>.subtraction x-d
<operator>.addressOf &hxwrwfoyzhyb
<operator>.addressOf &pd
<operator>.addressOf &pg
UNKNOWN int int
UNKNOWN int int
UNKNOWN int int
UNKNOWN int int
>>>PDG&52 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->20 0->21 0->25 0->26 0->27 0->28 0->29 0->30 0->32 0->33 0->34 0->35 0->36 0->37 0->39 0->40 0->41 0->42 0->43 0->44 2->1 3->1 3->1 3->1 3->3 3->4 3->7 3->8 3->9 3->9 3->10 3->12 3->15 3->17 3->45 3->46 3->47 4->1 4->3 5->2 6->1 6->1 7->1 7->1 7->1 7->28 8->1 8->12 8->18 8->26 8->39 9->1 9->4 10->1 10->1 10->10 10->11 10->17 10->19 10->19 10->22 10->25 10->28 11->1 11->17 12->1 12->1 12->10 12->16 12->21 13->1 13->3 13->6 14->3 14->6 15->1 15->17 16->1 17->1 17->10 17->10 17->18 17->28 18->10 18->10 18->12 18->26 18->39 19->1 19->1 19->10 19->19 19->20 19->23 19->24 19->25 19->27 19->29 19->30 19->32 19->33 19->48 20->1 20->25 21->1 22->1 22->1 22->25 23->1 23->1 23->30 24->1 24->1 24->1 24->41 25->1 25->19 25->19 25->26 25->29 26->12 26->18 26->19 26->19 26->39 27->1 27->1 27->1 27->31 27->34 27->35 27->36 27->37 27->40 27->43 27->49 28->1 28->7 28->11 28->22 28->22 28->35 29->1 29->23 29->23 29->30 30->20 30->24 30->24 30->27 30->33 31->1 31->1 31->34 31->37 32->1 32->29 32->29 34->1 34->1 34->1 34->38 34->40 34->40 34->42 34->42 34->43 34->44 34->50 34->51 35->1 35->11 35->31 35->31 35->44 36->1 36->35 36->35 38->1 38->1 38->1 38->39 39->1 39->12 39->18 39->26 40->1 40->1 40->38 40->38 40->41 40->44 41->1 41->1 41->38 41->38 42->1 43->1 44->1 44->11 44->35 44->41 44->41
>>>Token main ( ) { int hxwrwfoyzhyb , x , y , pd , pg , ncases , cases , sol , p ; double ikpfyoygwhtf , d ; for ( scanf ( " " , & ncases ) , cases = 1 ; cases <= ncases ; cases ++ ) { scanf ( " " , & hxwrwfoyzhyb , & pd , & pg ) ; sol = 0 ; for ( x = 100000 ; x > 0 && sol == 0 ; x -- ) { for ( y = min ( x , hxwrwfoyzhyb ) ; y > 0 && sol == 0 ; y -- ) { ikpfyoygwhtf = y * ( pd / 100.0 ) ; p = y - ikpfyoygwhtf ; if ( ikpfyoygwhtf == ( int ) ikpfyoygwhtf ) { d = x * ( pg / 100.0 ) ; if ( d == ( int ) d ) { if ( ( int ) d >= ( int ) ikpfyoygwhtf && x - d >= p ) { sol ++ ; } } } } } spwbkzlpconn ( " " , cases ) ; if ( sol == 0 ) spwbkzlpconn ( " \n " ) ; else spwbkzlpconn ( " \n " ) ; } return 0 ; }
>>>Func
METHOD dajrxzwkrhva
METHOD_RETURN double
PARAM int saxuooxggeak
<operator>.assignment pocanjmrhuge=0.0
<operator>.assignment xwccgbsozcfu=0
RETURN return (double)(pocanjmrhuge/(double)xwccgbsozcfu); return (double)(pocanjmrhuge/(double)xwccgbsozcfu);
<operator>.lessThan rlehekqzwdym<n
<operator>.preIncrement ++rlehekqzwdym
<operator>.cast (double)(pocanjmrhuge/(double)xwccgbsozcfu)
<operator>.assignment rlehekqzwdym=0
<operator>.notEquals -1!=Points[saxuooxggeak][rlehekqzwdym]
<operator>.division pocanjmrhuge/(double)xwccgbsozcfu
<operator>.assignmentPlus pocanjmrhuge+=CalculateOWP(rlehekqzwdym)
<operator>.postIncrement xwccgbsozcfu++
<operator>.cast (double)xwccgbsozcfu
<operator>.minus -1
CalculateOWP CalculateOWP(rlehekqzwdym)
<operator>.indirectIndexAccess Points[saxuooxggeak][rlehekqzwdym]
<operator>.indirectIndexAccess Points[saxuooxggeak]
>>>PDG&19 0->2 0->3 0->4 0->6 0->7 0->9 0->11 0->12 0->13 0->14 0->15 0->16 2->1 3->1 3->11 3->12 4->1 4->11 4->13 4->14 5->1 6->1 6->1 6->1 6->6 6->7 6->7 6->10 6->15 6->16 6->17 6->18 7->1 7->6 8->1 8->1 8->5 9->1 9->6 10->1 10->1 10->1 10->12 10->13 10->16 11->1 11->1 11->8 11->8 12->1 12->1 12->11 13->1 13->11 13->14 14->1 15->10 16->7 16->12
>>>Token double dajrxzwkrhva ( int saxuooxggeak ) { int rlehekqzwdym ; double pocanjmrhuge = 0.0 ; int xwccgbsozcfu = 0 ; for ( rlehekqzwdym = 0 ; rlehekqzwdym < n ; ++ rlehekqzwdym ) { if ( -1 != Points [ saxuooxggeak ] [ rlehekqzwdym ] ) { pocanjmrhuge += CalculateOWP ( rlehekqzwdym ) ; xwccgbsozcfu ++ ; } } return ( double ) ( pocanjmrhuge / ( double ) xwccgbsozcfu ) ; }
>>>Func
METHOD iecnjbbppyly
METHOD_RETURN int
PARAM const schdkczchsyc*p1
PARAM const schdkczchsyc*p2
<operator>.assignment *o1=(comb_pair *)p1
<operator>.assignment *o2=(comb_pair *)p2
pzchrjypfdgi pzchrjypfdgi(o1->first<o2->first)
RETURN return  -1; return  -1;
<operator>.minus -1
<operator>.cast (comb_pair *)p1
<operator>.cast (comb_pair *)p2
<operator>.lessThan o1->first<o2->first
>>>PDG&12 0->2 0->3 0->4 0->5 0->8 0->9 0->10 2->4 2->9 3->5 3->10 4->1 4->1 4->1 5->1 5->1 5->1 6->1 6->1 7->1 8->1 8->7 9->1 10->1 11->1 11->1 11->6 11->6
>>>Token int iecnjbbppyly ( const schdkczchsyc * p1 , const schdkczchsyc * p2 ) { comb_pair * o1 = ( comb_pair * ) p1 ; comb_pair * o2 = ( comb_pair * ) p2 ; pzchrjypfdgi ( o1 -> first < o2 -> first )  return -1 ; pzchrjypfdgi ( o1 -> first > o2 -> first )  return 1 ; pzchrjypfdgi ( o1 -> second < o2 -> second )  return -1 ; else pzchrjypfdgi ( o1 - > second = = o2 - > second )  return 0 ; return 1 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int jjukbuqldzix
PARAM char *argv [ ]
<operator>.assignment anwpazkpyzic=0
printf printf("Sum is: %d\n",anwpazkpyzic)
RETURN return 0; return 0;
<operator>.lessThan mtwvaedwxwzm<argv[1][0]
<operator>.postIncrement mtwvaedwxwzm++
<operator>.lessThan mtwvaedwxwzm<argv[1][0]
<operator>.postIncrement mtwvaedwxwzm++
LITERAL 0 return 0;
<operator>.assignment mtwvaedwxwzm=0
<operator>.assignmentPlus anwpazkpyzic+=mtwvaedwxwzm
<operator>.assignment mtwvaedwxwzm=0
<operator>.assignmentPlus anwpazkpyzic+=mtwvaedwxwzm
<operator>.indirectIndexAccess argv[1][0]
<operator>.indirectIndexAccess argv[1][0]
<operator>.indirectIndexAccess argv[1]
<operator>.indirectIndexAccess argv[1]
>>>PDG&20 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->1 3->1 4->1 4->5 4->13 4->15 5->1 5->1 6->1 7->7 7->8 7->8 7->9 7->13 7->13 7->16 7->18 8->1 8->7 9->1 9->1 9->1 9->9 9->10 9->10 9->15 9->15 9->17 9->19 10->1 10->9 11->6 12->7 13->1 13->5 13->15 14->1 14->9 15->1 15->5
>>>Token int main ( int jjukbuqldzix , char * argv [ ] ) { int mtwvaedwxwzm ; int anwpazkpyzic = 0 ; for ( mtwvaedwxwzm = 0 ; mtwvaedwxwzm < argv [ 1 ] [ 0 ] ; mtwvaedwxwzm ++ ) { anwpazkpyzic += mtwvaedwxwzm ; } for ( mtwvaedwxwzm = 0 ; mtwvaedwxwzm < argv [ 1 ] [ 0 ] ; mtwvaedwxwzm ++ ) { anwpazkpyzic += mtwvaedwxwzm ; } printf ( " \n " , anwpazkpyzic ) ; return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
<operator>.assignment inp=fopen("inp.txt","r")
<operator>.assignment out=fopen("out.txt","w")
scanf scanf("%d",&dfhlskbnkmtg)
<operator>.logicalAnd inp!=NULL&&out!=NULL
fopen fopen("inp.txt","r")
fopen fopen("out.txt","w")
fscanf fscanf(inp,"%d",&gndsapcmhmrp)
<operator>.assignment r=gndsapcmhmrp
fclose fclose(inp)
fclose fclose(out)
<operator>.notEquals inp!=NULL
<operator>.notEquals out!=NULL
IDENTIFIER r while (r)
<operator>.assignment bqtfdkyuznvj=0
fscanf fscanf(inp,"%d",&dfhlskbnkmtg)
fscanf fscanf(inp,"%d",&D)
fscanf fscanf(inp,"%d",&G)
printf printf("\n")
ruvzwwpvqals ruvzwwpvqals(out,"Case #")
ruvzwwpvqals ruvzwwpvqals(out,"%d",gndsapcmhmrp-r+1)
ruvzwwpvqals ruvzwwpvqals(out,": ")
<operator>.postDecrement r--
<operator>.logicalOr (G==0&&D!=0)||(G==100&&D!=100)
IDENTIFIER bqtfdkyuznvj if (bqtfdkyuznvj)
<operator>.assignment bqtfdkyuznvj=0
<operator>.addition gndsapcmhmrp-r+1
ruvzwwpvqals ruvzwwpvqals(out,"Possible\n")
<operator>.logicalAnd G==0&&D!=0
<operator>.logicalAnd G==100&&D!=100
<operator>.subtraction gndsapcmhmrp-r
ruvzwwpvqals ruvzwwpvqals (out,"Broken\n")
<operator>.equals G==0
<operator>.notEquals D!=0
<operator>.equals G==100
<operator>.notEquals D!=100
<operator>.lessThan i<dfhlskbnkmtg
<operator>.postIncrement i++
<operator>.assignment i=0
printf printf("%d " (dfhlskbnkmtg-i)*D)
<operator>.equals ((dfhlskbnkmtg-i)*D)%100==0
<operator>.multiplication (dfhlskbnkmtg-i)*D
<operator>.assignment bqtfdkyuznvj=1
<operator>.subtraction dfhlskbnkmtg-i
<operator>.modulo ((dfhlskbnkmtg-i)*D)%100
<operator>.multiplication (dfhlskbnkmtg-i)*D
<operator>.subtraction dfhlskbnkmtg-i
<operator>.addressOf &gndsapcmhmrp
<operator>.addressOf &dfhlskbnkmtg
<operator>.addressOf &D
<operator>.addressOf &G
>>>PDG&52 0->4 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->28 0->31 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 2->1 2->1 2->12 3->1 3->1 3->1 3->11 3->13 3->20 4->1 5->1 5->1 5->1 5->8 5->9 5->10 5->11 5->15 5->16 5->17 5->18 5->19 5->20 5->21 5->22 5->23 5->24 5->27 5->28 5->29 5->31 5->32 5->33 5->48 5->49 5->50 5->51 6->2 6->2 7->3 7->3 8->1 8->1 8->9 8->10 8->16 8->31 9->1 9->1 9->1 9->31 10->1 10->1 11->1 11->1 12->1 12->1 12->5 12->5 12->8 12->13 12->13 13->1 13->1 13->5 13->5 13->11 13->20 15->1 15->1 16->1 16->4 16->17 16->37 16->44 16->47 17->1 17->1 17->18 17->34 17->36 17->42 17->46 18->1 18->1 18->10 18->16 18->33 18->35 19->1 20->1 20->21 21->1 21->1 21->22 22->1 22->28 22->32 23->1 23->1 23->31 24->1 24->1 24->1 24->26 24->37 24->39 26->1 26->1 27->1 28->1 28->11 28->20 29->1 29->1 29->24 29->24 29->30 29->35 30->1 30->1 30->24 30->24 31->1 31->21 31->21 31->23 31->27 31->27 32->1 32->11 32->20 33->1 33->18 33->29 33->29 33->34 33->35 34->1 34->17 34->29 34->29 34->36 34->42 35->1 35->18 35->30 35->30 35->33 35->36 36->1 36->17 36->30 36->30 36->34 36->42 37->1 37->1 37->1 37->4 37->16 37->37 37->38 37->40 37->41 37->42 37->44 37->44 37->44 37->45 37->46 37->47 38->1 38->37 39->1 39->37 40->1 41->1 41->1 41->43 42->40 42->40 42->46 43->1 43->1 44->42 44->42 44->47 44->47 45->1 45->41 45->41 46->1 46->1 46->17 46->34 46->36 46->42 46->45 46->45 47->37 47->38 47->46 47->46
>>>Token int main ( ) { FILE * inp ; FILE * out ; inp = fopen ( " " , " " ) ; out = fopen ( " " , " " ) ; int dfhlskbnkmtg , D , G ; int gndsapcmhmrp , r ; int bqtfdkyuznvj , i , w ; if ( inp != NULL && out != NULL ) { fscanf ( inp , " " , & gndsapcmhmrp ) ; r = gndsapcmhmrp ; while ( r ) { bqtfdkyuznvj = 0 ; fscanf ( inp , " " , & dfhlskbnkmtg ) ; fscanf ( inp , " " , & D ) ; fscanf ( inp , " " , & G ) ; if ( ( G == 0 && D != 0 ) || ( G == 100 && D != 100 ) ) bqtfdkyuznvj = 0 ; else { for ( i = 0 ; i < dfhlskbnkmtg ; i ++ ) { printf ( " " , ( dfhlskbnkmtg - i ) * D ) ; if ( ( ( dfhlskbnkmtg - i ) * D ) % 100 == 0 ) bqtfdkyuznvj = 1 ; } } printf ( " \n " ) ; ruvzwwpvqals ( out , " " ) ; ruvzwwpvqals ( out , " " , gndsapcmhmrp - r + 1 ) ; ruvzwwpvqals ( out , " " ) ; if ( bqtfdkyuznvj ) ruvzwwpvqals ( out , " \n " ) ; else ruvzwwpvqals ( out , " \n " ) ; r -- ; } fclose ( inp ) ; fclose ( out ) ; } scanf ( " " , & dfhlskbnkmtg ) ; }
>>>Func
METHOD ttxjdrogemhd
METHOD_RETURN void
PARAM double lzgiwzpbxxos
PARAM double szvugrymdsti
PARAM double *r
PARAM double *theta
<operator>.assignment hyoesghsoods=0.f
<operator>.assignment *r=sqrt(lzgiwzpbxxos *lzgiwzpbxxos+szvugrymdsti *szvugrymdsti)
pdzboerxucfp pdzboerxucfp(lzgiwzpbxxos!=0)
BLOCK <empty> <empty>
pdzboerxucfp pdzboerxucfp(szvugrymdsti==0)
BLOCK <empty> <empty>
<operator>.assignment *theta=hyoesghsoods
pdzboerxucfp pdzboerxucfp(szvugrymdsti!=0)
BLOCK <empty> <empty>
pdzboerxucfp pdzboerxucfp(lzgiwzpbxxos>0)
BLOCK <empty> <empty>
sqrt sqrt(lzgiwzpbxxos *lzgiwzpbxxos+szvugrymdsti *szvugrymdsti)
<operator>.notEquals lzgiwzpbxxos!=0
<operator>.assignment *theta=atan(szvugrymdsti/lzgiwzpbxxos)
pdzboerxucfp pdzboerxucfp((lzgiwzpbxxos>0&&szvugrymdsti>0)||(lzgiwzpbxxos==-szvugrymdsti))
BLOCK <empty> <empty>
<operator>.equals szvugrymdsti==0
<operator>.assignment hyoesghsoods=0
<operator>.addition lzgiwzpbxxos *lzgiwzpbxxos+szvugrymdsti *szvugrymdsti
<operator>.notEquals szvugrymdsti!=0
<operator>.assignment hyoesghsoods=*theta
<operator>.greaterThan lzgiwzpbxxos>0
<operator>.multiplication lzgiwzpbxxos *lzgiwzpbxxos
<operator>.multiplication szvugrymdsti *szvugrymdsti
atan atan(szvugrymdsti/lzgiwzpbxxos)
<operator>.logicalOr (lzgiwzpbxxos>0&&szvugrymdsti>0)||(lzgiwzpbxxos==-szvugrymdsti)
<operator>.division szvugrymdsti/lzgiwzpbxxos
<operator>.logicalAnd lzgiwzpbxxos>0&&szvugrymdsti>0
<operator>.equals lzgiwzpbxxos==-szvugrymdsti
<operator>.greaterThan lzgiwzpbxxos>0
<operator>.greaterThan szvugrymdsti>0
<operator>.minus -szvugrymdsti
>>>PDG&38 0->2 0->3 0->4 0->5 0->6 0->9 0->11 0->12 0->14 0->16 0->18 0->21 0->22 0->23 0->25 0->27 0->28 0->29 0->32 0->34 0->35 0->36 0->37 2->28 3->29 4->1 5->1 6->1 7->1 7->1 7->1 8->1 8->1 10->1 10->1 12->1 12->1 12->1 13->1 13->1 15->1 15->1 17->1 17->7 18->8 18->8 18->32 19->1 19->1 19->26 20->1 20->1 22->1 22->10 22->10 23->1 23->12 24->1 24->1 25->13 25->13 25->32 26->1 27->1 27->15 27->15 28->17 28->18 28->24 29->17 29->24 29->25 30->1 30->19 31->1 31->1 31->20 31->20 32->22 32->30 32->30 32->35 32->36 32->37 33->1 33->31 33->31 33->34 33->37 34->1 34->27 34->31 34->31 35->27 35->33 35->33 35->34 35->36 36->22 36->33 36->33 36->37 37->22 37->34
>>>Token void ttxjdrogemhd ( double lzgiwzpbxxos , double szvugrymdsti , double * r , double * theta ) { double hyoesghsoods = 0.f ; * r = sqrt ( lzgiwzpbxxos * lzgiwzpbxxos + szvugrymdsti * szvugrymdsti ) ; pdzboerxucfp ( lzgiwzpbxxos != 0 )  { pdzboerxucfp ( szvugrymdsti != 0 ) { * theta = atan ( szvugrymdsti / lzgiwzpbxxos ) ; pdzboerxucfp ( ( lzgiwzpbxxos > 0 && szvugrymdsti > 0 ) || ( lzgiwzpbxxos == - szvugrymdsti ) )  { hyoesghsoods = * theta ; } else pdzboerxucfp ( lzgiwzpbxxos < 0 && szvugrymdsti > 0 ) { hyoesghsoods = * theta + M_PI ; } else pdzboerxucfp ( lzgiwzpbxxos < 0 && szvugrymdsti < 0 ) { hyoesghsoods = * theta - M_PI ; } else pdzboerxucfp ( lzgiwzpbxxos > 0 && szvugrymdsti < 0 ) { hyoesghsoods = 2 * M_PI - * theta ; } else  { fprintf ( stderr , " \n " ) ; } } } else  { pdzboerxucfp ( szvugrymdsti > 0 )  { hyoesghsoods = M_PI / 2 ; } else  { hyoesghsoods = - ( M_PI / 2 ) ; } } pdzboerxucfp ( szvugrymdsti == 0 )  { pdzboerxucfp ( lzgiwzpbxxos > 0 )  { hyoesghsoods = 0 ; } else  { hyoesghsoods = - M_PI ; } } * theta = hyoesghsoods ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
freopen freopen("in.small","r",stdin)
<operator>.assignment gznlwksdziac=0
scanf scanf("%d\n",&cdwmhhgiivjv)
RETURN return 0; return 0;
<operator>.lessThan gznlwksdziac<cdwmhhgiivjv
LITERAL 0 return 0;
printf printf("Case #%d: \n",++gznlwksdziac)
scanf scanf("%d\n",&vwjaqxkjsfsc)
<operator>.lessThan wbudhjkylcbj<vwjaqxkjsfsc
<operator>.postIncrement wbudhjkylcbj++
<operator>.lessThan wbudhjkylcbj<vwjaqxkjsfsc
<operator>.postIncrement wbudhjkylcbj++
<operator>.lessThan wbudhjkylcbj<vwjaqxkjsfsc
<operator>.postIncrement wbudhjkylcbj++
<operator>.lessThan wbudhjkylcbj<vwjaqxkjsfsc
<operator>.postIncrement wbudhjkylcbj++
<operator>.preIncrement ++gznlwksdziac
<operator>.assignment wbudhjkylcbj=0
<operator>.assignment ufhvhkaabsnl=0
<operator>.assignment snjkehkfjinz=0
getchar getchar()
<operator>.assignment kanmidkfuemd[wbudhjkylcbj][WP]=ufhvhkaabsnl/snjkehkfjinz
<operator>.assignment wbudhjkylcbj=0
<operator>.assignment snjkehkfjinz=0
<operator>.assignment hpxfdelwaobt=0
<operator>.assignment kanmidkfuemd[wbudhjkylcbj][OWP]=hpxfdelwaobt/snjkehkfjinz
<operator>.assignment wbudhjkylcbj=0
<operator>.assignment ewgyjyiepwaj=0
<operator>.assignment snjkehkfjinz=0
<operator>.assignment kanmidkfuemd[wbudhjkylcbj][OOWP]=ewgyjyiepwaj/snjkehkfjinz
<operator>.assignment wbudhjkylcbj=0
<operator>.assignment vabtxfuctqet=(0.25 *kanmidkfuemd[wbudhjkylcbj][WP])+(0.5 *kanmidkfuemd[wbudhjkylcbj][OWP])+(0.25 *kanmidkfuemd[wbudhjkylcbj][OOWP])
printf printf("%0.12g\n",vabtxfuctqet)
<operator>.lessThan zoiftewplrfs<vwjaqxkjsfsc
<operator>.postIncrement zoiftewplrfs++
<operator>.lessThan zoiftewplrfs<vwjaqxkjsfsc
<operator>.postIncrement zoiftewplrfs++
<operator>.lessThan zoiftewplrfs<vwjaqxkjsfsc
<operator>.postIncrement zoiftewplrfs++
<operator>.assignment zoiftewplrfs=0
<operator>.assignment baqbgkyweell=getchar()
<operator>.division ufhvhkaabsnl/snjkehkfjinz
<operator>.assignment zoiftewplrfs=0
<operator>.division hpxfdelwaobt/snjkehkfjinz
<operator>.assignment zoiftewplrfs=0
<operator>.division ewgyjyiepwaj/snjkehkfjinz
<operator>.addition (0.25 *kanmidkfuemd[wbudhjkylcbj][WP])+(0.5 *kanmidkfuemd[wbudhjkylcbj][OWP])+(0.25 *kanmidkfuemd[wbudhjkylcbj][OOWP])
<operator>.equals baqbgkyweell=='.'
<operator>.notEquals rirvbttazogm[wbudhjkylcbj][zoiftewplrfs]!=NOGAME
<operator>.notEquals rirvbttazogm[wbudhjkylcbj][zoiftewplrfs]!=NOGAME
<operator>.addition (0.25 *kanmidkfuemd[wbudhjkylcbj][WP])+(0.5 *kanmidkfuemd[wbudhjkylcbj][OWP])
<operator>.multiplication 0.25 *kanmidkfuemd[wbudhjkylcbj][OOWP]
<operator>.assignment rirvbttazogm[wbudhjkylcbj][zoiftewplrfs]=NOGAME
<operator>.assignment bcqyqrqpxnme=0
<operator>.assignment cyjfjypnhkor=0
<operator>.postIncrement snjkehkfjinz++
<operator>.assignmentPlus hpxfdelwaobt+=(double)bcqyqrqpxnme/cyjfjypnhkor
<operator>.assignmentPlus ewgyjyiepwaj+=kanmidkfuemd[zoiftewplrfs][OWP]
<operator>.postIncrement snjkehkfjinz++
<operator>.multiplication 0.25 *kanmidkfuemd[wbudhjkylcbj][WP]
<operator>.multiplication 0.5 *kanmidkfuemd[wbudhjkylcbj][OWP]
<operator>.assignmentMinus baqbgkyweell-='0'
<operator>.assignment rirvbttazogm[wbudhjkylcbj][zoiftewplrfs]=baqbgkyweell
<operator>.postIncrement snjkehkfjinz++
<operator>.assignmentPlus ufhvhkaabsnl+=baqbgkyweell
<operator>.lessThan jlwglsjwrzvf<vwjaqxkjsfsc
<operator>.postIncrement jlwglsjwrzvf++
<operator>.assignment jlwglsjwrzvf=0
<operator>.division (double)bcqyqrqpxnme/cyjfjypnhkor
<operator>.equals jlwglsjwrzvf==wbudhjkylcbj
<operator>.notEquals rirvbttazogm[zoiftewplrfs][jlwglsjwrzvf]!=NOGAME
<operator>.cast (double)bcqyqrqpxnme
<operator>.assignmentPlus bcqyqrqpxnme+=rirvbttazogm[zoiftewplrfs][jlwglsjwrzvf]
<operator>.postIncrement cyjfjypnhkor++
<operator>.addressOf &vwjaqxkjsfsc
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj][WP]
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj][OWP]
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj][OOWP]
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj]
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj]
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj]
getchar getchar()
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj][OOWP]
<operator>.indirectIndexAccess rirvbttazogm[wbudhjkylcbj][zoiftewplrfs]
<operator>.indirectIndexAccess rirvbttazogm[wbudhjkylcbj][zoiftewplrfs]
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj][WP]
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj][OWP]
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj]
<operator>.indirectIndexAccess rirvbttazogm[wbudhjkylcbj][zoiftewplrfs]
<operator>.indirectIndexAccess rirvbttazogm[wbudhjkylcbj]
<operator>.indirectIndexAccess rirvbttazogm[wbudhjkylcbj]
<operator>.indirectIndexAccess kanmidkfuemd[zoiftewplrfs][OWP]
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj]
<operator>.indirectIndexAccess kanmidkfuemd[wbudhjkylcbj]
<operator>.indirectIndexAccess rirvbttazogm[wbudhjkylcbj]
<operator>.indirectIndexAccess rirvbttazogm[wbudhjkylcbj][zoiftewplrfs]
<operator>.indirectIndexAccess kanmidkfuemd[zoiftewplrfs]
<operator>.indirectIndexAccess rirvbttazogm[wbudhjkylcbj]
UNKNOWN double double
<operator>.indirectIndexAccess rirvbttazogm[zoiftewplrfs][jlwglsjwrzvf]
<operator>.indirectIndexAccess rirvbttazogm[zoiftewplrfs]
<operator>.indirectIndexAccess rirvbttazogm[zoiftewplrfs][jlwglsjwrzvf]
<operator>.indirectIndexAccess rirvbttazogm[zoiftewplrfs]
>>>PDG&106 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->25 0->26 0->27 0->29 0->30 0->31 0->33 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->62 0->63 0->64 0->65 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 2->1 3->1 3->1 4->1 4->7 5->1 5->7 6->1 7->1 7->1 7->1 7->7 7->9 7->10 7->11 7->13 7->15 7->17 7->19 7->19 7->20 7->25 7->29 7->33 7->77 8->6 9->1 9->1 10->1 10->11 10->13 10->15 10->17 10->36 10->38 10->40 10->68 11->11 11->12 11->12 11->13 11->21 11->22 11->23 11->24 11->36 11->36 11->42 11->44 11->78 11->81 12->1 12->11 13->13 13->14 13->14 13->15 13->26 13->27 13->28 13->38 13->38 13->45 13->46 13->72 13->79 13->82 14->1 14->13 15->15 15->16 15->16 15->17 15->30 15->31 15->32 15->40 15->40 15->47 15->48 15->80 15->83 16->1 16->15 17->1 17->1 17->1 17->10 17->11 17->17 17->18 17->18 17->34 17->35 17->49 17->53 17->54 17->62 17->63 17->85 17->88 17->89 17->90 17->95 17->96 18->1 18->17 19->7 19->9 20->11 21->1 21->44 21->67 22->1 22->44 22->66 23->1 24->1 24->1 24->1 24->62 25->13 26->1 26->46 26->58 27->1 27->46 27->59 28->1 28->1 28->1 28->63 29->15 30->1 30->48 30->60 31->1 31->48 31->61 32->1 32->1 32->1 32->54 33->1 33->17 34->1 34->1 34->35 35->1 35->1 36->1 36->1 36->11 36->36 36->37 36->37 36->43 36->50 36->84 37->1 37->36 38->1 38->1 38->13 38->38 38->39 38->39 38->51 38->68 38->86 38->92 39->1 39->38 40->1 40->1 40->15 40->40 40->41 40->41 40->52 40->87 40->93 41->1 41->40 42->1 42->36 43->1 43->50 44->1 44->1 44->24 44->24 45->1 45->38 46->1 46->1 46->28 46->28 47->1 47->40 48->1 48->1 48->32 48->32 49->1 49->1 50->1 50->1 50->55 50->64 50->64 50->65 50->66 50->67 50->91 50->97 50->98 50->100 51->1 51->1 51->1 51->52 51->52 51->55 51->56 51->57 51->58 51->59 51->68 51->70 51->71 51->73 51->74 51->101 52->1 52->1 52->1 52->51 52->51 52->55 52->60 52->61 52->94 52->99 53->1 53->1 54->1 54->34 54->34 54->49 54->49 55->1 55->1 55->1 55->51 55->52 56->1 56->71 56->74 56->75 57->1 57->71 57->76 58->1 58->46 59->1 59->1 59->46 60->1 60->1 60->48 61->1 61->48 62->1 62->34 62->34 62->49 62->49 62->53 62->53 63->1 63->34 63->34 63->49 63->49 63->53 63->53 64->1 64->65 64->67 65->1 65->1 65->51 65->52 66->1 66->44 67->1 67->1 67->44 68->1 68->1 68->38 68->68 68->69 68->72 68->72 69->1 69->68 70->1 70->68 71->1 71->1 71->59 71->59 72->1 72->14 72->69 72->73 72->102 72->103 73->1 73->1 73->1 73->51 73->52 73->55 73->75 73->75 73->76 73->104 73->105 74->1 75->1 75->1 75->71 75->74 76->1 76->71
>>>Token int main ( void ) { freopen ( " " , " " , stdin ) ; int gznlwksdziac = 0 ; int cdwmhhgiivjv ; scanf ( " \n " , & cdwmhhgiivjv ) ; while ( gznlwksdziac < cdwmhhgiivjv ) { int vwjaqxkjsfsc ; int wbudhjkylcbj ; int zoiftewplrfs ; char rirvbttazogm [ N ] [ N ] ; double kanmidkfuemd [ N ] [ 3 ] ; printf ( " \n " , ++ gznlwksdziac ) ; scanf ( " \n " , & vwjaqxkjsfsc ) ; for ( wbudhjkylcbj = 0 ; wbudhjkylcbj < vwjaqxkjsfsc ; wbudhjkylcbj ++ ) { double ufhvhkaabsnl = 0 ; int snjkehkfjinz = 0 ; for ( zoiftewplrfs = 0 ; zoiftewplrfs < vwjaqxkjsfsc ; zoiftewplrfs ++ ) { char baqbgkyweell = getchar ( ) ; if ( baqbgkyweell == ' ' ) { rirvbttazogm [ wbudhjkylcbj ] [ zoiftewplrfs ] = NOGAME ; } else { baqbgkyweell -= ' ' ; rirvbttazogm [ wbudhjkylcbj ] [ zoiftewplrfs ] = baqbgkyweell ; snjkehkfjinz ++ ; ufhvhkaabsnl += baqbgkyweell ; } } getchar ( ) ; kanmidkfuemd [ wbudhjkylcbj ] [ WP ] = ufhvhkaabsnl / snjkehkfjinz ; } for ( wbudhjkylcbj = 0 ; wbudhjkylcbj < vwjaqxkjsfsc ; wbudhjkylcbj ++ ) { int snjkehkfjinz = 0 ; double hpxfdelwaobt = 0 ; for ( zoiftewplrfs = 0 ; zoiftewplrfs < vwjaqxkjsfsc ; zoiftewplrfs ++ ) { if ( rirvbttazogm [ wbudhjkylcbj ] [ zoiftewplrfs ] != NOGAME ) { int jlwglsjwrzvf ; int bcqyqrqpxnme = 0 ; int cyjfjypnhkor = 0 ; snjkehkfjinz ++ ; for ( jlwglsjwrzvf = 0 ; jlwglsjwrzvf < vwjaqxkjsfsc ; jlwglsjwrzvf ++ ) { if ( jlwglsjwrzvf == wbudhjkylcbj ) continue ; if ( rirvbttazogm [ zoiftewplrfs ] [ jlwglsjwrzvf ] != NOGAME ) { bcqyqrqpxnme += rirvbttazogm [ zoiftewplrfs ] [ jlwglsjwrzvf ] ; cyjfjypnhkor ++ ; } } hpxfdelwaobt += ( double ) bcqyqrqpxnme / cyjfjypnhkor ; } } kanmidkfuemd [ wbudhjkylcbj ] [ OWP ] = hpxfdelwaobt / snjkehkfjinz ; } for ( wbudhjkylcbj = 0 ; wbudhjkylcbj < vwjaqxkjsfsc ; wbudhjkylcbj ++ ) { double ewgyjyiepwaj = 0 ; int snjkehkfjinz = 0 ; for ( zoiftewplrfs = 0 ; zoiftewplrfs < vwjaqxkjsfsc ; zoiftewplrfs ++ ) { if ( rirvbttazogm [ wbudhjkylcbj ] [ zoiftewplrfs ] != NOGAME ) { ewgyjyiepwaj += kanmidkfuemd [ zoiftewplrfs ] [ OWP ] ; snjkehkfjinz ++ ; } } kanmidkfuemd [ wbudhjkylcbj ] [ OOWP ] = ewgyjyiepwaj / snjkehkfjinz ; } for ( wbudhjkylcbj = 0 ; wbudhjkylcbj < vwjaqxkjsfsc ; wbudhjkylcbj ++ ) { double vabtxfuctqet = ( 0.25 * kanmidkfuemd [ wbudhjkylcbj ] [ WP ] ) + ( 0.5 * kanmidkfuemd [ wbudhjkylcbj ] [ OWP ] ) + ( 0.25 * kanmidkfuemd [ wbudhjkylcbj ] [ OOWP ] ) ; printf ( " \n " , vabtxfuctqet ) ; } } return 0 ; }
>>>Func
METHOD hnmzgcggrhol
METHOD_RETURN void
PARAM char **texte
PARAM int beeqoxiorkga
<operator>.assignment tab_combine=malloc(26 *26 *sizeof(void *))
<operator>.lessThan kylppynzuobr<26 *26
<operator>.postIncrement kylppynzuobr++
<operator>.assignment tab_combine[kylppynzuobr]=NULL
<operator>.lessThan kylppynzuobr<beeqoxiorkga
<operator>.postIncrement kylppynzuobr++
malloc malloc(26 *26 *sizeof(void *))
<operator>.assignment kylppynzuobr=0
<operator>.assignment kylppynzuobr=0
<operator>.assignment *t=texte[kylppynzuobr]
<operator>.assignment hhqpjznjptiq=t[0]-'A'
<operator>.assignment nnyhkkqvdtfa=t[1]-'A'
<operator>.assignment *res=construit_char(t[2])
<operator>.assignment tab_combine[hhqpjznjptiq *26+nnyhkkqvdtfa]=res
<operator>.assignment tab_combine[nnyhkkqvdtfa *26+hhqpjznjptiq]=res
<operator>.multiplication 26 *26 *sizeof(void *)
<operator>.multiplication 26 *26
<operator>.multiplication 26 *26
<operator>.sizeOf sizeof(void *)
<operator>.subtraction t[0]-'A'
<operator>.subtraction t[1]-'A'
construit_char construit_char(t[2])
<operator>.addition hhqpjznjptiq *26+nnyhkkqvdtfa
<operator>.addition nnyhkkqvdtfa *26+hhqpjznjptiq
<operator>.multiplication hhqpjznjptiq *26
<operator>.multiplication nnyhkkqvdtfa *26
<operator>.indirectIndexAccess tab_combine[kylppynzuobr]
<operator>.indirectIndexAccess texte[kylppynzuobr]
<operator>.indirectIndexAccess tab_combine[hhqpjznjptiq *26+nnyhkkqvdtfa]
<operator>.indirectIndexAccess tab_combine[nnyhkkqvdtfa *26+hhqpjznjptiq]
<operator>.indirectIndexAccess t[0]
<operator>.indirectIndexAccess t[1]
<operator>.indirectIndexAccess t[2]
>>>PDG&37 0->2 0->3 0->5 0->6 0->7 0->8 0->9 0->11 0->12 0->17 0->18 0->20 0->21 0->23 0->24 0->26 0->27 0->28 0->29 2->1 2->13 3->8 4->1 4->1 4->1 5->1 5->1 5->5 5->6 5->6 5->7 5->20 5->30 6->1 6->5 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->13 8->14 8->15 8->16 8->17 8->18 8->23 8->24 8->25 8->26 8->27 8->28 8->29 8->31 8->32 8->33 8->34 8->35 8->36 9->1 9->8 10->1 10->4 11->5 12->1 12->8 13->23 13->24 13->25 14->28 15->26 15->29 16->17 16->18 19->10 20->5 21->19 22->1 23->14 23->14 24->15 24->15 25->16 28->26 28->26 28->27 29->27 29->27
>>>Token void hnmzgcggrhol ( char * * texte , int beeqoxiorkga ) { tab_combine = malloc ( 26 * 26 * sizeof ( void * ) ) ; int kylppynzuobr ; for ( kylppynzuobr = 0 ; kylppynzuobr < 26 * 26 ; kylppynzuobr ++ ) tab_combine [ kylppynzuobr ] = NULL ; for ( kylppynzuobr = 0 ; kylppynzuobr < beeqoxiorkga ; kylppynzuobr ++ ) { char * t = texte [ kylppynzuobr ] ; int hhqpjznjptiq = t [ 0 ] - ' ' ; int nnyhkkqvdtfa = t [ 1 ] - ' ' ; void * res = construit_char ( t [ 2 ] ) ; tab_combine [ hhqpjznjptiq * 26 + nnyhkkqvdtfa ] = res ; tab_combine [ nnyhkkqvdtfa * 26 + hhqpjznjptiq ] = res ; } }
>>>Func
METHOD nkkwyowojsavget_space
METHOD_RETURN ANY
PARAM FILE *f
PARAM nkkwyowojsav zjtgywzmzqwr
IDENTIFIER true while (true)
qkrhwhevcicy qkrhwhevcicy(zjtgywzmzqwr=='')
<operator>.postIncrement in_column++
<operator>.assignment zjtgywzmzqwr=getc(f)
<operator>.equals zjtgywzmzqwr==''
getc getc(f)
>>>PDG&10 0->2 0->3 0->4 0->6 0->8 0->9 2->1 2->9 3->1 3->8 6->1 8->5 8->5 9->7
>>>Token static nkkwyowojsavget_space ( FILE *  f , nkkwyowojsav zjtgywzmzqwr ) { while ( true ) { qkrhwhevcicy ( zjtgywzmzqwr == ' ' in_column ++  ; else qkrhwhevcicy ( zjtgywzmzqwr == ' t ' ) { tabs = true ; in_column = ( in_column / TABWIDTH + 1 ) * TABWIDTH ; } else dnqvhwlvljon  zjtgywzmzqwr ; zjtgywzmzqwr = getc ( f ) ; } }
>>>Func
METHOD arjvspgtcsos
METHOD_RETURN int
PARAM point mtzuhyawowgu
PARAM point sjjxkyqlgoqp
RETURN return zrynhsjdmmxl; return zrynhsjdmmxl;
<operator>.notEquals mtzuhyawowgu.x/2!=sjjxkyqlgoqp.x/2
<operator>.notEquals mtzuhyawowgu.y/2!=sjjxkyqlgoqp.y/2
IDENTIFIER zrynhsjdmmxl return zrynhsjdmmxl;
RETURN return nmlatxodzrcg; return nmlatxodzrcg;
RETURN return nmlatxodzrcg; return nmlatxodzrcg;
<operator>.division mtzuhyawowgu.x/2
<operator>.division sjjxkyqlgoqp.x/2
IDENTIFIER nmlatxodzrcg return nmlatxodzrcg;
<operator>.division mtzuhyawowgu.y/2
<operator>.division sjjxkyqlgoqp.y/2
IDENTIFIER nmlatxodzrcg return nmlatxodzrcg;
<operator>.fieldAccess mtzuhyawowgu.y
<operator>.fieldAccess sjjxkyqlgoqp.y
FIELD_IDENTIFIER y y
FIELD_IDENTIFIER y y
>>>PDG&20 0->2 0->3 0->4 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 2->1 2->10 2->13 3->1 3->11 3->14 4->1 5->1 5->1 5->1 5->6 5->8 5->13 5->14 5->16 5->17 5->18 5->19 6->4 6->9 7->4 8->1 9->1 10->1 10->5 10->5 11->1 11->5 11->5 12->8 13->6 13->6 14->6 14->6 15->9
>>>Token int arjvspgtcsos ( point mtzuhyawowgu , point sjjxkyqlgoqp ) { if ( mtzuhyawowgu . x / 2 != sjjxkyqlgoqp . x / 2 ) { return nmlatxodzrcg ; } if ( mtzuhyawowgu . y / 2 != sjjxkyqlgoqp . y / 2 ) { return nmlatxodzrcg ; } return zrynhsjdmmxl ; }
>>>Func
METHOD lxdcrmakusnm
METHOD_RETURN void
<operator>.lessThan jgijnnlpenfc<N
<operator>.postIncrement jgijnnlpenfc++
<operator>.assignment wp[jgijnnlpenfc]=1.f *game_won[jgijnnlpenfc]/game_played[jgijnnlpenfc]
<operator>.assignment jgijnnlpenfc=0
<operator>.division 1.f *game_won[jgijnnlpenfc]/game_played[jgijnnlpenfc]
<operator>.multiplication 1.f *game_won[jgijnnlpenfc]
<operator>.indirectIndexAccess wp[jgijnnlpenfc]
<operator>.indirectIndexAccess game_played[jgijnnlpenfc]
<operator>.indirectIndexAccess game_won[jgijnnlpenfc]
>>>PDG&11 0->2 0->3 0->5 0->7 2->1 2->1 2->1 2->2 2->3 2->3 2->4 2->6 2->7 2->8 2->9 2->10 3->1 3->2 4->1 4->1 4->1 5->1 5->2 6->1 6->1 6->4 6->4 7->1 7->6 7->6
>>>Token void lxdcrmakusnm ( ) { int jgijnnlpenfc ; for ( jgijnnlpenfc = 0 ; jgijnnlpenfc < N ; jgijnnlpenfc ++ ) wp [ jgijnnlpenfc ] = 1.f * game_won [ jgijnnlpenfc ] / game_played [ jgijnnlpenfc ] ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int hqshkownnwin
PARAM char *argv [ ]
<operator>.assignment qjinlmzhnnvm[len]={5 8 10 14 16}
<operator>.assignment jkupficnukxf=binarySearch(qjinlmzhnnvm,len,5)
RETURN return 0; return 0;
<operator>.lessThan jkupficnukxf<0
LITERAL 0 return 0;
<operator>.arrayInitializer {5 8 10 14 16}
binarySearch binarySearch(qjinlmzhnnvm,len,5)
printf printf("The number %d doesnt exist in array\n",5)
printf printf("The number %d exist in array at position : %d \n",5,jkupficnukxf)
>>>PDG&13 0->2 0->3 0->6 0->7 0->8 0->9 0->10 0->11 0->12 2->1 3->1 4->1 4->1 4->10 5->1 5->1 5->7 6->1 7->1 7->1 7->11 7->12 7->12 8->6 9->4 9->4 9->4 9->4 9->4 10->1 10->1 10->5 10->5 10->5 11->1 12->1 12->1
>>>Token int main ( int hqshkownnwin , char * argv [ ] ) { int qjinlmzhnnvm [ len ] = { 5 , 8 , 10 , 14 , 16 } ; int jkupficnukxf ; jkupficnukxf = binarySearch ( qjinlmzhnnvm , len , 5 ) ; if ( jkupficnukxf < 0 ) printf ( " \n " , 5 ) ; else { printf ( " \n " , 5 , jkupficnukxf ) ; } return 0 ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM void
<operator>.assignment in=fopen("input.txt","rt")
<operator>.assignment out=fopen("output.txt","wt")
fgets fgets(input,400,in)
<operator>.assignment T=atoi(input)
fclose fclose(in)
fclose fclose(out)
RETURN return 0; return 0;
<operator>.lessEqualsThan t<=T
<operator>.postIncrement t++
LITERAL 0 return 0;
fopen fopen("input.txt","rt")
fopen fopen("output.txt","wt")
atoi atoi(input)
<operator>.assignment t=1
fgets fgets(input,400,in)
<operator>.assignment j=0
<operator>.assignment k=0
<operator>.assignment brjstthonaqs[j]='\0'
<operator>.assignment C=atoi(brjstthonaqs)
<operator>.postIncrement k++
<operator>.assignment j=0
<operator>.assignment brjstthonaqs[j]='\0'
<operator>.assignment D=atoi(brjstthonaqs)
<operator>.postIncrement k++
<operator>.assignment j=0
<operator>.assignment brjstthonaqs[j]='\0'
<operator>.assignment N=atoi(brjstthonaqs)
<operator>.postIncrement k++
<operator>.assignment res[0]=inv[0]
<operator>.assignment prev=0
<operator>.assignment vyizevkwarjn=1
fprintf fprintf(out,"Case #%d: [",t)
fprintf fprintf(out,"]\n")
<operator>.notEquals input[k]!=''
<operator>.lessThan wtprvpxxexeb<128
<operator>.postIncrement wtprvpxxexeb++
<operator>.lessThan j<C
<operator>.postIncrement j++
<operator>.notEquals input[k]!=''
<operator>.lessThan wtprvpxxexeb<128
<operator>.postIncrement wtprvpxxexeb++
<operator>.lessThan j<D
<operator>.postIncrement j++
<operator>.notEquals input[k]!=''
<operator>.lessThan j<N
<operator>.expressionList j++ k++
<operator>.assignment inv[j]=input[k]
<operator>.lessThan k<N
<operator>.postIncrement k++
IDENTIFIER vyizevkwarjn if (vyizevkwarjn)
<operator>.assignment brjstthonaqs[j]=input[k]
<operator>.postIncrement j++
<operator>.postIncrement k++
atoi atoi(brjstthonaqs)
<operator>.assignment wtprvpxxexeb=0
<operator>.lessThan j<128
<operator>.postIncrement j++
<operator>.assignment com[wtprvpxxexeb][j]='\0'
<operator>.assignment j=0
<operator>.assignment com[input[k]][input[k+1]]=input[k+2]
<operator>.assignment com[input[k+1]][input[k]]=input[k+2]
<operator>.assignmentPlus k+=4
<operator>.assignment brjstthonaqs[j]=input[k]
<operator>.postIncrement j++
<operator>.postIncrement k++
atoi atoi(brjstthonaqs)
<operator>.assignment wtprvpxxexeb=0
<operator>.lessThan j<128
<operator>.postIncrement j++
<operator>.assignment opp[wtprvpxxexeb][j]=0
<operator>.assignment j=0
<operator>.assignment opp[input[k]][input[k+1]]=1
<operator>.assignment opp[input[k+1]][input[k]]=1
<operator>.assignmentPlus k+=3
<operator>.assignment brjstthonaqs[j]=input[k]
<operator>.postIncrement j++
<operator>.postIncrement k++
atoi atoi(brjstthonaqs)
<operator>.assignment j=0
<operator>.assignment k=1
<operator>.notEquals com[res[prev]][inv[k]]!='\0'
fprintf fprintf(out,"%c",res[0])
<operator>.assignment j=0
<operator>.assignment j=0
<operator>.postIncrement j++
<operator>.postIncrement k++
<operator>.assignment res[prev]=com[res[prev]][inv[k]]
<operator>.lessThan k<vyizevkwarjn
<operator>.postIncrement k++
fprintf fprintf(out,", %c",res[k])
<operator>.assignment res[vyizevkwarjn]=inv[k]
<operator>.postIncrement prev++
<operator>.postIncrement vyizevkwarjn++
<operator>.assignment k=1
<operator>.addition k+2
<operator>.addition k+2
<operator>.lessThan j<prev
<operator>.postIncrement j++
<operator>.addition k+1
<operator>.addition k+1
<operator>.assignment j=0
<operator>.addition k+1
<operator>.addition k+1
<operator>.postIncrement k++
<operator>.lessThan k<N
<operator>.assignment res[0]=inv[k]
<operator>.assignment prev=0
<operator>.assignment vyizevkwarjn=1
<operator>.assignment vyizevkwarjn=0
<operator>.indirectIndexAccess brjstthonaqs[j]
<operator>.indirectIndexAccess brjstthonaqs[j]
<operator>.indirectIndexAccess brjstthonaqs[j]
<operator>.indirectIndexAccess res[0]
<operator>.indirectIndexAccess inv[0]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess inv[j]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess brjstthonaqs[j]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess com[wtprvpxxexeb][j]
<operator>.indirectIndexAccess com[input[k]][input[k+1]]
<operator>.indirectIndexAccess input[k+2]
<operator>.indirectIndexAccess com[input[k+1]][input[k]]
<operator>.indirectIndexAccess input[k+2]
<operator>.indirectIndexAccess brjstthonaqs[j]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess opp[wtprvpxxexeb][j]
<operator>.indirectIndexAccess opp[input[k]][input[k+1]]
<operator>.indirectIndexAccess opp[input[k+1]][input[k]]
<operator>.indirectIndexAccess brjstthonaqs[j]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess com[res[prev]][inv[k]]
<operator>.indirectIndexAccess res[0]
<operator>.indirectIndexAccess com[wtprvpxxexeb]
<operator>.indirectIndexAccess com[input[k]]
<operator>.indirectIndexAccess input[k+1]
<operator>.indirectIndexAccess com[input[k+1]]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess opp[wtprvpxxexeb]
<operator>.indirectIndexAccess opp[input[k]]
<operator>.indirectIndexAccess input[k+1]
<operator>.indirectIndexAccess opp[input[k+1]]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess com[res[prev]]
<operator>.indirectIndexAccess inv[k]
<operator>.indirectIndexAccess res[prev]
<operator>.indirectIndexAccess com[res[prev]][inv[k]]
<operator>.indirectIndexAccess res[k]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess input[k+1]
<operator>.indirectIndexAccess input[k]
<operator>.indirectIndexAccess input[k+1]
<operator>.indirectIndexAccess res[prev]
<operator>.indirectIndexAccess com[res[prev]]
<operator>.indirectIndexAccess inv[k]
<operator>.indirectIndexAccess res[vyizevkwarjn]
<operator>.indirectIndexAccess inv[k]
<operator>.indirectIndexAccess res[prev]
<operator>.indirectIndexAccess opp[res[j]][res[prev]]
<operator>.indirectIndexAccess opp[res[j]]
<operator>.indirectIndexAccess res[prev]
<operator>.indirectIndexAccess res[j]
<operator>.indirectIndexAccess res[0]
<operator>.indirectIndexAccess inv[k]
>>>PDG&169 0->2 0->5 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->14 0->15 0->16 0->17 0->18 0->19 0->20 0->22 0->23 0->24 0->26 0->27 0->28 0->30 0->32 0->33 0->34 0->35 0->36 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->50 0->51 0->52 0->54 0->55 0->56 0->57 0->58 0->59 0->60 0->61 0->64 0->66 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->90 0->91 0->92 0->94 0->95 0->96 0->97 0->98 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->106 0->107 0->109 0->110 0->111 2->1 3->1 3->1 3->5 4->1 4->1 4->8 4->34 5->1 5->7 5->15 5->17 6->1 6->1 6->10 7->1 7->1 8->1 8->1 9->1 10->1 10->1 10->1 10->10 10->11 10->17 10->18 10->19 10->20 10->21 10->22 10->23 10->24 10->25 10->26 10->27 10->28 10->29 10->30 10->31 10->32 10->33 10->34 10->34 10->35 10->36 10->37 10->39 10->41 10->42 10->44 10->46 10->47 10->50 10->56 10->57 10->61 10->68 10->69 10->73 10->80 10->81 10->82 10->84 10->90 10->96 10->112 10->113 10->114 10->115 10->116 10->117 10->118 10->119 10->137 11->1 11->10 12->9 13->3 13->3 14->4 14->4 15->1 15->6 15->17 16->1 16->10 17->1 17->1 17->7 17->36 17->41 17->46 17->49 17->53 17->62 17->63 17->65 17->77 18->54 19->1 19->22 19->55 20->56 21->1 21->39 22->26 22->64 22->67 22->97 22->98 22->101 22->104 23->66 24->68 25->1 25->44 26->30 26->76 26->79 26->102 26->105 27->78 28->1 28->1 28->80 29->1 29->1 29->47 30->1 30->88 31->1 31->1 31->1 31->84 32->1 32->1 32->94 33->1 33->1 33->90 33->95 34->1 34->11 34->35 34->84 35->1 35->8 35->34 36->36 36->41 36->53 36->53 36->54 36->55 36->117 36->122 36->123 37->37 37->38 37->38 37->58 37->85 38->1 38->37 39->1 39->1 39->39 39->40 39->40 39->62 39->63 39->64 39->97 39->98 39->101 39->104 39->125 39->126 39->127 39->128 39->139 39->140 39->141 39->142 39->153 39->154 40->1 40->39 41->41 41->46 41->65 41->65 41->66 41->67 41->118 41->129 41->130 42->1 42->1 42->42 42->43 42->43 42->70 42->86 43->1 43->42 44->1 44->1 44->44 44->45 44->45 44->74 44->75 44->76 44->102 44->105 44->132 44->133 44->144 44->145 44->146 44->147 44->155 44->156 45->1 45->44 46->1 46->1 46->17 46->36 46->46 46->49 46->77 46->77 46->78 46->79 46->119 46->134 46->135 47->1 47->1 47->47 47->48 47->49 47->50 47->87 47->87 47->88 47->120 47->121 48->1 48->1 48->1 49->1 49->1 49->1 50->1 50->1 50->1 50->50 50->51 50->51 50->83 50->106 50->107 50->136 50->148 50->149 50->157 51->1 51->50 53->1 54->1 55->22 56->21 56->68 57->37 58->1 58->58 58->59 58->59 58->60 58->124 58->138 59->1 59->58 60->1 60->1 61->39 62->1 62->1 63->1 63->1 63->1 64->1 64->26 64->67 64->97 64->98 64->101 64->104 65->1 66->1 67->26 68->25 68->80 69->1 69->42 70->1 70->70 70->71 70->71 70->72 70->131 70->143 71->1 71->70 72->1 72->1 73->44 74->1 74->1 75->1 75->1 76->1 76->30 76->79 76->102 76->105 77->1 78->1 79->30 80->1 80->29 80->56 81->1 81->47 82->1 82->50 83->1 83->1 83->89 83->89 83->93 83->94 83->95 83->99 83->103 83->150 83->151 83->158 83->159 83->160 83->161 83->162 84->1 84->1 84->35 84->92 85->58 86->70 87->47 87->48 88->48 89->1 89->1 89->1 90->1 90->1 90->1 90->90 90->91 90->91 90->92 90->152 91->1 91->90 92->1 92->1 92->35 93->1 93->1 93->1 94->1 94->99 95->1 95->1 95->90 96->1 96->90 99->1 99->1 99->1 99->94 99->100 99->163 99->164 99->165 99->166 100->1 100->99 103->1 103->99 106->107 107->50 107->51 107->108 107->109 107->110 107->111 107->167 107->168 108->1 108->1 108->1 108->84 109->1 109->1 109->94 110->1 110->1 110->90 110->95 111->1 111->1 111->90 111->95 163->99 163->100 163->106 163->107
>>>Token int main ( void ) { char brjstthonaqs [ 4 ] , input [ 400 ] , com [ 128 ] [ 128 ] , inv [ 100 ] , res [ 100 ] ; int wtprvpxxexeb , j , k , t , T , C , D , N , opp [ 128 ] [ 128 ] , prev , vyizevkwarjn ; FILE * in , * out ; in = fopen ( " " , " " ) ; out = fopen ( " " , " " ) ; fgets ( input , 400 , in ) ; T = atoi ( input ) ; for ( t = 1 ; t <= T ; t ++ ) { fgets ( input , 400 , in ) ; j = 0 ; k = 0 ; while ( input [ k ] != ' ' ) { brjstthonaqs [ j ] = input [ k ] ; j ++ ; k ++ ; } brjstthonaqs [ j ] = ' \0 ' ; C = atoi ( brjstthonaqs ) ; k ++ ; for ( wtprvpxxexeb = 0 ; wtprvpxxexeb < 128 ; wtprvpxxexeb ++ ) for ( j = 0 ; j < 128 ; j ++ ) com [ wtprvpxxexeb ] [ j ] = ' \0 ' ; for ( j = 0 ; j < C ; j ++ ) { com [ input [ k ] ] [ input [ k + 1 ] ] = input [ k + 2 ] ; com [ input [ k + 1 ] ] [ input [ k ] ] = input [ k + 2 ] ; k += 4 ; } j = 0 ; while ( input [ k ] != ' ' ) { brjstthonaqs [ j ] = input [ k ] ; j ++ ; k ++ ; } brjstthonaqs [ j ] = ' \0 ' ; D = atoi ( brjstthonaqs ) ; k ++ ; for ( wtprvpxxexeb = 0 ; wtprvpxxexeb < 128 ; wtprvpxxexeb ++ ) for ( j = 0 ; j < 128 ; j ++ ) opp [ wtprvpxxexeb ] [ j ] = 0 ; for ( j = 0 ; j < D ; j ++ ) { opp [ input [ k ] ] [ input [ k + 1 ] ] = 1 ; opp [ input [ k + 1 ] ] [ input [ k ] ] = 1 ; k += 3 ; } j = 0 ; while ( input [ k ] != ' ' ) { brjstthonaqs [ j ] = input [ k ] ; j ++ ; k ++ ; } brjstthonaqs [ j ] = ' \0 ' ; N = atoi ( brjstthonaqs ) ; k ++ ; for ( j = 0 ; j < N ; j ++ , k ++ ) inv [ j ] = input [ k ] ; res [ 0 ] = inv [ 0 ] ; prev = 0 ; vyizevkwarjn = 1 ; for ( k = 1 ; k < N ; k ++ ) if ( com [ res [ prev ] ] [ inv [ k ] ] != ' \0 ' ) res [ prev ] = com [ res [ prev ] ] [ inv [ k ] ] ; else { res [ vyizevkwarjn ] = inv [ k ] ; prev ++ ; vyizevkwarjn ++ ; for ( j = 0 ; j < prev ; j ++ ) if ( opp [ res [ j ] ] [ res [ prev ] ] ) { k ++ ; if ( k < N ) { res [ 0 ] = inv [ k ] ; prev = 0 ; vyizevkwarjn = 1 ; } else vyizevkwarjn = 0 ; break ; } } fprintf ( out , " " , t ) ; if ( vyizevkwarjn ) { fprintf ( out , " " , res [ 0 ] ) ; for ( k = 1 ; k < vyizevkwarjn ; k ++ ) fprintf ( out , " " , res [ k ] ) ; } fprintf ( out , " \n " ) ; } fclose ( in ) ; fclose ( out ) ; return 0 ; }
>>>Func
METHOD int_to_string
METHOD_RETURN char*
PARAM uint16_t ksnbhgqhpnmx
PARAM zfliujrfmrsp *ezarutqwdkhs
PARAM int afhoecojtfeg
<operator>.assignment zfliujrfmrsphex_table [ ]={'0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 'a' 'b' 'c' 'd' 'e' 'f'}
<operator>.assignment fqfqramyuzgw=0
<operator>.assignment ezarutqwdkhs[fqfqramyuzgw]='\0'
RETURN return ezarutqwdkhs; return ezarutqwdkhs;
<operator>.notEquals ksnbhgqhpnmx!=0
<operator>.lessThan kgbbgoprodqk<limit
<operator>.preIncrement ++kgbbgoprodqk
IDENTIFIER ezarutqwdkhs return ezarutqwdkhs;
<operator>.arrayInitializer {'0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 'a' 'b' 'c' 'd' 'e' 'f'}
<operator>.assignment ezarutqwdkhs[fqfqramyuzgw++]=hex_table[ksnbhgqhpnmx%afhoecojtfeg]
<operator>.assignmentDivision ksnbhgqhpnmx/=afhoecojtfeg
<operator>.assignment kgbbgoprodqk=0
<operator>.assignment limit=fqfqramyuzgw/2
<operator>.assignment inubfimfmtqt=ezarutqwdkhs[kgbbgoprodqk]
<operator>.assignment ezarutqwdkhs[kgbbgoprodqk]=ezarutqwdkhs[fqfqramyuzgw-1-kgbbgoprodqk]
<operator>.assignment ezarutqwdkhs[fqfqramyuzgw-1-kgbbgoprodqk]=inubfimfmtqt
<operator>.division fqfqramyuzgw/2
<operator>.postIncrement fqfqramyuzgw++
<operator>.modulo ksnbhgqhpnmx%afhoecojtfeg
<operator>.subtraction fqfqramyuzgw-1-kgbbgoprodqk
<operator>.subtraction fqfqramyuzgw-1-kgbbgoprodqk
<operator>.subtraction fqfqramyuzgw-1
<operator>.subtraction fqfqramyuzgw-1
<operator>.indirectIndexAccess ezarutqwdkhs[fqfqramyuzgw++]
<operator>.indirectIndexAccess hex_table[ksnbhgqhpnmx%afhoecojtfeg]
<operator>.indirectIndexAccess ezarutqwdkhs[kgbbgoprodqk]
<operator>.indirectIndexAccess ezarutqwdkhs[kgbbgoprodqk]
<operator>.indirectIndexAccess ezarutqwdkhs[fqfqramyuzgw-1-kgbbgoprodqk]
<operator>.indirectIndexAccess ezarutqwdkhs[fqfqramyuzgw-1-kgbbgoprodqk]
>>>PDG&34 0->2 0->3 0->4 0->6 0->7 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 2->23 3->1 3->12 3->18 3->19 4->23 5->1 5->1 5->1 6->1 6->22 7->1 7->1 7->12 8->1 9->1 9->1 9->9 9->14 9->15 9->22 9->23 9->23 9->28 9->29 10->1 10->1 10->1 10->10 10->11 10->18 10->19 10->20 10->24 10->24 10->25 10->26 10->27 10->30 10->31 10->32 10->33 11->1 11->10 12->8 13->5 13->5 13->5 13->5 13->5 13->5 13->5 13->5 13->5 13->5 13->5 13->5 13->5 13->5 13->5 13->5 14->1 14->1 14->1 14->12 15->1 15->1 15->9 16->1 16->10 17->1 17->1 17->10 18->1 18->20 19->1 19->1 19->12 19->18 20->1 20->1 20->1 20->12 20->19 21->1 21->17 21->17 21->26 22->21 23->15 23->15 24->25 25->1 25->11 26->24 26->24 26->27 27->1 27->25 27->25 27->26
>>>Token char * int_to_string ( uint16_t ksnbhgqhpnmx , zfliujrfmrsp * ezarutqwdkhs , int afhoecojtfeg ) { const zfliujrfmrsphex_table  [ ] = { ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' } ; int fqfqramyuzgw = 0 ; do { ezarutqwdkhs [ fqfqramyuzgw ++ ] = hex_table [ ksnbhgqhpnmx % afhoecojtfeg ] ; ksnbhgqhpnmx /= afhoecojtfeg ; } while ( ksnbhgqhpnmx != 0 ) ; for ( int kgbbgoprodqk = 0 , limit = fqfqramyuzgw / 2 ; kgbbgoprodqk < limit ; ++ kgbbgoprodqk ) { zfliujrfmrsp inubfimfmtqt = ezarutqwdkhs [ kgbbgoprodqk ] ; ezarutqwdkhs [ kgbbgoprodqk ] = ezarutqwdkhs [ fqfqramyuzgw - 1 - kgbbgoprodqk ] ; ezarutqwdkhs [ fqfqramyuzgw - 1 - kgbbgoprodqk ] = inubfimfmtqt ; } ezarutqwdkhs [ fqfqramyuzgw ] = ' \0 ' ; return ezarutqwdkhs ; }
>>>Func
METHOD tkcgrcijgjni
METHOD_RETURN void
PARAM int *x
PARAM int *y
PARAM int *z
PARAM int *a
<operator>.assignment p=qnfkeednambv
<operator>.assignment *x=strtoul(p,&p,10)
<operator>.postIncrement p++
<operator>.assignment *y=strtoul(p,&p,10)
<operator>.postIncrement p++
<operator>.assignment *z=strtoul(p,&p,10)
<operator>.postIncrement p++
<operator>.assignment *a=strtoul(p,&p,10)
<operator>.logicalNot !fgets(qnfkeednambv,1000,stdin)
perror perror("fgets")
exit exit(-1)
strtoul strtoul(p,&p,10)
strtoul strtoul(p,&p,10)
strtoul strtoul(p,&p,10)
strtoul strtoul(p,&p,10)
fgets fgets(qnfkeednambv,1000,stdin)
<operator>.minus -1
>>>PDG&23 0->2 0->3 0->4 0->5 0->6 0->8 0->10 0->12 0->15 0->17 0->18 0->19 0->20 0->21 0->22 2->1 3->1 4->1 5->1 6->1 6->1 6->17 7->1 7->1 8->18 9->1 9->1 10->19 11->1 11->1 12->1 12->20 13->1 13->1 13->1 14->1 14->1 14->15 14->16 14->22 15->1 16->1 17->7 17->7 17->7 17->8 17->8 17->18 18->9 18->9 18->9 18->10 18->10 18->19 19->11 19->11 19->11 19->12 19->12 19->20 20->1 20->1 20->13 20->13 20->13 21->1 21->6 21->14 21->14 21->14 22->16
>>>Token void tkcgrcijgjni ( int * x , int * y , int * z , int * a ) { char qnfkeednambv [ 1000 ] ; char * p ; if ( ! fgets ( qnfkeednambv , 1000 , stdin ) ) { perror ( " " ) ; exit ( -1 ) ; } p = qnfkeednambv ; * x = strtoul ( p , & p , 10 ) ; p ++ ; * y = strtoul ( p , & p , 10 ) ; p ++ ; * z = strtoul ( p , & p , 10 ) ; p ++ ; * a = strtoul ( p , & p , 10 ) ; }
>>>Func
METHOD main
METHOD_RETURN int
PARAM int ixecqvajcecx
PARAM char *argv [ ]
<operator>.assignment red=(struct vysiktvyhgbn*)calloc(80 sizeof(reduce))
<operator>.assignment des=(struct ifajtyqhtqom*)calloc(80 sizeof(destroy))
fscanf fscanf(stdin,"%d\n",&czniuzhsbwdl)
RETURN return 0; return 0;
<operator>.lessThan tnaaxqpzzibx<czniuzhsbwdl
<operator>.postIncrement tnaaxqpzzibx++
LITERAL 0 return 0;
<operator>.cast (struct vysiktvyhgbn*)calloc(80 sizeof(reduce))
<operator>.cast (struct ifajtyqhtqom*)calloc(80 sizeof(destroy))
<operator>.assignment tnaaxqpzzibx=0
<operator>.assignment output=(char *)malloc(100 *sizeof(char))
<operator>.assignment output_sz=0
fscanf fscanf(stdin,"%d ",&red_sz)
<operator>.assignmentMultiplication red_sz *=2
fscanf fscanf(stdin,"%d ",&des_sz)
<operator>.assignmentMultiplication des_sz *=2
fscanf fscanf(stdin,"%d ",&counter)
bcpzgefvsngp bcpzgefvsngp("Case #%d: [",tnaaxqpzzibx+1)
calloc calloc(80 sizeof(reduce))
calloc calloc(80 sizeof(destroy))
<operator>.lessThan j<red_sz
<operator>.postIncrement j++
<operator>.lessThan j<des_sz
<operator>.postIncrement j++
<operator>.lessThan j<counter
<operator>.postIncrement j++
<operator>.lessThan j<output_sz-1
<operator>.postIncrement j++
bcpzgefvsngp bcpzgefvsngp("%c, ",output[j])
<operator>.notEquals output_sz!=0
<operator>.sizeOf sizeof(reduce)
<operator>.sizeOf sizeof(destroy)
<operator>.cast (char *)malloc(100 *sizeof(char))
<operator>.assignment j=0
fscanf fscanf(stdin,"%c",&xkusnxigcwts)
fscanf fscanf(stdin,"%c",&charB)
fscanf fscanf(stdin,"%c ",&Result)
<operator>.assignment red[2 *j].x=xkusnxigcwts
<operator>.assignment red[2 *j].y=charB
<operator>.assignment red[2 *j].result=Result
<operator>.assignment red[2 *j+1].x=charB
<operator>.assignment red[2 *j+1].y=xkusnxigcwts
<operator>.assignment red[2 *j+1].result=Result
<operator>.assignment j=0
fscanf fscanf(stdin,"%c",&xkusnxigcwts)
fscanf fscanf(stdin,"%c ",&charB)
<operator>.assignment des[2 *j].x=xkusnxigcwts
<operator>.assignment des[2 *j].y=charB
<operator>.assignment des[2 *j+1].x=charB
<operator>.assignment des[2 *j+1].y=xkusnxigcwts
<operator>.assignment j=0
fscanf fscanf(stdin,"%c",&Result)
<operator>.addition tnaaxqpzzibx+1
<operator>.assignment j=0
bcpzgefvsngp bcpzgefvsngp("%c]\n",output[output_sz-1])
malloc malloc(100 *sizeof(char))
<operator>.equals output_sz==0
<operator>.subtraction output_sz-1
bcpzgefvsngp bcpzgefvsngp ("]\n")
<operator>.multiplication 100 *sizeof(char)
<operator>.assignment output[0]=Result
<operator>.postIncrement output_sz++
<operator>.sizeOf sizeof(char)
<operator>.assignment bosoopknndbc=0
<operator>.subtraction output_sz-1
<operator>.multiplication 2 *j
<operator>.multiplication 2 *j
<operator>.multiplication 2 *j
<operator>.addition 2 *j+1
<operator>.addition 2 *j+1
<operator>.addition 2 *j+1
<operator>.multiplication 2 *j
<operator>.multiplication 2 *j
<operator>.addition 2 *j+1
<operator>.addition 2 *j+1
<operator>.lessThan k<red_sz
<operator>.postIncrement k++
<operator>.logicalNot !bosoopknndbc
<operator>.logicalNot !bosoopknndbc
<operator>.multiplication 2 *j
<operator>.multiplication 2 *j
<operator>.multiplication 2 *j
<operator>.multiplication 2 *j
<operator>.multiplication 2 *j
<operator>.assignment k=0
<operator>.assignment output[output_sz]=Result
<operator>.postIncrement output_sz++
<operator>.logicalAnd (red[k].x==Result)&&(red[k].y==output[output_sz-1])
<operator>.lessThan k<des_sz
<operator>.postIncrement k++
<operator>.assignment output[output_sz-1]=red[k].result
<operator>.assignment bosoopknndbc=1
<operator>.assignment k=0
<operator>.equals red[k].x==Result
<operator>.equals red[k].y==output[output_sz-1]
<operator>.equals des[k].x==Result
<operator>.subtraction output_sz-1
<operator>.subtraction output_sz-1
<operator>.lessThan l<output_sz
<operator>.postIncrement l++
IDENTIFIER bosoopknndbc if (bosoopknndbc)
<operator>.assignment l=0
<operator>.equals output[l]==des[k].y
<operator>.assignment output_sz=0
<operator>.assignment bosoopknndbc=1
<operator>.addressOf &red_sz
<operator>.addressOf &des_sz
<operator>.addressOf &counter
UNKNOWN char * char *
<operator>.indirectIndexAccess output[j]
<operator>.addressOf &xkusnxigcwts
<operator>.addressOf &charB
<operator>.addressOf &Result
<operator>.fieldAccess red[2 *j].x
<operator>.fieldAccess red[2 *j].y
<operator>.fieldAccess red[2 *j].result
<operator>.fieldAccess red[2 *j+1].x
<operator>.fieldAccess red[2 *j+1].y
<operator>.fieldAccess red[2 *j+1].result
<operator>.addressOf &xkusnxigcwts
<operator>.addressOf &charB
<operator>.fieldAccess des[2 *j].x
<operator>.fieldAccess des[2 *j].y
<operator>.fieldAccess des[2 *j+1].x
<operator>.fieldAccess des[2 *j+1].y
<operator>.addressOf &Result
<operator>.indirectIndexAccess output[output_sz-1]
<operator>.indirectIndexAccess red[2 *j]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess red[2 *j]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess red[2 *j]
FIELD_IDENTIFIER result result
<operator>.indirectIndexAccess red[2 *j+1]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess red[2 *j+1]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess red[2 *j+1]
FIELD_IDENTIFIER result result
<operator>.indirectIndexAccess des[2 *j]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess des[2 *j]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess des[2 *j+1]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess des[2 *j+1]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess output[0]
<operator>.indirectIndexAccess output[output_sz]
<operator>.fieldAccess red[k].x
<operator>.fieldAccess red[k].y
<operator>.indirectIndexAccess output[output_sz-1]
<operator>.indirectIndexAccess output[output_sz-1]
<operator>.fieldAccess red[k].result
<operator>.indirectIndexAccess red[k]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess red[k]
FIELD_IDENTIFIER y y
<operator>.indirectIndexAccess red[k]
FIELD_IDENTIFIER result result
<operator>.fieldAccess des[k].x
<operator>.indirectIndexAccess des[k]
FIELD_IDENTIFIER x x
<operator>.indirectIndexAccess output[l]
<operator>.fieldAccess des[k].y
<operator>.indirectIndexAccess des[k]
FIELD_IDENTIFIER y y
>>>PDG&171 0->2 0->3 0->4 0->5 0->6 0->7 0->8 0->9 0->10 0->11 0->12 0->13 0->15 0->16 0->17 0->18 0->19 0->20 0->21 0->22 0->23 0->24 0->25 0->26 0->27 0->28 0->29 0->30 0->31 0->32 0->33 0->37 0->38 0->39 0->40 0->41 0->42 0->43 0->44 0->45 0->46 0->47 0->48 0->49 0->50 0->51 0->52 0->53 0->54 0->55 0->56 0->57 0->58 0->60 0->61 0->62 0->63 0->64 0->65 0->67 0->68 0->69 0->70 0->71 0->72 0->73 0->74 0->75 0->76 0->77 0->78 0->79 0->80 0->81 0->82 0->83 0->84 0->85 0->86 0->87 0->88 0->89 0->90 0->92 0->93 0->95 0->96 0->97 0->99 0->100 0->101 0->102 0->103 0->104 0->105 0->107 0->108 2->1 3->1 4->1 4->1 4->1 5->1 5->1 5->1 6->1 6->1 6->1 6->8 6->16 7->1 8->1 8->1 8->1 8->8 8->9 8->9 8->14 8->15 8->16 8->17 8->18 8->19 8->20 8->21 8->21 8->24 8->26 8->28 8->30 8->33 8->36 8->37 8->47 8->54 8->56 8->56 8->57 8->59 8->61 8->63 8->66 8->109 8->110 8->111 8->112 9->1 9->8 10->7 11->1 12->1 13->1 13->8 14->1 14->1 14->1 14->32 14->58 14->98 14->106 15->1 15->60 15->61 16->1 16->1 16->17 16->18 16->24 16->38 16->79 17->1 17->1 17->16 17->24 17->79 18->1 18->1 18->19 18->20 18->26 18->48 18->92 19->1 19->1 19->18 19->26 19->92 20->1 20->1 20->1 20->16 20->28 20->55 21->1 21->1 24->1 24->17 24->24 24->25 24->38 24->39 24->40 24->41 24->42 24->43 24->44 24->45 24->46 24->69 24->69 24->70 24->71 24->72 24->73 24->74 24->83 24->84 24->85 24->114 24->115 24->116 24->117 24->118 24->119 24->120 24->121 24->122 24->131 24->132 24->133 24->134 24->135 24->136 24->137 24->138 24->139 24->140 24->141 24->142 25->1 25->24 26->1 26->19 26->26 26->27 26->48 26->49 26->50 26->51 26->52 26->53 26->75 26->75 26->76 26->77 26->78 26->86 26->87 26->123 26->124 26->125 26->126 26->127 26->128 26->143 26->144 26->145 26->146 26->147 26->148 26->149 26->150 27->1 27->26 28->1 28->1 28->20 28->28 28->29 28->29 28->55 28->60 28->129 29->1 29->28 30->1 30->1 30->1 30->30 30->31 30->31 30->32 30->61 30->113 31->1 31->30 32->1 32->1 33->1 33->1 33->58 33->62 33->68 33->68 33->130 34->1 35->1 36->1 37->24 38->1 38->1 38->39 38->41 38->45 38->48 38->50 38->53 39->1 39->1 39->40 39->42 39->44 39->49 39->51 39->52 40->1 40->1 40->18 40->38 40->43 40->46 40->55 40->64 40->89 40->97 40->99 41->1 42->1 43->1 44->1 44->1 45->1 45->1 46->1 46->1 47->26 48->1 48->1 48->38 48->41 48->49 48->50 48->53 49->1 49->1 49->20 49->39 49->42 49->48 49->51 49->52 50->1 51->1 52->1 52->1 53->1 53->1 54->28 55->1 55->1 55->1 55->16 55->40 55->43 55->64 55->89 55->97 55->99 57->1 57->30 58->1 58->1 58->98 59->1 59->14 59->36 60->1 60->61 60->64 60->65 60->65 60->67 60->79 60->81 60->82 60->88 60->90 60->100 60->101 60->102 60->151 61->30 61->30 61->33 62->1 63->59 64->1 64->1 64->1 65->1 65->60 65->61 66->1 67->1 67->81 68->1 69->70 70->71 71->83 74->1 75->76 76->86 78->1 79->1 79->1 79->1 79->16 79->24 79->80 79->91 79->97 79->153 79->158 79->159 80->1 80->79 81->82 81->92 81->96 82->1 82->1 82->89 82->90 82->152 83->72 83->72 83->84 84->73 84->73 84->85 85->25 85->74 85->74 86->77 86->77 86->87 87->27 87->78 87->78 88->1 88->79 89->1 89->1 89->1 90->1 90->60 90->61 91->1 91->1 91->1 91->79 91->80 91->94 91->95 91->101 91->156 91->157 91->162 91->163 92->1 92->1 92->1 92->18 92->26 92->93 92->99 92->164 92->165 92->166 93->1 93->92 94->1 94->1 94->1 94->58 94->98 95->1 95->81 96->1 96->92 97->1 97->1 97->40 97->43 97->55 97->64 97->89 97->91 97->91 97->98 97->99 97->100 97->154 97->155 97->160 97->161 98->1 98->1 98->58 98->91 98->91 99->1 99->1 99->1 99->40 99->43 99->55 99->64 99->89 99->92 99->93 99->97 99->102 99->105 100->60 100->61 100->90 100->101 100->102 101->60 101->61 101->90 101->102 102->1 102->1 102->60 102->61 102->90 102->103 102->106 102->167 102->168 102->169 102->170 103->1 103->102 105->1 105->102 106->1 106->1 106->1 106->102 106->103 106->107 106->108 107->1 107->60 107->61 107->90 107->102 108->1 108->82
>>>Token int main ( int ixecqvajcecx , char * argv [ ] ) { int tnaaxqpzzibx , j , k , l ; int bosoopknndbc ; int czniuzhsbwdl , counter , output_sz ; char xkusnxigcwts , charB , Result ; char * output ; red = ( struct vysiktvyhgbn * ) calloc ( 80 , sizeof ( reduce ) ) ; des = ( struct ifajtyqhtqom * ) calloc ( 80 , sizeof ( destroy ) ) ; fscanf ( stdin , " \n " , & czniuzhsbwdl ) ; for ( tnaaxqpzzibx = 0 ; tnaaxqpzzibx < czniuzhsbwdl ; tnaaxqpzzibx ++ ) { output = ( char * ) malloc ( 100 * sizeof ( char ) ) ; output_sz = 0 ; fscanf ( stdin , " " , & red_sz ) ; for ( j = 0 ; j < red_sz ; j ++ ) { fscanf ( stdin , " " , & xkusnxigcwts ) ; fscanf ( stdin , " " , & charB ) ; fscanf ( stdin , " " , & Result ) ; red [ 2 * j ] . x = xkusnxigcwts ; red [ 2 * j ] . y = charB ; red [ 2 * j ] . result = Result ; red [ 2 * j + 1 ] . x = charB ; red [ 2 * j + 1 ] . y = xkusnxigcwts ; red [ 2 * j + 1 ] . result = Result ; } red_sz *= 2 ; fscanf ( stdin , " " , & des_sz ) ; for ( j = 0 ; j < des_sz ; j ++ ) { fscanf ( stdin , " " , & xkusnxigcwts ) ; fscanf ( stdin , " " , & charB ) ; des [ 2 * j ] . x = xkusnxigcwts ; des [ 2 * j ] . y = charB ; des [ 2 * j + 1 ] . x = charB ; des [ 2 * j + 1 ] . y = xkusnxigcwts ; } des_sz *= 2 ; fscanf ( stdin , " " , & counter ) ; for ( j = 0 ; j < counter ; j ++ ) { fscanf ( stdin , " " , & Result ) ; if ( output_sz == 0 ) { output [ 0 ] = Result ; output_sz ++ ; } else { bosoopknndbc = 0 ; for ( k = 0 ; k < red_sz ; k ++ ) { if ( ( red [ k ] . x == Result ) && ( red [ k ] . y == output [ output_sz - 1 ] ) ) { output [ output_sz - 1 ] = red [ k ] . result ; bosoopknndbc = 1 ; break ; } } if ( ! bosoopknndbc ) { for ( k = 0 ; k < des_sz ; k ++ ) { if ( des [ k ] . x == Result ) { for ( l = 0 ; l < output_sz ; l ++ ) { if ( output [ l ] == des [ k ] . y ) { output_sz = 0 ; bosoopknndbc = 1 ; break ; } } if ( bosoopknndbc ) break ; } } } if ( ! bosoopknndbc ) { output [ output_sz ] = Result ; output_sz ++ ; } } } bcpzgefvsngp ( " " , tnaaxqpzzibx + 1 ) ; for ( j = 0 ; j < output_sz - 1 ; j ++ ) bcpzgefvsngp ( " " , output [ j ] ) ; if ( output_sz != 0 ) bcpzgefvsngp ( " \n " , output [ output_sz - 1 ] ) ; else bcpzgefvsngp ( " \n " ) ; } return 0 ; }
>>>Func
